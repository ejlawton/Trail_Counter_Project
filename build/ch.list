
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

08000200 <Reset_Handler>:
                .align  2
                .thumb_func
                .global Reset_Handler
Reset_Handler:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 8000200:	b672      	cpsid	i

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 8000202:	4826      	ldr	r0, [pc, #152]	; (800029c <endfiniloop+0x4>)
                msr     PSP, r0
 8000204:	f380 8809 	msr	PSP, r0

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 8000208:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 800020a:	f380 8814 	msr	CONTROL, r0
                isb
 800020e:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 8000212:	f000 f87d 	bl	8000310 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000216:	f00b fcb3 	bl	800bb80 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 800021a:	4821      	ldr	r0, [pc, #132]	; (80002a0 <endfiniloop+0x8>)
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 800021c:	4921      	ldr	r1, [pc, #132]	; (80002a4 <endfiniloop+0xc>)
                ldr     r2, =__main_stack_end__
 800021e:	4a22      	ldr	r2, [pc, #136]	; (80002a8 <endfiniloop+0x10>)

08000220 <msloop>:
msloop:
                cmp     r1, r2
 8000220:	4291      	cmp	r1, r2
                itt     lo
 8000222:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000224:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8000228:	f7ff bffa 	bcc.w	8000220 <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 800022c:	491f      	ldr	r1, [pc, #124]	; (80002ac <endfiniloop+0x14>)
                ldr     r2, =__process_stack_end__
 800022e:	4a1b      	ldr	r2, [pc, #108]	; (800029c <endfiniloop+0x4>)

08000230 <psloop>:
psloop:
                cmp     r1, r2
 8000230:	4291      	cmp	r1, r2
                itt     lo
 8000232:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000234:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 8000238:	f7ff bffa 	bcc.w	8000230 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 800023c:	491c      	ldr	r1, [pc, #112]	; (80002b0 <endfiniloop+0x18>)
                ldr     r2, =_data_start
 800023e:	4a1d      	ldr	r2, [pc, #116]	; (80002b4 <endfiniloop+0x1c>)
                ldr     r3, =_data_end
 8000240:	4b1d      	ldr	r3, [pc, #116]	; (80002b8 <endfiniloop+0x20>)

08000242 <dloop>:
dloop:
                cmp     r2, r3
 8000242:	429a      	cmp	r2, r3
                ittt    lo
 8000244:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000246:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 800024a:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 800024e:	f7ff bff8 	bcc.w	8000242 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000252:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
 8000254:	4919      	ldr	r1, [pc, #100]	; (80002bc <endfiniloop+0x24>)
                ldr     r2, =_bss_end
 8000256:	4a1a      	ldr	r2, [pc, #104]	; (80002c0 <endfiniloop+0x28>)

08000258 <bloop>:
bloop:
                cmp     r1, r2
 8000258:	4291      	cmp	r1, r2
                itt     lo
 800025a:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800025c:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8000260:	f7ff bffa 	bcc.w	8000258 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000264:	f000 f874 	bl	8000350 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000268:	f000 f862 	bl	8000330 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 800026c:	4c15      	ldr	r4, [pc, #84]	; (80002c4 <endfiniloop+0x2c>)
                ldr     r5, =__init_array_end
 800026e:	4d16      	ldr	r5, [pc, #88]	; (80002c8 <endfiniloop+0x30>)

08000270 <initloop>:
initloop:
                cmp     r4, r5
 8000270:	42ac      	cmp	r4, r5
                bge     endinitloop
 8000272:	f280 8005 	bge.w	8000280 <endinitloop>
                ldr     r1, [r4], #4
 8000276:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 800027a:	4788      	blx	r1
                b       initloop
 800027c:	f7ff bff8 	b.w	8000270 <initloop>

08000280 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000280:	f016 fb8e 	bl	80169a0 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 8000284:	4c11      	ldr	r4, [pc, #68]	; (80002cc <endfiniloop+0x34>)
                ldr     r5, =__fini_array_end
 8000286:	4d12      	ldr	r5, [pc, #72]	; (80002d0 <endfiniloop+0x38>)

08000288 <finiloop>:
finiloop:
                cmp     r4, r5
 8000288:	42ac      	cmp	r4, r5
                bge     endfiniloop
 800028a:	f280 8005 	bge.w	8000298 <endfiniloop>
                ldr     r1, [r4], #4
 800028e:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000292:	4788      	blx	r1
                b       finiloop
 8000294:	f7ff bff8 	b.w	8000288 <finiloop>

08000298 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 8000298:	f000 b852 	b.w	8000340 <__default_exit>
Reset_Handler:
                /* Interrupts are globally masked initially.*/
                cpsid   i

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 800029c:	20000800 	.word	0x20000800

                /* Early initialization.*/
                bl      __early_init

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 80002a0:	55555555 	.word	0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 80002a4:	20000000 	.word	0x20000000
                ldr     r2, =__main_stack_end__
 80002a8:	20000400 	.word	0x20000400
                blo     msloop

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 80002ac:	20000400 	.word	0x20000400
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 80002b0:	08019860 	.word	0x08019860
                ldr     r2, =_data_start
 80002b4:	20000800 	.word	0x20000800
                ldr     r3, =_data_end
 80002b8:	20000d44 	.word	0x20000d44

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
                ldr     r1, =_bss_start
 80002bc:	20000d48 	.word	0x20000d48
                ldr     r2, =_bss_end
 80002c0:	20002238 	.word	0x20002238
                /* Late initialization..*/
                bl      __late_init

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 80002c4:	08000200 	.word	0x08000200
                ldr     r5, =__init_array_end
 80002c8:	08000200 	.word	0x08000200
                /* Main program invocation, r0 contains the returned value.*/
                bl      main

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 80002cc:	08000200 	.word	0x08000200
                ldr     r5, =__fini_array_end
 80002d0:	08000200 	.word	0x08000200
	...

080002e0 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80002e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                vpush   {s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80002e4:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80002e8:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80002ea:	469d      	mov	sp, r3
#endif

#if CORTEX_USE_FPU
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80002ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002f0 <_port_thread_start>:
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80002f0:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80002f2:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80002f6:	4628      	mov	r0, r5
                blx     r4
 80002f8:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 80002fa:	2000      	movs	r0, #0
                bl      chThdExit
 80002fc:	f001 f838 	bl	8001370 <chThdExit>

08000300 <_port_switch_from_isr>:
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
 8000300:	f000 fdce 	bl	8000ea0 <chSchDoReschedule>

08000304 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 8000304:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 8000306:	e7fe      	b.n	8000306 <_port_exit_from_isr+0x2>
	...

08000310 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8000310:	4770      	bx	lr
 8000312:	bf00      	nop
 8000314:	f3af 8000 	nop.w
 8000318:	f3af 8000 	nop.w
 800031c:	f3af 8000 	nop.w
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __early_init(void) {}
 8000320:	4770      	bx	lr
 8000322:	bf00      	nop
 8000324:	f3af 8000 	nop.w
 8000328:	f3af 8000 	nop.w
 800032c:	f3af 8000 	nop.w

08000330 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8000330:	4770      	bx	lr
 8000332:	bf00      	nop
 8000334:	f3af 8000 	nop.w
 8000338:	f3af 8000 	nop.w
 800033c:	f3af 8000 	nop.w

08000340 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
  }
 8000340:	e7fe      	b.n	8000340 <__default_exit>
 8000342:	bf00      	nop
 8000344:	f3af 8000 	nop.w
 8000348:	f3af 8000 	nop.w
 800034c:	f3af 8000 	nop.w

08000350 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8000350:	b084      	sub	sp, #16
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8000352:	4b16      	ldr	r3, [pc, #88]	; (80003ac <__init_ram_areas+0x5c>)
 8000354:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 8000356:	9b03      	ldr	r3, [sp, #12]
 8000358:	681b      	ldr	r3, [r3, #0]
 800035a:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 800035c:	9b03      	ldr	r3, [sp, #12]
 800035e:	685b      	ldr	r3, [r3, #4]
 8000360:	9301      	str	r3, [sp, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000362:	e009      	b.n	8000378 <__init_ram_areas+0x28>
      *p = *tp;
 8000364:	9b02      	ldr	r3, [sp, #8]
 8000366:	681a      	ldr	r2, [r3, #0]
 8000368:	9b01      	ldr	r3, [sp, #4]
 800036a:	601a      	str	r2, [r3, #0]
      p++;
 800036c:	9b01      	ldr	r3, [sp, #4]
 800036e:	3304      	adds	r3, #4
 8000370:	9301      	str	r3, [sp, #4]
      tp++;
 8000372:	9b02      	ldr	r3, [sp, #8]
 8000374:	3304      	adds	r3, #4
 8000376:	9302      	str	r3, [sp, #8]
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000378:	9b03      	ldr	r3, [sp, #12]
 800037a:	689a      	ldr	r2, [r3, #8]
 800037c:	9b01      	ldr	r3, [sp, #4]
 800037e:	429a      	cmp	r2, r3
 8000380:	d8f0      	bhi.n	8000364 <__init_ram_areas+0x14>
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000382:	e005      	b.n	8000390 <__init_ram_areas+0x40>
      *p = 0;
 8000384:	9b01      	ldr	r3, [sp, #4]
 8000386:	2200      	movs	r2, #0
 8000388:	601a      	str	r2, [r3, #0]
      p++;
 800038a:	9b01      	ldr	r3, [sp, #4]
 800038c:	3304      	adds	r3, #4
 800038e:	9301      	str	r3, [sp, #4]
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000390:	9b03      	ldr	r3, [sp, #12]
 8000392:	68da      	ldr	r2, [r3, #12]
 8000394:	9b01      	ldr	r3, [sp, #4]
 8000396:	429a      	cmp	r2, r3
 8000398:	d8f4      	bhi.n	8000384 <__init_ram_areas+0x34>
      *p = 0;
      p++;
    }
    rap++;
 800039a:	9b03      	ldr	r3, [sp, #12]
 800039c:	3310      	adds	r3, #16
 800039e:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 80003a0:	9a03      	ldr	r2, [sp, #12]
 80003a2:	4b03      	ldr	r3, [pc, #12]	; (80003b0 <__init_ram_areas+0x60>)
 80003a4:	429a      	cmp	r2, r3
 80003a6:	d3d6      	bcc.n	8000356 <__init_ram_areas+0x6>
#endif
}
 80003a8:	b004      	add	sp, #16
 80003aa:	4770      	bx	lr
 80003ac:	08017760 	.word	0x08017760
 80003b0:	080177e0 	.word	0x080177e0
 80003b4:	f3af 8000 	nop.w
 80003b8:	f3af 8000 	nop.w
 80003bc:	f3af 8000 	nop.w

080003c0 <_unhandled_exception>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
/*lint -restore*/

  while (true) {
  }
 80003c0:	e7fe      	b.n	80003c0 <_unhandled_exception>
 80003c2:	bf00      	nop
 80003c4:	f3af 8000 	nop.w
 80003c8:	f3af 8000 	nop.w
 80003cc:	f3af 8000 	nop.w

080003d0 <NVIC_SetPriorityGrouping>:
  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80003d0:	b084      	sub	sp, #16
 80003d2:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 80003d4:	9b01      	ldr	r3, [sp, #4]
 80003d6:	f003 0307 	and.w	r3, r3, #7
 80003da:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80003dc:	4b0a      	ldr	r3, [pc, #40]	; (8000408 <NVIC_SetPriorityGrouping+0x38>)
 80003de:	68db      	ldr	r3, [r3, #12]
 80003e0:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 80003e2:	9a02      	ldr	r2, [sp, #8]
 80003e4:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 80003e8:	4013      	ands	r3, r2
 80003ea:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
 80003ec:	9b03      	ldr	r3, [sp, #12]
 80003ee:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80003f0:	9b02      	ldr	r3, [sp, #8]
 80003f2:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 80003f4:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80003f8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80003fc:	9302      	str	r3, [sp, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 80003fe:	4b02      	ldr	r3, [pc, #8]	; (8000408 <NVIC_SetPriorityGrouping+0x38>)
 8000400:	9a02      	ldr	r2, [sp, #8]
 8000402:	60da      	str	r2, [r3, #12]
}
 8000404:	b004      	add	sp, #16
 8000406:	4770      	bx	lr
 8000408:	e000ed00 	.word	0xe000ed00
 800040c:	f3af 8000 	nop.w

08000410 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8000410:	b082      	sub	sp, #8
 8000412:	4603      	mov	r3, r0
 8000414:	9100      	str	r1, [sp, #0]
 8000416:	f88d 3007 	strb.w	r3, [sp, #7]
  if((int32_t)IRQn < 0) {
 800041a:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 800041e:	2b00      	cmp	r3, #0
 8000420:	da0c      	bge.n	800043c <NVIC_SetPriority+0x2c>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000422:	490c      	ldr	r1, [pc, #48]	; (8000454 <NVIC_SetPriority+0x44>)
 8000424:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000428:	f003 030f 	and.w	r3, r3, #15
 800042c:	3b04      	subs	r3, #4
 800042e:	9a00      	ldr	r2, [sp, #0]
 8000430:	b2d2      	uxtb	r2, r2
 8000432:	0112      	lsls	r2, r2, #4
 8000434:	b2d2      	uxtb	r2, r2
 8000436:	440b      	add	r3, r1
 8000438:	761a      	strb	r2, [r3, #24]
 800043a:	e009      	b.n	8000450 <NVIC_SetPriority+0x40>
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800043c:	4906      	ldr	r1, [pc, #24]	; (8000458 <NVIC_SetPriority+0x48>)
 800043e:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8000442:	9a00      	ldr	r2, [sp, #0]
 8000444:	b2d2      	uxtb	r2, r2
 8000446:	0112      	lsls	r2, r2, #4
 8000448:	b2d2      	uxtb	r2, r2
 800044a:	440b      	add	r3, r1
 800044c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
 8000450:	b002      	add	sp, #8
 8000452:	4770      	bx	lr
 8000454:	e000ed00 	.word	0xe000ed00
 8000458:	e000e100 	.word	0xe000e100
 800045c:	f3af 8000 	nop.w

08000460 <port_init>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
 8000460:	b508      	push	{r3, lr}

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8000462:	4b0e      	ldr	r3, [pc, #56]	; (800049c <port_init+0x3c>)
 8000464:	2200      	movs	r2, #0
 8000466:	609a      	str	r2, [r3, #8]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 8000468:	2003      	movs	r0, #3
 800046a:	f7ff ffb1 	bl	80003d0 <NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800046e:	4b0c      	ldr	r3, [pc, #48]	; (80004a0 <port_init+0x40>)
 8000470:	4a0b      	ldr	r2, [pc, #44]	; (80004a0 <port_init+0x40>)
 8000472:	68d2      	ldr	r2, [r2, #12]
 8000474:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8000478:	60da      	str	r2, [r3, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800047a:	4b0a      	ldr	r3, [pc, #40]	; (80004a4 <port_init+0x44>)
 800047c:	4a09      	ldr	r2, [pc, #36]	; (80004a4 <port_init+0x44>)
 800047e:	6812      	ldr	r2, [r2, #0]
 8000480:	f042 0201 	orr.w	r2, r2, #1
 8000484:	601a      	str	r2, [r3, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 8000486:	f06f 0004 	mvn.w	r0, #4
 800048a:	2101      	movs	r1, #1
 800048c:	f7ff ffc0 	bl	8000410 <NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 8000490:	f06f 0001 	mvn.w	r0, #1
 8000494:	2102      	movs	r1, #2
 8000496:	f7ff ffbb 	bl	8000410 <NVIC_SetPriority>
}
 800049a:	bd08      	pop	{r3, pc}
 800049c:	e000ed00 	.word	0xe000ed00
 80004a0:	e000edf0 	.word	0xe000edf0
 80004a4:	e0001000 	.word	0xe0001000
 80004a8:	f3af 8000 	nop.w
 80004ac:	f3af 8000 	nop.w

080004b0 <port_get_irq_status>:
/**
 * @brief   Returns a word encoding the current interrupts status.
 *
 * @return              The interrupts status.
 */
static inline syssts_t port_get_irq_status(void) {
 80004b0:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80004b2:	f3ef 8311 	mrs	r3, BASEPRI
 80004b6:	9300      	str	r3, [sp, #0]
  return(result);
 80004b8:	9b00      	ldr	r3, [sp, #0]
  syssts_t sts;

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  sts = (syssts_t)__get_BASEPRI();
 80004ba:	9301      	str	r3, [sp, #4]
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  sts = (syssts_t)__get_PRIMASK();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
  return sts;
 80004bc:	9b01      	ldr	r3, [sp, #4]
}
 80004be:	4618      	mov	r0, r3
 80004c0:	b002      	add	sp, #8
 80004c2:	4770      	bx	lr
 80004c4:	f3af 8000 	nop.w
 80004c8:	f3af 8000 	nop.w
 80004cc:	f3af 8000 	nop.w

080004d0 <port_irq_enabled>:
 *
 * @return              The interrupt status.
 * @retvel false        the word specified a disabled interrupts status.
 * @retvel true         the word specified an enabled interrupts status.
 */
static inline bool port_irq_enabled(syssts_t sts) {
 80004d0:	b082      	sub	sp, #8
 80004d2:	9001      	str	r0, [sp, #4]

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  return sts == (syssts_t)CORTEX_BASEPRI_DISABLED;
 80004d4:	9b01      	ldr	r3, [sp, #4]
 80004d6:	2b00      	cmp	r3, #0
 80004d8:	bf14      	ite	ne
 80004da:	2300      	movne	r3, #0
 80004dc:	2301      	moveq	r3, #1
 80004de:	b2db      	uxtb	r3, r3
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  return (sts & (syssts_t)1) == (syssts_t)0;
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80004e0:	4618      	mov	r0, r3
 80004e2:	b002      	add	sp, #8
 80004e4:	4770      	bx	lr
 80004e6:	bf00      	nop
 80004e8:	f3af 8000 	nop.w
 80004ec:	f3af 8000 	nop.w

080004f0 <port_is_isr_context>:
 *
 * @return              The execution context.
 * @retval false        not running in ISR mode.
 * @retval true         running in ISR mode.
 */
static inline bool port_is_isr_context(void) {
 80004f0:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80004f2:	f3ef 8305 	mrs	r3, IPSR
 80004f6:	9301      	str	r3, [sp, #4]
  return(result);
 80004f8:	9b01      	ldr	r3, [sp, #4]

  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
 80004fa:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80004fe:	2b00      	cmp	r3, #0
 8000500:	bf0c      	ite	eq
 8000502:	2300      	moveq	r3, #0
 8000504:	2301      	movne	r3, #1
 8000506:	b2db      	uxtb	r3, r3
}
 8000508:	4618      	mov	r0, r3
 800050a:	b002      	add	sp, #8
 800050c:	4770      	bx	lr
 800050e:	bf00      	nop

08000510 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8000510:	b082      	sub	sp, #8
 8000512:	2320      	movs	r3, #32
 8000514:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000516:	9b01      	ldr	r3, [sp, #4]
 8000518:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800051c:	b002      	add	sp, #8
 800051e:	4770      	bx	lr

08000520 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8000520:	b082      	sub	sp, #8
 8000522:	2300      	movs	r3, #0
 8000524:	9301      	str	r3, [sp, #4]
 8000526:	9b01      	ldr	r3, [sp, #4]
 8000528:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800052c:	b002      	add	sp, #8
 800052e:	4770      	bx	lr

08000530 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000530:	b508      	push	{r3, lr}

  port_lock();
 8000532:	f7ff ffed 	bl	8000510 <port_lock>
}
 8000536:	bd08      	pop	{r3, pc}
 8000538:	f3af 8000 	nop.w
 800053c:	f3af 8000 	nop.w

08000540 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000540:	b508      	push	{r3, lr}

  port_unlock();
 8000542:	f7ff ffed 	bl	8000520 <port_unlock>
}
 8000546:	bd08      	pop	{r3, pc}
 8000548:	f3af 8000 	nop.w
 800054c:	f3af 8000 	nop.w

08000550 <port_disable>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000550:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 8000552:	4770      	bx	lr
 8000554:	f3af 8000 	nop.w
 8000558:	f3af 8000 	nop.w
 800055c:	f3af 8000 	nop.w

08000560 <port_enable>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
 8000560:	b082      	sub	sp, #8
 8000562:	2300      	movs	r3, #0
 8000564:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000566:	9b01      	ldr	r3, [sp, #4]
 8000568:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800056c:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
 800056e:	b002      	add	sp, #8
 8000570:	4770      	bx	lr
 8000572:	bf00      	nop
 8000574:	f3af 8000 	nop.w
 8000578:	f3af 8000 	nop.w
 800057c:	f3af 8000 	nop.w

08000580 <port_wait_for_interrupt>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 8000580:	4770      	bx	lr
 8000582:	bf00      	nop
 8000584:	f3af 8000 	nop.w
 8000588:	f3af 8000 	nop.w
 800058c:	f3af 8000 	nop.w

08000590 <port_rt_get_counter_value>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8000590:	4b01      	ldr	r3, [pc, #4]	; (8000598 <port_rt_get_counter_value+0x8>)
 8000592:	685b      	ldr	r3, [r3, #4]
}
 8000594:	4618      	mov	r0, r3
 8000596:	4770      	bx	lr
 8000598:	e0001000 	.word	0xe0001000
 800059c:	f3af 8000 	nop.w

080005a0 <chSysEnable>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 80005a0:	b508      	push	{r3, lr}

  _dbg_check_enable();
  port_enable();
 80005a2:	f7ff ffdd 	bl	8000560 <port_enable>
}
 80005a6:	bd08      	pop	{r3, pc}
 80005a8:	f3af 8000 	nop.w
 80005ac:	f3af 8000 	nop.w

080005b0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80005b0:	b508      	push	{r3, lr}

  port_lock();
 80005b2:	f7ff ffad 	bl	8000510 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80005b6:	bd08      	pop	{r3, pc}
 80005b8:	f3af 8000 	nop.w
 80005bc:	f3af 8000 	nop.w

080005c0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80005c0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80005c2:	f7ff ffad 	bl	8000520 <port_unlock>
}
 80005c6:	bd08      	pop	{r3, pc}
 80005c8:	f3af 8000 	nop.w
 80005cc:	f3af 8000 	nop.w

080005d0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 80005d0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 80005d2:	f7ff ffad 	bl	8000530 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 80005d6:	bd08      	pop	{r3, pc}
 80005d8:	f3af 8000 	nop.w
 80005dc:	f3af 8000 	nop.w

080005e0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80005e0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 80005e2:	f7ff ffad 	bl	8000540 <port_unlock_from_isr>
}
 80005e6:	bd08      	pop	{r3, pc}
 80005e8:	f3af 8000 	nop.w
 80005ec:	f3af 8000 	nop.w

080005f0 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 80005f0:	b500      	push	{lr}
 80005f2:	b083      	sub	sp, #12

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
 80005f4:	4b18      	ldr	r3, [pc, #96]	; (8000658 <chVTDoTickI+0x68>)
 80005f6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80005f8:	1c5a      	adds	r2, r3, #1
 80005fa:	4b17      	ldr	r3, [pc, #92]	; (8000658 <chVTDoTickI+0x68>)
 80005fc:	629a      	str	r2, [r3, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80005fe:	4b16      	ldr	r3, [pc, #88]	; (8000658 <chVTDoTickI+0x68>)
 8000600:	69da      	ldr	r2, [r3, #28]
 8000602:	4b16      	ldr	r3, [pc, #88]	; (800065c <chVTDoTickI+0x6c>)
 8000604:	429a      	cmp	r2, r3
 8000606:	d024      	beq.n	8000652 <chVTDoTickI+0x62>
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
 8000608:	4b13      	ldr	r3, [pc, #76]	; (8000658 <chVTDoTickI+0x68>)
 800060a:	69db      	ldr	r3, [r3, #28]
 800060c:	689a      	ldr	r2, [r3, #8]
 800060e:	3a01      	subs	r2, #1
 8000610:	609a      	str	r2, [r3, #8]
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
 8000612:	e019      	b.n	8000648 <chVTDoTickI+0x58>
      virtual_timer_t *vtp;
      vtfunc_t fn;

      vtp = ch.vtlist.vt_next;
 8000614:	4b10      	ldr	r3, [pc, #64]	; (8000658 <chVTDoTickI+0x68>)
 8000616:	69db      	ldr	r3, [r3, #28]
 8000618:	9301      	str	r3, [sp, #4]
      fn = vtp->vt_func;
 800061a:	9b01      	ldr	r3, [sp, #4]
 800061c:	68db      	ldr	r3, [r3, #12]
 800061e:	9300      	str	r3, [sp, #0]
      vtp->vt_func = NULL;
 8000620:	9b01      	ldr	r3, [sp, #4]
 8000622:	2200      	movs	r2, #0
 8000624:	60da      	str	r2, [r3, #12]
      vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000626:	9b01      	ldr	r3, [sp, #4]
 8000628:	681b      	ldr	r3, [r3, #0]
 800062a:	4a0c      	ldr	r2, [pc, #48]	; (800065c <chVTDoTickI+0x6c>)
 800062c:	605a      	str	r2, [r3, #4]
      ch.vtlist.vt_next = vtp->vt_next;
 800062e:	9b01      	ldr	r3, [sp, #4]
 8000630:	681a      	ldr	r2, [r3, #0]
 8000632:	4b09      	ldr	r3, [pc, #36]	; (8000658 <chVTDoTickI+0x68>)
 8000634:	61da      	str	r2, [r3, #28]
      chSysUnlockFromISR();
 8000636:	f7ff ffd3 	bl	80005e0 <chSysUnlockFromISR>
      fn(vtp->vt_par);
 800063a:	9b01      	ldr	r3, [sp, #4]
 800063c:	691a      	ldr	r2, [r3, #16]
 800063e:	9b00      	ldr	r3, [sp, #0]
 8000640:	4610      	mov	r0, r2
 8000642:	4798      	blx	r3
      chSysLockFromISR();
 8000644:	f7ff ffc4 	bl	80005d0 <chSysLockFromISR>
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
 8000648:	4b03      	ldr	r3, [pc, #12]	; (8000658 <chVTDoTickI+0x68>)
 800064a:	69db      	ldr	r3, [r3, #28]
 800064c:	689b      	ldr	r3, [r3, #8]
 800064e:	2b00      	cmp	r3, #0
 8000650:	d0e0      	beq.n	8000614 <chVTDoTickI+0x24>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
              (now + delta - ch.vtlist.vt_lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000652:	b003      	add	sp, #12
 8000654:	f85d fb04 	ldr.w	pc, [sp], #4
 8000658:	200016e0 	.word	0x200016e0
 800065c:	200016fc 	.word	0x200016fc

08000660 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8000660:	b082      	sub	sp, #8
 8000662:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8000664:	4b02      	ldr	r3, [pc, #8]	; (8000670 <chRegSetThreadName+0x10>)
 8000666:	699b      	ldr	r3, [r3, #24]
 8000668:	9a01      	ldr	r2, [sp, #4]
 800066a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 800066c:	b002      	add	sp, #8
 800066e:	4770      	bx	lr
 8000670:	200016e0 	.word	0x200016e0
 8000674:	f3af 8000 	nop.w
 8000678:	f3af 8000 	nop.w
 800067c:	f3af 8000 	nop.w

08000680 <chRegSetThreadNameX>:
 * @param[in] tp        pointer to the thread
 * @param[in] name      thread name as a zero terminated string
 *
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {
 8000680:	b082      	sub	sp, #8
 8000682:	9001      	str	r0, [sp, #4]
 8000684:	9100      	str	r1, [sp, #0]

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8000686:	9b01      	ldr	r3, [sp, #4]
 8000688:	9a00      	ldr	r2, [sp, #0]
 800068a:	619a      	str	r2, [r3, #24]
#else
  (void)tp;
  (void)name;
#endif
}
 800068c:	b002      	add	sp, #8
 800068e:	4770      	bx	lr

08000690 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8000690:	b500      	push	{lr}
 8000692:	b083      	sub	sp, #12
 8000694:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 8000696:	f7ff ff73 	bl	8000580 <port_wait_for_interrupt>
    /*lint -restore*/
    CH_CFG_IDLE_LOOP_HOOK();
  }
 800069a:	e7fc      	b.n	8000696 <_idle_thread+0x6>
 800069c:	f3af 8000 	nop.w

080006a0 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 80006a0:	b500      	push	{lr}
 80006a2:	b085      	sub	sp, #20
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
 80006a4:	f7ff fedc 	bl	8000460 <port_init>
  _scheduler_init();
 80006a8:	f000 fa6a 	bl	8000b80 <_scheduler_init>
  _vt_init();
 80006ac:	f000 f958 	bl	8000960 <_vt_init>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
 80006b0:	f000 ffd6 	bl	8001660 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 80006b4:	f002 ffbc 	bl	8003630 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 80006b8:	f003 f81a 	bl	80036f0 <_heap_init>
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80006bc:	480f      	ldr	r0, [pc, #60]	; (80006fc <chSysInit+0x5c>)
 80006be:	2140      	movs	r1, #64	; 0x40
 80006c0:	f000 fd26 	bl	8001110 <_thread_init>
 80006c4:	4602      	mov	r2, r0
 80006c6:	4b0e      	ldr	r3, [pc, #56]	; (8000700 <chSysInit+0x60>)
 80006c8:	619a      	str	r2, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 80006ca:	4b0d      	ldr	r3, [pc, #52]	; (8000700 <chSysInit+0x60>)
 80006cc:	699b      	ldr	r3, [r3, #24]
 80006ce:	2201      	movs	r2, #1
 80006d0:	771a      	strb	r2, [r3, #28]
#if CH_DBG_STATISTICS == TRUE
  /* Starting measurement for this thread.*/
  chTMStartMeasurementX(&currp->p_stats);
#endif

  chSysEnable();
 80006d2:	f7ff ff65 	bl	80005a0 <chSysEnable>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Note, &ch_debug points to the string "main" if the registry is
     active.*/
  chRegSetThreadName((const char *)&ch_debug);
 80006d6:	480b      	ldr	r0, [pc, #44]	; (8000704 <chSysInit+0x64>)
 80006d8:	f7ff ffc2 	bl	8000660 <chRegSetThreadName>
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 80006dc:	2300      	movs	r3, #0
 80006de:	9300      	str	r3, [sp, #0]
 80006e0:	4809      	ldr	r0, [pc, #36]	; (8000708 <chSysInit+0x68>)
 80006e2:	21d8      	movs	r1, #216	; 0xd8
 80006e4:	2201      	movs	r2, #1
 80006e6:	4b09      	ldr	r3, [pc, #36]	; (800070c <chSysInit+0x6c>)
 80006e8:	f000 fd7a 	bl	80011e0 <chThdCreateStatic>
 80006ec:	9003      	str	r0, [sp, #12]
                                      sizeof(ch.idle_thread_wa),
                                      IDLEPRIO,
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
 80006ee:	9803      	ldr	r0, [sp, #12]
 80006f0:	4907      	ldr	r1, [pc, #28]	; (8000710 <chSysInit+0x70>)
 80006f2:	f7ff ffc5 	bl	8000680 <chRegSetThreadNameX>
  }
#endif
}
 80006f6:	b005      	add	sp, #20
 80006f8:	f85d fb04 	ldr.w	pc, [sp], #4
 80006fc:	20001710 	.word	0x20001710
 8000700:	200016e0 	.word	0x200016e0
 8000704:	080177f0 	.word	0x080177f0
 8000708:	20001758 	.word	0x20001758
 800070c:	08000691 	.word	0x08000691
 8000710:	080177e0 	.word	0x080177e0
 8000714:	f3af 8000 	nop.w
 8000718:	f3af 8000 	nop.w
 800071c:	f3af 8000 	nop.w

08000720 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8000720:	b500      	push	{lr}
 8000722:	b083      	sub	sp, #12
 8000724:	9001      	str	r0, [sp, #4]

  port_disable();
 8000726:	f7ff ff13 	bl	8000550 <port_disable>
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 800072a:	4b02      	ldr	r3, [pc, #8]	; (8000734 <chSysHalt+0x14>)
 800072c:	9a01      	ldr	r2, [sp, #4]
 800072e:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Harmless infinite loop.*/
  while (true) {
  }
 8000730:	e7fe      	b.n	8000730 <chSysHalt+0x10>
 8000732:	bf00      	nop
 8000734:	200016e0 	.word	0x200016e0
 8000738:	f3af 8000 	nop.w
 800073c:	f3af 8000 	nop.w

08000740 <chSysIntegrityCheckI>:
 * @retval false        The test succeeded.
 * @retval true         Test failed.
 *
 * @iclass
 */
bool chSysIntegrityCheckI(unsigned testmask) {
 8000740:	b086      	sub	sp, #24
 8000742:	9001      	str	r0, [sp, #4]
  cnt_t n;

  chDbgCheckClassI();

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 8000744:	9b01      	ldr	r3, [sp, #4]
 8000746:	f003 0301 	and.w	r3, r3, #1
 800074a:	2b00      	cmp	r3, #0
 800074c:	d022      	beq.n	8000794 <chSysIntegrityCheckI+0x54>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 800074e:	2300      	movs	r3, #0
 8000750:	9305      	str	r3, [sp, #20]
    tp = ch.rlist.r_queue.p_next;
 8000752:	4b3a      	ldr	r3, [pc, #232]	; (800083c <chSysIntegrityCheckI+0xfc>)
 8000754:	681b      	ldr	r3, [r3, #0]
 8000756:	9304      	str	r3, [sp, #16]
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 8000758:	e005      	b.n	8000766 <chSysIntegrityCheckI+0x26>
      n++;
 800075a:	9b05      	ldr	r3, [sp, #20]
 800075c:	3301      	adds	r3, #1
 800075e:	9305      	str	r3, [sp, #20]
      tp = tp->p_next;
 8000760:	9b04      	ldr	r3, [sp, #16]
 8000762:	681b      	ldr	r3, [r3, #0]
 8000764:	9304      	str	r3, [sp, #16]
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_queue.p_next;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 8000766:	9a04      	ldr	r2, [sp, #16]
 8000768:	4b34      	ldr	r3, [pc, #208]	; (800083c <chSysIntegrityCheckI+0xfc>)
 800076a:	429a      	cmp	r2, r3
 800076c:	d1f5      	bne.n	800075a <chSysIntegrityCheckI+0x1a>
      n++;
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
 800076e:	4b33      	ldr	r3, [pc, #204]	; (800083c <chSysIntegrityCheckI+0xfc>)
 8000770:	685b      	ldr	r3, [r3, #4]
 8000772:	9304      	str	r3, [sp, #16]
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 8000774:	e005      	b.n	8000782 <chSysIntegrityCheckI+0x42>
      n--;
 8000776:	9b05      	ldr	r3, [sp, #20]
 8000778:	3b01      	subs	r3, #1
 800077a:	9305      	str	r3, [sp, #20]
      tp = tp->p_prev;
 800077c:	9b04      	ldr	r3, [sp, #16]
 800077e:	685b      	ldr	r3, [r3, #4]
 8000780:	9304      	str	r3, [sp, #16]
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 8000782:	9a04      	ldr	r2, [sp, #16]
 8000784:	4b2d      	ldr	r3, [pc, #180]	; (800083c <chSysIntegrityCheckI+0xfc>)
 8000786:	429a      	cmp	r2, r3
 8000788:	d1f5      	bne.n	8000776 <chSysIntegrityCheckI+0x36>
      n--;
      tp = tp->p_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800078a:	9b05      	ldr	r3, [sp, #20]
 800078c:	2b00      	cmp	r3, #0
 800078e:	d001      	beq.n	8000794 <chSysIntegrityCheckI+0x54>
      return true;
 8000790:	2301      	movs	r3, #1
 8000792:	e050      	b.n	8000836 <chSysIntegrityCheckI+0xf6>
    }
  }

  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
 8000794:	9b01      	ldr	r3, [sp, #4]
 8000796:	f003 0302 	and.w	r3, r3, #2
 800079a:	2b00      	cmp	r3, #0
 800079c:	d022      	beq.n	80007e4 <chSysIntegrityCheckI+0xa4>
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
 800079e:	2300      	movs	r3, #0
 80007a0:	9305      	str	r3, [sp, #20]
    vtp = ch.vtlist.vt_next;
 80007a2:	4b26      	ldr	r3, [pc, #152]	; (800083c <chSysIntegrityCheckI+0xfc>)
 80007a4:	69db      	ldr	r3, [r3, #28]
 80007a6:	9303      	str	r3, [sp, #12]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80007a8:	e005      	b.n	80007b6 <chSysIntegrityCheckI+0x76>
      n++;
 80007aa:	9b05      	ldr	r3, [sp, #20]
 80007ac:	3301      	adds	r3, #1
 80007ae:	9305      	str	r3, [sp, #20]
      vtp = vtp->vt_next;
 80007b0:	9b03      	ldr	r3, [sp, #12]
 80007b2:	681b      	ldr	r3, [r3, #0]
 80007b4:	9303      	str	r3, [sp, #12]
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80007b6:	9a03      	ldr	r2, [sp, #12]
 80007b8:	4b21      	ldr	r3, [pc, #132]	; (8000840 <chSysIntegrityCheckI+0x100>)
 80007ba:	429a      	cmp	r2, r3
 80007bc:	d1f5      	bne.n	80007aa <chSysIntegrityCheckI+0x6a>
      n++;
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
 80007be:	4b1f      	ldr	r3, [pc, #124]	; (800083c <chSysIntegrityCheckI+0xfc>)
 80007c0:	6a1b      	ldr	r3, [r3, #32]
 80007c2:	9303      	str	r3, [sp, #12]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80007c4:	e005      	b.n	80007d2 <chSysIntegrityCheckI+0x92>
      n--;
 80007c6:	9b05      	ldr	r3, [sp, #20]
 80007c8:	3b01      	subs	r3, #1
 80007ca:	9305      	str	r3, [sp, #20]
      vtp = vtp->vt_prev;
 80007cc:	9b03      	ldr	r3, [sp, #12]
 80007ce:	685b      	ldr	r3, [r3, #4]
 80007d0:	9303      	str	r3, [sp, #12]
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80007d2:	9a03      	ldr	r2, [sp, #12]
 80007d4:	4b1a      	ldr	r3, [pc, #104]	; (8000840 <chSysIntegrityCheckI+0x100>)
 80007d6:	429a      	cmp	r2, r3
 80007d8:	d1f5      	bne.n	80007c6 <chSysIntegrityCheckI+0x86>
      n--;
      vtp = vtp->vt_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 80007da:	9b05      	ldr	r3, [sp, #20]
 80007dc:	2b00      	cmp	r3, #0
 80007de:	d001      	beq.n	80007e4 <chSysIntegrityCheckI+0xa4>
      return true;
 80007e0:	2301      	movs	r3, #1
 80007e2:	e028      	b.n	8000836 <chSysIntegrityCheckI+0xf6>
    }
  }

#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
 80007e4:	9b01      	ldr	r3, [sp, #4]
 80007e6:	f003 0304 	and.w	r3, r3, #4
 80007ea:	2b00      	cmp	r3, #0
 80007ec:	d022      	beq.n	8000834 <chSysIntegrityCheckI+0xf4>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 80007ee:	2300      	movs	r3, #0
 80007f0:	9305      	str	r3, [sp, #20]
    tp = ch.rlist.r_newer;
 80007f2:	4b12      	ldr	r3, [pc, #72]	; (800083c <chSysIntegrityCheckI+0xfc>)
 80007f4:	691b      	ldr	r3, [r3, #16]
 80007f6:	9302      	str	r3, [sp, #8]
    while (tp != (thread_t *)&ch.rlist) {
 80007f8:	e005      	b.n	8000806 <chSysIntegrityCheckI+0xc6>
      n++;
 80007fa:	9b05      	ldr	r3, [sp, #20]
 80007fc:	3301      	adds	r3, #1
 80007fe:	9305      	str	r3, [sp, #20]
      tp = tp->p_newer;
 8000800:	9b02      	ldr	r3, [sp, #8]
 8000802:	691b      	ldr	r3, [r3, #16]
 8000804:	9302      	str	r3, [sp, #8]
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_newer;
    while (tp != (thread_t *)&ch.rlist) {
 8000806:	9a02      	ldr	r2, [sp, #8]
 8000808:	4b0c      	ldr	r3, [pc, #48]	; (800083c <chSysIntegrityCheckI+0xfc>)
 800080a:	429a      	cmp	r2, r3
 800080c:	d1f5      	bne.n	80007fa <chSysIntegrityCheckI+0xba>
      n++;
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
 800080e:	4b0b      	ldr	r3, [pc, #44]	; (800083c <chSysIntegrityCheckI+0xfc>)
 8000810:	695b      	ldr	r3, [r3, #20]
 8000812:	9302      	str	r3, [sp, #8]
    while (tp != (thread_t *)&ch.rlist) {
 8000814:	e005      	b.n	8000822 <chSysIntegrityCheckI+0xe2>
      n--;
 8000816:	9b05      	ldr	r3, [sp, #20]
 8000818:	3b01      	subs	r3, #1
 800081a:	9305      	str	r3, [sp, #20]
      tp = tp->p_older;
 800081c:	9b02      	ldr	r3, [sp, #8]
 800081e:	695b      	ldr	r3, [r3, #20]
 8000820:	9302      	str	r3, [sp, #8]
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
    while (tp != (thread_t *)&ch.rlist) {
 8000822:	9a02      	ldr	r2, [sp, #8]
 8000824:	4b05      	ldr	r3, [pc, #20]	; (800083c <chSysIntegrityCheckI+0xfc>)
 8000826:	429a      	cmp	r2, r3
 8000828:	d1f5      	bne.n	8000816 <chSysIntegrityCheckI+0xd6>
      n--;
      tp = tp->p_older;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800082a:	9b05      	ldr	r3, [sp, #20]
 800082c:	2b00      	cmp	r3, #0
 800082e:	d001      	beq.n	8000834 <chSysIntegrityCheckI+0xf4>
      return true;
 8000830:	2301      	movs	r3, #1
 8000832:	e000      	b.n	8000836 <chSysIntegrityCheckI+0xf6>
  if ((testmask & CH_INTEGRITY_PORT) != 0U) {
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
 8000834:	2300      	movs	r3, #0
}
 8000836:	4618      	mov	r0, r3
 8000838:	b006      	add	sp, #24
 800083a:	4770      	bx	lr
 800083c:	200016e0 	.word	0x200016e0
 8000840:	200016fc 	.word	0x200016fc
 8000844:	f3af 8000 	nop.w
 8000848:	f3af 8000 	nop.w
 800084c:	f3af 8000 	nop.w

08000850 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8000850:	b508      	push	{r3, lr}

  chDbgCheckClassI();

#if CH_CFG_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->p_preempt > (tslices_t)0) {
 8000852:	4b07      	ldr	r3, [pc, #28]	; (8000870 <chSysTimerHandlerI+0x20>)
 8000854:	699b      	ldr	r3, [r3, #24]
 8000856:	7fdb      	ldrb	r3, [r3, #31]
 8000858:	2b00      	cmp	r3, #0
 800085a:	d005      	beq.n	8000868 <chSysTimerHandlerI+0x18>
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
 800085c:	4b04      	ldr	r3, [pc, #16]	; (8000870 <chSysTimerHandlerI+0x20>)
 800085e:	699b      	ldr	r3, [r3, #24]
 8000860:	7fda      	ldrb	r2, [r3, #31]
 8000862:	3a01      	subs	r2, #1
 8000864:	b2d2      	uxtb	r2, r2
 8000866:	77da      	strb	r2, [r3, #31]
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->p_time++;
#endif
  chVTDoTickI();
 8000868:	f7ff fec2 	bl	80005f0 <chVTDoTickI>
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
 800086c:	bd08      	pop	{r3, pc}
 800086e:	bf00      	nop
 8000870:	200016e0 	.word	0x200016e0
 8000874:	f3af 8000 	nop.w
 8000878:	f3af 8000 	nop.w
 800087c:	f3af 8000 	nop.w

08000880 <chSysGetStatusAndLockX>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {
 8000880:	b500      	push	{lr}
 8000882:	b083      	sub	sp, #12

  syssts_t sts = port_get_irq_status();
 8000884:	f7ff fe14 	bl	80004b0 <port_get_irq_status>
 8000888:	9001      	str	r0, [sp, #4]
  if (port_irq_enabled(sts)) {
 800088a:	9801      	ldr	r0, [sp, #4]
 800088c:	f7ff fe20 	bl	80004d0 <port_irq_enabled>
 8000890:	4603      	mov	r3, r0
 8000892:	2b00      	cmp	r3, #0
 8000894:	d009      	beq.n	80008aa <chSysGetStatusAndLockX+0x2a>
    if (port_is_isr_context()) {
 8000896:	f7ff fe2b 	bl	80004f0 <port_is_isr_context>
 800089a:	4603      	mov	r3, r0
 800089c:	2b00      	cmp	r3, #0
 800089e:	d002      	beq.n	80008a6 <chSysGetStatusAndLockX+0x26>
      chSysLockFromISR();
 80008a0:	f7ff fe96 	bl	80005d0 <chSysLockFromISR>
 80008a4:	e001      	b.n	80008aa <chSysGetStatusAndLockX+0x2a>
    }
    else {
      chSysLock();
 80008a6:	f7ff fe83 	bl	80005b0 <chSysLock>
    }
  }
  return sts;
 80008aa:	9b01      	ldr	r3, [sp, #4]
}
 80008ac:	4618      	mov	r0, r3
 80008ae:	b003      	add	sp, #12
 80008b0:	f85d fb04 	ldr.w	pc, [sp], #4
 80008b4:	f3af 8000 	nop.w
 80008b8:	f3af 8000 	nop.w
 80008bc:	f3af 8000 	nop.w

080008c0 <chSysRestoreStatusX>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
 80008c0:	b500      	push	{lr}
 80008c2:	b083      	sub	sp, #12
 80008c4:	9001      	str	r0, [sp, #4]

  if (port_irq_enabled(sts)) {
 80008c6:	9801      	ldr	r0, [sp, #4]
 80008c8:	f7ff fe02 	bl	80004d0 <port_irq_enabled>
 80008cc:	4603      	mov	r3, r0
 80008ce:	2b00      	cmp	r3, #0
 80008d0:	d00b      	beq.n	80008ea <chSysRestoreStatusX+0x2a>
    if (port_is_isr_context()) {
 80008d2:	f7ff fe0d 	bl	80004f0 <port_is_isr_context>
 80008d6:	4603      	mov	r3, r0
 80008d8:	2b00      	cmp	r3, #0
 80008da:	d002      	beq.n	80008e2 <chSysRestoreStatusX+0x22>
      chSysUnlockFromISR();
 80008dc:	f7ff fe80 	bl	80005e0 <chSysUnlockFromISR>
 80008e0:	e003      	b.n	80008ea <chSysRestoreStatusX+0x2a>
    }
    else {
      chSchRescheduleS();
 80008e2:	f000 fa4d 	bl	8000d80 <chSchRescheduleS>
      chSysUnlock();
 80008e6:	f7ff fe6b 	bl	80005c0 <chSysUnlock>
    }
  }
}
 80008ea:	b003      	add	sp, #12
 80008ec:	f85d fb04 	ldr.w	pc, [sp], #4

080008f0 <chSysIsCounterWithinX>:
 * @retval true         current time within the specified time window.
 * @retval false        current time not within the specified time window.
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {
 80008f0:	b084      	sub	sp, #16
 80008f2:	9003      	str	r0, [sp, #12]
 80008f4:	9102      	str	r1, [sp, #8]
 80008f6:	9201      	str	r2, [sp, #4]

  return (bool)((cnt - start) < (end - start));
 80008f8:	9a03      	ldr	r2, [sp, #12]
 80008fa:	9b02      	ldr	r3, [sp, #8]
 80008fc:	1ad2      	subs	r2, r2, r3
 80008fe:	9901      	ldr	r1, [sp, #4]
 8000900:	9b02      	ldr	r3, [sp, #8]
 8000902:	1acb      	subs	r3, r1, r3
 8000904:	429a      	cmp	r2, r3
 8000906:	bf2c      	ite	cs
 8000908:	2300      	movcs	r3, #0
 800090a:	2301      	movcc	r3, #1
 800090c:	b2db      	uxtb	r3, r3
}
 800090e:	4618      	mov	r0, r3
 8000910:	b004      	add	sp, #16
 8000912:	4770      	bx	lr
 8000914:	f3af 8000 	nop.w
 8000918:	f3af 8000 	nop.w
 800091c:	f3af 8000 	nop.w

08000920 <chSysPolledDelayX>:
 *
 * @param[in] cycles    number of cycles
 *
 * @xclass
 */
void chSysPolledDelayX(rtcnt_t cycles) {
 8000920:	b500      	push	{lr}
 8000922:	b085      	sub	sp, #20
 8000924:	9001      	str	r0, [sp, #4]
  rtcnt_t start = chSysGetRealtimeCounterX();
 8000926:	f7ff fe33 	bl	8000590 <port_rt_get_counter_value>
 800092a:	9003      	str	r0, [sp, #12]
  rtcnt_t end  = start + cycles;
 800092c:	9a03      	ldr	r2, [sp, #12]
 800092e:	9b01      	ldr	r3, [sp, #4]
 8000930:	4413      	add	r3, r2
 8000932:	9302      	str	r3, [sp, #8]

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8000934:	bf00      	nop
 8000936:	f7ff fe2b 	bl	8000590 <port_rt_get_counter_value>
 800093a:	4603      	mov	r3, r0
 800093c:	4618      	mov	r0, r3
 800093e:	9903      	ldr	r1, [sp, #12]
 8000940:	9a02      	ldr	r2, [sp, #8]
 8000942:	f7ff ffd5 	bl	80008f0 <chSysIsCounterWithinX>
 8000946:	4603      	mov	r3, r0
 8000948:	2b00      	cmp	r3, #0
 800094a:	d1f4      	bne.n	8000936 <chSysPolledDelayX+0x16>
  }
}
 800094c:	b005      	add	sp, #20
 800094e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000952:	bf00      	nop
 8000954:	f3af 8000 	nop.w
 8000958:	f3af 8000 	nop.w
 800095c:	f3af 8000 	nop.w

08000960 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8000960:	4b06      	ldr	r3, [pc, #24]	; (800097c <_vt_init+0x1c>)
 8000962:	4a07      	ldr	r2, [pc, #28]	; (8000980 <_vt_init+0x20>)
 8000964:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000966:	4b05      	ldr	r3, [pc, #20]	; (800097c <_vt_init+0x1c>)
 8000968:	4a05      	ldr	r2, [pc, #20]	; (8000980 <_vt_init+0x20>)
 800096a:	621a      	str	r2, [r3, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
 800096c:	4b03      	ldr	r3, [pc, #12]	; (800097c <_vt_init+0x1c>)
 800096e:	f04f 32ff 	mov.w	r2, #4294967295
 8000972:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
 8000974:	4b01      	ldr	r3, [pc, #4]	; (800097c <_vt_init+0x1c>)
 8000976:	2200      	movs	r2, #0
 8000978:	629a      	str	r2, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800097a:	4770      	bx	lr
 800097c:	200016e0 	.word	0x200016e0
 8000980:	200016fc 	.word	0x200016fc
 8000984:	f3af 8000 	nop.w
 8000988:	f3af 8000 	nop.w
 800098c:	f3af 8000 	nop.w

08000990 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8000990:	b086      	sub	sp, #24
 8000992:	9003      	str	r0, [sp, #12]
 8000994:	9102      	str	r1, [sp, #8]
 8000996:	9201      	str	r2, [sp, #4]
 8000998:	9300      	str	r3, [sp, #0]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 800099a:	9b03      	ldr	r3, [sp, #12]
 800099c:	9a00      	ldr	r2, [sp, #0]
 800099e:	611a      	str	r2, [r3, #16]
  vtp->vt_func = vtfunc;
 80009a0:	9b03      	ldr	r3, [sp, #12]
 80009a2:	9a01      	ldr	r2, [sp, #4]
 80009a4:	60da      	str	r2, [r3, #12]
      port_timer_set_alarm(ch.vtlist.vt_lasttime + delta);
    }
  }
#else /* CH_CFG_ST_TIMEDELTA == 0 */
  /* Delta is initially equal to the specified delay.*/
  delta = delay;
 80009a6:	9b02      	ldr	r3, [sp, #8]
 80009a8:	9304      	str	r3, [sp, #16]

  /* Pointer to the first element in the delta list.*/
  p = ch.vtlist.vt_next;
 80009aa:	4b17      	ldr	r3, [pc, #92]	; (8000a08 <chVTDoSetI+0x78>)
 80009ac:	69db      	ldr	r3, [r3, #28]
 80009ae:	9305      	str	r3, [sp, #20]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delta) {
 80009b0:	e007      	b.n	80009c2 <chVTDoSetI+0x32>
    delta -= p->vt_delta;
 80009b2:	9b05      	ldr	r3, [sp, #20]
 80009b4:	689b      	ldr	r3, [r3, #8]
 80009b6:	9a04      	ldr	r2, [sp, #16]
 80009b8:	1ad3      	subs	r3, r2, r3
 80009ba:	9304      	str	r3, [sp, #16]
    p = p->vt_next;
 80009bc:	9b05      	ldr	r3, [sp, #20]
 80009be:	681b      	ldr	r3, [r3, #0]
 80009c0:	9305      	str	r3, [sp, #20]
  p = ch.vtlist.vt_next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delta) {
 80009c2:	9b05      	ldr	r3, [sp, #20]
 80009c4:	689a      	ldr	r2, [r3, #8]
 80009c6:	9b04      	ldr	r3, [sp, #16]
 80009c8:	429a      	cmp	r2, r3
 80009ca:	d3f2      	bcc.n	80009b2 <chVTDoSetI+0x22>
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 80009cc:	9b03      	ldr	r3, [sp, #12]
 80009ce:	9a05      	ldr	r2, [sp, #20]
 80009d0:	601a      	str	r2, [r3, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
 80009d2:	9b03      	ldr	r3, [sp, #12]
 80009d4:	681b      	ldr	r3, [r3, #0]
 80009d6:	685a      	ldr	r2, [r3, #4]
 80009d8:	9b03      	ldr	r3, [sp, #12]
 80009da:	605a      	str	r2, [r3, #4]
  vtp->vt_prev->vt_next = vtp;
 80009dc:	9b03      	ldr	r3, [sp, #12]
 80009de:	685b      	ldr	r3, [r3, #4]
 80009e0:	9a03      	ldr	r2, [sp, #12]
 80009e2:	601a      	str	r2, [r3, #0]
  p->vt_prev = vtp;
 80009e4:	9b05      	ldr	r3, [sp, #20]
 80009e6:	9a03      	ldr	r2, [sp, #12]
 80009e8:	605a      	str	r2, [r3, #4]
  vtp->vt_delta = delta
 80009ea:	9b03      	ldr	r3, [sp, #12]
 80009ec:	9a04      	ldr	r2, [sp, #16]
 80009ee:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 80009f0:	9b05      	ldr	r3, [sp, #20]
 80009f2:	689a      	ldr	r2, [r3, #8]
 80009f4:	9b04      	ldr	r3, [sp, #16]
 80009f6:	1ad2      	subs	r2, r2, r3
 80009f8:	9b05      	ldr	r3, [sp, #20]
 80009fa:	609a      	str	r2, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 80009fc:	4b02      	ldr	r3, [pc, #8]	; (8000a08 <chVTDoSetI+0x78>)
 80009fe:	f04f 32ff 	mov.w	r2, #4294967295
 8000a02:	625a      	str	r2, [r3, #36]	; 0x24
}
 8000a04:	b006      	add	sp, #24
 8000a06:	4770      	bx	lr
 8000a08:	200016e0 	.word	0x200016e0
 8000a0c:	f3af 8000 	nop.w

08000a10 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8000a10:	b082      	sub	sp, #8
 8000a12:	9001      	str	r0, [sp, #4]
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 8000a14:	9b01      	ldr	r3, [sp, #4]
 8000a16:	681b      	ldr	r3, [r3, #0]
 8000a18:	9a01      	ldr	r2, [sp, #4]
 8000a1a:	6812      	ldr	r2, [r2, #0]
 8000a1c:	6891      	ldr	r1, [r2, #8]
 8000a1e:	9a01      	ldr	r2, [sp, #4]
 8000a20:	6892      	ldr	r2, [r2, #8]
 8000a22:	440a      	add	r2, r1
 8000a24:	609a      	str	r2, [r3, #8]

 /* Removing the element from the delta list.*/
  vtp->vt_prev->vt_next = vtp->vt_next;
 8000a26:	9b01      	ldr	r3, [sp, #4]
 8000a28:	685b      	ldr	r3, [r3, #4]
 8000a2a:	9a01      	ldr	r2, [sp, #4]
 8000a2c:	6812      	ldr	r2, [r2, #0]
 8000a2e:	601a      	str	r2, [r3, #0]
  vtp->vt_next->vt_prev = vtp->vt_prev;
 8000a30:	9b01      	ldr	r3, [sp, #4]
 8000a32:	681b      	ldr	r3, [r3, #0]
 8000a34:	9a01      	ldr	r2, [sp, #4]
 8000a36:	6852      	ldr	r2, [r2, #4]
 8000a38:	605a      	str	r2, [r3, #4]
  vtp->vt_func = NULL;
 8000a3a:	9b01      	ldr	r3, [sp, #4]
 8000a3c:	2200      	movs	r2, #0
 8000a3e:	60da      	str	r2, [r3, #12]

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 8000a40:	4b02      	ldr	r3, [pc, #8]	; (8000a4c <chVTDoResetI+0x3c>)
 8000a42:	f04f 32ff 	mov.w	r2, #4294967295
 8000a46:	625a      	str	r2, [r3, #36]	; 0x24
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000a48:	b002      	add	sp, #8
 8000a4a:	4770      	bx	lr
 8000a4c:	200016e0 	.word	0x200016e0

08000a50 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8000a50:	b082      	sub	sp, #8
 8000a52:	2320      	movs	r3, #32
 8000a54:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000a56:	9b01      	ldr	r3, [sp, #4]
 8000a58:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000a5c:	b002      	add	sp, #8
 8000a5e:	4770      	bx	lr

08000a60 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8000a60:	b082      	sub	sp, #8
 8000a62:	2300      	movs	r3, #0
 8000a64:	9301      	str	r3, [sp, #4]
 8000a66:	9b01      	ldr	r3, [sp, #4]
 8000a68:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000a6c:	b002      	add	sp, #8
 8000a6e:	4770      	bx	lr

08000a70 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000a70:	b508      	push	{r3, lr}

  port_lock();
 8000a72:	f7ff ffed 	bl	8000a50 <port_lock>
}
 8000a76:	bd08      	pop	{r3, pc}
 8000a78:	f3af 8000 	nop.w
 8000a7c:	f3af 8000 	nop.w

08000a80 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000a80:	b508      	push	{r3, lr}

  port_unlock();
 8000a82:	f7ff ffed 	bl	8000a60 <port_unlock>
}
 8000a86:	bd08      	pop	{r3, pc}
 8000a88:	f3af 8000 	nop.w
 8000a8c:	f3af 8000 	nop.w

08000a90 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8000a90:	b082      	sub	sp, #8
 8000a92:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8000a94:	9b01      	ldr	r3, [sp, #4]
 8000a96:	9a01      	ldr	r2, [sp, #4]
 8000a98:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8000a9a:	9b01      	ldr	r3, [sp, #4]
 8000a9c:	9a01      	ldr	r2, [sp, #4]
 8000a9e:	605a      	str	r2, [r3, #4]
}
 8000aa0:	b002      	add	sp, #8
 8000aa2:	4770      	bx	lr
 8000aa4:	f3af 8000 	nop.w
 8000aa8:	f3af 8000 	nop.w
 8000aac:	f3af 8000 	nop.w

08000ab0 <queue_fifo_remove>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8000ab0:	b084      	sub	sp, #16
 8000ab2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8000ab4:	9b01      	ldr	r3, [sp, #4]
 8000ab6:	681b      	ldr	r3, [r3, #0]
 8000ab8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8000aba:	9b03      	ldr	r3, [sp, #12]
 8000abc:	681a      	ldr	r2, [r3, #0]
 8000abe:	9b01      	ldr	r3, [sp, #4]
 8000ac0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000ac2:	9b01      	ldr	r3, [sp, #4]
 8000ac4:	681b      	ldr	r3, [r3, #0]
 8000ac6:	9a01      	ldr	r2, [sp, #4]
 8000ac8:	605a      	str	r2, [r3, #4]

  return tp;
 8000aca:	9b03      	ldr	r3, [sp, #12]
}
 8000acc:	4618      	mov	r0, r3
 8000ace:	b004      	add	sp, #16
 8000ad0:	4770      	bx	lr
 8000ad2:	bf00      	nop
 8000ad4:	f3af 8000 	nop.w
 8000ad8:	f3af 8000 	nop.w
 8000adc:	f3af 8000 	nop.w

08000ae0 <queue_dequeue>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 8000ae0:	b082      	sub	sp, #8
 8000ae2:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
 8000ae4:	9b01      	ldr	r3, [sp, #4]
 8000ae6:	685b      	ldr	r3, [r3, #4]
 8000ae8:	9a01      	ldr	r2, [sp, #4]
 8000aea:	6812      	ldr	r2, [r2, #0]
 8000aec:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8000aee:	9b01      	ldr	r3, [sp, #4]
 8000af0:	681b      	ldr	r3, [r3, #0]
 8000af2:	9a01      	ldr	r2, [sp, #4]
 8000af4:	6852      	ldr	r2, [r2, #4]
 8000af6:	605a      	str	r2, [r3, #4]

  return tp;
 8000af8:	9b01      	ldr	r3, [sp, #4]
}
 8000afa:	4618      	mov	r0, r3
 8000afc:	b002      	add	sp, #8
 8000afe:	4770      	bx	lr

08000b00 <chSchIsRescRequiredI>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 8000b00:	4b06      	ldr	r3, [pc, #24]	; (8000b1c <chSchIsRescRequiredI+0x1c>)
 8000b02:	681b      	ldr	r3, [r3, #0]
 8000b04:	689a      	ldr	r2, [r3, #8]
 8000b06:	4b05      	ldr	r3, [pc, #20]	; (8000b1c <chSchIsRescRequiredI+0x1c>)
 8000b08:	699b      	ldr	r3, [r3, #24]
 8000b0a:	689b      	ldr	r3, [r3, #8]
 8000b0c:	429a      	cmp	r2, r3
 8000b0e:	bf94      	ite	ls
 8000b10:	2300      	movls	r3, #0
 8000b12:	2301      	movhi	r3, #1
 8000b14:	b2db      	uxtb	r3, r3
}
 8000b16:	4618      	mov	r0, r3
 8000b18:	4770      	bx	lr
 8000b1a:	bf00      	nop
 8000b1c:	200016e0 	.word	0x200016e0

08000b20 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8000b20:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8000b22:	f7ff ffa5 	bl	8000a70 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8000b26:	bd08      	pop	{r3, pc}
 8000b28:	f3af 8000 	nop.w
 8000b2c:	f3af 8000 	nop.w

08000b30 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8000b30:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8000b32:	f7ff ffa5 	bl	8000a80 <port_unlock_from_isr>
}
 8000b36:	bd08      	pop	{r3, pc}
 8000b38:	f3af 8000 	nop.w
 8000b3c:	f3af 8000 	nop.w

08000b40 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 8000b40:	b082      	sub	sp, #8
 8000b42:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->vt_func != NULL);
 8000b44:	9b01      	ldr	r3, [sp, #4]
 8000b46:	68db      	ldr	r3, [r3, #12]
 8000b48:	2b00      	cmp	r3, #0
 8000b4a:	bf0c      	ite	eq
 8000b4c:	2300      	moveq	r3, #0
 8000b4e:	2301      	movne	r3, #1
 8000b50:	b2db      	uxtb	r3, r3
}
 8000b52:	4618      	mov	r0, r3
 8000b54:	b002      	add	sp, #8
 8000b56:	4770      	bx	lr
 8000b58:	f3af 8000 	nop.w
 8000b5c:	f3af 8000 	nop.w

08000b60 <chSemFastSignalI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8000b60:	b082      	sub	sp, #8
 8000b62:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  sp->s_cnt++;
 8000b64:	9b01      	ldr	r3, [sp, #4]
 8000b66:	689b      	ldr	r3, [r3, #8]
 8000b68:	1c5a      	adds	r2, r3, #1
 8000b6a:	9b01      	ldr	r3, [sp, #4]
 8000b6c:	609a      	str	r2, [r3, #8]
}
 8000b6e:	b002      	add	sp, #8
 8000b70:	4770      	bx	lr
 8000b72:	bf00      	nop
 8000b74:	f3af 8000 	nop.w
 8000b78:	f3af 8000 	nop.w
 8000b7c:	f3af 8000 	nop.w

08000b80 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 8000b80:	b508      	push	{r3, lr}

  queue_init(&ch.rlist.r_queue);
 8000b82:	4806      	ldr	r0, [pc, #24]	; (8000b9c <_scheduler_init+0x1c>)
 8000b84:	f7ff ff84 	bl	8000a90 <queue_init>
  ch.rlist.r_prio = NOPRIO;
 8000b88:	4b04      	ldr	r3, [pc, #16]	; (8000b9c <_scheduler_init+0x1c>)
 8000b8a:	2200      	movs	r2, #0
 8000b8c:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 8000b8e:	4b03      	ldr	r3, [pc, #12]	; (8000b9c <_scheduler_init+0x1c>)
 8000b90:	4a02      	ldr	r2, [pc, #8]	; (8000b9c <_scheduler_init+0x1c>)
 8000b92:	611a      	str	r2, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 8000b94:	4b01      	ldr	r3, [pc, #4]	; (8000b9c <_scheduler_init+0x1c>)
 8000b96:	4a01      	ldr	r2, [pc, #4]	; (8000b9c <_scheduler_init+0x1c>)
 8000b98:	615a      	str	r2, [r3, #20]
#endif
}
 8000b9a:	bd08      	pop	{r3, pc}
 8000b9c:	200016e0 	.word	0x200016e0

08000ba0 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8000ba0:	b084      	sub	sp, #16
 8000ba2:	9001      	str	r0, [sp, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000ba4:	9b01      	ldr	r3, [sp, #4]
 8000ba6:	2200      	movs	r2, #0
 8000ba8:	771a      	strb	r2, [r3, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8000baa:	4b0e      	ldr	r3, [pc, #56]	; (8000be4 <chSchReadyI+0x44>)
 8000bac:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 8000bae:	9b03      	ldr	r3, [sp, #12]
 8000bb0:	681b      	ldr	r3, [r3, #0]
 8000bb2:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio >= tp->p_prio);
 8000bb4:	9b03      	ldr	r3, [sp, #12]
 8000bb6:	689a      	ldr	r2, [r3, #8]
 8000bb8:	9b01      	ldr	r3, [sp, #4]
 8000bba:	689b      	ldr	r3, [r3, #8]
 8000bbc:	429a      	cmp	r2, r3
 8000bbe:	d2f6      	bcs.n	8000bae <chSchReadyI+0xe>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000bc0:	9b01      	ldr	r3, [sp, #4]
 8000bc2:	9a03      	ldr	r2, [sp, #12]
 8000bc4:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 8000bc6:	9b03      	ldr	r3, [sp, #12]
 8000bc8:	685a      	ldr	r2, [r3, #4]
 8000bca:	9b01      	ldr	r3, [sp, #4]
 8000bcc:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8000bce:	9b01      	ldr	r3, [sp, #4]
 8000bd0:	685b      	ldr	r3, [r3, #4]
 8000bd2:	9a01      	ldr	r2, [sp, #4]
 8000bd4:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 8000bd6:	9b03      	ldr	r3, [sp, #12]
 8000bd8:	9a01      	ldr	r2, [sp, #4]
 8000bda:	605a      	str	r2, [r3, #4]

  return tp;
 8000bdc:	9b01      	ldr	r3, [sp, #4]
}
 8000bde:	4618      	mov	r0, r3
 8000be0:	b004      	add	sp, #16
 8000be2:	4770      	bx	lr
 8000be4:	200016e0 	.word	0x200016e0
 8000be8:	f3af 8000 	nop.w
 8000bec:	f3af 8000 	nop.w

08000bf0 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8000bf0:	b500      	push	{lr}
 8000bf2:	b085      	sub	sp, #20
 8000bf4:	4603      	mov	r3, r0
 8000bf6:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 8000bfa:	4b0e      	ldr	r3, [pc, #56]	; (8000c34 <chSchGoSleepS+0x44>)
 8000bfc:	699b      	ldr	r3, [r3, #24]
 8000bfe:	9303      	str	r3, [sp, #12]
  otp->p_state = newstate;
 8000c00:	9b03      	ldr	r3, [sp, #12]
 8000c02:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8000c06:	771a      	strb	r2, [r3, #28]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 8000c08:	9b03      	ldr	r3, [sp, #12]
 8000c0a:	220a      	movs	r2, #10
 8000c0c:	77da      	strb	r2, [r3, #31]
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000c0e:	4809      	ldr	r0, [pc, #36]	; (8000c34 <chSchGoSleepS+0x44>)
 8000c10:	f7ff ff4e 	bl	8000ab0 <queue_fifo_remove>
 8000c14:	4602      	mov	r2, r0
 8000c16:	4b07      	ldr	r3, [pc, #28]	; (8000c34 <chSchGoSleepS+0x44>)
 8000c18:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000c1a:	4b06      	ldr	r3, [pc, #24]	; (8000c34 <chSchGoSleepS+0x44>)
 8000c1c:	699b      	ldr	r3, [r3, #24]
 8000c1e:	2201      	movs	r2, #1
 8000c20:	771a      	strb	r2, [r3, #28]
  chSysSwitch(currp, otp);
 8000c22:	4b04      	ldr	r3, [pc, #16]	; (8000c34 <chSchGoSleepS+0x44>)
 8000c24:	699b      	ldr	r3, [r3, #24]
 8000c26:	4618      	mov	r0, r3
 8000c28:	9903      	ldr	r1, [sp, #12]
 8000c2a:	f7ff fb59 	bl	80002e0 <_port_switch>
}
 8000c2e:	b005      	add	sp, #20
 8000c30:	f85d fb04 	ldr.w	pc, [sp], #4
 8000c34:	200016e0 	.word	0x200016e0
 8000c38:	f3af 8000 	nop.w
 8000c3c:	f3af 8000 	nop.w

08000c40 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8000c40:	b500      	push	{lr}
 8000c42:	b085      	sub	sp, #20
 8000c44:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
 8000c46:	9b01      	ldr	r3, [sp, #4]
 8000c48:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 8000c4a:	f7ff ff69 	bl	8000b20 <chSysLockFromISR>
  switch (tp->p_state) {
 8000c4e:	9b03      	ldr	r3, [sp, #12]
 8000c50:	7f1b      	ldrb	r3, [r3, #28]
 8000c52:	2b07      	cmp	r3, #7
 8000c54:	d823      	bhi.n	8000c9e <wakeup+0x5e>
 8000c56:	a201      	add	r2, pc, #4	; (adr r2, 8000c5c <wakeup+0x1c>)
 8000c58:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000c5c:	08000c7d 	.word	0x08000c7d
 8000c60:	08000c9f 	.word	0x08000c9f
 8000c64:	08000c9f 	.word	0x08000c9f
 8000c68:	08000c83 	.word	0x08000c83
 8000c6c:	08000c97 	.word	0x08000c97
 8000c70:	08000c8d 	.word	0x08000c8d
 8000c74:	08000c9f 	.word	0x08000c9f
 8000c78:	08000c97 	.word	0x08000c97
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8000c7c:	f7ff ff58 	bl	8000b30 <chSysUnlockFromISR>
    return;
 8000c80:	e017      	b.n	8000cb2 <wakeup+0x72>
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8000c82:	9b03      	ldr	r3, [sp, #12]
 8000c84:	6a1b      	ldr	r3, [r3, #32]
 8000c86:	2200      	movs	r2, #0
 8000c88:	601a      	str	r2, [r3, #0]
    break;
 8000c8a:	e009      	b.n	8000ca0 <wakeup+0x60>
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 8000c8c:	9b03      	ldr	r3, [sp, #12]
 8000c8e:	6a1b      	ldr	r3, [r3, #32]
 8000c90:	4618      	mov	r0, r3
 8000c92:	f7ff ff65 	bl	8000b60 <chSemFastSignalI>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 8000c96:	9803      	ldr	r0, [sp, #12]
 8000c98:	f7ff ff22 	bl	8000ae0 <queue_dequeue>
    break;
 8000c9c:	e000      	b.n	8000ca0 <wakeup+0x60>
  default:
    /* Any other state, nothing to do.*/
    break;
 8000c9e:	bf00      	nop
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8000ca0:	9b03      	ldr	r3, [sp, #12]
 8000ca2:	f04f 32ff 	mov.w	r2, #4294967295
 8000ca6:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 8000ca8:	9803      	ldr	r0, [sp, #12]
 8000caa:	f7ff ff79 	bl	8000ba0 <chSchReadyI>
  chSysUnlockFromISR();
 8000cae:	f7ff ff3f 	bl	8000b30 <chSysUnlockFromISR>
}
 8000cb2:	b005      	add	sp, #20
 8000cb4:	f85d fb04 	ldr.w	pc, [sp], #4
 8000cb8:	f3af 8000 	nop.w
 8000cbc:	f3af 8000 	nop.w

08000cc0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000cc0:	b500      	push	{lr}
 8000cc2:	b089      	sub	sp, #36	; 0x24
 8000cc4:	4603      	mov	r3, r0
 8000cc6:	9100      	str	r1, [sp, #0]
 8000cc8:	f88d 3007 	strb.w	r3, [sp, #7]

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8000ccc:	9b00      	ldr	r3, [sp, #0]
 8000cce:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000cd2:	d019      	beq.n	8000d08 <chSchGoSleepTimeoutS+0x48>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8000cd4:	4b12      	ldr	r3, [pc, #72]	; (8000d20 <chSchGoSleepTimeoutS+0x60>)
 8000cd6:	699b      	ldr	r3, [r3, #24]
 8000cd8:	aa03      	add	r2, sp, #12
 8000cda:	4610      	mov	r0, r2
 8000cdc:	9900      	ldr	r1, [sp, #0]
 8000cde:	4a11      	ldr	r2, [pc, #68]	; (8000d24 <chSchGoSleepTimeoutS+0x64>)
 8000ce0:	f7ff fe56 	bl	8000990 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8000ce4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000ce8:	4618      	mov	r0, r3
 8000cea:	f7ff ff81 	bl	8000bf0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8000cee:	ab03      	add	r3, sp, #12
 8000cf0:	4618      	mov	r0, r3
 8000cf2:	f7ff ff25 	bl	8000b40 <chVTIsArmedI>
 8000cf6:	4603      	mov	r3, r0
 8000cf8:	2b00      	cmp	r3, #0
 8000cfa:	d004      	beq.n	8000d06 <chSchGoSleepTimeoutS+0x46>
      chVTDoResetI(&vt);
 8000cfc:	ab03      	add	r3, sp, #12
 8000cfe:	4618      	mov	r0, r3
 8000d00:	f7ff fe86 	bl	8000a10 <chVTDoResetI>
 8000d04:	e005      	b.n	8000d12 <chSchGoSleepTimeoutS+0x52>
 8000d06:	e004      	b.n	8000d12 <chSchGoSleepTimeoutS+0x52>
    }
  }
  else {
    chSchGoSleepS(newstate);
 8000d08:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000d0c:	4618      	mov	r0, r3
 8000d0e:	f7ff ff6f 	bl	8000bf0 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 8000d12:	4b03      	ldr	r3, [pc, #12]	; (8000d20 <chSchGoSleepTimeoutS+0x60>)
 8000d14:	699b      	ldr	r3, [r3, #24]
 8000d16:	6a1b      	ldr	r3, [r3, #32]
}
 8000d18:	4618      	mov	r0, r3
 8000d1a:	b009      	add	sp, #36	; 0x24
 8000d1c:	f85d fb04 	ldr.w	pc, [sp], #4
 8000d20:	200016e0 	.word	0x200016e0
 8000d24:	08000c41 	.word	0x08000c41
 8000d28:	f3af 8000 	nop.w
 8000d2c:	f3af 8000 	nop.w

08000d30 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000d30:	b500      	push	{lr}
 8000d32:	b085      	sub	sp, #20
 8000d34:	9001      	str	r0, [sp, #4]
 8000d36:	9100      	str	r1, [sp, #0]
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8000d38:	9b01      	ldr	r3, [sp, #4]
 8000d3a:	9a00      	ldr	r2, [sp, #0]
 8000d3c:	621a      	str	r2, [r3, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8000d3e:	9b01      	ldr	r3, [sp, #4]
 8000d40:	689a      	ldr	r2, [r3, #8]
 8000d42:	4b0e      	ldr	r3, [pc, #56]	; (8000d7c <chSchWakeupS+0x4c>)
 8000d44:	699b      	ldr	r3, [r3, #24]
 8000d46:	689b      	ldr	r3, [r3, #8]
 8000d48:	429a      	cmp	r2, r3
 8000d4a:	d803      	bhi.n	8000d54 <chSchWakeupS+0x24>
    (void) chSchReadyI(ntp);
 8000d4c:	9801      	ldr	r0, [sp, #4]
 8000d4e:	f7ff ff27 	bl	8000ba0 <chSchReadyI>
 8000d52:	e00f      	b.n	8000d74 <chSchWakeupS+0x44>
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8000d54:	4b09      	ldr	r3, [pc, #36]	; (8000d7c <chSchWakeupS+0x4c>)
 8000d56:	699b      	ldr	r3, [r3, #24]
 8000d58:	4618      	mov	r0, r3
 8000d5a:	f7ff ff21 	bl	8000ba0 <chSchReadyI>
 8000d5e:	9003      	str	r0, [sp, #12]
    setcurrp(ntp);
 8000d60:	4b06      	ldr	r3, [pc, #24]	; (8000d7c <chSchWakeupS+0x4c>)
 8000d62:	9a01      	ldr	r2, [sp, #4]
 8000d64:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8000d66:	9b01      	ldr	r3, [sp, #4]
 8000d68:	2201      	movs	r2, #1
 8000d6a:	771a      	strb	r2, [r3, #28]
    chSysSwitch(ntp, otp);
 8000d6c:	9801      	ldr	r0, [sp, #4]
 8000d6e:	9903      	ldr	r1, [sp, #12]
 8000d70:	f7ff fab6 	bl	80002e0 <_port_switch>
  }
}
 8000d74:	b005      	add	sp, #20
 8000d76:	f85d fb04 	ldr.w	pc, [sp], #4
 8000d7a:	bf00      	nop
 8000d7c:	200016e0 	.word	0x200016e0

08000d80 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8000d80:	b508      	push	{r3, lr}

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 8000d82:	f7ff febd 	bl	8000b00 <chSchIsRescRequiredI>
 8000d86:	4603      	mov	r3, r0
 8000d88:	2b00      	cmp	r3, #0
 8000d8a:	d001      	beq.n	8000d90 <chSchRescheduleS+0x10>
    chSchDoRescheduleAhead();
 8000d8c:	f000 f850 	bl	8000e30 <chSchDoRescheduleAhead>
  }
}
 8000d90:	bd08      	pop	{r3, pc}
 8000d92:	bf00      	nop
 8000d94:	f3af 8000 	nop.w
 8000d98:	f3af 8000 	nop.w
 8000d9c:	f3af 8000 	nop.w

08000da0 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8000da0:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8000da2:	4b0f      	ldr	r3, [pc, #60]	; (8000de0 <chSchIsPreemptionRequired+0x40>)
 8000da4:	681b      	ldr	r3, [r3, #0]
 8000da6:	689b      	ldr	r3, [r3, #8]
 8000da8:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->p_prio;
 8000daa:	4b0d      	ldr	r3, [pc, #52]	; (8000de0 <chSchIsPreemptionRequired+0x40>)
 8000dac:	699b      	ldr	r3, [r3, #24]
 8000dae:	689b      	ldr	r3, [r3, #8]
 8000db0:	9300      	str	r3, [sp, #0]
#if CH_CFG_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
 8000db2:	4b0b      	ldr	r3, [pc, #44]	; (8000de0 <chSchIsPreemptionRequired+0x40>)
 8000db4:	699b      	ldr	r3, [r3, #24]
 8000db6:	7fdb      	ldrb	r3, [r3, #31]
 8000db8:	2b00      	cmp	r3, #0
 8000dba:	d007      	beq.n	8000dcc <chSchIsPreemptionRequired+0x2c>
 8000dbc:	9a01      	ldr	r2, [sp, #4]
 8000dbe:	9b00      	ldr	r3, [sp, #0]
 8000dc0:	429a      	cmp	r2, r3
 8000dc2:	bf94      	ite	ls
 8000dc4:	2300      	movls	r3, #0
 8000dc6:	2301      	movhi	r3, #1
 8000dc8:	b2db      	uxtb	r3, r3
 8000dca:	e006      	b.n	8000dda <chSchIsPreemptionRequired+0x3a>
 8000dcc:	9a01      	ldr	r2, [sp, #4]
 8000dce:	9b00      	ldr	r3, [sp, #0]
 8000dd0:	429a      	cmp	r2, r3
 8000dd2:	bf34      	ite	cc
 8000dd4:	2300      	movcc	r3, #0
 8000dd6:	2301      	movcs	r3, #1
 8000dd8:	b2db      	uxtb	r3, r3
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
#endif
}
 8000dda:	4618      	mov	r0, r3
 8000ddc:	b002      	add	sp, #8
 8000dde:	4770      	bx	lr
 8000de0:	200016e0 	.word	0x200016e0
 8000de4:	f3af 8000 	nop.w
 8000de8:	f3af 8000 	nop.w
 8000dec:	f3af 8000 	nop.w

08000df0 <chSchDoRescheduleBehind>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleBehind(void) {
 8000df0:	b500      	push	{lr}
 8000df2:	b083      	sub	sp, #12
  thread_t *otp;

  otp = currp;
 8000df4:	4b0d      	ldr	r3, [pc, #52]	; (8000e2c <chSchDoRescheduleBehind+0x3c>)
 8000df6:	699b      	ldr	r3, [r3, #24]
 8000df8:	9301      	str	r3, [sp, #4]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000dfa:	480c      	ldr	r0, [pc, #48]	; (8000e2c <chSchDoRescheduleBehind+0x3c>)
 8000dfc:	f7ff fe58 	bl	8000ab0 <queue_fifo_remove>
 8000e00:	4602      	mov	r2, r0
 8000e02:	4b0a      	ldr	r3, [pc, #40]	; (8000e2c <chSchDoRescheduleBehind+0x3c>)
 8000e04:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000e06:	4b09      	ldr	r3, [pc, #36]	; (8000e2c <chSchDoRescheduleBehind+0x3c>)
 8000e08:	699b      	ldr	r3, [r3, #24]
 8000e0a:	2201      	movs	r2, #1
 8000e0c:	771a      	strb	r2, [r3, #28]
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 8000e0e:	9b01      	ldr	r3, [sp, #4]
 8000e10:	220a      	movs	r2, #10
 8000e12:	77da      	strb	r2, [r3, #31]
#endif
  (void) chSchReadyI(otp);
 8000e14:	9801      	ldr	r0, [sp, #4]
 8000e16:	f7ff fec3 	bl	8000ba0 <chSchReadyI>
  chSysSwitch(currp, otp);
 8000e1a:	4b04      	ldr	r3, [pc, #16]	; (8000e2c <chSchDoRescheduleBehind+0x3c>)
 8000e1c:	699b      	ldr	r3, [r3, #24]
 8000e1e:	4618      	mov	r0, r3
 8000e20:	9901      	ldr	r1, [sp, #4]
 8000e22:	f7ff fa5d 	bl	80002e0 <_port_switch>
}
 8000e26:	b003      	add	sp, #12
 8000e28:	f85d fb04 	ldr.w	pc, [sp], #4
 8000e2c:	200016e0 	.word	0x200016e0

08000e30 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8000e30:	b500      	push	{lr}
 8000e32:	b083      	sub	sp, #12
  thread_t *otp, *cp;

  otp = currp;
 8000e34:	4b18      	ldr	r3, [pc, #96]	; (8000e98 <chSchDoRescheduleAhead+0x68>)
 8000e36:	699b      	ldr	r3, [r3, #24]
 8000e38:	9300      	str	r3, [sp, #0]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000e3a:	4817      	ldr	r0, [pc, #92]	; (8000e98 <chSchDoRescheduleAhead+0x68>)
 8000e3c:	f7ff fe38 	bl	8000ab0 <queue_fifo_remove>
 8000e40:	4602      	mov	r2, r0
 8000e42:	4b15      	ldr	r3, [pc, #84]	; (8000e98 <chSchDoRescheduleAhead+0x68>)
 8000e44:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000e46:	4b14      	ldr	r3, [pc, #80]	; (8000e98 <chSchDoRescheduleAhead+0x68>)
 8000e48:	699b      	ldr	r3, [r3, #24]
 8000e4a:	2201      	movs	r2, #1
 8000e4c:	771a      	strb	r2, [r3, #28]

  otp->p_state = CH_STATE_READY;
 8000e4e:	9b00      	ldr	r3, [sp, #0]
 8000e50:	2200      	movs	r2, #0
 8000e52:	771a      	strb	r2, [r3, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8000e54:	4b10      	ldr	r3, [pc, #64]	; (8000e98 <chSchDoRescheduleAhead+0x68>)
 8000e56:	9301      	str	r3, [sp, #4]
  do {
    cp = cp->p_next;
 8000e58:	9b01      	ldr	r3, [sp, #4]
 8000e5a:	681b      	ldr	r3, [r3, #0]
 8000e5c:	9301      	str	r3, [sp, #4]
  } while (cp->p_prio > otp->p_prio);
 8000e5e:	9b01      	ldr	r3, [sp, #4]
 8000e60:	689a      	ldr	r2, [r3, #8]
 8000e62:	9b00      	ldr	r3, [sp, #0]
 8000e64:	689b      	ldr	r3, [r3, #8]
 8000e66:	429a      	cmp	r2, r3
 8000e68:	d8f6      	bhi.n	8000e58 <chSchDoRescheduleAhead+0x28>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8000e6a:	9b00      	ldr	r3, [sp, #0]
 8000e6c:	9a01      	ldr	r2, [sp, #4]
 8000e6e:	601a      	str	r2, [r3, #0]
  otp->p_prev = cp->p_prev;
 8000e70:	9b01      	ldr	r3, [sp, #4]
 8000e72:	685a      	ldr	r2, [r3, #4]
 8000e74:	9b00      	ldr	r3, [sp, #0]
 8000e76:	605a      	str	r2, [r3, #4]
  otp->p_prev->p_next = otp;
 8000e78:	9b00      	ldr	r3, [sp, #0]
 8000e7a:	685b      	ldr	r3, [r3, #4]
 8000e7c:	9a00      	ldr	r2, [sp, #0]
 8000e7e:	601a      	str	r2, [r3, #0]
  cp->p_prev = otp;
 8000e80:	9b01      	ldr	r3, [sp, #4]
 8000e82:	9a00      	ldr	r2, [sp, #0]
 8000e84:	605a      	str	r2, [r3, #4]

  chSysSwitch(currp, otp);
 8000e86:	4b04      	ldr	r3, [pc, #16]	; (8000e98 <chSchDoRescheduleAhead+0x68>)
 8000e88:	699b      	ldr	r3, [r3, #24]
 8000e8a:	4618      	mov	r0, r3
 8000e8c:	9900      	ldr	r1, [sp, #0]
 8000e8e:	f7ff fa27 	bl	80002e0 <_port_switch>
}
 8000e92:	b003      	add	sp, #12
 8000e94:	f85d fb04 	ldr.w	pc, [sp], #4
 8000e98:	200016e0 	.word	0x200016e0
 8000e9c:	f3af 8000 	nop.w

08000ea0 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8000ea0:	b508      	push	{r3, lr}

#if CH_CFG_TIME_QUANTUM > 0
  /* If CH_CFG_TIME_QUANTUM is enabled then there are two different scenarios
     to handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == (tslices_t)0) {
 8000ea2:	4b05      	ldr	r3, [pc, #20]	; (8000eb8 <chSchDoReschedule+0x18>)
 8000ea4:	699b      	ldr	r3, [r3, #24]
 8000ea6:	7fdb      	ldrb	r3, [r3, #31]
 8000ea8:	2b00      	cmp	r3, #0
 8000eaa:	d102      	bne.n	8000eb2 <chSchDoReschedule+0x12>
    /* The thread consumed its time quantum so it is enqueued behind threads
       with same priority level, however, it acquires a new time quantum.*/
    chSchDoRescheduleBehind();
 8000eac:	f7ff ffa0 	bl	8000df0 <chSchDoRescheduleBehind>
 8000eb0:	e001      	b.n	8000eb6 <chSchDoReschedule+0x16>
  }
  else {
    /* The thread didn't consume all its time quantum so it is put ahead of
       threads with equal priority and does not acquire a new time quantum.*/
    chSchDoRescheduleAhead();
 8000eb2:	f7ff ffbd 	bl	8000e30 <chSchDoRescheduleAhead>
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 8000eb6:	bd08      	pop	{r3, pc}
 8000eb8:	200016e0 	.word	0x200016e0
 8000ebc:	f3af 8000 	nop.w

08000ec0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8000ec0:	b082      	sub	sp, #8
 8000ec2:	2320      	movs	r3, #32
 8000ec4:	9301      	str	r3, [sp, #4]
 8000ec6:	9b01      	ldr	r3, [sp, #4]
 8000ec8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000ecc:	b002      	add	sp, #8
 8000ece:	4770      	bx	lr

08000ed0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8000ed0:	b082      	sub	sp, #8
 8000ed2:	2300      	movs	r3, #0
 8000ed4:	9301      	str	r3, [sp, #4]
 8000ed6:	9b01      	ldr	r3, [sp, #4]
 8000ed8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000edc:	b002      	add	sp, #8
 8000ede:	4770      	bx	lr

08000ee0 <list_init>:
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
 8000ee0:	b082      	sub	sp, #8
 8000ee2:	9001      	str	r0, [sp, #4]

  tlp->p_next = (thread_t *)tlp;
 8000ee4:	9b01      	ldr	r3, [sp, #4]
 8000ee6:	9a01      	ldr	r2, [sp, #4]
 8000ee8:	601a      	str	r2, [r3, #0]
}
 8000eea:	b002      	add	sp, #8
 8000eec:	4770      	bx	lr
 8000eee:	bf00      	nop

08000ef0 <list_notempty>:
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
 8000ef0:	b082      	sub	sp, #8
 8000ef2:	9001      	str	r0, [sp, #4]

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8000ef4:	9b01      	ldr	r3, [sp, #4]
 8000ef6:	681a      	ldr	r2, [r3, #0]
 8000ef8:	9b01      	ldr	r3, [sp, #4]
 8000efa:	429a      	cmp	r2, r3
 8000efc:	bf0c      	ite	eq
 8000efe:	2300      	moveq	r3, #0
 8000f00:	2301      	movne	r3, #1
 8000f02:	b2db      	uxtb	r3, r3
}
 8000f04:	4618      	mov	r0, r3
 8000f06:	b002      	add	sp, #8
 8000f08:	4770      	bx	lr
 8000f0a:	bf00      	nop
 8000f0c:	f3af 8000 	nop.w

08000f10 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8000f10:	b082      	sub	sp, #8
 8000f12:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8000f14:	9b01      	ldr	r3, [sp, #4]
 8000f16:	9a01      	ldr	r2, [sp, #4]
 8000f18:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8000f1a:	9b01      	ldr	r3, [sp, #4]
 8000f1c:	9a01      	ldr	r2, [sp, #4]
 8000f1e:	605a      	str	r2, [r3, #4]
}
 8000f20:	b002      	add	sp, #8
 8000f22:	4770      	bx	lr
 8000f24:	f3af 8000 	nop.w
 8000f28:	f3af 8000 	nop.w
 8000f2c:	f3af 8000 	nop.w

08000f30 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8000f30:	b082      	sub	sp, #8
 8000f32:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8000f34:	9b01      	ldr	r3, [sp, #4]
 8000f36:	681a      	ldr	r2, [r3, #0]
 8000f38:	9b01      	ldr	r3, [sp, #4]
 8000f3a:	429a      	cmp	r2, r3
 8000f3c:	bf0c      	ite	eq
 8000f3e:	2300      	moveq	r3, #0
 8000f40:	2301      	movne	r3, #1
 8000f42:	b2db      	uxtb	r3, r3
}
 8000f44:	4618      	mov	r0, r3
 8000f46:	b002      	add	sp, #8
 8000f48:	4770      	bx	lr
 8000f4a:	bf00      	nop
 8000f4c:	f3af 8000 	nop.w

08000f50 <list_insert>:

/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void list_insert(thread_t *tp, threads_list_t *tlp) {
 8000f50:	b082      	sub	sp, #8
 8000f52:	9001      	str	r0, [sp, #4]
 8000f54:	9100      	str	r1, [sp, #0]

  tp->p_next = tlp->p_next;
 8000f56:	9b00      	ldr	r3, [sp, #0]
 8000f58:	681a      	ldr	r2, [r3, #0]
 8000f5a:	9b01      	ldr	r3, [sp, #4]
 8000f5c:	601a      	str	r2, [r3, #0]
  tlp->p_next = tp;
 8000f5e:	9b00      	ldr	r3, [sp, #0]
 8000f60:	9a01      	ldr	r2, [sp, #4]
 8000f62:	601a      	str	r2, [r3, #0]
}
 8000f64:	b002      	add	sp, #8
 8000f66:	4770      	bx	lr
 8000f68:	f3af 8000 	nop.w
 8000f6c:	f3af 8000 	nop.w

08000f70 <list_remove>:

static inline thread_t *list_remove(threads_list_t *tlp) {
 8000f70:	b084      	sub	sp, #16
 8000f72:	9001      	str	r0, [sp, #4]

  thread_t *tp = tlp->p_next;
 8000f74:	9b01      	ldr	r3, [sp, #4]
 8000f76:	681b      	ldr	r3, [r3, #0]
 8000f78:	9303      	str	r3, [sp, #12]
  tlp->p_next = tp->p_next;
 8000f7a:	9b03      	ldr	r3, [sp, #12]
 8000f7c:	681a      	ldr	r2, [r3, #0]
 8000f7e:	9b01      	ldr	r3, [sp, #4]
 8000f80:	601a      	str	r2, [r3, #0]

  return tp;
 8000f82:	9b03      	ldr	r3, [sp, #12]
}
 8000f84:	4618      	mov	r0, r3
 8000f86:	b004      	add	sp, #16
 8000f88:	4770      	bx	lr
 8000f8a:	bf00      	nop
 8000f8c:	f3af 8000 	nop.w

08000f90 <queue_insert>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8000f90:	b082      	sub	sp, #8
 8000f92:	9001      	str	r0, [sp, #4]
 8000f94:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 8000f96:	9b01      	ldr	r3, [sp, #4]
 8000f98:	9a00      	ldr	r2, [sp, #0]
 8000f9a:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 8000f9c:	9b00      	ldr	r3, [sp, #0]
 8000f9e:	685a      	ldr	r2, [r3, #4]
 8000fa0:	9b01      	ldr	r3, [sp, #4]
 8000fa2:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8000fa4:	9b01      	ldr	r3, [sp, #4]
 8000fa6:	685b      	ldr	r3, [r3, #4]
 8000fa8:	9a01      	ldr	r2, [sp, #4]
 8000faa:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 8000fac:	9b00      	ldr	r3, [sp, #0]
 8000fae:	9a01      	ldr	r2, [sp, #4]
 8000fb0:	605a      	str	r2, [r3, #4]
}
 8000fb2:	b002      	add	sp, #8
 8000fb4:	4770      	bx	lr
 8000fb6:	bf00      	nop
 8000fb8:	f3af 8000 	nop.w
 8000fbc:	f3af 8000 	nop.w

08000fc0 <queue_fifo_remove>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8000fc0:	b084      	sub	sp, #16
 8000fc2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8000fc4:	9b01      	ldr	r3, [sp, #4]
 8000fc6:	681b      	ldr	r3, [r3, #0]
 8000fc8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8000fca:	9b03      	ldr	r3, [sp, #12]
 8000fcc:	681a      	ldr	r2, [r3, #0]
 8000fce:	9b01      	ldr	r3, [sp, #4]
 8000fd0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000fd2:	9b01      	ldr	r3, [sp, #4]
 8000fd4:	681b      	ldr	r3, [r3, #0]
 8000fd6:	9a01      	ldr	r2, [sp, #4]
 8000fd8:	605a      	str	r2, [r3, #4]

  return tp;
 8000fda:	9b03      	ldr	r3, [sp, #12]
}
 8000fdc:	4618      	mov	r0, r3
 8000fde:	b004      	add	sp, #16
 8000fe0:	4770      	bx	lr
 8000fe2:	bf00      	nop
 8000fe4:	f3af 8000 	nop.w
 8000fe8:	f3af 8000 	nop.w
 8000fec:	f3af 8000 	nop.w

08000ff0 <chSchCanYieldS>:
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.r_queue) >= currp->p_prio;
 8000ff0:	4b06      	ldr	r3, [pc, #24]	; (800100c <chSchCanYieldS+0x1c>)
 8000ff2:	681b      	ldr	r3, [r3, #0]
 8000ff4:	689a      	ldr	r2, [r3, #8]
 8000ff6:	4b05      	ldr	r3, [pc, #20]	; (800100c <chSchCanYieldS+0x1c>)
 8000ff8:	699b      	ldr	r3, [r3, #24]
 8000ffa:	689b      	ldr	r3, [r3, #8]
 8000ffc:	429a      	cmp	r2, r3
 8000ffe:	bf34      	ite	cc
 8001000:	2300      	movcc	r3, #0
 8001002:	2301      	movcs	r3, #1
 8001004:	b2db      	uxtb	r3, r3
}
 8001006:	4618      	mov	r0, r3
 8001008:	4770      	bx	lr
 800100a:	bf00      	nop
 800100c:	200016e0 	.word	0x200016e0

08001010 <chSchDoYieldS>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal or higher priority, if any.
 *
 * @sclass
 */
static inline void chSchDoYieldS(void) {
 8001010:	b508      	push	{r3, lr}

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 8001012:	f7ff ffed 	bl	8000ff0 <chSchCanYieldS>
 8001016:	4603      	mov	r3, r0
 8001018:	2b00      	cmp	r3, #0
 800101a:	d001      	beq.n	8001020 <chSchDoYieldS+0x10>
    chSchDoRescheduleBehind();
 800101c:	f7ff fee8 	bl	8000df0 <chSchDoRescheduleBehind>
  }
}
 8001020:	bd08      	pop	{r3, pc}
 8001022:	bf00      	nop
 8001024:	f3af 8000 	nop.w
 8001028:	f3af 8000 	nop.w
 800102c:	f3af 8000 	nop.w

08001030 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001030:	b508      	push	{r3, lr}

  port_lock();
 8001032:	f7ff ff45 	bl	8000ec0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001036:	bd08      	pop	{r3, pc}
 8001038:	f3af 8000 	nop.w
 800103c:	f3af 8000 	nop.w

08001040 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001040:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001042:	f7ff ff45 	bl	8000ed0 <port_unlock>
}
 8001046:	bd08      	pop	{r3, pc}
 8001048:	f3af 8000 	nop.w
 800104c:	f3af 8000 	nop.w

08001050 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 8001050:	4b01      	ldr	r3, [pc, #4]	; (8001058 <chVTGetSystemTimeX+0x8>)
 8001052:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001054:	4618      	mov	r0, r3
 8001056:	4770      	bx	lr
 8001058:	200016e0 	.word	0x200016e0
 800105c:	f3af 8000 	nop.w

08001060 <chVTIsTimeWithinX>:
 *
 * @xclass
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {
 8001060:	b084      	sub	sp, #16
 8001062:	9003      	str	r0, [sp, #12]
 8001064:	9102      	str	r1, [sp, #8]
 8001066:	9201      	str	r2, [sp, #4]

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 8001068:	9a03      	ldr	r2, [sp, #12]
 800106a:	9b02      	ldr	r3, [sp, #8]
 800106c:	1ad2      	subs	r2, r2, r3
 800106e:	9901      	ldr	r1, [sp, #4]
 8001070:	9b02      	ldr	r3, [sp, #8]
 8001072:	1acb      	subs	r3, r1, r3
 8001074:	429a      	cmp	r2, r3
 8001076:	bf2c      	ite	cs
 8001078:	2300      	movcs	r3, #0
 800107a:	2301      	movcc	r3, #1
 800107c:	b2db      	uxtb	r3, r3
}
 800107e:	4618      	mov	r0, r3
 8001080:	b004      	add	sp, #16
 8001082:	4770      	bx	lr
 8001084:	f3af 8000 	nop.w
 8001088:	f3af 8000 	nop.w
 800108c:	f3af 8000 	nop.w

08001090 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001090:	4b01      	ldr	r3, [pc, #4]	; (8001098 <chThdGetSelfX+0x8>)
 8001092:	699b      	ldr	r3, [r3, #24]
}
 8001094:	4618      	mov	r0, r3
 8001096:	4770      	bx	lr
 8001098:	200016e0 	.word	0x200016e0
 800109c:	f3af 8000 	nop.w

080010a0 <chThdStartI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
static inline thread_t *chThdStartI(thread_t *tp) {
 80010a0:	b500      	push	{lr}
 80010a2:	b083      	sub	sp, #12
 80010a4:	9001      	str	r0, [sp, #4]

  chDbgAssert(tp->p_state == CH_STATE_WTSTART, "wrong state");

  return chSchReadyI(tp);
 80010a6:	9801      	ldr	r0, [sp, #4]
 80010a8:	f7ff fd7a 	bl	8000ba0 <chSchReadyI>
 80010ac:	4603      	mov	r3, r0
}
 80010ae:	4618      	mov	r0, r3
 80010b0:	b003      	add	sp, #12
 80010b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80010b6:	bf00      	nop
 80010b8:	f3af 8000 	nop.w
 80010bc:	f3af 8000 	nop.w

080010c0 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {
 80010c0:	b500      	push	{lr}
 80010c2:	b083      	sub	sp, #12
 80010c4:	9001      	str	r0, [sp, #4]

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 80010c6:	2008      	movs	r0, #8
 80010c8:	9901      	ldr	r1, [sp, #4]
 80010ca:	f7ff fdf9 	bl	8000cc0 <chSchGoSleepTimeoutS>
}
 80010ce:	b003      	add	sp, #12
 80010d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80010d4:	f3af 8000 	nop.w
 80010d8:	f3af 8000 	nop.w
 80010dc:	f3af 8000 	nop.w

080010e0 <chThdDoDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80010e0:	b500      	push	{lr}
 80010e2:	b085      	sub	sp, #20
 80010e4:	9001      	str	r0, [sp, #4]
 80010e6:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);
 80010e8:	9801      	ldr	r0, [sp, #4]
 80010ea:	f7ff ff69 	bl	8000fc0 <queue_fifo_remove>
 80010ee:	9003      	str	r0, [sp, #12]

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 80010f0:	9b03      	ldr	r3, [sp, #12]
 80010f2:	9a00      	ldr	r2, [sp, #0]
 80010f4:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 80010f6:	9803      	ldr	r0, [sp, #12]
 80010f8:	f7ff fd52 	bl	8000ba0 <chSchReadyI>
}
 80010fc:	b005      	add	sp, #20
 80010fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8001102:	bf00      	nop
 8001104:	f3af 8000 	nop.w
 8001108:	f3af 8000 	nop.w
 800110c:	f3af 8000 	nop.w

08001110 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 8001110:	b500      	push	{lr}
 8001112:	b083      	sub	sp, #12
 8001114:	9001      	str	r0, [sp, #4]
 8001116:	9100      	str	r1, [sp, #0]

  tp->p_prio = prio;
 8001118:	9b01      	ldr	r3, [sp, #4]
 800111a:	9a00      	ldr	r2, [sp, #0]
 800111c:	609a      	str	r2, [r3, #8]
  tp->p_state = CH_STATE_WTSTART;
 800111e:	9b01      	ldr	r3, [sp, #4]
 8001120:	2202      	movs	r2, #2
 8001122:	771a      	strb	r2, [r3, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8001124:	9b01      	ldr	r3, [sp, #4]
 8001126:	2200      	movs	r2, #0
 8001128:	775a      	strb	r2, [r3, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 800112a:	9b01      	ldr	r3, [sp, #4]
 800112c:	220a      	movs	r2, #10
 800112e:	77da      	strb	r2, [r3, #31]
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8001130:	9b01      	ldr	r3, [sp, #4]
 8001132:	9a00      	ldr	r2, [sp, #0]
 8001134:	63da      	str	r2, [r3, #60]	; 0x3c
  tp->p_mtxlist = NULL;
 8001136:	9b01      	ldr	r3, [sp, #4]
 8001138:	2200      	movs	r2, #0
 800113a:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 800113c:	9b01      	ldr	r3, [sp, #4]
 800113e:	2200      	movs	r2, #0
 8001140:	635a      	str	r2, [r3, #52]	; 0x34
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8001142:	9b01      	ldr	r3, [sp, #4]
 8001144:	2201      	movs	r2, #1
 8001146:	779a      	strb	r2, [r3, #30]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8001148:	9b01      	ldr	r3, [sp, #4]
 800114a:	2200      	movs	r2, #0
 800114c:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 800114e:	9b01      	ldr	r3, [sp, #4]
 8001150:	4a0d      	ldr	r2, [pc, #52]	; (8001188 <_thread_init+0x78>)
 8001152:	611a      	str	r2, [r3, #16]
 8001154:	4b0c      	ldr	r3, [pc, #48]	; (8001188 <_thread_init+0x78>)
 8001156:	695a      	ldr	r2, [r3, #20]
 8001158:	9b01      	ldr	r3, [sp, #4]
 800115a:	615a      	str	r2, [r3, #20]
 800115c:	9b01      	ldr	r3, [sp, #4]
 800115e:	695b      	ldr	r3, [r3, #20]
 8001160:	9a01      	ldr	r2, [sp, #4]
 8001162:	611a      	str	r2, [r3, #16]
 8001164:	4b08      	ldr	r3, [pc, #32]	; (8001188 <_thread_init+0x78>)
 8001166:	9a01      	ldr	r2, [sp, #4]
 8001168:	615a      	str	r2, [r3, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 800116a:	9b01      	ldr	r3, [sp, #4]
 800116c:	3324      	adds	r3, #36	; 0x24
 800116e:	4618      	mov	r0, r3
 8001170:	f7ff feb6 	bl	8000ee0 <list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 8001174:	9b01      	ldr	r3, [sp, #4]
 8001176:	3328      	adds	r3, #40	; 0x28
 8001178:	4618      	mov	r0, r3
 800117a:	f7ff fec9 	bl	8000f10 <queue_init>
  chTMObjectInit(&tp->p_stats);
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
 800117e:	9b01      	ldr	r3, [sp, #4]
}
 8001180:	4618      	mov	r0, r3
 8001182:	b003      	add	sp, #12
 8001184:	f85d fb04 	ldr.w	pc, [sp], #4
 8001188:	200016e0 	.word	0x200016e0
 800118c:	f3af 8000 	nop.w

08001190 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 8001190:	b500      	push	{lr}
 8001192:	b087      	sub	sp, #28
 8001194:	9003      	str	r0, [sp, #12]
 8001196:	9102      	str	r1, [sp, #8]
 8001198:	9201      	str	r2, [sp, #4]
 800119a:	9300      	str	r3, [sp, #0]
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;
 800119c:	9b03      	ldr	r3, [sp, #12]
 800119e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80011a0:	9b02      	ldr	r3, [sp, #8]
 80011a2:	3b24      	subs	r3, #36	; 0x24
 80011a4:	9a03      	ldr	r2, [sp, #12]
 80011a6:	441a      	add	r2, r3
 80011a8:	9b05      	ldr	r3, [sp, #20]
 80011aa:	60da      	str	r2, [r3, #12]
 80011ac:	9b05      	ldr	r3, [sp, #20]
 80011ae:	68db      	ldr	r3, [r3, #12]
 80011b0:	9a00      	ldr	r2, [sp, #0]
 80011b2:	601a      	str	r2, [r3, #0]
 80011b4:	9b05      	ldr	r3, [sp, #20]
 80011b6:	68db      	ldr	r3, [r3, #12]
 80011b8:	9a08      	ldr	r2, [sp, #32]
 80011ba:	605a      	str	r2, [r3, #4]
 80011bc:	9b05      	ldr	r3, [sp, #20]
 80011be:	68db      	ldr	r3, [r3, #12]
 80011c0:	4a05      	ldr	r2, [pc, #20]	; (80011d8 <chThdCreateI+0x48>)
 80011c2:	621a      	str	r2, [r3, #32]

  return _thread_init(tp, prio);
 80011c4:	9805      	ldr	r0, [sp, #20]
 80011c6:	9901      	ldr	r1, [sp, #4]
 80011c8:	f7ff ffa2 	bl	8001110 <_thread_init>
 80011cc:	4603      	mov	r3, r0
}
 80011ce:	4618      	mov	r0, r3
 80011d0:	b007      	add	sp, #28
 80011d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80011d6:	bf00      	nop
 80011d8:	080002f1 	.word	0x080002f1
 80011dc:	f3af 8000 	nop.w

080011e0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 80011e0:	b500      	push	{lr}
 80011e2:	b089      	sub	sp, #36	; 0x24
 80011e4:	9005      	str	r0, [sp, #20]
 80011e6:	9104      	str	r1, [sp, #16]
 80011e8:	9203      	str	r2, [sp, #12]
 80011ea:	9302      	str	r3, [sp, #8]
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 80011ec:	f7ff ff20 	bl	8001030 <chSysLock>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 80011f0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80011f2:	9300      	str	r3, [sp, #0]
 80011f4:	9805      	ldr	r0, [sp, #20]
 80011f6:	9904      	ldr	r1, [sp, #16]
 80011f8:	9a03      	ldr	r2, [sp, #12]
 80011fa:	9b02      	ldr	r3, [sp, #8]
 80011fc:	f7ff ffc8 	bl	8001190 <chThdCreateI>
 8001200:	9007      	str	r0, [sp, #28]
  chSchWakeupS(tp, MSG_OK);
 8001202:	9807      	ldr	r0, [sp, #28]
 8001204:	2100      	movs	r1, #0
 8001206:	f7ff fd93 	bl	8000d30 <chSchWakeupS>
  chSysUnlock();
 800120a:	f7ff ff19 	bl	8001040 <chSysUnlock>

  return tp;
 800120e:	9b07      	ldr	r3, [sp, #28]
}
 8001210:	4618      	mov	r0, r3
 8001212:	b009      	add	sp, #36	; 0x24
 8001214:	f85d fb04 	ldr.w	pc, [sp], #4
 8001218:	f3af 8000 	nop.w
 800121c:	f3af 8000 	nop.w

08001220 <chThdStart>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdStart(thread_t *tp) {
 8001220:	b500      	push	{lr}
 8001222:	b083      	sub	sp, #12
 8001224:	9001      	str	r0, [sp, #4]

  chSysLock();
 8001226:	f7ff ff03 	bl	8001030 <chSysLock>
  tp = chThdStartI(tp);
 800122a:	9801      	ldr	r0, [sp, #4]
 800122c:	f7ff ff38 	bl	80010a0 <chThdStartI>
 8001230:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 8001232:	f7ff ff05 	bl	8001040 <chSysUnlock>

  return tp;
 8001236:	9b01      	ldr	r3, [sp, #4]
}
 8001238:	4618      	mov	r0, r3
 800123a:	b003      	add	sp, #12
 800123c:	f85d fb04 	ldr.w	pc, [sp], #4

08001240 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 8001240:	b500      	push	{lr}
 8001242:	b085      	sub	sp, #20
 8001244:	9001      	str	r0, [sp, #4]
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO);

  chSysLock();
 8001246:	f7ff fef3 	bl	8001030 <chSysLock>
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->p_realprio;
 800124a:	4b11      	ldr	r3, [pc, #68]	; (8001290 <chThdSetPriority+0x50>)
 800124c:	699b      	ldr	r3, [r3, #24]
 800124e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001250:	9303      	str	r3, [sp, #12]
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio)) {
 8001252:	4b0f      	ldr	r3, [pc, #60]	; (8001290 <chThdSetPriority+0x50>)
 8001254:	699b      	ldr	r3, [r3, #24]
 8001256:	689a      	ldr	r2, [r3, #8]
 8001258:	4b0d      	ldr	r3, [pc, #52]	; (8001290 <chThdSetPriority+0x50>)
 800125a:	699b      	ldr	r3, [r3, #24]
 800125c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800125e:	429a      	cmp	r2, r3
 8001260:	d005      	beq.n	800126e <chThdSetPriority+0x2e>
 8001262:	4b0b      	ldr	r3, [pc, #44]	; (8001290 <chThdSetPriority+0x50>)
 8001264:	699b      	ldr	r3, [r3, #24]
 8001266:	689a      	ldr	r2, [r3, #8]
 8001268:	9b01      	ldr	r3, [sp, #4]
 800126a:	429a      	cmp	r2, r3
 800126c:	d203      	bcs.n	8001276 <chThdSetPriority+0x36>
    currp->p_prio = newprio;
 800126e:	4b08      	ldr	r3, [pc, #32]	; (8001290 <chThdSetPriority+0x50>)
 8001270:	699b      	ldr	r3, [r3, #24]
 8001272:	9a01      	ldr	r2, [sp, #4]
 8001274:	609a      	str	r2, [r3, #8]
  }
  currp->p_realprio = newprio;
 8001276:	4b06      	ldr	r3, [pc, #24]	; (8001290 <chThdSetPriority+0x50>)
 8001278:	699b      	ldr	r3, [r3, #24]
 800127a:	9a01      	ldr	r2, [sp, #4]
 800127c:	63da      	str	r2, [r3, #60]	; 0x3c
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
 800127e:	f7ff fd7f 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 8001282:	f7ff fedd 	bl	8001040 <chSysUnlock>

  return oldprio;
 8001286:	9b03      	ldr	r3, [sp, #12]
}
 8001288:	4618      	mov	r0, r3
 800128a:	b005      	add	sp, #20
 800128c:	f85d fb04 	ldr.w	pc, [sp], #4
 8001290:	200016e0 	.word	0x200016e0
 8001294:	f3af 8000 	nop.w
 8001298:	f3af 8000 	nop.w
 800129c:	f3af 8000 	nop.w

080012a0 <chThdTerminate>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdTerminate(thread_t *tp) {
 80012a0:	b500      	push	{lr}
 80012a2:	b083      	sub	sp, #12
 80012a4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80012a6:	f7ff fec3 	bl	8001030 <chSysLock>
  tp->p_flags |= CH_FLAG_TERMINATE;
 80012aa:	9b01      	ldr	r3, [sp, #4]
 80012ac:	7f5b      	ldrb	r3, [r3, #29]
 80012ae:	f043 0304 	orr.w	r3, r3, #4
 80012b2:	b2da      	uxtb	r2, r3
 80012b4:	9b01      	ldr	r3, [sp, #4]
 80012b6:	775a      	strb	r2, [r3, #29]
  chSysUnlock();
 80012b8:	f7ff fec2 	bl	8001040 <chSysUnlock>
}
 80012bc:	b003      	add	sp, #12
 80012be:	f85d fb04 	ldr.w	pc, [sp], #4
 80012c2:	bf00      	nop
 80012c4:	f3af 8000 	nop.w
 80012c8:	f3af 8000 	nop.w
 80012cc:	f3af 8000 	nop.w

080012d0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 80012d0:	b500      	push	{lr}
 80012d2:	b083      	sub	sp, #12
 80012d4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80012d6:	f7ff feab 	bl	8001030 <chSysLock>
  chThdSleepS(time);
 80012da:	9801      	ldr	r0, [sp, #4]
 80012dc:	f7ff fef0 	bl	80010c0 <chThdSleepS>
  chSysUnlock();
 80012e0:	f7ff feae 	bl	8001040 <chSysUnlock>
}
 80012e4:	b003      	add	sp, #12
 80012e6:	f85d fb04 	ldr.w	pc, [sp], #4
 80012ea:	bf00      	nop
 80012ec:	f3af 8000 	nop.w

080012f0 <chThdSleepUntil>:
 *
 * @param[in] time      absolute system time
 *
 * @api
 */
void chThdSleepUntil(systime_t time) {
 80012f0:	b500      	push	{lr}
 80012f2:	b083      	sub	sp, #12
 80012f4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80012f6:	f7ff fe9b 	bl	8001030 <chSysLock>
  time -= chVTGetSystemTimeX();
 80012fa:	f7ff fea9 	bl	8001050 <chVTGetSystemTimeX>
 80012fe:	4603      	mov	r3, r0
 8001300:	9a01      	ldr	r2, [sp, #4]
 8001302:	1ad3      	subs	r3, r2, r3
 8001304:	9301      	str	r3, [sp, #4]
  if (time > (systime_t)0) {
 8001306:	9b01      	ldr	r3, [sp, #4]
 8001308:	2b00      	cmp	r3, #0
 800130a:	d002      	beq.n	8001312 <chThdSleepUntil+0x22>
    chThdSleepS(time);
 800130c:	9801      	ldr	r0, [sp, #4]
 800130e:	f7ff fed7 	bl	80010c0 <chThdSleepS>
  }
  chSysUnlock();
 8001312:	f7ff fe95 	bl	8001040 <chSysUnlock>
}
 8001316:	b003      	add	sp, #12
 8001318:	f85d fb04 	ldr.w	pc, [sp], #4
 800131c:	f3af 8000 	nop.w

08001320 <chThdSleepUntilWindowed>:
 * @param[in] next      absolute system time of the next deadline
 * @return				the @p next parameter
 *
 * @api
 */
systime_t chThdSleepUntilWindowed(systime_t prev, systime_t next) {
 8001320:	b500      	push	{lr}
 8001322:	b085      	sub	sp, #20
 8001324:	9001      	str	r0, [sp, #4]
 8001326:	9100      	str	r1, [sp, #0]
  systime_t time;

  chSysLock();
 8001328:	f7ff fe82 	bl	8001030 <chSysLock>
  time = chVTGetSystemTimeX();
 800132c:	f7ff fe90 	bl	8001050 <chVTGetSystemTimeX>
 8001330:	9003      	str	r0, [sp, #12]
  if (chVTIsTimeWithinX(time, prev, next)) {
 8001332:	9803      	ldr	r0, [sp, #12]
 8001334:	9901      	ldr	r1, [sp, #4]
 8001336:	9a00      	ldr	r2, [sp, #0]
 8001338:	f7ff fe92 	bl	8001060 <chVTIsTimeWithinX>
 800133c:	4603      	mov	r3, r0
 800133e:	2b00      	cmp	r3, #0
 8001340:	d005      	beq.n	800134e <chThdSleepUntilWindowed+0x2e>
	chThdSleepS(next - time);
 8001342:	9a00      	ldr	r2, [sp, #0]
 8001344:	9b03      	ldr	r3, [sp, #12]
 8001346:	1ad3      	subs	r3, r2, r3
 8001348:	4618      	mov	r0, r3
 800134a:	f7ff feb9 	bl	80010c0 <chThdSleepS>
  }
  chSysUnlock();
 800134e:	f7ff fe77 	bl	8001040 <chSysUnlock>

  return next;
 8001352:	9b00      	ldr	r3, [sp, #0]
}
 8001354:	4618      	mov	r0, r3
 8001356:	b005      	add	sp, #20
 8001358:	f85d fb04 	ldr.w	pc, [sp], #4
 800135c:	f3af 8000 	nop.w

08001360 <chThdYield>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
 8001360:	b508      	push	{r3, lr}

  chSysLock();
 8001362:	f7ff fe65 	bl	8001030 <chSysLock>
  chSchDoYieldS();
 8001366:	f7ff fe53 	bl	8001010 <chSchDoYieldS>
  chSysUnlock();
 800136a:	f7ff fe69 	bl	8001040 <chSysUnlock>
}
 800136e:	bd08      	pop	{r3, pc}

08001370 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8001370:	b500      	push	{lr}
 8001372:	b083      	sub	sp, #12
 8001374:	9001      	str	r0, [sp, #4]

  chSysLock();
 8001376:	f7ff fe5b 	bl	8001030 <chSysLock>
  chThdExitS(msg);
 800137a:	9801      	ldr	r0, [sp, #4]
 800137c:	f000 f808 	bl	8001390 <chThdExitS>
  /* The thread never returns here.*/
}
 8001380:	b003      	add	sp, #12
 8001382:	f85d fb04 	ldr.w	pc, [sp], #4
 8001386:	bf00      	nop
 8001388:	f3af 8000 	nop.w
 800138c:	f3af 8000 	nop.w

08001390 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8001390:	b500      	push	{lr}
 8001392:	b085      	sub	sp, #20
 8001394:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
 8001396:	4b17      	ldr	r3, [pc, #92]	; (80013f4 <chThdExitS+0x64>)
 8001398:	699b      	ldr	r3, [r3, #24]
 800139a:	9303      	str	r3, [sp, #12]

  tp->p_u.exitcode = msg;
 800139c:	9b03      	ldr	r3, [sp, #12]
 800139e:	9a01      	ldr	r2, [sp, #4]
 80013a0:	621a      	str	r2, [r3, #32]
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 80013a2:	e008      	b.n	80013b6 <chThdExitS+0x26>
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 80013a4:	9b03      	ldr	r3, [sp, #12]
 80013a6:	3324      	adds	r3, #36	; 0x24
 80013a8:	4618      	mov	r0, r3
 80013aa:	f7ff fde1 	bl	8000f70 <list_remove>
 80013ae:	4603      	mov	r3, r0
 80013b0:	4618      	mov	r0, r3
 80013b2:	f7ff fbf5 	bl	8000ba0 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 80013b6:	9b03      	ldr	r3, [sp, #12]
 80013b8:	3324      	adds	r3, #36	; 0x24
 80013ba:	4618      	mov	r0, r3
 80013bc:	f7ff fd98 	bl	8000ef0 <list_notempty>
 80013c0:	4603      	mov	r3, r0
 80013c2:	2b00      	cmp	r3, #0
 80013c4:	d1ee      	bne.n	80013a4 <chThdExitS+0x14>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 80013c6:	9b03      	ldr	r3, [sp, #12]
 80013c8:	7f5b      	ldrb	r3, [r3, #29]
 80013ca:	f003 0303 	and.w	r3, r3, #3
 80013ce:	2b00      	cmp	r3, #0
 80013d0:	d109      	bne.n	80013e6 <chThdExitS+0x56>
    REG_REMOVE(tp);
 80013d2:	9b03      	ldr	r3, [sp, #12]
 80013d4:	695b      	ldr	r3, [r3, #20]
 80013d6:	9a03      	ldr	r2, [sp, #12]
 80013d8:	6912      	ldr	r2, [r2, #16]
 80013da:	611a      	str	r2, [r3, #16]
 80013dc:	9b03      	ldr	r3, [sp, #12]
 80013de:	691b      	ldr	r3, [r3, #16]
 80013e0:	9a03      	ldr	r2, [sp, #12]
 80013e2:	6952      	ldr	r2, [r2, #20]
 80013e4:	615a      	str	r2, [r3, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 80013e6:	200f      	movs	r0, #15
 80013e8:	f7ff fc02 	bl	8000bf0 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 80013ec:	b005      	add	sp, #20
 80013ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80013f2:	bf00      	nop
 80013f4:	200016e0 	.word	0x200016e0
 80013f8:	f3af 8000 	nop.w
 80013fc:	f3af 8000 	nop.w

08001400 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
 8001400:	b500      	push	{lr}
 8001402:	b085      	sub	sp, #20
 8001404:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chDbgCheck(tp != NULL);

  chSysLock();
 8001406:	f7ff fe13 	bl	8001030 <chSysLock>
  chDbgAssert(tp != currp, "waiting self");
#if CH_CFG_USE_DYNAMIC == TRUE
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
#endif
  if (tp->p_state != CH_STATE_FINAL) {
 800140a:	9b01      	ldr	r3, [sp, #4]
 800140c:	7f1b      	ldrb	r3, [r3, #28]
 800140e:	2b0f      	cmp	r3, #15
 8001410:	d00a      	beq.n	8001428 <chThdWait+0x28>
    list_insert(currp, &tp->p_waiting);
 8001412:	4b0c      	ldr	r3, [pc, #48]	; (8001444 <chThdWait+0x44>)
 8001414:	699a      	ldr	r2, [r3, #24]
 8001416:	9b01      	ldr	r3, [sp, #4]
 8001418:	3324      	adds	r3, #36	; 0x24
 800141a:	4610      	mov	r0, r2
 800141c:	4619      	mov	r1, r3
 800141e:	f7ff fd97 	bl	8000f50 <list_insert>
    chSchGoSleepS(CH_STATE_WTEXIT);
 8001422:	2009      	movs	r0, #9
 8001424:	f7ff fbe4 	bl	8000bf0 <chSchGoSleepS>
  }
  msg = tp->p_u.exitcode;
 8001428:	9b01      	ldr	r3, [sp, #4]
 800142a:	6a1b      	ldr	r3, [r3, #32]
 800142c:	9303      	str	r3, [sp, #12]
  chSysUnlock();
 800142e:	f7ff fe07 	bl	8001040 <chSysUnlock>

#if CH_CFG_USE_DYNAMIC == TRUE
  /* Releasing a lock if it is a dynamic thread.*/
  chThdRelease(tp);
 8001432:	9801      	ldr	r0, [sp, #4]
 8001434:	f000 f9c4 	bl	80017c0 <chThdRelease>
#endif

  return msg;
 8001438:	9b03      	ldr	r3, [sp, #12]
}
 800143a:	4618      	mov	r0, r3
 800143c:	b005      	add	sp, #20
 800143e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001442:	bf00      	nop
 8001444:	200016e0 	.word	0x200016e0
 8001448:	f3af 8000 	nop.w
 800144c:	f3af 8000 	nop.w

08001450 <chThdSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendS(thread_reference_t *trp) {
 8001450:	b500      	push	{lr}
 8001452:	b085      	sub	sp, #20
 8001454:	9001      	str	r0, [sp, #4]
  thread_t *tp = chThdGetSelfX();
 8001456:	f7ff fe1b 	bl	8001090 <chThdGetSelfX>
 800145a:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
 800145c:	9b01      	ldr	r3, [sp, #4]
 800145e:	9a03      	ldr	r2, [sp, #12]
 8001460:	601a      	str	r2, [r3, #0]
  tp->p_u.wttrp = trp;
 8001462:	9b03      	ldr	r3, [sp, #12]
 8001464:	9a01      	ldr	r2, [sp, #4]
 8001466:	621a      	str	r2, [r3, #32]
  chSchGoSleepS(CH_STATE_SUSPENDED);
 8001468:	2003      	movs	r0, #3
 800146a:	f7ff fbc1 	bl	8000bf0 <chSchGoSleepS>

  return chThdGetSelfX()->p_u.rdymsg;
 800146e:	f7ff fe0f 	bl	8001090 <chThdGetSelfX>
 8001472:	4603      	mov	r3, r0
 8001474:	6a1b      	ldr	r3, [r3, #32]
}
 8001476:	4618      	mov	r0, r3
 8001478:	b005      	add	sp, #20
 800147a:	f85d fb04 	ldr.w	pc, [sp], #4
 800147e:	bf00      	nop

08001480 <chThdSuspendTimeoutS>:
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {
 8001480:	b500      	push	{lr}
 8001482:	b085      	sub	sp, #20
 8001484:	9001      	str	r0, [sp, #4]
 8001486:	9100      	str	r1, [sp, #0]
  thread_t *tp = chThdGetSelfX();
 8001488:	f7ff fe02 	bl	8001090 <chThdGetSelfX>
 800148c:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");

  if (TIME_IMMEDIATE == timeout) {
 800148e:	9b00      	ldr	r3, [sp, #0]
 8001490:	2b00      	cmp	r3, #0
 8001492:	d102      	bne.n	800149a <chThdSuspendTimeoutS+0x1a>
    return MSG_TIMEOUT;
 8001494:	f04f 33ff 	mov.w	r3, #4294967295
 8001498:	e00a      	b.n	80014b0 <chThdSuspendTimeoutS+0x30>
  }

  *trp = tp;
 800149a:	9b01      	ldr	r3, [sp, #4]
 800149c:	9a03      	ldr	r2, [sp, #12]
 800149e:	601a      	str	r2, [r3, #0]
  tp->p_u.wttrp = trp;
 80014a0:	9b03      	ldr	r3, [sp, #12]
 80014a2:	9a01      	ldr	r2, [sp, #4]
 80014a4:	621a      	str	r2, [r3, #32]

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 80014a6:	2003      	movs	r0, #3
 80014a8:	9900      	ldr	r1, [sp, #0]
 80014aa:	f7ff fc09 	bl	8000cc0 <chSchGoSleepTimeoutS>
 80014ae:	4603      	mov	r3, r0
}
 80014b0:	4618      	mov	r0, r3
 80014b2:	b005      	add	sp, #20
 80014b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80014b8:	f3af 8000 	nop.w
 80014bc:	f3af 8000 	nop.w

080014c0 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 80014c0:	b500      	push	{lr}
 80014c2:	b085      	sub	sp, #20
 80014c4:	9001      	str	r0, [sp, #4]
 80014c6:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 80014c8:	9b01      	ldr	r3, [sp, #4]
 80014ca:	681b      	ldr	r3, [r3, #0]
 80014cc:	2b00      	cmp	r3, #0
 80014ce:	d00b      	beq.n	80014e8 <chThdResumeI+0x28>
    thread_t *tp = *trp;
 80014d0:	9b01      	ldr	r3, [sp, #4]
 80014d2:	681b      	ldr	r3, [r3, #0]
 80014d4:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 80014d6:	9b01      	ldr	r3, [sp, #4]
 80014d8:	2200      	movs	r2, #0
 80014da:	601a      	str	r2, [r3, #0]
    tp->p_u.rdymsg = msg;
 80014dc:	9b03      	ldr	r3, [sp, #12]
 80014de:	9a00      	ldr	r2, [sp, #0]
 80014e0:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 80014e2:	9803      	ldr	r0, [sp, #12]
 80014e4:	f7ff fb5c 	bl	8000ba0 <chSchReadyI>
  }
}
 80014e8:	b005      	add	sp, #20
 80014ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80014ee:	bf00      	nop

080014f0 <chThdResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeS(thread_reference_t *trp, msg_t msg) {
 80014f0:	b500      	push	{lr}
 80014f2:	b085      	sub	sp, #20
 80014f4:	9001      	str	r0, [sp, #4]
 80014f6:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 80014f8:	9b01      	ldr	r3, [sp, #4]
 80014fa:	681b      	ldr	r3, [r3, #0]
 80014fc:	2b00      	cmp	r3, #0
 80014fe:	d009      	beq.n	8001514 <chThdResumeS+0x24>
    thread_t *tp = *trp;
 8001500:	9b01      	ldr	r3, [sp, #4]
 8001502:	681b      	ldr	r3, [r3, #0]
 8001504:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 8001506:	9b01      	ldr	r3, [sp, #4]
 8001508:	2200      	movs	r2, #0
 800150a:	601a      	str	r2, [r3, #0]
    chSchWakeupS(tp, msg);
 800150c:	9803      	ldr	r0, [sp, #12]
 800150e:	9900      	ldr	r1, [sp, #0]
 8001510:	f7ff fc0e 	bl	8000d30 <chSchWakeupS>
  }
}
 8001514:	b005      	add	sp, #20
 8001516:	f85d fb04 	ldr.w	pc, [sp], #4
 800151a:	bf00      	nop
 800151c:	f3af 8000 	nop.w

08001520 <chThdResume>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @api
 */
void chThdResume(thread_reference_t *trp, msg_t msg) {
 8001520:	b500      	push	{lr}
 8001522:	b083      	sub	sp, #12
 8001524:	9001      	str	r0, [sp, #4]
 8001526:	9100      	str	r1, [sp, #0]

  chSysLock();
 8001528:	f7ff fd82 	bl	8001030 <chSysLock>
  chThdResumeS(trp, msg);
 800152c:	9801      	ldr	r0, [sp, #4]
 800152e:	9900      	ldr	r1, [sp, #0]
 8001530:	f7ff ffde 	bl	80014f0 <chThdResumeS>
  chSysUnlock();
 8001534:	f7ff fd84 	bl	8001040 <chSysUnlock>
}
 8001538:	b003      	add	sp, #12
 800153a:	f85d fb04 	ldr.w	pc, [sp], #4
 800153e:	bf00      	nop

08001540 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8001540:	b500      	push	{lr}
 8001542:	b083      	sub	sp, #12
 8001544:	9001      	str	r0, [sp, #4]
 8001546:	9100      	str	r1, [sp, #0]

  if (TIME_IMMEDIATE == timeout) {
 8001548:	9b00      	ldr	r3, [sp, #0]
 800154a:	2b00      	cmp	r3, #0
 800154c:	d102      	bne.n	8001554 <chThdEnqueueTimeoutS+0x14>
    return MSG_TIMEOUT;
 800154e:	f04f 33ff 	mov.w	r3, #4294967295
 8001552:	e00a      	b.n	800156a <chThdEnqueueTimeoutS+0x2a>
  }

  queue_insert(currp, tqp);
 8001554:	4b07      	ldr	r3, [pc, #28]	; (8001574 <chThdEnqueueTimeoutS+0x34>)
 8001556:	699b      	ldr	r3, [r3, #24]
 8001558:	4618      	mov	r0, r3
 800155a:	9901      	ldr	r1, [sp, #4]
 800155c:	f7ff fd18 	bl	8000f90 <queue_insert>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001560:	2004      	movs	r0, #4
 8001562:	9900      	ldr	r1, [sp, #0]
 8001564:	f7ff fbac 	bl	8000cc0 <chSchGoSleepTimeoutS>
 8001568:	4603      	mov	r3, r0
}
 800156a:	4618      	mov	r0, r3
 800156c:	b003      	add	sp, #12
 800156e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001572:	bf00      	nop
 8001574:	200016e0 	.word	0x200016e0
 8001578:	f3af 8000 	nop.w
 800157c:	f3af 8000 	nop.w

08001580 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8001580:	b500      	push	{lr}
 8001582:	b083      	sub	sp, #12
 8001584:	9001      	str	r0, [sp, #4]
 8001586:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
 8001588:	9801      	ldr	r0, [sp, #4]
 800158a:	f7ff fcd1 	bl	8000f30 <queue_notempty>
 800158e:	4603      	mov	r3, r0
 8001590:	2b00      	cmp	r3, #0
 8001592:	d003      	beq.n	800159c <chThdDequeueNextI+0x1c>
    chThdDoDequeueNextI(tqp, msg);
 8001594:	9801      	ldr	r0, [sp, #4]
 8001596:	9900      	ldr	r1, [sp, #0]
 8001598:	f7ff fda2 	bl	80010e0 <chThdDoDequeueNextI>
  }
}
 800159c:	b003      	add	sp, #12
 800159e:	f85d fb04 	ldr.w	pc, [sp], #4
 80015a2:	bf00      	nop
 80015a4:	f3af 8000 	nop.w
 80015a8:	f3af 8000 	nop.w
 80015ac:	f3af 8000 	nop.w

080015b0 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 80015b0:	b500      	push	{lr}
 80015b2:	b083      	sub	sp, #12
 80015b4:	9001      	str	r0, [sp, #4]
 80015b6:	9100      	str	r1, [sp, #0]

  while (queue_notempty(tqp)) {
 80015b8:	e003      	b.n	80015c2 <chThdDequeueAllI+0x12>
    chThdDoDequeueNextI(tqp, msg);
 80015ba:	9801      	ldr	r0, [sp, #4]
 80015bc:	9900      	ldr	r1, [sp, #0]
 80015be:	f7ff fd8f 	bl	80010e0 <chThdDoDequeueNextI>
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  while (queue_notempty(tqp)) {
 80015c2:	9801      	ldr	r0, [sp, #4]
 80015c4:	f7ff fcb4 	bl	8000f30 <queue_notempty>
 80015c8:	4603      	mov	r3, r0
 80015ca:	2b00      	cmp	r3, #0
 80015cc:	d1f5      	bne.n	80015ba <chThdDequeueAllI+0xa>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 80015ce:	b003      	add	sp, #12
 80015d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80015d4:	f3af 8000 	nop.w
 80015d8:	f3af 8000 	nop.w
 80015dc:	f3af 8000 	nop.w

080015e0 <port_rt_get_counter_value>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80015e0:	4b01      	ldr	r3, [pc, #4]	; (80015e8 <port_rt_get_counter_value+0x8>)
 80015e2:	685b      	ldr	r3, [r3, #4]
}
 80015e4:	4618      	mov	r0, r3
 80015e6:	4770      	bx	lr
 80015e8:	e0001000 	.word	0xe0001000
 80015ec:	f3af 8000 	nop.w

080015f0 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
 80015f0:	b084      	sub	sp, #16
 80015f2:	9003      	str	r0, [sp, #12]
 80015f4:	9102      	str	r1, [sp, #8]
 80015f6:	9201      	str	r2, [sp, #4]

  tmp->n++;
 80015f8:	9b03      	ldr	r3, [sp, #12]
 80015fa:	68db      	ldr	r3, [r3, #12]
 80015fc:	1c5a      	adds	r2, r3, #1
 80015fe:	9b03      	ldr	r3, [sp, #12]
 8001600:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
 8001602:	9b03      	ldr	r3, [sp, #12]
 8001604:	689b      	ldr	r3, [r3, #8]
 8001606:	9a02      	ldr	r2, [sp, #8]
 8001608:	1ad2      	subs	r2, r2, r3
 800160a:	9b01      	ldr	r3, [sp, #4]
 800160c:	1ad2      	subs	r2, r2, r3
 800160e:	9b03      	ldr	r3, [sp, #12]
 8001610:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8001612:	9b03      	ldr	r3, [sp, #12]
 8001614:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8001618:	9b03      	ldr	r3, [sp, #12]
 800161a:	689b      	ldr	r3, [r3, #8]
 800161c:	461a      	mov	r2, r3
 800161e:	f04f 0300 	mov.w	r3, #0
 8001622:	1812      	adds	r2, r2, r0
 8001624:	eb43 0301 	adc.w	r3, r3, r1
 8001628:	9903      	ldr	r1, [sp, #12]
 800162a:	e9c1 2304 	strd	r2, r3, [r1, #16]
  if (tmp->last > tmp->worst) {
 800162e:	9b03      	ldr	r3, [sp, #12]
 8001630:	689a      	ldr	r2, [r3, #8]
 8001632:	9b03      	ldr	r3, [sp, #12]
 8001634:	685b      	ldr	r3, [r3, #4]
 8001636:	429a      	cmp	r2, r3
 8001638:	d903      	bls.n	8001642 <tm_stop+0x52>
    tmp->worst = tmp->last;
 800163a:	9b03      	ldr	r3, [sp, #12]
 800163c:	689a      	ldr	r2, [r3, #8]
 800163e:	9b03      	ldr	r3, [sp, #12]
 8001640:	605a      	str	r2, [r3, #4]
  }
  if (tmp->last < tmp->best) {
 8001642:	9b03      	ldr	r3, [sp, #12]
 8001644:	689a      	ldr	r2, [r3, #8]
 8001646:	9b03      	ldr	r3, [sp, #12]
 8001648:	681b      	ldr	r3, [r3, #0]
 800164a:	429a      	cmp	r2, r3
 800164c:	d203      	bcs.n	8001656 <tm_stop+0x66>
    tmp->best = tmp->last;
 800164e:	9b03      	ldr	r3, [sp, #12]
 8001650:	689a      	ldr	r2, [r3, #8]
 8001652:	9b03      	ldr	r3, [sp, #12]
 8001654:	601a      	str	r2, [r3, #0]
  }
}
 8001656:	b004      	add	sp, #16
 8001658:	4770      	bx	lr
 800165a:	bf00      	nop
 800165c:	f3af 8000 	nop.w

08001660 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8001660:	b500      	push	{lr}
 8001662:	b087      	sub	sp, #28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8001664:	4b0a      	ldr	r3, [pc, #40]	; (8001690 <_tm_init+0x30>)
 8001666:	2200      	movs	r2, #0
 8001668:	675a      	str	r2, [r3, #116]	; 0x74
  chTMObjectInit(&tm);
 800166a:	466b      	mov	r3, sp
 800166c:	4618      	mov	r0, r3
 800166e:	f000 f817 	bl	80016a0 <chTMObjectInit>
  chTMStartMeasurementX(&tm);
 8001672:	466b      	mov	r3, sp
 8001674:	4618      	mov	r0, r3
 8001676:	f000 f82b 	bl	80016d0 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 800167a:	466b      	mov	r3, sp
 800167c:	4618      	mov	r0, r3
 800167e:	f000 f837 	bl	80016f0 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 8001682:	9a02      	ldr	r2, [sp, #8]
 8001684:	4b02      	ldr	r3, [pc, #8]	; (8001690 <_tm_init+0x30>)
 8001686:	675a      	str	r2, [r3, #116]	; 0x74
}
 8001688:	b007      	add	sp, #28
 800168a:	f85d fb04 	ldr.w	pc, [sp], #4
 800168e:	bf00      	nop
 8001690:	200016e0 	.word	0x200016e0
 8001694:	f3af 8000 	nop.w
 8001698:	f3af 8000 	nop.w
 800169c:	f3af 8000 	nop.w

080016a0 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
 80016a0:	b082      	sub	sp, #8
 80016a2:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
 80016a4:	9b01      	ldr	r3, [sp, #4]
 80016a6:	f04f 32ff 	mov.w	r2, #4294967295
 80016aa:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
 80016ac:	9b01      	ldr	r3, [sp, #4]
 80016ae:	2200      	movs	r2, #0
 80016b0:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
 80016b2:	9b01      	ldr	r3, [sp, #4]
 80016b4:	2200      	movs	r2, #0
 80016b6:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
 80016b8:	9b01      	ldr	r3, [sp, #4]
 80016ba:	2200      	movs	r2, #0
 80016bc:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
 80016be:	9901      	ldr	r1, [sp, #4]
 80016c0:	f04f 0200 	mov.w	r2, #0
 80016c4:	f04f 0300 	mov.w	r3, #0
 80016c8:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
 80016cc:	b002      	add	sp, #8
 80016ce:	4770      	bx	lr

080016d0 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
 80016d0:	b500      	push	{lr}
 80016d2:	b083      	sub	sp, #12
 80016d4:	9001      	str	r0, [sp, #4]

  tmp->last = chSysGetRealtimeCounterX();
 80016d6:	f7ff ff83 	bl	80015e0 <port_rt_get_counter_value>
 80016da:	4602      	mov	r2, r0
 80016dc:	9b01      	ldr	r3, [sp, #4]
 80016de:	609a      	str	r2, [r3, #8]
}
 80016e0:	b003      	add	sp, #12
 80016e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80016e6:	bf00      	nop
 80016e8:	f3af 8000 	nop.w
 80016ec:	f3af 8000 	nop.w

080016f0 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 80016f0:	b500      	push	{lr}
 80016f2:	b083      	sub	sp, #12
 80016f4:	9001      	str	r0, [sp, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80016f6:	f7ff ff73 	bl	80015e0 <port_rt_get_counter_value>
 80016fa:	4602      	mov	r2, r0
 80016fc:	4b04      	ldr	r3, [pc, #16]	; (8001710 <chTMStopMeasurementX+0x20>)
 80016fe:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8001700:	9801      	ldr	r0, [sp, #4]
 8001702:	4611      	mov	r1, r2
 8001704:	461a      	mov	r2, r3
 8001706:	f7ff ff73 	bl	80015f0 <tm_stop>
}
 800170a:	b003      	add	sp, #12
 800170c:	f85d fb04 	ldr.w	pc, [sp], #4
 8001710:	200016e0 	.word	0x200016e0
 8001714:	f3af 8000 	nop.w
 8001718:	f3af 8000 	nop.w
 800171c:	f3af 8000 	nop.w

08001720 <chTMChainMeasurementToX>:
 *
 *
 * @xclass
 */
NOINLINE void chTMChainMeasurementToX(time_measurement_t *tmp1,
                                      time_measurement_t *tmp2) {
 8001720:	b500      	push	{lr}
 8001722:	b083      	sub	sp, #12
 8001724:	9001      	str	r0, [sp, #4]
 8001726:	9100      	str	r1, [sp, #0]

  /* Starts new measurement.*/
  tmp2->last = chSysGetRealtimeCounterX();
 8001728:	f7ff ff5a 	bl	80015e0 <port_rt_get_counter_value>
 800172c:	4602      	mov	r2, r0
 800172e:	9b00      	ldr	r3, [sp, #0]
 8001730:	609a      	str	r2, [r3, #8]

  /* Stops previous measurement using the same time stamp.*/
  tm_stop(tmp1, tmp2->last, (rtcnt_t)0);
 8001732:	9b00      	ldr	r3, [sp, #0]
 8001734:	689b      	ldr	r3, [r3, #8]
 8001736:	9801      	ldr	r0, [sp, #4]
 8001738:	4619      	mov	r1, r3
 800173a:	2200      	movs	r2, #0
 800173c:	f7ff ff58 	bl	80015f0 <tm_stop>
}
 8001740:	b003      	add	sp, #12
 8001742:	f85d fb04 	ldr.w	pc, [sp], #4
 8001746:	bf00      	nop
 8001748:	f3af 8000 	nop.w
 800174c:	f3af 8000 	nop.w

08001750 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8001750:	b082      	sub	sp, #8
 8001752:	2320      	movs	r3, #32
 8001754:	9301      	str	r3, [sp, #4]
 8001756:	9b01      	ldr	r3, [sp, #4]
 8001758:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800175c:	b002      	add	sp, #8
 800175e:	4770      	bx	lr

08001760 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8001760:	b082      	sub	sp, #8
 8001762:	2300      	movs	r3, #0
 8001764:	9301      	str	r3, [sp, #4]
 8001766:	9b01      	ldr	r3, [sp, #4]
 8001768:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800176c:	b002      	add	sp, #8
 800176e:	4770      	bx	lr

08001770 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001770:	b508      	push	{r3, lr}

  port_lock();
 8001772:	f7ff ffed 	bl	8001750 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001776:	bd08      	pop	{r3, pc}
 8001778:	f3af 8000 	nop.w
 800177c:	f3af 8000 	nop.w

08001780 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001780:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001782:	f7ff ffed 	bl	8001760 <port_unlock>
}
 8001786:	bd08      	pop	{r3, pc}
 8001788:	f3af 8000 	nop.w
 800178c:	f3af 8000 	nop.w

08001790 <chThdAddRef>:
 * @return              The same thread pointer passed as parameter
 *                      representing the new reference.
 *
 * @api
 */
thread_t *chThdAddRef(thread_t *tp) {
 8001790:	b500      	push	{lr}
 8001792:	b083      	sub	sp, #12
 8001794:	9001      	str	r0, [sp, #4]

  chSysLock();
 8001796:	f7ff ffeb 	bl	8001770 <chSysLock>
  chDbgAssert(tp->p_refs < (trefs_t)255, "too many references");
  tp->p_refs++;
 800179a:	9b01      	ldr	r3, [sp, #4]
 800179c:	7f9b      	ldrb	r3, [r3, #30]
 800179e:	3301      	adds	r3, #1
 80017a0:	b2da      	uxtb	r2, r3
 80017a2:	9b01      	ldr	r3, [sp, #4]
 80017a4:	779a      	strb	r2, [r3, #30]
  chSysUnlock();
 80017a6:	f7ff ffeb 	bl	8001780 <chSysUnlock>

  return tp;
 80017aa:	9b01      	ldr	r3, [sp, #4]
}
 80017ac:	4618      	mov	r0, r3
 80017ae:	b003      	add	sp, #12
 80017b0:	f85d fb04 	ldr.w	pc, [sp], #4
 80017b4:	f3af 8000 	nop.w
 80017b8:	f3af 8000 	nop.w
 80017bc:	f3af 8000 	nop.w

080017c0 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 80017c0:	b500      	push	{lr}
 80017c2:	b085      	sub	sp, #20
 80017c4:	9001      	str	r0, [sp, #4]
  trefs_t refs;

  chSysLock();
 80017c6:	f7ff ffd3 	bl	8001770 <chSysLock>
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
  tp->p_refs--;
 80017ca:	9b01      	ldr	r3, [sp, #4]
 80017cc:	7f9b      	ldrb	r3, [r3, #30]
 80017ce:	3b01      	subs	r3, #1
 80017d0:	b2da      	uxtb	r2, r3
 80017d2:	9b01      	ldr	r3, [sp, #4]
 80017d4:	779a      	strb	r2, [r3, #30]
  refs = tp->p_refs;
 80017d6:	9b01      	ldr	r3, [sp, #4]
 80017d8:	7f9b      	ldrb	r3, [r3, #30]
 80017da:	f88d 300f 	strb.w	r3, [sp, #15]

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
 80017de:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80017e2:	2b00      	cmp	r3, #0
 80017e4:	d12f      	bne.n	8001846 <chThdRelease+0x86>
 80017e6:	9b01      	ldr	r3, [sp, #4]
 80017e8:	7f1b      	ldrb	r3, [r3, #28]
 80017ea:	2b0f      	cmp	r3, #15
 80017ec:	d12b      	bne.n	8001846 <chThdRelease+0x86>
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
 80017ee:	9b01      	ldr	r3, [sp, #4]
 80017f0:	7f5b      	ldrb	r3, [r3, #29]
 80017f2:	f003 0303 	and.w	r3, r3, #3
 80017f6:	2b01      	cmp	r3, #1
 80017f8:	d002      	beq.n	8001800 <chThdRelease+0x40>
 80017fa:	2b02      	cmp	r3, #2
 80017fc:	d010      	beq.n	8001820 <chThdRelease+0x60>
      return;
#endif
    default:
      /* Nothing to do for static threads, those are removed from the
         registry on exit.*/
      break;
 80017fe:	e022      	b.n	8001846 <chThdRelease+0x86>
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 8001800:	9b01      	ldr	r3, [sp, #4]
 8001802:	695b      	ldr	r3, [r3, #20]
 8001804:	9a01      	ldr	r2, [sp, #4]
 8001806:	6912      	ldr	r2, [r2, #16]
 8001808:	611a      	str	r2, [r3, #16]
 800180a:	9b01      	ldr	r3, [sp, #4]
 800180c:	691b      	ldr	r3, [r3, #16]
 800180e:	9a01      	ldr	r2, [sp, #4]
 8001810:	6952      	ldr	r2, [r2, #20]
 8001812:	615a      	str	r2, [r3, #20]
#endif
      chSysUnlock();
 8001814:	f7ff ffb4 	bl	8001780 <chSysUnlock>
      chHeapFree(tp);
 8001818:	9801      	ldr	r0, [sp, #4]
 800181a:	f002 f819 	bl	8003850 <chHeapFree>
      return;
 800181e:	e014      	b.n	800184a <chThdRelease+0x8a>
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 8001820:	9b01      	ldr	r3, [sp, #4]
 8001822:	695b      	ldr	r3, [r3, #20]
 8001824:	9a01      	ldr	r2, [sp, #4]
 8001826:	6912      	ldr	r2, [r2, #16]
 8001828:	611a      	str	r2, [r3, #16]
 800182a:	9b01      	ldr	r3, [sp, #4]
 800182c:	691b      	ldr	r3, [r3, #16]
 800182e:	9a01      	ldr	r2, [sp, #4]
 8001830:	6952      	ldr	r2, [r2, #20]
 8001832:	615a      	str	r2, [r3, #20]
#endif
      chSysUnlock();
 8001834:	f7ff ffa4 	bl	8001780 <chSysUnlock>
      chPoolFree(tp->p_mpool, tp);
 8001838:	9b01      	ldr	r3, [sp, #4]
 800183a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800183c:	4618      	mov	r0, r3
 800183e:	9901      	ldr	r1, [sp, #4]
 8001840:	f002 f93e 	bl	8003ac0 <chPoolFree>
      return;
 8001844:	e001      	b.n	800184a <chThdRelease+0x8a>
      /* Nothing to do for static threads, those are removed from the
         registry on exit.*/
      break;
    }
  }
  chSysUnlock();
 8001846:	f7ff ff9b 	bl	8001780 <chSysUnlock>
}
 800184a:	b005      	add	sp, #20
 800184c:	f85d fb04 	ldr.w	pc, [sp], #4

08001850 <chThdCreateFromHeap>:
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
                              tprio_t prio, tfunc_t pf, void *arg) {
 8001850:	b500      	push	{lr}
 8001852:	b089      	sub	sp, #36	; 0x24
 8001854:	9005      	str	r0, [sp, #20]
 8001856:	9104      	str	r1, [sp, #16]
 8001858:	9203      	str	r2, [sp, #12]
 800185a:	9302      	str	r3, [sp, #8]
  void *wsp;
  thread_t *tp;

  wsp = chHeapAlloc(heapp, size);
 800185c:	9805      	ldr	r0, [sp, #20]
 800185e:	9904      	ldr	r1, [sp, #16]
 8001860:	f001 ff7e 	bl	8003760 <chHeapAlloc>
 8001864:	9007      	str	r0, [sp, #28]
  if (wsp == NULL) {
 8001866:	9b07      	ldr	r3, [sp, #28]
 8001868:	2b00      	cmp	r3, #0
 800186a:	d101      	bne.n	8001870 <chThdCreateFromHeap+0x20>
    return NULL;
 800186c:	2300      	movs	r3, #0
 800186e:	e014      	b.n	800189a <chThdCreateFromHeap+0x4a>
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 8001870:	f7ff ff7e 	bl	8001770 <chSysLock>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 8001874:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8001876:	9300      	str	r3, [sp, #0]
 8001878:	9807      	ldr	r0, [sp, #28]
 800187a:	9904      	ldr	r1, [sp, #16]
 800187c:	9a03      	ldr	r2, [sp, #12]
 800187e:	9b02      	ldr	r3, [sp, #8]
 8001880:	f7ff fc86 	bl	8001190 <chThdCreateI>
 8001884:	9006      	str	r0, [sp, #24]
  tp->p_flags = CH_FLAG_MODE_HEAP;
 8001886:	9b06      	ldr	r3, [sp, #24]
 8001888:	2201      	movs	r2, #1
 800188a:	775a      	strb	r2, [r3, #29]
  chSchWakeupS(tp, MSG_OK);
 800188c:	9806      	ldr	r0, [sp, #24]
 800188e:	2100      	movs	r1, #0
 8001890:	f7ff fa4e 	bl	8000d30 <chSchWakeupS>
  chSysUnlock();
 8001894:	f7ff ff74 	bl	8001780 <chSysUnlock>

  return tp;
 8001898:	9b06      	ldr	r3, [sp, #24]
}
 800189a:	4618      	mov	r0, r3
 800189c:	b009      	add	sp, #36	; 0x24
 800189e:	f85d fb04 	ldr.w	pc, [sp], #4
 80018a2:	bf00      	nop
 80018a4:	f3af 8000 	nop.w
 80018a8:	f3af 8000 	nop.w
 80018ac:	f3af 8000 	nop.w

080018b0 <chThdCreateFromMemoryPool>:
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, tprio_t prio,
                                    tfunc_t pf, void *arg) {
 80018b0:	b500      	push	{lr}
 80018b2:	b089      	sub	sp, #36	; 0x24
 80018b4:	9005      	str	r0, [sp, #20]
 80018b6:	9104      	str	r1, [sp, #16]
 80018b8:	9203      	str	r2, [sp, #12]
 80018ba:	9302      	str	r3, [sp, #8]
  void *wsp;
  thread_t *tp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 80018bc:	9805      	ldr	r0, [sp, #20]
 80018be:	f002 f8df 	bl	8003a80 <chPoolAlloc>
 80018c2:	9007      	str	r0, [sp, #28]
  if (wsp == NULL) {
 80018c4:	9b07      	ldr	r3, [sp, #28]
 80018c6:	2b00      	cmp	r3, #0
 80018c8:	d101      	bne.n	80018ce <chThdCreateFromMemoryPool+0x1e>
    return NULL;
 80018ca:	2300      	movs	r3, #0
 80018cc:	e019      	b.n	8001902 <chThdCreateFromMemoryPool+0x52>
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
                  (uint8_t *)wsp + mp->mp_object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 80018ce:	f7ff ff4f 	bl	8001770 <chSysLock>
  tp = chThdCreateI(wsp, mp->mp_object_size, prio, pf, arg);
 80018d2:	9b05      	ldr	r3, [sp, #20]
 80018d4:	685b      	ldr	r3, [r3, #4]
 80018d6:	9a02      	ldr	r2, [sp, #8]
 80018d8:	9200      	str	r2, [sp, #0]
 80018da:	9807      	ldr	r0, [sp, #28]
 80018dc:	4619      	mov	r1, r3
 80018de:	9a04      	ldr	r2, [sp, #16]
 80018e0:	9b03      	ldr	r3, [sp, #12]
 80018e2:	f7ff fc55 	bl	8001190 <chThdCreateI>
 80018e6:	9006      	str	r0, [sp, #24]
  tp->p_flags = CH_FLAG_MODE_MPOOL;
 80018e8:	9b06      	ldr	r3, [sp, #24]
 80018ea:	2202      	movs	r2, #2
 80018ec:	775a      	strb	r2, [r3, #29]
  tp->p_mpool = mp;
 80018ee:	9b06      	ldr	r3, [sp, #24]
 80018f0:	9a05      	ldr	r2, [sp, #20]
 80018f2:	641a      	str	r2, [r3, #64]	; 0x40
  chSchWakeupS(tp, MSG_OK);
 80018f4:	9806      	ldr	r0, [sp, #24]
 80018f6:	2100      	movs	r1, #0
 80018f8:	f7ff fa1a 	bl	8000d30 <chSchWakeupS>
  chSysUnlock();
 80018fc:	f7ff ff40 	bl	8001780 <chSysUnlock>

  return tp;
 8001900:	9b06      	ldr	r3, [sp, #24]
}
 8001902:	4618      	mov	r0, r3
 8001904:	b009      	add	sp, #36	; 0x24
 8001906:	f85d fb04 	ldr.w	pc, [sp], #4
 800190a:	bf00      	nop
 800190c:	f3af 8000 	nop.w

08001910 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8001910:	b082      	sub	sp, #8
 8001912:	2320      	movs	r3, #32
 8001914:	9301      	str	r3, [sp, #4]
 8001916:	9b01      	ldr	r3, [sp, #4]
 8001918:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800191c:	b002      	add	sp, #8
 800191e:	4770      	bx	lr

08001920 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8001920:	b082      	sub	sp, #8
 8001922:	2300      	movs	r3, #0
 8001924:	9301      	str	r3, [sp, #4]
 8001926:	9b01      	ldr	r3, [sp, #4]
 8001928:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800192c:	b002      	add	sp, #8
 800192e:	4770      	bx	lr

08001930 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001930:	b508      	push	{r3, lr}

  port_lock();
 8001932:	f7ff ffed 	bl	8001910 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001936:	bd08      	pop	{r3, pc}
 8001938:	f3af 8000 	nop.w
 800193c:	f3af 8000 	nop.w

08001940 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001940:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001942:	f7ff ffed 	bl	8001920 <port_unlock>
}
 8001946:	bd08      	pop	{r3, pc}
 8001948:	f3af 8000 	nop.w
 800194c:	f3af 8000 	nop.w

08001950 <chRegFirstThread>:
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
thread_t *chRegFirstThread(void) {
 8001950:	b500      	push	{lr}
 8001952:	b083      	sub	sp, #12
  thread_t *tp;

  chSysLock();
 8001954:	f7ff ffec 	bl	8001930 <chSysLock>
  tp = ch.rlist.r_newer;
 8001958:	4b07      	ldr	r3, [pc, #28]	; (8001978 <chRegFirstThread+0x28>)
 800195a:	691b      	ldr	r3, [r3, #16]
 800195c:	9301      	str	r3, [sp, #4]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs++;
 800195e:	9b01      	ldr	r3, [sp, #4]
 8001960:	7f9b      	ldrb	r3, [r3, #30]
 8001962:	3301      	adds	r3, #1
 8001964:	b2da      	uxtb	r2, r3
 8001966:	9b01      	ldr	r3, [sp, #4]
 8001968:	779a      	strb	r2, [r3, #30]
#endif
  chSysUnlock();
 800196a:	f7ff ffe9 	bl	8001940 <chSysUnlock>

  return tp;
 800196e:	9b01      	ldr	r3, [sp, #4]
}
 8001970:	4618      	mov	r0, r3
 8001972:	b003      	add	sp, #12
 8001974:	f85d fb04 	ldr.w	pc, [sp], #4
 8001978:	200016e0 	.word	0x200016e0
 800197c:	f3af 8000 	nop.w

08001980 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 8001980:	b500      	push	{lr}
 8001982:	b085      	sub	sp, #20
 8001984:	9001      	str	r0, [sp, #4]
  thread_t *ntp;

  chSysLock();
 8001986:	f7ff ffd3 	bl	8001930 <chSysLock>
  ntp = tp->p_newer;
 800198a:	9b01      	ldr	r3, [sp, #4]
 800198c:	691b      	ldr	r3, [r3, #16]
 800198e:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 8001990:	9a03      	ldr	r2, [sp, #12]
 8001992:	4b0b      	ldr	r3, [pc, #44]	; (80019c0 <chRegNextThread+0x40>)
 8001994:	429a      	cmp	r2, r3
 8001996:	d102      	bne.n	800199e <chRegNextThread+0x1e>
  /*lint -restore*/
    ntp = NULL;
 8001998:	2300      	movs	r3, #0
 800199a:	9303      	str	r3, [sp, #12]
 800199c:	e005      	b.n	80019aa <chRegNextThread+0x2a>
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->p_refs < (trefs_t)255, "too many references");
    ntp->p_refs++;
 800199e:	9b03      	ldr	r3, [sp, #12]
 80019a0:	7f9b      	ldrb	r3, [r3, #30]
 80019a2:	3301      	adds	r3, #1
 80019a4:	b2da      	uxtb	r2, r3
 80019a6:	9b03      	ldr	r3, [sp, #12]
 80019a8:	779a      	strb	r2, [r3, #30]
  }
#endif
  chSysUnlock();
 80019aa:	f7ff ffc9 	bl	8001940 <chSysUnlock>
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 80019ae:	9801      	ldr	r0, [sp, #4]
 80019b0:	f7ff ff06 	bl	80017c0 <chThdRelease>
#endif

  return ntp;
 80019b4:	9b03      	ldr	r3, [sp, #12]
}
 80019b6:	4618      	mov	r0, r3
 80019b8:	b005      	add	sp, #20
 80019ba:	f85d fb04 	ldr.w	pc, [sp], #4
 80019be:	bf00      	nop
 80019c0:	200016e0 	.word	0x200016e0
 80019c4:	f3af 8000 	nop.w
 80019c8:	f3af 8000 	nop.w
 80019cc:	f3af 8000 	nop.w

080019d0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80019d0:	b082      	sub	sp, #8
 80019d2:	2320      	movs	r3, #32
 80019d4:	9301      	str	r3, [sp, #4]
 80019d6:	9b01      	ldr	r3, [sp, #4]
 80019d8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80019dc:	b002      	add	sp, #8
 80019de:	4770      	bx	lr

080019e0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80019e0:	b082      	sub	sp, #8
 80019e2:	2300      	movs	r3, #0
 80019e4:	9301      	str	r3, [sp, #4]
 80019e6:	9b01      	ldr	r3, [sp, #4]
 80019e8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80019ec:	b002      	add	sp, #8
 80019ee:	4770      	bx	lr

080019f0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 80019f0:	b082      	sub	sp, #8
 80019f2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 80019f4:	9b01      	ldr	r3, [sp, #4]
 80019f6:	9a01      	ldr	r2, [sp, #4]
 80019f8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80019fa:	9b01      	ldr	r3, [sp, #4]
 80019fc:	9a01      	ldr	r2, [sp, #4]
 80019fe:	605a      	str	r2, [r3, #4]
}
 8001a00:	b002      	add	sp, #8
 8001a02:	4770      	bx	lr
 8001a04:	f3af 8000 	nop.w
 8001a08:	f3af 8000 	nop.w
 8001a0c:	f3af 8000 	nop.w

08001a10 <queue_insert>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8001a10:	b082      	sub	sp, #8
 8001a12:	9001      	str	r0, [sp, #4]
 8001a14:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 8001a16:	9b01      	ldr	r3, [sp, #4]
 8001a18:	9a00      	ldr	r2, [sp, #0]
 8001a1a:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 8001a1c:	9b00      	ldr	r3, [sp, #0]
 8001a1e:	685a      	ldr	r2, [r3, #4]
 8001a20:	9b01      	ldr	r3, [sp, #4]
 8001a22:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8001a24:	9b01      	ldr	r3, [sp, #4]
 8001a26:	685b      	ldr	r3, [r3, #4]
 8001a28:	9a01      	ldr	r2, [sp, #4]
 8001a2a:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 8001a2c:	9b00      	ldr	r3, [sp, #0]
 8001a2e:	9a01      	ldr	r2, [sp, #4]
 8001a30:	605a      	str	r2, [r3, #4]
}
 8001a32:	b002      	add	sp, #8
 8001a34:	4770      	bx	lr
 8001a36:	bf00      	nop
 8001a38:	f3af 8000 	nop.w
 8001a3c:	f3af 8000 	nop.w

08001a40 <queue_fifo_remove>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8001a40:	b084      	sub	sp, #16
 8001a42:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8001a44:	9b01      	ldr	r3, [sp, #4]
 8001a46:	681b      	ldr	r3, [r3, #0]
 8001a48:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8001a4a:	9b03      	ldr	r3, [sp, #12]
 8001a4c:	681a      	ldr	r2, [r3, #0]
 8001a4e:	9b01      	ldr	r3, [sp, #4]
 8001a50:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001a52:	9b01      	ldr	r3, [sp, #4]
 8001a54:	681b      	ldr	r3, [r3, #0]
 8001a56:	9a01      	ldr	r2, [sp, #4]
 8001a58:	605a      	str	r2, [r3, #4]

  return tp;
 8001a5a:	9b03      	ldr	r3, [sp, #12]
}
 8001a5c:	4618      	mov	r0, r3
 8001a5e:	b004      	add	sp, #16
 8001a60:	4770      	bx	lr
 8001a62:	bf00      	nop
 8001a64:	f3af 8000 	nop.w
 8001a68:	f3af 8000 	nop.w
 8001a6c:	f3af 8000 	nop.w

08001a70 <queue_lifo_remove>:

static inline thread_t *queue_lifo_remove(threads_queue_t *tqp) {
 8001a70:	b084      	sub	sp, #16
 8001a72:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_prev;
 8001a74:	9b01      	ldr	r3, [sp, #4]
 8001a76:	685b      	ldr	r3, [r3, #4]
 8001a78:	9303      	str	r3, [sp, #12]

  tqp->p_prev = tp->p_prev;
 8001a7a:	9b03      	ldr	r3, [sp, #12]
 8001a7c:	685a      	ldr	r2, [r3, #4]
 8001a7e:	9b01      	ldr	r3, [sp, #4]
 8001a80:	605a      	str	r2, [r3, #4]
  tqp->p_prev->p_next = (thread_t *)tqp;
 8001a82:	9b01      	ldr	r3, [sp, #4]
 8001a84:	685b      	ldr	r3, [r3, #4]
 8001a86:	9a01      	ldr	r2, [sp, #4]
 8001a88:	601a      	str	r2, [r3, #0]

  return tp;
 8001a8a:	9b03      	ldr	r3, [sp, #12]
}
 8001a8c:	4618      	mov	r0, r3
 8001a8e:	b004      	add	sp, #16
 8001a90:	4770      	bx	lr
 8001a92:	bf00      	nop
 8001a94:	f3af 8000 	nop.w
 8001a98:	f3af 8000 	nop.w
 8001a9c:	f3af 8000 	nop.w

08001aa0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001aa0:	b508      	push	{r3, lr}

  port_lock();
 8001aa2:	f7ff ff95 	bl	80019d0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001aa6:	bd08      	pop	{r3, pc}
 8001aa8:	f3af 8000 	nop.w
 8001aac:	f3af 8000 	nop.w

08001ab0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001ab0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001ab2:	f7ff ff95 	bl	80019e0 <port_unlock>
}
 8001ab6:	bd08      	pop	{r3, pc}
 8001ab8:	f3af 8000 	nop.w
 8001abc:	f3af 8000 	nop.w

08001ac0 <chSemObjectInit>:
 * @param[in] n         initial value of the semaphore counter. Must be
 *                      non-negative.
 *
 * @init
 */
void chSemObjectInit(semaphore_t *sp, cnt_t n) {
 8001ac0:	b500      	push	{lr}
 8001ac2:	b083      	sub	sp, #12
 8001ac4:	9001      	str	r0, [sp, #4]
 8001ac6:	9100      	str	r1, [sp, #0]

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->s_queue);
 8001ac8:	9b01      	ldr	r3, [sp, #4]
 8001aca:	4618      	mov	r0, r3
 8001acc:	f7ff ff90 	bl	80019f0 <queue_init>
  sp->s_cnt = n;
 8001ad0:	9b01      	ldr	r3, [sp, #4]
 8001ad2:	9a00      	ldr	r2, [sp, #0]
 8001ad4:	609a      	str	r2, [r3, #8]
}
 8001ad6:	b003      	add	sp, #12
 8001ad8:	f85d fb04 	ldr.w	pc, [sp], #4
 8001adc:	f3af 8000 	nop.w

08001ae0 <chSemReset>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {
 8001ae0:	b500      	push	{lr}
 8001ae2:	b083      	sub	sp, #12
 8001ae4:	9001      	str	r0, [sp, #4]
 8001ae6:	9100      	str	r1, [sp, #0]

  chSysLock();
 8001ae8:	f7ff ffda 	bl	8001aa0 <chSysLock>
  chSemResetI(sp, n);
 8001aec:	9801      	ldr	r0, [sp, #4]
 8001aee:	9900      	ldr	r1, [sp, #0]
 8001af0:	f000 f80e 	bl	8001b10 <chSemResetI>
  chSchRescheduleS();
 8001af4:	f7ff f944 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 8001af8:	f7ff ffda 	bl	8001ab0 <chSysUnlock>
}
 8001afc:	b003      	add	sp, #12
 8001afe:	f85d fb04 	ldr.w	pc, [sp], #4
 8001b02:	bf00      	nop
 8001b04:	f3af 8000 	nop.w
 8001b08:	f3af 8000 	nop.w
 8001b0c:	f3af 8000 	nop.w

08001b10 <chSemResetI>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(semaphore_t *sp, cnt_t n) {
 8001b10:	b500      	push	{lr}
 8001b12:	b085      	sub	sp, #20
 8001b14:	9001      	str	r0, [sp, #4]
 8001b16:	9100      	str	r1, [sp, #0]
  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
 8001b18:	9b01      	ldr	r3, [sp, #4]
 8001b1a:	689b      	ldr	r3, [r3, #8]
 8001b1c:	9303      	str	r3, [sp, #12]
  sp->s_cnt = n;
 8001b1e:	9b01      	ldr	r3, [sp, #4]
 8001b20:	9a00      	ldr	r2, [sp, #0]
 8001b22:	609a      	str	r2, [r3, #8]
  while (++cnt <= (cnt_t)0) {
 8001b24:	e00b      	b.n	8001b3e <chSemResetI+0x2e>
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
 8001b26:	9b01      	ldr	r3, [sp, #4]
 8001b28:	4618      	mov	r0, r3
 8001b2a:	f7ff ffa1 	bl	8001a70 <queue_lifo_remove>
 8001b2e:	4603      	mov	r3, r0
 8001b30:	4618      	mov	r0, r3
 8001b32:	f7ff f835 	bl	8000ba0 <chSchReadyI>
 8001b36:	4603      	mov	r3, r0
 8001b38:	f06f 0201 	mvn.w	r2, #1
 8001b3c:	621a      	str	r2, [r3, #32]
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= (cnt_t)0) {
 8001b3e:	9b03      	ldr	r3, [sp, #12]
 8001b40:	3301      	adds	r3, #1
 8001b42:	9303      	str	r3, [sp, #12]
 8001b44:	9b03      	ldr	r3, [sp, #12]
 8001b46:	2b00      	cmp	r3, #0
 8001b48:	dded      	ble.n	8001b26 <chSemResetI+0x16>
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
  }
}
 8001b4a:	b005      	add	sp, #20
 8001b4c:	f85d fb04 	ldr.w	pc, [sp], #4

08001b50 <chSemWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemWait(semaphore_t *sp) {
 8001b50:	b500      	push	{lr}
 8001b52:	b085      	sub	sp, #20
 8001b54:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chSysLock();
 8001b56:	f7ff ffa3 	bl	8001aa0 <chSysLock>
  msg = chSemWaitS(sp);
 8001b5a:	9801      	ldr	r0, [sp, #4]
 8001b5c:	f000 f808 	bl	8001b70 <chSemWaitS>
 8001b60:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8001b62:	f7ff ffa5 	bl	8001ab0 <chSysUnlock>

  return msg;
 8001b66:	9b03      	ldr	r3, [sp, #12]
}
 8001b68:	4618      	mov	r0, r3
 8001b6a:	b005      	add	sp, #20
 8001b6c:	f85d fb04 	ldr.w	pc, [sp], #4

08001b70 <chSemWaitS>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @sclass
 */
msg_t chSemWaitS(semaphore_t *sp) {
 8001b70:	b500      	push	{lr}
 8001b72:	b083      	sub	sp, #12
 8001b74:	9001      	str	r0, [sp, #4]
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 8001b76:	9b01      	ldr	r3, [sp, #4]
 8001b78:	689b      	ldr	r3, [r3, #8]
 8001b7a:	1e5a      	subs	r2, r3, #1
 8001b7c:	9b01      	ldr	r3, [sp, #4]
 8001b7e:	609a      	str	r2, [r3, #8]
 8001b80:	9b01      	ldr	r3, [sp, #4]
 8001b82:	689b      	ldr	r3, [r3, #8]
 8001b84:	2b00      	cmp	r3, #0
 8001b86:	da11      	bge.n	8001bac <chSemWaitS+0x3c>
    currp->p_u.wtsemp = sp;
 8001b88:	4b0b      	ldr	r3, [pc, #44]	; (8001bb8 <chSemWaitS+0x48>)
 8001b8a:	699b      	ldr	r3, [r3, #24]
 8001b8c:	9a01      	ldr	r2, [sp, #4]
 8001b8e:	621a      	str	r2, [r3, #32]
    sem_insert(currp, &sp->s_queue);
 8001b90:	4b09      	ldr	r3, [pc, #36]	; (8001bb8 <chSemWaitS+0x48>)
 8001b92:	699a      	ldr	r2, [r3, #24]
 8001b94:	9b01      	ldr	r3, [sp, #4]
 8001b96:	4610      	mov	r0, r2
 8001b98:	4619      	mov	r1, r3
 8001b9a:	f7ff ff39 	bl	8001a10 <queue_insert>
    chSchGoSleepS(CH_STATE_WTSEM);
 8001b9e:	2005      	movs	r0, #5
 8001ba0:	f7ff f826 	bl	8000bf0 <chSchGoSleepS>

    return currp->p_u.rdymsg;
 8001ba4:	4b04      	ldr	r3, [pc, #16]	; (8001bb8 <chSemWaitS+0x48>)
 8001ba6:	699b      	ldr	r3, [r3, #24]
 8001ba8:	6a1b      	ldr	r3, [r3, #32]
 8001baa:	e000      	b.n	8001bae <chSemWaitS+0x3e>
  }

  return MSG_OK;
 8001bac:	2300      	movs	r3, #0
}
 8001bae:	4618      	mov	r0, r3
 8001bb0:	b003      	add	sp, #12
 8001bb2:	f85d fb04 	ldr.w	pc, [sp], #4
 8001bb6:	bf00      	nop
 8001bb8:	200016e0 	.word	0x200016e0
 8001bbc:	f3af 8000 	nop.w

08001bc0 <chSemWaitTimeout>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t time) {
 8001bc0:	b500      	push	{lr}
 8001bc2:	b085      	sub	sp, #20
 8001bc4:	9001      	str	r0, [sp, #4]
 8001bc6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  chSysLock();
 8001bc8:	f7ff ff6a 	bl	8001aa0 <chSysLock>
  msg = chSemWaitTimeoutS(sp, time);
 8001bcc:	9801      	ldr	r0, [sp, #4]
 8001bce:	9900      	ldr	r1, [sp, #0]
 8001bd0:	f000 f80e 	bl	8001bf0 <chSemWaitTimeoutS>
 8001bd4:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8001bd6:	f7ff ff6b 	bl	8001ab0 <chSysUnlock>

  return msg;
 8001bda:	9b03      	ldr	r3, [sp, #12]
}
 8001bdc:	4618      	mov	r0, r3
 8001bde:	b005      	add	sp, #20
 8001be0:	f85d fb04 	ldr.w	pc, [sp], #4
 8001be4:	f3af 8000 	nop.w
 8001be8:	f3af 8000 	nop.w
 8001bec:	f3af 8000 	nop.w

08001bf0 <chSemWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 8001bf0:	b500      	push	{lr}
 8001bf2:	b083      	sub	sp, #12
 8001bf4:	9001      	str	r0, [sp, #4]
 8001bf6:	9100      	str	r1, [sp, #0]
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 8001bf8:	9b01      	ldr	r3, [sp, #4]
 8001bfa:	689b      	ldr	r3, [r3, #8]
 8001bfc:	1e5a      	subs	r2, r3, #1
 8001bfe:	9b01      	ldr	r3, [sp, #4]
 8001c00:	609a      	str	r2, [r3, #8]
 8001c02:	9b01      	ldr	r3, [sp, #4]
 8001c04:	689b      	ldr	r3, [r3, #8]
 8001c06:	2b00      	cmp	r3, #0
 8001c08:	da1b      	bge.n	8001c42 <chSemWaitTimeoutS+0x52>
    if (TIME_IMMEDIATE == time) {
 8001c0a:	9b00      	ldr	r3, [sp, #0]
 8001c0c:	2b00      	cmp	r3, #0
 8001c0e:	d107      	bne.n	8001c20 <chSemWaitTimeoutS+0x30>
      sp->s_cnt++;
 8001c10:	9b01      	ldr	r3, [sp, #4]
 8001c12:	689b      	ldr	r3, [r3, #8]
 8001c14:	1c5a      	adds	r2, r3, #1
 8001c16:	9b01      	ldr	r3, [sp, #4]
 8001c18:	609a      	str	r2, [r3, #8]

      return MSG_TIMEOUT;
 8001c1a:	f04f 33ff 	mov.w	r3, #4294967295
 8001c1e:	e011      	b.n	8001c44 <chSemWaitTimeoutS+0x54>
    }
    currp->p_u.wtsemp = sp;
 8001c20:	4b0a      	ldr	r3, [pc, #40]	; (8001c4c <chSemWaitTimeoutS+0x5c>)
 8001c22:	699b      	ldr	r3, [r3, #24]
 8001c24:	9a01      	ldr	r2, [sp, #4]
 8001c26:	621a      	str	r2, [r3, #32]
    sem_insert(currp, &sp->s_queue);
 8001c28:	4b08      	ldr	r3, [pc, #32]	; (8001c4c <chSemWaitTimeoutS+0x5c>)
 8001c2a:	699a      	ldr	r2, [r3, #24]
 8001c2c:	9b01      	ldr	r3, [sp, #4]
 8001c2e:	4610      	mov	r0, r2
 8001c30:	4619      	mov	r1, r3
 8001c32:	f7ff feed 	bl	8001a10 <queue_insert>

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 8001c36:	2005      	movs	r0, #5
 8001c38:	9900      	ldr	r1, [sp, #0]
 8001c3a:	f7ff f841 	bl	8000cc0 <chSchGoSleepTimeoutS>
 8001c3e:	4603      	mov	r3, r0
 8001c40:	e000      	b.n	8001c44 <chSemWaitTimeoutS+0x54>
  }

  return MSG_OK;
 8001c42:	2300      	movs	r3, #0
}
 8001c44:	4618      	mov	r0, r3
 8001c46:	b003      	add	sp, #12
 8001c48:	f85d fb04 	ldr.w	pc, [sp], #4
 8001c4c:	200016e0 	.word	0x200016e0

08001c50 <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @api
 */
void chSemSignal(semaphore_t *sp) {
 8001c50:	b500      	push	{lr}
 8001c52:	b083      	sub	sp, #12
 8001c54:	9001      	str	r0, [sp, #4]
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  chSysLock();
 8001c56:	f7ff ff23 	bl	8001aa0 <chSysLock>
  if (++sp->s_cnt <= (cnt_t)0) {
 8001c5a:	9b01      	ldr	r3, [sp, #4]
 8001c5c:	689b      	ldr	r3, [r3, #8]
 8001c5e:	1c5a      	adds	r2, r3, #1
 8001c60:	9b01      	ldr	r3, [sp, #4]
 8001c62:	609a      	str	r2, [r3, #8]
 8001c64:	9b01      	ldr	r3, [sp, #4]
 8001c66:	689b      	ldr	r3, [r3, #8]
 8001c68:	2b00      	cmp	r3, #0
 8001c6a:	dc08      	bgt.n	8001c7e <chSemSignal+0x2e>
    chSchWakeupS(queue_fifo_remove(&sp->s_queue), MSG_OK);
 8001c6c:	9b01      	ldr	r3, [sp, #4]
 8001c6e:	4618      	mov	r0, r3
 8001c70:	f7ff fee6 	bl	8001a40 <queue_fifo_remove>
 8001c74:	4603      	mov	r3, r0
 8001c76:	4618      	mov	r0, r3
 8001c78:	2100      	movs	r1, #0
 8001c7a:	f7ff f859 	bl	8000d30 <chSchWakeupS>
  }
  chSysUnlock();
 8001c7e:	f7ff ff17 	bl	8001ab0 <chSysUnlock>
}
 8001c82:	b003      	add	sp, #12
 8001c84:	f85d fb04 	ldr.w	pc, [sp], #4
 8001c88:	f3af 8000 	nop.w
 8001c8c:	f3af 8000 	nop.w

08001c90 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
 8001c90:	b500      	push	{lr}
 8001c92:	b085      	sub	sp, #20
 8001c94:	9001      	str	r0, [sp, #4]
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (++sp->s_cnt <= (cnt_t)0) {
 8001c96:	9b01      	ldr	r3, [sp, #4]
 8001c98:	689b      	ldr	r3, [r3, #8]
 8001c9a:	1c5a      	adds	r2, r3, #1
 8001c9c:	9b01      	ldr	r3, [sp, #4]
 8001c9e:	609a      	str	r2, [r3, #8]
 8001ca0:	9b01      	ldr	r3, [sp, #4]
 8001ca2:	689b      	ldr	r3, [r3, #8]
 8001ca4:	2b00      	cmp	r3, #0
 8001ca6:	dc0a      	bgt.n	8001cbe <chSemSignalI+0x2e>
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
 8001ca8:	9b01      	ldr	r3, [sp, #4]
 8001caa:	4618      	mov	r0, r3
 8001cac:	f7ff fec8 	bl	8001a40 <queue_fifo_remove>
 8001cb0:	9003      	str	r0, [sp, #12]
    tp->p_u.rdymsg = MSG_OK;
 8001cb2:	9b03      	ldr	r3, [sp, #12]
 8001cb4:	2200      	movs	r2, #0
 8001cb6:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 8001cb8:	9803      	ldr	r0, [sp, #12]
 8001cba:	f7fe ff71 	bl	8000ba0 <chSchReadyI>
  }
}
 8001cbe:	b005      	add	sp, #20
 8001cc0:	f85d fb04 	ldr.w	pc, [sp], #4
 8001cc4:	f3af 8000 	nop.w
 8001cc8:	f3af 8000 	nop.w
 8001ccc:	f3af 8000 	nop.w

08001cd0 <chSemAddCounterI>:
 * @param[in] n         value to be added to the semaphore counter. The value
 *                      must be positive.
 *
 * @iclass
 */
void chSemAddCounterI(semaphore_t *sp, cnt_t n) {
 8001cd0:	b500      	push	{lr}
 8001cd2:	b083      	sub	sp, #12
 8001cd4:	9001      	str	r0, [sp, #4]
 8001cd6:	9100      	str	r1, [sp, #0]
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8001cd8:	e016      	b.n	8001d08 <chSemAddCounterI+0x38>
    if (++sp->s_cnt <= (cnt_t)0) {
 8001cda:	9b01      	ldr	r3, [sp, #4]
 8001cdc:	689b      	ldr	r3, [r3, #8]
 8001cde:	1c5a      	adds	r2, r3, #1
 8001ce0:	9b01      	ldr	r3, [sp, #4]
 8001ce2:	609a      	str	r2, [r3, #8]
 8001ce4:	9b01      	ldr	r3, [sp, #4]
 8001ce6:	689b      	ldr	r3, [r3, #8]
 8001ce8:	2b00      	cmp	r3, #0
 8001cea:	dc0a      	bgt.n	8001d02 <chSemAddCounterI+0x32>
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
 8001cec:	9b01      	ldr	r3, [sp, #4]
 8001cee:	4618      	mov	r0, r3
 8001cf0:	f7ff fea6 	bl	8001a40 <queue_fifo_remove>
 8001cf4:	4603      	mov	r3, r0
 8001cf6:	4618      	mov	r0, r3
 8001cf8:	f7fe ff52 	bl	8000ba0 <chSchReadyI>
 8001cfc:	4603      	mov	r3, r0
 8001cfe:	2200      	movs	r2, #0
 8001d00:	621a      	str	r2, [r3, #32]
    }
    n--;
 8001d02:	9b00      	ldr	r3, [sp, #0]
 8001d04:	3b01      	subs	r3, #1
 8001d06:	9300      	str	r3, [sp, #0]
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8001d08:	9b00      	ldr	r3, [sp, #0]
 8001d0a:	2b00      	cmp	r3, #0
 8001d0c:	dce5      	bgt.n	8001cda <chSemAddCounterI+0xa>
    if (++sp->s_cnt <= (cnt_t)0) {
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
    }
    n--;
  }
}
 8001d0e:	b003      	add	sp, #12
 8001d10:	f85d fb04 	ldr.w	pc, [sp], #4
 8001d14:	f3af 8000 	nop.w
 8001d18:	f3af 8000 	nop.w
 8001d1c:	f3af 8000 	nop.w

08001d20 <chSemSignalWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
 8001d20:	b500      	push	{lr}
 8001d22:	b085      	sub	sp, #20
 8001d24:	9001      	str	r0, [sp, #4]
 8001d26:	9100      	str	r1, [sp, #0]
              "inconsistent semaphore");
  chDbgAssert(((spw->s_cnt >= (cnt_t)0) && queue_isempty(&spw->s_queue)) ||
              ((spw->s_cnt < (cnt_t)0) && queue_notempty(&spw->s_queue)),
              "inconsistent semaphore");

  chSysLock();
 8001d28:	f7ff feba 	bl	8001aa0 <chSysLock>
  if (++sps->s_cnt <= (cnt_t)0) {
 8001d2c:	9b01      	ldr	r3, [sp, #4]
 8001d2e:	689b      	ldr	r3, [r3, #8]
 8001d30:	1c5a      	adds	r2, r3, #1
 8001d32:	9b01      	ldr	r3, [sp, #4]
 8001d34:	609a      	str	r2, [r3, #8]
 8001d36:	9b01      	ldr	r3, [sp, #4]
 8001d38:	689b      	ldr	r3, [r3, #8]
 8001d3a:	2b00      	cmp	r3, #0
 8001d3c:	dc0a      	bgt.n	8001d54 <chSemSignalWait+0x34>
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
 8001d3e:	9b01      	ldr	r3, [sp, #4]
 8001d40:	4618      	mov	r0, r3
 8001d42:	f7ff fe7d 	bl	8001a40 <queue_fifo_remove>
 8001d46:	4603      	mov	r3, r0
 8001d48:	4618      	mov	r0, r3
 8001d4a:	f7fe ff29 	bl	8000ba0 <chSchReadyI>
 8001d4e:	4603      	mov	r3, r0
 8001d50:	2200      	movs	r2, #0
 8001d52:	621a      	str	r2, [r3, #32]
  }
  if (--spw->s_cnt < (cnt_t)0) {
 8001d54:	9b00      	ldr	r3, [sp, #0]
 8001d56:	689b      	ldr	r3, [r3, #8]
 8001d58:	1e5a      	subs	r2, r3, #1
 8001d5a:	9b00      	ldr	r3, [sp, #0]
 8001d5c:	609a      	str	r2, [r3, #8]
 8001d5e:	9b00      	ldr	r3, [sp, #0]
 8001d60:	689b      	ldr	r3, [r3, #8]
 8001d62:	2b00      	cmp	r3, #0
 8001d64:	da11      	bge.n	8001d8a <chSemSignalWait+0x6a>
    thread_t *ctp = currp;
 8001d66:	4b0e      	ldr	r3, [pc, #56]	; (8001da0 <chSemSignalWait+0x80>)
 8001d68:	699b      	ldr	r3, [r3, #24]
 8001d6a:	9302      	str	r3, [sp, #8]
    sem_insert(ctp, &spw->s_queue);
 8001d6c:	9b00      	ldr	r3, [sp, #0]
 8001d6e:	9802      	ldr	r0, [sp, #8]
 8001d70:	4619      	mov	r1, r3
 8001d72:	f7ff fe4d 	bl	8001a10 <queue_insert>
    ctp->p_u.wtsemp = spw;
 8001d76:	9b02      	ldr	r3, [sp, #8]
 8001d78:	9a00      	ldr	r2, [sp, #0]
 8001d7a:	621a      	str	r2, [r3, #32]
    chSchGoSleepS(CH_STATE_WTSEM);
 8001d7c:	2005      	movs	r0, #5
 8001d7e:	f7fe ff37 	bl	8000bf0 <chSchGoSleepS>
    msg = ctp->p_u.rdymsg;
 8001d82:	9b02      	ldr	r3, [sp, #8]
 8001d84:	6a1b      	ldr	r3, [r3, #32]
 8001d86:	9303      	str	r3, [sp, #12]
 8001d88:	e003      	b.n	8001d92 <chSemSignalWait+0x72>
  }
  else {
    chSchRescheduleS();
 8001d8a:	f7fe fff9 	bl	8000d80 <chSchRescheduleS>
    msg = MSG_OK;
 8001d8e:	2300      	movs	r3, #0
 8001d90:	9303      	str	r3, [sp, #12]
  }
  chSysUnlock();
 8001d92:	f7ff fe8d 	bl	8001ab0 <chSysUnlock>

  return msg;
 8001d96:	9b03      	ldr	r3, [sp, #12]
}
 8001d98:	4618      	mov	r0, r3
 8001d9a:	b005      	add	sp, #20
 8001d9c:	f85d fb04 	ldr.w	pc, [sp], #4
 8001da0:	200016e0 	.word	0x200016e0
 8001da4:	f3af 8000 	nop.w
 8001da8:	f3af 8000 	nop.w
 8001dac:	f3af 8000 	nop.w

08001db0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8001db0:	b082      	sub	sp, #8
 8001db2:	2320      	movs	r3, #32
 8001db4:	9301      	str	r3, [sp, #4]
 8001db6:	9b01      	ldr	r3, [sp, #4]
 8001db8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8001dbc:	b002      	add	sp, #8
 8001dbe:	4770      	bx	lr

08001dc0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8001dc0:	b082      	sub	sp, #8
 8001dc2:	2300      	movs	r3, #0
 8001dc4:	9301      	str	r3, [sp, #4]
 8001dc6:	9b01      	ldr	r3, [sp, #4]
 8001dc8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8001dcc:	b002      	add	sp, #8
 8001dce:	4770      	bx	lr

08001dd0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8001dd0:	b082      	sub	sp, #8
 8001dd2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8001dd4:	9b01      	ldr	r3, [sp, #4]
 8001dd6:	9a01      	ldr	r2, [sp, #4]
 8001dd8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8001dda:	9b01      	ldr	r3, [sp, #4]
 8001ddc:	9a01      	ldr	r2, [sp, #4]
 8001dde:	605a      	str	r2, [r3, #4]
}
 8001de0:	b002      	add	sp, #8
 8001de2:	4770      	bx	lr
 8001de4:	f3af 8000 	nop.w
 8001de8:	f3af 8000 	nop.w
 8001dec:	f3af 8000 	nop.w

08001df0 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8001df0:	b082      	sub	sp, #8
 8001df2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8001df4:	9b01      	ldr	r3, [sp, #4]
 8001df6:	681a      	ldr	r2, [r3, #0]
 8001df8:	9b01      	ldr	r3, [sp, #4]
 8001dfa:	429a      	cmp	r2, r3
 8001dfc:	bf0c      	ite	eq
 8001dfe:	2300      	moveq	r3, #0
 8001e00:	2301      	movne	r3, #1
 8001e02:	b2db      	uxtb	r3, r3
}
 8001e04:	4618      	mov	r0, r3
 8001e06:	b002      	add	sp, #8
 8001e08:	4770      	bx	lr
 8001e0a:	bf00      	nop
 8001e0c:	f3af 8000 	nop.w

08001e10 <queue_prio_insert>:
  tlp->p_next = tp->p_next;

  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 8001e10:	b084      	sub	sp, #16
 8001e12:	9001      	str	r0, [sp, #4]
 8001e14:	9100      	str	r1, [sp, #0]

  thread_t *cp = (thread_t *)tqp;
 8001e16:	9b00      	ldr	r3, [sp, #0]
 8001e18:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 8001e1a:	9b03      	ldr	r3, [sp, #12]
 8001e1c:	681b      	ldr	r3, [r3, #0]
 8001e1e:	9303      	str	r3, [sp, #12]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001e20:	9a03      	ldr	r2, [sp, #12]
 8001e22:	9b00      	ldr	r3, [sp, #0]
 8001e24:	429a      	cmp	r2, r3
 8001e26:	d005      	beq.n	8001e34 <queue_prio_insert+0x24>
 8001e28:	9b03      	ldr	r3, [sp, #12]
 8001e2a:	689a      	ldr	r2, [r3, #8]
 8001e2c:	9b01      	ldr	r3, [sp, #4]
 8001e2e:	689b      	ldr	r3, [r3, #8]
 8001e30:	429a      	cmp	r2, r3
 8001e32:	d2f2      	bcs.n	8001e1a <queue_prio_insert+0xa>
  tp->p_next = cp;
 8001e34:	9b01      	ldr	r3, [sp, #4]
 8001e36:	9a03      	ldr	r2, [sp, #12]
 8001e38:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 8001e3a:	9b03      	ldr	r3, [sp, #12]
 8001e3c:	685a      	ldr	r2, [r3, #4]
 8001e3e:	9b01      	ldr	r3, [sp, #4]
 8001e40:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8001e42:	9b01      	ldr	r3, [sp, #4]
 8001e44:	685b      	ldr	r3, [r3, #4]
 8001e46:	9a01      	ldr	r2, [sp, #4]
 8001e48:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 8001e4a:	9b03      	ldr	r3, [sp, #12]
 8001e4c:	9a01      	ldr	r2, [sp, #4]
 8001e4e:	605a      	str	r2, [r3, #4]
}
 8001e50:	b004      	add	sp, #16
 8001e52:	4770      	bx	lr
 8001e54:	f3af 8000 	nop.w
 8001e58:	f3af 8000 	nop.w
 8001e5c:	f3af 8000 	nop.w

08001e60 <queue_fifo_remove>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8001e60:	b084      	sub	sp, #16
 8001e62:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8001e64:	9b01      	ldr	r3, [sp, #4]
 8001e66:	681b      	ldr	r3, [r3, #0]
 8001e68:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8001e6a:	9b03      	ldr	r3, [sp, #12]
 8001e6c:	681a      	ldr	r2, [r3, #0]
 8001e6e:	9b01      	ldr	r3, [sp, #4]
 8001e70:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001e72:	9b01      	ldr	r3, [sp, #4]
 8001e74:	681b      	ldr	r3, [r3, #0]
 8001e76:	9a01      	ldr	r2, [sp, #4]
 8001e78:	605a      	str	r2, [r3, #4]

  return tp;
 8001e7a:	9b03      	ldr	r3, [sp, #12]
}
 8001e7c:	4618      	mov	r0, r3
 8001e7e:	b004      	add	sp, #16
 8001e80:	4770      	bx	lr
 8001e82:	bf00      	nop
 8001e84:	f3af 8000 	nop.w
 8001e88:	f3af 8000 	nop.w
 8001e8c:	f3af 8000 	nop.w

08001e90 <queue_dequeue>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 8001e90:	b082      	sub	sp, #8
 8001e92:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
 8001e94:	9b01      	ldr	r3, [sp, #4]
 8001e96:	685b      	ldr	r3, [r3, #4]
 8001e98:	9a01      	ldr	r2, [sp, #4]
 8001e9a:	6812      	ldr	r2, [r2, #0]
 8001e9c:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8001e9e:	9b01      	ldr	r3, [sp, #4]
 8001ea0:	681b      	ldr	r3, [r3, #0]
 8001ea2:	9a01      	ldr	r2, [sp, #4]
 8001ea4:	6852      	ldr	r2, [r2, #4]
 8001ea6:	605a      	str	r2, [r3, #4]

  return tp;
 8001ea8:	9b01      	ldr	r3, [sp, #4]
}
 8001eaa:	4618      	mov	r0, r3
 8001eac:	b002      	add	sp, #8
 8001eae:	4770      	bx	lr

08001eb0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001eb0:	b508      	push	{r3, lr}

  port_lock();
 8001eb2:	f7ff ff7d 	bl	8001db0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001eb6:	bd08      	pop	{r3, pc}
 8001eb8:	f3af 8000 	nop.w
 8001ebc:	f3af 8000 	nop.w

08001ec0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001ec0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001ec2:	f7ff ff7d 	bl	8001dc0 <port_unlock>
}
 8001ec6:	bd08      	pop	{r3, pc}
 8001ec8:	f3af 8000 	nop.w
 8001ecc:	f3af 8000 	nop.w

08001ed0 <chMtxQueueNotEmptyS>:
 * @return              The mutex queue status.
 *
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
 8001ed0:	b500      	push	{lr}
 8001ed2:	b083      	sub	sp, #12
 8001ed4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();

  return queue_notempty(&mp->m_queue);
 8001ed6:	9b01      	ldr	r3, [sp, #4]
 8001ed8:	4618      	mov	r0, r3
 8001eda:	f7ff ff89 	bl	8001df0 <queue_notempty>
 8001ede:	4603      	mov	r3, r0
}
 8001ee0:	4618      	mov	r0, r3
 8001ee2:	b003      	add	sp, #12
 8001ee4:	f85d fb04 	ldr.w	pc, [sp], #4
 8001ee8:	f3af 8000 	nop.w
 8001eec:	f3af 8000 	nop.w

08001ef0 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8001ef0:	b500      	push	{lr}
 8001ef2:	b083      	sub	sp, #12
 8001ef4:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
 8001ef6:	9b01      	ldr	r3, [sp, #4]
 8001ef8:	4618      	mov	r0, r3
 8001efa:	f7ff ff69 	bl	8001dd0 <queue_init>
  mp->m_owner = NULL;
 8001efe:	9b01      	ldr	r3, [sp, #4]
 8001f00:	2200      	movs	r2, #0
 8001f02:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->m_cnt = (cnt_t)0;
#endif
}
 8001f04:	b003      	add	sp, #12
 8001f06:	f85d fb04 	ldr.w	pc, [sp], #4
 8001f0a:	bf00      	nop
 8001f0c:	f3af 8000 	nop.w

08001f10 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 8001f10:	b500      	push	{lr}
 8001f12:	b083      	sub	sp, #12
 8001f14:	9001      	str	r0, [sp, #4]

  chSysLock();
 8001f16:	f7ff ffcb 	bl	8001eb0 <chSysLock>
  chMtxLockS(mp);
 8001f1a:	9801      	ldr	r0, [sp, #4]
 8001f1c:	f000 f808 	bl	8001f30 <chMtxLockS>
  chSysUnlock();
 8001f20:	f7ff ffce 	bl	8001ec0 <chSysUnlock>
}
 8001f24:	b003      	add	sp, #12
 8001f26:	f85d fb04 	ldr.w	pc, [sp], #4
 8001f2a:	bf00      	nop
 8001f2c:	f3af 8000 	nop.w

08001f30 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8001f30:	b500      	push	{lr}
 8001f32:	b085      	sub	sp, #20
 8001f34:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8001f36:	4b2d      	ldr	r3, [pc, #180]	; (8001fec <chMtxLockS+0xbc>)
 8001f38:	699b      	ldr	r3, [r3, #24]
 8001f3a:	9302      	str	r3, [sp, #8]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 8001f3c:	9b01      	ldr	r3, [sp, #4]
 8001f3e:	689b      	ldr	r3, [r3, #8]
 8001f40:	2b00      	cmp	r3, #0
 8001f42:	d045      	beq.n	8001fd0 <chMtxLockS+0xa0>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;
 8001f44:	9b01      	ldr	r3, [sp, #4]
 8001f46:	689b      	ldr	r3, [r3, #8]
 8001f48:	9303      	str	r3, [sp, #12]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 8001f4a:	e02f      	b.n	8001fac <chMtxLockS+0x7c>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
 8001f4c:	9b02      	ldr	r3, [sp, #8]
 8001f4e:	689a      	ldr	r2, [r3, #8]
 8001f50:	9b03      	ldr	r3, [sp, #12]
 8001f52:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 8001f54:	9b03      	ldr	r3, [sp, #12]
 8001f56:	7f1b      	ldrb	r3, [r3, #28]
 8001f58:	2b06      	cmp	r3, #6
 8001f5a:	d004      	beq.n	8001f66 <chMtxLockS+0x36>
 8001f5c:	2b07      	cmp	r3, #7
 8001f5e:	d011      	beq.n	8001f84 <chMtxLockS+0x54>
 8001f60:	2b00      	cmp	r3, #0
 8001f62:	d01a      	beq.n	8001f9a <chMtxLockS+0x6a>
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
          break;
        default:
          /* Nothing to do for other states.*/
          break;
 8001f64:	e021      	b.n	8001faa <chMtxLockS+0x7a>

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8001f66:	9803      	ldr	r0, [sp, #12]
 8001f68:	f7ff ff92 	bl	8001e90 <queue_dequeue>
 8001f6c:	4602      	mov	r2, r0
 8001f6e:	9b03      	ldr	r3, [sp, #12]
 8001f70:	6a1b      	ldr	r3, [r3, #32]
 8001f72:	4610      	mov	r0, r2
 8001f74:	4619      	mov	r1, r3
 8001f76:	f7ff ff4b 	bl	8001e10 <queue_prio_insert>
          tp = tp->p_u.wtmtxp->m_owner;
 8001f7a:	9b03      	ldr	r3, [sp, #12]
 8001f7c:	6a1b      	ldr	r3, [r3, #32]
 8001f7e:	689b      	ldr	r3, [r3, #8]
 8001f80:	9303      	str	r3, [sp, #12]
          /*lint -e{9042} [16.1] Continues the while.*/
          continue;
 8001f82:	e013      	b.n	8001fac <chMtxLockS+0x7c>
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8001f84:	9803      	ldr	r0, [sp, #12]
 8001f86:	f7ff ff83 	bl	8001e90 <queue_dequeue>
 8001f8a:	4602      	mov	r2, r0
 8001f8c:	9b03      	ldr	r3, [sp, #12]
 8001f8e:	6a1b      	ldr	r3, [r3, #32]
 8001f90:	4610      	mov	r0, r2
 8001f92:	4619      	mov	r1, r3
 8001f94:	f7ff ff3c 	bl	8001e10 <queue_prio_insert>
          break;
 8001f98:	e007      	b.n	8001faa <chMtxLockS+0x7a>
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 8001f9a:	9803      	ldr	r0, [sp, #12]
 8001f9c:	f7ff ff78 	bl	8001e90 <queue_dequeue>
 8001fa0:	4603      	mov	r3, r0
 8001fa2:	4618      	mov	r0, r3
 8001fa4:	f7fe fdfc 	bl	8000ba0 <chSchReadyI>
          break;
 8001fa8:	bf00      	nop
        default:
          /* Nothing to do for other states.*/
          break;
        }
        break;
 8001faa:	e005      	b.n	8001fb8 <chMtxLockS+0x88>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 8001fac:	9b03      	ldr	r3, [sp, #12]
 8001fae:	689a      	ldr	r2, [r3, #8]
 8001fb0:	9b02      	ldr	r3, [sp, #8]
 8001fb2:	689b      	ldr	r3, [r3, #8]
 8001fb4:	429a      	cmp	r2, r3
 8001fb6:	d3c9      	bcc.n	8001f4c <chMtxLockS+0x1c>
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
 8001fb8:	9b01      	ldr	r3, [sp, #4]
 8001fba:	9802      	ldr	r0, [sp, #8]
 8001fbc:	4619      	mov	r1, r3
 8001fbe:	f7ff ff27 	bl	8001e10 <queue_prio_insert>
      ctp->p_u.wtmtxp = mp;
 8001fc2:	9b02      	ldr	r3, [sp, #8]
 8001fc4:	9a01      	ldr	r2, [sp, #4]
 8001fc6:	621a      	str	r2, [r3, #32]
      chSchGoSleepS(CH_STATE_WTMTX);
 8001fc8:	2006      	movs	r0, #6
 8001fca:	f7fe fe11 	bl	8000bf0 <chSchGoSleepS>
 8001fce:	e009      	b.n	8001fe4 <chMtxLockS+0xb4>
    chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 8001fd0:	9b01      	ldr	r3, [sp, #4]
 8001fd2:	9a02      	ldr	r2, [sp, #8]
 8001fd4:	609a      	str	r2, [r3, #8]
    mp->m_next = ctp->p_mtxlist;
 8001fd6:	9b02      	ldr	r3, [sp, #8]
 8001fd8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001fda:	9b01      	ldr	r3, [sp, #4]
 8001fdc:	60da      	str	r2, [r3, #12]
    ctp->p_mtxlist = mp;
 8001fde:	9b02      	ldr	r3, [sp, #8]
 8001fe0:	9a01      	ldr	r2, [sp, #4]
 8001fe2:	639a      	str	r2, [r3, #56]	; 0x38
  }
}
 8001fe4:	b005      	add	sp, #20
 8001fe6:	f85d fb04 	ldr.w	pc, [sp], #4
 8001fea:	bf00      	nop
 8001fec:	200016e0 	.word	0x200016e0

08001ff0 <chMtxTryLock>:
 * @retval true         if the mutex has been successfully acquired
 * @retval false        if the lock attempt failed.
 *
 * @api
 */
bool chMtxTryLock(mutex_t *mp) {
 8001ff0:	b500      	push	{lr}
 8001ff2:	b085      	sub	sp, #20
 8001ff4:	9001      	str	r0, [sp, #4]
  bool b;

  chSysLock();
 8001ff6:	f7ff ff5b 	bl	8001eb0 <chSysLock>
  b = chMtxTryLockS(mp);
 8001ffa:	9801      	ldr	r0, [sp, #4]
 8001ffc:	f000 f810 	bl	8002020 <chMtxTryLockS>
 8002000:	4603      	mov	r3, r0
 8002002:	f88d 300f 	strb.w	r3, [sp, #15]
  chSysUnlock();
 8002006:	f7ff ff5b 	bl	8001ec0 <chSysUnlock>

  return b;
 800200a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 800200e:	4618      	mov	r0, r3
 8002010:	b005      	add	sp, #20
 8002012:	f85d fb04 	ldr.w	pc, [sp], #4
 8002016:	bf00      	nop
 8002018:	f3af 8000 	nop.w
 800201c:	f3af 8000 	nop.w

08002020 <chMtxTryLockS>:
 * @retval true         if the mutex has been successfully acquired
 * @retval false        if the lock attempt failed.
 *
 * @sclass
 */
bool chMtxTryLockS(mutex_t *mp) {
 8002020:	b082      	sub	sp, #8
 8002022:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->m_owner != NULL) {
 8002024:	9b01      	ldr	r3, [sp, #4]
 8002026:	689b      	ldr	r3, [r3, #8]
 8002028:	2b00      	cmp	r3, #0
 800202a:	d001      	beq.n	8002030 <chMtxTryLockS+0x10>
    if (mp->m_owner == currp) {
      mp->m_cnt++;
      return true;
    }
#endif
    return false;
 800202c:	2300      	movs	r3, #0
 800202e:	e00d      	b.n	800204c <chMtxTryLockS+0x2c>

  chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
 8002030:	4b08      	ldr	r3, [pc, #32]	; (8002054 <chMtxTryLockS+0x34>)
 8002032:	699a      	ldr	r2, [r3, #24]
 8002034:	9b01      	ldr	r3, [sp, #4]
 8002036:	609a      	str	r2, [r3, #8]
  mp->m_next = currp->p_mtxlist;
 8002038:	4b06      	ldr	r3, [pc, #24]	; (8002054 <chMtxTryLockS+0x34>)
 800203a:	699b      	ldr	r3, [r3, #24]
 800203c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800203e:	9b01      	ldr	r3, [sp, #4]
 8002040:	60da      	str	r2, [r3, #12]
  currp->p_mtxlist = mp;
 8002042:	4b04      	ldr	r3, [pc, #16]	; (8002054 <chMtxTryLockS+0x34>)
 8002044:	699b      	ldr	r3, [r3, #24]
 8002046:	9a01      	ldr	r2, [sp, #4]
 8002048:	639a      	str	r2, [r3, #56]	; 0x38
  return true;
 800204a:	2301      	movs	r3, #1
}
 800204c:	4618      	mov	r0, r3
 800204e:	b002      	add	sp, #8
 8002050:	4770      	bx	lr
 8002052:	bf00      	nop
 8002054:	200016e0 	.word	0x200016e0
 8002058:	f3af 8000 	nop.w
 800205c:	f3af 8000 	nop.w

08002060 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8002060:	b500      	push	{lr}
 8002062:	b087      	sub	sp, #28
 8002064:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002066:	4b26      	ldr	r3, [pc, #152]	; (8002100 <chMtxUnlock+0xa0>)
 8002068:	699b      	ldr	r3, [r3, #24]
 800206a:	9303      	str	r3, [sp, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);

  chSysLock();
 800206c:	f7ff ff20 	bl	8001eb0 <chSysLock>
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 8002070:	9b01      	ldr	r3, [sp, #4]
 8002072:	68da      	ldr	r2, [r3, #12]
 8002074:	9b03      	ldr	r3, [sp, #12]
 8002076:	639a      	str	r2, [r3, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8002078:	9801      	ldr	r0, [sp, #4]
 800207a:	f7ff ff29 	bl	8001ed0 <chMtxQueueNotEmptyS>
 800207e:	4603      	mov	r3, r0
 8002080:	2b00      	cmp	r3, #0
 8002082:	d034      	beq.n	80020ee <chMtxUnlock+0x8e>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 8002084:	9b03      	ldr	r3, [sp, #12]
 8002086:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002088:	9304      	str	r3, [sp, #16]
      lmp = ctp->p_mtxlist;
 800208a:	9b03      	ldr	r3, [sp, #12]
 800208c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800208e:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 8002090:	e012      	b.n	80020b8 <chMtxUnlock+0x58>
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8002092:	9805      	ldr	r0, [sp, #20]
 8002094:	f7ff ff1c 	bl	8001ed0 <chMtxQueueNotEmptyS>
 8002098:	4603      	mov	r3, r0
 800209a:	2b00      	cmp	r3, #0
 800209c:	d009      	beq.n	80020b2 <chMtxUnlock+0x52>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 800209e:	9b05      	ldr	r3, [sp, #20]
 80020a0:	681b      	ldr	r3, [r3, #0]
 80020a2:	689a      	ldr	r2, [r3, #8]
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80020a4:	9b04      	ldr	r3, [sp, #16]
 80020a6:	429a      	cmp	r2, r3
 80020a8:	d903      	bls.n	80020b2 <chMtxUnlock+0x52>
            (lmp->m_queue.p_next->p_prio > newprio)) {
          newprio = lmp->m_queue.p_next->p_prio;
 80020aa:	9b05      	ldr	r3, [sp, #20]
 80020ac:	681b      	ldr	r3, [r3, #0]
 80020ae:	689b      	ldr	r3, [r3, #8]
 80020b0:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->m_next;
 80020b2:	9b05      	ldr	r3, [sp, #20]
 80020b4:	68db      	ldr	r3, [r3, #12]
 80020b6:	9305      	str	r3, [sp, #20]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 80020b8:	9b05      	ldr	r3, [sp, #20]
 80020ba:	2b00      	cmp	r3, #0
 80020bc:	d1e9      	bne.n	8002092 <chMtxUnlock+0x32>
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 80020be:	9b03      	ldr	r3, [sp, #12]
 80020c0:	9a04      	ldr	r2, [sp, #16]
 80020c2:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
 80020c4:	9b01      	ldr	r3, [sp, #4]
 80020c6:	4618      	mov	r0, r3
 80020c8:	f7ff feca 	bl	8001e60 <queue_fifo_remove>
 80020cc:	9002      	str	r0, [sp, #8]
      mp->m_owner = tp;
 80020ce:	9b01      	ldr	r3, [sp, #4]
 80020d0:	9a02      	ldr	r2, [sp, #8]
 80020d2:	609a      	str	r2, [r3, #8]
      mp->m_next = tp->p_mtxlist;
 80020d4:	9b02      	ldr	r3, [sp, #8]
 80020d6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80020d8:	9b01      	ldr	r3, [sp, #4]
 80020da:	60da      	str	r2, [r3, #12]
      tp->p_mtxlist = mp;
 80020dc:	9b02      	ldr	r3, [sp, #8]
 80020de:	9a01      	ldr	r2, [sp, #4]
 80020e0:	639a      	str	r2, [r3, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 80020e2:	9802      	ldr	r0, [sp, #8]
 80020e4:	f7fe fd5c 	bl	8000ba0 <chSchReadyI>
      chSchRescheduleS();
 80020e8:	f7fe fe4a 	bl	8000d80 <chSchRescheduleS>
 80020ec:	e002      	b.n	80020f4 <chMtxUnlock+0x94>
    }
    else {
      mp->m_owner = NULL;
 80020ee:	9b01      	ldr	r3, [sp, #4]
 80020f0:	2200      	movs	r2, #0
 80020f2:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
 80020f4:	f7ff fee4 	bl	8001ec0 <chSysUnlock>
}
 80020f8:	b007      	add	sp, #28
 80020fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80020fe:	bf00      	nop
 8002100:	200016e0 	.word	0x200016e0
 8002104:	f3af 8000 	nop.w
 8002108:	f3af 8000 	nop.w
 800210c:	f3af 8000 	nop.w

08002110 <chMtxUnlockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 8002110:	b500      	push	{lr}
 8002112:	b087      	sub	sp, #28
 8002114:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002116:	4b23      	ldr	r3, [pc, #140]	; (80021a4 <chMtxUnlockS+0x94>)
 8002118:	699b      	ldr	r3, [r3, #24]
 800211a:	9303      	str	r3, [sp, #12]
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 800211c:	9b01      	ldr	r3, [sp, #4]
 800211e:	68da      	ldr	r2, [r3, #12]
 8002120:	9b03      	ldr	r3, [sp, #12]
 8002122:	639a      	str	r2, [r3, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8002124:	9801      	ldr	r0, [sp, #4]
 8002126:	f7ff fed3 	bl	8001ed0 <chMtxQueueNotEmptyS>
 800212a:	4603      	mov	r3, r0
 800212c:	2b00      	cmp	r3, #0
 800212e:	d032      	beq.n	8002196 <chMtxUnlockS+0x86>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 8002130:	9b03      	ldr	r3, [sp, #12]
 8002132:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002134:	9304      	str	r3, [sp, #16]
      lmp = ctp->p_mtxlist;
 8002136:	9b03      	ldr	r3, [sp, #12]
 8002138:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800213a:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 800213c:	e012      	b.n	8002164 <chMtxUnlockS+0x54>
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800213e:	9805      	ldr	r0, [sp, #20]
 8002140:	f7ff fec6 	bl	8001ed0 <chMtxQueueNotEmptyS>
 8002144:	4603      	mov	r3, r0
 8002146:	2b00      	cmp	r3, #0
 8002148:	d009      	beq.n	800215e <chMtxUnlockS+0x4e>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 800214a:	9b05      	ldr	r3, [sp, #20]
 800214c:	681b      	ldr	r3, [r3, #0]
 800214e:	689a      	ldr	r2, [r3, #8]
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8002150:	9b04      	ldr	r3, [sp, #16]
 8002152:	429a      	cmp	r2, r3
 8002154:	d903      	bls.n	800215e <chMtxUnlockS+0x4e>
            (lmp->m_queue.p_next->p_prio > newprio)) {
          newprio = lmp->m_queue.p_next->p_prio;
 8002156:	9b05      	ldr	r3, [sp, #20]
 8002158:	681b      	ldr	r3, [r3, #0]
 800215a:	689b      	ldr	r3, [r3, #8]
 800215c:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->m_next;
 800215e:	9b05      	ldr	r3, [sp, #20]
 8002160:	68db      	ldr	r3, [r3, #12]
 8002162:	9305      	str	r3, [sp, #20]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8002164:	9b05      	ldr	r3, [sp, #20]
 8002166:	2b00      	cmp	r3, #0
 8002168:	d1e9      	bne.n	800213e <chMtxUnlockS+0x2e>
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 800216a:	9b03      	ldr	r3, [sp, #12]
 800216c:	9a04      	ldr	r2, [sp, #16]
 800216e:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
 8002170:	9b01      	ldr	r3, [sp, #4]
 8002172:	4618      	mov	r0, r3
 8002174:	f7ff fe74 	bl	8001e60 <queue_fifo_remove>
 8002178:	9002      	str	r0, [sp, #8]
      mp->m_owner = tp;
 800217a:	9b01      	ldr	r3, [sp, #4]
 800217c:	9a02      	ldr	r2, [sp, #8]
 800217e:	609a      	str	r2, [r3, #8]
      mp->m_next = tp->p_mtxlist;
 8002180:	9b02      	ldr	r3, [sp, #8]
 8002182:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002184:	9b01      	ldr	r3, [sp, #4]
 8002186:	60da      	str	r2, [r3, #12]
      tp->p_mtxlist = mp;
 8002188:	9b02      	ldr	r3, [sp, #8]
 800218a:	9a01      	ldr	r2, [sp, #4]
 800218c:	639a      	str	r2, [r3, #56]	; 0x38
      (void) chSchReadyI(tp);
 800218e:	9802      	ldr	r0, [sp, #8]
 8002190:	f7fe fd06 	bl	8000ba0 <chSchReadyI>
 8002194:	e002      	b.n	800219c <chMtxUnlockS+0x8c>
    }
    else {
      mp->m_owner = NULL;
 8002196:	9b01      	ldr	r3, [sp, #4]
 8002198:	2200      	movs	r2, #0
 800219a:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 800219c:	b007      	add	sp, #28
 800219e:	f85d fb04 	ldr.w	pc, [sp], #4
 80021a2:	bf00      	nop
 80021a4:	200016e0 	.word	0x200016e0
 80021a8:	f3af 8000 	nop.w
 80021ac:	f3af 8000 	nop.w

080021b0 <chMtxUnlockAll>:
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
 80021b0:	b500      	push	{lr}
 80021b2:	b085      	sub	sp, #20
  thread_t *ctp = currp;
 80021b4:	4b1d      	ldr	r3, [pc, #116]	; (800222c <chMtxUnlockAll+0x7c>)
 80021b6:	699b      	ldr	r3, [r3, #24]
 80021b8:	9303      	str	r3, [sp, #12]

  chSysLock();
 80021ba:	f7ff fe79 	bl	8001eb0 <chSysLock>
  if (ctp->p_mtxlist != NULL) {
 80021be:	9b03      	ldr	r3, [sp, #12]
 80021c0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80021c2:	2b00      	cmp	r3, #0
 80021c4:	d02c      	beq.n	8002220 <chMtxUnlockAll+0x70>
    do {
      mutex_t *mp = ctp->p_mtxlist;
 80021c6:	9b03      	ldr	r3, [sp, #12]
 80021c8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80021ca:	9302      	str	r3, [sp, #8]
      ctp->p_mtxlist = mp->m_next;
 80021cc:	9b02      	ldr	r3, [sp, #8]
 80021ce:	68da      	ldr	r2, [r3, #12]
 80021d0:	9b03      	ldr	r3, [sp, #12]
 80021d2:	639a      	str	r2, [r3, #56]	; 0x38
      if (chMtxQueueNotEmptyS(mp)) {
 80021d4:	9802      	ldr	r0, [sp, #8]
 80021d6:	f7ff fe7b 	bl	8001ed0 <chMtxQueueNotEmptyS>
 80021da:	4603      	mov	r3, r0
 80021dc:	2b00      	cmp	r3, #0
 80021de:	d012      	beq.n	8002206 <chMtxUnlockAll+0x56>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->m_queue);
 80021e0:	9b02      	ldr	r3, [sp, #8]
 80021e2:	4618      	mov	r0, r3
 80021e4:	f7ff fe3c 	bl	8001e60 <queue_fifo_remove>
 80021e8:	9001      	str	r0, [sp, #4]
        mp->m_owner = tp;
 80021ea:	9b02      	ldr	r3, [sp, #8]
 80021ec:	9a01      	ldr	r2, [sp, #4]
 80021ee:	609a      	str	r2, [r3, #8]
        mp->m_next = tp->p_mtxlist;
 80021f0:	9b01      	ldr	r3, [sp, #4]
 80021f2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80021f4:	9b02      	ldr	r3, [sp, #8]
 80021f6:	60da      	str	r2, [r3, #12]
        tp->p_mtxlist = mp;
 80021f8:	9b01      	ldr	r3, [sp, #4]
 80021fa:	9a02      	ldr	r2, [sp, #8]
 80021fc:	639a      	str	r2, [r3, #56]	; 0x38
        (void) chSchReadyI(tp);
 80021fe:	9801      	ldr	r0, [sp, #4]
 8002200:	f7fe fcce 	bl	8000ba0 <chSchReadyI>
 8002204:	e002      	b.n	800220c <chMtxUnlockAll+0x5c>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)0;
#endif
        mp->m_owner = NULL;
 8002206:	9b02      	ldr	r3, [sp, #8]
 8002208:	2200      	movs	r2, #0
 800220a:	609a      	str	r2, [r3, #8]
      }
    } while (ctp->p_mtxlist != NULL);
 800220c:	9b03      	ldr	r3, [sp, #12]
 800220e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002210:	2b00      	cmp	r3, #0
 8002212:	d1d8      	bne.n	80021c6 <chMtxUnlockAll+0x16>
    ctp->p_prio = ctp->p_realprio;
 8002214:	9b03      	ldr	r3, [sp, #12]
 8002216:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8002218:	9b03      	ldr	r3, [sp, #12]
 800221a:	609a      	str	r2, [r3, #8]
    chSchRescheduleS();
 800221c:	f7fe fdb0 	bl	8000d80 <chSchRescheduleS>
  }
  chSysUnlock();
 8002220:	f7ff fe4e 	bl	8001ec0 <chSysUnlock>
}
 8002224:	b005      	add	sp, #20
 8002226:	f85d fb04 	ldr.w	pc, [sp], #4
 800222a:	bf00      	nop
 800222c:	200016e0 	.word	0x200016e0

08002230 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002230:	b082      	sub	sp, #8
 8002232:	2320      	movs	r3, #32
 8002234:	9301      	str	r3, [sp, #4]
 8002236:	9b01      	ldr	r3, [sp, #4]
 8002238:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800223c:	b002      	add	sp, #8
 800223e:	4770      	bx	lr

08002240 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002240:	b082      	sub	sp, #8
 8002242:	2300      	movs	r3, #0
 8002244:	9301      	str	r3, [sp, #4]
 8002246:	9b01      	ldr	r3, [sp, #4]
 8002248:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800224c:	b002      	add	sp, #8
 800224e:	4770      	bx	lr

08002250 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8002250:	b082      	sub	sp, #8
 8002252:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8002254:	9b01      	ldr	r3, [sp, #4]
 8002256:	9a01      	ldr	r2, [sp, #4]
 8002258:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800225a:	9b01      	ldr	r3, [sp, #4]
 800225c:	9a01      	ldr	r2, [sp, #4]
 800225e:	605a      	str	r2, [r3, #4]
}
 8002260:	b002      	add	sp, #8
 8002262:	4770      	bx	lr
 8002264:	f3af 8000 	nop.w
 8002268:	f3af 8000 	nop.w
 800226c:	f3af 8000 	nop.w

08002270 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8002270:	b082      	sub	sp, #8
 8002272:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8002274:	9b01      	ldr	r3, [sp, #4]
 8002276:	681a      	ldr	r2, [r3, #0]
 8002278:	9b01      	ldr	r3, [sp, #4]
 800227a:	429a      	cmp	r2, r3
 800227c:	bf0c      	ite	eq
 800227e:	2300      	moveq	r3, #0
 8002280:	2301      	movne	r3, #1
 8002282:	b2db      	uxtb	r3, r3
}
 8002284:	4618      	mov	r0, r3
 8002286:	b002      	add	sp, #8
 8002288:	4770      	bx	lr
 800228a:	bf00      	nop
 800228c:	f3af 8000 	nop.w

08002290 <queue_prio_insert>:
  tlp->p_next = tp->p_next;

  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 8002290:	b084      	sub	sp, #16
 8002292:	9001      	str	r0, [sp, #4]
 8002294:	9100      	str	r1, [sp, #0]

  thread_t *cp = (thread_t *)tqp;
 8002296:	9b00      	ldr	r3, [sp, #0]
 8002298:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 800229a:	9b03      	ldr	r3, [sp, #12]
 800229c:	681b      	ldr	r3, [r3, #0]
 800229e:	9303      	str	r3, [sp, #12]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 80022a0:	9a03      	ldr	r2, [sp, #12]
 80022a2:	9b00      	ldr	r3, [sp, #0]
 80022a4:	429a      	cmp	r2, r3
 80022a6:	d005      	beq.n	80022b4 <queue_prio_insert+0x24>
 80022a8:	9b03      	ldr	r3, [sp, #12]
 80022aa:	689a      	ldr	r2, [r3, #8]
 80022ac:	9b01      	ldr	r3, [sp, #4]
 80022ae:	689b      	ldr	r3, [r3, #8]
 80022b0:	429a      	cmp	r2, r3
 80022b2:	d2f2      	bcs.n	800229a <queue_prio_insert+0xa>
  tp->p_next = cp;
 80022b4:	9b01      	ldr	r3, [sp, #4]
 80022b6:	9a03      	ldr	r2, [sp, #12]
 80022b8:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 80022ba:	9b03      	ldr	r3, [sp, #12]
 80022bc:	685a      	ldr	r2, [r3, #4]
 80022be:	9b01      	ldr	r3, [sp, #4]
 80022c0:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 80022c2:	9b01      	ldr	r3, [sp, #4]
 80022c4:	685b      	ldr	r3, [r3, #4]
 80022c6:	9a01      	ldr	r2, [sp, #4]
 80022c8:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 80022ca:	9b03      	ldr	r3, [sp, #12]
 80022cc:	9a01      	ldr	r2, [sp, #4]
 80022ce:	605a      	str	r2, [r3, #4]
}
 80022d0:	b004      	add	sp, #16
 80022d2:	4770      	bx	lr
 80022d4:	f3af 8000 	nop.w
 80022d8:	f3af 8000 	nop.w
 80022dc:	f3af 8000 	nop.w

080022e0 <queue_fifo_remove>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 80022e0:	b084      	sub	sp, #16
 80022e2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 80022e4:	9b01      	ldr	r3, [sp, #4]
 80022e6:	681b      	ldr	r3, [r3, #0]
 80022e8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 80022ea:	9b03      	ldr	r3, [sp, #12]
 80022ec:	681a      	ldr	r2, [r3, #0]
 80022ee:	9b01      	ldr	r3, [sp, #4]
 80022f0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80022f2:	9b01      	ldr	r3, [sp, #4]
 80022f4:	681b      	ldr	r3, [r3, #0]
 80022f6:	9a01      	ldr	r2, [sp, #4]
 80022f8:	605a      	str	r2, [r3, #4]

  return tp;
 80022fa:	9b03      	ldr	r3, [sp, #12]
}
 80022fc:	4618      	mov	r0, r3
 80022fe:	b004      	add	sp, #16
 8002300:	4770      	bx	lr
 8002302:	bf00      	nop
 8002304:	f3af 8000 	nop.w
 8002308:	f3af 8000 	nop.w
 800230c:	f3af 8000 	nop.w

08002310 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8002310:	b508      	push	{r3, lr}

  port_lock();
 8002312:	f7ff ff8d 	bl	8002230 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002316:	bd08      	pop	{r3, pc}
 8002318:	f3af 8000 	nop.w
 800231c:	f3af 8000 	nop.w

08002320 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002320:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8002322:	f7ff ff8d 	bl	8002240 <port_unlock>
}
 8002326:	bd08      	pop	{r3, pc}
 8002328:	f3af 8000 	nop.w
 800232c:	f3af 8000 	nop.w

08002330 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002330:	4b01      	ldr	r3, [pc, #4]	; (8002338 <chThdGetSelfX+0x8>)
 8002332:	699b      	ldr	r3, [r3, #24]
}
 8002334:	4618      	mov	r0, r3
 8002336:	4770      	bx	lr
 8002338:	200016e0 	.word	0x200016e0
 800233c:	f3af 8000 	nop.w

08002340 <chMtxGetNextMutexS>:
 * @return              A pointer to the next mutex in the stack.
 * @retval NULL         if the stack is empty.
 *
 * @sclass
 */
static inline mutex_t *chMtxGetNextMutexS(void) {
 8002340:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_mtxlist;
 8002342:	f7ff fff5 	bl	8002330 <chThdGetSelfX>
 8002346:	4603      	mov	r3, r0
 8002348:	6b9b      	ldr	r3, [r3, #56]	; 0x38
}
 800234a:	4618      	mov	r0, r3
 800234c:	bd08      	pop	{r3, pc}
 800234e:	bf00      	nop

08002350 <chCondObjectInit>:
 *
 * @param[out] cp       pointer to a @p condition_variable_t structure
 *
 * @init
 */
void chCondObjectInit(condition_variable_t *cp) {
 8002350:	b500      	push	{lr}
 8002352:	b083      	sub	sp, #12
 8002354:	9001      	str	r0, [sp, #4]

  chDbgCheck(cp != NULL);

  queue_init(&cp->c_queue);
 8002356:	9b01      	ldr	r3, [sp, #4]
 8002358:	4618      	mov	r0, r3
 800235a:	f7ff ff79 	bl	8002250 <queue_init>
}
 800235e:	b003      	add	sp, #12
 8002360:	f85d fb04 	ldr.w	pc, [sp], #4
 8002364:	f3af 8000 	nop.w
 8002368:	f3af 8000 	nop.w
 800236c:	f3af 8000 	nop.w

08002370 <chCondSignal>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondSignal(condition_variable_t *cp) {
 8002370:	b500      	push	{lr}
 8002372:	b083      	sub	sp, #12
 8002374:	9001      	str	r0, [sp, #4]

  chDbgCheck(cp != NULL);

  chSysLock();
 8002376:	f7ff ffcb 	bl	8002310 <chSysLock>
  if (queue_notempty(&cp->c_queue)) {
 800237a:	9b01      	ldr	r3, [sp, #4]
 800237c:	4618      	mov	r0, r3
 800237e:	f7ff ff77 	bl	8002270 <queue_notempty>
 8002382:	4603      	mov	r3, r0
 8002384:	2b00      	cmp	r3, #0
 8002386:	d008      	beq.n	800239a <chCondSignal+0x2a>
    chSchWakeupS(queue_fifo_remove(&cp->c_queue), MSG_OK);
 8002388:	9b01      	ldr	r3, [sp, #4]
 800238a:	4618      	mov	r0, r3
 800238c:	f7ff ffa8 	bl	80022e0 <queue_fifo_remove>
 8002390:	4603      	mov	r3, r0
 8002392:	4618      	mov	r0, r3
 8002394:	2100      	movs	r1, #0
 8002396:	f7fe fccb 	bl	8000d30 <chSchWakeupS>
  }
  chSysUnlock();
 800239a:	f7ff ffc1 	bl	8002320 <chSysUnlock>
}
 800239e:	b003      	add	sp, #12
 80023a0:	f85d fb04 	ldr.w	pc, [sp], #4
 80023a4:	f3af 8000 	nop.w
 80023a8:	f3af 8000 	nop.w
 80023ac:	f3af 8000 	nop.w

080023b0 <chCondSignalI>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondSignalI(condition_variable_t *cp) {
 80023b0:	b500      	push	{lr}
 80023b2:	b085      	sub	sp, #20
 80023b4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->c_queue)) {
 80023b6:	9b01      	ldr	r3, [sp, #4]
 80023b8:	4618      	mov	r0, r3
 80023ba:	f7ff ff59 	bl	8002270 <queue_notempty>
 80023be:	4603      	mov	r3, r0
 80023c0:	2b00      	cmp	r3, #0
 80023c2:	d00a      	beq.n	80023da <chCondSignalI+0x2a>
    thread_t *tp = queue_fifo_remove(&cp->c_queue);
 80023c4:	9b01      	ldr	r3, [sp, #4]
 80023c6:	4618      	mov	r0, r3
 80023c8:	f7ff ff8a 	bl	80022e0 <queue_fifo_remove>
 80023cc:	9003      	str	r0, [sp, #12]
    tp->p_u.rdymsg = MSG_OK;
 80023ce:	9b03      	ldr	r3, [sp, #12]
 80023d0:	2200      	movs	r2, #0
 80023d2:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 80023d4:	9803      	ldr	r0, [sp, #12]
 80023d6:	f7fe fbe3 	bl	8000ba0 <chSchReadyI>
  }
}
 80023da:	b005      	add	sp, #20
 80023dc:	f85d fb04 	ldr.w	pc, [sp], #4

080023e0 <chCondBroadcast>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondBroadcast(condition_variable_t *cp) {
 80023e0:	b500      	push	{lr}
 80023e2:	b083      	sub	sp, #12
 80023e4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80023e6:	f7ff ff93 	bl	8002310 <chSysLock>
  chCondBroadcastI(cp);
 80023ea:	9801      	ldr	r0, [sp, #4]
 80023ec:	f000 f808 	bl	8002400 <chCondBroadcastI>
  chSchRescheduleS();
 80023f0:	f7fe fcc6 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 80023f4:	f7ff ff94 	bl	8002320 <chSysUnlock>
}
 80023f8:	b003      	add	sp, #12
 80023fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80023fe:	bf00      	nop

08002400 <chCondBroadcastI>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondBroadcastI(condition_variable_t *cp) {
 8002400:	b500      	push	{lr}
 8002402:	b083      	sub	sp, #12
 8002404:	9001      	str	r0, [sp, #4]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
 8002406:	e00b      	b.n	8002420 <chCondBroadcastI+0x20>
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
 8002408:	9b01      	ldr	r3, [sp, #4]
 800240a:	4618      	mov	r0, r3
 800240c:	f7ff ff68 	bl	80022e0 <queue_fifo_remove>
 8002410:	4603      	mov	r3, r0
 8002412:	4618      	mov	r0, r3
 8002414:	f7fe fbc4 	bl	8000ba0 <chSchReadyI>
 8002418:	4603      	mov	r3, r0
 800241a:	f06f 0201 	mvn.w	r2, #1
 800241e:	621a      	str	r2, [r3, #32]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
 8002420:	9b01      	ldr	r3, [sp, #4]
 8002422:	4618      	mov	r0, r3
 8002424:	f7ff ff24 	bl	8002270 <queue_notempty>
 8002428:	4603      	mov	r3, r0
 800242a:	2b00      	cmp	r3, #0
 800242c:	d1ec      	bne.n	8002408 <chCondBroadcastI+0x8>
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
  }
}
 800242e:	b003      	add	sp, #12
 8002430:	f85d fb04 	ldr.w	pc, [sp], #4
 8002434:	f3af 8000 	nop.w
 8002438:	f3af 8000 	nop.w
 800243c:	f3af 8000 	nop.w

08002440 <chCondWait>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @api
 */
msg_t chCondWait(condition_variable_t *cp) {
 8002440:	b500      	push	{lr}
 8002442:	b085      	sub	sp, #20
 8002444:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chSysLock();
 8002446:	f7ff ff63 	bl	8002310 <chSysLock>
  msg = chCondWaitS(cp);
 800244a:	9801      	ldr	r0, [sp, #4]
 800244c:	f000 f808 	bl	8002460 <chCondWaitS>
 8002450:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8002452:	f7ff ff65 	bl	8002320 <chSysUnlock>
  return msg;
 8002456:	9b03      	ldr	r3, [sp, #12]
}
 8002458:	4618      	mov	r0, r3
 800245a:	b005      	add	sp, #20
 800245c:	f85d fb04 	ldr.w	pc, [sp], #4

08002460 <chCondWaitS>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
 8002460:	b500      	push	{lr}
 8002462:	b087      	sub	sp, #28
 8002464:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002466:	4b0f      	ldr	r3, [pc, #60]	; (80024a4 <chCondWaitS+0x44>)
 8002468:	699b      	ldr	r3, [r3, #24]
 800246a:	9305      	str	r3, [sp, #20]
  chDbgCheckClassS();
  chDbgCheck(cp != NULL);
  chDbgAssert(ctp->p_mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
 800246c:	f7ff ff68 	bl	8002340 <chMtxGetNextMutexS>
 8002470:	9004      	str	r0, [sp, #16]
  chMtxUnlockS(mp);
 8002472:	9804      	ldr	r0, [sp, #16]
 8002474:	f7ff fe4c 	bl	8002110 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  ctp->p_u.wtobjp = cp;
 8002478:	9b05      	ldr	r3, [sp, #20]
 800247a:	9a01      	ldr	r2, [sp, #4]
 800247c:	621a      	str	r2, [r3, #32]
  queue_prio_insert(ctp, &cp->c_queue);
 800247e:	9b01      	ldr	r3, [sp, #4]
 8002480:	9805      	ldr	r0, [sp, #20]
 8002482:	4619      	mov	r1, r3
 8002484:	f7ff ff04 	bl	8002290 <queue_prio_insert>
  chSchGoSleepS(CH_STATE_WTCOND);
 8002488:	2007      	movs	r0, #7
 800248a:	f7fe fbb1 	bl	8000bf0 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
 800248e:	9b05      	ldr	r3, [sp, #20]
 8002490:	6a1b      	ldr	r3, [r3, #32]
 8002492:	9303      	str	r3, [sp, #12]
  chMtxLockS(mp);
 8002494:	9804      	ldr	r0, [sp, #16]
 8002496:	f7ff fd4b 	bl	8001f30 <chMtxLockS>

  return msg;
 800249a:	9b03      	ldr	r3, [sp, #12]
}
 800249c:	4618      	mov	r0, r3
 800249e:	b007      	add	sp, #28
 80024a0:	f85d fb04 	ldr.w	pc, [sp], #4
 80024a4:	200016e0 	.word	0x200016e0
 80024a8:	f3af 8000 	nop.w
 80024ac:	f3af 8000 	nop.w

080024b0 <chCondWaitTimeout>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chCondWaitTimeout(condition_variable_t *cp, systime_t time) {
 80024b0:	b500      	push	{lr}
 80024b2:	b085      	sub	sp, #20
 80024b4:	9001      	str	r0, [sp, #4]
 80024b6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  chSysLock();
 80024b8:	f7ff ff2a 	bl	8002310 <chSysLock>
  msg = chCondWaitTimeoutS(cp, time);
 80024bc:	9801      	ldr	r0, [sp, #4]
 80024be:	9900      	ldr	r1, [sp, #0]
 80024c0:	f000 f80e 	bl	80024e0 <chCondWaitTimeoutS>
 80024c4:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 80024c6:	f7ff ff2b 	bl	8002320 <chSysUnlock>

  return msg;
 80024ca:	9b03      	ldr	r3, [sp, #12]
}
 80024cc:	4618      	mov	r0, r3
 80024ce:	b005      	add	sp, #20
 80024d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80024d4:	f3af 8000 	nop.w
 80024d8:	f3af 8000 	nop.w
 80024dc:	f3af 8000 	nop.w

080024e0 <chCondWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chCondWaitTimeoutS(condition_variable_t *cp, systime_t time) {
 80024e0:	b500      	push	{lr}
 80024e2:	b085      	sub	sp, #20
 80024e4:	9001      	str	r0, [sp, #4]
 80024e6:	9100      	str	r1, [sp, #0]
  chDbgCheckClassS();
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE));
  chDbgAssert(currp->p_mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
 80024e8:	f7ff ff2a 	bl	8002340 <chMtxGetNextMutexS>
 80024ec:	9003      	str	r0, [sp, #12]
  chMtxUnlockS(mp);
 80024ee:	9803      	ldr	r0, [sp, #12]
 80024f0:	f7ff fe0e 	bl	8002110 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->p_u.wtobjp = cp;
 80024f4:	4b0d      	ldr	r3, [pc, #52]	; (800252c <chCondWaitTimeoutS+0x4c>)
 80024f6:	699b      	ldr	r3, [r3, #24]
 80024f8:	9a01      	ldr	r2, [sp, #4]
 80024fa:	621a      	str	r2, [r3, #32]
  queue_prio_insert(currp, &cp->c_queue);
 80024fc:	4b0b      	ldr	r3, [pc, #44]	; (800252c <chCondWaitTimeoutS+0x4c>)
 80024fe:	699a      	ldr	r2, [r3, #24]
 8002500:	9b01      	ldr	r3, [sp, #4]
 8002502:	4610      	mov	r0, r2
 8002504:	4619      	mov	r1, r3
 8002506:	f7ff fec3 	bl	8002290 <queue_prio_insert>
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, time);
 800250a:	2007      	movs	r0, #7
 800250c:	9900      	ldr	r1, [sp, #0]
 800250e:	f7fe fbd7 	bl	8000cc0 <chSchGoSleepTimeoutS>
 8002512:	9002      	str	r0, [sp, #8]
  if (msg != MSG_TIMEOUT) {
 8002514:	9b02      	ldr	r3, [sp, #8]
 8002516:	f1b3 3fff 	cmp.w	r3, #4294967295
 800251a:	d002      	beq.n	8002522 <chCondWaitTimeoutS+0x42>
    chMtxLockS(mp);
 800251c:	9803      	ldr	r0, [sp, #12]
 800251e:	f7ff fd07 	bl	8001f30 <chMtxLockS>
  }

  return msg;
 8002522:	9b02      	ldr	r3, [sp, #8]
}
 8002524:	4618      	mov	r0, r3
 8002526:	b005      	add	sp, #20
 8002528:	f85d fb04 	ldr.w	pc, [sp], #4
 800252c:	200016e0 	.word	0x200016e0

08002530 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002530:	b082      	sub	sp, #8
 8002532:	2320      	movs	r3, #32
 8002534:	9301      	str	r3, [sp, #4]
 8002536:	9b01      	ldr	r3, [sp, #4]
 8002538:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800253c:	b002      	add	sp, #8
 800253e:	4770      	bx	lr

08002540 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002540:	b082      	sub	sp, #8
 8002542:	2300      	movs	r3, #0
 8002544:	9301      	str	r3, [sp, #4]
 8002546:	9b01      	ldr	r3, [sp, #4]
 8002548:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800254c:	b002      	add	sp, #8
 800254e:	4770      	bx	lr

08002550 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8002550:	b508      	push	{r3, lr}

  port_lock();
 8002552:	f7ff ffed 	bl	8002530 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002556:	bd08      	pop	{r3, pc}
 8002558:	f3af 8000 	nop.w
 800255c:	f3af 8000 	nop.w

08002560 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002560:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8002562:	f7ff ffed 	bl	8002540 <port_unlock>
}
 8002566:	bd08      	pop	{r3, pc}
 8002568:	f3af 8000 	nop.w
 800256c:	f3af 8000 	nop.w

08002570 <chEvtRegisterMaskWithFlags>:
 * @api
 */
void chEvtRegisterMaskWithFlags(event_source_t *esp,
                                event_listener_t *elp,
                                eventmask_t events,
                                eventflags_t wflags) {
 8002570:	b500      	push	{lr}
 8002572:	b085      	sub	sp, #20
 8002574:	9003      	str	r0, [sp, #12]
 8002576:	9102      	str	r1, [sp, #8]
 8002578:	9201      	str	r2, [sp, #4]
 800257a:	9300      	str	r3, [sp, #0]

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
 800257c:	f7ff ffe8 	bl	8002550 <chSysLock>
  elp->el_next     = esp->es_next;
 8002580:	9b03      	ldr	r3, [sp, #12]
 8002582:	681a      	ldr	r2, [r3, #0]
 8002584:	9b02      	ldr	r3, [sp, #8]
 8002586:	601a      	str	r2, [r3, #0]
  esp->es_next     = elp;
 8002588:	9b03      	ldr	r3, [sp, #12]
 800258a:	9a02      	ldr	r2, [sp, #8]
 800258c:	601a      	str	r2, [r3, #0]
  elp->el_listener = currp;
 800258e:	4b09      	ldr	r3, [pc, #36]	; (80025b4 <chEvtRegisterMaskWithFlags+0x44>)
 8002590:	699a      	ldr	r2, [r3, #24]
 8002592:	9b02      	ldr	r3, [sp, #8]
 8002594:	605a      	str	r2, [r3, #4]
  elp->el_events   = events;
 8002596:	9b02      	ldr	r3, [sp, #8]
 8002598:	9a01      	ldr	r2, [sp, #4]
 800259a:	609a      	str	r2, [r3, #8]
  elp->el_flags    = (eventflags_t)0;
 800259c:	9b02      	ldr	r3, [sp, #8]
 800259e:	2200      	movs	r2, #0
 80025a0:	60da      	str	r2, [r3, #12]
  elp->el_wflags   = wflags;
 80025a2:	9b02      	ldr	r3, [sp, #8]
 80025a4:	9a00      	ldr	r2, [sp, #0]
 80025a6:	611a      	str	r2, [r3, #16]
  chSysUnlock();
 80025a8:	f7ff ffda 	bl	8002560 <chSysUnlock>
}
 80025ac:	b005      	add	sp, #20
 80025ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80025b2:	bf00      	nop
 80025b4:	200016e0 	.word	0x200016e0
 80025b8:	f3af 8000 	nop.w
 80025bc:	f3af 8000 	nop.w

080025c0 <chEvtUnregister>:
 * @param[in] esp       pointer to the  @p event_source_t structure
 * @param[in] elp       pointer to the @p event_listener_t structure
 *
 * @api
 */
void chEvtUnregister(event_source_t *esp, event_listener_t *elp) {
 80025c0:	b500      	push	{lr}
 80025c2:	b085      	sub	sp, #20
 80025c4:	9001      	str	r0, [sp, #4]
 80025c6:	9100      	str	r1, [sp, #0]
  event_listener_t *p;

  chDbgCheck((esp != NULL) && (elp != NULL));

  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
 80025c8:	9b01      	ldr	r3, [sp, #4]
 80025ca:	9303      	str	r3, [sp, #12]
  /*lint -restore*/
  chSysLock();
 80025cc:	f7ff ffc0 	bl	8002550 <chSysLock>
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
 80025d0:	e00c      	b.n	80025ec <chEvtUnregister+0x2c>
  /*lint -restore*/
    if (p->el_next == elp) {
 80025d2:	9b03      	ldr	r3, [sp, #12]
 80025d4:	681a      	ldr	r2, [r3, #0]
 80025d6:	9b00      	ldr	r3, [sp, #0]
 80025d8:	429a      	cmp	r2, r3
 80025da:	d104      	bne.n	80025e6 <chEvtUnregister+0x26>
      p->el_next = elp->el_next;
 80025dc:	9b00      	ldr	r3, [sp, #0]
 80025de:	681a      	ldr	r2, [r3, #0]
 80025e0:	9b03      	ldr	r3, [sp, #12]
 80025e2:	601a      	str	r2, [r3, #0]
      break;
 80025e4:	e007      	b.n	80025f6 <chEvtUnregister+0x36>
    }
    p = p->el_next;
 80025e6:	9b03      	ldr	r3, [sp, #12]
 80025e8:	681b      	ldr	r3, [r3, #0]
 80025ea:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
 80025ec:	9b03      	ldr	r3, [sp, #12]
 80025ee:	681a      	ldr	r2, [r3, #0]
 80025f0:	9b01      	ldr	r3, [sp, #4]
 80025f2:	429a      	cmp	r2, r3
 80025f4:	d1ed      	bne.n	80025d2 <chEvtUnregister+0x12>
      p->el_next = elp->el_next;
      break;
    }
    p = p->el_next;
  }
  chSysUnlock();
 80025f6:	f7ff ffb3 	bl	8002560 <chSysUnlock>
}
 80025fa:	b005      	add	sp, #20
 80025fc:	f85d fb04 	ldr.w	pc, [sp], #4

08002600 <chEvtGetAndClearEvents>:
 * @param[in] events    the events to be cleared
 * @return              The pending events that were cleared.
 *
 * @api
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
 8002600:	b500      	push	{lr}
 8002602:	b085      	sub	sp, #20
 8002604:	9001      	str	r0, [sp, #4]
  eventmask_t m;

  chSysLock();
 8002606:	f7ff ffa3 	bl	8002550 <chSysLock>
  m = currp->p_epending & events;
 800260a:	4b0b      	ldr	r3, [pc, #44]	; (8002638 <chEvtGetAndClearEvents+0x38>)
 800260c:	699b      	ldr	r3, [r3, #24]
 800260e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002610:	9b01      	ldr	r3, [sp, #4]
 8002612:	4013      	ands	r3, r2
 8002614:	9303      	str	r3, [sp, #12]
  currp->p_epending &= ~events;
 8002616:	4b08      	ldr	r3, [pc, #32]	; (8002638 <chEvtGetAndClearEvents+0x38>)
 8002618:	699b      	ldr	r3, [r3, #24]
 800261a:	4a07      	ldr	r2, [pc, #28]	; (8002638 <chEvtGetAndClearEvents+0x38>)
 800261c:	6992      	ldr	r2, [r2, #24]
 800261e:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8002620:	9a01      	ldr	r2, [sp, #4]
 8002622:	43d2      	mvns	r2, r2
 8002624:	400a      	ands	r2, r1
 8002626:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8002628:	f7ff ff9a 	bl	8002560 <chSysUnlock>

  return m;
 800262c:	9b03      	ldr	r3, [sp, #12]
}
 800262e:	4618      	mov	r0, r3
 8002630:	b005      	add	sp, #20
 8002632:	f85d fb04 	ldr.w	pc, [sp], #4
 8002636:	bf00      	nop
 8002638:	200016e0 	.word	0x200016e0
 800263c:	f3af 8000 	nop.w

08002640 <chEvtAddEvents>:
 * @param[in] events    the events to be added
 * @return              The current pending events.
 *
 * @api
 */
eventmask_t chEvtAddEvents(eventmask_t events) {
 8002640:	b500      	push	{lr}
 8002642:	b083      	sub	sp, #12
 8002644:	9001      	str	r0, [sp, #4]

  chSysLock();
 8002646:	f7ff ff83 	bl	8002550 <chSysLock>
  currp->p_epending |= events;
 800264a:	4b09      	ldr	r3, [pc, #36]	; (8002670 <chEvtAddEvents+0x30>)
 800264c:	699b      	ldr	r3, [r3, #24]
 800264e:	4a08      	ldr	r2, [pc, #32]	; (8002670 <chEvtAddEvents+0x30>)
 8002650:	6992      	ldr	r2, [r2, #24]
 8002652:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8002654:	9a01      	ldr	r2, [sp, #4]
 8002656:	430a      	orrs	r2, r1
 8002658:	635a      	str	r2, [r3, #52]	; 0x34
  events = currp->p_epending;
 800265a:	4b05      	ldr	r3, [pc, #20]	; (8002670 <chEvtAddEvents+0x30>)
 800265c:	699b      	ldr	r3, [r3, #24]
 800265e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002660:	9301      	str	r3, [sp, #4]
  chSysUnlock();
 8002662:	f7ff ff7d 	bl	8002560 <chSysUnlock>

  return events;
 8002666:	9b01      	ldr	r3, [sp, #4]
}
 8002668:	4618      	mov	r0, r3
 800266a:	b003      	add	sp, #12
 800266c:	f85d fb04 	ldr.w	pc, [sp], #4
 8002670:	200016e0 	.word	0x200016e0
 8002674:	f3af 8000 	nop.w
 8002678:	f3af 8000 	nop.w
 800267c:	f3af 8000 	nop.w

08002680 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8002680:	b500      	push	{lr}
 8002682:	b085      	sub	sp, #20
 8002684:	9001      	str	r0, [sp, #4]
 8002686:	9100      	str	r1, [sp, #0]
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 8002688:	9b01      	ldr	r3, [sp, #4]
 800268a:	681b      	ldr	r3, [r3, #0]
 800268c:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 800268e:	e01a      	b.n	80026c6 <chEvtBroadcastFlagsI+0x46>
  /*lint -restore*/
    elp->el_flags |= flags;
 8002690:	9b03      	ldr	r3, [sp, #12]
 8002692:	68da      	ldr	r2, [r3, #12]
 8002694:	9b00      	ldr	r3, [sp, #0]
 8002696:	431a      	orrs	r2, r3
 8002698:	9b03      	ldr	r3, [sp, #12]
 800269a:	60da      	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 800269c:	9b00      	ldr	r3, [sp, #0]
 800269e:	2b00      	cmp	r3, #0
 80026a0:	d006      	beq.n	80026b0 <chEvtBroadcastFlagsI+0x30>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
 80026a2:	9b03      	ldr	r3, [sp, #12]
 80026a4:	68da      	ldr	r2, [r3, #12]
 80026a6:	9b03      	ldr	r3, [sp, #12]
 80026a8:	691b      	ldr	r3, [r3, #16]
 80026aa:	4013      	ands	r3, r2
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 80026ac:	2b00      	cmp	r3, #0
 80026ae:	d007      	beq.n	80026c0 <chEvtBroadcastFlagsI+0x40>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 80026b0:	9b03      	ldr	r3, [sp, #12]
 80026b2:	685a      	ldr	r2, [r3, #4]
 80026b4:	9b03      	ldr	r3, [sp, #12]
 80026b6:	689b      	ldr	r3, [r3, #8]
 80026b8:	4610      	mov	r0, r2
 80026ba:	4619      	mov	r1, r3
 80026bc:	f000 f840 	bl	8002740 <chEvtSignalI>
    }
    elp = elp->el_next;
 80026c0:	9b03      	ldr	r3, [sp, #12]
 80026c2:	681b      	ldr	r3, [r3, #0]
 80026c4:	9303      	str	r3, [sp, #12]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80026c6:	9a03      	ldr	r2, [sp, #12]
 80026c8:	9b01      	ldr	r3, [sp, #4]
 80026ca:	429a      	cmp	r2, r3
 80026cc:	d1e0      	bne.n	8002690 <chEvtBroadcastFlagsI+0x10>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
  }
}
 80026ce:	b005      	add	sp, #20
 80026d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80026d4:	f3af 8000 	nop.w
 80026d8:	f3af 8000 	nop.w
 80026dc:	f3af 8000 	nop.w

080026e0 <chEvtGetAndClearFlags>:
 * @return              The flags added to the listener by the associated
 *                      event source.
 *
 * @api
 */
eventflags_t chEvtGetAndClearFlags(event_listener_t *elp) {
 80026e0:	b500      	push	{lr}
 80026e2:	b085      	sub	sp, #20
 80026e4:	9001      	str	r0, [sp, #4]
  eventflags_t flags;

  chSysLock();
 80026e6:	f7ff ff33 	bl	8002550 <chSysLock>
  flags = elp->el_flags;
 80026ea:	9b01      	ldr	r3, [sp, #4]
 80026ec:	68db      	ldr	r3, [r3, #12]
 80026ee:	9303      	str	r3, [sp, #12]
  elp->el_flags = (eventflags_t)0;
 80026f0:	9b01      	ldr	r3, [sp, #4]
 80026f2:	2200      	movs	r2, #0
 80026f4:	60da      	str	r2, [r3, #12]
  chSysUnlock();
 80026f6:	f7ff ff33 	bl	8002560 <chSysUnlock>

  return flags;
 80026fa:	9b03      	ldr	r3, [sp, #12]
}
 80026fc:	4618      	mov	r0, r3
 80026fe:	b005      	add	sp, #20
 8002700:	f85d fb04 	ldr.w	pc, [sp], #4
 8002704:	f3af 8000 	nop.w
 8002708:	f3af 8000 	nop.w
 800270c:	f3af 8000 	nop.w

08002710 <chEvtSignal>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @api
 */
void chEvtSignal(thread_t *tp, eventmask_t events) {
 8002710:	b500      	push	{lr}
 8002712:	b083      	sub	sp, #12
 8002714:	9001      	str	r0, [sp, #4]
 8002716:	9100      	str	r1, [sp, #0]

  chDbgCheck(tp != NULL);

  chSysLock();
 8002718:	f7ff ff1a 	bl	8002550 <chSysLock>
  chEvtSignalI(tp, events);
 800271c:	9801      	ldr	r0, [sp, #4]
 800271e:	9900      	ldr	r1, [sp, #0]
 8002720:	f000 f80e 	bl	8002740 <chEvtSignalI>
  chSchRescheduleS();
 8002724:	f7fe fb2c 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 8002728:	f7ff ff1a 	bl	8002560 <chSysUnlock>
}
 800272c:	b003      	add	sp, #12
 800272e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002732:	bf00      	nop
 8002734:	f3af 8000 	nop.w
 8002738:	f3af 8000 	nop.w
 800273c:	f3af 8000 	nop.w

08002740 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8002740:	b500      	push	{lr}
 8002742:	b083      	sub	sp, #12
 8002744:	9001      	str	r0, [sp, #4]
 8002746:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8002748:	9b01      	ldr	r3, [sp, #4]
 800274a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800274c:	9b00      	ldr	r3, [sp, #0]
 800274e:	431a      	orrs	r2, r3
 8002750:	9b01      	ldr	r3, [sp, #4]
 8002752:	635a      	str	r2, [r3, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8002754:	9b01      	ldr	r3, [sp, #4]
 8002756:	7f1b      	ldrb	r3, [r3, #28]
 8002758:	2b0a      	cmp	r3, #10
 800275a:	d106      	bne.n	800276a <chEvtSignalI+0x2a>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800275c:	9b01      	ldr	r3, [sp, #4]
 800275e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002760:	9b01      	ldr	r3, [sp, #4]
 8002762:	6a1b      	ldr	r3, [r3, #32]
 8002764:	4013      	ands	r3, r2
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8002766:	2b00      	cmp	r3, #0
 8002768:	d10c      	bne.n	8002784 <chEvtSignalI+0x44>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 800276a:	9b01      	ldr	r3, [sp, #4]
 800276c:	7f1b      	ldrb	r3, [r3, #28]
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800276e:	2b0b      	cmp	r3, #11
 8002770:	d10e      	bne.n	8002790 <chEvtSignalI+0x50>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8002772:	9b01      	ldr	r3, [sp, #4]
 8002774:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002776:	9b01      	ldr	r3, [sp, #4]
 8002778:	6a1b      	ldr	r3, [r3, #32]
 800277a:	401a      	ands	r2, r3
 800277c:	9b01      	ldr	r3, [sp, #4]
 800277e:	6a1b      	ldr	r3, [r3, #32]

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8002780:	429a      	cmp	r2, r3
 8002782:	d105      	bne.n	8002790 <chEvtSignalI+0x50>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8002784:	9b01      	ldr	r3, [sp, #4]
 8002786:	2200      	movs	r2, #0
 8002788:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 800278a:	9801      	ldr	r0, [sp, #4]
 800278c:	f7fe fa08 	bl	8000ba0 <chSchReadyI>
  }
}
 8002790:	b003      	add	sp, #12
 8002792:	f85d fb04 	ldr.w	pc, [sp], #4
 8002796:	bf00      	nop
 8002798:	f3af 8000 	nop.w
 800279c:	f3af 8000 	nop.w

080027a0 <chEvtBroadcastFlags>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {
 80027a0:	b500      	push	{lr}
 80027a2:	b083      	sub	sp, #12
 80027a4:	9001      	str	r0, [sp, #4]
 80027a6:	9100      	str	r1, [sp, #0]

  chSysLock();
 80027a8:	f7ff fed2 	bl	8002550 <chSysLock>
  chEvtBroadcastFlagsI(esp, flags);
 80027ac:	9801      	ldr	r0, [sp, #4]
 80027ae:	9900      	ldr	r1, [sp, #0]
 80027b0:	f7ff ff66 	bl	8002680 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 80027b4:	f7fe fae4 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 80027b8:	f7ff fed2 	bl	8002560 <chSysUnlock>
}
 80027bc:	b003      	add	sp, #12
 80027be:	f85d fb04 	ldr.w	pc, [sp], #4
 80027c2:	bf00      	nop
 80027c4:	f3af 8000 	nop.w
 80027c8:	f3af 8000 	nop.w
 80027cc:	f3af 8000 	nop.w

080027d0 <chEvtGetAndClearFlagsI>:
 * @return              The flags added to the listener by the associated
 *                      event source.
 *
 * @iclass
 */
eventflags_t chEvtGetAndClearFlagsI(event_listener_t *elp) {
 80027d0:	b084      	sub	sp, #16
 80027d2:	9001      	str	r0, [sp, #4]
  eventflags_t flags;

  flags = elp->el_flags;
 80027d4:	9b01      	ldr	r3, [sp, #4]
 80027d6:	68db      	ldr	r3, [r3, #12]
 80027d8:	9303      	str	r3, [sp, #12]
  elp->el_flags = (eventflags_t)0;
 80027da:	9b01      	ldr	r3, [sp, #4]
 80027dc:	2200      	movs	r2, #0
 80027de:	60da      	str	r2, [r3, #12]

  return flags;
 80027e0:	9b03      	ldr	r3, [sp, #12]
}
 80027e2:	4618      	mov	r0, r3
 80027e4:	b004      	add	sp, #16
 80027e6:	4770      	bx	lr
 80027e8:	f3af 8000 	nop.w
 80027ec:	f3af 8000 	nop.w

080027f0 <chEvtDispatch>:
 * @param[in] handlers  an array of @p evhandler_t. The array must have size
 *                      equal to the number of bits in eventmask_t.
 *
 * @api
 */
void chEvtDispatch(const evhandler_t *handlers, eventmask_t events) {
 80027f0:	b500      	push	{lr}
 80027f2:	b085      	sub	sp, #20
 80027f4:	9001      	str	r0, [sp, #4]
 80027f6:	9100      	str	r1, [sp, #0]
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
 80027f8:	2300      	movs	r3, #0
 80027fa:	9303      	str	r3, [sp, #12]
  while (events != (eventmask_t)0) {
 80027fc:	e019      	b.n	8002832 <chEvtDispatch+0x42>
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 80027fe:	9a00      	ldr	r2, [sp, #0]
 8002800:	9b03      	ldr	r3, [sp, #12]
 8002802:	fa22 f303 	lsr.w	r3, r2, r3
 8002806:	f003 0301 	and.w	r3, r3, #1
 800280a:	2b00      	cmp	r3, #0
 800280c:	d00e      	beq.n	800282c <chEvtDispatch+0x3c>
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 800280e:	2201      	movs	r2, #1
 8002810:	9b03      	ldr	r3, [sp, #12]
 8002812:	fa02 f303 	lsl.w	r3, r2, r3
 8002816:	43db      	mvns	r3, r3
 8002818:	9a00      	ldr	r2, [sp, #0]
 800281a:	4013      	ands	r3, r2
 800281c:	9300      	str	r3, [sp, #0]
      handlers[eid](eid);
 800281e:	9b03      	ldr	r3, [sp, #12]
 8002820:	009b      	lsls	r3, r3, #2
 8002822:	9a01      	ldr	r2, [sp, #4]
 8002824:	4413      	add	r3, r2
 8002826:	681b      	ldr	r3, [r3, #0]
 8002828:	9803      	ldr	r0, [sp, #12]
 800282a:	4798      	blx	r3
    }
    eid++;
 800282c:	9b03      	ldr	r3, [sp, #12]
 800282e:	3301      	adds	r3, #1
 8002830:	9303      	str	r3, [sp, #12]
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 8002832:	9b00      	ldr	r3, [sp, #0]
 8002834:	2b00      	cmp	r3, #0
 8002836:	d1e2      	bne.n	80027fe <chEvtDispatch+0xe>
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
  }
}
 8002838:	b005      	add	sp, #20
 800283a:	f85d fb04 	ldr.w	pc, [sp], #4
 800283e:	bf00      	nop

08002840 <chEvtWaitOne>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
 8002840:	b500      	push	{lr}
 8002842:	b085      	sub	sp, #20
 8002844:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002846:	4b15      	ldr	r3, [pc, #84]	; (800289c <chEvtWaitOne+0x5c>)
 8002848:	699b      	ldr	r3, [r3, #24]
 800284a:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 800284c:	f7ff fe80 	bl	8002550 <chSysLock>
  m = ctp->p_epending & events;
 8002850:	9b02      	ldr	r3, [sp, #8]
 8002852:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002854:	9b01      	ldr	r3, [sp, #4]
 8002856:	4013      	ands	r3, r2
 8002858:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 800285a:	9b03      	ldr	r3, [sp, #12]
 800285c:	2b00      	cmp	r3, #0
 800285e:	d10a      	bne.n	8002876 <chEvtWaitOne+0x36>
    ctp->p_u.ewmask = events;
 8002860:	9b02      	ldr	r3, [sp, #8]
 8002862:	9a01      	ldr	r2, [sp, #4]
 8002864:	621a      	str	r2, [r3, #32]
    chSchGoSleepS(CH_STATE_WTOREVT);
 8002866:	200a      	movs	r0, #10
 8002868:	f7fe f9c2 	bl	8000bf0 <chSchGoSleepS>
    m = ctp->p_epending & events;
 800286c:	9b02      	ldr	r3, [sp, #8]
 800286e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002870:	9b01      	ldr	r3, [sp, #4]
 8002872:	4013      	ands	r3, r2
 8002874:	9303      	str	r3, [sp, #12]
  }
  m ^= m & (m - (eventmask_t)1);
 8002876:	9b03      	ldr	r3, [sp, #12]
 8002878:	425b      	negs	r3, r3
 800287a:	9a03      	ldr	r2, [sp, #12]
 800287c:	4013      	ands	r3, r2
 800287e:	9303      	str	r3, [sp, #12]
  ctp->p_epending &= ~m;
 8002880:	9b02      	ldr	r3, [sp, #8]
 8002882:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002884:	9b03      	ldr	r3, [sp, #12]
 8002886:	43db      	mvns	r3, r3
 8002888:	401a      	ands	r2, r3
 800288a:	9b02      	ldr	r3, [sp, #8]
 800288c:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 800288e:	f7ff fe67 	bl	8002560 <chSysUnlock>

  return m;
 8002892:	9b03      	ldr	r3, [sp, #12]
}
 8002894:	4618      	mov	r0, r3
 8002896:	b005      	add	sp, #20
 8002898:	f85d fb04 	ldr.w	pc, [sp], #4
 800289c:	200016e0 	.word	0x200016e0

080028a0 <chEvtWaitAny>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
 80028a0:	b500      	push	{lr}
 80028a2:	b085      	sub	sp, #20
 80028a4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 80028a6:	4b13      	ldr	r3, [pc, #76]	; (80028f4 <chEvtWaitAny+0x54>)
 80028a8:	699b      	ldr	r3, [r3, #24]
 80028aa:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 80028ac:	f7ff fe50 	bl	8002550 <chSysLock>
  m = ctp->p_epending & events;
 80028b0:	9b02      	ldr	r3, [sp, #8]
 80028b2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80028b4:	9b01      	ldr	r3, [sp, #4]
 80028b6:	4013      	ands	r3, r2
 80028b8:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 80028ba:	9b03      	ldr	r3, [sp, #12]
 80028bc:	2b00      	cmp	r3, #0
 80028be:	d10a      	bne.n	80028d6 <chEvtWaitAny+0x36>
    ctp->p_u.ewmask = events;
 80028c0:	9b02      	ldr	r3, [sp, #8]
 80028c2:	9a01      	ldr	r2, [sp, #4]
 80028c4:	621a      	str	r2, [r3, #32]
    chSchGoSleepS(CH_STATE_WTOREVT);
 80028c6:	200a      	movs	r0, #10
 80028c8:	f7fe f992 	bl	8000bf0 <chSchGoSleepS>
    m = ctp->p_epending & events;
 80028cc:	9b02      	ldr	r3, [sp, #8]
 80028ce:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80028d0:	9b01      	ldr	r3, [sp, #4]
 80028d2:	4013      	ands	r3, r2
 80028d4:	9303      	str	r3, [sp, #12]
  }
  ctp->p_epending &= ~m;
 80028d6:	9b02      	ldr	r3, [sp, #8]
 80028d8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80028da:	9b03      	ldr	r3, [sp, #12]
 80028dc:	43db      	mvns	r3, r3
 80028de:	401a      	ands	r2, r3
 80028e0:	9b02      	ldr	r3, [sp, #8]
 80028e2:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 80028e4:	f7ff fe3c 	bl	8002560 <chSysUnlock>

  return m;
 80028e8:	9b03      	ldr	r3, [sp, #12]
}
 80028ea:	4618      	mov	r0, r3
 80028ec:	b005      	add	sp, #20
 80028ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80028f2:	bf00      	nop
 80028f4:	200016e0 	.word	0x200016e0
 80028f8:	f3af 8000 	nop.w
 80028fc:	f3af 8000 	nop.w

08002900 <chEvtWaitAll>:
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
 8002900:	b500      	push	{lr}
 8002902:	b085      	sub	sp, #20
 8002904:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002906:	4b10      	ldr	r3, [pc, #64]	; (8002948 <chEvtWaitAll+0x48>)
 8002908:	699b      	ldr	r3, [r3, #24]
 800290a:	9303      	str	r3, [sp, #12]

  chSysLock();
 800290c:	f7ff fe20 	bl	8002550 <chSysLock>
  if ((ctp->p_epending & events) != events) {
 8002910:	9b03      	ldr	r3, [sp, #12]
 8002912:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002914:	9b01      	ldr	r3, [sp, #4]
 8002916:	401a      	ands	r2, r3
 8002918:	9b01      	ldr	r3, [sp, #4]
 800291a:	429a      	cmp	r2, r3
 800291c:	d005      	beq.n	800292a <chEvtWaitAll+0x2a>
    ctp->p_u.ewmask = events;
 800291e:	9b03      	ldr	r3, [sp, #12]
 8002920:	9a01      	ldr	r2, [sp, #4]
 8002922:	621a      	str	r2, [r3, #32]
    chSchGoSleepS(CH_STATE_WTANDEVT);
 8002924:	200b      	movs	r0, #11
 8002926:	f7fe f963 	bl	8000bf0 <chSchGoSleepS>
  }
  ctp->p_epending &= ~events;
 800292a:	9b03      	ldr	r3, [sp, #12]
 800292c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800292e:	9b01      	ldr	r3, [sp, #4]
 8002930:	43db      	mvns	r3, r3
 8002932:	401a      	ands	r2, r3
 8002934:	9b03      	ldr	r3, [sp, #12]
 8002936:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8002938:	f7ff fe12 	bl	8002560 <chSysUnlock>

  return events;
 800293c:	9b01      	ldr	r3, [sp, #4]
}
 800293e:	4618      	mov	r0, r3
 8002940:	b005      	add	sp, #20
 8002942:	f85d fb04 	ldr.w	pc, [sp], #4
 8002946:	bf00      	nop
 8002948:	200016e0 	.word	0x200016e0
 800294c:	f3af 8000 	nop.w

08002950 <chEvtWaitOneTimeout>:
 * @return              The mask of the lowest event id served and cleared.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
 8002950:	b500      	push	{lr}
 8002952:	b085      	sub	sp, #20
 8002954:	9001      	str	r0, [sp, #4]
 8002956:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 8002958:	4b1c      	ldr	r3, [pc, #112]	; (80029cc <chEvtWaitOneTimeout+0x7c>)
 800295a:	699b      	ldr	r3, [r3, #24]
 800295c:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 800295e:	f7ff fdf7 	bl	8002550 <chSysLock>
  m = ctp->p_epending & events;
 8002962:	9b02      	ldr	r3, [sp, #8]
 8002964:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002966:	9b01      	ldr	r3, [sp, #4]
 8002968:	4013      	ands	r3, r2
 800296a:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 800296c:	9b03      	ldr	r3, [sp, #12]
 800296e:	2b00      	cmp	r3, #0
 8002970:	d119      	bne.n	80029a6 <chEvtWaitOneTimeout+0x56>
    if (TIME_IMMEDIATE == time) {
 8002972:	9b00      	ldr	r3, [sp, #0]
 8002974:	2b00      	cmp	r3, #0
 8002976:	d103      	bne.n	8002980 <chEvtWaitOneTimeout+0x30>
      chSysUnlock();
 8002978:	f7ff fdf2 	bl	8002560 <chSysUnlock>
      return (eventmask_t)0;
 800297c:	2300      	movs	r3, #0
 800297e:	e021      	b.n	80029c4 <chEvtWaitOneTimeout+0x74>
    }
    ctp->p_u.ewmask = events;
 8002980:	9b02      	ldr	r3, [sp, #8]
 8002982:	9a01      	ldr	r2, [sp, #4]
 8002984:	621a      	str	r2, [r3, #32]
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8002986:	200a      	movs	r0, #10
 8002988:	9900      	ldr	r1, [sp, #0]
 800298a:	f7fe f999 	bl	8000cc0 <chSchGoSleepTimeoutS>
 800298e:	4603      	mov	r3, r0
 8002990:	2b00      	cmp	r3, #0
 8002992:	da03      	bge.n	800299c <chEvtWaitOneTimeout+0x4c>
      chSysUnlock();
 8002994:	f7ff fde4 	bl	8002560 <chSysUnlock>
      return (eventmask_t)0;
 8002998:	2300      	movs	r3, #0
 800299a:	e013      	b.n	80029c4 <chEvtWaitOneTimeout+0x74>
    }
    m = ctp->p_epending & events;
 800299c:	9b02      	ldr	r3, [sp, #8]
 800299e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80029a0:	9b01      	ldr	r3, [sp, #4]
 80029a2:	4013      	ands	r3, r2
 80029a4:	9303      	str	r3, [sp, #12]
  }
  m ^= m & (m - (eventmask_t)1);
 80029a6:	9b03      	ldr	r3, [sp, #12]
 80029a8:	425b      	negs	r3, r3
 80029aa:	9a03      	ldr	r2, [sp, #12]
 80029ac:	4013      	ands	r3, r2
 80029ae:	9303      	str	r3, [sp, #12]
  ctp->p_epending &= ~m;
 80029b0:	9b02      	ldr	r3, [sp, #8]
 80029b2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80029b4:	9b03      	ldr	r3, [sp, #12]
 80029b6:	43db      	mvns	r3, r3
 80029b8:	401a      	ands	r2, r3
 80029ba:	9b02      	ldr	r3, [sp, #8]
 80029bc:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 80029be:	f7ff fdcf 	bl	8002560 <chSysUnlock>

  return m;
 80029c2:	9b03      	ldr	r3, [sp, #12]
}
 80029c4:	4618      	mov	r0, r3
 80029c6:	b005      	add	sp, #20
 80029c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80029cc:	200016e0 	.word	0x200016e0

080029d0 <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
 80029d0:	b500      	push	{lr}
 80029d2:	b085      	sub	sp, #20
 80029d4:	9001      	str	r0, [sp, #4]
 80029d6:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 80029d8:	4b1a      	ldr	r3, [pc, #104]	; (8002a44 <chEvtWaitAnyTimeout+0x74>)
 80029da:	699b      	ldr	r3, [r3, #24]
 80029dc:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 80029de:	f7ff fdb7 	bl	8002550 <chSysLock>
  m = ctp->p_epending & events;
 80029e2:	9b02      	ldr	r3, [sp, #8]
 80029e4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80029e6:	9b01      	ldr	r3, [sp, #4]
 80029e8:	4013      	ands	r3, r2
 80029ea:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 80029ec:	9b03      	ldr	r3, [sp, #12]
 80029ee:	2b00      	cmp	r3, #0
 80029f0:	d119      	bne.n	8002a26 <chEvtWaitAnyTimeout+0x56>
    if (TIME_IMMEDIATE == time) {
 80029f2:	9b00      	ldr	r3, [sp, #0]
 80029f4:	2b00      	cmp	r3, #0
 80029f6:	d103      	bne.n	8002a00 <chEvtWaitAnyTimeout+0x30>
      chSysUnlock();
 80029f8:	f7ff fdb2 	bl	8002560 <chSysUnlock>
      return (eventmask_t)0;
 80029fc:	2300      	movs	r3, #0
 80029fe:	e01c      	b.n	8002a3a <chEvtWaitAnyTimeout+0x6a>
    }
    ctp->p_u.ewmask = events;
 8002a00:	9b02      	ldr	r3, [sp, #8]
 8002a02:	9a01      	ldr	r2, [sp, #4]
 8002a04:	621a      	str	r2, [r3, #32]
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8002a06:	200a      	movs	r0, #10
 8002a08:	9900      	ldr	r1, [sp, #0]
 8002a0a:	f7fe f959 	bl	8000cc0 <chSchGoSleepTimeoutS>
 8002a0e:	4603      	mov	r3, r0
 8002a10:	2b00      	cmp	r3, #0
 8002a12:	da03      	bge.n	8002a1c <chEvtWaitAnyTimeout+0x4c>
      chSysUnlock();
 8002a14:	f7ff fda4 	bl	8002560 <chSysUnlock>
      return (eventmask_t)0;
 8002a18:	2300      	movs	r3, #0
 8002a1a:	e00e      	b.n	8002a3a <chEvtWaitAnyTimeout+0x6a>
    }
    m = ctp->p_epending & events;
 8002a1c:	9b02      	ldr	r3, [sp, #8]
 8002a1e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002a20:	9b01      	ldr	r3, [sp, #4]
 8002a22:	4013      	ands	r3, r2
 8002a24:	9303      	str	r3, [sp, #12]
  }
  ctp->p_epending &= ~m;
 8002a26:	9b02      	ldr	r3, [sp, #8]
 8002a28:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002a2a:	9b03      	ldr	r3, [sp, #12]
 8002a2c:	43db      	mvns	r3, r3
 8002a2e:	401a      	ands	r2, r3
 8002a30:	9b02      	ldr	r3, [sp, #8]
 8002a32:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8002a34:	f7ff fd94 	bl	8002560 <chSysUnlock>

  return m;
 8002a38:	9b03      	ldr	r3, [sp, #12]
}
 8002a3a:	4618      	mov	r0, r3
 8002a3c:	b005      	add	sp, #20
 8002a3e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002a42:	bf00      	nop
 8002a44:	200016e0 	.word	0x200016e0
 8002a48:	f3af 8000 	nop.w
 8002a4c:	f3af 8000 	nop.w

08002a50 <chEvtWaitAllTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
 8002a50:	b500      	push	{lr}
 8002a52:	b085      	sub	sp, #20
 8002a54:	9001      	str	r0, [sp, #4]
 8002a56:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 8002a58:	4b17      	ldr	r3, [pc, #92]	; (8002ab8 <chEvtWaitAllTimeout+0x68>)
 8002a5a:	699b      	ldr	r3, [r3, #24]
 8002a5c:	9303      	str	r3, [sp, #12]

  chSysLock();
 8002a5e:	f7ff fd77 	bl	8002550 <chSysLock>
  if ((ctp->p_epending & events) != events) {
 8002a62:	9b03      	ldr	r3, [sp, #12]
 8002a64:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002a66:	9b01      	ldr	r3, [sp, #4]
 8002a68:	401a      	ands	r2, r3
 8002a6a:	9b01      	ldr	r3, [sp, #4]
 8002a6c:	429a      	cmp	r2, r3
 8002a6e:	d014      	beq.n	8002a9a <chEvtWaitAllTimeout+0x4a>
    if (TIME_IMMEDIATE == time) {
 8002a70:	9b00      	ldr	r3, [sp, #0]
 8002a72:	2b00      	cmp	r3, #0
 8002a74:	d103      	bne.n	8002a7e <chEvtWaitAllTimeout+0x2e>
      chSysUnlock();
 8002a76:	f7ff fd73 	bl	8002560 <chSysUnlock>
      return (eventmask_t)0;
 8002a7a:	2300      	movs	r3, #0
 8002a7c:	e017      	b.n	8002aae <chEvtWaitAllTimeout+0x5e>
    }
    ctp->p_u.ewmask = events;
 8002a7e:	9b03      	ldr	r3, [sp, #12]
 8002a80:	9a01      	ldr	r2, [sp, #4]
 8002a82:	621a      	str	r2, [r3, #32]
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, time) < MSG_OK) {
 8002a84:	200b      	movs	r0, #11
 8002a86:	9900      	ldr	r1, [sp, #0]
 8002a88:	f7fe f91a 	bl	8000cc0 <chSchGoSleepTimeoutS>
 8002a8c:	4603      	mov	r3, r0
 8002a8e:	2b00      	cmp	r3, #0
 8002a90:	da03      	bge.n	8002a9a <chEvtWaitAllTimeout+0x4a>
      chSysUnlock();
 8002a92:	f7ff fd65 	bl	8002560 <chSysUnlock>
      return (eventmask_t)0;
 8002a96:	2300      	movs	r3, #0
 8002a98:	e009      	b.n	8002aae <chEvtWaitAllTimeout+0x5e>
    }
  }
  ctp->p_epending &= ~events;
 8002a9a:	9b03      	ldr	r3, [sp, #12]
 8002a9c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002a9e:	9b01      	ldr	r3, [sp, #4]
 8002aa0:	43db      	mvns	r3, r3
 8002aa2:	401a      	ands	r2, r3
 8002aa4:	9b03      	ldr	r3, [sp, #12]
 8002aa6:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8002aa8:	f7ff fd5a 	bl	8002560 <chSysUnlock>

  return events;
 8002aac:	9b01      	ldr	r3, [sp, #4]
}
 8002aae:	4618      	mov	r0, r3
 8002ab0:	b005      	add	sp, #20
 8002ab2:	f85d fb04 	ldr.w	pc, [sp], #4
 8002ab6:	bf00      	nop
 8002ab8:	200016e0 	.word	0x200016e0
 8002abc:	f3af 8000 	nop.w

08002ac0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002ac0:	b082      	sub	sp, #8
 8002ac2:	2320      	movs	r3, #32
 8002ac4:	9301      	str	r3, [sp, #4]
 8002ac6:	9b01      	ldr	r3, [sp, #4]
 8002ac8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002acc:	b002      	add	sp, #8
 8002ace:	4770      	bx	lr

08002ad0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002ad0:	b082      	sub	sp, #8
 8002ad2:	2300      	movs	r3, #0
 8002ad4:	9301      	str	r3, [sp, #4]
 8002ad6:	9b01      	ldr	r3, [sp, #4]
 8002ad8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002adc:	b002      	add	sp, #8
 8002ade:	4770      	bx	lr

08002ae0 <queue_insert>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8002ae0:	b082      	sub	sp, #8
 8002ae2:	9001      	str	r0, [sp, #4]
 8002ae4:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 8002ae6:	9b01      	ldr	r3, [sp, #4]
 8002ae8:	9a00      	ldr	r2, [sp, #0]
 8002aea:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 8002aec:	9b00      	ldr	r3, [sp, #0]
 8002aee:	685a      	ldr	r2, [r3, #4]
 8002af0:	9b01      	ldr	r3, [sp, #4]
 8002af2:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8002af4:	9b01      	ldr	r3, [sp, #4]
 8002af6:	685b      	ldr	r3, [r3, #4]
 8002af8:	9a01      	ldr	r2, [sp, #4]
 8002afa:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 8002afc:	9b00      	ldr	r3, [sp, #0]
 8002afe:	9a01      	ldr	r2, [sp, #4]
 8002b00:	605a      	str	r2, [r3, #4]
}
 8002b02:	b002      	add	sp, #8
 8002b04:	4770      	bx	lr
 8002b06:	bf00      	nop
 8002b08:	f3af 8000 	nop.w
 8002b0c:	f3af 8000 	nop.w

08002b10 <queue_fifo_remove>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8002b10:	b084      	sub	sp, #16
 8002b12:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8002b14:	9b01      	ldr	r3, [sp, #4]
 8002b16:	681b      	ldr	r3, [r3, #0]
 8002b18:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8002b1a:	9b03      	ldr	r3, [sp, #12]
 8002b1c:	681a      	ldr	r2, [r3, #0]
 8002b1e:	9b01      	ldr	r3, [sp, #4]
 8002b20:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8002b22:	9b01      	ldr	r3, [sp, #4]
 8002b24:	681b      	ldr	r3, [r3, #0]
 8002b26:	9a01      	ldr	r2, [sp, #4]
 8002b28:	605a      	str	r2, [r3, #4]

  return tp;
 8002b2a:	9b03      	ldr	r3, [sp, #12]
}
 8002b2c:	4618      	mov	r0, r3
 8002b2e:	b004      	add	sp, #16
 8002b30:	4770      	bx	lr
 8002b32:	bf00      	nop
 8002b34:	f3af 8000 	nop.w
 8002b38:	f3af 8000 	nop.w
 8002b3c:	f3af 8000 	nop.w

08002b40 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8002b40:	b508      	push	{r3, lr}

  port_lock();
 8002b42:	f7ff ffbd 	bl	8002ac0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002b46:	bd08      	pop	{r3, pc}
 8002b48:	f3af 8000 	nop.w
 8002b4c:	f3af 8000 	nop.w

08002b50 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002b50:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8002b52:	f7ff ffbd 	bl	8002ad0 <port_unlock>
}
 8002b56:	bd08      	pop	{r3, pc}
 8002b58:	f3af 8000 	nop.w
 8002b5c:	f3af 8000 	nop.w

08002b60 <chMsgIsPendingI>:
 * @param[in] tp        pointer to the thread
 * @return              The pending messages status.
 *
 * @iclass
 */
static inline bool chMsgIsPendingI(thread_t *tp) {
 8002b60:	b082      	sub	sp, #8
 8002b62:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(tp->p_msgqueue.p_next != (thread_t *)&tp->p_msgqueue);
 8002b64:	9b01      	ldr	r3, [sp, #4]
 8002b66:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8002b68:	9b01      	ldr	r3, [sp, #4]
 8002b6a:	3328      	adds	r3, #40	; 0x28
 8002b6c:	429a      	cmp	r2, r3
 8002b6e:	bf0c      	ite	eq
 8002b70:	2300      	moveq	r3, #0
 8002b72:	2301      	movne	r3, #1
 8002b74:	b2db      	uxtb	r3, r3
}
 8002b76:	4618      	mov	r0, r3
 8002b78:	b002      	add	sp, #8
 8002b7a:	4770      	bx	lr
 8002b7c:	f3af 8000 	nop.w

08002b80 <chMsgReleaseS>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @sclass
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {
 8002b80:	b500      	push	{lr}
 8002b82:	b083      	sub	sp, #12
 8002b84:	9001      	str	r0, [sp, #4]
 8002b86:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();

  chSchWakeupS(tp, msg);
 8002b88:	9801      	ldr	r0, [sp, #4]
 8002b8a:	9900      	ldr	r1, [sp, #0]
 8002b8c:	f7fe f8d0 	bl	8000d30 <chSchWakeupS>
}
 8002b90:	b003      	add	sp, #12
 8002b92:	f85d fb04 	ldr.w	pc, [sp], #4
 8002b96:	bf00      	nop
 8002b98:	f3af 8000 	nop.w
 8002b9c:	f3af 8000 	nop.w

08002ba0 <chMsgSend>:
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 8002ba0:	b500      	push	{lr}
 8002ba2:	b085      	sub	sp, #20
 8002ba4:	9001      	str	r0, [sp, #4]
 8002ba6:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 8002ba8:	4b13      	ldr	r3, [pc, #76]	; (8002bf8 <chMsgSend+0x58>)
 8002baa:	699b      	ldr	r3, [r3, #24]
 8002bac:	9303      	str	r3, [sp, #12]

  chDbgCheck(tp != NULL);

  chSysLock();
 8002bae:	f7ff ffc7 	bl	8002b40 <chSysLock>
  ctp->p_msg = msg;
 8002bb2:	9b03      	ldr	r3, [sp, #12]
 8002bb4:	9a00      	ldr	r2, [sp, #0]
 8002bb6:	631a      	str	r2, [r3, #48]	; 0x30
  ctp->p_u.wtobjp = &tp->p_msgqueue;
 8002bb8:	9b01      	ldr	r3, [sp, #4]
 8002bba:	f103 0228 	add.w	r2, r3, #40	; 0x28
 8002bbe:	9b03      	ldr	r3, [sp, #12]
 8002bc0:	621a      	str	r2, [r3, #32]
  msg_insert(ctp, &tp->p_msgqueue);
 8002bc2:	9b01      	ldr	r3, [sp, #4]
 8002bc4:	3328      	adds	r3, #40	; 0x28
 8002bc6:	9803      	ldr	r0, [sp, #12]
 8002bc8:	4619      	mov	r1, r3
 8002bca:	f7ff ff89 	bl	8002ae0 <queue_insert>
  if (tp->p_state == CH_STATE_WTMSG) {
 8002bce:	9b01      	ldr	r3, [sp, #4]
 8002bd0:	7f1b      	ldrb	r3, [r3, #28]
 8002bd2:	2b0e      	cmp	r3, #14
 8002bd4:	d102      	bne.n	8002bdc <chMsgSend+0x3c>
    (void) chSchReadyI(tp);
 8002bd6:	9801      	ldr	r0, [sp, #4]
 8002bd8:	f7fd ffe2 	bl	8000ba0 <chSchReadyI>
  }
  chSchGoSleepS(CH_STATE_SNDMSGQ);
 8002bdc:	200c      	movs	r0, #12
 8002bde:	f7fe f807 	bl	8000bf0 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
 8002be2:	9b03      	ldr	r3, [sp, #12]
 8002be4:	6a1b      	ldr	r3, [r3, #32]
 8002be6:	9300      	str	r3, [sp, #0]
  chSysUnlock();
 8002be8:	f7ff ffb2 	bl	8002b50 <chSysUnlock>

  return msg;
 8002bec:	9b00      	ldr	r3, [sp, #0]
}
 8002bee:	4618      	mov	r0, r3
 8002bf0:	b005      	add	sp, #20
 8002bf2:	f85d fb04 	ldr.w	pc, [sp], #4
 8002bf6:	bf00      	nop
 8002bf8:	200016e0 	.word	0x200016e0
 8002bfc:	f3af 8000 	nop.w

08002c00 <chMsgWait>:
 *
 * @return              A reference to the thread carrying the message.
 *
 * @api
 */
thread_t *chMsgWait(void) {
 8002c00:	b500      	push	{lr}
 8002c02:	b083      	sub	sp, #12
  thread_t *tp;

  chSysLock();
 8002c04:	f7ff ff9c 	bl	8002b40 <chSysLock>
  if (!chMsgIsPendingI(currp)) {
 8002c08:	4b0f      	ldr	r3, [pc, #60]	; (8002c48 <chMsgWait+0x48>)
 8002c0a:	699b      	ldr	r3, [r3, #24]
 8002c0c:	4618      	mov	r0, r3
 8002c0e:	f7ff ffa7 	bl	8002b60 <chMsgIsPendingI>
 8002c12:	4603      	mov	r3, r0
 8002c14:	f083 0301 	eor.w	r3, r3, #1
 8002c18:	b2db      	uxtb	r3, r3
 8002c1a:	2b00      	cmp	r3, #0
 8002c1c:	d002      	beq.n	8002c24 <chMsgWait+0x24>
    chSchGoSleepS(CH_STATE_WTMSG);
 8002c1e:	200e      	movs	r0, #14
 8002c20:	f7fd ffe6 	bl	8000bf0 <chSchGoSleepS>
  }
  tp = queue_fifo_remove(&currp->p_msgqueue);
 8002c24:	4b08      	ldr	r3, [pc, #32]	; (8002c48 <chMsgWait+0x48>)
 8002c26:	699b      	ldr	r3, [r3, #24]
 8002c28:	3328      	adds	r3, #40	; 0x28
 8002c2a:	4618      	mov	r0, r3
 8002c2c:	f7ff ff70 	bl	8002b10 <queue_fifo_remove>
 8002c30:	9001      	str	r0, [sp, #4]
  tp->p_state = CH_STATE_SNDMSG;
 8002c32:	9b01      	ldr	r3, [sp, #4]
 8002c34:	220d      	movs	r2, #13
 8002c36:	771a      	strb	r2, [r3, #28]
  chSysUnlock();
 8002c38:	f7ff ff8a 	bl	8002b50 <chSysUnlock>

  return tp;
 8002c3c:	9b01      	ldr	r3, [sp, #4]
}
 8002c3e:	4618      	mov	r0, r3
 8002c40:	b003      	add	sp, #12
 8002c42:	f85d fb04 	ldr.w	pc, [sp], #4
 8002c46:	bf00      	nop
 8002c48:	200016e0 	.word	0x200016e0
 8002c4c:	f3af 8000 	nop.w

08002c50 <chMsgRelease>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @api
 */
void chMsgRelease(thread_t *tp, msg_t msg) {
 8002c50:	b500      	push	{lr}
 8002c52:	b083      	sub	sp, #12
 8002c54:	9001      	str	r0, [sp, #4]
 8002c56:	9100      	str	r1, [sp, #0]

  chSysLock();
 8002c58:	f7ff ff72 	bl	8002b40 <chSysLock>
  chDbgAssert(tp->p_state == CH_STATE_SNDMSG, "invalid state");
  chMsgReleaseS(tp, msg);
 8002c5c:	9801      	ldr	r0, [sp, #4]
 8002c5e:	9900      	ldr	r1, [sp, #0]
 8002c60:	f7ff ff8e 	bl	8002b80 <chMsgReleaseS>
  chSysUnlock();
 8002c64:	f7ff ff74 	bl	8002b50 <chSysUnlock>
}
 8002c68:	b003      	add	sp, #12
 8002c6a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002c6e:	bf00      	nop

08002c70 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002c70:	b082      	sub	sp, #8
 8002c72:	2320      	movs	r3, #32
 8002c74:	9301      	str	r3, [sp, #4]
 8002c76:	9b01      	ldr	r3, [sp, #4]
 8002c78:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002c7c:	b002      	add	sp, #8
 8002c7e:	4770      	bx	lr

08002c80 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002c80:	b082      	sub	sp, #8
 8002c82:	2300      	movs	r3, #0
 8002c84:	9301      	str	r3, [sp, #4]
 8002c86:	9b01      	ldr	r3, [sp, #4]
 8002c88:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002c8c:	b002      	add	sp, #8
 8002c8e:	4770      	bx	lr

08002c90 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8002c90:	b508      	push	{r3, lr}

  port_lock();
 8002c92:	f7ff ffed 	bl	8002c70 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002c96:	bd08      	pop	{r3, pc}
 8002c98:	f3af 8000 	nop.w
 8002c9c:	f3af 8000 	nop.w

08002ca0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002ca0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8002ca2:	f7ff ffed 	bl	8002c80 <port_unlock>
}
 8002ca6:	bd08      	pop	{r3, pc}
 8002ca8:	f3af 8000 	nop.w
 8002cac:	f3af 8000 	nop.w

08002cb0 <chSemFastWaitI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastWaitI(semaphore_t *sp) {
 8002cb0:	b082      	sub	sp, #8
 8002cb2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  sp->s_cnt--;
 8002cb4:	9b01      	ldr	r3, [sp, #4]
 8002cb6:	689b      	ldr	r3, [r3, #8]
 8002cb8:	1e5a      	subs	r2, r3, #1
 8002cba:	9b01      	ldr	r3, [sp, #4]
 8002cbc:	609a      	str	r2, [r3, #8]
}
 8002cbe:	b002      	add	sp, #8
 8002cc0:	4770      	bx	lr
 8002cc2:	bf00      	nop
 8002cc4:	f3af 8000 	nop.w
 8002cc8:	f3af 8000 	nop.w
 8002ccc:	f3af 8000 	nop.w

08002cd0 <chSemGetCounterI>:
 * @param[in] sp        pointer to a @p semaphore_t structure
 * @return              The semaphore counter value.
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {
 8002cd0:	b082      	sub	sp, #8
 8002cd2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return sp->s_cnt;
 8002cd4:	9b01      	ldr	r3, [sp, #4]
 8002cd6:	689b      	ldr	r3, [r3, #8]
}
 8002cd8:	4618      	mov	r0, r3
 8002cda:	b002      	add	sp, #8
 8002cdc:	4770      	bx	lr
 8002cde:	bf00      	nop

08002ce0 <chMBObjectInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {
 8002ce0:	b500      	push	{lr}
 8002ce2:	b085      	sub	sp, #20
 8002ce4:	9003      	str	r0, [sp, #12]
 8002ce6:	9102      	str	r1, [sp, #8]
 8002ce8:	9201      	str	r2, [sp, #4]

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->mb_buffer = buf;
 8002cea:	9b03      	ldr	r3, [sp, #12]
 8002cec:	9a02      	ldr	r2, [sp, #8]
 8002cee:	601a      	str	r2, [r3, #0]
  mbp->mb_rdptr = buf;
 8002cf0:	9b03      	ldr	r3, [sp, #12]
 8002cf2:	9a02      	ldr	r2, [sp, #8]
 8002cf4:	60da      	str	r2, [r3, #12]
  mbp->mb_wrptr = buf;
 8002cf6:	9b03      	ldr	r3, [sp, #12]
 8002cf8:	9a02      	ldr	r2, [sp, #8]
 8002cfa:	609a      	str	r2, [r3, #8]
  mbp->mb_top = &buf[n];
 8002cfc:	9b01      	ldr	r3, [sp, #4]
 8002cfe:	009b      	lsls	r3, r3, #2
 8002d00:	9a02      	ldr	r2, [sp, #8]
 8002d02:	441a      	add	r2, r3
 8002d04:	9b03      	ldr	r3, [sp, #12]
 8002d06:	605a      	str	r2, [r3, #4]
  chSemObjectInit(&mbp->mb_emptysem, n);
 8002d08:	9b03      	ldr	r3, [sp, #12]
 8002d0a:	331c      	adds	r3, #28
 8002d0c:	4618      	mov	r0, r3
 8002d0e:	9901      	ldr	r1, [sp, #4]
 8002d10:	f7fe fed6 	bl	8001ac0 <chSemObjectInit>
  chSemObjectInit(&mbp->mb_fullsem, (cnt_t)0);
 8002d14:	9b03      	ldr	r3, [sp, #12]
 8002d16:	3310      	adds	r3, #16
 8002d18:	4618      	mov	r0, r3
 8002d1a:	2100      	movs	r1, #0
 8002d1c:	f7fe fed0 	bl	8001ac0 <chSemObjectInit>
}
 8002d20:	b005      	add	sp, #20
 8002d22:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d26:	bf00      	nop
 8002d28:	f3af 8000 	nop.w
 8002d2c:	f3af 8000 	nop.w

08002d30 <chMBReset>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBReset(mailbox_t *mbp) {
 8002d30:	b500      	push	{lr}
 8002d32:	b083      	sub	sp, #12
 8002d34:	9001      	str	r0, [sp, #4]

  chSysLock();
 8002d36:	f7ff ffab 	bl	8002c90 <chSysLock>
  chMBResetI(mbp);
 8002d3a:	9801      	ldr	r0, [sp, #4]
 8002d3c:	f000 f808 	bl	8002d50 <chMBResetI>
  chSchRescheduleS();
 8002d40:	f7fe f81e 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 8002d44:	f7ff ffac 	bl	8002ca0 <chSysUnlock>
}
 8002d48:	b003      	add	sp, #12
 8002d4a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d4e:	bf00      	nop

08002d50 <chMBResetI>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBResetI(mailbox_t *mbp) {
 8002d50:	b500      	push	{lr}
 8002d52:	b083      	sub	sp, #12
 8002d54:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_buffer;
 8002d56:	9b01      	ldr	r3, [sp, #4]
 8002d58:	681a      	ldr	r2, [r3, #0]
 8002d5a:	9b01      	ldr	r3, [sp, #4]
 8002d5c:	609a      	str	r2, [r3, #8]
  mbp->mb_rdptr = mbp->mb_buffer;
 8002d5e:	9b01      	ldr	r3, [sp, #4]
 8002d60:	681a      	ldr	r2, [r3, #0]
 8002d62:	9b01      	ldr	r3, [sp, #4]
 8002d64:	60da      	str	r2, [r3, #12]
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
 8002d66:	9b01      	ldr	r3, [sp, #4]
 8002d68:	f103 021c 	add.w	r2, r3, #28
 8002d6c:	9b01      	ldr	r3, [sp, #4]
 8002d6e:	685b      	ldr	r3, [r3, #4]
 8002d70:	4619      	mov	r1, r3
 8002d72:	9b01      	ldr	r3, [sp, #4]
 8002d74:	681b      	ldr	r3, [r3, #0]
 8002d76:	1acb      	subs	r3, r1, r3
 8002d78:	109b      	asrs	r3, r3, #2
 8002d7a:	4610      	mov	r0, r2
 8002d7c:	4619      	mov	r1, r3
 8002d7e:	f7fe fec7 	bl	8001b10 <chSemResetI>
  chSemResetI(&mbp->mb_fullsem, (cnt_t)0);
 8002d82:	9b01      	ldr	r3, [sp, #4]
 8002d84:	3310      	adds	r3, #16
 8002d86:	4618      	mov	r0, r3
 8002d88:	2100      	movs	r1, #0
 8002d8a:	f7fe fec1 	bl	8001b10 <chSemResetI>
}
 8002d8e:	b003      	add	sp, #12
 8002d90:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d94:	f3af 8000 	nop.w
 8002d98:	f3af 8000 	nop.w
 8002d9c:	f3af 8000 	nop.w

08002da0 <chMBPost>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8002da0:	b500      	push	{lr}
 8002da2:	b087      	sub	sp, #28
 8002da4:	9003      	str	r0, [sp, #12]
 8002da6:	9102      	str	r1, [sp, #8]
 8002da8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 8002daa:	f7ff ff71 	bl	8002c90 <chSysLock>
  rdymsg = chMBPostS(mbp, msg, timeout);
 8002dae:	9803      	ldr	r0, [sp, #12]
 8002db0:	9902      	ldr	r1, [sp, #8]
 8002db2:	9a01      	ldr	r2, [sp, #4]
 8002db4:	f000 f80c 	bl	8002dd0 <chMBPostS>
 8002db8:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 8002dba:	f7ff ff71 	bl	8002ca0 <chSysUnlock>

  return rdymsg;
 8002dbe:	9b05      	ldr	r3, [sp, #20]
}
 8002dc0:	4618      	mov	r0, r3
 8002dc2:	b007      	add	sp, #28
 8002dc4:	f85d fb04 	ldr.w	pc, [sp], #4
 8002dc8:	f3af 8000 	nop.w
 8002dcc:	f3af 8000 	nop.w

08002dd0 <chMBPostS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8002dd0:	b500      	push	{lr}
 8002dd2:	b087      	sub	sp, #28
 8002dd4:	9003      	str	r0, [sp, #12]
 8002dd6:	9102      	str	r1, [sp, #8]
 8002dd8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 8002dda:	9b03      	ldr	r3, [sp, #12]
 8002ddc:	331c      	adds	r3, #28
 8002dde:	4618      	mov	r0, r3
 8002de0:	9901      	ldr	r1, [sp, #4]
 8002de2:	f7fe ff05 	bl	8001bf0 <chSemWaitTimeoutS>
 8002de6:	9005      	str	r0, [sp, #20]
  if (rdymsg == MSG_OK) {
 8002de8:	9b05      	ldr	r3, [sp, #20]
 8002dea:	2b00      	cmp	r3, #0
 8002dec:	d117      	bne.n	8002e1e <chMBPostS+0x4e>
    *mbp->mb_wrptr++ = msg;
 8002dee:	9b03      	ldr	r3, [sp, #12]
 8002df0:	689b      	ldr	r3, [r3, #8]
 8002df2:	1d19      	adds	r1, r3, #4
 8002df4:	9a03      	ldr	r2, [sp, #12]
 8002df6:	6091      	str	r1, [r2, #8]
 8002df8:	9a02      	ldr	r2, [sp, #8]
 8002dfa:	601a      	str	r2, [r3, #0]
    if (mbp->mb_wrptr >= mbp->mb_top) {
 8002dfc:	9b03      	ldr	r3, [sp, #12]
 8002dfe:	689a      	ldr	r2, [r3, #8]
 8002e00:	9b03      	ldr	r3, [sp, #12]
 8002e02:	685b      	ldr	r3, [r3, #4]
 8002e04:	429a      	cmp	r2, r3
 8002e06:	d303      	bcc.n	8002e10 <chMBPostS+0x40>
      mbp->mb_wrptr = mbp->mb_buffer;
 8002e08:	9b03      	ldr	r3, [sp, #12]
 8002e0a:	681a      	ldr	r2, [r3, #0]
 8002e0c:	9b03      	ldr	r3, [sp, #12]
 8002e0e:	609a      	str	r2, [r3, #8]
    }
    chSemSignalI(&mbp->mb_fullsem);
 8002e10:	9b03      	ldr	r3, [sp, #12]
 8002e12:	3310      	adds	r3, #16
 8002e14:	4618      	mov	r0, r3
 8002e16:	f7fe ff3b 	bl	8001c90 <chSemSignalI>
    chSchRescheduleS();
 8002e1a:	f7fd ffb1 	bl	8000d80 <chSchRescheduleS>
  }

  return rdymsg;
 8002e1e:	9b05      	ldr	r3, [sp, #20]
}
 8002e20:	4618      	mov	r0, r3
 8002e22:	b007      	add	sp, #28
 8002e24:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e28:	f3af 8000 	nop.w
 8002e2c:	f3af 8000 	nop.w

08002e30 <chMBPostI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 8002e30:	b500      	push	{lr}
 8002e32:	b083      	sub	sp, #12
 8002e34:	9001      	str	r0, [sp, #4]
 8002e36:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
 8002e38:	9b01      	ldr	r3, [sp, #4]
 8002e3a:	331c      	adds	r3, #28
 8002e3c:	4618      	mov	r0, r3
 8002e3e:	f7ff ff47 	bl	8002cd0 <chSemGetCounterI>
 8002e42:	4603      	mov	r3, r0
 8002e44:	2b00      	cmp	r3, #0
 8002e46:	dc02      	bgt.n	8002e4e <chMBPostI+0x1e>
    return MSG_TIMEOUT;
 8002e48:	f04f 33ff 	mov.w	r3, #4294967295
 8002e4c:	e01b      	b.n	8002e86 <chMBPostI+0x56>
  }

  chSemFastWaitI(&mbp->mb_emptysem);
 8002e4e:	9b01      	ldr	r3, [sp, #4]
 8002e50:	331c      	adds	r3, #28
 8002e52:	4618      	mov	r0, r3
 8002e54:	f7ff ff2c 	bl	8002cb0 <chSemFastWaitI>
  *mbp->mb_wrptr++ = msg;
 8002e58:	9b01      	ldr	r3, [sp, #4]
 8002e5a:	689b      	ldr	r3, [r3, #8]
 8002e5c:	1d19      	adds	r1, r3, #4
 8002e5e:	9a01      	ldr	r2, [sp, #4]
 8002e60:	6091      	str	r1, [r2, #8]
 8002e62:	9a00      	ldr	r2, [sp, #0]
 8002e64:	601a      	str	r2, [r3, #0]
  if (mbp->mb_wrptr >= mbp->mb_top) {
 8002e66:	9b01      	ldr	r3, [sp, #4]
 8002e68:	689a      	ldr	r2, [r3, #8]
 8002e6a:	9b01      	ldr	r3, [sp, #4]
 8002e6c:	685b      	ldr	r3, [r3, #4]
 8002e6e:	429a      	cmp	r2, r3
 8002e70:	d303      	bcc.n	8002e7a <chMBPostI+0x4a>
     mbp->mb_wrptr = mbp->mb_buffer;
 8002e72:	9b01      	ldr	r3, [sp, #4]
 8002e74:	681a      	ldr	r2, [r3, #0]
 8002e76:	9b01      	ldr	r3, [sp, #4]
 8002e78:	609a      	str	r2, [r3, #8]
  }
  chSemSignalI(&mbp->mb_fullsem);
 8002e7a:	9b01      	ldr	r3, [sp, #4]
 8002e7c:	3310      	adds	r3, #16
 8002e7e:	4618      	mov	r0, r3
 8002e80:	f7fe ff06 	bl	8001c90 <chSemSignalI>

  return MSG_OK;
 8002e84:	2300      	movs	r3, #0
}
 8002e86:	4618      	mov	r0, r3
 8002e88:	b003      	add	sp, #12
 8002e8a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e8e:	bf00      	nop

08002e90 <chMBPostAhead>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPostAhead(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8002e90:	b500      	push	{lr}
 8002e92:	b087      	sub	sp, #28
 8002e94:	9003      	str	r0, [sp, #12]
 8002e96:	9102      	str	r1, [sp, #8]
 8002e98:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 8002e9a:	f7ff fef9 	bl	8002c90 <chSysLock>
  rdymsg = chMBPostAheadS(mbp, msg, timeout);
 8002e9e:	9803      	ldr	r0, [sp, #12]
 8002ea0:	9902      	ldr	r1, [sp, #8]
 8002ea2:	9a01      	ldr	r2, [sp, #4]
 8002ea4:	f000 f80c 	bl	8002ec0 <chMBPostAheadS>
 8002ea8:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 8002eaa:	f7ff fef9 	bl	8002ca0 <chSysUnlock>

  return rdymsg;
 8002eae:	9b05      	ldr	r3, [sp, #20]
}
 8002eb0:	4618      	mov	r0, r3
 8002eb2:	b007      	add	sp, #28
 8002eb4:	f85d fb04 	ldr.w	pc, [sp], #4
 8002eb8:	f3af 8000 	nop.w
 8002ebc:	f3af 8000 	nop.w

08002ec0 <chMBPostAheadS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostAheadS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8002ec0:	b500      	push	{lr}
 8002ec2:	b087      	sub	sp, #28
 8002ec4:	9003      	str	r0, [sp, #12]
 8002ec6:	9102      	str	r1, [sp, #8]
 8002ec8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 8002eca:	9b03      	ldr	r3, [sp, #12]
 8002ecc:	331c      	adds	r3, #28
 8002ece:	4618      	mov	r0, r3
 8002ed0:	9901      	ldr	r1, [sp, #4]
 8002ed2:	f7fe fe8d 	bl	8001bf0 <chSemWaitTimeoutS>
 8002ed6:	9005      	str	r0, [sp, #20]
  if (rdymsg == MSG_OK) {
 8002ed8:	9b05      	ldr	r3, [sp, #20]
 8002eda:	2b00      	cmp	r3, #0
 8002edc:	d11a      	bne.n	8002f14 <chMBPostAheadS+0x54>
    if (--mbp->mb_rdptr < mbp->mb_buffer) {
 8002ede:	9b03      	ldr	r3, [sp, #12]
 8002ee0:	68db      	ldr	r3, [r3, #12]
 8002ee2:	1f1a      	subs	r2, r3, #4
 8002ee4:	9b03      	ldr	r3, [sp, #12]
 8002ee6:	60da      	str	r2, [r3, #12]
 8002ee8:	9b03      	ldr	r3, [sp, #12]
 8002eea:	68da      	ldr	r2, [r3, #12]
 8002eec:	9b03      	ldr	r3, [sp, #12]
 8002eee:	681b      	ldr	r3, [r3, #0]
 8002ef0:	429a      	cmp	r2, r3
 8002ef2:	d204      	bcs.n	8002efe <chMBPostAheadS+0x3e>
      mbp->mb_rdptr = mbp->mb_top - 1;
 8002ef4:	9b03      	ldr	r3, [sp, #12]
 8002ef6:	685b      	ldr	r3, [r3, #4]
 8002ef8:	1f1a      	subs	r2, r3, #4
 8002efa:	9b03      	ldr	r3, [sp, #12]
 8002efc:	60da      	str	r2, [r3, #12]
    }
    *mbp->mb_rdptr = msg;
 8002efe:	9b03      	ldr	r3, [sp, #12]
 8002f00:	68db      	ldr	r3, [r3, #12]
 8002f02:	9a02      	ldr	r2, [sp, #8]
 8002f04:	601a      	str	r2, [r3, #0]
    chSemSignalI(&mbp->mb_fullsem);
 8002f06:	9b03      	ldr	r3, [sp, #12]
 8002f08:	3310      	adds	r3, #16
 8002f0a:	4618      	mov	r0, r3
 8002f0c:	f7fe fec0 	bl	8001c90 <chSemSignalI>
    chSchRescheduleS();
 8002f10:	f7fd ff36 	bl	8000d80 <chSchRescheduleS>
  }

  return rdymsg;
 8002f14:	9b05      	ldr	r3, [sp, #20]
}
 8002f16:	4618      	mov	r0, r3
 8002f18:	b007      	add	sp, #28
 8002f1a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002f1e:	bf00      	nop

08002f20 <chMBPostAheadI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
 8002f20:	b500      	push	{lr}
 8002f22:	b083      	sub	sp, #12
 8002f24:	9001      	str	r0, [sp, #4]
 8002f26:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
 8002f28:	9b01      	ldr	r3, [sp, #4]
 8002f2a:	331c      	adds	r3, #28
 8002f2c:	4618      	mov	r0, r3
 8002f2e:	f7ff fecf 	bl	8002cd0 <chSemGetCounterI>
 8002f32:	4603      	mov	r3, r0
 8002f34:	2b00      	cmp	r3, #0
 8002f36:	dc02      	bgt.n	8002f3e <chMBPostAheadI+0x1e>
    return MSG_TIMEOUT;
 8002f38:	f04f 33ff 	mov.w	r3, #4294967295
 8002f3c:	e01e      	b.n	8002f7c <chMBPostAheadI+0x5c>
  }
  chSemFastWaitI(&mbp->mb_emptysem);
 8002f3e:	9b01      	ldr	r3, [sp, #4]
 8002f40:	331c      	adds	r3, #28
 8002f42:	4618      	mov	r0, r3
 8002f44:	f7ff feb4 	bl	8002cb0 <chSemFastWaitI>
  if (--mbp->mb_rdptr < mbp->mb_buffer) {
 8002f48:	9b01      	ldr	r3, [sp, #4]
 8002f4a:	68db      	ldr	r3, [r3, #12]
 8002f4c:	1f1a      	subs	r2, r3, #4
 8002f4e:	9b01      	ldr	r3, [sp, #4]
 8002f50:	60da      	str	r2, [r3, #12]
 8002f52:	9b01      	ldr	r3, [sp, #4]
 8002f54:	68da      	ldr	r2, [r3, #12]
 8002f56:	9b01      	ldr	r3, [sp, #4]
 8002f58:	681b      	ldr	r3, [r3, #0]
 8002f5a:	429a      	cmp	r2, r3
 8002f5c:	d204      	bcs.n	8002f68 <chMBPostAheadI+0x48>
    mbp->mb_rdptr = mbp->mb_top - 1;
 8002f5e:	9b01      	ldr	r3, [sp, #4]
 8002f60:	685b      	ldr	r3, [r3, #4]
 8002f62:	1f1a      	subs	r2, r3, #4
 8002f64:	9b01      	ldr	r3, [sp, #4]
 8002f66:	60da      	str	r2, [r3, #12]
  }
  *mbp->mb_rdptr = msg;
 8002f68:	9b01      	ldr	r3, [sp, #4]
 8002f6a:	68db      	ldr	r3, [r3, #12]
 8002f6c:	9a00      	ldr	r2, [sp, #0]
 8002f6e:	601a      	str	r2, [r3, #0]
  chSemSignalI(&mbp->mb_fullsem);
 8002f70:	9b01      	ldr	r3, [sp, #4]
 8002f72:	3310      	adds	r3, #16
 8002f74:	4618      	mov	r0, r3
 8002f76:	f7fe fe8b 	bl	8001c90 <chSemSignalI>

  return MSG_OK;
 8002f7a:	2300      	movs	r3, #0
}
 8002f7c:	4618      	mov	r0, r3
 8002f7e:	b003      	add	sp, #12
 8002f80:	f85d fb04 	ldr.w	pc, [sp], #4
 8002f84:	f3af 8000 	nop.w
 8002f88:	f3af 8000 	nop.w
 8002f8c:	f3af 8000 	nop.w

08002f90 <chMBFetch>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 8002f90:	b500      	push	{lr}
 8002f92:	b087      	sub	sp, #28
 8002f94:	9003      	str	r0, [sp, #12]
 8002f96:	9102      	str	r1, [sp, #8]
 8002f98:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 8002f9a:	f7ff fe79 	bl	8002c90 <chSysLock>
  rdymsg = chMBFetchS(mbp, msgp, timeout);
 8002f9e:	9803      	ldr	r0, [sp, #12]
 8002fa0:	9902      	ldr	r1, [sp, #8]
 8002fa2:	9a01      	ldr	r2, [sp, #4]
 8002fa4:	f000 f80c 	bl	8002fc0 <chMBFetchS>
 8002fa8:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 8002faa:	f7ff fe79 	bl	8002ca0 <chSysUnlock>

  return rdymsg;
 8002fae:	9b05      	ldr	r3, [sp, #20]
}
 8002fb0:	4618      	mov	r0, r3
 8002fb2:	b007      	add	sp, #28
 8002fb4:	f85d fb04 	ldr.w	pc, [sp], #4
 8002fb8:	f3af 8000 	nop.w
 8002fbc:	f3af 8000 	nop.w

08002fc0 <chMBFetchS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 8002fc0:	b500      	push	{lr}
 8002fc2:	b087      	sub	sp, #28
 8002fc4:	9003      	str	r0, [sp, #12]
 8002fc6:	9102      	str	r1, [sp, #8]
 8002fc8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
 8002fca:	9b03      	ldr	r3, [sp, #12]
 8002fcc:	3310      	adds	r3, #16
 8002fce:	4618      	mov	r0, r3
 8002fd0:	9901      	ldr	r1, [sp, #4]
 8002fd2:	f7fe fe0d 	bl	8001bf0 <chSemWaitTimeoutS>
 8002fd6:	9005      	str	r0, [sp, #20]
  if (rdymsg == MSG_OK) {
 8002fd8:	9b05      	ldr	r3, [sp, #20]
 8002fda:	2b00      	cmp	r3, #0
 8002fdc:	d118      	bne.n	8003010 <chMBFetchS+0x50>
    *msgp = *mbp->mb_rdptr++;
 8002fde:	9b03      	ldr	r3, [sp, #12]
 8002fe0:	68db      	ldr	r3, [r3, #12]
 8002fe2:	1d19      	adds	r1, r3, #4
 8002fe4:	9a03      	ldr	r2, [sp, #12]
 8002fe6:	60d1      	str	r1, [r2, #12]
 8002fe8:	681a      	ldr	r2, [r3, #0]
 8002fea:	9b02      	ldr	r3, [sp, #8]
 8002fec:	601a      	str	r2, [r3, #0]
    if (mbp->mb_rdptr >= mbp->mb_top) {
 8002fee:	9b03      	ldr	r3, [sp, #12]
 8002ff0:	68da      	ldr	r2, [r3, #12]
 8002ff2:	9b03      	ldr	r3, [sp, #12]
 8002ff4:	685b      	ldr	r3, [r3, #4]
 8002ff6:	429a      	cmp	r2, r3
 8002ff8:	d303      	bcc.n	8003002 <chMBFetchS+0x42>
      mbp->mb_rdptr = mbp->mb_buffer;
 8002ffa:	9b03      	ldr	r3, [sp, #12]
 8002ffc:	681a      	ldr	r2, [r3, #0]
 8002ffe:	9b03      	ldr	r3, [sp, #12]
 8003000:	60da      	str	r2, [r3, #12]
    }
    chSemSignalI(&mbp->mb_emptysem);
 8003002:	9b03      	ldr	r3, [sp, #12]
 8003004:	331c      	adds	r3, #28
 8003006:	4618      	mov	r0, r3
 8003008:	f7fe fe42 	bl	8001c90 <chSemSignalI>
    chSchRescheduleS();
 800300c:	f7fd feb8 	bl	8000d80 <chSchRescheduleS>
  }

  return rdymsg;
 8003010:	9b05      	ldr	r3, [sp, #20]
}
 8003012:	4618      	mov	r0, r3
 8003014:	b007      	add	sp, #28
 8003016:	f85d fb04 	ldr.w	pc, [sp], #4
 800301a:	bf00      	nop
 800301c:	f3af 8000 	nop.w

08003020 <chMBFetchI>:
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
 8003020:	b500      	push	{lr}
 8003022:	b083      	sub	sp, #12
 8003024:	9001      	str	r0, [sp, #4]
 8003026:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
 8003028:	9b01      	ldr	r3, [sp, #4]
 800302a:	3310      	adds	r3, #16
 800302c:	4618      	mov	r0, r3
 800302e:	f7ff fe4f 	bl	8002cd0 <chSemGetCounterI>
 8003032:	4603      	mov	r3, r0
 8003034:	2b00      	cmp	r3, #0
 8003036:	dc02      	bgt.n	800303e <chMBFetchI+0x1e>
    return MSG_TIMEOUT;
 8003038:	f04f 33ff 	mov.w	r3, #4294967295
 800303c:	e01c      	b.n	8003078 <chMBFetchI+0x58>
  }
  chSemFastWaitI(&mbp->mb_fullsem);
 800303e:	9b01      	ldr	r3, [sp, #4]
 8003040:	3310      	adds	r3, #16
 8003042:	4618      	mov	r0, r3
 8003044:	f7ff fe34 	bl	8002cb0 <chSemFastWaitI>
  *msgp = *mbp->mb_rdptr++;
 8003048:	9b01      	ldr	r3, [sp, #4]
 800304a:	68db      	ldr	r3, [r3, #12]
 800304c:	1d19      	adds	r1, r3, #4
 800304e:	9a01      	ldr	r2, [sp, #4]
 8003050:	60d1      	str	r1, [r2, #12]
 8003052:	681a      	ldr	r2, [r3, #0]
 8003054:	9b00      	ldr	r3, [sp, #0]
 8003056:	601a      	str	r2, [r3, #0]
  if (mbp->mb_rdptr >= mbp->mb_top) {
 8003058:	9b01      	ldr	r3, [sp, #4]
 800305a:	68da      	ldr	r2, [r3, #12]
 800305c:	9b01      	ldr	r3, [sp, #4]
 800305e:	685b      	ldr	r3, [r3, #4]
 8003060:	429a      	cmp	r2, r3
 8003062:	d303      	bcc.n	800306c <chMBFetchI+0x4c>
    mbp->mb_rdptr = mbp->mb_buffer;
 8003064:	9b01      	ldr	r3, [sp, #4]
 8003066:	681a      	ldr	r2, [r3, #0]
 8003068:	9b01      	ldr	r3, [sp, #4]
 800306a:	60da      	str	r2, [r3, #12]
  }
  chSemSignalI(&mbp->mb_emptysem);
 800306c:	9b01      	ldr	r3, [sp, #4]
 800306e:	331c      	adds	r3, #28
 8003070:	4618      	mov	r0, r3
 8003072:	f7fe fe0d 	bl	8001c90 <chSemSignalI>

  return MSG_OK;
 8003076:	2300      	movs	r3, #0
}
 8003078:	4618      	mov	r0, r3
 800307a:	b003      	add	sp, #12
 800307c:	f85d fb04 	ldr.w	pc, [sp], #4

08003080 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003080:	b082      	sub	sp, #8
 8003082:	2320      	movs	r3, #32
 8003084:	9301      	str	r3, [sp, #4]
 8003086:	9b01      	ldr	r3, [sp, #4]
 8003088:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800308c:	b002      	add	sp, #8
 800308e:	4770      	bx	lr

08003090 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003090:	b082      	sub	sp, #8
 8003092:	2300      	movs	r3, #0
 8003094:	9301      	str	r3, [sp, #4]
 8003096:	9b01      	ldr	r3, [sp, #4]
 8003098:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800309c:	b002      	add	sp, #8
 800309e:	4770      	bx	lr

080030a0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 80030a0:	b082      	sub	sp, #8
 80030a2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 80030a4:	9b01      	ldr	r3, [sp, #4]
 80030a6:	9a01      	ldr	r2, [sp, #4]
 80030a8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80030aa:	9b01      	ldr	r3, [sp, #4]
 80030ac:	9a01      	ldr	r2, [sp, #4]
 80030ae:	605a      	str	r2, [r3, #4]
}
 80030b0:	b002      	add	sp, #8
 80030b2:	4770      	bx	lr
 80030b4:	f3af 8000 	nop.w
 80030b8:	f3af 8000 	nop.w
 80030bc:	f3af 8000 	nop.w

080030c0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80030c0:	b508      	push	{r3, lr}

  port_lock();
 80030c2:	f7ff ffdd 	bl	8003080 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80030c6:	bd08      	pop	{r3, pc}
 80030c8:	f3af 8000 	nop.w
 80030cc:	f3af 8000 	nop.w

080030d0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80030d0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80030d2:	f7ff ffdd 	bl	8003090 <port_unlock>
}
 80030d6:	bd08      	pop	{r3, pc}
 80030d8:	f3af 8000 	nop.w
 80030dc:	f3af 8000 	nop.w

080030e0 <chThdQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 80030e0:	b500      	push	{lr}
 80030e2:	b083      	sub	sp, #12
 80030e4:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 80030e6:	9801      	ldr	r0, [sp, #4]
 80030e8:	f7ff ffda 	bl	80030a0 <queue_init>
}
 80030ec:	b003      	add	sp, #12
 80030ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80030f2:	bf00      	nop
 80030f4:	f3af 8000 	nop.w
 80030f8:	f3af 8000 	nop.w
 80030fc:	f3af 8000 	nop.w

08003100 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 8003100:	b082      	sub	sp, #8
 8003102:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8003104:	9b01      	ldr	r3, [sp, #4]
 8003106:	689b      	ldr	r3, [r3, #8]
 8003108:	2b00      	cmp	r3, #0
 800310a:	bf14      	ite	ne
 800310c:	2300      	movne	r3, #0
 800310e:	2301      	moveq	r3, #1
 8003110:	b2db      	uxtb	r3, r3
}
 8003112:	4618      	mov	r0, r3
 8003114:	b002      	add	sp, #8
 8003116:	4770      	bx	lr
 8003118:	f3af 8000 	nop.w
 800311c:	f3af 8000 	nop.w

08003120 <chIQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {
 8003120:	b082      	sub	sp, #8
 8003122:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8003124:	9b01      	ldr	r3, [sp, #4]
 8003126:	695a      	ldr	r2, [r3, #20]
 8003128:	9b01      	ldr	r3, [sp, #4]
 800312a:	699b      	ldr	r3, [r3, #24]
 800312c:	429a      	cmp	r2, r3
 800312e:	d105      	bne.n	800313c <chIQIsFullI+0x1c>
 8003130:	9b01      	ldr	r3, [sp, #4]
 8003132:	689b      	ldr	r3, [r3, #8]
 8003134:	2b00      	cmp	r3, #0
 8003136:	d001      	beq.n	800313c <chIQIsFullI+0x1c>
 8003138:	2301      	movs	r3, #1
 800313a:	e000      	b.n	800313e <chIQIsFullI+0x1e>
 800313c:	2300      	movs	r3, #0
 800313e:	f003 0301 	and.w	r3, r3, #1
 8003142:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 8003144:	4618      	mov	r0, r3
 8003146:	b002      	add	sp, #8
 8003148:	4770      	bx	lr
 800314a:	bf00      	nop
 800314c:	f3af 8000 	nop.w

08003150 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 8003150:	b082      	sub	sp, #8
 8003152:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8003154:	9b01      	ldr	r3, [sp, #4]
 8003156:	695a      	ldr	r2, [r3, #20]
 8003158:	9b01      	ldr	r3, [sp, #4]
 800315a:	699b      	ldr	r3, [r3, #24]
 800315c:	429a      	cmp	r2, r3
 800315e:	d105      	bne.n	800316c <chOQIsEmptyI+0x1c>
 8003160:	9b01      	ldr	r3, [sp, #4]
 8003162:	689b      	ldr	r3, [r3, #8]
 8003164:	2b00      	cmp	r3, #0
 8003166:	d001      	beq.n	800316c <chOQIsEmptyI+0x1c>
 8003168:	2301      	movs	r3, #1
 800316a:	e000      	b.n	800316e <chOQIsEmptyI+0x1e>
 800316c:	2300      	movs	r3, #0
 800316e:	f003 0301 	and.w	r3, r3, #1
 8003172:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 8003174:	4618      	mov	r0, r3
 8003176:	b002      	add	sp, #8
 8003178:	4770      	bx	lr
 800317a:	bf00      	nop
 800317c:	f3af 8000 	nop.w

08003180 <chOQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
 8003180:	b082      	sub	sp, #8
 8003182:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8003184:	9b01      	ldr	r3, [sp, #4]
 8003186:	689b      	ldr	r3, [r3, #8]
 8003188:	2b00      	cmp	r3, #0
 800318a:	bf14      	ite	ne
 800318c:	2300      	movne	r3, #0
 800318e:	2301      	moveq	r3, #1
 8003190:	b2db      	uxtb	r3, r3
}
 8003192:	4618      	mov	r0, r3
 8003194:	b002      	add	sp, #8
 8003196:	4770      	bx	lr
 8003198:	f3af 8000 	nop.w
 800319c:	f3af 8000 	nop.w

080031a0 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
 80031a0:	b500      	push	{lr}
 80031a2:	b085      	sub	sp, #20
 80031a4:	9003      	str	r0, [sp, #12]
 80031a6:	9102      	str	r1, [sp, #8]
 80031a8:	9201      	str	r2, [sp, #4]
 80031aa:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&iqp->q_waiting);
 80031ac:	9b03      	ldr	r3, [sp, #12]
 80031ae:	4618      	mov	r0, r3
 80031b0:	f7ff ff96 	bl	80030e0 <chThdQueueObjectInit>
  iqp->q_counter = 0;
 80031b4:	9b03      	ldr	r3, [sp, #12]
 80031b6:	2200      	movs	r2, #0
 80031b8:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
 80031ba:	9b03      	ldr	r3, [sp, #12]
 80031bc:	9a02      	ldr	r2, [sp, #8]
 80031be:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 80031c0:	9b03      	ldr	r3, [sp, #12]
 80031c2:	9a02      	ldr	r2, [sp, #8]
 80031c4:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 80031c6:	9b03      	ldr	r3, [sp, #12]
 80031c8:	9a02      	ldr	r2, [sp, #8]
 80031ca:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 80031cc:	9a02      	ldr	r2, [sp, #8]
 80031ce:	9b01      	ldr	r3, [sp, #4]
 80031d0:	441a      	add	r2, r3
 80031d2:	9b03      	ldr	r3, [sp, #12]
 80031d4:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 80031d6:	9b03      	ldr	r3, [sp, #12]
 80031d8:	9a00      	ldr	r2, [sp, #0]
 80031da:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 80031dc:	9b03      	ldr	r3, [sp, #12]
 80031de:	9a06      	ldr	r2, [sp, #24]
 80031e0:	621a      	str	r2, [r3, #32]
}
 80031e2:	b005      	add	sp, #20
 80031e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80031e8:	f3af 8000 	nop.w
 80031ec:	f3af 8000 	nop.w

080031f0 <chIQResetI>:
 *
 * @param[in] iqp       pointer to an @p input_queue_t structure
 *
 * @iclass
 */
void chIQResetI(input_queue_t *iqp) {
 80031f0:	b500      	push	{lr}
 80031f2:	b083      	sub	sp, #12
 80031f4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
 80031f6:	9b01      	ldr	r3, [sp, #4]
 80031f8:	68da      	ldr	r2, [r3, #12]
 80031fa:	9b01      	ldr	r3, [sp, #4]
 80031fc:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr = iqp->q_buffer;
 80031fe:	9b01      	ldr	r3, [sp, #4]
 8003200:	68da      	ldr	r2, [r3, #12]
 8003202:	9b01      	ldr	r3, [sp, #4]
 8003204:	615a      	str	r2, [r3, #20]
  iqp->q_counter = 0;
 8003206:	9b01      	ldr	r3, [sp, #4]
 8003208:	2200      	movs	r2, #0
 800320a:	609a      	str	r2, [r3, #8]
  chThdDequeueAllI(&iqp->q_waiting, Q_RESET);
 800320c:	9b01      	ldr	r3, [sp, #4]
 800320e:	4618      	mov	r0, r3
 8003210:	f06f 0101 	mvn.w	r1, #1
 8003214:	f7fe f9cc 	bl	80015b0 <chThdDequeueAllI>
}
 8003218:	b003      	add	sp, #12
 800321a:	f85d fb04 	ldr.w	pc, [sp], #4
 800321e:	bf00      	nop

08003220 <chIQPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
 8003220:	b500      	push	{lr}
 8003222:	b083      	sub	sp, #12
 8003224:	9001      	str	r0, [sp, #4]
 8003226:	460b      	mov	r3, r1
 8003228:	f88d 3003 	strb.w	r3, [sp, #3]

  chDbgCheckClassI();

  if (chIQIsFullI(iqp)) {
 800322c:	9801      	ldr	r0, [sp, #4]
 800322e:	f7ff ff77 	bl	8003120 <chIQIsFullI>
 8003232:	4603      	mov	r3, r0
 8003234:	2b00      	cmp	r3, #0
 8003236:	d002      	beq.n	800323e <chIQPutI+0x1e>
    return Q_FULL;
 8003238:	f06f 0303 	mvn.w	r3, #3
 800323c:	e01c      	b.n	8003278 <chIQPutI+0x58>
  }

  iqp->q_counter++;
 800323e:	9b01      	ldr	r3, [sp, #4]
 8003240:	689b      	ldr	r3, [r3, #8]
 8003242:	1c5a      	adds	r2, r3, #1
 8003244:	9b01      	ldr	r3, [sp, #4]
 8003246:	609a      	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
 8003248:	9b01      	ldr	r3, [sp, #4]
 800324a:	695b      	ldr	r3, [r3, #20]
 800324c:	1c59      	adds	r1, r3, #1
 800324e:	9a01      	ldr	r2, [sp, #4]
 8003250:	6151      	str	r1, [r2, #20]
 8003252:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8003256:	701a      	strb	r2, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8003258:	9b01      	ldr	r3, [sp, #4]
 800325a:	695a      	ldr	r2, [r3, #20]
 800325c:	9b01      	ldr	r3, [sp, #4]
 800325e:	691b      	ldr	r3, [r3, #16]
 8003260:	429a      	cmp	r2, r3
 8003262:	d303      	bcc.n	800326c <chIQPutI+0x4c>
    iqp->q_wrptr = iqp->q_buffer;
 8003264:	9b01      	ldr	r3, [sp, #4]
 8003266:	68da      	ldr	r2, [r3, #12]
 8003268:	9b01      	ldr	r3, [sp, #4]
 800326a:	615a      	str	r2, [r3, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
 800326c:	9b01      	ldr	r3, [sp, #4]
 800326e:	4618      	mov	r0, r3
 8003270:	2100      	movs	r1, #0
 8003272:	f7fe f985 	bl	8001580 <chThdDequeueNextI>

  return Q_OK;
 8003276:	2300      	movs	r3, #0
}
 8003278:	4618      	mov	r0, r3
 800327a:	b003      	add	sp, #12
 800327c:	f85d fb04 	ldr.w	pc, [sp], #4

08003280 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8003280:	b500      	push	{lr}
 8003282:	b085      	sub	sp, #20
 8003284:	9001      	str	r0, [sp, #4]
 8003286:	9100      	str	r1, [sp, #0]
  uint8_t b;

  chSysLock();
 8003288:	f7ff ff1a 	bl	80030c0 <chSysLock>
  if (iqp->q_notify != NULL) {
 800328c:	9b01      	ldr	r3, [sp, #4]
 800328e:	69db      	ldr	r3, [r3, #28]
 8003290:	2b00      	cmp	r3, #0
 8003292:	d004      	beq.n	800329e <chIQGetTimeout+0x1e>
    iqp->q_notify(iqp);
 8003294:	9b01      	ldr	r3, [sp, #4]
 8003296:	69db      	ldr	r3, [r3, #28]
 8003298:	9801      	ldr	r0, [sp, #4]
 800329a:	4798      	blx	r3
  }

  while (chIQIsEmptyI(iqp)) {
 800329c:	e00d      	b.n	80032ba <chIQGetTimeout+0x3a>
 800329e:	e00c      	b.n	80032ba <chIQGetTimeout+0x3a>
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 80032a0:	9b01      	ldr	r3, [sp, #4]
 80032a2:	4618      	mov	r0, r3
 80032a4:	9900      	ldr	r1, [sp, #0]
 80032a6:	f7fe f94b 	bl	8001540 <chThdEnqueueTimeoutS>
 80032aa:	9003      	str	r0, [sp, #12]
    if (msg < Q_OK) {
 80032ac:	9b03      	ldr	r3, [sp, #12]
 80032ae:	2b00      	cmp	r3, #0
 80032b0:	da03      	bge.n	80032ba <chIQGetTimeout+0x3a>
      chSysUnlock();
 80032b2:	f7ff ff0d 	bl	80030d0 <chSysUnlock>
      return msg;
 80032b6:	9b03      	ldr	r3, [sp, #12]
 80032b8:	e020      	b.n	80032fc <chIQGetTimeout+0x7c>
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 80032ba:	9801      	ldr	r0, [sp, #4]
 80032bc:	f7ff ff20 	bl	8003100 <chIQIsEmptyI>
 80032c0:	4603      	mov	r3, r0
 80032c2:	2b00      	cmp	r3, #0
 80032c4:	d1ec      	bne.n	80032a0 <chIQGetTimeout+0x20>
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 80032c6:	9b01      	ldr	r3, [sp, #4]
 80032c8:	689b      	ldr	r3, [r3, #8]
 80032ca:	1e5a      	subs	r2, r3, #1
 80032cc:	9b01      	ldr	r3, [sp, #4]
 80032ce:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
 80032d0:	9b01      	ldr	r3, [sp, #4]
 80032d2:	699b      	ldr	r3, [r3, #24]
 80032d4:	1c59      	adds	r1, r3, #1
 80032d6:	9a01      	ldr	r2, [sp, #4]
 80032d8:	6191      	str	r1, [r2, #24]
 80032da:	781b      	ldrb	r3, [r3, #0]
 80032dc:	f88d 300b 	strb.w	r3, [sp, #11]
  if (iqp->q_rdptr >= iqp->q_top) {
 80032e0:	9b01      	ldr	r3, [sp, #4]
 80032e2:	699a      	ldr	r2, [r3, #24]
 80032e4:	9b01      	ldr	r3, [sp, #4]
 80032e6:	691b      	ldr	r3, [r3, #16]
 80032e8:	429a      	cmp	r2, r3
 80032ea:	d303      	bcc.n	80032f4 <chIQGetTimeout+0x74>
    iqp->q_rdptr = iqp->q_buffer;
 80032ec:	9b01      	ldr	r3, [sp, #4]
 80032ee:	68da      	ldr	r2, [r3, #12]
 80032f0:	9b01      	ldr	r3, [sp, #4]
 80032f2:	619a      	str	r2, [r3, #24]
  }
  chSysUnlock();
 80032f4:	f7ff feec 	bl	80030d0 <chSysUnlock>

  return (msg_t)b;
 80032f8:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 80032fc:	4618      	mov	r0, r3
 80032fe:	b005      	add	sp, #20
 8003300:	f85d fb04 	ldr.w	pc, [sp], #4
 8003304:	f3af 8000 	nop.w
 8003308:	f3af 8000 	nop.w
 800330c:	f3af 8000 	nop.w

08003310 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 8003310:	b500      	push	{lr}
 8003312:	b087      	sub	sp, #28
 8003314:	9003      	str	r0, [sp, #12]
 8003316:	9102      	str	r1, [sp, #8]
 8003318:	9201      	str	r2, [sp, #4]
 800331a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = iqp->q_notify;
 800331c:	9b03      	ldr	r3, [sp, #12]
 800331e:	69db      	ldr	r3, [r3, #28]
 8003320:	9304      	str	r3, [sp, #16]
  size_t r = 0;
 8003322:	2300      	movs	r3, #0
 8003324:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);

  chSysLock();
 8003326:	f7ff fecb 	bl	80030c0 <chSysLock>
  while (true) {
    if (nfy != NULL) {
 800332a:	9b04      	ldr	r3, [sp, #16]
 800332c:	2b00      	cmp	r3, #0
 800332e:	d003      	beq.n	8003338 <chIQReadTimeout+0x28>
      nfy(iqp);
 8003330:	9b04      	ldr	r3, [sp, #16]
 8003332:	9803      	ldr	r0, [sp, #12]
 8003334:	4798      	blx	r3
    }

    while (chIQIsEmptyI(iqp)) {
 8003336:	e00c      	b.n	8003352 <chIQReadTimeout+0x42>
 8003338:	e00b      	b.n	8003352 <chIQReadTimeout+0x42>
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 800333a:	9b03      	ldr	r3, [sp, #12]
 800333c:	4618      	mov	r0, r3
 800333e:	9900      	ldr	r1, [sp, #0]
 8003340:	f7fe f8fe 	bl	8001540 <chThdEnqueueTimeoutS>
 8003344:	4603      	mov	r3, r0
 8003346:	2b00      	cmp	r3, #0
 8003348:	d003      	beq.n	8003352 <chIQReadTimeout+0x42>
        chSysUnlock();
 800334a:	f7ff fec1 	bl	80030d0 <chSysUnlock>
        return r;
 800334e:	9b05      	ldr	r3, [sp, #20]
 8003350:	e02e      	b.n	80033b0 <chIQReadTimeout+0xa0>
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 8003352:	9803      	ldr	r0, [sp, #12]
 8003354:	f7ff fed4 	bl	8003100 <chIQIsEmptyI>
 8003358:	4603      	mov	r3, r0
 800335a:	2b00      	cmp	r3, #0
 800335c:	d1ed      	bne.n	800333a <chIQReadTimeout+0x2a>
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 800335e:	9b03      	ldr	r3, [sp, #12]
 8003360:	689b      	ldr	r3, [r3, #8]
 8003362:	1e5a      	subs	r2, r3, #1
 8003364:	9b03      	ldr	r3, [sp, #12]
 8003366:	609a      	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
 8003368:	9b02      	ldr	r3, [sp, #8]
 800336a:	1c5a      	adds	r2, r3, #1
 800336c:	9202      	str	r2, [sp, #8]
 800336e:	9a03      	ldr	r2, [sp, #12]
 8003370:	6992      	ldr	r2, [r2, #24]
 8003372:	1c50      	adds	r0, r2, #1
 8003374:	9903      	ldr	r1, [sp, #12]
 8003376:	6188      	str	r0, [r1, #24]
 8003378:	7812      	ldrb	r2, [r2, #0]
 800337a:	701a      	strb	r2, [r3, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 800337c:	9b03      	ldr	r3, [sp, #12]
 800337e:	699a      	ldr	r2, [r3, #24]
 8003380:	9b03      	ldr	r3, [sp, #12]
 8003382:	691b      	ldr	r3, [r3, #16]
 8003384:	429a      	cmp	r2, r3
 8003386:	d303      	bcc.n	8003390 <chIQReadTimeout+0x80>
      iqp->q_rdptr = iqp->q_buffer;
 8003388:	9b03      	ldr	r3, [sp, #12]
 800338a:	68da      	ldr	r2, [r3, #12]
 800338c:	9b03      	ldr	r3, [sp, #12]
 800338e:	619a      	str	r2, [r3, #24]
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 8003390:	f7ff fe9e 	bl	80030d0 <chSysUnlock>

    r++;
 8003394:	9b05      	ldr	r3, [sp, #20]
 8003396:	3301      	adds	r3, #1
 8003398:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 800339a:	9b01      	ldr	r3, [sp, #4]
 800339c:	3b01      	subs	r3, #1
 800339e:	9301      	str	r3, [sp, #4]
 80033a0:	9b01      	ldr	r3, [sp, #4]
 80033a2:	2b00      	cmp	r3, #0
 80033a4:	d101      	bne.n	80033aa <chIQReadTimeout+0x9a>
      return r;
 80033a6:	9b05      	ldr	r3, [sp, #20]
 80033a8:	e002      	b.n	80033b0 <chIQReadTimeout+0xa0>
    }

    chSysLock();
 80033aa:	f7ff fe89 	bl	80030c0 <chSysLock>
  }
 80033ae:	e7bc      	b.n	800332a <chIQReadTimeout+0x1a>
}
 80033b0:	4618      	mov	r0, r3
 80033b2:	b007      	add	sp, #28
 80033b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80033b8:	f3af 8000 	nop.w
 80033bc:	f3af 8000 	nop.w

080033c0 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
 80033c0:	b500      	push	{lr}
 80033c2:	b085      	sub	sp, #20
 80033c4:	9003      	str	r0, [sp, #12]
 80033c6:	9102      	str	r1, [sp, #8]
 80033c8:	9201      	str	r2, [sp, #4]
 80033ca:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&oqp->q_waiting);
 80033cc:	9b03      	ldr	r3, [sp, #12]
 80033ce:	4618      	mov	r0, r3
 80033d0:	f7ff fe86 	bl	80030e0 <chThdQueueObjectInit>
  oqp->q_counter = size;
 80033d4:	9b03      	ldr	r3, [sp, #12]
 80033d6:	9a01      	ldr	r2, [sp, #4]
 80033d8:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 80033da:	9b03      	ldr	r3, [sp, #12]
 80033dc:	9a02      	ldr	r2, [sp, #8]
 80033de:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 80033e0:	9b03      	ldr	r3, [sp, #12]
 80033e2:	9a02      	ldr	r2, [sp, #8]
 80033e4:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 80033e6:	9b03      	ldr	r3, [sp, #12]
 80033e8:	9a02      	ldr	r2, [sp, #8]
 80033ea:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 80033ec:	9a02      	ldr	r2, [sp, #8]
 80033ee:	9b01      	ldr	r3, [sp, #4]
 80033f0:	441a      	add	r2, r3
 80033f2:	9b03      	ldr	r3, [sp, #12]
 80033f4:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 80033f6:	9b03      	ldr	r3, [sp, #12]
 80033f8:	9a00      	ldr	r2, [sp, #0]
 80033fa:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 80033fc:	9b03      	ldr	r3, [sp, #12]
 80033fe:	9a06      	ldr	r2, [sp, #24]
 8003400:	621a      	str	r2, [r3, #32]
}
 8003402:	b005      	add	sp, #20
 8003404:	f85d fb04 	ldr.w	pc, [sp], #4
 8003408:	f3af 8000 	nop.w
 800340c:	f3af 8000 	nop.w

08003410 <chOQResetI>:
 *
 * @param[in] oqp       pointer to an @p output_queue_t structure
 *
 * @iclass
 */
void chOQResetI(output_queue_t *oqp) {
 8003410:	b500      	push	{lr}
 8003412:	b083      	sub	sp, #12
 8003414:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
 8003416:	9b01      	ldr	r3, [sp, #4]
 8003418:	68da      	ldr	r2, [r3, #12]
 800341a:	9b01      	ldr	r3, [sp, #4]
 800341c:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr = oqp->q_buffer;
 800341e:	9b01      	ldr	r3, [sp, #4]
 8003420:	68da      	ldr	r2, [r3, #12]
 8003422:	9b01      	ldr	r3, [sp, #4]
 8003424:	615a      	str	r2, [r3, #20]
  oqp->q_counter = chQSizeX(oqp);
 8003426:	9b01      	ldr	r3, [sp, #4]
 8003428:	691b      	ldr	r3, [r3, #16]
 800342a:	461a      	mov	r2, r3
 800342c:	9b01      	ldr	r3, [sp, #4]
 800342e:	68db      	ldr	r3, [r3, #12]
 8003430:	1ad3      	subs	r3, r2, r3
 8003432:	461a      	mov	r2, r3
 8003434:	9b01      	ldr	r3, [sp, #4]
 8003436:	609a      	str	r2, [r3, #8]
  chThdDequeueAllI(&oqp->q_waiting, Q_RESET);
 8003438:	9b01      	ldr	r3, [sp, #4]
 800343a:	4618      	mov	r0, r3
 800343c:	f06f 0101 	mvn.w	r1, #1
 8003440:	f7fe f8b6 	bl	80015b0 <chThdDequeueAllI>
}
 8003444:	b003      	add	sp, #12
 8003446:	f85d fb04 	ldr.w	pc, [sp], #4
 800344a:	bf00      	nop
 800344c:	f3af 8000 	nop.w

08003450 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8003450:	b500      	push	{lr}
 8003452:	b087      	sub	sp, #28
 8003454:	9003      	str	r0, [sp, #12]
 8003456:	460b      	mov	r3, r1
 8003458:	9201      	str	r2, [sp, #4]
 800345a:	f88d 300b 	strb.w	r3, [sp, #11]

  chSysLock();
 800345e:	f7ff fe2f 	bl	80030c0 <chSysLock>
  while (chOQIsFullI(oqp)) {
 8003462:	e00c      	b.n	800347e <chOQPutTimeout+0x2e>
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8003464:	9b03      	ldr	r3, [sp, #12]
 8003466:	4618      	mov	r0, r3
 8003468:	9901      	ldr	r1, [sp, #4]
 800346a:	f7fe f869 	bl	8001540 <chThdEnqueueTimeoutS>
 800346e:	9005      	str	r0, [sp, #20]
    if (msg < Q_OK) {
 8003470:	9b05      	ldr	r3, [sp, #20]
 8003472:	2b00      	cmp	r3, #0
 8003474:	da03      	bge.n	800347e <chOQPutTimeout+0x2e>
      chSysUnlock();
 8003476:	f7ff fe2b 	bl	80030d0 <chSysUnlock>
      return msg;
 800347a:	9b05      	ldr	r3, [sp, #20]
 800347c:	e027      	b.n	80034ce <chOQPutTimeout+0x7e>
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 800347e:	9803      	ldr	r0, [sp, #12]
 8003480:	f7ff fe7e 	bl	8003180 <chOQIsFullI>
 8003484:	4603      	mov	r3, r0
 8003486:	2b00      	cmp	r3, #0
 8003488:	d1ec      	bne.n	8003464 <chOQPutTimeout+0x14>
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 800348a:	9b03      	ldr	r3, [sp, #12]
 800348c:	689b      	ldr	r3, [r3, #8]
 800348e:	1e5a      	subs	r2, r3, #1
 8003490:	9b03      	ldr	r3, [sp, #12]
 8003492:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
 8003494:	9b03      	ldr	r3, [sp, #12]
 8003496:	695b      	ldr	r3, [r3, #20]
 8003498:	1c59      	adds	r1, r3, #1
 800349a:	9a03      	ldr	r2, [sp, #12]
 800349c:	6151      	str	r1, [r2, #20]
 800349e:	f89d 200b 	ldrb.w	r2, [sp, #11]
 80034a2:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 80034a4:	9b03      	ldr	r3, [sp, #12]
 80034a6:	695a      	ldr	r2, [r3, #20]
 80034a8:	9b03      	ldr	r3, [sp, #12]
 80034aa:	691b      	ldr	r3, [r3, #16]
 80034ac:	429a      	cmp	r2, r3
 80034ae:	d303      	bcc.n	80034b8 <chOQPutTimeout+0x68>
    oqp->q_wrptr = oqp->q_buffer;
 80034b0:	9b03      	ldr	r3, [sp, #12]
 80034b2:	68da      	ldr	r2, [r3, #12]
 80034b4:	9b03      	ldr	r3, [sp, #12]
 80034b6:	615a      	str	r2, [r3, #20]
  }

  if (oqp->q_notify != NULL) {
 80034b8:	9b03      	ldr	r3, [sp, #12]
 80034ba:	69db      	ldr	r3, [r3, #28]
 80034bc:	2b00      	cmp	r3, #0
 80034be:	d003      	beq.n	80034c8 <chOQPutTimeout+0x78>
    oqp->q_notify(oqp);
 80034c0:	9b03      	ldr	r3, [sp, #12]
 80034c2:	69db      	ldr	r3, [r3, #28]
 80034c4:	9803      	ldr	r0, [sp, #12]
 80034c6:	4798      	blx	r3
  }
  chSysUnlock();
 80034c8:	f7ff fe02 	bl	80030d0 <chSysUnlock>

  return Q_OK;
 80034cc:	2300      	movs	r3, #0
}
 80034ce:	4618      	mov	r0, r3
 80034d0:	b007      	add	sp, #28
 80034d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80034d6:	bf00      	nop
 80034d8:	f3af 8000 	nop.w
 80034dc:	f3af 8000 	nop.w

080034e0 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
 80034e0:	b500      	push	{lr}
 80034e2:	b085      	sub	sp, #20
 80034e4:	9001      	str	r0, [sp, #4]
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp)) {
 80034e6:	9801      	ldr	r0, [sp, #4]
 80034e8:	f7ff fe32 	bl	8003150 <chOQIsEmptyI>
 80034ec:	4603      	mov	r3, r0
 80034ee:	2b00      	cmp	r3, #0
 80034f0:	d002      	beq.n	80034f8 <chOQGetI+0x18>
    return Q_EMPTY;
 80034f2:	f06f 0302 	mvn.w	r3, #2
 80034f6:	e01d      	b.n	8003534 <chOQGetI+0x54>
  }

  oqp->q_counter++;
 80034f8:	9b01      	ldr	r3, [sp, #4]
 80034fa:	689b      	ldr	r3, [r3, #8]
 80034fc:	1c5a      	adds	r2, r3, #1
 80034fe:	9b01      	ldr	r3, [sp, #4]
 8003500:	609a      	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
 8003502:	9b01      	ldr	r3, [sp, #4]
 8003504:	699b      	ldr	r3, [r3, #24]
 8003506:	1c59      	adds	r1, r3, #1
 8003508:	9a01      	ldr	r2, [sp, #4]
 800350a:	6191      	str	r1, [r2, #24]
 800350c:	781b      	ldrb	r3, [r3, #0]
 800350e:	f88d 300f 	strb.w	r3, [sp, #15]
  if (oqp->q_rdptr >= oqp->q_top) {
 8003512:	9b01      	ldr	r3, [sp, #4]
 8003514:	699a      	ldr	r2, [r3, #24]
 8003516:	9b01      	ldr	r3, [sp, #4]
 8003518:	691b      	ldr	r3, [r3, #16]
 800351a:	429a      	cmp	r2, r3
 800351c:	d303      	bcc.n	8003526 <chOQGetI+0x46>
    oqp->q_rdptr = oqp->q_buffer;
 800351e:	9b01      	ldr	r3, [sp, #4]
 8003520:	68da      	ldr	r2, [r3, #12]
 8003522:	9b01      	ldr	r3, [sp, #4]
 8003524:	619a      	str	r2, [r3, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
 8003526:	9b01      	ldr	r3, [sp, #4]
 8003528:	4618      	mov	r0, r3
 800352a:	2100      	movs	r1, #0
 800352c:	f7fe f828 	bl	8001580 <chThdDequeueNextI>

  return (msg_t)b;
 8003530:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8003534:	4618      	mov	r0, r3
 8003536:	b005      	add	sp, #20
 8003538:	f85d fb04 	ldr.w	pc, [sp], #4
 800353c:	f3af 8000 	nop.w

08003540 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8003540:	b500      	push	{lr}
 8003542:	b087      	sub	sp, #28
 8003544:	9003      	str	r0, [sp, #12]
 8003546:	9102      	str	r1, [sp, #8]
 8003548:	9201      	str	r2, [sp, #4]
 800354a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = oqp->q_notify;
 800354c:	9b03      	ldr	r3, [sp, #12]
 800354e:	69db      	ldr	r3, [r3, #28]
 8003550:	9304      	str	r3, [sp, #16]
  size_t w = 0;
 8003552:	2300      	movs	r3, #0
 8003554:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);

  chSysLock();
 8003556:	f7ff fdb3 	bl	80030c0 <chSysLock>
  while (true) {
    while (chOQIsFullI(oqp)) {
 800355a:	e00b      	b.n	8003574 <chOQWriteTimeout+0x34>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 800355c:	9b03      	ldr	r3, [sp, #12]
 800355e:	4618      	mov	r0, r3
 8003560:	9900      	ldr	r1, [sp, #0]
 8003562:	f7fd ffed 	bl	8001540 <chThdEnqueueTimeoutS>
 8003566:	4603      	mov	r3, r0
 8003568:	2b00      	cmp	r3, #0
 800356a:	d003      	beq.n	8003574 <chOQWriteTimeout+0x34>
        chSysUnlock();
 800356c:	f7ff fdb0 	bl	80030d0 <chSysUnlock>
        return w;
 8003570:	9b05      	ldr	r3, [sp, #20]
 8003572:	e035      	b.n	80035e0 <chOQWriteTimeout+0xa0>

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8003574:	9803      	ldr	r0, [sp, #12]
 8003576:	f7ff fe03 	bl	8003180 <chOQIsFullI>
 800357a:	4603      	mov	r3, r0
 800357c:	2b00      	cmp	r3, #0
 800357e:	d1ed      	bne.n	800355c <chOQWriteTimeout+0x1c>
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8003580:	9b03      	ldr	r3, [sp, #12]
 8003582:	689b      	ldr	r3, [r3, #8]
 8003584:	1e5a      	subs	r2, r3, #1
 8003586:	9b03      	ldr	r3, [sp, #12]
 8003588:	609a      	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
 800358a:	9b03      	ldr	r3, [sp, #12]
 800358c:	695b      	ldr	r3, [r3, #20]
 800358e:	1c59      	adds	r1, r3, #1
 8003590:	9a03      	ldr	r2, [sp, #12]
 8003592:	6151      	str	r1, [r2, #20]
 8003594:	9a02      	ldr	r2, [sp, #8]
 8003596:	1c51      	adds	r1, r2, #1
 8003598:	9102      	str	r1, [sp, #8]
 800359a:	7812      	ldrb	r2, [r2, #0]
 800359c:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 800359e:	9b03      	ldr	r3, [sp, #12]
 80035a0:	695a      	ldr	r2, [r3, #20]
 80035a2:	9b03      	ldr	r3, [sp, #12]
 80035a4:	691b      	ldr	r3, [r3, #16]
 80035a6:	429a      	cmp	r2, r3
 80035a8:	d303      	bcc.n	80035b2 <chOQWriteTimeout+0x72>
      oqp->q_wrptr = oqp->q_buffer;
 80035aa:	9b03      	ldr	r3, [sp, #12]
 80035ac:	68da      	ldr	r2, [r3, #12]
 80035ae:	9b03      	ldr	r3, [sp, #12]
 80035b0:	615a      	str	r2, [r3, #20]
    }

    if (nfy != NULL) {
 80035b2:	9b04      	ldr	r3, [sp, #16]
 80035b4:	2b00      	cmp	r3, #0
 80035b6:	d002      	beq.n	80035be <chOQWriteTimeout+0x7e>
      nfy(oqp);
 80035b8:	9b04      	ldr	r3, [sp, #16]
 80035ba:	9803      	ldr	r0, [sp, #12]
 80035bc:	4798      	blx	r3
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 80035be:	f7ff fd87 	bl	80030d0 <chSysUnlock>

    w++;
 80035c2:	9b05      	ldr	r3, [sp, #20]
 80035c4:	3301      	adds	r3, #1
 80035c6:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 80035c8:	9b01      	ldr	r3, [sp, #4]
 80035ca:	3b01      	subs	r3, #1
 80035cc:	9301      	str	r3, [sp, #4]
 80035ce:	9b01      	ldr	r3, [sp, #4]
 80035d0:	2b00      	cmp	r3, #0
 80035d2:	d101      	bne.n	80035d8 <chOQWriteTimeout+0x98>
      return w;
 80035d4:	9b05      	ldr	r3, [sp, #20]
 80035d6:	e003      	b.n	80035e0 <chOQWriteTimeout+0xa0>
    }
    chSysLock();
 80035d8:	f7ff fd72 	bl	80030c0 <chSysLock>
  }
 80035dc:	bf00      	nop

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 80035de:	e7c9      	b.n	8003574 <chOQWriteTimeout+0x34>
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 80035e0:	4618      	mov	r0, r3
 80035e2:	b007      	add	sp, #28
 80035e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80035e8:	f3af 8000 	nop.w
 80035ec:	f3af 8000 	nop.w

080035f0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80035f0:	b082      	sub	sp, #8
 80035f2:	2320      	movs	r3, #32
 80035f4:	9301      	str	r3, [sp, #4]
 80035f6:	9b01      	ldr	r3, [sp, #4]
 80035f8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80035fc:	b002      	add	sp, #8
 80035fe:	4770      	bx	lr

08003600 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003600:	b082      	sub	sp, #8
 8003602:	2300      	movs	r3, #0
 8003604:	9301      	str	r3, [sp, #4]
 8003606:	9b01      	ldr	r3, [sp, #4]
 8003608:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800360c:	b002      	add	sp, #8
 800360e:	4770      	bx	lr

08003610 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8003610:	b508      	push	{r3, lr}

  port_lock();
 8003612:	f7ff ffed 	bl	80035f0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8003616:	bd08      	pop	{r3, pc}
 8003618:	f3af 8000 	nop.w
 800361c:	f3af 8000 	nop.w

08003620 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8003620:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8003622:	f7ff ffed 	bl	8003600 <port_unlock>
}
 8003626:	bd08      	pop	{r3, pc}
 8003628:	f3af 8000 	nop.w
 800362c:	f3af 8000 	nop.w

08003630 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8003630:	4b06      	ldr	r3, [pc, #24]	; (800364c <_core_init+0x1c>)
 8003632:	3307      	adds	r3, #7
 8003634:	f023 0307 	bic.w	r3, r3, #7
 8003638:	461a      	mov	r2, r3
 800363a:	4b05      	ldr	r3, [pc, #20]	; (8003650 <_core_init+0x20>)
 800363c:	601a      	str	r2, [r3, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 800363e:	4b05      	ldr	r3, [pc, #20]	; (8003654 <_core_init+0x24>)
 8003640:	f023 0307 	bic.w	r3, r3, #7
 8003644:	461a      	mov	r2, r3
 8003646:	4b04      	ldr	r3, [pc, #16]	; (8003658 <_core_init+0x28>)
 8003648:	601a      	str	r2, [r3, #0]

  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_CFG_MEMCORE_SIZE) /
                              MEM_ALIGN_SIZE];
#endif
}
 800364a:	4770      	bx	lr
 800364c:	20002238 	.word	0x20002238
 8003650:	20000d48 	.word	0x20000d48
 8003654:	20018000 	.word	0x20018000
 8003658:	20000d4c 	.word	0x20000d4c
 800365c:	f3af 8000 	nop.w

08003660 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8003660:	b500      	push	{lr}
 8003662:	b085      	sub	sp, #20
 8003664:	9001      	str	r0, [sp, #4]
  void *p;

  chSysLock();
 8003666:	f7ff ffd3 	bl	8003610 <chSysLock>
  p = chCoreAllocI(size);
 800366a:	9801      	ldr	r0, [sp, #4]
 800366c:	f000 f808 	bl	8003680 <chCoreAllocI>
 8003670:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8003672:	f7ff ffd5 	bl	8003620 <chSysUnlock>

  return p;
 8003676:	9b03      	ldr	r3, [sp, #12]
}
 8003678:	4618      	mov	r0, r3
 800367a:	b005      	add	sp, #20
 800367c:	f85d fb04 	ldr.w	pc, [sp], #4

08003680 <chCoreAllocI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
 8003680:	b084      	sub	sp, #16
 8003682:	9001      	str	r0, [sp, #4]
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8003684:	9b01      	ldr	r3, [sp, #4]
 8003686:	3307      	adds	r3, #7
 8003688:	f023 0307 	bic.w	r3, r3, #7
 800368c:	9301      	str	r3, [sp, #4]
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 800368e:	4b0c      	ldr	r3, [pc, #48]	; (80036c0 <chCoreAllocI+0x40>)
 8003690:	681b      	ldr	r3, [r3, #0]
 8003692:	461a      	mov	r2, r3
 8003694:	4b0b      	ldr	r3, [pc, #44]	; (80036c4 <chCoreAllocI+0x44>)
 8003696:	681b      	ldr	r3, [r3, #0]
 8003698:	1ad3      	subs	r3, r2, r3
 800369a:	461a      	mov	r2, r3
 800369c:	9b01      	ldr	r3, [sp, #4]
 800369e:	429a      	cmp	r2, r3
 80036a0:	d201      	bcs.n	80036a6 <chCoreAllocI+0x26>
  /*lint -restore*/
    return NULL;
 80036a2:	2300      	movs	r3, #0
 80036a4:	e009      	b.n	80036ba <chCoreAllocI+0x3a>
  }
  p = nextmem;
 80036a6:	4b07      	ldr	r3, [pc, #28]	; (80036c4 <chCoreAllocI+0x44>)
 80036a8:	681b      	ldr	r3, [r3, #0]
 80036aa:	9303      	str	r3, [sp, #12]
  nextmem += size;
 80036ac:	4b05      	ldr	r3, [pc, #20]	; (80036c4 <chCoreAllocI+0x44>)
 80036ae:	681a      	ldr	r2, [r3, #0]
 80036b0:	9b01      	ldr	r3, [sp, #4]
 80036b2:	441a      	add	r2, r3
 80036b4:	4b03      	ldr	r3, [pc, #12]	; (80036c4 <chCoreAllocI+0x44>)
 80036b6:	601a      	str	r2, [r3, #0]

  return p;
 80036b8:	9b03      	ldr	r3, [sp, #12]
}
 80036ba:	4618      	mov	r0, r3
 80036bc:	b004      	add	sp, #16
 80036be:	4770      	bx	lr
 80036c0:	20000d4c 	.word	0x20000d4c
 80036c4:	20000d48 	.word	0x20000d48
 80036c8:	f3af 8000 	nop.w
 80036cc:	f3af 8000 	nop.w

080036d0 <chCoreGetStatusX>:
 * @xclass
 */
size_t chCoreGetStatusX(void) {

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(endmem - nextmem);
 80036d0:	4b03      	ldr	r3, [pc, #12]	; (80036e0 <chCoreGetStatusX+0x10>)
 80036d2:	681b      	ldr	r3, [r3, #0]
 80036d4:	461a      	mov	r2, r3
 80036d6:	4b03      	ldr	r3, [pc, #12]	; (80036e4 <chCoreGetStatusX+0x14>)
 80036d8:	681b      	ldr	r3, [r3, #0]
 80036da:	1ad3      	subs	r3, r2, r3
  /*lint -restore*/
}
 80036dc:	4618      	mov	r0, r3
 80036de:	4770      	bx	lr
 80036e0:	20000d4c 	.word	0x20000d4c
 80036e4:	20000d48 	.word	0x20000d48
 80036e8:	f3af 8000 	nop.w
 80036ec:	f3af 8000 	nop.w

080036f0 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 80036f0:	b508      	push	{r3, lr}

  default_heap.h_provider = chCoreAlloc;
 80036f2:	4b06      	ldr	r3, [pc, #24]	; (800370c <_heap_init+0x1c>)
 80036f4:	4a06      	ldr	r2, [pc, #24]	; (8003710 <_heap_init+0x20>)
 80036f6:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
 80036f8:	4b04      	ldr	r3, [pc, #16]	; (800370c <_heap_init+0x1c>)
 80036fa:	2200      	movs	r2, #0
 80036fc:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 80036fe:	4b03      	ldr	r3, [pc, #12]	; (800370c <_heap_init+0x1c>)
 8003700:	2200      	movs	r2, #0
 8003702:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8003704:	4803      	ldr	r0, [pc, #12]	; (8003714 <_heap_init+0x24>)
 8003706:	f7fe fbf3 	bl	8001ef0 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.h_sem, (cnt_t)1);
#endif
}
 800370a:	bd08      	pop	{r3, pc}
 800370c:	20000d50 	.word	0x20000d50
 8003710:	08003661 	.word	0x08003661
 8003714:	20000d60 	.word	0x20000d60
 8003718:	f3af 8000 	nop.w
 800371c:	f3af 8000 	nop.w

08003720 <chHeapObjectInit>:
 * @param[in] buf       heap buffer base
 * @param[in] size      heap size
 *
 * @init
 */
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
 8003720:	b500      	push	{lr}
 8003722:	b087      	sub	sp, #28
 8003724:	9003      	str	r0, [sp, #12]
 8003726:	9102      	str	r1, [sp, #8]
 8003728:	9201      	str	r2, [sp, #4]
  union heap_header *hp = buf;
 800372a:	9b02      	ldr	r3, [sp, #8]
 800372c:	9305      	str	r3, [sp, #20]

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 800372e:	9b03      	ldr	r3, [sp, #12]
 8003730:	2200      	movs	r2, #0
 8003732:	601a      	str	r2, [r3, #0]
  heapp->h_free.h.u.next = hp;
 8003734:	9b03      	ldr	r3, [sp, #12]
 8003736:	9a05      	ldr	r2, [sp, #20]
 8003738:	609a      	str	r2, [r3, #8]
  heapp->h_free.h.size = 0;
 800373a:	9b03      	ldr	r3, [sp, #12]
 800373c:	2200      	movs	r2, #0
 800373e:	60da      	str	r2, [r3, #12]
  hp->h.u.next = NULL;
 8003740:	9b05      	ldr	r3, [sp, #20]
 8003742:	2200      	movs	r2, #0
 8003744:	601a      	str	r2, [r3, #0]
  hp->h.size = size - sizeof(union heap_header);
 8003746:	9b01      	ldr	r3, [sp, #4]
 8003748:	f1a3 0208 	sub.w	r2, r3, #8
 800374c:	9b05      	ldr	r3, [sp, #20]
 800374e:	605a      	str	r2, [r3, #4]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&heapp->h_mtx);
 8003750:	9b03      	ldr	r3, [sp, #12]
 8003752:	3310      	adds	r3, #16
 8003754:	4618      	mov	r0, r3
 8003756:	f7fe fbcb 	bl	8001ef0 <chMtxObjectInit>
#else
  chSemObjectInit(&heapp->h_sem, (cnt_t)1);
#endif
}
 800375a:	b007      	add	sp, #28
 800375c:	f85d fb04 	ldr.w	pc, [sp], #4

08003760 <chHeapAlloc>:
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
 8003760:	b500      	push	{lr}
 8003762:	b087      	sub	sp, #28
 8003764:	9001      	str	r0, [sp, #4]
 8003766:	9100      	str	r1, [sp, #0]
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL) {
 8003768:	9b01      	ldr	r3, [sp, #4]
 800376a:	2b00      	cmp	r3, #0
 800376c:	d101      	bne.n	8003772 <chHeapAlloc+0x12>
    heapp = &default_heap;
 800376e:	4b37      	ldr	r3, [pc, #220]	; (800384c <chHeapAlloc+0xec>)
 8003770:	9301      	str	r3, [sp, #4]
  }

  size = MEM_ALIGN_NEXT(size);
 8003772:	9b00      	ldr	r3, [sp, #0]
 8003774:	3307      	adds	r3, #7
 8003776:	f023 0307 	bic.w	r3, r3, #7
 800377a:	9300      	str	r3, [sp, #0]
  qp = &heapp->h_free;
 800377c:	9b01      	ldr	r3, [sp, #4]
 800377e:	3308      	adds	r3, #8
 8003780:	9305      	str	r3, [sp, #20]

  H_LOCK(heapp);
 8003782:	9b01      	ldr	r3, [sp, #4]
 8003784:	3310      	adds	r3, #16
 8003786:	4618      	mov	r0, r3
 8003788:	f7fe fbc2 	bl	8001f10 <chMtxLock>
  while (qp->h.u.next != NULL) {
 800378c:	e036      	b.n	80037fc <chHeapAlloc+0x9c>
    hp = qp->h.u.next;
 800378e:	9b05      	ldr	r3, [sp, #20]
 8003790:	681b      	ldr	r3, [r3, #0]
 8003792:	9304      	str	r3, [sp, #16]
    if (hp->h.size >= size) {
 8003794:	9b04      	ldr	r3, [sp, #16]
 8003796:	685a      	ldr	r2, [r3, #4]
 8003798:	9b00      	ldr	r3, [sp, #0]
 800379a:	429a      	cmp	r2, r3
 800379c:	d32c      	bcc.n	80037f8 <chHeapAlloc+0x98>
      if (hp->h.size < (size + sizeof(union heap_header))) {
 800379e:	9b04      	ldr	r3, [sp, #16]
 80037a0:	685a      	ldr	r2, [r3, #4]
 80037a2:	9b00      	ldr	r3, [sp, #0]
 80037a4:	3308      	adds	r3, #8
 80037a6:	429a      	cmp	r2, r3
 80037a8:	d204      	bcs.n	80037b4 <chHeapAlloc+0x54>
        /* Gets the whole block even if it is slightly bigger than the
           requested size because the fragment would be too small to be
           useful.*/
        qp->h.u.next = hp->h.u.next;
 80037aa:	9b04      	ldr	r3, [sp, #16]
 80037ac:	681a      	ldr	r2, [r3, #0]
 80037ae:	9b05      	ldr	r3, [sp, #20]
 80037b0:	601a      	str	r2, [r3, #0]
 80037b2:	e016      	b.n	80037e2 <chHeapAlloc+0x82>
      }
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
 80037b4:	9b00      	ldr	r3, [sp, #0]
 80037b6:	3308      	adds	r3, #8
 80037b8:	9a04      	ldr	r2, [sp, #16]
 80037ba:	4413      	add	r3, r2
 80037bc:	9303      	str	r3, [sp, #12]
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
 80037be:	9b04      	ldr	r3, [sp, #16]
 80037c0:	681a      	ldr	r2, [r3, #0]
 80037c2:	9b03      	ldr	r3, [sp, #12]
 80037c4:	601a      	str	r2, [r3, #0]
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 80037c6:	9b04      	ldr	r3, [sp, #16]
 80037c8:	685a      	ldr	r2, [r3, #4]
 80037ca:	9b00      	ldr	r3, [sp, #0]
 80037cc:	1ad3      	subs	r3, r2, r3
 80037ce:	f1a3 0208 	sub.w	r2, r3, #8
 80037d2:	9b03      	ldr	r3, [sp, #12]
 80037d4:	605a      	str	r2, [r3, #4]
        qp->h.u.next = fp;
 80037d6:	9b05      	ldr	r3, [sp, #20]
 80037d8:	9a03      	ldr	r2, [sp, #12]
 80037da:	601a      	str	r2, [r3, #0]
        hp->h.size = size;
 80037dc:	9b04      	ldr	r3, [sp, #16]
 80037de:	9a00      	ldr	r2, [sp, #0]
 80037e0:	605a      	str	r2, [r3, #4]
      }
      hp->h.u.heap = heapp;
 80037e2:	9b04      	ldr	r3, [sp, #16]
 80037e4:	9a01      	ldr	r2, [sp, #4]
 80037e6:	601a      	str	r2, [r3, #0]
      H_UNLOCK(heapp);
 80037e8:	9b01      	ldr	r3, [sp, #4]
 80037ea:	3310      	adds	r3, #16
 80037ec:	4618      	mov	r0, r3
 80037ee:	f7fe fc37 	bl	8002060 <chMtxUnlock>

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)(hp + 1);
 80037f2:	9b04      	ldr	r3, [sp, #16]
 80037f4:	3308      	adds	r3, #8
 80037f6:	e024      	b.n	8003842 <chHeapAlloc+0xe2>
      /*lint -restore*/
    }
    qp = hp;
 80037f8:	9b04      	ldr	r3, [sp, #16]
 80037fa:	9305      	str	r3, [sp, #20]

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
 80037fc:	9b05      	ldr	r3, [sp, #20]
 80037fe:	681b      	ldr	r3, [r3, #0]
 8003800:	2b00      	cmp	r3, #0
 8003802:	d1c4      	bne.n	800378e <chHeapAlloc+0x2e>
      return (void *)(hp + 1);
      /*lint -restore*/
    }
    qp = hp;
  }
  H_UNLOCK(heapp);
 8003804:	9b01      	ldr	r3, [sp, #4]
 8003806:	3310      	adds	r3, #16
 8003808:	4618      	mov	r0, r3
 800380a:	f7fe fc29 	bl	8002060 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider != NULL) {
 800380e:	9b01      	ldr	r3, [sp, #4]
 8003810:	681b      	ldr	r3, [r3, #0]
 8003812:	2b00      	cmp	r3, #0
 8003814:	d014      	beq.n	8003840 <chHeapAlloc+0xe0>
    hp = heapp->h_provider(size + sizeof(union heap_header));
 8003816:	9b01      	ldr	r3, [sp, #4]
 8003818:	681b      	ldr	r3, [r3, #0]
 800381a:	9a00      	ldr	r2, [sp, #0]
 800381c:	3208      	adds	r2, #8
 800381e:	4610      	mov	r0, r2
 8003820:	4798      	blx	r3
 8003822:	9004      	str	r0, [sp, #16]
    if (hp != NULL) {
 8003824:	9b04      	ldr	r3, [sp, #16]
 8003826:	2b00      	cmp	r3, #0
 8003828:	d00a      	beq.n	8003840 <chHeapAlloc+0xe0>
      hp->h.u.heap = heapp;
 800382a:	9b04      	ldr	r3, [sp, #16]
 800382c:	9a01      	ldr	r2, [sp, #4]
 800382e:	601a      	str	r2, [r3, #0]
      hp->h.size = size;
 8003830:	9b04      	ldr	r3, [sp, #16]
 8003832:	9a00      	ldr	r2, [sp, #0]
 8003834:	605a      	str	r2, [r3, #4]
      hp++;
 8003836:	9b04      	ldr	r3, [sp, #16]
 8003838:	3308      	adds	r3, #8
 800383a:	9304      	str	r3, [sp, #16]

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)hp;
 800383c:	9b04      	ldr	r3, [sp, #16]
 800383e:	e000      	b.n	8003842 <chHeapAlloc+0xe2>
      /*lint -restore*/
    }
  }

  return NULL;
 8003840:	2300      	movs	r3, #0
}
 8003842:	4618      	mov	r0, r3
 8003844:	b007      	add	sp, #28
 8003846:	f85d fb04 	ldr.w	pc, [sp], #4
 800384a:	bf00      	nop
 800384c:	20000d50 	.word	0x20000d50

08003850 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8003850:	b500      	push	{lr}
 8003852:	b087      	sub	sp, #28
 8003854:	9001      	str	r0, [sp, #4]
  memory_heap_t *heapp;

  chDbgCheck(p != NULL);

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
 8003856:	9b01      	ldr	r3, [sp, #4]
 8003858:	3b08      	subs	r3, #8
 800385a:	9304      	str	r3, [sp, #16]
  /*lint -restore*/
  heapp = hp->h.u.heap;
 800385c:	9b04      	ldr	r3, [sp, #16]
 800385e:	681b      	ldr	r3, [r3, #0]
 8003860:	9303      	str	r3, [sp, #12]
  qp = &heapp->h_free;
 8003862:	9b03      	ldr	r3, [sp, #12]
 8003864:	3308      	adds	r3, #8
 8003866:	9305      	str	r3, [sp, #20]

  H_LOCK(heapp);
 8003868:	9b03      	ldr	r3, [sp, #12]
 800386a:	3310      	adds	r3, #16
 800386c:	4618      	mov	r0, r3
 800386e:	f7fe fb4f 	bl	8001f10 <chMtxLock>
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 8003872:	9b03      	ldr	r3, [sp, #12]
 8003874:	f103 0208 	add.w	r2, r3, #8
 8003878:	9b05      	ldr	r3, [sp, #20]
 800387a:	429a      	cmp	r2, r3
 800387c:	d003      	beq.n	8003886 <chHeapFree+0x36>
 800387e:	9a04      	ldr	r2, [sp, #16]
 8003880:	9b05      	ldr	r3, [sp, #20]
 8003882:	429a      	cmp	r2, r3
 8003884:	d93e      	bls.n	8003904 <chHeapFree+0xb4>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 8003886:	9b05      	ldr	r3, [sp, #20]
 8003888:	681b      	ldr	r3, [r3, #0]

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 800388a:	2b00      	cmp	r3, #0
 800388c:	d004      	beq.n	8003898 <chHeapFree+0x48>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 800388e:	9b05      	ldr	r3, [sp, #20]
 8003890:	681a      	ldr	r2, [r3, #0]
 8003892:	9b04      	ldr	r3, [sp, #16]
 8003894:	429a      	cmp	r2, r3
 8003896:	d935      	bls.n	8003904 <chHeapFree+0xb4>
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
 8003898:	9b05      	ldr	r3, [sp, #20]
 800389a:	681a      	ldr	r2, [r3, #0]
 800389c:	9b04      	ldr	r3, [sp, #16]
 800389e:	601a      	str	r2, [r3, #0]
      qp->h.u.next = hp;
 80038a0:	9b05      	ldr	r3, [sp, #20]
 80038a2:	9a04      	ldr	r2, [sp, #16]
 80038a4:	601a      	str	r2, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 80038a6:	9b04      	ldr	r3, [sp, #16]
 80038a8:	685b      	ldr	r3, [r3, #4]
 80038aa:	3308      	adds	r3, #8
 80038ac:	9a04      	ldr	r2, [sp, #16]
 80038ae:	441a      	add	r2, r3
 80038b0:	9b04      	ldr	r3, [sp, #16]
 80038b2:	681b      	ldr	r3, [r3, #0]
 80038b4:	429a      	cmp	r2, r3
 80038b6:	d10e      	bne.n	80038d6 <chHeapFree+0x86>
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 80038b8:	9b04      	ldr	r3, [sp, #16]
 80038ba:	685a      	ldr	r2, [r3, #4]
 80038bc:	9b04      	ldr	r3, [sp, #16]
 80038be:	681b      	ldr	r3, [r3, #0]
 80038c0:	685b      	ldr	r3, [r3, #4]
 80038c2:	4413      	add	r3, r2
 80038c4:	f103 0208 	add.w	r2, r3, #8
 80038c8:	9b04      	ldr	r3, [sp, #16]
 80038ca:	605a      	str	r2, [r3, #4]
        hp->h.u.next = hp->h.u.next->h.u.next;
 80038cc:	9b04      	ldr	r3, [sp, #16]
 80038ce:	681b      	ldr	r3, [r3, #0]
 80038d0:	681a      	ldr	r2, [r3, #0]
 80038d2:	9b04      	ldr	r3, [sp, #16]
 80038d4:	601a      	str	r2, [r3, #0]
      }
      if ((LIMIT(qp) == hp)) {
 80038d6:	9b05      	ldr	r3, [sp, #20]
 80038d8:	685b      	ldr	r3, [r3, #4]
 80038da:	3308      	adds	r3, #8
 80038dc:	9a05      	ldr	r2, [sp, #20]
 80038de:	441a      	add	r2, r3
 80038e0:	9b04      	ldr	r3, [sp, #16]
 80038e2:	429a      	cmp	r2, r3
 80038e4:	d10d      	bne.n	8003902 <chHeapFree+0xb2>
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 80038e6:	9b05      	ldr	r3, [sp, #20]
 80038e8:	685a      	ldr	r2, [r3, #4]
 80038ea:	9b04      	ldr	r3, [sp, #16]
 80038ec:	685b      	ldr	r3, [r3, #4]
 80038ee:	4413      	add	r3, r2
 80038f0:	f103 0208 	add.w	r2, r3, #8
 80038f4:	9b05      	ldr	r3, [sp, #20]
 80038f6:	605a      	str	r2, [r3, #4]
        qp->h.u.next = hp->h.u.next;
 80038f8:	9b04      	ldr	r3, [sp, #16]
 80038fa:	681a      	ldr	r2, [r3, #0]
 80038fc:	9b05      	ldr	r3, [sp, #20]
 80038fe:	601a      	str	r2, [r3, #0]
      }
      break;
 8003900:	e004      	b.n	800390c <chHeapFree+0xbc>
 8003902:	e003      	b.n	800390c <chHeapFree+0xbc>
    }
    qp = qp->h.u.next;
 8003904:	9b05      	ldr	r3, [sp, #20]
 8003906:	681b      	ldr	r3, [r3, #0]
 8003908:	9305      	str	r3, [sp, #20]
  }
 800390a:	e7b2      	b.n	8003872 <chHeapFree+0x22>
  H_UNLOCK(heapp);
 800390c:	9b03      	ldr	r3, [sp, #12]
 800390e:	3310      	adds	r3, #16
 8003910:	4618      	mov	r0, r3
 8003912:	f7fe fba5 	bl	8002060 <chMtxUnlock>

  return;
 8003916:	bf00      	nop
}
 8003918:	b007      	add	sp, #28
 800391a:	f85d fb04 	ldr.w	pc, [sp], #4
 800391e:	bf00      	nop

08003920 <chHeapStatus>:
 *                      fragmented free space
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *sizep) {
 8003920:	b500      	push	{lr}
 8003922:	b087      	sub	sp, #28
 8003924:	9001      	str	r0, [sp, #4]
 8003926:	9100      	str	r1, [sp, #0]
  union heap_header *qp;
  size_t n, sz;

  if (heapp == NULL) {
 8003928:	9b01      	ldr	r3, [sp, #4]
 800392a:	2b00      	cmp	r3, #0
 800392c:	d101      	bne.n	8003932 <chHeapStatus+0x12>
    heapp = &default_heap;
 800392e:	4b17      	ldr	r3, [pc, #92]	; (800398c <chHeapStatus+0x6c>)
 8003930:	9301      	str	r3, [sp, #4]
  }

  H_LOCK(heapp);
 8003932:	9b01      	ldr	r3, [sp, #4]
 8003934:	3310      	adds	r3, #16
 8003936:	4618      	mov	r0, r3
 8003938:	f7fe faea 	bl	8001f10 <chMtxLock>
  sz = 0;
 800393c:	2300      	movs	r3, #0
 800393e:	9303      	str	r3, [sp, #12]
  n = 0;
 8003940:	2300      	movs	r3, #0
 8003942:	9304      	str	r3, [sp, #16]
  qp = &heapp->h_free;
 8003944:	9b01      	ldr	r3, [sp, #4]
 8003946:	3308      	adds	r3, #8
 8003948:	9305      	str	r3, [sp, #20]
  while (qp->h.u.next != NULL) {
 800394a:	e00b      	b.n	8003964 <chHeapStatus+0x44>
    sz += qp->h.u.next->h.size;
 800394c:	9b05      	ldr	r3, [sp, #20]
 800394e:	681b      	ldr	r3, [r3, #0]
 8003950:	685b      	ldr	r3, [r3, #4]
 8003952:	9a03      	ldr	r2, [sp, #12]
 8003954:	4413      	add	r3, r2
 8003956:	9303      	str	r3, [sp, #12]
    n++;
 8003958:	9b04      	ldr	r3, [sp, #16]
 800395a:	3301      	adds	r3, #1
 800395c:	9304      	str	r3, [sp, #16]
    qp = qp->h.u.next;
 800395e:	9b05      	ldr	r3, [sp, #20]
 8003960:	681b      	ldr	r3, [r3, #0]
 8003962:	9305      	str	r3, [sp, #20]

  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 8003964:	9b05      	ldr	r3, [sp, #20]
 8003966:	681b      	ldr	r3, [r3, #0]
 8003968:	2b00      	cmp	r3, #0
 800396a:	d1ef      	bne.n	800394c <chHeapStatus+0x2c>
    sz += qp->h.u.next->h.size;
    n++;
    qp = qp->h.u.next;
  }
  if (sizep != NULL) {
 800396c:	9b00      	ldr	r3, [sp, #0]
 800396e:	2b00      	cmp	r3, #0
 8003970:	d002      	beq.n	8003978 <chHeapStatus+0x58>
    *sizep = sz;
 8003972:	9b00      	ldr	r3, [sp, #0]
 8003974:	9a03      	ldr	r2, [sp, #12]
 8003976:	601a      	str	r2, [r3, #0]
  }
  H_UNLOCK(heapp);
 8003978:	9b01      	ldr	r3, [sp, #4]
 800397a:	3310      	adds	r3, #16
 800397c:	4618      	mov	r0, r3
 800397e:	f7fe fb6f 	bl	8002060 <chMtxUnlock>

  return n;
 8003982:	9b04      	ldr	r3, [sp, #16]
}
 8003984:	4618      	mov	r0, r3
 8003986:	b007      	add	sp, #28
 8003988:	f85d fb04 	ldr.w	pc, [sp], #4
 800398c:	20000d50 	.word	0x20000d50

08003990 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003990:	b082      	sub	sp, #8
 8003992:	2320      	movs	r3, #32
 8003994:	9301      	str	r3, [sp, #4]
 8003996:	9b01      	ldr	r3, [sp, #4]
 8003998:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800399c:	b002      	add	sp, #8
 800399e:	4770      	bx	lr

080039a0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80039a0:	b082      	sub	sp, #8
 80039a2:	2300      	movs	r3, #0
 80039a4:	9301      	str	r3, [sp, #4]
 80039a6:	9b01      	ldr	r3, [sp, #4]
 80039a8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80039ac:	b002      	add	sp, #8
 80039ae:	4770      	bx	lr

080039b0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80039b0:	b508      	push	{r3, lr}

  port_lock();
 80039b2:	f7ff ffed 	bl	8003990 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80039b6:	bd08      	pop	{r3, pc}
 80039b8:	f3af 8000 	nop.w
 80039bc:	f3af 8000 	nop.w

080039c0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80039c0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80039c2:	f7ff ffed 	bl	80039a0 <port_unlock>
}
 80039c6:	bd08      	pop	{r3, pc}
 80039c8:	f3af 8000 	nop.w
 80039cc:	f3af 8000 	nop.w

080039d0 <chPoolAdd>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be added
 *
 * @api
 */
static inline void chPoolAdd(memory_pool_t *mp, void *objp) {
 80039d0:	b500      	push	{lr}
 80039d2:	b083      	sub	sp, #12
 80039d4:	9001      	str	r0, [sp, #4]
 80039d6:	9100      	str	r1, [sp, #0]

  chPoolFree(mp, objp);
 80039d8:	9801      	ldr	r0, [sp, #4]
 80039da:	9900      	ldr	r1, [sp, #0]
 80039dc:	f000 f870 	bl	8003ac0 <chPoolFree>
}
 80039e0:	b003      	add	sp, #12
 80039e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80039e6:	bf00      	nop
 80039e8:	f3af 8000 	nop.w
 80039ec:	f3af 8000 	nop.w

080039f0 <chPoolObjectInit>:
 *                      @p NULL if the pool is not allowed to grow
 *                      automatically
 *
 * @init
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {
 80039f0:	b084      	sub	sp, #16
 80039f2:	9003      	str	r0, [sp, #12]
 80039f4:	9102      	str	r1, [sp, #8]
 80039f6:	9201      	str	r2, [sp, #4]

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 80039f8:	9b03      	ldr	r3, [sp, #12]
 80039fa:	2200      	movs	r2, #0
 80039fc:	601a      	str	r2, [r3, #0]
  mp->mp_object_size = size;
 80039fe:	9b03      	ldr	r3, [sp, #12]
 8003a00:	9a02      	ldr	r2, [sp, #8]
 8003a02:	605a      	str	r2, [r3, #4]
  mp->mp_provider = provider;
 8003a04:	9b03      	ldr	r3, [sp, #12]
 8003a06:	9a01      	ldr	r2, [sp, #4]
 8003a08:	609a      	str	r2, [r3, #8]
}
 8003a0a:	b004      	add	sp, #16
 8003a0c:	4770      	bx	lr
 8003a0e:	bf00      	nop

08003a10 <chPoolLoadArray>:
 * @param[in] p         pointer to the array first element
 * @param[in] n         number of elements in the array
 *
 * @api
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {
 8003a10:	b500      	push	{lr}
 8003a12:	b085      	sub	sp, #20
 8003a14:	9003      	str	r0, [sp, #12]
 8003a16:	9102      	str	r1, [sp, #8]
 8003a18:	9201      	str	r2, [sp, #4]

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8003a1a:	e00b      	b.n	8003a34 <chPoolLoadArray+0x24>
    chPoolAdd(mp, p);
 8003a1c:	9803      	ldr	r0, [sp, #12]
 8003a1e:	9902      	ldr	r1, [sp, #8]
 8003a20:	f7ff ffd6 	bl	80039d0 <chPoolAdd>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
 8003a24:	9b03      	ldr	r3, [sp, #12]
 8003a26:	685b      	ldr	r3, [r3, #4]
 8003a28:	9a02      	ldr	r2, [sp, #8]
 8003a2a:	4413      	add	r3, r2
 8003a2c:	9302      	str	r3, [sp, #8]
    /*lint -restore*/
    n--;
 8003a2e:	9b01      	ldr	r3, [sp, #4]
 8003a30:	3b01      	subs	r3, #1
 8003a32:	9301      	str	r3, [sp, #4]
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8003a34:	9b01      	ldr	r3, [sp, #4]
 8003a36:	2b00      	cmp	r3, #0
 8003a38:	d1f0      	bne.n	8003a1c <chPoolLoadArray+0xc>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
    /*lint -restore*/
    n--;
  }
}
 8003a3a:	b005      	add	sp, #20
 8003a3c:	f85d fb04 	ldr.w	pc, [sp], #4

08003a40 <chPoolAllocI>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(memory_pool_t *mp) {
 8003a40:	b500      	push	{lr}
 8003a42:	b085      	sub	sp, #20
 8003a44:	9001      	str	r0, [sp, #4]
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);

  objp = mp->mp_next;
 8003a46:	9b01      	ldr	r3, [sp, #4]
 8003a48:	681b      	ldr	r3, [r3, #0]
 8003a4a:	9303      	str	r3, [sp, #12]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 8003a4c:	9b03      	ldr	r3, [sp, #12]
 8003a4e:	2b00      	cmp	r3, #0
 8003a50:	d005      	beq.n	8003a5e <chPoolAllocI+0x1e>
    mp->mp_next = mp->mp_next->ph_next;
 8003a52:	9b01      	ldr	r3, [sp, #4]
 8003a54:	681b      	ldr	r3, [r3, #0]
 8003a56:	681a      	ldr	r2, [r3, #0]
 8003a58:	9b01      	ldr	r3, [sp, #4]
 8003a5a:	601a      	str	r2, [r3, #0]
 8003a5c:	e00a      	b.n	8003a74 <chPoolAllocI+0x34>
  }
  else if (mp->mp_provider != NULL) {
 8003a5e:	9b01      	ldr	r3, [sp, #4]
 8003a60:	689b      	ldr	r3, [r3, #8]
 8003a62:	2b00      	cmp	r3, #0
 8003a64:	d006      	beq.n	8003a74 <chPoolAllocI+0x34>
    objp = mp->mp_provider(mp->mp_object_size);
 8003a66:	9b01      	ldr	r3, [sp, #4]
 8003a68:	689b      	ldr	r3, [r3, #8]
 8003a6a:	9a01      	ldr	r2, [sp, #4]
 8003a6c:	6852      	ldr	r2, [r2, #4]
 8003a6e:	4610      	mov	r0, r2
 8003a70:	4798      	blx	r3
 8003a72:	9003      	str	r0, [sp, #12]
  }
  /*lint -restore*/

  return objp;
 8003a74:	9b03      	ldr	r3, [sp, #12]
}
 8003a76:	4618      	mov	r0, r3
 8003a78:	b005      	add	sp, #20
 8003a7a:	f85d fb04 	ldr.w	pc, [sp], #4
 8003a7e:	bf00      	nop

08003a80 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
 8003a80:	b500      	push	{lr}
 8003a82:	b085      	sub	sp, #20
 8003a84:	9001      	str	r0, [sp, #4]
  void *objp;

  chSysLock();
 8003a86:	f7ff ff93 	bl	80039b0 <chSysLock>
  objp = chPoolAllocI(mp);
 8003a8a:	9801      	ldr	r0, [sp, #4]
 8003a8c:	f7ff ffd8 	bl	8003a40 <chPoolAllocI>
 8003a90:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8003a92:	f7ff ff95 	bl	80039c0 <chSysUnlock>

  return objp;
 8003a96:	9b03      	ldr	r3, [sp, #12]
}
 8003a98:	4618      	mov	r0, r3
 8003a9a:	b005      	add	sp, #20
 8003a9c:	f85d fb04 	ldr.w	pc, [sp], #4

08003aa0 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 8003aa0:	b084      	sub	sp, #16
 8003aa2:	9001      	str	r0, [sp, #4]
 8003aa4:	9100      	str	r1, [sp, #0]
  struct pool_header *php = objp;
 8003aa6:	9b00      	ldr	r3, [sp, #0]
 8003aa8:	9303      	str	r3, [sp, #12]

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 8003aaa:	9b01      	ldr	r3, [sp, #4]
 8003aac:	681a      	ldr	r2, [r3, #0]
 8003aae:	9b03      	ldr	r3, [sp, #12]
 8003ab0:	601a      	str	r2, [r3, #0]
  mp->mp_next = php;
 8003ab2:	9b01      	ldr	r3, [sp, #4]
 8003ab4:	9a03      	ldr	r2, [sp, #12]
 8003ab6:	601a      	str	r2, [r3, #0]
}
 8003ab8:	b004      	add	sp, #16
 8003aba:	4770      	bx	lr
 8003abc:	f3af 8000 	nop.w

08003ac0 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
 8003ac0:	b500      	push	{lr}
 8003ac2:	b083      	sub	sp, #12
 8003ac4:	9001      	str	r0, [sp, #4]
 8003ac6:	9100      	str	r1, [sp, #0]

  chSysLock();
 8003ac8:	f7ff ff72 	bl	80039b0 <chSysLock>
  chPoolFreeI(mp, objp);
 8003acc:	9801      	ldr	r0, [sp, #4]
 8003ace:	9900      	ldr	r1, [sp, #0]
 8003ad0:	f7ff ffe6 	bl	8003aa0 <chPoolFreeI>
  chSysUnlock();
 8003ad4:	f7ff ff74 	bl	80039c0 <chSysUnlock>
}
 8003ad8:	b003      	add	sp, #12
 8003ada:	f85d fb04 	ldr.w	pc, [sp], #4
 8003ade:	bf00      	nop

08003ae0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003ae0:	b082      	sub	sp, #8
 8003ae2:	2320      	movs	r3, #32
 8003ae4:	9301      	str	r3, [sp, #4]
 8003ae6:	9b01      	ldr	r3, [sp, #4]
 8003ae8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003aec:	b002      	add	sp, #8
 8003aee:	4770      	bx	lr

08003af0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003af0:	b082      	sub	sp, #8
 8003af2:	2300      	movs	r3, #0
 8003af4:	9301      	str	r3, [sp, #4]
 8003af6:	9b01      	ldr	r3, [sp, #4]
 8003af8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003afc:	b002      	add	sp, #8
 8003afe:	4770      	bx	lr

08003b00 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8003b00:	b508      	push	{r3, lr}

  port_lock();
 8003b02:	f7ff ffed 	bl	8003ae0 <port_lock>
}
 8003b06:	bd08      	pop	{r3, pc}
 8003b08:	f3af 8000 	nop.w
 8003b0c:	f3af 8000 	nop.w

08003b10 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8003b10:	b508      	push	{r3, lr}

  port_unlock();
 8003b12:	f7ff ffed 	bl	8003af0 <port_unlock>
}
 8003b16:	bd08      	pop	{r3, pc}
 8003b18:	f3af 8000 	nop.w
 8003b1c:	f3af 8000 	nop.w

08003b20 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 8003b20:	b510      	push	{r4, lr}
 8003b22:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003b24:	f3ef 8309 	mrs	r3, PSP
 8003b28:	461c      	mov	r4, r3
  return(result);
 8003b2a:	4623      	mov	r3, r4
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
#endif

  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();
 8003b2c:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8003b2e:	9b01      	ldr	r3, [sp, #4]
 8003b30:	3320      	adds	r3, #32
 8003b32:	9301      	str	r3, [sp, #4]

  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);
 8003b34:	9b01      	ldr	r3, [sp, #4]
 8003b36:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8003b38:	9b00      	ldr	r3, [sp, #0]
 8003b3a:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 8003b3e:	f7ff ffe7 	bl	8003b10 <port_unlock_from_isr>
}
 8003b42:	b002      	add	sp, #8
 8003b44:	bd10      	pop	{r4, pc}
 8003b46:	bf00      	nop
 8003b48:	f3af 8000 	nop.w
 8003b4c:	f3af 8000 	nop.w

08003b50 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8003b50:	b510      	push	{r4, lr}
 8003b52:	b082      	sub	sp, #8

  port_lock_from_isr();
 8003b54:	f7ff ffd4 	bl	8003b00 <port_lock_from_isr>
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8003b58:	4b13      	ldr	r3, [pc, #76]	; (8003ba8 <_port_irq_epilogue+0x58>)
 8003b5a:	685b      	ldr	r3, [r3, #4]
 8003b5c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8003b60:	2b00      	cmp	r3, #0
 8003b62:	d01d      	beq.n	8003ba0 <_port_irq_epilogue+0x50>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003b64:	f3ef 8309 	mrs	r3, PSP
 8003b68:	461c      	mov	r4, r3
  return(result);
 8003b6a:	4623      	mov	r3, r4
      /* Enforcing a lazy FPU state save by accessing the FPCSR register.*/
      (void) __get_FPSCR();
#endif

    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 8003b6c:	9301      	str	r3, [sp, #4]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8003b6e:	9b01      	ldr	r3, [sp, #4]
 8003b70:	3b20      	subs	r3, #32
 8003b72:	9301      	str	r3, [sp, #4]

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8003b74:	9b01      	ldr	r3, [sp, #4]
 8003b76:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8003b7a:	61da      	str	r2, [r3, #28]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
#endif

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 8003b7c:	9b01      	ldr	r3, [sp, #4]
 8003b7e:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8003b80:	9b00      	ldr	r3, [sp, #0]
 8003b82:	f383 8809 	msr	PSP, r3

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8003b86:	f7fd f90b 	bl	8000da0 <chSchIsPreemptionRequired>
 8003b8a:	4603      	mov	r3, r0
 8003b8c:	2b00      	cmp	r3, #0
 8003b8e:	d003      	beq.n	8003b98 <_port_irq_epilogue+0x48>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8003b90:	9b01      	ldr	r3, [sp, #4]
 8003b92:	4a06      	ldr	r2, [pc, #24]	; (8003bac <_port_irq_epilogue+0x5c>)
 8003b94:	619a      	str	r2, [r3, #24]
      ctxp->pc = (regarm_t)_port_exit_from_isr;
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
 8003b96:	e005      	b.n	8003ba4 <_port_irq_epilogue+0x54>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8003b98:	9b01      	ldr	r3, [sp, #4]
 8003b9a:	4a05      	ldr	r2, [pc, #20]	; (8003bb0 <_port_irq_epilogue+0x60>)
 8003b9c:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
 8003b9e:	e001      	b.n	8003ba4 <_port_irq_epilogue+0x54>
  }
  port_unlock_from_isr();
 8003ba0:	f7ff ffb6 	bl	8003b10 <port_unlock_from_isr>
}
 8003ba4:	b002      	add	sp, #8
 8003ba6:	bd10      	pop	{r4, pc}
 8003ba8:	e000ed00 	.word	0xe000ed00
 8003bac:	08000301 	.word	0x08000301
 8003bb0:	08000304 	.word	0x08000304
 8003bb4:	f3af 8000 	nop.w
 8003bb8:	f3af 8000 	nop.w
 8003bbc:	f3af 8000 	nop.w

08003bc0 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 8003bc0:	4770      	bx	lr
 8003bc2:	bf00      	nop
 8003bc4:	f3af 8000 	nop.w
 8003bc8:	f3af 8000 	nop.w
 8003bcc:	f3af 8000 	nop.w

08003bd0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8003bd0:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8003bd2:	f7ff fff5 	bl	8003bc0 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 8003bd6:	f003 fc63 	bl	80074a0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 8003bda:	4809      	ldr	r0, [pc, #36]	; (8003c00 <halInit+0x30>)
 8003bdc:	f004 fa28 	bl	8008030 <_pal_lld_init>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 8003be0:	f002 fade 	bl	80061a0 <sdInit>
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
 8003be4:	f001 ff44 	bl	8005a70 <sdcInit>
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
 8003be8:	f002 fc32 	bl	8006450 <spiInit>
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
#endif
#if (HAL_USE_USB == TRUE) || defined(__DOXYGEN__)
  usbInit();
 8003bec:	f003 f820 	bl	8006c30 <usbInit>
#endif
#if (HAL_USE_SERIAL_USB == TRUE) || defined(__DOXYGEN__)
  sduInit();
#endif
#if (HAL_USE_RTC == TRUE) || defined(__DOXYGEN__)
  rtcInit();
 8003bf0:	f001 fa36 	bl	8005060 <rtcInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8003bf4:	f007 ffdc 	bl	800bbb0 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8003bf8:	f000 f832 	bl	8003c60 <stInit>
#endif
}
 8003bfc:	bd08      	pop	{r3, pc}
 8003bfe:	bf00      	nop
 8003c00:	08017a00 	.word	0x08017a00
 8003c04:	f3af 8000 	nop.w
 8003c08:	f3af 8000 	nop.w
 8003c0c:	f3af 8000 	nop.w

08003c10 <st_lld_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
 8003c10:	b082      	sub	sp, #8
 8003c12:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003c14:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003c18:	9a01      	ldr	r2, [sp, #4]
 8003c1a:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8003c1c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003c20:	2200      	movs	r2, #0
 8003c22:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8003c24:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003c28:	2202      	movs	r2, #2
 8003c2a:	60da      	str	r2, [r3, #12]
}
 8003c2c:	b002      	add	sp, #8
 8003c2e:	4770      	bx	lr

08003c30 <st_lld_stop_alarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8003c30:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003c34:	2200      	movs	r2, #0
 8003c36:	60da      	str	r2, [r3, #12]
}
 8003c38:	4770      	bx	lr
 8003c3a:	bf00      	nop
 8003c3c:	f3af 8000 	nop.w

08003c40 <st_lld_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
 8003c40:	b082      	sub	sp, #8
 8003c42:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003c44:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003c48:	9a01      	ldr	r2, [sp, #4]
 8003c4a:	635a      	str	r2, [r3, #52]	; 0x34
}
 8003c4c:	b002      	add	sp, #8
 8003c4e:	4770      	bx	lr

08003c50 <st_lld_get_alarm>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_alarm(void) {

  return (systime_t)STM32_ST_TIM->CCR[0];
 8003c50:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003c54:	6b5b      	ldr	r3, [r3, #52]	; 0x34
}
 8003c56:	4618      	mov	r0, r3
 8003c58:	4770      	bx	lr
 8003c5a:	bf00      	nop
 8003c5c:	f3af 8000 	nop.w

08003c60 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8003c60:	b508      	push	{r3, lr}

  st_lld_init();
 8003c62:	f004 f99d 	bl	8007fa0 <st_lld_init>
}
 8003c66:	bd08      	pop	{r3, pc}
 8003c68:	f3af 8000 	nop.w
 8003c6c:	f3af 8000 	nop.w

08003c70 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 8003c70:	b500      	push	{lr}
 8003c72:	b083      	sub	sp, #12
 8003c74:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
 8003c76:	9801      	ldr	r0, [sp, #4]
 8003c78:	f7ff ffca 	bl	8003c10 <st_lld_start_alarm>
}
 8003c7c:	b003      	add	sp, #12
 8003c7e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003c82:	bf00      	nop
 8003c84:	f3af 8000 	nop.w
 8003c88:	f3af 8000 	nop.w
 8003c8c:	f3af 8000 	nop.w

08003c90 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8003c90:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 8003c92:	f7ff ffcd 	bl	8003c30 <st_lld_stop_alarm>
}
 8003c96:	bd08      	pop	{r3, pc}
 8003c98:	f3af 8000 	nop.w
 8003c9c:	f3af 8000 	nop.w

08003ca0 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8003ca0:	b500      	push	{lr}
 8003ca2:	b083      	sub	sp, #12
 8003ca4:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
 8003ca6:	9801      	ldr	r0, [sp, #4]
 8003ca8:	f7ff ffca 	bl	8003c40 <st_lld_set_alarm>
}
 8003cac:	b003      	add	sp, #12
 8003cae:	f85d fb04 	ldr.w	pc, [sp], #4
 8003cb2:	bf00      	nop
 8003cb4:	f3af 8000 	nop.w
 8003cb8:	f3af 8000 	nop.w
 8003cbc:	f3af 8000 	nop.w

08003cc0 <stGetAlarm>:
 *
 * @return              The currently set alarm time.
 *
 * @api
 */
systime_t stGetAlarm(void) {
 8003cc0:	b508      	push	{r3, lr}

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  return st_lld_get_alarm();
 8003cc2:	f7ff ffc5 	bl	8003c50 <st_lld_get_alarm>
 8003cc6:	4603      	mov	r3, r0
}
 8003cc8:	4618      	mov	r0, r3
 8003cca:	bd08      	pop	{r3, pc}
 8003ccc:	f3af 8000 	nop.w

08003cd0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003cd0:	b082      	sub	sp, #8
 8003cd2:	2320      	movs	r3, #32
 8003cd4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003cd6:	9b01      	ldr	r3, [sp, #4]
 8003cd8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003cdc:	b002      	add	sp, #8
 8003cde:	4770      	bx	lr

08003ce0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003ce0:	b082      	sub	sp, #8
 8003ce2:	2300      	movs	r3, #0
 8003ce4:	9301      	str	r3, [sp, #4]
 8003ce6:	9b01      	ldr	r3, [sp, #4]
 8003ce8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003cec:	b002      	add	sp, #8
 8003cee:	4770      	bx	lr

08003cf0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8003cf0:	b082      	sub	sp, #8
 8003cf2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8003cf4:	9b01      	ldr	r3, [sp, #4]
 8003cf6:	9a01      	ldr	r2, [sp, #4]
 8003cf8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8003cfa:	9b01      	ldr	r3, [sp, #4]
 8003cfc:	9a01      	ldr	r2, [sp, #4]
 8003cfe:	605a      	str	r2, [r3, #4]
}
 8003d00:	b002      	add	sp, #8
 8003d02:	4770      	bx	lr
 8003d04:	f3af 8000 	nop.w
 8003d08:	f3af 8000 	nop.w
 8003d0c:	f3af 8000 	nop.w

08003d10 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8003d10:	b508      	push	{r3, lr}

  port_lock();
 8003d12:	f7ff ffdd 	bl	8003cd0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8003d16:	bd08      	pop	{r3, pc}
 8003d18:	f3af 8000 	nop.w
 8003d1c:	f3af 8000 	nop.w

08003d20 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8003d20:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8003d22:	f7ff ffdd 	bl	8003ce0 <port_unlock>
}
 8003d26:	bd08      	pop	{r3, pc}
 8003d28:	f3af 8000 	nop.w
 8003d2c:	f3af 8000 	nop.w

08003d30 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 8003d30:	4b01      	ldr	r3, [pc, #4]	; (8003d38 <chVTGetSystemTimeX+0x8>)
 8003d32:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8003d34:	4618      	mov	r0, r3
 8003d36:	4770      	bx	lr
 8003d38:	200016e0 	.word	0x200016e0
 8003d3c:	f3af 8000 	nop.w

08003d40 <chThdQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8003d40:	b500      	push	{lr}
 8003d42:	b083      	sub	sp, #12
 8003d44:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 8003d46:	9801      	ldr	r0, [sp, #4]
 8003d48:	f7ff ffd2 	bl	8003cf0 <queue_init>
}
 8003d4c:	b003      	add	sp, #12
 8003d4e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003d52:	bf00      	nop
 8003d54:	f3af 8000 	nop.w
 8003d58:	f3af 8000 	nop.w
 8003d5c:	f3af 8000 	nop.w

08003d60 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8003d60:	b508      	push	{r3, lr}

  chSysLock();
 8003d62:	f7ff ffd5 	bl	8003d10 <chSysLock>
}
 8003d66:	bd08      	pop	{r3, pc}
 8003d68:	f3af 8000 	nop.w
 8003d6c:	f3af 8000 	nop.w

08003d70 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8003d70:	b508      	push	{r3, lr}

  chSysUnlock();
 8003d72:	f7ff ffd5 	bl	8003d20 <chSysUnlock>
}
 8003d76:	bd08      	pop	{r3, pc}
 8003d78:	f3af 8000 	nop.w
 8003d7c:	f3af 8000 	nop.w

08003d80 <osalOsGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t osalOsGetSystemTimeX(void) {
 8003d80:	b508      	push	{r3, lr}

  return chVTGetSystemTimeX();
 8003d82:	f7ff ffd5 	bl	8003d30 <chVTGetSystemTimeX>
 8003d86:	4603      	mov	r3, r0
}
 8003d88:	4618      	mov	r0, r3
 8003d8a:	bd08      	pop	{r3, pc}
 8003d8c:	f3af 8000 	nop.w

08003d90 <osalThreadQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 8003d90:	b500      	push	{lr}
 8003d92:	b083      	sub	sp, #12
 8003d94:	9001      	str	r0, [sp, #4]

  chThdQueueObjectInit(tqp);
 8003d96:	9801      	ldr	r0, [sp, #4]
 8003d98:	f7ff ffd2 	bl	8003d40 <chThdQueueObjectInit>
}
 8003d9c:	b003      	add	sp, #12
 8003d9e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003da2:	bf00      	nop
 8003da4:	f3af 8000 	nop.w
 8003da8:	f3af 8000 	nop.w
 8003dac:	f3af 8000 	nop.w

08003db0 <osalThreadEnqueueTimeoutS>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
 8003db0:	b500      	push	{lr}
 8003db2:	b083      	sub	sp, #12
 8003db4:	9001      	str	r0, [sp, #4]
 8003db6:	9100      	str	r1, [sp, #0]

  return chThdEnqueueTimeoutS(tqp, time);
 8003db8:	9801      	ldr	r0, [sp, #4]
 8003dba:	9900      	ldr	r1, [sp, #0]
 8003dbc:	f7fd fbc0 	bl	8001540 <chThdEnqueueTimeoutS>
 8003dc0:	4603      	mov	r3, r0
}
 8003dc2:	4618      	mov	r0, r3
 8003dc4:	b003      	add	sp, #12
 8003dc6:	f85d fb04 	ldr.w	pc, [sp], #4
 8003dca:	bf00      	nop
 8003dcc:	f3af 8000 	nop.w

08003dd0 <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8003dd0:	b500      	push	{lr}
 8003dd2:	b083      	sub	sp, #12
 8003dd4:	9001      	str	r0, [sp, #4]
 8003dd6:	9100      	str	r1, [sp, #0]

  chThdDequeueNextI(tqp, msg);
 8003dd8:	9801      	ldr	r0, [sp, #4]
 8003dda:	9900      	ldr	r1, [sp, #0]
 8003ddc:	f7fd fbd0 	bl	8001580 <chThdDequeueNextI>
}
 8003de0:	b003      	add	sp, #12
 8003de2:	f85d fb04 	ldr.w	pc, [sp], #4
 8003de6:	bf00      	nop
 8003de8:	f3af 8000 	nop.w
 8003dec:	f3af 8000 	nop.w

08003df0 <osalThreadDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8003df0:	b500      	push	{lr}
 8003df2:	b083      	sub	sp, #12
 8003df4:	9001      	str	r0, [sp, #4]
 8003df6:	9100      	str	r1, [sp, #0]

  chThdDequeueAllI(tqp, msg);
 8003df8:	9801      	ldr	r0, [sp, #4]
 8003dfa:	9900      	ldr	r1, [sp, #0]
 8003dfc:	f7fd fbd8 	bl	80015b0 <chThdDequeueAllI>
}
 8003e00:	b003      	add	sp, #12
 8003e02:	f85d fb04 	ldr.w	pc, [sp], #4
 8003e06:	bf00      	nop
 8003e08:	f3af 8000 	nop.w
 8003e0c:	f3af 8000 	nop.w

08003e10 <ibqObjectInit>:
 *
 * @init
 */
void ibqObjectInit(input_buffers_queue_t *ibqp, uint8_t *bp,
                   size_t size, size_t n,
                   bqnotify_t infy, void *link) {
 8003e10:	b500      	push	{lr}
 8003e12:	b085      	sub	sp, #20
 8003e14:	9003      	str	r0, [sp, #12]
 8003e16:	9102      	str	r1, [sp, #8]
 8003e18:	9201      	str	r2, [sp, #4]
 8003e1a:	9300      	str	r3, [sp, #0]

  osalDbgCheck((ibqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&ibqp->waiting);
 8003e1c:	9b03      	ldr	r3, [sp, #12]
 8003e1e:	4618      	mov	r0, r3
 8003e20:	f7ff ffb6 	bl	8003d90 <osalThreadQueueObjectInit>
  ibqp->bcounter = 0;
 8003e24:	9b03      	ldr	r3, [sp, #12]
 8003e26:	2200      	movs	r2, #0
 8003e28:	609a      	str	r2, [r3, #8]
  ibqp->brdptr   = bp;
 8003e2a:	9b03      	ldr	r3, [sp, #12]
 8003e2c:	9a02      	ldr	r2, [sp, #8]
 8003e2e:	611a      	str	r2, [r3, #16]
  ibqp->bwrptr   = bp;
 8003e30:	9b03      	ldr	r3, [sp, #12]
 8003e32:	9a02      	ldr	r2, [sp, #8]
 8003e34:	60da      	str	r2, [r3, #12]
  ibqp->btop     = bp + ((size + sizeof (size_t)) * n);
 8003e36:	9b01      	ldr	r3, [sp, #4]
 8003e38:	3304      	adds	r3, #4
 8003e3a:	9a00      	ldr	r2, [sp, #0]
 8003e3c:	fb02 f303 	mul.w	r3, r2, r3
 8003e40:	9a02      	ldr	r2, [sp, #8]
 8003e42:	441a      	add	r2, r3
 8003e44:	9b03      	ldr	r3, [sp, #12]
 8003e46:	615a      	str	r2, [r3, #20]
  ibqp->bsize    = size + sizeof (size_t);
 8003e48:	9b01      	ldr	r3, [sp, #4]
 8003e4a:	1d1a      	adds	r2, r3, #4
 8003e4c:	9b03      	ldr	r3, [sp, #12]
 8003e4e:	619a      	str	r2, [r3, #24]
  ibqp->bn       = n;
 8003e50:	9b03      	ldr	r3, [sp, #12]
 8003e52:	9a00      	ldr	r2, [sp, #0]
 8003e54:	61da      	str	r2, [r3, #28]
  ibqp->buffers  = bp;
 8003e56:	9b03      	ldr	r3, [sp, #12]
 8003e58:	9a02      	ldr	r2, [sp, #8]
 8003e5a:	621a      	str	r2, [r3, #32]
  ibqp->ptr      = NULL;
 8003e5c:	9b03      	ldr	r3, [sp, #12]
 8003e5e:	2200      	movs	r2, #0
 8003e60:	625a      	str	r2, [r3, #36]	; 0x24
  ibqp->top      = NULL;
 8003e62:	9b03      	ldr	r3, [sp, #12]
 8003e64:	2200      	movs	r2, #0
 8003e66:	629a      	str	r2, [r3, #40]	; 0x28
  ibqp->notify   = infy;
 8003e68:	9b03      	ldr	r3, [sp, #12]
 8003e6a:	9a06      	ldr	r2, [sp, #24]
 8003e6c:	62da      	str	r2, [r3, #44]	; 0x2c
  ibqp->link     = link;
 8003e6e:	9b03      	ldr	r3, [sp, #12]
 8003e70:	9a07      	ldr	r2, [sp, #28]
 8003e72:	631a      	str	r2, [r3, #48]	; 0x30
}
 8003e74:	b005      	add	sp, #20
 8003e76:	f85d fb04 	ldr.w	pc, [sp], #4
 8003e7a:	bf00      	nop
 8003e7c:	f3af 8000 	nop.w

08003e80 <ibqResetI>:
 *
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 *
 * @iclass
 */
void ibqResetI(input_buffers_queue_t *ibqp) {
 8003e80:	b500      	push	{lr}
 8003e82:	b083      	sub	sp, #12
 8003e84:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  ibqp->bcounter = 0;
 8003e86:	9b01      	ldr	r3, [sp, #4]
 8003e88:	2200      	movs	r2, #0
 8003e8a:	609a      	str	r2, [r3, #8]
  ibqp->brdptr   = ibqp->buffers;
 8003e8c:	9b01      	ldr	r3, [sp, #4]
 8003e8e:	6a1a      	ldr	r2, [r3, #32]
 8003e90:	9b01      	ldr	r3, [sp, #4]
 8003e92:	611a      	str	r2, [r3, #16]
  ibqp->bwrptr   = ibqp->buffers;
 8003e94:	9b01      	ldr	r3, [sp, #4]
 8003e96:	6a1a      	ldr	r2, [r3, #32]
 8003e98:	9b01      	ldr	r3, [sp, #4]
 8003e9a:	60da      	str	r2, [r3, #12]
  ibqp->ptr      = NULL;
 8003e9c:	9b01      	ldr	r3, [sp, #4]
 8003e9e:	2200      	movs	r2, #0
 8003ea0:	625a      	str	r2, [r3, #36]	; 0x24
  ibqp->top      = NULL;
 8003ea2:	9b01      	ldr	r3, [sp, #4]
 8003ea4:	2200      	movs	r2, #0
 8003ea6:	629a      	str	r2, [r3, #40]	; 0x28
  osalThreadDequeueAllI(&ibqp->waiting, MSG_RESET);
 8003ea8:	9b01      	ldr	r3, [sp, #4]
 8003eaa:	4618      	mov	r0, r3
 8003eac:	f06f 0101 	mvn.w	r1, #1
 8003eb0:	f7ff ff9e 	bl	8003df0 <osalThreadDequeueAllI>
}
 8003eb4:	b003      	add	sp, #12
 8003eb6:	f85d fb04 	ldr.w	pc, [sp], #4
 8003eba:	bf00      	nop
 8003ebc:	f3af 8000 	nop.w

08003ec0 <ibqGetEmptyBufferI>:
 * @return              A pointer to the next buffer to be filled.
 * @retval NULL         if the queue is full.
 *
 * @iclass
 */
uint8_t *ibqGetEmptyBufferI(input_buffers_queue_t *ibqp) {
 8003ec0:	b082      	sub	sp, #8
 8003ec2:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  if (ibqIsFullI(ibqp)) {
 8003ec4:	9b01      	ldr	r3, [sp, #4]
 8003ec6:	68da      	ldr	r2, [r3, #12]
 8003ec8:	9b01      	ldr	r3, [sp, #4]
 8003eca:	691b      	ldr	r3, [r3, #16]
 8003ecc:	429a      	cmp	r2, r3
 8003ece:	d105      	bne.n	8003edc <ibqGetEmptyBufferI+0x1c>
 8003ed0:	9b01      	ldr	r3, [sp, #4]
 8003ed2:	689b      	ldr	r3, [r3, #8]
 8003ed4:	2b00      	cmp	r3, #0
 8003ed6:	d001      	beq.n	8003edc <ibqGetEmptyBufferI+0x1c>
 8003ed8:	2301      	movs	r3, #1
 8003eda:	e000      	b.n	8003ede <ibqGetEmptyBufferI+0x1e>
 8003edc:	2300      	movs	r3, #0
 8003ede:	f003 0301 	and.w	r3, r3, #1
 8003ee2:	b2db      	uxtb	r3, r3
 8003ee4:	2b00      	cmp	r3, #0
 8003ee6:	d001      	beq.n	8003eec <ibqGetEmptyBufferI+0x2c>
    return NULL;
 8003ee8:	2300      	movs	r3, #0
 8003eea:	e002      	b.n	8003ef2 <ibqGetEmptyBufferI+0x32>
  }

  return ibqp->bwrptr + sizeof (size_t);
 8003eec:	9b01      	ldr	r3, [sp, #4]
 8003eee:	68db      	ldr	r3, [r3, #12]
 8003ef0:	3304      	adds	r3, #4
}
 8003ef2:	4618      	mov	r0, r3
 8003ef4:	b002      	add	sp, #8
 8003ef6:	4770      	bx	lr
 8003ef8:	f3af 8000 	nop.w
 8003efc:	f3af 8000 	nop.w

08003f00 <ibqPostFullBufferI>:
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @iclass
 */
void ibqPostFullBufferI(input_buffers_queue_t *ibqp, size_t size) {
 8003f00:	b500      	push	{lr}
 8003f02:	b083      	sub	sp, #12
 8003f04:	9001      	str	r0, [sp, #4]
 8003f06:	9100      	str	r1, [sp, #0]

  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;
 8003f08:	9b01      	ldr	r3, [sp, #4]
 8003f0a:	68db      	ldr	r3, [r3, #12]
 8003f0c:	9a00      	ldr	r2, [sp, #0]
 8003f0e:	601a      	str	r2, [r3, #0]

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
 8003f10:	9b01      	ldr	r3, [sp, #4]
 8003f12:	689b      	ldr	r3, [r3, #8]
 8003f14:	1c5a      	adds	r2, r3, #1
 8003f16:	9b01      	ldr	r3, [sp, #4]
 8003f18:	609a      	str	r2, [r3, #8]
  ibqp->bwrptr += ibqp->bsize;
 8003f1a:	9b01      	ldr	r3, [sp, #4]
 8003f1c:	68da      	ldr	r2, [r3, #12]
 8003f1e:	9b01      	ldr	r3, [sp, #4]
 8003f20:	699b      	ldr	r3, [r3, #24]
 8003f22:	441a      	add	r2, r3
 8003f24:	9b01      	ldr	r3, [sp, #4]
 8003f26:	60da      	str	r2, [r3, #12]
  if (ibqp->bwrptr >= ibqp->btop) {
 8003f28:	9b01      	ldr	r3, [sp, #4]
 8003f2a:	68da      	ldr	r2, [r3, #12]
 8003f2c:	9b01      	ldr	r3, [sp, #4]
 8003f2e:	695b      	ldr	r3, [r3, #20]
 8003f30:	429a      	cmp	r2, r3
 8003f32:	d303      	bcc.n	8003f3c <ibqPostFullBufferI+0x3c>
    ibqp->bwrptr = ibqp->buffers;
 8003f34:	9b01      	ldr	r3, [sp, #4]
 8003f36:	6a1a      	ldr	r2, [r3, #32]
 8003f38:	9b01      	ldr	r3, [sp, #4]
 8003f3a:	60da      	str	r2, [r3, #12]
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&ibqp->waiting, MSG_OK);
 8003f3c:	9b01      	ldr	r3, [sp, #4]
 8003f3e:	4618      	mov	r0, r3
 8003f40:	2100      	movs	r1, #0
 8003f42:	f7ff ff45 	bl	8003dd0 <osalThreadDequeueNextI>
}
 8003f46:	b003      	add	sp, #12
 8003f48:	f85d fb04 	ldr.w	pc, [sp], #4
 8003f4c:	f3af 8000 	nop.w

08003f50 <ibqGetFullBufferTimeout>:
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t ibqGetFullBufferTimeout(input_buffers_queue_t *ibqp,
                              systime_t timeout) {
 8003f50:	b500      	push	{lr}
 8003f52:	b085      	sub	sp, #20
 8003f54:	9001      	str	r0, [sp, #4]
 8003f56:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalSysLock();
 8003f58:	f7ff ff02 	bl	8003d60 <osalSysLock>
  msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8003f5c:	9801      	ldr	r0, [sp, #4]
 8003f5e:	9900      	ldr	r1, [sp, #0]
 8003f60:	f000 f80e 	bl	8003f80 <ibqGetFullBufferTimeoutS>
 8003f64:	9003      	str	r0, [sp, #12]
  osalSysUnlock();
 8003f66:	f7ff ff03 	bl	8003d70 <osalSysUnlock>

  return msg;
 8003f6a:	9b03      	ldr	r3, [sp, #12]
}
 8003f6c:	4618      	mov	r0, r3
 8003f6e:	b005      	add	sp, #20
 8003f70:	f85d fb04 	ldr.w	pc, [sp], #4
 8003f74:	f3af 8000 	nop.w
 8003f78:	f3af 8000 	nop.w
 8003f7c:	f3af 8000 	nop.w

08003f80 <ibqGetFullBufferTimeoutS>:
   * @retval MSG_RESET    if the queue has been reset.
   *
   * @sclass
   */
  msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp,
                                 systime_t timeout) {
 8003f80:	b500      	push	{lr}
 8003f82:	b085      	sub	sp, #20
 8003f84:	9001      	str	r0, [sp, #4]
 8003f86:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassS();

  while (ibqIsEmptyI(ibqp)) {
 8003f88:	e00a      	b.n	8003fa0 <ibqGetFullBufferTimeoutS+0x20>
    msg_t msg = osalThreadEnqueueTimeoutS(&ibqp->waiting, timeout);
 8003f8a:	9b01      	ldr	r3, [sp, #4]
 8003f8c:	4618      	mov	r0, r3
 8003f8e:	9900      	ldr	r1, [sp, #0]
 8003f90:	f7ff ff0e 	bl	8003db0 <osalThreadEnqueueTimeoutS>
 8003f94:	9003      	str	r0, [sp, #12]
    if (msg < MSG_OK) {
 8003f96:	9b03      	ldr	r3, [sp, #12]
 8003f98:	2b00      	cmp	r3, #0
 8003f9a:	da01      	bge.n	8003fa0 <ibqGetFullBufferTimeoutS+0x20>
       return msg;
 8003f9c:	9b03      	ldr	r3, [sp, #12]
 8003f9e:	e011      	b.n	8003fc4 <ibqGetFullBufferTimeoutS+0x44>
  msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp,
                                 systime_t timeout) {

  osalDbgCheckClassS();

  while (ibqIsEmptyI(ibqp)) {
 8003fa0:	9b01      	ldr	r3, [sp, #4]
 8003fa2:	689b      	ldr	r3, [r3, #8]
 8003fa4:	2b00      	cmp	r3, #0
 8003fa6:	d0f0      	beq.n	8003f8a <ibqGetFullBufferTimeoutS+0xa>
  }

  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");

  /* Setting up the "current" buffer and its boundary.*/
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8003fa8:	9b01      	ldr	r3, [sp, #4]
 8003faa:	691b      	ldr	r3, [r3, #16]
 8003fac:	1d1a      	adds	r2, r3, #4
 8003fae:	9b01      	ldr	r3, [sp, #4]
 8003fb0:	625a      	str	r2, [r3, #36]	; 0x24
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 8003fb2:	9b01      	ldr	r3, [sp, #4]
 8003fb4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8003fb6:	9b01      	ldr	r3, [sp, #4]
 8003fb8:	691b      	ldr	r3, [r3, #16]
 8003fba:	681b      	ldr	r3, [r3, #0]
 8003fbc:	441a      	add	r2, r3
 8003fbe:	9b01      	ldr	r3, [sp, #4]
 8003fc0:	629a      	str	r2, [r3, #40]	; 0x28

  return MSG_OK;
 8003fc2:	2300      	movs	r3, #0
}
 8003fc4:	4618      	mov	r0, r3
 8003fc6:	b005      	add	sp, #20
 8003fc8:	f85d fb04 	ldr.w	pc, [sp], #4
 8003fcc:	f3af 8000 	nop.w

08003fd0 <ibqReleaseEmptyBuffer>:
 *
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 *
 * @api
 */
void ibqReleaseEmptyBuffer(input_buffers_queue_t *ibqp) {
 8003fd0:	b500      	push	{lr}
 8003fd2:	b083      	sub	sp, #12
 8003fd4:	9001      	str	r0, [sp, #4]

  osalSysLock();
 8003fd6:	f7ff fec3 	bl	8003d60 <osalSysLock>
  ibqReleaseEmptyBufferS(ibqp);
 8003fda:	9801      	ldr	r0, [sp, #4]
 8003fdc:	f000 f808 	bl	8003ff0 <ibqReleaseEmptyBufferS>
  osalSysUnlock();
 8003fe0:	f7ff fec6 	bl	8003d70 <osalSysUnlock>
}
 8003fe4:	b003      	add	sp, #12
 8003fe6:	f85d fb04 	ldr.w	pc, [sp], #4
 8003fea:	bf00      	nop
 8003fec:	f3af 8000 	nop.w

08003ff0 <ibqReleaseEmptyBufferS>:
   *
   * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
   *
   * @sclass
   */
  void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {
 8003ff0:	b500      	push	{lr}
 8003ff2:	b083      	sub	sp, #12
 8003ff4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassS();
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
 8003ff6:	9b01      	ldr	r3, [sp, #4]
 8003ff8:	689b      	ldr	r3, [r3, #8]
 8003ffa:	1e5a      	subs	r2, r3, #1
 8003ffc:	9b01      	ldr	r3, [sp, #4]
 8003ffe:	609a      	str	r2, [r3, #8]
  ibqp->brdptr += ibqp->bsize;
 8004000:	9b01      	ldr	r3, [sp, #4]
 8004002:	691a      	ldr	r2, [r3, #16]
 8004004:	9b01      	ldr	r3, [sp, #4]
 8004006:	699b      	ldr	r3, [r3, #24]
 8004008:	441a      	add	r2, r3
 800400a:	9b01      	ldr	r3, [sp, #4]
 800400c:	611a      	str	r2, [r3, #16]
  if (ibqp->brdptr >= ibqp->btop) {
 800400e:	9b01      	ldr	r3, [sp, #4]
 8004010:	691a      	ldr	r2, [r3, #16]
 8004012:	9b01      	ldr	r3, [sp, #4]
 8004014:	695b      	ldr	r3, [r3, #20]
 8004016:	429a      	cmp	r2, r3
 8004018:	d303      	bcc.n	8004022 <ibqReleaseEmptyBufferS+0x32>
    ibqp->brdptr = ibqp->buffers;
 800401a:	9b01      	ldr	r3, [sp, #4]
 800401c:	6a1a      	ldr	r2, [r3, #32]
 800401e:	9b01      	ldr	r3, [sp, #4]
 8004020:	611a      	str	r2, [r3, #16]
  }

  /* No "current" buffer.*/
  ibqp->ptr = NULL;
 8004022:	9b01      	ldr	r3, [sp, #4]
 8004024:	2200      	movs	r2, #0
 8004026:	625a      	str	r2, [r3, #36]	; 0x24

  /* Notifying the buffer release.*/
  if (ibqp->notify != NULL) {
 8004028:	9b01      	ldr	r3, [sp, #4]
 800402a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800402c:	2b00      	cmp	r3, #0
 800402e:	d003      	beq.n	8004038 <ibqReleaseEmptyBufferS+0x48>
    ibqp->notify(ibqp);
 8004030:	9b01      	ldr	r3, [sp, #4]
 8004032:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004034:	9801      	ldr	r0, [sp, #4]
 8004036:	4798      	blx	r3
  }
}
 8004038:	b003      	add	sp, #12
 800403a:	f85d fb04 	ldr.w	pc, [sp], #4
 800403e:	bf00      	nop

08004040 <ibqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, systime_t timeout) {
 8004040:	b500      	push	{lr}
 8004042:	b085      	sub	sp, #20
 8004044:	9001      	str	r0, [sp, #4]
 8004046:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalSysLock();
 8004048:	f7ff fe8a 	bl	8003d60 <osalSysLock>

  /* This condition indicates that a new buffer must be acquired.*/
  if (ibqp->ptr == NULL) {
 800404c:	9b01      	ldr	r3, [sp, #4]
 800404e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004050:	2b00      	cmp	r3, #0
 8004052:	d10b      	bne.n	800406c <ibqGetTimeout+0x2c>
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8004054:	9801      	ldr	r0, [sp, #4]
 8004056:	9900      	ldr	r1, [sp, #0]
 8004058:	f7ff ff92 	bl	8003f80 <ibqGetFullBufferTimeoutS>
 800405c:	9003      	str	r0, [sp, #12]
    if (msg != MSG_OK) {
 800405e:	9b03      	ldr	r3, [sp, #12]
 8004060:	2b00      	cmp	r3, #0
 8004062:	d003      	beq.n	800406c <ibqGetTimeout+0x2c>
      osalSysUnlock();
 8004064:	f7ff fe84 	bl	8003d70 <osalSysUnlock>
      return msg;
 8004068:	9b03      	ldr	r3, [sp, #12]
 800406a:	e014      	b.n	8004096 <ibqGetTimeout+0x56>
    }
  }

  /* Next byte from the buffer.*/
  msg = (msg_t)*ibqp->ptr;
 800406c:	9b01      	ldr	r3, [sp, #4]
 800406e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004070:	781b      	ldrb	r3, [r3, #0]
 8004072:	9303      	str	r3, [sp, #12]
  ibqp->ptr++;
 8004074:	9b01      	ldr	r3, [sp, #4]
 8004076:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004078:	1c5a      	adds	r2, r3, #1
 800407a:	9b01      	ldr	r3, [sp, #4]
 800407c:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the current buffer has been fully read then it is returned as
     empty in the queue.*/
  if (ibqp->ptr >= ibqp->top) {
 800407e:	9b01      	ldr	r3, [sp, #4]
 8004080:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004082:	9b01      	ldr	r3, [sp, #4]
 8004084:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004086:	429a      	cmp	r2, r3
 8004088:	d302      	bcc.n	8004090 <ibqGetTimeout+0x50>
    ibqReleaseEmptyBufferS(ibqp);
 800408a:	9801      	ldr	r0, [sp, #4]
 800408c:	f7ff ffb0 	bl	8003ff0 <ibqReleaseEmptyBufferS>
  }

  osalSysUnlock();
 8004090:	f7ff fe6e 	bl	8003d70 <osalSysUnlock>
  return msg;
 8004094:	9b03      	ldr	r3, [sp, #12]
}
 8004096:	4618      	mov	r0, r3
 8004098:	b005      	add	sp, #20
 800409a:	f85d fb04 	ldr.w	pc, [sp], #4
 800409e:	bf00      	nop

080040a0 <ibqReadTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
                      size_t n, systime_t timeout) {
 80040a0:	b500      	push	{lr}
 80040a2:	b08b      	sub	sp, #44	; 0x2c
 80040a4:	9003      	str	r0, [sp, #12]
 80040a6:	9102      	str	r1, [sp, #8]
 80040a8:	9201      	str	r2, [sp, #4]
 80040aa:	9300      	str	r3, [sp, #0]
  size_t r = 0;
 80040ac:	2300      	movs	r3, #0
 80040ae:	9309      	str	r3, [sp, #36]	; 0x24
  systime_t deadline;

  osalSysLock();
 80040b0:	f7ff fe56 	bl	8003d60 <osalSysLock>

  /* Time window for the whole operation.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 80040b4:	f7ff fe64 	bl	8003d80 <osalOsGetSystemTimeX>
 80040b8:	4602      	mov	r2, r0
 80040ba:	9b00      	ldr	r3, [sp, #0]
 80040bc:	4413      	add	r3, r2
 80040be:	9306      	str	r3, [sp, #24]

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (ibqp->ptr == NULL) {
 80040c0:	9b03      	ldr	r3, [sp, #12]
 80040c2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80040c4:	2b00      	cmp	r3, #0
 80040c6:	d126      	bne.n	8004116 <ibqReadTimeout+0x76>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80040c8:	9b00      	ldr	r3, [sp, #0]
 80040ca:	f1b3 3fff 	cmp.w	r3, #4294967295
 80040ce:	d002      	beq.n	80040d6 <ibqReadTimeout+0x36>
 80040d0:	9b00      	ldr	r3, [sp, #0]
 80040d2:	2b00      	cmp	r3, #0
 80040d4:	d105      	bne.n	80040e2 <ibqReadTimeout+0x42>
        msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 80040d6:	9803      	ldr	r0, [sp, #12]
 80040d8:	9900      	ldr	r1, [sp, #0]
 80040da:	f7ff ff51 	bl	8003f80 <ibqGetFullBufferTimeoutS>
 80040de:	9007      	str	r0, [sp, #28]
 80040e0:	e012      	b.n	8004108 <ibqReadTimeout+0x68>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 80040e2:	f7ff fe4d 	bl	8003d80 <osalOsGetSystemTimeX>
 80040e6:	4603      	mov	r3, r0
 80040e8:	9a06      	ldr	r2, [sp, #24]
 80040ea:	1ad3      	subs	r3, r2, r3
 80040ec:	9305      	str	r3, [sp, #20]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 80040ee:	9a05      	ldr	r2, [sp, #20]
 80040f0:	9b00      	ldr	r3, [sp, #0]
 80040f2:	429a      	cmp	r2, r3
 80040f4:	d903      	bls.n	80040fe <ibqReadTimeout+0x5e>
          osalSysUnlock();
 80040f6:	f7ff fe3b 	bl	8003d70 <osalSysUnlock>
          return r;
 80040fa:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80040fc:	e05c      	b.n	80041b8 <ibqReadTimeout+0x118>
        }
        msg = ibqGetFullBufferTimeoutS(ibqp, next_timeout);
 80040fe:	9803      	ldr	r0, [sp, #12]
 8004100:	9905      	ldr	r1, [sp, #20]
 8004102:	f7ff ff3d 	bl	8003f80 <ibqGetFullBufferTimeoutS>
 8004106:	9007      	str	r0, [sp, #28]
      }

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 8004108:	9b07      	ldr	r3, [sp, #28]
 800410a:	2b00      	cmp	r3, #0
 800410c:	d003      	beq.n	8004116 <ibqReadTimeout+0x76>
        osalSysUnlock();
 800410e:	f7ff fe2f 	bl	8003d70 <osalSysUnlock>
        return r;
 8004112:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004114:	e050      	b.n	80041b8 <ibqReadTimeout+0x118>
      }
    }

    /* Size of the data chunk present in the current buffer.*/
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8004116:	9b03      	ldr	r3, [sp, #12]
 8004118:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800411a:	461a      	mov	r2, r3
 800411c:	9b03      	ldr	r3, [sp, #12]
 800411e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004120:	1ad3      	subs	r3, r2, r3
 8004122:	9308      	str	r3, [sp, #32]
    if (size > (n - r)) {
 8004124:	9a01      	ldr	r2, [sp, #4]
 8004126:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004128:	1ad2      	subs	r2, r2, r3
 800412a:	9b08      	ldr	r3, [sp, #32]
 800412c:	429a      	cmp	r2, r3
 800412e:	d203      	bcs.n	8004138 <ibqReadTimeout+0x98>
      size = n - r;
 8004130:	9a01      	ldr	r2, [sp, #4]
 8004132:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004134:	1ad3      	subs	r3, r2, r3
 8004136:	9308      	str	r3, [sp, #32]
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
 8004138:	9b08      	ldr	r3, [sp, #32]
 800413a:	2b40      	cmp	r3, #64	; 0x40
 800413c:	d913      	bls.n	8004166 <ibqReadTimeout+0xc6>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(bp, ibqp->ptr, 64U);
 800413e:	9b03      	ldr	r3, [sp, #12]
 8004140:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004142:	9802      	ldr	r0, [sp, #8]
 8004144:	4619      	mov	r1, r3
 8004146:	2240      	movs	r2, #64	; 0x40
 8004148:	f012 ff9a 	bl	8017080 <memcpy>
      bp        += 64U;
 800414c:	9b02      	ldr	r3, [sp, #8]
 800414e:	3340      	adds	r3, #64	; 0x40
 8004150:	9302      	str	r3, [sp, #8]
      ibqp->ptr += 64U;
 8004152:	9b03      	ldr	r3, [sp, #12]
 8004154:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004156:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800415a:	9b03      	ldr	r3, [sp, #12]
 800415c:	625a      	str	r2, [r3, #36]	; 0x24
      r         += 64U;
 800415e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004160:	3340      	adds	r3, #64	; 0x40
 8004162:	9309      	str	r3, [sp, #36]	; 0x24
 8004164:	e014      	b.n	8004190 <ibqReadTimeout+0xf0>
    }
    else {
      memcpy(bp, ibqp->ptr, size);
 8004166:	9b03      	ldr	r3, [sp, #12]
 8004168:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800416a:	9802      	ldr	r0, [sp, #8]
 800416c:	4619      	mov	r1, r3
 800416e:	9a08      	ldr	r2, [sp, #32]
 8004170:	f012 ff86 	bl	8017080 <memcpy>
      bp        += size;
 8004174:	9a02      	ldr	r2, [sp, #8]
 8004176:	9b08      	ldr	r3, [sp, #32]
 8004178:	4413      	add	r3, r2
 800417a:	9302      	str	r3, [sp, #8]
      ibqp->ptr += size;
 800417c:	9b03      	ldr	r3, [sp, #12]
 800417e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004180:	9b08      	ldr	r3, [sp, #32]
 8004182:	441a      	add	r2, r3
 8004184:	9b03      	ldr	r3, [sp, #12]
 8004186:	625a      	str	r2, [r3, #36]	; 0x24
      r         += size;
 8004188:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800418a:	9b08      	ldr	r3, [sp, #32]
 800418c:	4413      	add	r3, r2
 800418e:	9309      	str	r3, [sp, #36]	; 0x24
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 8004190:	9b03      	ldr	r3, [sp, #12]
 8004192:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004194:	9b03      	ldr	r3, [sp, #12]
 8004196:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004198:	429a      	cmp	r2, r3
 800419a:	d302      	bcc.n	80041a2 <ibqReadTimeout+0x102>
      ibqReleaseEmptyBufferS(ibqp);
 800419c:	9803      	ldr	r0, [sp, #12]
 800419e:	f7ff ff27 	bl	8003ff0 <ibqReleaseEmptyBufferS>
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
 80041a2:	f7ff fde5 	bl	8003d70 <osalSysUnlock>
    if (r >= n) {
 80041a6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80041a8:	9b01      	ldr	r3, [sp, #4]
 80041aa:	429a      	cmp	r2, r3
 80041ac:	d301      	bcc.n	80041b2 <ibqReadTimeout+0x112>
      return r;
 80041ae:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80041b0:	e002      	b.n	80041b8 <ibqReadTimeout+0x118>
    }
    osalSysLock();
 80041b2:	f7ff fdd5 	bl	8003d60 <osalSysLock>
  }
 80041b6:	e783      	b.n	80040c0 <ibqReadTimeout+0x20>
}
 80041b8:	4618      	mov	r0, r3
 80041ba:	b00b      	add	sp, #44	; 0x2c
 80041bc:	f85d fb04 	ldr.w	pc, [sp], #4

080041c0 <obqObjectInit>:
 *
 * @init
 */
void obqObjectInit(output_buffers_queue_t *obqp, uint8_t *bp,
                   size_t size, size_t n,
                   bqnotify_t onfy, void *link) {
 80041c0:	b500      	push	{lr}
 80041c2:	b085      	sub	sp, #20
 80041c4:	9003      	str	r0, [sp, #12]
 80041c6:	9102      	str	r1, [sp, #8]
 80041c8:	9201      	str	r2, [sp, #4]
 80041ca:	9300      	str	r3, [sp, #0]

  osalDbgCheck((obqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&obqp->waiting);
 80041cc:	9b03      	ldr	r3, [sp, #12]
 80041ce:	4618      	mov	r0, r3
 80041d0:	f7ff fdde 	bl	8003d90 <osalThreadQueueObjectInit>
  obqp->bcounter = n;
 80041d4:	9b03      	ldr	r3, [sp, #12]
 80041d6:	9a00      	ldr	r2, [sp, #0]
 80041d8:	609a      	str	r2, [r3, #8]
  obqp->brdptr   = bp;
 80041da:	9b03      	ldr	r3, [sp, #12]
 80041dc:	9a02      	ldr	r2, [sp, #8]
 80041de:	611a      	str	r2, [r3, #16]
  obqp->bwrptr   = bp;
 80041e0:	9b03      	ldr	r3, [sp, #12]
 80041e2:	9a02      	ldr	r2, [sp, #8]
 80041e4:	60da      	str	r2, [r3, #12]
  obqp->btop     = bp + ((size + sizeof (size_t)) * n);
 80041e6:	9b01      	ldr	r3, [sp, #4]
 80041e8:	3304      	adds	r3, #4
 80041ea:	9a00      	ldr	r2, [sp, #0]
 80041ec:	fb02 f303 	mul.w	r3, r2, r3
 80041f0:	9a02      	ldr	r2, [sp, #8]
 80041f2:	441a      	add	r2, r3
 80041f4:	9b03      	ldr	r3, [sp, #12]
 80041f6:	615a      	str	r2, [r3, #20]
  obqp->bsize    = size + sizeof (size_t);
 80041f8:	9b01      	ldr	r3, [sp, #4]
 80041fa:	1d1a      	adds	r2, r3, #4
 80041fc:	9b03      	ldr	r3, [sp, #12]
 80041fe:	619a      	str	r2, [r3, #24]
  obqp->bn       = n;
 8004200:	9b03      	ldr	r3, [sp, #12]
 8004202:	9a00      	ldr	r2, [sp, #0]
 8004204:	61da      	str	r2, [r3, #28]
  obqp->buffers  = bp;
 8004206:	9b03      	ldr	r3, [sp, #12]
 8004208:	9a02      	ldr	r2, [sp, #8]
 800420a:	621a      	str	r2, [r3, #32]
  obqp->ptr      = NULL;
 800420c:	9b03      	ldr	r3, [sp, #12]
 800420e:	2200      	movs	r2, #0
 8004210:	625a      	str	r2, [r3, #36]	; 0x24
  obqp->top      = NULL;
 8004212:	9b03      	ldr	r3, [sp, #12]
 8004214:	2200      	movs	r2, #0
 8004216:	629a      	str	r2, [r3, #40]	; 0x28
  obqp->notify   = onfy;
 8004218:	9b03      	ldr	r3, [sp, #12]
 800421a:	9a06      	ldr	r2, [sp, #24]
 800421c:	62da      	str	r2, [r3, #44]	; 0x2c
  obqp->link     = link;
 800421e:	9b03      	ldr	r3, [sp, #12]
 8004220:	9a07      	ldr	r2, [sp, #28]
 8004222:	631a      	str	r2, [r3, #48]	; 0x30
}
 8004224:	b005      	add	sp, #20
 8004226:	f85d fb04 	ldr.w	pc, [sp], #4
 800422a:	bf00      	nop
 800422c:	f3af 8000 	nop.w

08004230 <obqResetI>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @iclass
 */
void obqResetI(output_buffers_queue_t *obqp) {
 8004230:	b500      	push	{lr}
 8004232:	b083      	sub	sp, #12
 8004234:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  obqp->bcounter = bqSizeX(obqp);
 8004236:	9b01      	ldr	r3, [sp, #4]
 8004238:	69da      	ldr	r2, [r3, #28]
 800423a:	9b01      	ldr	r3, [sp, #4]
 800423c:	609a      	str	r2, [r3, #8]
  obqp->brdptr   = obqp->buffers;
 800423e:	9b01      	ldr	r3, [sp, #4]
 8004240:	6a1a      	ldr	r2, [r3, #32]
 8004242:	9b01      	ldr	r3, [sp, #4]
 8004244:	611a      	str	r2, [r3, #16]
  obqp->bwrptr   = obqp->buffers;
 8004246:	9b01      	ldr	r3, [sp, #4]
 8004248:	6a1a      	ldr	r2, [r3, #32]
 800424a:	9b01      	ldr	r3, [sp, #4]
 800424c:	60da      	str	r2, [r3, #12]
  obqp->ptr      = NULL;
 800424e:	9b01      	ldr	r3, [sp, #4]
 8004250:	2200      	movs	r2, #0
 8004252:	625a      	str	r2, [r3, #36]	; 0x24
  obqp->top      = NULL;
 8004254:	9b01      	ldr	r3, [sp, #4]
 8004256:	2200      	movs	r2, #0
 8004258:	629a      	str	r2, [r3, #40]	; 0x28
  osalThreadDequeueAllI(&obqp->waiting, MSG_RESET);
 800425a:	9b01      	ldr	r3, [sp, #4]
 800425c:	4618      	mov	r0, r3
 800425e:	f06f 0101 	mvn.w	r1, #1
 8004262:	f7ff fdc5 	bl	8003df0 <osalThreadDequeueAllI>
}
 8004266:	b003      	add	sp, #12
 8004268:	f85d fb04 	ldr.w	pc, [sp], #4
 800426c:	f3af 8000 	nop.w

08004270 <obqGetFullBufferI>:
 * @retval NULL         if the queue is empty.
 *
 * @iclass
 */
uint8_t *obqGetFullBufferI(output_buffers_queue_t *obqp,
                           size_t *sizep) {
 8004270:	b082      	sub	sp, #8
 8004272:	9001      	str	r0, [sp, #4]
 8004274:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassI();

  if (obqIsEmptyI(obqp)) {
 8004276:	9b01      	ldr	r3, [sp, #4]
 8004278:	68da      	ldr	r2, [r3, #12]
 800427a:	9b01      	ldr	r3, [sp, #4]
 800427c:	691b      	ldr	r3, [r3, #16]
 800427e:	429a      	cmp	r2, r3
 8004280:	d105      	bne.n	800428e <obqGetFullBufferI+0x1e>
 8004282:	9b01      	ldr	r3, [sp, #4]
 8004284:	689b      	ldr	r3, [r3, #8]
 8004286:	2b00      	cmp	r3, #0
 8004288:	d001      	beq.n	800428e <obqGetFullBufferI+0x1e>
 800428a:	2301      	movs	r3, #1
 800428c:	e000      	b.n	8004290 <obqGetFullBufferI+0x20>
 800428e:	2300      	movs	r3, #0
 8004290:	f003 0301 	and.w	r3, r3, #1
 8004294:	b2db      	uxtb	r3, r3
 8004296:	2b00      	cmp	r3, #0
 8004298:	d001      	beq.n	800429e <obqGetFullBufferI+0x2e>
    return NULL;
 800429a:	2300      	movs	r3, #0
 800429c:	e007      	b.n	80042ae <obqGetFullBufferI+0x3e>
  }

  /* Buffer size.*/
  *sizep = *((size_t *)obqp->brdptr);
 800429e:	9b01      	ldr	r3, [sp, #4]
 80042a0:	691b      	ldr	r3, [r3, #16]
 80042a2:	681a      	ldr	r2, [r3, #0]
 80042a4:	9b00      	ldr	r3, [sp, #0]
 80042a6:	601a      	str	r2, [r3, #0]

  return obqp->brdptr + sizeof (size_t);
 80042a8:	9b01      	ldr	r3, [sp, #4]
 80042aa:	691b      	ldr	r3, [r3, #16]
 80042ac:	3304      	adds	r3, #4
}
 80042ae:	4618      	mov	r0, r3
 80042b0:	b002      	add	sp, #8
 80042b2:	4770      	bx	lr
 80042b4:	f3af 8000 	nop.w
 80042b8:	f3af 8000 	nop.w
 80042bc:	f3af 8000 	nop.w

080042c0 <obqReleaseEmptyBufferI>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @iclass
 */
void obqReleaseEmptyBufferI(output_buffers_queue_t *obqp) {
 80042c0:	b500      	push	{lr}
 80042c2:	b083      	sub	sp, #12
 80042c4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
 80042c6:	9b01      	ldr	r3, [sp, #4]
 80042c8:	689b      	ldr	r3, [r3, #8]
 80042ca:	1c5a      	adds	r2, r3, #1
 80042cc:	9b01      	ldr	r3, [sp, #4]
 80042ce:	609a      	str	r2, [r3, #8]
  obqp->brdptr += obqp->bsize;
 80042d0:	9b01      	ldr	r3, [sp, #4]
 80042d2:	691a      	ldr	r2, [r3, #16]
 80042d4:	9b01      	ldr	r3, [sp, #4]
 80042d6:	699b      	ldr	r3, [r3, #24]
 80042d8:	441a      	add	r2, r3
 80042da:	9b01      	ldr	r3, [sp, #4]
 80042dc:	611a      	str	r2, [r3, #16]
  if (obqp->brdptr >= obqp->btop) {
 80042de:	9b01      	ldr	r3, [sp, #4]
 80042e0:	691a      	ldr	r2, [r3, #16]
 80042e2:	9b01      	ldr	r3, [sp, #4]
 80042e4:	695b      	ldr	r3, [r3, #20]
 80042e6:	429a      	cmp	r2, r3
 80042e8:	d303      	bcc.n	80042f2 <obqReleaseEmptyBufferI+0x32>
    obqp->brdptr = obqp->buffers;
 80042ea:	9b01      	ldr	r3, [sp, #4]
 80042ec:	6a1a      	ldr	r2, [r3, #32]
 80042ee:	9b01      	ldr	r3, [sp, #4]
 80042f0:	611a      	str	r2, [r3, #16]
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&obqp->waiting, MSG_OK);
 80042f2:	9b01      	ldr	r3, [sp, #4]
 80042f4:	4618      	mov	r0, r3
 80042f6:	2100      	movs	r1, #0
 80042f8:	f7ff fd6a 	bl	8003dd0 <osalThreadDequeueNextI>
}
 80042fc:	b003      	add	sp, #12
 80042fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8004302:	bf00      	nop
 8004304:	f3af 8000 	nop.w
 8004308:	f3af 8000 	nop.w
 800430c:	f3af 8000 	nop.w

08004310 <obqGetEmptyBufferTimeout>:
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t obqGetEmptyBufferTimeout(output_buffers_queue_t *obqp,
                                systime_t timeout) {
 8004310:	b500      	push	{lr}
 8004312:	b085      	sub	sp, #20
 8004314:	9001      	str	r0, [sp, #4]
 8004316:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalSysLock();
 8004318:	f7ff fd22 	bl	8003d60 <osalSysLock>
  msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 800431c:	9801      	ldr	r0, [sp, #4]
 800431e:	9900      	ldr	r1, [sp, #0]
 8004320:	f000 f80e 	bl	8004340 <obqGetEmptyBufferTimeoutS>
 8004324:	9003      	str	r0, [sp, #12]
  osalSysUnlock();
 8004326:	f7ff fd23 	bl	8003d70 <osalSysUnlock>

  return msg;
 800432a:	9b03      	ldr	r3, [sp, #12]
}
 800432c:	4618      	mov	r0, r3
 800432e:	b005      	add	sp, #20
 8004330:	f85d fb04 	ldr.w	pc, [sp], #4
 8004334:	f3af 8000 	nop.w
 8004338:	f3af 8000 	nop.w
 800433c:	f3af 8000 	nop.w

08004340 <obqGetEmptyBufferTimeoutS>:
   * @retval MSG_RESET    if the queue has been reset.
   *
   * @sclass
   */
  msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                  systime_t timeout) {
 8004340:	b500      	push	{lr}
 8004342:	b085      	sub	sp, #20
 8004344:	9001      	str	r0, [sp, #4]
 8004346:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassS();

  while (obqIsFullI(obqp)) {
 8004348:	e00a      	b.n	8004360 <obqGetEmptyBufferTimeoutS+0x20>
    msg_t msg = osalThreadEnqueueTimeoutS(&obqp->waiting, timeout);
 800434a:	9b01      	ldr	r3, [sp, #4]
 800434c:	4618      	mov	r0, r3
 800434e:	9900      	ldr	r1, [sp, #0]
 8004350:	f7ff fd2e 	bl	8003db0 <osalThreadEnqueueTimeoutS>
 8004354:	9003      	str	r0, [sp, #12]
    if (msg < MSG_OK) {
 8004356:	9b03      	ldr	r3, [sp, #12]
 8004358:	2b00      	cmp	r3, #0
 800435a:	da01      	bge.n	8004360 <obqGetEmptyBufferTimeoutS+0x20>
      return msg;
 800435c:	9b03      	ldr	r3, [sp, #12]
 800435e:	e010      	b.n	8004382 <obqGetEmptyBufferTimeoutS+0x42>
  msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                  systime_t timeout) {

  osalDbgCheckClassS();

  while (obqIsFullI(obqp)) {
 8004360:	9b01      	ldr	r3, [sp, #4]
 8004362:	689b      	ldr	r3, [r3, #8]
 8004364:	2b00      	cmp	r3, #0
 8004366:	d0f0      	beq.n	800434a <obqGetEmptyBufferTimeoutS+0xa>
  }

  osalDbgAssert(!obqIsFullI(obqp), "still full");

  /* Setting up the "current" buffer and its boundary.*/
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 8004368:	9b01      	ldr	r3, [sp, #4]
 800436a:	68db      	ldr	r3, [r3, #12]
 800436c:	1d1a      	adds	r2, r3, #4
 800436e:	9b01      	ldr	r3, [sp, #4]
 8004370:	625a      	str	r2, [r3, #36]	; 0x24
  obqp->top = obqp->bwrptr + obqp->bsize;
 8004372:	9b01      	ldr	r3, [sp, #4]
 8004374:	68da      	ldr	r2, [r3, #12]
 8004376:	9b01      	ldr	r3, [sp, #4]
 8004378:	699b      	ldr	r3, [r3, #24]
 800437a:	441a      	add	r2, r3
 800437c:	9b01      	ldr	r3, [sp, #4]
 800437e:	629a      	str	r2, [r3, #40]	; 0x28

  return MSG_OK;
 8004380:	2300      	movs	r3, #0
}
 8004382:	4618      	mov	r0, r3
 8004384:	b005      	add	sp, #20
 8004386:	f85d fb04 	ldr.w	pc, [sp], #4
 800438a:	bf00      	nop
 800438c:	f3af 8000 	nop.w

08004390 <obqPostFullBuffer>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @api
 */
void obqPostFullBuffer(output_buffers_queue_t *obqp, size_t size) {
 8004390:	b500      	push	{lr}
 8004392:	b083      	sub	sp, #12
 8004394:	9001      	str	r0, [sp, #4]
 8004396:	9100      	str	r1, [sp, #0]

  osalSysLock();
 8004398:	f7ff fce2 	bl	8003d60 <osalSysLock>
  obqPostFullBufferS(obqp, size);
 800439c:	9801      	ldr	r0, [sp, #4]
 800439e:	9900      	ldr	r1, [sp, #0]
 80043a0:	f000 f806 	bl	80043b0 <obqPostFullBufferS>
  osalSysUnlock();
 80043a4:	f7ff fce4 	bl	8003d70 <osalSysUnlock>
}
 80043a8:	b003      	add	sp, #12
 80043aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80043ae:	bf00      	nop

080043b0 <obqPostFullBufferS>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @sclass
 */
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {
 80043b0:	b500      	push	{lr}
 80043b2:	b083      	sub	sp, #12
 80043b4:	9001      	str	r0, [sp, #4]
 80043b6:	9100      	str	r1, [sp, #0]
  osalDbgCheckClassS();
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;
 80043b8:	9b01      	ldr	r3, [sp, #4]
 80043ba:	68db      	ldr	r3, [r3, #12]
 80043bc:	9a00      	ldr	r2, [sp, #0]
 80043be:	601a      	str	r2, [r3, #0]

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
 80043c0:	9b01      	ldr	r3, [sp, #4]
 80043c2:	689b      	ldr	r3, [r3, #8]
 80043c4:	1e5a      	subs	r2, r3, #1
 80043c6:	9b01      	ldr	r3, [sp, #4]
 80043c8:	609a      	str	r2, [r3, #8]
  obqp->bwrptr += obqp->bsize;
 80043ca:	9b01      	ldr	r3, [sp, #4]
 80043cc:	68da      	ldr	r2, [r3, #12]
 80043ce:	9b01      	ldr	r3, [sp, #4]
 80043d0:	699b      	ldr	r3, [r3, #24]
 80043d2:	441a      	add	r2, r3
 80043d4:	9b01      	ldr	r3, [sp, #4]
 80043d6:	60da      	str	r2, [r3, #12]
  if (obqp->bwrptr >= obqp->btop) {
 80043d8:	9b01      	ldr	r3, [sp, #4]
 80043da:	68da      	ldr	r2, [r3, #12]
 80043dc:	9b01      	ldr	r3, [sp, #4]
 80043de:	695b      	ldr	r3, [r3, #20]
 80043e0:	429a      	cmp	r2, r3
 80043e2:	d303      	bcc.n	80043ec <obqPostFullBufferS+0x3c>
    obqp->bwrptr = obqp->buffers;
 80043e4:	9b01      	ldr	r3, [sp, #4]
 80043e6:	6a1a      	ldr	r2, [r3, #32]
 80043e8:	9b01      	ldr	r3, [sp, #4]
 80043ea:	60da      	str	r2, [r3, #12]
  }

  /* No "current" buffer.*/
  obqp->ptr = NULL;
 80043ec:	9b01      	ldr	r3, [sp, #4]
 80043ee:	2200      	movs	r2, #0
 80043f0:	625a      	str	r2, [r3, #36]	; 0x24

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
 80043f2:	9b01      	ldr	r3, [sp, #4]
 80043f4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80043f6:	2b00      	cmp	r3, #0
 80043f8:	d003      	beq.n	8004402 <obqPostFullBufferS+0x52>
    obqp->notify(obqp);
 80043fa:	9b01      	ldr	r3, [sp, #4]
 80043fc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80043fe:	9801      	ldr	r0, [sp, #4]
 8004400:	4798      	blx	r3
  }
}
 8004402:	b003      	add	sp, #12
 8004404:	f85d fb04 	ldr.w	pc, [sp], #4
 8004408:	f3af 8000 	nop.w
 800440c:	f3af 8000 	nop.w

08004410 <obqPutTimeout>:
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t obqPutTimeout(output_buffers_queue_t *obqp, uint8_t b,
                    systime_t timeout) {
 8004410:	b500      	push	{lr}
 8004412:	b087      	sub	sp, #28
 8004414:	9003      	str	r0, [sp, #12]
 8004416:	460b      	mov	r3, r1
 8004418:	9201      	str	r2, [sp, #4]
 800441a:	f88d 300b 	strb.w	r3, [sp, #11]
  msg_t msg;

  osalSysLock();
 800441e:	f7ff fc9f 	bl	8003d60 <osalSysLock>

  /* This condition indicates that a new buffer must be acquired.*/
  if (obqp->ptr == NULL) {
 8004422:	9b03      	ldr	r3, [sp, #12]
 8004424:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004426:	2b00      	cmp	r3, #0
 8004428:	d10b      	bne.n	8004442 <obqPutTimeout+0x32>
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 800442a:	9803      	ldr	r0, [sp, #12]
 800442c:	9901      	ldr	r1, [sp, #4]
 800442e:	f7ff ff87 	bl	8004340 <obqGetEmptyBufferTimeoutS>
 8004432:	9005      	str	r0, [sp, #20]
    if (msg != MSG_OK) {
 8004434:	9b05      	ldr	r3, [sp, #20]
 8004436:	2b00      	cmp	r3, #0
 8004438:	d003      	beq.n	8004442 <obqPutTimeout+0x32>
      osalSysUnlock();
 800443a:	f7ff fc99 	bl	8003d70 <osalSysUnlock>
      return msg;
 800443e:	9b05      	ldr	r3, [sp, #20]
 8004440:	e019      	b.n	8004476 <obqPutTimeout+0x66>
    }
  }

  /* Writing the byte to the buffer.*/
  *obqp->ptr = b;
 8004442:	9b03      	ldr	r3, [sp, #12]
 8004444:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004446:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800444a:	701a      	strb	r2, [r3, #0]
  obqp->ptr++;
 800444c:	9b03      	ldr	r3, [sp, #12]
 800444e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004450:	1c5a      	adds	r2, r3, #1
 8004452:	9b03      	ldr	r3, [sp, #12]
 8004454:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
 8004456:	9b03      	ldr	r3, [sp, #12]
 8004458:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800445a:	9b03      	ldr	r3, [sp, #12]
 800445c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800445e:	429a      	cmp	r2, r3
 8004460:	d306      	bcc.n	8004470 <obqPutTimeout+0x60>
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8004462:	9b03      	ldr	r3, [sp, #12]
 8004464:	699b      	ldr	r3, [r3, #24]
 8004466:	3b04      	subs	r3, #4
 8004468:	9803      	ldr	r0, [sp, #12]
 800446a:	4619      	mov	r1, r3
 800446c:	f7ff ffa0 	bl	80043b0 <obqPostFullBufferS>
  }

  osalSysUnlock();
 8004470:	f7ff fc7e 	bl	8003d70 <osalSysUnlock>
  return MSG_OK;
 8004474:	2300      	movs	r3, #0
}
 8004476:	4618      	mov	r0, r3
 8004478:	b007      	add	sp, #28
 800447a:	f85d fb04 	ldr.w	pc, [sp], #4
 800447e:	bf00      	nop

08004480 <obqWriteTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
                       size_t n, systime_t timeout) {
 8004480:	b500      	push	{lr}
 8004482:	b08b      	sub	sp, #44	; 0x2c
 8004484:	9003      	str	r0, [sp, #12]
 8004486:	9102      	str	r1, [sp, #8]
 8004488:	9201      	str	r2, [sp, #4]
 800448a:	9300      	str	r3, [sp, #0]
  size_t w = 0;
 800448c:	2300      	movs	r3, #0
 800448e:	9309      	str	r3, [sp, #36]	; 0x24
  systime_t deadline;

  osalSysLock();
 8004490:	f7ff fc66 	bl	8003d60 <osalSysLock>

  /* Time window for the whole operation.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8004494:	f7ff fc74 	bl	8003d80 <osalOsGetSystemTimeX>
 8004498:	4602      	mov	r2, r0
 800449a:	9b00      	ldr	r3, [sp, #0]
 800449c:	4413      	add	r3, r2
 800449e:	9306      	str	r3, [sp, #24]

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (obqp->ptr == NULL) {
 80044a0:	9b03      	ldr	r3, [sp, #12]
 80044a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80044a4:	2b00      	cmp	r3, #0
 80044a6:	d126      	bne.n	80044f6 <obqWriteTimeout+0x76>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80044a8:	9b00      	ldr	r3, [sp, #0]
 80044aa:	f1b3 3fff 	cmp.w	r3, #4294967295
 80044ae:	d002      	beq.n	80044b6 <obqWriteTimeout+0x36>
 80044b0:	9b00      	ldr	r3, [sp, #0]
 80044b2:	2b00      	cmp	r3, #0
 80044b4:	d105      	bne.n	80044c2 <obqWriteTimeout+0x42>
        msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 80044b6:	9803      	ldr	r0, [sp, #12]
 80044b8:	9900      	ldr	r1, [sp, #0]
 80044ba:	f7ff ff41 	bl	8004340 <obqGetEmptyBufferTimeoutS>
 80044be:	9007      	str	r0, [sp, #28]
 80044c0:	e012      	b.n	80044e8 <obqWriteTimeout+0x68>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 80044c2:	f7ff fc5d 	bl	8003d80 <osalOsGetSystemTimeX>
 80044c6:	4603      	mov	r3, r0
 80044c8:	9a06      	ldr	r2, [sp, #24]
 80044ca:	1ad3      	subs	r3, r2, r3
 80044cc:	9305      	str	r3, [sp, #20]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 80044ce:	9a05      	ldr	r2, [sp, #20]
 80044d0:	9b00      	ldr	r3, [sp, #0]
 80044d2:	429a      	cmp	r2, r3
 80044d4:	d903      	bls.n	80044de <obqWriteTimeout+0x5e>
          osalSysUnlock();
 80044d6:	f7ff fc4b 	bl	8003d70 <osalSysUnlock>
          return w;
 80044da:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80044dc:	e060      	b.n	80045a0 <obqWriteTimeout+0x120>
        }
        msg = obqGetEmptyBufferTimeoutS(obqp, next_timeout);
 80044de:	9803      	ldr	r0, [sp, #12]
 80044e0:	9905      	ldr	r1, [sp, #20]
 80044e2:	f7ff ff2d 	bl	8004340 <obqGetEmptyBufferTimeoutS>
 80044e6:	9007      	str	r0, [sp, #28]
      }

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 80044e8:	9b07      	ldr	r3, [sp, #28]
 80044ea:	2b00      	cmp	r3, #0
 80044ec:	d003      	beq.n	80044f6 <obqWriteTimeout+0x76>
        osalSysUnlock();
 80044ee:	f7ff fc3f 	bl	8003d70 <osalSysUnlock>
        return w;
 80044f2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80044f4:	e054      	b.n	80045a0 <obqWriteTimeout+0x120>
      }
    }

    /* Size of the space available in the current buffer.*/
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 80044f6:	9b03      	ldr	r3, [sp, #12]
 80044f8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80044fa:	461a      	mov	r2, r3
 80044fc:	9b03      	ldr	r3, [sp, #12]
 80044fe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004500:	1ad3      	subs	r3, r2, r3
 8004502:	9308      	str	r3, [sp, #32]
    if (size > (n - w)) {
 8004504:	9a01      	ldr	r2, [sp, #4]
 8004506:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004508:	1ad2      	subs	r2, r2, r3
 800450a:	9b08      	ldr	r3, [sp, #32]
 800450c:	429a      	cmp	r2, r3
 800450e:	d203      	bcs.n	8004518 <obqWriteTimeout+0x98>
      size = n - w;
 8004510:	9a01      	ldr	r2, [sp, #4]
 8004512:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004514:	1ad3      	subs	r3, r2, r3
 8004516:	9308      	str	r3, [sp, #32]
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
 8004518:	9b08      	ldr	r3, [sp, #32]
 800451a:	2b40      	cmp	r3, #64	; 0x40
 800451c:	d913      	bls.n	8004546 <obqWriteTimeout+0xc6>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, 64U);
 800451e:	9b03      	ldr	r3, [sp, #12]
 8004520:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004522:	4618      	mov	r0, r3
 8004524:	9902      	ldr	r1, [sp, #8]
 8004526:	2240      	movs	r2, #64	; 0x40
 8004528:	f012 fdaa 	bl	8017080 <memcpy>
      bp        += 64U;
 800452c:	9b02      	ldr	r3, [sp, #8]
 800452e:	3340      	adds	r3, #64	; 0x40
 8004530:	9302      	str	r3, [sp, #8]
      obqp->ptr += 64U;
 8004532:	9b03      	ldr	r3, [sp, #12]
 8004534:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004536:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800453a:	9b03      	ldr	r3, [sp, #12]
 800453c:	625a      	str	r2, [r3, #36]	; 0x24
      w         += 64U;
 800453e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004540:	3340      	adds	r3, #64	; 0x40
 8004542:	9309      	str	r3, [sp, #36]	; 0x24
 8004544:	e014      	b.n	8004570 <obqWriteTimeout+0xf0>
    }
    else {
      memcpy(obqp->ptr, bp, size);
 8004546:	9b03      	ldr	r3, [sp, #12]
 8004548:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800454a:	4618      	mov	r0, r3
 800454c:	9902      	ldr	r1, [sp, #8]
 800454e:	9a08      	ldr	r2, [sp, #32]
 8004550:	f012 fd96 	bl	8017080 <memcpy>
      bp        += size;
 8004554:	9a02      	ldr	r2, [sp, #8]
 8004556:	9b08      	ldr	r3, [sp, #32]
 8004558:	4413      	add	r3, r2
 800455a:	9302      	str	r3, [sp, #8]
      obqp->ptr += size;
 800455c:	9b03      	ldr	r3, [sp, #12]
 800455e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004560:	9b08      	ldr	r3, [sp, #32]
 8004562:	441a      	add	r2, r3
 8004564:	9b03      	ldr	r3, [sp, #12]
 8004566:	625a      	str	r2, [r3, #36]	; 0x24
      w         += size;
 8004568:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800456a:	9b08      	ldr	r3, [sp, #32]
 800456c:	4413      	add	r3, r2
 800456e:	9309      	str	r3, [sp, #36]	; 0x24
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 8004570:	9b03      	ldr	r3, [sp, #12]
 8004572:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004574:	9b03      	ldr	r3, [sp, #12]
 8004576:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004578:	429a      	cmp	r2, r3
 800457a:	d306      	bcc.n	800458a <obqWriteTimeout+0x10a>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 800457c:	9b03      	ldr	r3, [sp, #12]
 800457e:	699b      	ldr	r3, [r3, #24]
 8004580:	3b04      	subs	r3, #4
 8004582:	9803      	ldr	r0, [sp, #12]
 8004584:	4619      	mov	r1, r3
 8004586:	f7ff ff13 	bl	80043b0 <obqPostFullBufferS>
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
 800458a:	f7ff fbf1 	bl	8003d70 <osalSysUnlock>
    if (w >= n) {
 800458e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8004590:	9b01      	ldr	r3, [sp, #4]
 8004592:	429a      	cmp	r2, r3
 8004594:	d301      	bcc.n	800459a <obqWriteTimeout+0x11a>
      return w;
 8004596:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004598:	e002      	b.n	80045a0 <obqWriteTimeout+0x120>
    }
    osalSysLock();
 800459a:	f7ff fbe1 	bl	8003d60 <osalSysLock>
  }
 800459e:	e77f      	b.n	80044a0 <obqWriteTimeout+0x20>
}
 80045a0:	4618      	mov	r0, r3
 80045a2:	b00b      	add	sp, #44	; 0x2c
 80045a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80045a8:	f3af 8000 	nop.w
 80045ac:	f3af 8000 	nop.w

080045b0 <obqTryFlushI>:
 * @retval false        if no new filled buffer has been posted to the queue.
 * @retval true         if a new filled buffer has been posted to the queue.
 *
 * @iclass
 */
bool obqTryFlushI(output_buffers_queue_t *obqp) {
 80045b0:	b084      	sub	sp, #16
 80045b2:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 80045b4:	9b01      	ldr	r3, [sp, #4]
 80045b6:	68da      	ldr	r2, [r3, #12]
 80045b8:	9b01      	ldr	r3, [sp, #4]
 80045ba:	691b      	ldr	r3, [r3, #16]
 80045bc:	429a      	cmp	r2, r3
 80045be:	d105      	bne.n	80045cc <obqTryFlushI+0x1c>
 80045c0:	9b01      	ldr	r3, [sp, #4]
 80045c2:	689b      	ldr	r3, [r3, #8]
 80045c4:	2b00      	cmp	r3, #0
 80045c6:	d001      	beq.n	80045cc <obqTryFlushI+0x1c>
 80045c8:	2301      	movs	r3, #1
 80045ca:	e000      	b.n	80045ce <obqTryFlushI+0x1e>
 80045cc:	2300      	movs	r3, #0
 80045ce:	f003 0301 	and.w	r3, r3, #1
 80045d2:	b2db      	uxtb	r3, r3
 80045d4:	2b00      	cmp	r3, #0
 80045d6:	d02d      	beq.n	8004634 <obqTryFlushI+0x84>
 80045d8:	9b01      	ldr	r3, [sp, #4]
 80045da:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80045dc:	2b00      	cmp	r3, #0
 80045de:	d029      	beq.n	8004634 <obqTryFlushI+0x84>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
 80045e0:	9b01      	ldr	r3, [sp, #4]
 80045e2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80045e4:	461a      	mov	r2, r3
 80045e6:	9b01      	ldr	r3, [sp, #4]
 80045e8:	68db      	ldr	r3, [r3, #12]
 80045ea:	1ad3      	subs	r3, r2, r3
 80045ec:	3b04      	subs	r3, #4
 80045ee:	9303      	str	r3, [sp, #12]

    if (size > 0U) {
 80045f0:	9b03      	ldr	r3, [sp, #12]
 80045f2:	2b00      	cmp	r3, #0
 80045f4:	d01e      	beq.n	8004634 <obqTryFlushI+0x84>

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;
 80045f6:	9b01      	ldr	r3, [sp, #4]
 80045f8:	68db      	ldr	r3, [r3, #12]
 80045fa:	9a03      	ldr	r2, [sp, #12]
 80045fc:	601a      	str	r2, [r3, #0]

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
 80045fe:	9b01      	ldr	r3, [sp, #4]
 8004600:	689b      	ldr	r3, [r3, #8]
 8004602:	1e5a      	subs	r2, r3, #1
 8004604:	9b01      	ldr	r3, [sp, #4]
 8004606:	609a      	str	r2, [r3, #8]
      obqp->bwrptr += obqp->bsize;
 8004608:	9b01      	ldr	r3, [sp, #4]
 800460a:	68da      	ldr	r2, [r3, #12]
 800460c:	9b01      	ldr	r3, [sp, #4]
 800460e:	699b      	ldr	r3, [r3, #24]
 8004610:	441a      	add	r2, r3
 8004612:	9b01      	ldr	r3, [sp, #4]
 8004614:	60da      	str	r2, [r3, #12]
      if (obqp->bwrptr >= obqp->btop) {
 8004616:	9b01      	ldr	r3, [sp, #4]
 8004618:	68da      	ldr	r2, [r3, #12]
 800461a:	9b01      	ldr	r3, [sp, #4]
 800461c:	695b      	ldr	r3, [r3, #20]
 800461e:	429a      	cmp	r2, r3
 8004620:	d303      	bcc.n	800462a <obqTryFlushI+0x7a>
        obqp->bwrptr = obqp->buffers;
 8004622:	9b01      	ldr	r3, [sp, #4]
 8004624:	6a1a      	ldr	r2, [r3, #32]
 8004626:	9b01      	ldr	r3, [sp, #4]
 8004628:	60da      	str	r2, [r3, #12]
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
 800462a:	9b01      	ldr	r3, [sp, #4]
 800462c:	2200      	movs	r2, #0
 800462e:	625a      	str	r2, [r3, #36]	; 0x24

      return true;
 8004630:	2301      	movs	r3, #1
 8004632:	e000      	b.n	8004636 <obqTryFlushI+0x86>
    }
  }
  return false;
 8004634:	2300      	movs	r3, #0
}
 8004636:	4618      	mov	r0, r3
 8004638:	b004      	add	sp, #16
 800463a:	4770      	bx	lr
 800463c:	f3af 8000 	nop.w

08004640 <obqFlush>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @api
 */
void obqFlush(output_buffers_queue_t *obqp) {
 8004640:	b500      	push	{lr}
 8004642:	b085      	sub	sp, #20
 8004644:	9001      	str	r0, [sp, #4]

  osalSysLock();
 8004646:	f7ff fb8b 	bl	8003d60 <osalSysLock>

  /* If there is a buffer partially filled and not being written.*/
  if (obqp->ptr != NULL) {
 800464a:	9b01      	ldr	r3, [sp, #4]
 800464c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800464e:	2b00      	cmp	r3, #0
 8004650:	d00e      	beq.n	8004670 <obqFlush+0x30>
    size_t size = (size_t)obqp->ptr - (size_t)obqp->bwrptr - sizeof (size_t);
 8004652:	9b01      	ldr	r3, [sp, #4]
 8004654:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004656:	461a      	mov	r2, r3
 8004658:	9b01      	ldr	r3, [sp, #4]
 800465a:	68db      	ldr	r3, [r3, #12]
 800465c:	1ad3      	subs	r3, r2, r3
 800465e:	3b04      	subs	r3, #4
 8004660:	9303      	str	r3, [sp, #12]

    if (size > 0U) {
 8004662:	9b03      	ldr	r3, [sp, #12]
 8004664:	2b00      	cmp	r3, #0
 8004666:	d003      	beq.n	8004670 <obqFlush+0x30>
      obqPostFullBufferS(obqp, size);
 8004668:	9801      	ldr	r0, [sp, #4]
 800466a:	9903      	ldr	r1, [sp, #12]
 800466c:	f7ff fea0 	bl	80043b0 <obqPostFullBufferS>
    }
  }

  osalSysUnlock();
 8004670:	f7ff fb7e 	bl	8003d70 <osalSysUnlock>
}
 8004674:	b005      	add	sp, #20
 8004676:	f85d fb04 	ldr.w	pc, [sp], #4
 800467a:	bf00      	nop
 800467c:	f3af 8000 	nop.w

08004680 <_mmcsd_get_slice>:
 *
 * @notapi
 */
uint32_t _mmcsd_get_slice(const uint32_t *data,
                          uint32_t end,
                          uint32_t start) {
 8004680:	b088      	sub	sp, #32
 8004682:	9003      	str	r0, [sp, #12]
 8004684:	9102      	str	r1, [sp, #8]
 8004686:	9201      	str	r2, [sp, #4]
  unsigned startidx, endidx, startoff;
  uint32_t endmask;

  osalDbgCheck((end >= start) && ((end - start) < 32U));

  startidx = start / 32U;
 8004688:	9b01      	ldr	r3, [sp, #4]
 800468a:	095b      	lsrs	r3, r3, #5
 800468c:	9307      	str	r3, [sp, #28]
  startoff = start % 32U;
 800468e:	9b01      	ldr	r3, [sp, #4]
 8004690:	f003 031f 	and.w	r3, r3, #31
 8004694:	9306      	str	r3, [sp, #24]
  endidx   = end / 32U;
 8004696:	9b02      	ldr	r3, [sp, #8]
 8004698:	095b      	lsrs	r3, r3, #5
 800469a:	9305      	str	r3, [sp, #20]
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;
 800469c:	9b02      	ldr	r3, [sp, #8]
 800469e:	f003 031f 	and.w	r3, r3, #31
 80046a2:	3301      	adds	r3, #1
 80046a4:	2201      	movs	r2, #1
 80046a6:	fa02 f303 	lsl.w	r3, r2, r3
 80046aa:	3b01      	subs	r3, #1
 80046ac:	9304      	str	r3, [sp, #16]

  /* One or two pieces?*/
  if (startidx < endidx) {
 80046ae:	9a07      	ldr	r2, [sp, #28]
 80046b0:	9b05      	ldr	r3, [sp, #20]
 80046b2:	429a      	cmp	r2, r3
 80046b4:	d214      	bcs.n	80046e0 <_mmcsd_get_slice+0x60>
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 80046b6:	9b07      	ldr	r3, [sp, #28]
 80046b8:	009b      	lsls	r3, r3, #2
 80046ba:	9a03      	ldr	r2, [sp, #12]
 80046bc:	4413      	add	r3, r2
 80046be:	681a      	ldr	r2, [r3, #0]
 80046c0:	9b06      	ldr	r3, [sp, #24]
 80046c2:	40da      	lsrs	r2, r3
           ((data[endidx] & endmask) << (32U - startoff));
 80046c4:	9b05      	ldr	r3, [sp, #20]
 80046c6:	009b      	lsls	r3, r3, #2
 80046c8:	9903      	ldr	r1, [sp, #12]
 80046ca:	440b      	add	r3, r1
 80046cc:	6819      	ldr	r1, [r3, #0]
 80046ce:	9b04      	ldr	r3, [sp, #16]
 80046d0:	4019      	ands	r1, r3
 80046d2:	9b06      	ldr	r3, [sp, #24]
 80046d4:	f1c3 0320 	rsb	r3, r3, #32
 80046d8:	fa01 f303 	lsl.w	r3, r1, r3
  endidx   = end / 32U;
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;

  /* One or two pieces?*/
  if (startidx < endidx) {
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 80046dc:	4313      	orrs	r3, r2
 80046de:	e009      	b.n	80046f4 <_mmcsd_get_slice+0x74>
           ((data[endidx] & endmask) << (32U - startoff));
  }
  return (data[startidx] & endmask) >> startoff;        /* One piece case.  */
 80046e0:	9b07      	ldr	r3, [sp, #28]
 80046e2:	009b      	lsls	r3, r3, #2
 80046e4:	9a03      	ldr	r2, [sp, #12]
 80046e6:	4413      	add	r3, r2
 80046e8:	681a      	ldr	r2, [r3, #0]
 80046ea:	9b04      	ldr	r3, [sp, #16]
 80046ec:	401a      	ands	r2, r3
 80046ee:	9b06      	ldr	r3, [sp, #24]
 80046f0:	fa22 f303 	lsr.w	r3, r2, r3
}
 80046f4:	4618      	mov	r0, r3
 80046f6:	b008      	add	sp, #32
 80046f8:	4770      	bx	lr
 80046fa:	bf00      	nop
 80046fc:	f3af 8000 	nop.w

08004700 <_mmcsd_get_capacity>:
 * @return              The card capacity.
 * @retval 0            CSD format error
 *
 * @notapi
 */
uint32_t _mmcsd_get_capacity(const uint32_t *csd) {
 8004700:	b500      	push	{lr}
 8004702:	b087      	sub	sp, #28
 8004704:	9001      	str	r0, [sp, #4]
  uint32_t a, b, c;

  osalDbgCheck(NULL != csd);

  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 8004706:	9801      	ldr	r0, [sp, #4]
 8004708:	217f      	movs	r1, #127	; 0x7f
 800470a:	227e      	movs	r2, #126	; 0x7e
 800470c:	f7ff ffb8 	bl	8004680 <_mmcsd_get_slice>
 8004710:	4603      	mov	r3, r0
 8004712:	2b00      	cmp	r3, #0
 8004714:	d004      	beq.n	8004720 <_mmcsd_get_capacity+0x20>
 8004716:	2b01      	cmp	r3, #1
 8004718:	d01e      	beq.n	8004758 <_mmcsd_get_capacity+0x58>
  case 1:
    /* CSD version 2.0.*/
    return 1024U * (_mmcsd_get_slice(csd, MMCSD_CSD_20_C_SIZE_SLICE) + 1U);
  default:
    /* Reserved value detected.*/
    break;
 800471a:	bf00      	nop
  }
  return 0U;
 800471c:	2300      	movs	r3, #0
 800471e:	e023      	b.n	8004768 <_mmcsd_get_capacity+0x68>
  osalDbgCheck(NULL != csd);

  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
  case 0:
    /* CSD version 1.0 */
    a = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_SLICE);
 8004720:	9801      	ldr	r0, [sp, #4]
 8004722:	2149      	movs	r1, #73	; 0x49
 8004724:	223e      	movs	r2, #62	; 0x3e
 8004726:	f7ff ffab 	bl	8004680 <_mmcsd_get_slice>
 800472a:	9005      	str	r0, [sp, #20]
    b = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_MULT_SLICE);
 800472c:	9801      	ldr	r0, [sp, #4]
 800472e:	2131      	movs	r1, #49	; 0x31
 8004730:	222f      	movs	r2, #47	; 0x2f
 8004732:	f7ff ffa5 	bl	8004680 <_mmcsd_get_slice>
 8004736:	9004      	str	r0, [sp, #16]
    c = _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_LEN_SLICE);
 8004738:	9801      	ldr	r0, [sp, #4]
 800473a:	2153      	movs	r1, #83	; 0x53
 800473c:	2250      	movs	r2, #80	; 0x50
 800473e:	f7ff ff9f 	bl	8004680 <_mmcsd_get_slice>
 8004742:	9003      	str	r0, [sp, #12]
    return ((a + 1U) << (b + 2U)) << (c - 9U);  /* 2^9 == MMCSD_BLOCK_SIZE. */
 8004744:	9b05      	ldr	r3, [sp, #20]
 8004746:	1c5a      	adds	r2, r3, #1
 8004748:	9b04      	ldr	r3, [sp, #16]
 800474a:	3302      	adds	r3, #2
 800474c:	409a      	lsls	r2, r3
 800474e:	9b03      	ldr	r3, [sp, #12]
 8004750:	3b09      	subs	r3, #9
 8004752:	fa02 f303 	lsl.w	r3, r2, r3
 8004756:	e007      	b.n	8004768 <_mmcsd_get_capacity+0x68>
  case 1:
    /* CSD version 2.0.*/
    return 1024U * (_mmcsd_get_slice(csd, MMCSD_CSD_20_C_SIZE_SLICE) + 1U);
 8004758:	9801      	ldr	r0, [sp, #4]
 800475a:	2145      	movs	r1, #69	; 0x45
 800475c:	2230      	movs	r2, #48	; 0x30
 800475e:	f7ff ff8f 	bl	8004680 <_mmcsd_get_slice>
 8004762:	4603      	mov	r3, r0
 8004764:	3301      	adds	r3, #1
 8004766:	029b      	lsls	r3, r3, #10
  default:
    /* Reserved value detected.*/
    break;
  }
  return 0U;
}
 8004768:	4618      	mov	r0, r3
 800476a:	b007      	add	sp, #28
 800476c:	f85d fb04 	ldr.w	pc, [sp], #4

08004770 <_mmcsd_get_capacity_ext>:
 *
 * @return              The card capacity.
 *
 * @notapi
 */
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {
 8004770:	b082      	sub	sp, #8
 8004772:	9001      	str	r0, [sp, #4]

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
 8004774:	9b01      	ldr	r3, [sp, #4]
 8004776:	33d7      	adds	r3, #215	; 0xd7
 8004778:	781b      	ldrb	r3, [r3, #0]
 800477a:	061a      	lsls	r2, r3, #24
         ((uint32_t)ext_csd[214] << 16U) +
 800477c:	9b01      	ldr	r3, [sp, #4]
 800477e:	33d6      	adds	r3, #214	; 0xd6
 8004780:	781b      	ldrb	r3, [r3, #0]
 8004782:	041b      	lsls	r3, r3, #16
 */
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
 8004784:	441a      	add	r2, r3
         ((uint32_t)ext_csd[214] << 16U) +
         ((uint32_t)ext_csd[213] << 8U)  +
 8004786:	9b01      	ldr	r3, [sp, #4]
 8004788:	33d5      	adds	r3, #213	; 0xd5
 800478a:	781b      	ldrb	r3, [r3, #0]
 800478c:	021b      	lsls	r3, r3, #8
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
         ((uint32_t)ext_csd[214] << 16U) +
 800478e:	441a      	add	r2, r3
         ((uint32_t)ext_csd[213] << 8U)  +
         (uint32_t)ext_csd[212];
 8004790:	9b01      	ldr	r3, [sp, #4]
 8004792:	33d4      	adds	r3, #212	; 0xd4
 8004794:	781b      	ldrb	r3, [r3, #0]
 */
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
 8004796:	4413      	add	r3, r2
         ((uint32_t)ext_csd[214] << 16U) +
         ((uint32_t)ext_csd[213] << 8U)  +
         (uint32_t)ext_csd[212];
}
 8004798:	4618      	mov	r0, r3
 800479a:	b002      	add	sp, #8
 800479c:	4770      	bx	lr
 800479e:	bf00      	nop

080047a0 <_mmcsd_unpack_sdc_cid>:
 * @param[out] cidsdc   pointer to the @p unpacked_sdc_cid_t object
 *
 * @notapi
 */
void _mmcsd_unpack_sdc_cid(const MMCSDBlockDevice *sdcp,
                           unpacked_sdc_cid_t *cidsdc) {
 80047a0:	b500      	push	{lr}
 80047a2:	b085      	sub	sp, #20
 80047a4:	9001      	str	r0, [sp, #4]
 80047a6:	9100      	str	r1, [sp, #0]
  const uint32_t *cid;

  osalDbgCheck((NULL != sdcp) && (NULL != cidsdc));

  cid = sdcp->cid;
 80047a8:	9b01      	ldr	r3, [sp, #4]
 80047aa:	3308      	adds	r3, #8
 80047ac:	9303      	str	r3, [sp, #12]
  cidsdc->crc    = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_SDC_CRC_SLICE);
 80047ae:	9803      	ldr	r0, [sp, #12]
 80047b0:	2107      	movs	r1, #7
 80047b2:	2201      	movs	r2, #1
 80047b4:	f7ff ff64 	bl	8004680 <_mmcsd_get_slice>
 80047b8:	4603      	mov	r3, r0
 80047ba:	b2da      	uxtb	r2, r3
 80047bc:	9b00      	ldr	r3, [sp, #0]
 80047be:	751a      	strb	r2, [r3, #20]
  cidsdc->mdt_y  = (uint16_t)_mmcsd_get_slice(cid, MMCSD_CID_SDC_MDT_Y_SLICE) +
 80047c0:	9803      	ldr	r0, [sp, #12]
 80047c2:	2113      	movs	r1, #19
 80047c4:	220c      	movs	r2, #12
 80047c6:	f7ff ff5b 	bl	8004680 <_mmcsd_get_slice>
 80047ca:	4603      	mov	r3, r0
 80047cc:	b29b      	uxth	r3, r3
 80047ce:	f503 63fa 	add.w	r3, r3, #2000	; 0x7d0
 80047d2:	b29a      	uxth	r2, r3
 80047d4:	9b00      	ldr	r3, [sp, #0]
 80047d6:	825a      	strh	r2, [r3, #18]
                             2000U;
  cidsdc->mdt_m  = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_SDC_MDT_M_SLICE);
 80047d8:	9803      	ldr	r0, [sp, #12]
 80047da:	210b      	movs	r1, #11
 80047dc:	2208      	movs	r2, #8
 80047de:	f7ff ff4f 	bl	8004680 <_mmcsd_get_slice>
 80047e2:	4603      	mov	r3, r0
 80047e4:	b2da      	uxtb	r2, r3
 80047e6:	9b00      	ldr	r3, [sp, #0]
 80047e8:	741a      	strb	r2, [r3, #16]
  cidsdc->mid    = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_SDC_MID_SLICE);
 80047ea:	9803      	ldr	r0, [sp, #12]
 80047ec:	217f      	movs	r1, #127	; 0x7f
 80047ee:	2278      	movs	r2, #120	; 0x78
 80047f0:	f7ff ff46 	bl	8004680 <_mmcsd_get_slice>
 80047f4:	4603      	mov	r3, r0
 80047f6:	b2da      	uxtb	r2, r3
 80047f8:	9b00      	ldr	r3, [sp, #0]
 80047fa:	701a      	strb	r2, [r3, #0]
  cidsdc->oid    = (uint16_t)_mmcsd_get_slice(cid, MMCSD_CID_SDC_OID_SLICE);
 80047fc:	9803      	ldr	r0, [sp, #12]
 80047fe:	2177      	movs	r1, #119	; 0x77
 8004800:	2268      	movs	r2, #104	; 0x68
 8004802:	f7ff ff3d 	bl	8004680 <_mmcsd_get_slice>
 8004806:	4603      	mov	r3, r0
 8004808:	b29a      	uxth	r2, r3
 800480a:	9b00      	ldr	r3, [sp, #0]
 800480c:	805a      	strh	r2, [r3, #2]
  cidsdc->pnm[4] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_SDC_PNM0_SLICE);
 800480e:	9803      	ldr	r0, [sp, #12]
 8004810:	2147      	movs	r1, #71	; 0x47
 8004812:	2240      	movs	r2, #64	; 0x40
 8004814:	f7ff ff34 	bl	8004680 <_mmcsd_get_slice>
 8004818:	4603      	mov	r3, r0
 800481a:	b2da      	uxtb	r2, r3
 800481c:	9b00      	ldr	r3, [sp, #0]
 800481e:	721a      	strb	r2, [r3, #8]
  cidsdc->pnm[3] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_SDC_PNM1_SLICE);
 8004820:	9803      	ldr	r0, [sp, #12]
 8004822:	214f      	movs	r1, #79	; 0x4f
 8004824:	2248      	movs	r2, #72	; 0x48
 8004826:	f7ff ff2b 	bl	8004680 <_mmcsd_get_slice>
 800482a:	4603      	mov	r3, r0
 800482c:	b2da      	uxtb	r2, r3
 800482e:	9b00      	ldr	r3, [sp, #0]
 8004830:	71da      	strb	r2, [r3, #7]
  cidsdc->pnm[2] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_SDC_PNM2_SLICE);
 8004832:	9803      	ldr	r0, [sp, #12]
 8004834:	2157      	movs	r1, #87	; 0x57
 8004836:	2250      	movs	r2, #80	; 0x50
 8004838:	f7ff ff22 	bl	8004680 <_mmcsd_get_slice>
 800483c:	4603      	mov	r3, r0
 800483e:	b2da      	uxtb	r2, r3
 8004840:	9b00      	ldr	r3, [sp, #0]
 8004842:	719a      	strb	r2, [r3, #6]
  cidsdc->pnm[1] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_SDC_PNM3_SLICE);
 8004844:	9803      	ldr	r0, [sp, #12]
 8004846:	215f      	movs	r1, #95	; 0x5f
 8004848:	2258      	movs	r2, #88	; 0x58
 800484a:	f7ff ff19 	bl	8004680 <_mmcsd_get_slice>
 800484e:	4603      	mov	r3, r0
 8004850:	b2da      	uxtb	r2, r3
 8004852:	9b00      	ldr	r3, [sp, #0]
 8004854:	715a      	strb	r2, [r3, #5]
  cidsdc->pnm[0] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_SDC_PNM4_SLICE);
 8004856:	9803      	ldr	r0, [sp, #12]
 8004858:	2167      	movs	r1, #103	; 0x67
 800485a:	2260      	movs	r2, #96	; 0x60
 800485c:	f7ff ff10 	bl	8004680 <_mmcsd_get_slice>
 8004860:	4603      	mov	r3, r0
 8004862:	b2da      	uxtb	r2, r3
 8004864:	9b00      	ldr	r3, [sp, #0]
 8004866:	711a      	strb	r2, [r3, #4]
  cidsdc->prv_n  = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_SDC_PRV_N_SLICE);
 8004868:	9803      	ldr	r0, [sp, #12]
 800486a:	213f      	movs	r1, #63	; 0x3f
 800486c:	223c      	movs	r2, #60	; 0x3c
 800486e:	f7ff ff07 	bl	8004680 <_mmcsd_get_slice>
 8004872:	4603      	mov	r3, r0
 8004874:	b2da      	uxtb	r2, r3
 8004876:	9b00      	ldr	r3, [sp, #0]
 8004878:	725a      	strb	r2, [r3, #9]
  cidsdc->prv_m  = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_SDC_PRV_M_SLICE);
 800487a:	9803      	ldr	r0, [sp, #12]
 800487c:	213b      	movs	r1, #59	; 0x3b
 800487e:	2238      	movs	r2, #56	; 0x38
 8004880:	f7ff fefe 	bl	8004680 <_mmcsd_get_slice>
 8004884:	4603      	mov	r3, r0
 8004886:	b2da      	uxtb	r2, r3
 8004888:	9b00      	ldr	r3, [sp, #0]
 800488a:	729a      	strb	r2, [r3, #10]
  cidsdc->psn    =           _mmcsd_get_slice(cid, MMCSD_CID_SDC_PSN_SLICE);
 800488c:	9803      	ldr	r0, [sp, #12]
 800488e:	2137      	movs	r1, #55	; 0x37
 8004890:	2218      	movs	r2, #24
 8004892:	f7ff fef5 	bl	8004680 <_mmcsd_get_slice>
 8004896:	4602      	mov	r2, r0
 8004898:	9b00      	ldr	r3, [sp, #0]
 800489a:	60da      	str	r2, [r3, #12]
}
 800489c:	b005      	add	sp, #20
 800489e:	f85d fb04 	ldr.w	pc, [sp], #4
 80048a2:	bf00      	nop
 80048a4:	f3af 8000 	nop.w
 80048a8:	f3af 8000 	nop.w
 80048ac:	f3af 8000 	nop.w

080048b0 <_mmcsd_unpack_mmc_cid>:
 * @param[out] cidmmc   pointer to the @p unpacked_mmc_cid_t object
 *
 * @notapi
 */
void _mmcsd_unpack_mmc_cid(const MMCSDBlockDevice *sdcp,
                           unpacked_mmc_cid_t *cidmmc) {
 80048b0:	b500      	push	{lr}
 80048b2:	b085      	sub	sp, #20
 80048b4:	9001      	str	r0, [sp, #4]
 80048b6:	9100      	str	r1, [sp, #0]
  const uint32_t *cid;

  osalDbgCheck((NULL != sdcp) && (NULL != cidmmc));

  cid = sdcp->cid;
 80048b8:	9b01      	ldr	r3, [sp, #4]
 80048ba:	3308      	adds	r3, #8
 80048bc:	9303      	str	r3, [sp, #12]
  cidmmc->crc    = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_MMC_CRC_SLICE);
 80048be:	9803      	ldr	r0, [sp, #12]
 80048c0:	2107      	movs	r1, #7
 80048c2:	2201      	movs	r2, #1
 80048c4:	f7ff fedc 	bl	8004680 <_mmcsd_get_slice>
 80048c8:	4603      	mov	r3, r0
 80048ca:	b2da      	uxtb	r2, r3
 80048cc:	9b00      	ldr	r3, [sp, #0]
 80048ce:	751a      	strb	r2, [r3, #20]
  cidmmc->mdt_y  = (uint16_t)_mmcsd_get_slice(cid, MMCSD_CID_MMC_MDT_Y_SLICE) +
 80048d0:	9803      	ldr	r0, [sp, #12]
 80048d2:	210b      	movs	r1, #11
 80048d4:	2208      	movs	r2, #8
 80048d6:	f7ff fed3 	bl	8004680 <_mmcsd_get_slice>
 80048da:	4603      	mov	r3, r0
 80048dc:	b29b      	uxth	r3, r3
 80048de:	f203 73cd 	addw	r3, r3, #1997	; 0x7cd
 80048e2:	b29a      	uxth	r2, r3
 80048e4:	9b00      	ldr	r3, [sp, #0]
 80048e6:	825a      	strh	r2, [r3, #18]
                             1997U;
  cidmmc->mdt_m  = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_MMC_MDT_M_SLICE);
 80048e8:	9803      	ldr	r0, [sp, #12]
 80048ea:	210f      	movs	r1, #15
 80048ec:	220c      	movs	r2, #12
 80048ee:	f7ff fec7 	bl	8004680 <_mmcsd_get_slice>
 80048f2:	4603      	mov	r3, r0
 80048f4:	b2da      	uxtb	r2, r3
 80048f6:	9b00      	ldr	r3, [sp, #0]
 80048f8:	741a      	strb	r2, [r3, #16]
  cidmmc->mid    = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_MMC_MID_SLICE);
 80048fa:	9803      	ldr	r0, [sp, #12]
 80048fc:	217f      	movs	r1, #127	; 0x7f
 80048fe:	2278      	movs	r2, #120	; 0x78
 8004900:	f7ff febe 	bl	8004680 <_mmcsd_get_slice>
 8004904:	4603      	mov	r3, r0
 8004906:	b2da      	uxtb	r2, r3
 8004908:	9b00      	ldr	r3, [sp, #0]
 800490a:	701a      	strb	r2, [r3, #0]
  cidmmc->oid    = (uint16_t)_mmcsd_get_slice(cid, MMCSD_CID_MMC_OID_SLICE);
 800490c:	9803      	ldr	r0, [sp, #12]
 800490e:	2177      	movs	r1, #119	; 0x77
 8004910:	2268      	movs	r2, #104	; 0x68
 8004912:	f7ff feb5 	bl	8004680 <_mmcsd_get_slice>
 8004916:	4603      	mov	r3, r0
 8004918:	b29a      	uxth	r2, r3
 800491a:	9b00      	ldr	r3, [sp, #0]
 800491c:	805a      	strh	r2, [r3, #2]
  cidmmc->pnm[5] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_MMC_PNM0_SLICE);
 800491e:	9803      	ldr	r0, [sp, #12]
 8004920:	213f      	movs	r1, #63	; 0x3f
 8004922:	2238      	movs	r2, #56	; 0x38
 8004924:	f7ff feac 	bl	8004680 <_mmcsd_get_slice>
 8004928:	4603      	mov	r3, r0
 800492a:	b2da      	uxtb	r2, r3
 800492c:	9b00      	ldr	r3, [sp, #0]
 800492e:	725a      	strb	r2, [r3, #9]
  cidmmc->pnm[4] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_MMC_PNM1_SLICE);
 8004930:	9803      	ldr	r0, [sp, #12]
 8004932:	2147      	movs	r1, #71	; 0x47
 8004934:	2240      	movs	r2, #64	; 0x40
 8004936:	f7ff fea3 	bl	8004680 <_mmcsd_get_slice>
 800493a:	4603      	mov	r3, r0
 800493c:	b2da      	uxtb	r2, r3
 800493e:	9b00      	ldr	r3, [sp, #0]
 8004940:	721a      	strb	r2, [r3, #8]
  cidmmc->pnm[3] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_MMC_PNM2_SLICE);
 8004942:	9803      	ldr	r0, [sp, #12]
 8004944:	214f      	movs	r1, #79	; 0x4f
 8004946:	2248      	movs	r2, #72	; 0x48
 8004948:	f7ff fe9a 	bl	8004680 <_mmcsd_get_slice>
 800494c:	4603      	mov	r3, r0
 800494e:	b2da      	uxtb	r2, r3
 8004950:	9b00      	ldr	r3, [sp, #0]
 8004952:	71da      	strb	r2, [r3, #7]
  cidmmc->pnm[2] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_MMC_PNM3_SLICE);
 8004954:	9803      	ldr	r0, [sp, #12]
 8004956:	2157      	movs	r1, #87	; 0x57
 8004958:	2250      	movs	r2, #80	; 0x50
 800495a:	f7ff fe91 	bl	8004680 <_mmcsd_get_slice>
 800495e:	4603      	mov	r3, r0
 8004960:	b2da      	uxtb	r2, r3
 8004962:	9b00      	ldr	r3, [sp, #0]
 8004964:	719a      	strb	r2, [r3, #6]
  cidmmc->pnm[1] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_MMC_PNM4_SLICE);
 8004966:	9803      	ldr	r0, [sp, #12]
 8004968:	215f      	movs	r1, #95	; 0x5f
 800496a:	2258      	movs	r2, #88	; 0x58
 800496c:	f7ff fe88 	bl	8004680 <_mmcsd_get_slice>
 8004970:	4603      	mov	r3, r0
 8004972:	b2da      	uxtb	r2, r3
 8004974:	9b00      	ldr	r3, [sp, #0]
 8004976:	715a      	strb	r2, [r3, #5]
  cidmmc->pnm[0] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_MMC_PNM5_SLICE);
 8004978:	9803      	ldr	r0, [sp, #12]
 800497a:	2167      	movs	r1, #103	; 0x67
 800497c:	2260      	movs	r2, #96	; 0x60
 800497e:	f7ff fe7f 	bl	8004680 <_mmcsd_get_slice>
 8004982:	4603      	mov	r3, r0
 8004984:	b2da      	uxtb	r2, r3
 8004986:	9b00      	ldr	r3, [sp, #0]
 8004988:	711a      	strb	r2, [r3, #4]
  cidmmc->prv_n  = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_MMC_PRV_N_SLICE);
 800498a:	9803      	ldr	r0, [sp, #12]
 800498c:	2137      	movs	r1, #55	; 0x37
 800498e:	2234      	movs	r2, #52	; 0x34
 8004990:	f7ff fe76 	bl	8004680 <_mmcsd_get_slice>
 8004994:	4603      	mov	r3, r0
 8004996:	b2da      	uxtb	r2, r3
 8004998:	9b00      	ldr	r3, [sp, #0]
 800499a:	729a      	strb	r2, [r3, #10]
  cidmmc->prv_m  = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_MMC_PRV_M_SLICE);
 800499c:	9803      	ldr	r0, [sp, #12]
 800499e:	2133      	movs	r1, #51	; 0x33
 80049a0:	2230      	movs	r2, #48	; 0x30
 80049a2:	f7ff fe6d 	bl	8004680 <_mmcsd_get_slice>
 80049a6:	4603      	mov	r3, r0
 80049a8:	b2da      	uxtb	r2, r3
 80049aa:	9b00      	ldr	r3, [sp, #0]
 80049ac:	72da      	strb	r2, [r3, #11]
  cidmmc->psn    =           _mmcsd_get_slice(cid, MMCSD_CID_MMC_PSN_SLICE);
 80049ae:	9803      	ldr	r0, [sp, #12]
 80049b0:	212f      	movs	r1, #47	; 0x2f
 80049b2:	2210      	movs	r2, #16
 80049b4:	f7ff fe64 	bl	8004680 <_mmcsd_get_slice>
 80049b8:	4602      	mov	r2, r0
 80049ba:	9b00      	ldr	r3, [sp, #0]
 80049bc:	60da      	str	r2, [r3, #12]
}
 80049be:	b005      	add	sp, #20
 80049c0:	f85d fb04 	ldr.w	pc, [sp], #4
 80049c4:	f3af 8000 	nop.w
 80049c8:	f3af 8000 	nop.w
 80049cc:	f3af 8000 	nop.w

080049d0 <_mmcsd_unpack_csd_mmc>:
 * @param[out] csdmmc   pointer to the @p unpacked_mmc_csd_t object
 *
 * @notapi
 */
void _mmcsd_unpack_csd_mmc(const MMCSDBlockDevice *sdcp,
                           unpacked_mmc_csd_t *csdmmc) {
 80049d0:	b500      	push	{lr}
 80049d2:	b085      	sub	sp, #20
 80049d4:	9001      	str	r0, [sp, #4]
 80049d6:	9100      	str	r1, [sp, #0]
  const uint32_t *csd;

  osalDbgCheck((NULL != sdcp) && (NULL != csdmmc));

  csd = sdcp->csd;
 80049d8:	9b01      	ldr	r3, [sp, #4]
 80049da:	3318      	adds	r3, #24
 80049dc:	9303      	str	r3, [sp, #12]
  csdmmc->c_size             = (uint16_t)_mmcsd_get_slice(csd, MMCSD_CSD_MMC_C_SIZE_SLICE);
 80049de:	9803      	ldr	r0, [sp, #12]
 80049e0:	2149      	movs	r1, #73	; 0x49
 80049e2:	223e      	movs	r2, #62	; 0x3e
 80049e4:	f7ff fe4c 	bl	8004680 <_mmcsd_get_slice>
 80049e8:	4603      	mov	r3, r0
 80049ea:	b29a      	uxth	r2, r3
 80049ec:	9b00      	ldr	r3, [sp, #0]
 80049ee:	81da      	strh	r2, [r3, #14]
  csdmmc->c_size_mult        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_C_SIZE_MULT_SLICE);
 80049f0:	9803      	ldr	r0, [sp, #12]
 80049f2:	2131      	movs	r1, #49	; 0x31
 80049f4:	222f      	movs	r2, #47	; 0x2f
 80049f6:	f7ff fe43 	bl	8004680 <_mmcsd_get_slice>
 80049fa:	4603      	mov	r3, r0
 80049fc:	b2da      	uxtb	r2, r3
 80049fe:	9b00      	ldr	r3, [sp, #0]
 8004a00:	751a      	strb	r2, [r3, #20]
  csdmmc->ccc                = (uint16_t)_mmcsd_get_slice(csd, MMCSD_CSD_MMC_CCC_SLICE);
 8004a02:	9803      	ldr	r0, [sp, #12]
 8004a04:	215f      	movs	r1, #95	; 0x5f
 8004a06:	2254      	movs	r2, #84	; 0x54
 8004a08:	f7ff fe3a 	bl	8004680 <_mmcsd_get_slice>
 8004a0c:	4603      	mov	r3, r0
 8004a0e:	b29a      	uxth	r2, r3
 8004a10:	9b00      	ldr	r3, [sp, #0]
 8004a12:	80da      	strh	r2, [r3, #6]
  csdmmc->copy               = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_COPY_SLICE);
 8004a14:	9803      	ldr	r0, [sp, #12]
 8004a16:	210e      	movs	r1, #14
 8004a18:	220e      	movs	r2, #14
 8004a1a:	f7ff fe31 	bl	8004680 <_mmcsd_get_slice>
 8004a1e:	4603      	mov	r3, r0
 8004a20:	b2da      	uxtb	r2, r3
 8004a22:	9b00      	ldr	r3, [sp, #0]
 8004a24:	77da      	strb	r2, [r3, #31]
  csdmmc->crc                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_CRC_SLICE);
 8004a26:	9803      	ldr	r0, [sp, #12]
 8004a28:	2107      	movs	r1, #7
 8004a2a:	2201      	movs	r2, #1
 8004a2c:	f7ff fe28 	bl	8004680 <_mmcsd_get_slice>
 8004a30:	4603      	mov	r3, r0
 8004a32:	b2da      	uxtb	r2, r3
 8004a34:	9b00      	ldr	r3, [sp, #0]
 8004a36:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  csdmmc->csd_structure      = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_CSD_STRUCTURE_SLICE);
 8004a3a:	9803      	ldr	r0, [sp, #12]
 8004a3c:	217f      	movs	r1, #127	; 0x7f
 8004a3e:	227e      	movs	r2, #126	; 0x7e
 8004a40:	f7ff fe1e 	bl	8004680 <_mmcsd_get_slice>
 8004a44:	4603      	mov	r3, r0
 8004a46:	b2da      	uxtb	r2, r3
 8004a48:	9b00      	ldr	r3, [sp, #0]
 8004a4a:	701a      	strb	r2, [r3, #0]
  csdmmc->dsr_imp            = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_DSR_IMP_SLICE);
 8004a4c:	9803      	ldr	r0, [sp, #12]
 8004a4e:	214c      	movs	r1, #76	; 0x4c
 8004a50:	224c      	movs	r2, #76	; 0x4c
 8004a52:	f7ff fe15 	bl	8004680 <_mmcsd_get_slice>
 8004a56:	4603      	mov	r3, r0
 8004a58:	b2da      	uxtb	r2, r3
 8004a5a:	9b00      	ldr	r3, [sp, #0]
 8004a5c:	731a      	strb	r2, [r3, #12]
  csdmmc->ecc                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_ECC_SLICE);
 8004a5e:	9803      	ldr	r0, [sp, #12]
 8004a60:	2109      	movs	r1, #9
 8004a62:	2208      	movs	r2, #8
 8004a64:	f7ff fe0c 	bl	8004680 <_mmcsd_get_slice>
 8004a68:	4603      	mov	r3, r0
 8004a6a:	b2da      	uxtb	r2, r3
 8004a6c:	9b00      	ldr	r3, [sp, #0]
 8004a6e:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
  csdmmc->erase_grp_mult     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_ERASE_GRP_MULT_SLICE);
 8004a72:	9803      	ldr	r0, [sp, #12]
 8004a74:	2129      	movs	r1, #41	; 0x29
 8004a76:	2225      	movs	r2, #37	; 0x25
 8004a78:	f7ff fe02 	bl	8004680 <_mmcsd_get_slice>
 8004a7c:	4603      	mov	r3, r0
 8004a7e:	b2da      	uxtb	r2, r3
 8004a80:	9b00      	ldr	r3, [sp, #0]
 8004a82:	759a      	strb	r2, [r3, #22]
  csdmmc->erase_grp_size     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_ERASE_GRP_SIZE_SLICE);
 8004a84:	9803      	ldr	r0, [sp, #12]
 8004a86:	212e      	movs	r1, #46	; 0x2e
 8004a88:	222a      	movs	r2, #42	; 0x2a
 8004a8a:	f7ff fdf9 	bl	8004680 <_mmcsd_get_slice>
 8004a8e:	4603      	mov	r3, r0
 8004a90:	b2da      	uxtb	r2, r3
 8004a92:	9b00      	ldr	r3, [sp, #0]
 8004a94:	755a      	strb	r2, [r3, #21]
  csdmmc->file_format        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_FILE_FORMAT_SLICE);
 8004a96:	9803      	ldr	r0, [sp, #12]
 8004a98:	210b      	movs	r1, #11
 8004a9a:	220a      	movs	r2, #10
 8004a9c:	f7ff fdf0 	bl	8004680 <_mmcsd_get_slice>
 8004aa0:	4603      	mov	r3, r0
 8004aa2:	b2da      	uxtb	r2, r3
 8004aa4:	9b00      	ldr	r3, [sp, #0]
 8004aa6:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  csdmmc->file_format_grp    = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_FILE_FORMAT_GRP_SLICE);
 8004aaa:	9803      	ldr	r0, [sp, #12]
 8004aac:	210f      	movs	r1, #15
 8004aae:	220f      	movs	r2, #15
 8004ab0:	f7ff fde6 	bl	8004680 <_mmcsd_get_slice>
 8004ab4:	4603      	mov	r3, r0
 8004ab6:	b2da      	uxtb	r2, r3
 8004ab8:	9b00      	ldr	r3, [sp, #0]
 8004aba:	779a      	strb	r2, [r3, #30]
  csdmmc->nsac               = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_NSAC_SLICE);
 8004abc:	9803      	ldr	r0, [sp, #12]
 8004abe:	216f      	movs	r1, #111	; 0x6f
 8004ac0:	2268      	movs	r2, #104	; 0x68
 8004ac2:	f7ff fddd 	bl	8004680 <_mmcsd_get_slice>
 8004ac6:	4603      	mov	r3, r0
 8004ac8:	b2da      	uxtb	r2, r3
 8004aca:	9b00      	ldr	r3, [sp, #0]
 8004acc:	70da      	strb	r2, [r3, #3]
  csdmmc->perm_write_protect = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_PERM_WRITE_PROTECT_SLICE);
 8004ace:	9803      	ldr	r0, [sp, #12]
 8004ad0:	210d      	movs	r1, #13
 8004ad2:	220d      	movs	r2, #13
 8004ad4:	f7ff fdd4 	bl	8004680 <_mmcsd_get_slice>
 8004ad8:	4603      	mov	r3, r0
 8004ada:	b2da      	uxtb	r2, r3
 8004adc:	9b00      	ldr	r3, [sp, #0]
 8004ade:	f883 2020 	strb.w	r2, [r3, #32]
  csdmmc->r2w_factor         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_R2W_FACTOR_SLICE);
 8004ae2:	9803      	ldr	r0, [sp, #12]
 8004ae4:	211c      	movs	r1, #28
 8004ae6:	221a      	movs	r2, #26
 8004ae8:	f7ff fdca 	bl	8004680 <_mmcsd_get_slice>
 8004aec:	4603      	mov	r3, r0
 8004aee:	b2da      	uxtb	r2, r3
 8004af0:	9b00      	ldr	r3, [sp, #0]
 8004af2:	769a      	strb	r2, [r3, #26]
  csdmmc->read_bl_len        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_READ_BL_LEN_SLICE);
 8004af4:	9803      	ldr	r0, [sp, #12]
 8004af6:	2153      	movs	r1, #83	; 0x53
 8004af8:	2250      	movs	r2, #80	; 0x50
 8004afa:	f7ff fdc1 	bl	8004680 <_mmcsd_get_slice>
 8004afe:	4603      	mov	r3, r0
 8004b00:	b2da      	uxtb	r2, r3
 8004b02:	9b00      	ldr	r3, [sp, #0]
 8004b04:	721a      	strb	r2, [r3, #8]
  csdmmc->read_bl_partial    = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_READ_BL_PARTIAL_SLICE);
 8004b06:	9803      	ldr	r0, [sp, #12]
 8004b08:	214f      	movs	r1, #79	; 0x4f
 8004b0a:	224f      	movs	r2, #79	; 0x4f
 8004b0c:	f7ff fdb8 	bl	8004680 <_mmcsd_get_slice>
 8004b10:	4603      	mov	r3, r0
 8004b12:	b2da      	uxtb	r2, r3
 8004b14:	9b00      	ldr	r3, [sp, #0]
 8004b16:	725a      	strb	r2, [r3, #9]
  csdmmc->read_blk_misalign  = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_READ_BLK_MISALIGN_SLICE);
 8004b18:	9803      	ldr	r0, [sp, #12]
 8004b1a:	214d      	movs	r1, #77	; 0x4d
 8004b1c:	224d      	movs	r2, #77	; 0x4d
 8004b1e:	f7ff fdaf 	bl	8004680 <_mmcsd_get_slice>
 8004b22:	4603      	mov	r3, r0
 8004b24:	b2da      	uxtb	r2, r3
 8004b26:	9b00      	ldr	r3, [sp, #0]
 8004b28:	72da      	strb	r2, [r3, #11]
  csdmmc->spec_vers          = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_SPEC_VERS_SLICE);
 8004b2a:	9803      	ldr	r0, [sp, #12]
 8004b2c:	217d      	movs	r1, #125	; 0x7d
 8004b2e:	227a      	movs	r2, #122	; 0x7a
 8004b30:	f7ff fda6 	bl	8004680 <_mmcsd_get_slice>
 8004b34:	4603      	mov	r3, r0
 8004b36:	b2da      	uxtb	r2, r3
 8004b38:	9b00      	ldr	r3, [sp, #0]
 8004b3a:	705a      	strb	r2, [r3, #1]
  csdmmc->taac               = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_TAAC_SLICE);
 8004b3c:	9803      	ldr	r0, [sp, #12]
 8004b3e:	2177      	movs	r1, #119	; 0x77
 8004b40:	2270      	movs	r2, #112	; 0x70
 8004b42:	f7ff fd9d 	bl	8004680 <_mmcsd_get_slice>
 8004b46:	4603      	mov	r3, r0
 8004b48:	b2da      	uxtb	r2, r3
 8004b4a:	9b00      	ldr	r3, [sp, #0]
 8004b4c:	709a      	strb	r2, [r3, #2]
  csdmmc->tmp_write_protect  = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_TMP_WRITE_PROTECT_SLICE);
 8004b4e:	9803      	ldr	r0, [sp, #12]
 8004b50:	210c      	movs	r1, #12
 8004b52:	220c      	movs	r2, #12
 8004b54:	f7ff fd94 	bl	8004680 <_mmcsd_get_slice>
 8004b58:	4603      	mov	r3, r0
 8004b5a:	b2da      	uxtb	r2, r3
 8004b5c:	9b00      	ldr	r3, [sp, #0]
 8004b5e:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  csdmmc->tran_speed         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_TRAN_SPEED_SLICE);
 8004b62:	9803      	ldr	r0, [sp, #12]
 8004b64:	2167      	movs	r1, #103	; 0x67
 8004b66:	2260      	movs	r2, #96	; 0x60
 8004b68:	f7ff fd8a 	bl	8004680 <_mmcsd_get_slice>
 8004b6c:	4603      	mov	r3, r0
 8004b6e:	b2da      	uxtb	r2, r3
 8004b70:	9b00      	ldr	r3, [sp, #0]
 8004b72:	711a      	strb	r2, [r3, #4]
  csdmmc->vdd_r_curr_max     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_VDD_R_CURR_MAX_SLICE);
 8004b74:	9803      	ldr	r0, [sp, #12]
 8004b76:	213a      	movs	r1, #58	; 0x3a
 8004b78:	2238      	movs	r2, #56	; 0x38
 8004b7a:	f7ff fd81 	bl	8004680 <_mmcsd_get_slice>
 8004b7e:	4603      	mov	r3, r0
 8004b80:	b2da      	uxtb	r2, r3
 8004b82:	9b00      	ldr	r3, [sp, #0]
 8004b84:	745a      	strb	r2, [r3, #17]
  csdmmc->vdd_r_curr_min     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_VDD_R_CURR_MIN_SLICE);
 8004b86:	9803      	ldr	r0, [sp, #12]
 8004b88:	213d      	movs	r1, #61	; 0x3d
 8004b8a:	223b      	movs	r2, #59	; 0x3b
 8004b8c:	f7ff fd78 	bl	8004680 <_mmcsd_get_slice>
 8004b90:	4603      	mov	r3, r0
 8004b92:	b2da      	uxtb	r2, r3
 8004b94:	9b00      	ldr	r3, [sp, #0]
 8004b96:	741a      	strb	r2, [r3, #16]
  csdmmc->vdd_w_curr_max     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_VDD_W_CURR_MAX_SLICE);
 8004b98:	9803      	ldr	r0, [sp, #12]
 8004b9a:	2134      	movs	r1, #52	; 0x34
 8004b9c:	2232      	movs	r2, #50	; 0x32
 8004b9e:	f7ff fd6f 	bl	8004680 <_mmcsd_get_slice>
 8004ba2:	4603      	mov	r3, r0
 8004ba4:	b2da      	uxtb	r2, r3
 8004ba6:	9b00      	ldr	r3, [sp, #0]
 8004ba8:	74da      	strb	r2, [r3, #19]
  csdmmc->vdd_w_curr_min     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_VDD_W_CURR_MIN_SLICE);
 8004baa:	9803      	ldr	r0, [sp, #12]
 8004bac:	2137      	movs	r1, #55	; 0x37
 8004bae:	2235      	movs	r2, #53	; 0x35
 8004bb0:	f7ff fd66 	bl	8004680 <_mmcsd_get_slice>
 8004bb4:	4603      	mov	r3, r0
 8004bb6:	b2da      	uxtb	r2, r3
 8004bb8:	9b00      	ldr	r3, [sp, #0]
 8004bba:	749a      	strb	r2, [r3, #18]
  csdmmc->wp_grp_enable      = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_WP_GRP_ENABLE_SLICE);
 8004bbc:	9803      	ldr	r0, [sp, #12]
 8004bbe:	211f      	movs	r1, #31
 8004bc0:	221f      	movs	r2, #31
 8004bc2:	f7ff fd5d 	bl	8004680 <_mmcsd_get_slice>
 8004bc6:	4603      	mov	r3, r0
 8004bc8:	b2da      	uxtb	r2, r3
 8004bca:	9b00      	ldr	r3, [sp, #0]
 8004bcc:	761a      	strb	r2, [r3, #24]
  csdmmc->wp_grp_size        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_WP_GRP_SIZE_SLICE);
 8004bce:	9803      	ldr	r0, [sp, #12]
 8004bd0:	2124      	movs	r1, #36	; 0x24
 8004bd2:	2220      	movs	r2, #32
 8004bd4:	f7ff fd54 	bl	8004680 <_mmcsd_get_slice>
 8004bd8:	4603      	mov	r3, r0
 8004bda:	b2da      	uxtb	r2, r3
 8004bdc:	9b00      	ldr	r3, [sp, #0]
 8004bde:	75da      	strb	r2, [r3, #23]
  csdmmc->write_bl_len       = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_WRITE_BL_LEN_SLICE);
 8004be0:	9803      	ldr	r0, [sp, #12]
 8004be2:	2119      	movs	r1, #25
 8004be4:	2216      	movs	r2, #22
 8004be6:	f7ff fd4b 	bl	8004680 <_mmcsd_get_slice>
 8004bea:	4603      	mov	r3, r0
 8004bec:	b2da      	uxtb	r2, r3
 8004bee:	9b00      	ldr	r3, [sp, #0]
 8004bf0:	76da      	strb	r2, [r3, #27]
  csdmmc->write_bl_partial   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_WRITE_BL_PARTIAL_SLICE);
 8004bf2:	9803      	ldr	r0, [sp, #12]
 8004bf4:	2115      	movs	r1, #21
 8004bf6:	2215      	movs	r2, #21
 8004bf8:	f7ff fd42 	bl	8004680 <_mmcsd_get_slice>
 8004bfc:	4603      	mov	r3, r0
 8004bfe:	b2da      	uxtb	r2, r3
 8004c00:	9b00      	ldr	r3, [sp, #0]
 8004c02:	771a      	strb	r2, [r3, #28]
  csdmmc->write_blk_misalign = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_WRITE_BLK_MISALIGN_SLICE);
 8004c04:	9803      	ldr	r0, [sp, #12]
 8004c06:	214e      	movs	r1, #78	; 0x4e
 8004c08:	224e      	movs	r2, #78	; 0x4e
 8004c0a:	f7ff fd39 	bl	8004680 <_mmcsd_get_slice>
 8004c0e:	4603      	mov	r3, r0
 8004c10:	b2da      	uxtb	r2, r3
 8004c12:	9b00      	ldr	r3, [sp, #0]
 8004c14:	729a      	strb	r2, [r3, #10]
}
 8004c16:	b005      	add	sp, #20
 8004c18:	f85d fb04 	ldr.w	pc, [sp], #4
 8004c1c:	f3af 8000 	nop.w

08004c20 <_mmcsd_unpack_csd_v10>:
 * @param[out] csd10    pointer to the @p unpacked_sdc_csd_10_t object
 *
 * @notapi
 */
void _mmcsd_unpack_csd_v10(const MMCSDBlockDevice *sdcp,
                           unpacked_sdc_csd_10_t *csd10) {
 8004c20:	b500      	push	{lr}
 8004c22:	b085      	sub	sp, #20
 8004c24:	9001      	str	r0, [sp, #4]
 8004c26:	9100      	str	r1, [sp, #0]
  const uint32_t *csd;

  osalDbgCheck(NULL != sdcp);

  csd = sdcp->csd;
 8004c28:	9b01      	ldr	r3, [sp, #4]
 8004c2a:	3318      	adds	r3, #24
 8004c2c:	9303      	str	r3, [sp, #12]
  csd10->c_size              = (uint16_t)_mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_SLICE);
 8004c2e:	9803      	ldr	r0, [sp, #12]
 8004c30:	2149      	movs	r1, #73	; 0x49
 8004c32:	223e      	movs	r2, #62	; 0x3e
 8004c34:	f7ff fd24 	bl	8004680 <_mmcsd_get_slice>
 8004c38:	4603      	mov	r3, r0
 8004c3a:	b29a      	uxth	r2, r3
 8004c3c:	9b00      	ldr	r3, [sp, #0]
 8004c3e:	819a      	strh	r2, [r3, #12]
  csd10->c_size_mult         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_MULT_SLICE);
 8004c40:	9803      	ldr	r0, [sp, #12]
 8004c42:	2131      	movs	r1, #49	; 0x31
 8004c44:	222f      	movs	r2, #47	; 0x2f
 8004c46:	f7ff fd1b 	bl	8004680 <_mmcsd_get_slice>
 8004c4a:	4603      	mov	r3, r0
 8004c4c:	b2da      	uxtb	r2, r3
 8004c4e:	9b00      	ldr	r3, [sp, #0]
 8004c50:	749a      	strb	r2, [r3, #18]
  csd10->ccc                 = (uint16_t)_mmcsd_get_slice(csd, MMCSD_CSD_10_CCC_SLICE);
 8004c52:	9803      	ldr	r0, [sp, #12]
 8004c54:	215f      	movs	r1, #95	; 0x5f
 8004c56:	2254      	movs	r2, #84	; 0x54
 8004c58:	f7ff fd12 	bl	8004680 <_mmcsd_get_slice>
 8004c5c:	4603      	mov	r3, r0
 8004c5e:	b29a      	uxth	r2, r3
 8004c60:	9b00      	ldr	r3, [sp, #0]
 8004c62:	809a      	strh	r2, [r3, #4]
  csd10->copy                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_COPY_SLICE);
 8004c64:	9803      	ldr	r0, [sp, #12]
 8004c66:	210e      	movs	r1, #14
 8004c68:	220e      	movs	r2, #14
 8004c6a:	f7ff fd09 	bl	8004680 <_mmcsd_get_slice>
 8004c6e:	4603      	mov	r3, r0
 8004c70:	b2da      	uxtb	r2, r3
 8004c72:	9b00      	ldr	r3, [sp, #0]
 8004c74:	76da      	strb	r2, [r3, #27]
  csd10->crc                 = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_CRC_SLICE);
 8004c76:	9803      	ldr	r0, [sp, #12]
 8004c78:	2107      	movs	r1, #7
 8004c7a:	2201      	movs	r2, #1
 8004c7c:	f7ff fd00 	bl	8004680 <_mmcsd_get_slice>
 8004c80:	4603      	mov	r3, r0
 8004c82:	b2da      	uxtb	r2, r3
 8004c84:	9b00      	ldr	r3, [sp, #0]
 8004c86:	77da      	strb	r2, [r3, #31]
  csd10->csd_structure       = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE);
 8004c88:	9803      	ldr	r0, [sp, #12]
 8004c8a:	217f      	movs	r1, #127	; 0x7f
 8004c8c:	227e      	movs	r2, #126	; 0x7e
 8004c8e:	f7ff fcf7 	bl	8004680 <_mmcsd_get_slice>
 8004c92:	4603      	mov	r3, r0
 8004c94:	b2da      	uxtb	r2, r3
 8004c96:	9b00      	ldr	r3, [sp, #0]
 8004c98:	701a      	strb	r2, [r3, #0]
  csd10->dsr_imp             = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_DSR_IMP_SLICE);
 8004c9a:	9803      	ldr	r0, [sp, #12]
 8004c9c:	214c      	movs	r1, #76	; 0x4c
 8004c9e:	224c      	movs	r2, #76	; 0x4c
 8004ca0:	f7ff fcee 	bl	8004680 <_mmcsd_get_slice>
 8004ca4:	4603      	mov	r3, r0
 8004ca6:	b2da      	uxtb	r2, r3
 8004ca8:	9b00      	ldr	r3, [sp, #0]
 8004caa:	729a      	strb	r2, [r3, #10]
  csd10->erase_blk_en        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_ERASE_BLK_EN_SLICE);
 8004cac:	9803      	ldr	r0, [sp, #12]
 8004cae:	212e      	movs	r1, #46	; 0x2e
 8004cb0:	222e      	movs	r2, #46	; 0x2e
 8004cb2:	f7ff fce5 	bl	8004680 <_mmcsd_get_slice>
 8004cb6:	4603      	mov	r3, r0
 8004cb8:	b2da      	uxtb	r2, r3
 8004cba:	9b00      	ldr	r3, [sp, #0]
 8004cbc:	74da      	strb	r2, [r3, #19]
  csd10->erase_sector_size   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_ERASE_SECTOR_SIZE_SLICE);
 8004cbe:	9803      	ldr	r0, [sp, #12]
 8004cc0:	212d      	movs	r1, #45	; 0x2d
 8004cc2:	2227      	movs	r2, #39	; 0x27
 8004cc4:	f7ff fcdc 	bl	8004680 <_mmcsd_get_slice>
 8004cc8:	4603      	mov	r3, r0
 8004cca:	b2da      	uxtb	r2, r3
 8004ccc:	9b00      	ldr	r3, [sp, #0]
 8004cce:	751a      	strb	r2, [r3, #20]
  csd10->file_format         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_FILE_FORMAT_SLICE);
 8004cd0:	9803      	ldr	r0, [sp, #12]
 8004cd2:	210b      	movs	r1, #11
 8004cd4:	220a      	movs	r2, #10
 8004cd6:	f7ff fcd3 	bl	8004680 <_mmcsd_get_slice>
 8004cda:	4603      	mov	r3, r0
 8004cdc:	b2da      	uxtb	r2, r3
 8004cde:	9b00      	ldr	r3, [sp, #0]
 8004ce0:	779a      	strb	r2, [r3, #30]
  csd10->file_format_grp     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_FILE_FORMAT_GRP_SLICE);
 8004ce2:	9803      	ldr	r0, [sp, #12]
 8004ce4:	210f      	movs	r1, #15
 8004ce6:	220f      	movs	r2, #15
 8004ce8:	f7ff fcca 	bl	8004680 <_mmcsd_get_slice>
 8004cec:	4603      	mov	r3, r0
 8004cee:	b2da      	uxtb	r2, r3
 8004cf0:	9b00      	ldr	r3, [sp, #0]
 8004cf2:	769a      	strb	r2, [r3, #26]
  csd10->nsac                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_NSAC_SLICE);
 8004cf4:	9803      	ldr	r0, [sp, #12]
 8004cf6:	216f      	movs	r1, #111	; 0x6f
 8004cf8:	2268      	movs	r2, #104	; 0x68
 8004cfa:	f7ff fcc1 	bl	8004680 <_mmcsd_get_slice>
 8004cfe:	4603      	mov	r3, r0
 8004d00:	b2da      	uxtb	r2, r3
 8004d02:	9b00      	ldr	r3, [sp, #0]
 8004d04:	709a      	strb	r2, [r3, #2]
  csd10->perm_write_protect  = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_PERM_WRITE_PROTECT_SLICE);
 8004d06:	9803      	ldr	r0, [sp, #12]
 8004d08:	210d      	movs	r1, #13
 8004d0a:	220d      	movs	r2, #13
 8004d0c:	f7ff fcb8 	bl	8004680 <_mmcsd_get_slice>
 8004d10:	4603      	mov	r3, r0
 8004d12:	b2da      	uxtb	r2, r3
 8004d14:	9b00      	ldr	r3, [sp, #0]
 8004d16:	771a      	strb	r2, [r3, #28]
  csd10->r2w_factor          = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_R2W_FACTOR_SLICE);
 8004d18:	9803      	ldr	r0, [sp, #12]
 8004d1a:	211c      	movs	r1, #28
 8004d1c:	221a      	movs	r2, #26
 8004d1e:	f7ff fcaf 	bl	8004680 <_mmcsd_get_slice>
 8004d22:	4603      	mov	r3, r0
 8004d24:	b2da      	uxtb	r2, r3
 8004d26:	9b00      	ldr	r3, [sp, #0]
 8004d28:	75da      	strb	r2, [r3, #23]
  csd10->read_bl_len         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_LEN_SLICE);
 8004d2a:	9803      	ldr	r0, [sp, #12]
 8004d2c:	2153      	movs	r1, #83	; 0x53
 8004d2e:	2250      	movs	r2, #80	; 0x50
 8004d30:	f7ff fca6 	bl	8004680 <_mmcsd_get_slice>
 8004d34:	4603      	mov	r3, r0
 8004d36:	b2da      	uxtb	r2, r3
 8004d38:	9b00      	ldr	r3, [sp, #0]
 8004d3a:	719a      	strb	r2, [r3, #6]
  csd10->read_bl_partial     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_PARTIAL_SLICE);
 8004d3c:	9803      	ldr	r0, [sp, #12]
 8004d3e:	214f      	movs	r1, #79	; 0x4f
 8004d40:	224f      	movs	r2, #79	; 0x4f
 8004d42:	f7ff fc9d 	bl	8004680 <_mmcsd_get_slice>
 8004d46:	4603      	mov	r3, r0
 8004d48:	b2da      	uxtb	r2, r3
 8004d4a:	9b00      	ldr	r3, [sp, #0]
 8004d4c:	71da      	strb	r2, [r3, #7]
  csd10->read_blk_misalign   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BLK_MISALIGN_SLICE);
 8004d4e:	9803      	ldr	r0, [sp, #12]
 8004d50:	214d      	movs	r1, #77	; 0x4d
 8004d52:	224d      	movs	r2, #77	; 0x4d
 8004d54:	f7ff fc94 	bl	8004680 <_mmcsd_get_slice>
 8004d58:	4603      	mov	r3, r0
 8004d5a:	b2da      	uxtb	r2, r3
 8004d5c:	9b00      	ldr	r3, [sp, #0]
 8004d5e:	725a      	strb	r2, [r3, #9]
  csd10->taac                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_TAAC_SLICE);
 8004d60:	9803      	ldr	r0, [sp, #12]
 8004d62:	2177      	movs	r1, #119	; 0x77
 8004d64:	2270      	movs	r2, #112	; 0x70
 8004d66:	f7ff fc8b 	bl	8004680 <_mmcsd_get_slice>
 8004d6a:	4603      	mov	r3, r0
 8004d6c:	b2da      	uxtb	r2, r3
 8004d6e:	9b00      	ldr	r3, [sp, #0]
 8004d70:	705a      	strb	r2, [r3, #1]
  csd10->tmp_write_protect   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_TMP_WRITE_PROTECT_SLICE);
 8004d72:	9803      	ldr	r0, [sp, #12]
 8004d74:	210c      	movs	r1, #12
 8004d76:	220c      	movs	r2, #12
 8004d78:	f7ff fc82 	bl	8004680 <_mmcsd_get_slice>
 8004d7c:	4603      	mov	r3, r0
 8004d7e:	b2da      	uxtb	r2, r3
 8004d80:	9b00      	ldr	r3, [sp, #0]
 8004d82:	775a      	strb	r2, [r3, #29]
  csd10->tran_speed          = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_TRANS_SPEED_SLICE);
 8004d84:	9803      	ldr	r0, [sp, #12]
 8004d86:	2167      	movs	r1, #103	; 0x67
 8004d88:	2260      	movs	r2, #96	; 0x60
 8004d8a:	f7ff fc79 	bl	8004680 <_mmcsd_get_slice>
 8004d8e:	4603      	mov	r3, r0
 8004d90:	b2da      	uxtb	r2, r3
 8004d92:	9b00      	ldr	r3, [sp, #0]
 8004d94:	70da      	strb	r2, [r3, #3]
  csd10->wp_grp_enable       = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_WP_GRP_ENABLE_SLICE);
 8004d96:	9803      	ldr	r0, [sp, #12]
 8004d98:	211f      	movs	r1, #31
 8004d9a:	221f      	movs	r2, #31
 8004d9c:	f7ff fc70 	bl	8004680 <_mmcsd_get_slice>
 8004da0:	4603      	mov	r3, r0
 8004da2:	b2da      	uxtb	r2, r3
 8004da4:	9b00      	ldr	r3, [sp, #0]
 8004da6:	759a      	strb	r2, [r3, #22]
  csd10->wp_grp_size         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_WP_GRP_SIZE_SLICE);
 8004da8:	9803      	ldr	r0, [sp, #12]
 8004daa:	2126      	movs	r1, #38	; 0x26
 8004dac:	2220      	movs	r2, #32
 8004dae:	f7ff fc67 	bl	8004680 <_mmcsd_get_slice>
 8004db2:	4603      	mov	r3, r0
 8004db4:	b2da      	uxtb	r2, r3
 8004db6:	9b00      	ldr	r3, [sp, #0]
 8004db8:	755a      	strb	r2, [r3, #21]
  csd10->write_bl_len        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_WRITE_BL_LEN_SLICE);
 8004dba:	9803      	ldr	r0, [sp, #12]
 8004dbc:	2119      	movs	r1, #25
 8004dbe:	220c      	movs	r2, #12
 8004dc0:	f7ff fc5e 	bl	8004680 <_mmcsd_get_slice>
 8004dc4:	4603      	mov	r3, r0
 8004dc6:	b2da      	uxtb	r2, r3
 8004dc8:	9b00      	ldr	r3, [sp, #0]
 8004dca:	761a      	strb	r2, [r3, #24]
  csd10->write_bl_partial    = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_WRITE_BL_PARTIAL_SLICE);
 8004dcc:	9803      	ldr	r0, [sp, #12]
 8004dce:	2115      	movs	r1, #21
 8004dd0:	2215      	movs	r2, #21
 8004dd2:	f7ff fc55 	bl	8004680 <_mmcsd_get_slice>
 8004dd6:	4603      	mov	r3, r0
 8004dd8:	b2da      	uxtb	r2, r3
 8004dda:	9b00      	ldr	r3, [sp, #0]
 8004ddc:	765a      	strb	r2, [r3, #25]
  csd10->write_blk_misalign  = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_WRITE_BLK_MISALIGN_SLICE);
 8004dde:	9803      	ldr	r0, [sp, #12]
 8004de0:	214e      	movs	r1, #78	; 0x4e
 8004de2:	224e      	movs	r2, #78	; 0x4e
 8004de4:	f7ff fc4c 	bl	8004680 <_mmcsd_get_slice>
 8004de8:	4603      	mov	r3, r0
 8004dea:	b2da      	uxtb	r2, r3
 8004dec:	9b00      	ldr	r3, [sp, #0]
 8004dee:	721a      	strb	r2, [r3, #8]
}
 8004df0:	b005      	add	sp, #20
 8004df2:	f85d fb04 	ldr.w	pc, [sp], #4
 8004df6:	bf00      	nop
 8004df8:	f3af 8000 	nop.w
 8004dfc:	f3af 8000 	nop.w

08004e00 <_mmcsd_unpack_csd_v20>:
 * @param[out] csd20    pointer to the @p unpacked_sdc_csd_20_t object
 *
 * @notapi
 */
void _mmcsd_unpack_csd_v20(const MMCSDBlockDevice *sdcp,
                           unpacked_sdc_csd_20_t *csd20) {
 8004e00:	b500      	push	{lr}
 8004e02:	b085      	sub	sp, #20
 8004e04:	9001      	str	r0, [sp, #4]
 8004e06:	9100      	str	r1, [sp, #0]
  const uint32_t *csd;

  osalDbgCheck(NULL != sdcp);

  csd = sdcp->csd;
 8004e08:	9b01      	ldr	r3, [sp, #4]
 8004e0a:	3318      	adds	r3, #24
 8004e0c:	9303      	str	r3, [sp, #12]
  csd20->c_size              =           _mmcsd_get_slice(csd, MMCSD_CSD_20_C_SIZE_SLICE);
 8004e0e:	9803      	ldr	r0, [sp, #12]
 8004e10:	2145      	movs	r1, #69	; 0x45
 8004e12:	2230      	movs	r2, #48	; 0x30
 8004e14:	f7ff fc34 	bl	8004680 <_mmcsd_get_slice>
 8004e18:	4602      	mov	r2, r0
 8004e1a:	9b00      	ldr	r3, [sp, #0]
 8004e1c:	60da      	str	r2, [r3, #12]
  csd20->crc                 = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_CRC_SLICE);
 8004e1e:	9803      	ldr	r0, [sp, #12]
 8004e20:	2107      	movs	r1, #7
 8004e22:	2201      	movs	r2, #1
 8004e24:	f7ff fc2c 	bl	8004680 <_mmcsd_get_slice>
 8004e28:	4603      	mov	r3, r0
 8004e2a:	b2da      	uxtb	r2, r3
 8004e2c:	9b00      	ldr	r3, [sp, #0]
 8004e2e:	771a      	strb	r2, [r3, #28]
  csd20->ccc                 = (uint16_t)_mmcsd_get_slice(csd, MMCSD_CSD_20_CCC_SLICE);
 8004e30:	9803      	ldr	r0, [sp, #12]
 8004e32:	215f      	movs	r1, #95	; 0x5f
 8004e34:	2254      	movs	r2, #84	; 0x54
 8004e36:	f7ff fc23 	bl	8004680 <_mmcsd_get_slice>
 8004e3a:	4603      	mov	r3, r0
 8004e3c:	b29a      	uxth	r2, r3
 8004e3e:	9b00      	ldr	r3, [sp, #0]
 8004e40:	809a      	strh	r2, [r3, #4]
  csd20->copy                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_COPY_SLICE);
 8004e42:	9803      	ldr	r0, [sp, #12]
 8004e44:	210e      	movs	r1, #14
 8004e46:	220e      	movs	r2, #14
 8004e48:	f7ff fc1a 	bl	8004680 <_mmcsd_get_slice>
 8004e4c:	4603      	mov	r3, r0
 8004e4e:	b2da      	uxtb	r2, r3
 8004e50:	9b00      	ldr	r3, [sp, #0]
 8004e52:	761a      	strb	r2, [r3, #24]
  csd20->csd_structure       = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_CSD_STRUCTURE_SLICE);
 8004e54:	9803      	ldr	r0, [sp, #12]
 8004e56:	217f      	movs	r1, #127	; 0x7f
 8004e58:	227e      	movs	r2, #126	; 0x7e
 8004e5a:	f7ff fc11 	bl	8004680 <_mmcsd_get_slice>
 8004e5e:	4603      	mov	r3, r0
 8004e60:	b2da      	uxtb	r2, r3
 8004e62:	9b00      	ldr	r3, [sp, #0]
 8004e64:	701a      	strb	r2, [r3, #0]
  csd20->dsr_imp             = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_DSR_IMP_SLICE);
 8004e66:	9803      	ldr	r0, [sp, #12]
 8004e68:	214c      	movs	r1, #76	; 0x4c
 8004e6a:	224c      	movs	r2, #76	; 0x4c
 8004e6c:	f7ff fc08 	bl	8004680 <_mmcsd_get_slice>
 8004e70:	4603      	mov	r3, r0
 8004e72:	b2da      	uxtb	r2, r3
 8004e74:	9b00      	ldr	r3, [sp, #0]
 8004e76:	729a      	strb	r2, [r3, #10]
  csd20->erase_blk_en        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_ERASE_BLK_EN_SLICE);
 8004e78:	9803      	ldr	r0, [sp, #12]
 8004e7a:	212e      	movs	r1, #46	; 0x2e
 8004e7c:	222e      	movs	r2, #46	; 0x2e
 8004e7e:	f7ff fbff 	bl	8004680 <_mmcsd_get_slice>
 8004e82:	4603      	mov	r3, r0
 8004e84:	b2da      	uxtb	r2, r3
 8004e86:	9b00      	ldr	r3, [sp, #0]
 8004e88:	741a      	strb	r2, [r3, #16]
  csd20->file_format         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_FILE_FORMAT_SLICE);
 8004e8a:	9803      	ldr	r0, [sp, #12]
 8004e8c:	210b      	movs	r1, #11
 8004e8e:	220a      	movs	r2, #10
 8004e90:	f7ff fbf6 	bl	8004680 <_mmcsd_get_slice>
 8004e94:	4603      	mov	r3, r0
 8004e96:	b2da      	uxtb	r2, r3
 8004e98:	9b00      	ldr	r3, [sp, #0]
 8004e9a:	76da      	strb	r2, [r3, #27]
  csd20->file_format_grp     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_FILE_FORMAT_GRP_SLICE);
 8004e9c:	9803      	ldr	r0, [sp, #12]
 8004e9e:	210f      	movs	r1, #15
 8004ea0:	220f      	movs	r2, #15
 8004ea2:	f7ff fbed 	bl	8004680 <_mmcsd_get_slice>
 8004ea6:	4603      	mov	r3, r0
 8004ea8:	b2da      	uxtb	r2, r3
 8004eaa:	9b00      	ldr	r3, [sp, #0]
 8004eac:	75da      	strb	r2, [r3, #23]
  csd20->nsac                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_NSAC_SLICE);
 8004eae:	9803      	ldr	r0, [sp, #12]
 8004eb0:	216f      	movs	r1, #111	; 0x6f
 8004eb2:	2268      	movs	r2, #104	; 0x68
 8004eb4:	f7ff fbe4 	bl	8004680 <_mmcsd_get_slice>
 8004eb8:	4603      	mov	r3, r0
 8004eba:	b2da      	uxtb	r2, r3
 8004ebc:	9b00      	ldr	r3, [sp, #0]
 8004ebe:	709a      	strb	r2, [r3, #2]
  csd20->perm_write_protect  = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_PERM_WRITE_PROTECT_SLICE);
 8004ec0:	9803      	ldr	r0, [sp, #12]
 8004ec2:	210d      	movs	r1, #13
 8004ec4:	220d      	movs	r2, #13
 8004ec6:	f7ff fbdb 	bl	8004680 <_mmcsd_get_slice>
 8004eca:	4603      	mov	r3, r0
 8004ecc:	b2da      	uxtb	r2, r3
 8004ece:	9b00      	ldr	r3, [sp, #0]
 8004ed0:	765a      	strb	r2, [r3, #25]
  csd20->r2w_factor          = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_R2W_FACTOR_SLICE);
 8004ed2:	9803      	ldr	r0, [sp, #12]
 8004ed4:	211c      	movs	r1, #28
 8004ed6:	221a      	movs	r2, #26
 8004ed8:	f7ff fbd2 	bl	8004680 <_mmcsd_get_slice>
 8004edc:	4603      	mov	r3, r0
 8004ede:	b2da      	uxtb	r2, r3
 8004ee0:	9b00      	ldr	r3, [sp, #0]
 8004ee2:	751a      	strb	r2, [r3, #20]
  csd20->read_bl_len         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_READ_BL_LEN_SLICE);
 8004ee4:	9803      	ldr	r0, [sp, #12]
 8004ee6:	2153      	movs	r1, #83	; 0x53
 8004ee8:	2250      	movs	r2, #80	; 0x50
 8004eea:	f7ff fbc9 	bl	8004680 <_mmcsd_get_slice>
 8004eee:	4603      	mov	r3, r0
 8004ef0:	b2da      	uxtb	r2, r3
 8004ef2:	9b00      	ldr	r3, [sp, #0]
 8004ef4:	719a      	strb	r2, [r3, #6]
  csd20->read_bl_partial     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_READ_BL_PARTIAL_SLICE);
 8004ef6:	9803      	ldr	r0, [sp, #12]
 8004ef8:	214f      	movs	r1, #79	; 0x4f
 8004efa:	224f      	movs	r2, #79	; 0x4f
 8004efc:	f7ff fbc0 	bl	8004680 <_mmcsd_get_slice>
 8004f00:	4603      	mov	r3, r0
 8004f02:	b2da      	uxtb	r2, r3
 8004f04:	9b00      	ldr	r3, [sp, #0]
 8004f06:	71da      	strb	r2, [r3, #7]
  csd20->read_blk_misalign   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_READ_BLK_MISALIGN_SLICE);
 8004f08:	9803      	ldr	r0, [sp, #12]
 8004f0a:	214d      	movs	r1, #77	; 0x4d
 8004f0c:	224d      	movs	r2, #77	; 0x4d
 8004f0e:	f7ff fbb7 	bl	8004680 <_mmcsd_get_slice>
 8004f12:	4603      	mov	r3, r0
 8004f14:	b2da      	uxtb	r2, r3
 8004f16:	9b00      	ldr	r3, [sp, #0]
 8004f18:	725a      	strb	r2, [r3, #9]
  csd20->erase_sector_size   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_ERASE_SECTOR_SIZE_SLICE);
 8004f1a:	9803      	ldr	r0, [sp, #12]
 8004f1c:	212d      	movs	r1, #45	; 0x2d
 8004f1e:	2227      	movs	r2, #39	; 0x27
 8004f20:	f7ff fbae 	bl	8004680 <_mmcsd_get_slice>
 8004f24:	4603      	mov	r3, r0
 8004f26:	b2da      	uxtb	r2, r3
 8004f28:	9b00      	ldr	r3, [sp, #0]
 8004f2a:	745a      	strb	r2, [r3, #17]
  csd20->taac                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_TAAC_SLICE);
 8004f2c:	9803      	ldr	r0, [sp, #12]
 8004f2e:	2177      	movs	r1, #119	; 0x77
 8004f30:	2270      	movs	r2, #112	; 0x70
 8004f32:	f7ff fba5 	bl	8004680 <_mmcsd_get_slice>
 8004f36:	4603      	mov	r3, r0
 8004f38:	b2da      	uxtb	r2, r3
 8004f3a:	9b00      	ldr	r3, [sp, #0]
 8004f3c:	705a      	strb	r2, [r3, #1]
  csd20->tmp_write_protect   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_TMP_WRITE_PROTECT_SLICE);
 8004f3e:	9803      	ldr	r0, [sp, #12]
 8004f40:	210c      	movs	r1, #12
 8004f42:	220c      	movs	r2, #12
 8004f44:	f7ff fb9c 	bl	8004680 <_mmcsd_get_slice>
 8004f48:	4603      	mov	r3, r0
 8004f4a:	b2da      	uxtb	r2, r3
 8004f4c:	9b00      	ldr	r3, [sp, #0]
 8004f4e:	769a      	strb	r2, [r3, #26]
  csd20->tran_speed          = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_TRANS_SPEED_SLICE);
 8004f50:	9803      	ldr	r0, [sp, #12]
 8004f52:	2167      	movs	r1, #103	; 0x67
 8004f54:	2260      	movs	r2, #96	; 0x60
 8004f56:	f7ff fb93 	bl	8004680 <_mmcsd_get_slice>
 8004f5a:	4603      	mov	r3, r0
 8004f5c:	b2da      	uxtb	r2, r3
 8004f5e:	9b00      	ldr	r3, [sp, #0]
 8004f60:	70da      	strb	r2, [r3, #3]
  csd20->wp_grp_enable       = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_WP_GRP_ENABLE_SLICE);
 8004f62:	9803      	ldr	r0, [sp, #12]
 8004f64:	211f      	movs	r1, #31
 8004f66:	221f      	movs	r2, #31
 8004f68:	f7ff fb8a 	bl	8004680 <_mmcsd_get_slice>
 8004f6c:	4603      	mov	r3, r0
 8004f6e:	b2da      	uxtb	r2, r3
 8004f70:	9b00      	ldr	r3, [sp, #0]
 8004f72:	74da      	strb	r2, [r3, #19]
  csd20->wp_grp_size         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_WP_GRP_SIZE_SLICE);
 8004f74:	9803      	ldr	r0, [sp, #12]
 8004f76:	2126      	movs	r1, #38	; 0x26
 8004f78:	2220      	movs	r2, #32
 8004f7a:	f7ff fb81 	bl	8004680 <_mmcsd_get_slice>
 8004f7e:	4603      	mov	r3, r0
 8004f80:	b2da      	uxtb	r2, r3
 8004f82:	9b00      	ldr	r3, [sp, #0]
 8004f84:	749a      	strb	r2, [r3, #18]
  csd20->write_bl_len        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_WRITE_BL_LEN_SLICE);
 8004f86:	9803      	ldr	r0, [sp, #12]
 8004f88:	2119      	movs	r1, #25
 8004f8a:	220c      	movs	r2, #12
 8004f8c:	f7ff fb78 	bl	8004680 <_mmcsd_get_slice>
 8004f90:	4603      	mov	r3, r0
 8004f92:	b2da      	uxtb	r2, r3
 8004f94:	9b00      	ldr	r3, [sp, #0]
 8004f96:	755a      	strb	r2, [r3, #21]
  csd20->write_bl_partial    = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_WRITE_BL_PARTIAL_SLICE);
 8004f98:	9803      	ldr	r0, [sp, #12]
 8004f9a:	2115      	movs	r1, #21
 8004f9c:	2215      	movs	r2, #21
 8004f9e:	f7ff fb6f 	bl	8004680 <_mmcsd_get_slice>
 8004fa2:	4603      	mov	r3, r0
 8004fa4:	b2da      	uxtb	r2, r3
 8004fa6:	9b00      	ldr	r3, [sp, #0]
 8004fa8:	759a      	strb	r2, [r3, #22]
  csd20->write_blk_misalign  = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_WRITE_BLK_MISALIGN_SLICE);
 8004faa:	9803      	ldr	r0, [sp, #12]
 8004fac:	214e      	movs	r1, #78	; 0x4e
 8004fae:	224e      	movs	r2, #78	; 0x4e
 8004fb0:	f7ff fb66 	bl	8004680 <_mmcsd_get_slice>
 8004fb4:	4603      	mov	r3, r0
 8004fb6:	b2da      	uxtb	r2, r3
 8004fb8:	9b00      	ldr	r3, [sp, #0]
 8004fba:	721a      	strb	r2, [r3, #8]
}
 8004fbc:	b005      	add	sp, #20
 8004fbe:	f85d fb04 	ldr.w	pc, [sp], #4
 8004fc2:	bf00      	nop
 8004fc4:	f3af 8000 	nop.w
 8004fc8:	f3af 8000 	nop.w
 8004fcc:	f3af 8000 	nop.w

08004fd0 <palReadBus>:
 * @param[in] bus       the I/O bus, pointer to a @p IOBus structure
 * @return              The bus logical states.
 *
 * @special
 */
ioportmask_t palReadBus(IOBus *bus) {
 8004fd0:	b082      	sub	sp, #8
 8004fd2:	9001      	str	r0, [sp, #4]

  osalDbgCheck((bus != NULL) && (bus->offset < PAL_IOPORTS_WIDTH));

  return palReadGroup(bus->portid, bus->mask, bus->offset);
 8004fd4:	9b01      	ldr	r3, [sp, #4]
 8004fd6:	681b      	ldr	r3, [r3, #0]
 8004fd8:	691a      	ldr	r2, [r3, #16]
 8004fda:	9b01      	ldr	r3, [sp, #4]
 8004fdc:	689b      	ldr	r3, [r3, #8]
 8004fde:	40da      	lsrs	r2, r3
 8004fe0:	9b01      	ldr	r3, [sp, #4]
 8004fe2:	685b      	ldr	r3, [r3, #4]
 8004fe4:	4013      	ands	r3, r2
}
 8004fe6:	4618      	mov	r0, r3
 8004fe8:	b002      	add	sp, #8
 8004fea:	4770      	bx	lr
 8004fec:	f3af 8000 	nop.w

08004ff0 <palWriteBus>:
 *                      the bus width are masked so most significant bits are
 *                      lost.
 *
 * @special
 */
void palWriteBus(IOBus *bus, ioportmask_t bits) {
 8004ff0:	b082      	sub	sp, #8
 8004ff2:	9001      	str	r0, [sp, #4]
 8004ff4:	9100      	str	r1, [sp, #0]

  osalDbgCheck((bus != NULL) && (bus->offset < PAL_IOPORTS_WIDTH));

  palWriteGroup(bus->portid, bus->mask, bus->offset, bits);
 8004ff6:	9b01      	ldr	r3, [sp, #4]
 8004ff8:	681b      	ldr	r3, [r3, #0]
 8004ffa:	9a00      	ldr	r2, [sp, #0]
 8004ffc:	43d1      	mvns	r1, r2
 8004ffe:	9a01      	ldr	r2, [sp, #4]
 8005000:	6852      	ldr	r2, [r2, #4]
 8005002:	4011      	ands	r1, r2
 8005004:	9a01      	ldr	r2, [sp, #4]
 8005006:	6892      	ldr	r2, [r2, #8]
 8005008:	3210      	adds	r2, #16
 800500a:	4091      	lsls	r1, r2
 800500c:	9a01      	ldr	r2, [sp, #4]
 800500e:	6850      	ldr	r0, [r2, #4]
 8005010:	9a00      	ldr	r2, [sp, #0]
 8005012:	4010      	ands	r0, r2
 8005014:	9a01      	ldr	r2, [sp, #4]
 8005016:	6892      	ldr	r2, [r2, #8]
 8005018:	fa00 f202 	lsl.w	r2, r0, r2
 800501c:	430a      	orrs	r2, r1
 800501e:	619a      	str	r2, [r3, #24]
}
 8005020:	b002      	add	sp, #8
 8005022:	4770      	bx	lr
 8005024:	f3af 8000 	nop.w
 8005028:	f3af 8000 	nop.w
 800502c:	f3af 8000 	nop.w

08005030 <palSetBusMode>:
 * @param[in] bus       the I/O bus, pointer to a @p IOBus structure
 * @param[in] mode      the mode
 *
 * @special
 */
void palSetBusMode(IOBus *bus, iomode_t mode) {
 8005030:	b500      	push	{lr}
 8005032:	b083      	sub	sp, #12
 8005034:	9001      	str	r0, [sp, #4]
 8005036:	9100      	str	r1, [sp, #0]

  osalDbgCheck((bus != NULL) && (bus->offset < PAL_IOPORTS_WIDTH));

  palSetGroupMode(bus->portid, bus->mask, bus->offset, mode);
 8005038:	9b01      	ldr	r3, [sp, #4]
 800503a:	681a      	ldr	r2, [r3, #0]
 800503c:	9b01      	ldr	r3, [sp, #4]
 800503e:	6859      	ldr	r1, [r3, #4]
 8005040:	9b01      	ldr	r3, [sp, #4]
 8005042:	689b      	ldr	r3, [r3, #8]
 8005044:	fa01 f303 	lsl.w	r3, r1, r3
 8005048:	4610      	mov	r0, r2
 800504a:	4619      	mov	r1, r3
 800504c:	9a00      	ldr	r2, [sp, #0]
 800504e:	f003 f83f 	bl	80080d0 <_pal_lld_setgroupmode>
}
 8005052:	b003      	add	sp, #12
 8005054:	f85d fb04 	ldr.w	pc, [sp], #4
 8005058:	f3af 8000 	nop.w
 800505c:	f3af 8000 	nop.w

08005060 <rtcInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void rtcInit(void) {
 8005060:	b508      	push	{r3, lr}

  rtc_lld_init();
 8005062:	f004 fe9d 	bl	8009da0 <rtc_lld_init>
}
 8005066:	bd08      	pop	{r3, pc}
 8005068:	f3af 8000 	nop.w
 800506c:	f3af 8000 	nop.w

08005070 <rtcObjectInit>:
 *
 * @param[out] rtcp     pointer to RTC driver structure
 *
 * @init
 */
void rtcObjectInit(RTCDriver *rtcp) {
 8005070:	b082      	sub	sp, #8
 8005072:	9001      	str	r0, [sp, #4]
#if RTC_HAS_STORAGE == TRUE
  rtcp->vmt = &_rtc_lld_vmt;
#else
  (void)rtcp;
#endif
}
 8005074:	b002      	add	sp, #8
 8005076:	4770      	bx	lr
 8005078:	f3af 8000 	nop.w
 800507c:	f3af 8000 	nop.w

08005080 <rtcSetTime>:
 * @param[in] rtcp      pointer to RTC driver structure
 * @param[in] timespec  pointer to a @p RTCDateTime structure
 *
 * @special
 */
void rtcSetTime(RTCDriver *rtcp, const RTCDateTime *timespec) {
 8005080:	b500      	push	{lr}
 8005082:	b083      	sub	sp, #12
 8005084:	9001      	str	r0, [sp, #4]
 8005086:	9100      	str	r1, [sp, #0]

  osalDbgCheck((rtcp != NULL) && (timespec != NULL));

  rtc_lld_set_time(rtcp, timespec);
 8005088:	9801      	ldr	r0, [sp, #4]
 800508a:	9900      	ldr	r1, [sp, #0]
 800508c:	f004 fec8 	bl	8009e20 <rtc_lld_set_time>
}
 8005090:	b003      	add	sp, #12
 8005092:	f85d fb04 	ldr.w	pc, [sp], #4
 8005096:	bf00      	nop
 8005098:	f3af 8000 	nop.w
 800509c:	f3af 8000 	nop.w

080050a0 <rtcGetTime>:
 * @param[in] rtcp      pointer to RTC driver structure
 * @param[out] timespec pointer to a @p RTCDateTime structure
 *
 * @special
 */
void rtcGetTime(RTCDriver *rtcp, RTCDateTime *timespec) {
 80050a0:	b500      	push	{lr}
 80050a2:	b083      	sub	sp, #12
 80050a4:	9001      	str	r0, [sp, #4]
 80050a6:	9100      	str	r1, [sp, #0]

  osalDbgCheck((rtcp != NULL) && (timespec != NULL));

  rtc_lld_get_time(rtcp, timespec);
 80050a8:	9801      	ldr	r0, [sp, #4]
 80050aa:	9900      	ldr	r1, [sp, #0]
 80050ac:	f004 fee8 	bl	8009e80 <rtc_lld_get_time>
}
 80050b0:	b003      	add	sp, #12
 80050b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80050b6:	bf00      	nop
 80050b8:	f3af 8000 	nop.w
 80050bc:	f3af 8000 	nop.w

080050c0 <rtcSetAlarm>:
 *
 * @special
 */
void rtcSetAlarm(RTCDriver *rtcp,
                 rtcalarm_t alarm,
                 const RTCAlarm *alarmspec) {
 80050c0:	b500      	push	{lr}
 80050c2:	b085      	sub	sp, #20
 80050c4:	9003      	str	r0, [sp, #12]
 80050c6:	9102      	str	r1, [sp, #8]
 80050c8:	9201      	str	r2, [sp, #4]

  osalDbgCheck((rtcp != NULL) && (alarm < (rtcalarm_t)RTC_ALARMS));

  rtc_lld_set_alarm(rtcp, alarm, alarmspec);
 80050ca:	9803      	ldr	r0, [sp, #12]
 80050cc:	9902      	ldr	r1, [sp, #8]
 80050ce:	9a01      	ldr	r2, [sp, #4]
 80050d0:	f004 ff36 	bl	8009f40 <rtc_lld_set_alarm>
}
 80050d4:	b005      	add	sp, #20
 80050d6:	f85d fb04 	ldr.w	pc, [sp], #4
 80050da:	bf00      	nop
 80050dc:	f3af 8000 	nop.w

080050e0 <rtcGetAlarm>:
 *
 * @special
 */
void rtcGetAlarm(RTCDriver *rtcp,
                 rtcalarm_t alarm,
                 RTCAlarm *alarmspec) {
 80050e0:	b500      	push	{lr}
 80050e2:	b085      	sub	sp, #20
 80050e4:	9003      	str	r0, [sp, #12]
 80050e6:	9102      	str	r1, [sp, #8]
 80050e8:	9201      	str	r2, [sp, #4]

  osalDbgCheck((rtcp != NULL) &&
               (alarm < (rtcalarm_t)RTC_ALARMS) &&
               (alarmspec != NULL));

  rtc_lld_get_alarm(rtcp, alarm, alarmspec);
 80050ea:	9803      	ldr	r0, [sp, #12]
 80050ec:	9902      	ldr	r1, [sp, #8]
 80050ee:	9a01      	ldr	r2, [sp, #4]
 80050f0:	f004 ffae 	bl	800a050 <rtc_lld_get_alarm>
}
 80050f4:	b005      	add	sp, #20
 80050f6:	f85d fb04 	ldr.w	pc, [sp], #4
 80050fa:	bf00      	nop
 80050fc:	f3af 8000 	nop.w

08005100 <rtcConvertDateTimeToStructTm>:
 *
 * @api
 */
void rtcConvertDateTimeToStructTm(const RTCDateTime *timespec,
                                  struct tm *timp,
                                  uint32_t *tv_msec) {
 8005100:	b086      	sub	sp, #24
 8005102:	9003      	str	r0, [sp, #12]
 8005104:	9102      	str	r1, [sp, #8]
 8005106:	9201      	str	r2, [sp, #4]
  int sec;

  timp->tm_year  = (int)timespec->year + (1980 - 1900);
 8005108:	9b03      	ldr	r3, [sp, #12]
 800510a:	781b      	ldrb	r3, [r3, #0]
 800510c:	f103 0250 	add.w	r2, r3, #80	; 0x50
 8005110:	9b02      	ldr	r3, [sp, #8]
 8005112:	615a      	str	r2, [r3, #20]
  timp->tm_mon   = (int)timespec->month - 1;
 8005114:	9b03      	ldr	r3, [sp, #12]
 8005116:	785b      	ldrb	r3, [r3, #1]
 8005118:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800511c:	b2db      	uxtb	r3, r3
 800511e:	1e5a      	subs	r2, r3, #1
 8005120:	9b02      	ldr	r3, [sp, #8]
 8005122:	611a      	str	r2, [r3, #16]
  timp->tm_mday  = (int)timespec->day;
 8005124:	9b03      	ldr	r3, [sp, #12]
 8005126:	789b      	ldrb	r3, [r3, #2]
 8005128:	f3c3 0304 	ubfx	r3, r3, #0, #5
 800512c:	b2db      	uxtb	r3, r3
 800512e:	461a      	mov	r2, r3
 8005130:	9b02      	ldr	r3, [sp, #8]
 8005132:	60da      	str	r2, [r3, #12]
  timp->tm_isdst = (int)timespec->dstflag;
 8005134:	9b03      	ldr	r3, [sp, #12]
 8005136:	785b      	ldrb	r3, [r3, #1]
 8005138:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800513c:	b2db      	uxtb	r3, r3
 800513e:	461a      	mov	r2, r3
 8005140:	9b02      	ldr	r3, [sp, #8]
 8005142:	621a      	str	r2, [r3, #32]
  timp->tm_wday  = (int)timespec->dayofweek - 1;
 8005144:	9b03      	ldr	r3, [sp, #12]
 8005146:	785b      	ldrb	r3, [r3, #1]
 8005148:	f3c3 1342 	ubfx	r3, r3, #5, #3
 800514c:	b2db      	uxtb	r3, r3
 800514e:	1e5a      	subs	r2, r3, #1
 8005150:	9b02      	ldr	r3, [sp, #8]
 8005152:	619a      	str	r2, [r3, #24]

  sec = (int)timespec->millisecond / 1000;
 8005154:	9b03      	ldr	r3, [sp, #12]
 8005156:	685b      	ldr	r3, [r3, #4]
 8005158:	f3c3 031a 	ubfx	r3, r3, #0, #27
 800515c:	4a26      	ldr	r2, [pc, #152]	; (80051f8 <rtcConvertDateTimeToStructTm+0xf8>)
 800515e:	fb82 1203 	smull	r1, r2, r2, r3
 8005162:	1192      	asrs	r2, r2, #6
 8005164:	17db      	asrs	r3, r3, #31
 8005166:	1ad3      	subs	r3, r2, r3
 8005168:	9305      	str	r3, [sp, #20]
  timp->tm_hour = sec / 3600;
 800516a:	9b05      	ldr	r3, [sp, #20]
 800516c:	4a23      	ldr	r2, [pc, #140]	; (80051fc <rtcConvertDateTimeToStructTm+0xfc>)
 800516e:	fb82 1203 	smull	r1, r2, r2, r3
 8005172:	441a      	add	r2, r3
 8005174:	12d2      	asrs	r2, r2, #11
 8005176:	17db      	asrs	r3, r3, #31
 8005178:	1ad2      	subs	r2, r2, r3
 800517a:	9b02      	ldr	r3, [sp, #8]
 800517c:	609a      	str	r2, [r3, #8]
  sec %= 3600;
 800517e:	9b05      	ldr	r3, [sp, #20]
 8005180:	4a1e      	ldr	r2, [pc, #120]	; (80051fc <rtcConvertDateTimeToStructTm+0xfc>)
 8005182:	fb82 1203 	smull	r1, r2, r2, r3
 8005186:	441a      	add	r2, r3
 8005188:	12d1      	asrs	r1, r2, #11
 800518a:	17da      	asrs	r2, r3, #31
 800518c:	1a8a      	subs	r2, r1, r2
 800518e:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 8005192:	fb01 f202 	mul.w	r2, r1, r2
 8005196:	1a9b      	subs	r3, r3, r2
 8005198:	9305      	str	r3, [sp, #20]
  timp->tm_min = sec / 60;
 800519a:	9b05      	ldr	r3, [sp, #20]
 800519c:	4a18      	ldr	r2, [pc, #96]	; (8005200 <rtcConvertDateTimeToStructTm+0x100>)
 800519e:	fb82 1203 	smull	r1, r2, r2, r3
 80051a2:	441a      	add	r2, r3
 80051a4:	1152      	asrs	r2, r2, #5
 80051a6:	17db      	asrs	r3, r3, #31
 80051a8:	1ad2      	subs	r2, r2, r3
 80051aa:	9b02      	ldr	r3, [sp, #8]
 80051ac:	605a      	str	r2, [r3, #4]
  timp->tm_sec = sec % 60;
 80051ae:	9905      	ldr	r1, [sp, #20]
 80051b0:	4b13      	ldr	r3, [pc, #76]	; (8005200 <rtcConvertDateTimeToStructTm+0x100>)
 80051b2:	fb83 2301 	smull	r2, r3, r3, r1
 80051b6:	440b      	add	r3, r1
 80051b8:	115a      	asrs	r2, r3, #5
 80051ba:	17cb      	asrs	r3, r1, #31
 80051bc:	1ad2      	subs	r2, r2, r3
 80051be:	4613      	mov	r3, r2
 80051c0:	011b      	lsls	r3, r3, #4
 80051c2:	1a9b      	subs	r3, r3, r2
 80051c4:	009b      	lsls	r3, r3, #2
 80051c6:	1aca      	subs	r2, r1, r3
 80051c8:	9b02      	ldr	r3, [sp, #8]
 80051ca:	601a      	str	r2, [r3, #0]

  if (NULL != tv_msec) {
 80051cc:	9b01      	ldr	r3, [sp, #4]
 80051ce:	2b00      	cmp	r3, #0
 80051d0:	d00f      	beq.n	80051f2 <rtcConvertDateTimeToStructTm+0xf2>
    *tv_msec = (uint32_t)timespec->millisecond % 1000U;
 80051d2:	9b03      	ldr	r3, [sp, #12]
 80051d4:	685b      	ldr	r3, [r3, #4]
 80051d6:	f3c3 021a 	ubfx	r2, r3, #0, #27
 80051da:	4b07      	ldr	r3, [pc, #28]	; (80051f8 <rtcConvertDateTimeToStructTm+0xf8>)
 80051dc:	fba3 1302 	umull	r1, r3, r3, r2
 80051e0:	099b      	lsrs	r3, r3, #6
 80051e2:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80051e6:	fb01 f303 	mul.w	r3, r1, r3
 80051ea:	1ad3      	subs	r3, r2, r3
 80051ec:	461a      	mov	r2, r3
 80051ee:	9b01      	ldr	r3, [sp, #4]
 80051f0:	601a      	str	r2, [r3, #0]
  }
}
 80051f2:	b006      	add	sp, #24
 80051f4:	4770      	bx	lr
 80051f6:	bf00      	nop
 80051f8:	10624dd3 	.word	0x10624dd3
 80051fc:	91a2b3c5 	.word	0x91a2b3c5
 8005200:	88888889 	.word	0x88888889
 8005204:	f3af 8000 	nop.w
 8005208:	f3af 8000 	nop.w
 800520c:	f3af 8000 	nop.w

08005210 <rtcConvertStructTmToDateTime>:
 *
 * @api
 */
void rtcConvertStructTmToDateTime(const struct tm *timp,
                                  uint32_t tv_msec,
                                  RTCDateTime *timespec) {
 8005210:	b084      	sub	sp, #16
 8005212:	9003      	str	r0, [sp, #12]
 8005214:	9102      	str	r1, [sp, #8]
 8005216:	9201      	str	r2, [sp, #4]

  /*lint -save -e9034 [10.4] Verified assignments to bit fields.*/
  timespec->year      = (uint32_t)timp->tm_year - (1980U - 1900U);
 8005218:	9b03      	ldr	r3, [sp, #12]
 800521a:	695b      	ldr	r3, [r3, #20]
 800521c:	b2db      	uxtb	r3, r3
 800521e:	3b50      	subs	r3, #80	; 0x50
 8005220:	b2d9      	uxtb	r1, r3
 8005222:	9a01      	ldr	r2, [sp, #4]
 8005224:	7813      	ldrb	r3, [r2, #0]
 8005226:	f361 0307 	bfi	r3, r1, #0, #8
 800522a:	7013      	strb	r3, [r2, #0]
  timespec->month     = (uint32_t)timp->tm_mon + 1U;
 800522c:	9b03      	ldr	r3, [sp, #12]
 800522e:	691b      	ldr	r3, [r3, #16]
 8005230:	b2db      	uxtb	r3, r3
 8005232:	3301      	adds	r3, #1
 8005234:	b2db      	uxtb	r3, r3
 8005236:	f003 030f 	and.w	r3, r3, #15
 800523a:	b2d9      	uxtb	r1, r3
 800523c:	9a01      	ldr	r2, [sp, #4]
 800523e:	7853      	ldrb	r3, [r2, #1]
 8005240:	f361 0303 	bfi	r3, r1, #0, #4
 8005244:	7053      	strb	r3, [r2, #1]
  timespec->day       = (uint32_t)timp->tm_mday;
 8005246:	9b03      	ldr	r3, [sp, #12]
 8005248:	68db      	ldr	r3, [r3, #12]
 800524a:	b2db      	uxtb	r3, r3
 800524c:	f003 031f 	and.w	r3, r3, #31
 8005250:	b2d9      	uxtb	r1, r3
 8005252:	9a01      	ldr	r2, [sp, #4]
 8005254:	7893      	ldrb	r3, [r2, #2]
 8005256:	f361 0304 	bfi	r3, r1, #0, #5
 800525a:	7093      	strb	r3, [r2, #2]
  timespec->dayofweek = (uint32_t)timp->tm_wday + 1U;  
 800525c:	9b03      	ldr	r3, [sp, #12]
 800525e:	699b      	ldr	r3, [r3, #24]
 8005260:	b2db      	uxtb	r3, r3
 8005262:	3301      	adds	r3, #1
 8005264:	b2db      	uxtb	r3, r3
 8005266:	f003 0307 	and.w	r3, r3, #7
 800526a:	b2d9      	uxtb	r1, r3
 800526c:	9a01      	ldr	r2, [sp, #4]
 800526e:	7853      	ldrb	r3, [r2, #1]
 8005270:	f361 1347 	bfi	r3, r1, #5, #3
 8005274:	7053      	strb	r3, [r2, #1]
  if (-1 == timp->tm_isdst) {
 8005276:	9b03      	ldr	r3, [sp, #12]
 8005278:	6a1b      	ldr	r3, [r3, #32]
 800527a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800527e:	d105      	bne.n	800528c <rtcConvertStructTmToDateTime+0x7c>
    timespec->dstflag = 0U;  /* set zero if dst is unknown */
 8005280:	9a01      	ldr	r2, [sp, #4]
 8005282:	7853      	ldrb	r3, [r2, #1]
 8005284:	f36f 1304 	bfc	r3, #4, #1
 8005288:	7053      	strb	r3, [r2, #1]
 800528a:	e00a      	b.n	80052a2 <rtcConvertStructTmToDateTime+0x92>
  }
  else {
    timespec->dstflag = (uint32_t)timp->tm_isdst;
 800528c:	9b03      	ldr	r3, [sp, #12]
 800528e:	6a1b      	ldr	r3, [r3, #32]
 8005290:	b2db      	uxtb	r3, r3
 8005292:	f003 0301 	and.w	r3, r3, #1
 8005296:	b2d9      	uxtb	r1, r3
 8005298:	9a01      	ldr	r2, [sp, #4]
 800529a:	7853      	ldrb	r3, [r2, #1]
 800529c:	f361 1304 	bfi	r3, r1, #4, #1
 80052a0:	7053      	strb	r3, [r2, #1]
  }
  /*lint -restore*/
  /*lint -save -e9033 [10.8] Verified assignments to bit fields.*/
  timespec->millisecond = tv_msec + (uint32_t)(((timp->tm_hour * 3600) +
 80052a2:	9b03      	ldr	r3, [sp, #12]
 80052a4:	689b      	ldr	r3, [r3, #8]
 80052a6:	f44f 6261 	mov.w	r2, #3600	; 0xe10
 80052aa:	fb02 f103 	mul.w	r1, r2, r3
                                                (timp->tm_min * 60) +
 80052ae:	9b03      	ldr	r3, [sp, #12]
 80052b0:	685a      	ldr	r2, [r3, #4]
 80052b2:	4613      	mov	r3, r2
 80052b4:	011b      	lsls	r3, r3, #4
 80052b6:	1a9b      	subs	r3, r3, r2
 80052b8:	009b      	lsls	r3, r3, #2
  else {
    timespec->dstflag = (uint32_t)timp->tm_isdst;
  }
  /*lint -restore*/
  /*lint -save -e9033 [10.8] Verified assignments to bit fields.*/
  timespec->millisecond = tv_msec + (uint32_t)(((timp->tm_hour * 3600) +
 80052ba:	18ca      	adds	r2, r1, r3
                                                (timp->tm_min * 60) +
                                                 timp->tm_sec) * 1000);
 80052bc:	9b03      	ldr	r3, [sp, #12]
 80052be:	681b      	ldr	r3, [r3, #0]
    timespec->dstflag = (uint32_t)timp->tm_isdst;
  }
  /*lint -restore*/
  /*lint -save -e9033 [10.8] Verified assignments to bit fields.*/
  timespec->millisecond = tv_msec + (uint32_t)(((timp->tm_hour * 3600) +
                                                (timp->tm_min * 60) +
 80052c0:	4413      	add	r3, r2
                                                 timp->tm_sec) * 1000);
 80052c2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80052c6:	fb02 f303 	mul.w	r3, r2, r3
  else {
    timespec->dstflag = (uint32_t)timp->tm_isdst;
  }
  /*lint -restore*/
  /*lint -save -e9033 [10.8] Verified assignments to bit fields.*/
  timespec->millisecond = tv_msec + (uint32_t)(((timp->tm_hour * 3600) +
 80052ca:	461a      	mov	r2, r3
 80052cc:	9b02      	ldr	r3, [sp, #8]
 80052ce:	4413      	add	r3, r2
 80052d0:	f023 4178 	bic.w	r1, r3, #4160749568	; 0xf8000000
 80052d4:	9a01      	ldr	r2, [sp, #4]
 80052d6:	6853      	ldr	r3, [r2, #4]
 80052d8:	f361 031a 	bfi	r3, r1, #0, #27
 80052dc:	6053      	str	r3, [r2, #4]
                                                (timp->tm_min * 60) +
                                                 timp->tm_sec) * 1000);
  /*lint -restore*/
}
 80052de:	b004      	add	sp, #16
 80052e0:	4770      	bx	lr
 80052e2:	bf00      	nop
 80052e4:	f3af 8000 	nop.w
 80052e8:	f3af 8000 	nop.w
 80052ec:	f3af 8000 	nop.w

080052f0 <rtcConvertDateTimeToFAT>:
 * @param[out] timespec pointer to a @p RTCDateTime structure
 * @return              FAT date/time value
. *
 * @api
 */
uint32_t rtcConvertDateTimeToFAT(const RTCDateTime *timespec) {
 80052f0:	b088      	sub	sp, #32
 80052f2:	9001      	str	r0, [sp, #4]
  uint32_t fattime;
  uint32_t sec, min, hour, day, month;

  sec   = timespec->millisecond / 1000U;
 80052f4:	9b01      	ldr	r3, [sp, #4]
 80052f6:	685b      	ldr	r3, [r3, #4]
 80052f8:	f3c3 021a 	ubfx	r2, r3, #0, #27
 80052fc:	4b39      	ldr	r3, [pc, #228]	; (80053e4 <rtcConvertDateTimeToFAT+0xf4>)
 80052fe:	fba3 1302 	umull	r1, r3, r3, r2
 8005302:	099b      	lsrs	r3, r3, #6
 8005304:	9304      	str	r3, [sp, #16]
  hour  = sec / 3600U;
 8005306:	9a04      	ldr	r2, [sp, #16]
 8005308:	4b37      	ldr	r3, [pc, #220]	; (80053e8 <rtcConvertDateTimeToFAT+0xf8>)
 800530a:	fba3 1302 	umull	r1, r3, r3, r2
 800530e:	0adb      	lsrs	r3, r3, #11
 8005310:	9307      	str	r3, [sp, #28]
  sec  %= 3600U;
 8005312:	9b04      	ldr	r3, [sp, #16]
 8005314:	4a34      	ldr	r2, [pc, #208]	; (80053e8 <rtcConvertDateTimeToFAT+0xf8>)
 8005316:	fba2 1203 	umull	r1, r2, r2, r3
 800531a:	0ad2      	lsrs	r2, r2, #11
 800531c:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 8005320:	fb01 f202 	mul.w	r2, r1, r2
 8005324:	1a9b      	subs	r3, r3, r2
 8005326:	9304      	str	r3, [sp, #16]
  min   = sec / 60U;
 8005328:	9a04      	ldr	r2, [sp, #16]
 800532a:	4b30      	ldr	r3, [pc, #192]	; (80053ec <rtcConvertDateTimeToFAT+0xfc>)
 800532c:	fba3 1302 	umull	r1, r3, r3, r2
 8005330:	095b      	lsrs	r3, r3, #5
 8005332:	9303      	str	r3, [sp, #12]
  sec  %= 60U;
 8005334:	9a04      	ldr	r2, [sp, #16]
 8005336:	4b2d      	ldr	r3, [pc, #180]	; (80053ec <rtcConvertDateTimeToFAT+0xfc>)
 8005338:	fba3 1302 	umull	r1, r3, r3, r2
 800533c:	0959      	lsrs	r1, r3, #5
 800533e:	460b      	mov	r3, r1
 8005340:	011b      	lsls	r3, r3, #4
 8005342:	1a5b      	subs	r3, r3, r1
 8005344:	009b      	lsls	r3, r3, #2
 8005346:	1ad3      	subs	r3, r2, r3
 8005348:	9304      	str	r3, [sp, #16]
  day   = timespec->day;
 800534a:	9b01      	ldr	r3, [sp, #4]
 800534c:	789b      	ldrb	r3, [r3, #2]
 800534e:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8005352:	b2db      	uxtb	r3, r3
 8005354:	9306      	str	r3, [sp, #24]
  month = timespec->month;
 8005356:	9b01      	ldr	r3, [sp, #4]
 8005358:	785b      	ldrb	r3, [r3, #1]
 800535a:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800535e:	b2db      	uxtb	r3, r3
 8005360:	9305      	str	r3, [sp, #20]

  /* handle DST flag */
  if (1U == timespec->dstflag) {
 8005362:	9b01      	ldr	r3, [sp, #4]
 8005364:	785b      	ldrb	r3, [r3, #1]
 8005366:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800536a:	b2db      	uxtb	r3, r3
 800536c:	2b01      	cmp	r3, #1
 800536e:	d117      	bne.n	80053a0 <rtcConvertDateTimeToFAT+0xb0>
    hour += 1U;
 8005370:	9b07      	ldr	r3, [sp, #28]
 8005372:	3301      	adds	r3, #1
 8005374:	9307      	str	r3, [sp, #28]
    if (hour == 24U) {
 8005376:	9b07      	ldr	r3, [sp, #28]
 8005378:	2b18      	cmp	r3, #24
 800537a:	d111      	bne.n	80053a0 <rtcConvertDateTimeToFAT+0xb0>
      hour = 0U;
 800537c:	2300      	movs	r3, #0
 800537e:	9307      	str	r3, [sp, #28]
      day += 1U;
 8005380:	9b06      	ldr	r3, [sp, #24]
 8005382:	3301      	adds	r3, #1
 8005384:	9306      	str	r3, [sp, #24]
      if (day > month_len[month - 1U]) {
 8005386:	9b05      	ldr	r3, [sp, #20]
 8005388:	3b01      	subs	r3, #1
 800538a:	4a19      	ldr	r2, [pc, #100]	; (80053f0 <rtcConvertDateTimeToFAT+0x100>)
 800538c:	5cd3      	ldrb	r3, [r2, r3]
 800538e:	461a      	mov	r2, r3
 8005390:	9b06      	ldr	r3, [sp, #24]
 8005392:	429a      	cmp	r2, r3
 8005394:	d204      	bcs.n	80053a0 <rtcConvertDateTimeToFAT+0xb0>
        day = 1U;
 8005396:	2301      	movs	r3, #1
 8005398:	9306      	str	r3, [sp, #24]
        month += 1U;
 800539a:	9b05      	ldr	r3, [sp, #20]
 800539c:	3301      	adds	r3, #1
 800539e:	9305      	str	r3, [sp, #20]
      }
    }
  }

  fattime  = sec   >> 1U;
 80053a0:	9b04      	ldr	r3, [sp, #16]
 80053a2:	085b      	lsrs	r3, r3, #1
 80053a4:	9302      	str	r3, [sp, #8]
  fattime |= min   << 5U;
 80053a6:	9b03      	ldr	r3, [sp, #12]
 80053a8:	015b      	lsls	r3, r3, #5
 80053aa:	9a02      	ldr	r2, [sp, #8]
 80053ac:	4313      	orrs	r3, r2
 80053ae:	9302      	str	r3, [sp, #8]
  fattime |= hour  << 11U;
 80053b0:	9b07      	ldr	r3, [sp, #28]
 80053b2:	02db      	lsls	r3, r3, #11
 80053b4:	9a02      	ldr	r2, [sp, #8]
 80053b6:	4313      	orrs	r3, r2
 80053b8:	9302      	str	r3, [sp, #8]
  fattime |= day   << 16U;
 80053ba:	9b06      	ldr	r3, [sp, #24]
 80053bc:	041b      	lsls	r3, r3, #16
 80053be:	9a02      	ldr	r2, [sp, #8]
 80053c0:	4313      	orrs	r3, r2
 80053c2:	9302      	str	r3, [sp, #8]
  fattime |= month << 21U;
 80053c4:	9b05      	ldr	r3, [sp, #20]
 80053c6:	055b      	lsls	r3, r3, #21
 80053c8:	9a02      	ldr	r2, [sp, #8]
 80053ca:	4313      	orrs	r3, r2
 80053cc:	9302      	str	r3, [sp, #8]
  fattime |= (uint32_t)timespec->year << 25U;
 80053ce:	9b01      	ldr	r3, [sp, #4]
 80053d0:	781b      	ldrb	r3, [r3, #0]
 80053d2:	065b      	lsls	r3, r3, #25
 80053d4:	9a02      	ldr	r2, [sp, #8]
 80053d6:	4313      	orrs	r3, r2
 80053d8:	9302      	str	r3, [sp, #8]

  return fattime;
 80053da:	9b02      	ldr	r3, [sp, #8]
}
 80053dc:	4618      	mov	r0, r3
 80053de:	b008      	add	sp, #32
 80053e0:	4770      	bx	lr
 80053e2:	bf00      	nop
 80053e4:	10624dd3 	.word	0x10624dd3
 80053e8:	91a2b3c5 	.word	0x91a2b3c5
 80053ec:	88888889 	.word	0x88888889
 80053f0:	08017810 	.word	0x08017810
 80053f4:	f3af 8000 	nop.w
 80053f8:	f3af 8000 	nop.w
 80053fc:	f3af 8000 	nop.w

08005400 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8005400:	b082      	sub	sp, #8
 8005402:	2320      	movs	r3, #32
 8005404:	9301      	str	r3, [sp, #4]
 8005406:	9b01      	ldr	r3, [sp, #4]
 8005408:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800540c:	b002      	add	sp, #8
 800540e:	4770      	bx	lr

08005410 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8005410:	b082      	sub	sp, #8
 8005412:	2300      	movs	r3, #0
 8005414:	9301      	str	r3, [sp, #4]
 8005416:	9b01      	ldr	r3, [sp, #4]
 8005418:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800541c:	b002      	add	sp, #8
 800541e:	4770      	bx	lr

08005420 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8005420:	b508      	push	{r3, lr}

  port_lock();
 8005422:	f7ff ffed 	bl	8005400 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8005426:	bd08      	pop	{r3, pc}
 8005428:	f3af 8000 	nop.w
 800542c:	f3af 8000 	nop.w

08005430 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8005430:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8005432:	f7ff ffed 	bl	8005410 <port_unlock>
}
 8005436:	bd08      	pop	{r3, pc}
 8005438:	f3af 8000 	nop.w
 800543c:	f3af 8000 	nop.w

08005440 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8005440:	b508      	push	{r3, lr}

  chSysLock();
 8005442:	f7ff ffed 	bl	8005420 <chSysLock>
}
 8005446:	bd08      	pop	{r3, pc}
 8005448:	f3af 8000 	nop.w
 800544c:	f3af 8000 	nop.w

08005450 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8005450:	b508      	push	{r3, lr}

  chSysUnlock();
 8005452:	f7ff ffed 	bl	8005430 <chSysUnlock>
}
 8005456:	bd08      	pop	{r3, pc}
 8005458:	f3af 8000 	nop.w
 800545c:	f3af 8000 	nop.w

08005460 <osalThreadSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
static inline void osalThreadSleep(systime_t time) {
 8005460:	b500      	push	{lr}
 8005462:	b083      	sub	sp, #12
 8005464:	9001      	str	r0, [sp, #4]

  chThdSleep(time);
 8005466:	9801      	ldr	r0, [sp, #4]
 8005468:	f7fb ff32 	bl	80012d0 <chThdSleep>
}
 800546c:	b003      	add	sp, #12
 800546e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005472:	bf00      	nop
 8005474:	f3af 8000 	nop.w
 8005478:	f3af 8000 	nop.w
 800547c:	f3af 8000 	nop.w

08005480 <mode_detect>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool mode_detect(SDCDriver *sdcp) {
 8005480:	b500      	push	{lr}
 8005482:	b085      	sub	sp, #20
 8005484:	9001      	str	r0, [sp, #4]
  uint32_t resp[1];

  /* V2.0 cards detection.*/
  if (!sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_IF_COND,
 8005486:	ab03      	add	r3, sp, #12
 8005488:	9801      	ldr	r0, [sp, #4]
 800548a:	2108      	movs	r1, #8
 800548c:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
 8005490:	f005 fa36 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005494:	4603      	mov	r3, r0
 8005496:	f083 0301 	eor.w	r3, r3, #1
 800549a:	b2db      	uxtb	r3, r3
 800549c:	2b00      	cmp	r3, #0
 800549e:	d01a      	beq.n	80054d6 <mode_detect+0x56>
                                  MMCSD_CMD8_PATTERN, resp)) {
    sdcp->cardmode = SDC_MODE_CARDTYPE_SDV20;
 80054a0:	9b01      	ldr	r3, [sp, #4]
 80054a2:	2201      	movs	r2, #1
 80054a4:	631a      	str	r2, [r3, #48]	; 0x30
    /* Voltage verification.*/
    if (((resp[0] >> 8U) & 0xFU) != 1U) {
 80054a6:	9b03      	ldr	r3, [sp, #12]
 80054a8:	0a1b      	lsrs	r3, r3, #8
 80054aa:	f003 030f 	and.w	r3, r3, #15
 80054ae:	2b01      	cmp	r3, #1
 80054b0:	d001      	beq.n	80054b6 <mode_detect+0x36>
      return HAL_FAILED;
 80054b2:	2301      	movs	r3, #1
 80054b4:	e02a      	b.n	800550c <mode_detect+0x8c>
    }
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 80054b6:	ab03      	add	r3, sp, #12
 80054b8:	9801      	ldr	r0, [sp, #4]
 80054ba:	2137      	movs	r1, #55	; 0x37
 80054bc:	2200      	movs	r2, #0
 80054be:	f005 fa1f 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 80054c2:	4603      	mov	r3, r0
 80054c4:	2b00      	cmp	r3, #0
 80054c6:	d104      	bne.n	80054d2 <mode_detect+0x52>
        MMCSD_R1_ERROR(resp[0])) {
 80054c8:	9a03      	ldr	r2, [sp, #12]
 80054ca:	4b12      	ldr	r3, [pc, #72]	; (8005514 <mode_detect+0x94>)
 80054cc:	4013      	ands	r3, r2
    sdcp->cardmode = SDC_MODE_CARDTYPE_SDV20;
    /* Voltage verification.*/
    if (((resp[0] >> 8U) & 0xFU) != 1U) {
      return HAL_FAILED;
    }
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 80054ce:	2b00      	cmp	r3, #0
 80054d0:	d01b      	beq.n	800550a <mode_detect+0x8a>
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
 80054d2:	2301      	movs	r3, #1
 80054d4:	e01a      	b.n	800550c <mode_detect+0x8c>
    }
  }
  else {
    /* MMC or SD V1.1 detection.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 80054d6:	ab03      	add	r3, sp, #12
 80054d8:	9801      	ldr	r0, [sp, #4]
 80054da:	2137      	movs	r1, #55	; 0x37
 80054dc:	2200      	movs	r2, #0
 80054de:	f005 fa0f 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 80054e2:	4603      	mov	r3, r0
 80054e4:	2b00      	cmp	r3, #0
 80054e6:	d104      	bne.n	80054f2 <mode_detect+0x72>
        MMCSD_R1_ERROR(resp[0])) {
 80054e8:	9a03      	ldr	r2, [sp, #12]
 80054ea:	4b0a      	ldr	r3, [pc, #40]	; (8005514 <mode_detect+0x94>)
 80054ec:	4013      	ands	r3, r2
      return HAL_FAILED;
    }
  }
  else {
    /* MMC or SD V1.1 detection.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 80054ee:	2b00      	cmp	r3, #0
 80054f0:	d003      	beq.n	80054fa <mode_detect+0x7a>
        MMCSD_R1_ERROR(resp[0])) {
      sdcp->cardmode = SDC_MODE_CARDTYPE_MMC;
 80054f2:	9b01      	ldr	r3, [sp, #4]
 80054f4:	2202      	movs	r2, #2
 80054f6:	631a      	str	r2, [r3, #48]	; 0x30
 80054f8:	e007      	b.n	800550a <mode_detect+0x8a>
    }
    else {
      sdcp->cardmode = SDC_MODE_CARDTYPE_SDV11;
 80054fa:	9b01      	ldr	r3, [sp, #4]
 80054fc:	2200      	movs	r2, #0
 80054fe:	631a      	str	r2, [r3, #48]	; 0x30
    
      /* Reset error flag illegal command.*/
      sdc_lld_send_cmd_none(sdcp, MMCSD_CMD_GO_IDLE_STATE, 0);
 8005500:	9801      	ldr	r0, [sp, #4]
 8005502:	2100      	movs	r1, #0
 8005504:	2200      	movs	r2, #0
 8005506:	f005 f99b 	bl	800a840 <sdc_lld_send_cmd_none>
    }
  }

  return HAL_SUCCESS;
 800550a:	2300      	movs	r3, #0
}
 800550c:	4618      	mov	r0, r3
 800550e:	b005      	add	sp, #20
 8005510:	f85d fb04 	ldr.w	pc, [sp], #4
 8005514:	fdffe008 	.word	0xfdffe008
 8005518:	f3af 8000 	nop.w
 800551c:	f3af 8000 	nop.w

08005520 <mmc_init>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool mmc_init(SDCDriver *sdcp) {
 8005520:	b500      	push	{lr}
 8005522:	b087      	sub	sp, #28
 8005524:	9001      	str	r0, [sp, #4]
  uint32_t ocr;
  unsigned i;
  uint32_t resp[1];

  ocr = 0xC0FF8000U;
 8005526:	4b18      	ldr	r3, [pc, #96]	; (8005588 <mmc_init+0x68>)
 8005528:	9304      	str	r3, [sp, #16]
  i = 0;
 800552a:	2300      	movs	r3, #0
 800552c:	9305      	str	r3, [sp, #20]
  while (true) {
    if (sdc_lld_send_cmd_short(sdcp, MMCSD_CMD_INIT, ocr, resp)) {
 800552e:	ab03      	add	r3, sp, #12
 8005530:	9801      	ldr	r0, [sp, #4]
 8005532:	2101      	movs	r1, #1
 8005534:	9a04      	ldr	r2, [sp, #16]
 8005536:	f005 f9a3 	bl	800a880 <sdc_lld_send_cmd_short>
 800553a:	4603      	mov	r3, r0
 800553c:	2b00      	cmp	r3, #0
 800553e:	d001      	beq.n	8005544 <mmc_init+0x24>
      return HAL_FAILED;
 8005540:	2301      	movs	r3, #1
 8005542:	e01c      	b.n	800557e <mmc_init+0x5e>
    }
    if ((resp[0] & 0x80000000U) != 0U) {
 8005544:	9b03      	ldr	r3, [sp, #12]
 8005546:	2b00      	cmp	r3, #0
 8005548:	da0c      	bge.n	8005564 <mmc_init+0x44>
      if ((resp[0] & 0x40000000U) != 0U) {
 800554a:	9b03      	ldr	r3, [sp, #12]
 800554c:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8005550:	2b00      	cmp	r3, #0
 8005552:	d006      	beq.n	8005562 <mmc_init+0x42>
        sdcp->cardmode |= SDC_MODE_HIGH_CAPACITY;
 8005554:	9b01      	ldr	r3, [sp, #4]
 8005556:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005558:	f043 0210 	orr.w	r2, r3, #16
 800555c:	9b01      	ldr	r3, [sp, #4]
 800555e:	631a      	str	r2, [r3, #48]	; 0x30
      }
      break;
 8005560:	e00c      	b.n	800557c <mmc_init+0x5c>
 8005562:	e00b      	b.n	800557c <mmc_init+0x5c>
    }
    if (++i >= (unsigned)SDC_INIT_RETRY) {
 8005564:	9b05      	ldr	r3, [sp, #20]
 8005566:	3301      	adds	r3, #1
 8005568:	9305      	str	r3, [sp, #20]
 800556a:	9b05      	ldr	r3, [sp, #20]
 800556c:	2b63      	cmp	r3, #99	; 0x63
 800556e:	d901      	bls.n	8005574 <mmc_init+0x54>
      return HAL_FAILED;
 8005570:	2301      	movs	r3, #1
 8005572:	e004      	b.n	800557e <mmc_init+0x5e>
    }
    osalThreadSleepMilliseconds(10);
 8005574:	200a      	movs	r0, #10
 8005576:	f7ff ff73 	bl	8005460 <osalThreadSleep>
  }
 800557a:	e7d8      	b.n	800552e <mmc_init+0xe>

  return HAL_SUCCESS;
 800557c:	2300      	movs	r3, #0
}
 800557e:	4618      	mov	r0, r3
 8005580:	b007      	add	sp, #28
 8005582:	f85d fb04 	ldr.w	pc, [sp], #4
 8005586:	bf00      	nop
 8005588:	c0ff8000 	.word	0xc0ff8000
 800558c:	f3af 8000 	nop.w

08005590 <sdc_init>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_init(SDCDriver *sdcp) {
 8005590:	b500      	push	{lr}
 8005592:	b087      	sub	sp, #28
 8005594:	9001      	str	r0, [sp, #4]
  unsigned i;
  uint32_t ocr;
  uint32_t resp[1];

  if ((sdcp->cardmode &  SDC_MODE_CARDTYPE_MASK) == SDC_MODE_CARDTYPE_SDV20) {
 8005596:	9b01      	ldr	r3, [sp, #4]
 8005598:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800559a:	f003 030f 	and.w	r3, r3, #15
 800559e:	2b01      	cmp	r3, #1
 80055a0:	d102      	bne.n	80055a8 <sdc_init+0x18>
    ocr = 0xC0100000U;
 80055a2:	4b21      	ldr	r3, [pc, #132]	; (8005628 <sdc_init+0x98>)
 80055a4:	9304      	str	r3, [sp, #16]
 80055a6:	e001      	b.n	80055ac <sdc_init+0x1c>
  }
  else {
    ocr = 0x80100000U;
 80055a8:	4b20      	ldr	r3, [pc, #128]	; (800562c <sdc_init+0x9c>)
 80055aa:	9304      	str	r3, [sp, #16]
  }

  i = 0;
 80055ac:	2300      	movs	r3, #0
 80055ae:	9305      	str	r3, [sp, #20]
  while (true) {
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 80055b0:	ab03      	add	r3, sp, #12
 80055b2:	9801      	ldr	r0, [sp, #4]
 80055b4:	2137      	movs	r1, #55	; 0x37
 80055b6:	2200      	movs	r2, #0
 80055b8:	f005 f9a2 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 80055bc:	4603      	mov	r3, r0
 80055be:	2b00      	cmp	r3, #0
 80055c0:	d104      	bne.n	80055cc <sdc_init+0x3c>
        MMCSD_R1_ERROR(resp[0])) {
 80055c2:	9a03      	ldr	r2, [sp, #12]
 80055c4:	4b1a      	ldr	r3, [pc, #104]	; (8005630 <sdc_init+0xa0>)
 80055c6:	4013      	ands	r3, r2
    ocr = 0x80100000U;
  }

  i = 0;
  while (true) {
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 80055c8:	2b00      	cmp	r3, #0
 80055ca:	d001      	beq.n	80055d0 <sdc_init+0x40>
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
 80055cc:	2301      	movs	r3, #1
 80055ce:	e027      	b.n	8005620 <sdc_init+0x90>
    }
    if (sdc_lld_send_cmd_short(sdcp, MMCSD_CMD_APP_OP_COND, ocr, resp)) {
 80055d0:	ab03      	add	r3, sp, #12
 80055d2:	9801      	ldr	r0, [sp, #4]
 80055d4:	2129      	movs	r1, #41	; 0x29
 80055d6:	9a04      	ldr	r2, [sp, #16]
 80055d8:	f005 f952 	bl	800a880 <sdc_lld_send_cmd_short>
 80055dc:	4603      	mov	r3, r0
 80055de:	2b00      	cmp	r3, #0
 80055e0:	d001      	beq.n	80055e6 <sdc_init+0x56>
      return HAL_FAILED;
 80055e2:	2301      	movs	r3, #1
 80055e4:	e01c      	b.n	8005620 <sdc_init+0x90>
    }
    if ((resp[0] & 0x80000000U) != 0U) {
 80055e6:	9b03      	ldr	r3, [sp, #12]
 80055e8:	2b00      	cmp	r3, #0
 80055ea:	da0c      	bge.n	8005606 <sdc_init+0x76>
      if ((resp[0] & 0x40000000U) != 0U) {
 80055ec:	9b03      	ldr	r3, [sp, #12]
 80055ee:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 80055f2:	2b00      	cmp	r3, #0
 80055f4:	d006      	beq.n	8005604 <sdc_init+0x74>
        sdcp->cardmode |= SDC_MODE_HIGH_CAPACITY;
 80055f6:	9b01      	ldr	r3, [sp, #4]
 80055f8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80055fa:	f043 0210 	orr.w	r2, r3, #16
 80055fe:	9b01      	ldr	r3, [sp, #4]
 8005600:	631a      	str	r2, [r3, #48]	; 0x30
      }
      break;
 8005602:	e00c      	b.n	800561e <sdc_init+0x8e>
 8005604:	e00b      	b.n	800561e <sdc_init+0x8e>
    }
    if (++i >= (unsigned)SDC_INIT_RETRY) {
 8005606:	9b05      	ldr	r3, [sp, #20]
 8005608:	3301      	adds	r3, #1
 800560a:	9305      	str	r3, [sp, #20]
 800560c:	9b05      	ldr	r3, [sp, #20]
 800560e:	2b63      	cmp	r3, #99	; 0x63
 8005610:	d901      	bls.n	8005616 <sdc_init+0x86>
      return HAL_FAILED;
 8005612:	2301      	movs	r3, #1
 8005614:	e004      	b.n	8005620 <sdc_init+0x90>
    }
    osalThreadSleepMilliseconds(10);
 8005616:	200a      	movs	r0, #10
 8005618:	f7ff ff22 	bl	8005460 <osalThreadSleep>
  }
 800561c:	e7c8      	b.n	80055b0 <sdc_init+0x20>

  return HAL_SUCCESS;
 800561e:	2300      	movs	r3, #0
}
 8005620:	4618      	mov	r0, r3
 8005622:	b007      	add	sp, #28
 8005624:	f85d fb04 	ldr.w	pc, [sp], #4
 8005628:	c0100000 	.word	0xc0100000
 800562c:	80100000 	.word	0x80100000
 8005630:	fdffe008 	.word	0xfdffe008
 8005634:	f3af 8000 	nop.w
 8005638:	f3af 8000 	nop.w
 800563c:	f3af 8000 	nop.w

08005640 <mmc_cmd6_construct>:
 * @return              CMD6 argument.
 *
 * @notapi
 */
static uint32_t mmc_cmd6_construct(mmc_switch_t access, uint32_t idx,
                                   uint32_t value, uint32_t cmd_set) {
 8005640:	b084      	sub	sp, #16
 8005642:	9102      	str	r1, [sp, #8]
 8005644:	9201      	str	r2, [sp, #4]
 8005646:	9300      	str	r3, [sp, #0]
 8005648:	4603      	mov	r3, r0
 800564a:	f88d 300f 	strb.w	r3, [sp, #15]

  osalDbgAssert(idx <= 191U, "This field is not writable");
  osalDbgAssert(cmd_set < 8U, "This field has only 3 bits");

  return ((uint32_t)access << 24U) | (idx << 16U) | (value << 8U) | cmd_set;
 800564e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8005652:	061a      	lsls	r2, r3, #24
 8005654:	9b02      	ldr	r3, [sp, #8]
 8005656:	041b      	lsls	r3, r3, #16
 8005658:	431a      	orrs	r2, r3
 800565a:	9b01      	ldr	r3, [sp, #4]
 800565c:	021b      	lsls	r3, r3, #8
 800565e:	431a      	orrs	r2, r3
 8005660:	9b00      	ldr	r3, [sp, #0]
 8005662:	4313      	orrs	r3, r2
}
 8005664:	4618      	mov	r0, r3
 8005666:	b004      	add	sp, #16
 8005668:	4770      	bx	lr
 800566a:	bf00      	nop
 800566c:	f3af 8000 	nop.w

08005670 <sdc_cmd6_construct>:
 *
 * @notapi
 */
static uint32_t sdc_cmd6_construct(sd_switch_t mode,
                                   sd_switch_function_t function,
                                   uint32_t value) {
 8005670:	b084      	sub	sp, #16
 8005672:	460b      	mov	r3, r1
 8005674:	9200      	str	r2, [sp, #0]
 8005676:	4602      	mov	r2, r0
 8005678:	f88d 2007 	strb.w	r2, [sp, #7]
 800567c:	f88d 3006 	strb.w	r3, [sp, #6]
  uint32_t ret = 0xFFFFFF;
 8005680:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8005684:	9303      	str	r3, [sp, #12]

  osalDbgAssert((value < 16U), "This field has only 4 bits");

  ret &= ~((uint32_t)0xFU << ((uint32_t)function * 4U));
 8005686:	f89d 3006 	ldrb.w	r3, [sp, #6]
 800568a:	009b      	lsls	r3, r3, #2
 800568c:	220f      	movs	r2, #15
 800568e:	fa02 f303 	lsl.w	r3, r2, r3
 8005692:	43db      	mvns	r3, r3
 8005694:	9a03      	ldr	r2, [sp, #12]
 8005696:	4013      	ands	r3, r2
 8005698:	9303      	str	r3, [sp, #12]
  ret |= value << ((uint32_t)function * 4U);
 800569a:	f89d 3006 	ldrb.w	r3, [sp, #6]
 800569e:	009b      	lsls	r3, r3, #2
 80056a0:	9a00      	ldr	r2, [sp, #0]
 80056a2:	fa02 f303 	lsl.w	r3, r2, r3
 80056a6:	9a03      	ldr	r2, [sp, #12]
 80056a8:	4313      	orrs	r3, r2
 80056aa:	9303      	str	r3, [sp, #12]
  return ret | ((uint32_t)mode << 31U);
 80056ac:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80056b0:	07da      	lsls	r2, r3, #31
 80056b2:	9b03      	ldr	r3, [sp, #12]
 80056b4:	4313      	orrs	r3, r2
}
 80056b6:	4618      	mov	r0, r3
 80056b8:	b004      	add	sp, #16
 80056ba:	4770      	bx	lr
 80056bc:	f3af 8000 	nop.w

080056c0 <sdc_cmd6_extract_info>:
 * @return              extracted answer.
 *
 * @notapi
 */
static uint16_t sdc_cmd6_extract_info(sd_switch_function_t function,
                                      const uint8_t *buf) {
 80056c0:	b084      	sub	sp, #16
 80056c2:	4603      	mov	r3, r0
 80056c4:	9100      	str	r1, [sp, #0]
 80056c6:	f88d 3007 	strb.w	r3, [sp, #7]

  unsigned start = 12U - ((unsigned)function * 2U);
 80056ca:	f89d 2007 	ldrb.w	r2, [sp, #7]
 80056ce:	4613      	mov	r3, r2
 80056d0:	07db      	lsls	r3, r3, #31
 80056d2:	1a9b      	subs	r3, r3, r2
 80056d4:	005b      	lsls	r3, r3, #1
 80056d6:	330c      	adds	r3, #12
 80056d8:	9303      	str	r3, [sp, #12]

  return ((uint16_t)buf[start] << 8U) | (uint16_t)buf[start + 1U];
 80056da:	9a00      	ldr	r2, [sp, #0]
 80056dc:	9b03      	ldr	r3, [sp, #12]
 80056de:	4413      	add	r3, r2
 80056e0:	781b      	ldrb	r3, [r3, #0]
 80056e2:	021b      	lsls	r3, r3, #8
 80056e4:	b29a      	uxth	r2, r3
 80056e6:	9b03      	ldr	r3, [sp, #12]
 80056e8:	3301      	adds	r3, #1
 80056ea:	9900      	ldr	r1, [sp, #0]
 80056ec:	440b      	add	r3, r1
 80056ee:	781b      	ldrb	r3, [r3, #0]
 80056f0:	4313      	orrs	r3, r2
 80056f2:	b29b      	uxth	r3, r3
 80056f4:	b29b      	uxth	r3, r3
}
 80056f6:	4618      	mov	r0, r3
 80056f8:	b004      	add	sp, #16
 80056fa:	4770      	bx	lr
 80056fc:	f3af 8000 	nop.w

08005700 <sdc_cmd6_check_status>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_cmd6_check_status(sd_switch_function_t function,
                                 const uint8_t *buf) {
 8005700:	b084      	sub	sp, #16
 8005702:	4603      	mov	r3, r0
 8005704:	9100      	str	r1, [sp, #0]
 8005706:	f88d 3007 	strb.w	r3, [sp, #7]

  uint32_t tmp;
  uint32_t status;

  tmp = ((uint32_t)buf[14] << 16U) |
 800570a:	9b00      	ldr	r3, [sp, #0]
 800570c:	330e      	adds	r3, #14
 800570e:	781b      	ldrb	r3, [r3, #0]
 8005710:	041a      	lsls	r2, r3, #16
        ((uint32_t)buf[15] << 8U) |
 8005712:	9b00      	ldr	r3, [sp, #0]
 8005714:	330f      	adds	r3, #15
 8005716:	781b      	ldrb	r3, [r3, #0]
 8005718:	021b      	lsls	r3, r3, #8
                                 const uint8_t *buf) {

  uint32_t tmp;
  uint32_t status;

  tmp = ((uint32_t)buf[14] << 16U) |
 800571a:	431a      	orrs	r2, r3
        ((uint32_t)buf[15] << 8U) |
        (uint32_t)buf[16];
 800571c:	9b00      	ldr	r3, [sp, #0]
 800571e:	3310      	adds	r3, #16
 8005720:	781b      	ldrb	r3, [r3, #0]
                                 const uint8_t *buf) {

  uint32_t tmp;
  uint32_t status;

  tmp = ((uint32_t)buf[14] << 16U) |
 8005722:	4313      	orrs	r3, r2
 8005724:	9303      	str	r3, [sp, #12]
        ((uint32_t)buf[15] << 8U) |
        (uint32_t)buf[16];
  status = (tmp >> ((uint32_t)function * 4U)) & 0xFU;
 8005726:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800572a:	009b      	lsls	r3, r3, #2
 800572c:	9a03      	ldr	r2, [sp, #12]
 800572e:	fa22 f303 	lsr.w	r3, r2, r3
 8005732:	f003 030f 	and.w	r3, r3, #15
 8005736:	9302      	str	r3, [sp, #8]
  if (0xFU != status) {
 8005738:	9b02      	ldr	r3, [sp, #8]
 800573a:	2b0f      	cmp	r3, #15
 800573c:	d001      	beq.n	8005742 <sdc_cmd6_check_status+0x42>
    return HAL_SUCCESS;
 800573e:	2300      	movs	r3, #0
 8005740:	e000      	b.n	8005744 <sdc_cmd6_check_status+0x44>
  }
  return HAL_FAILED;
 8005742:	2301      	movs	r3, #1
}
 8005744:	4618      	mov	r0, r3
 8005746:	b004      	add	sp, #16
 8005748:	4770      	bx	lr
 800574a:	bf00      	nop
 800574c:	f3af 8000 	nop.w

08005750 <sdc_detect_bus_clk>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_detect_bus_clk(SDCDriver *sdcp, sdcbusclk_t *clk) {
 8005750:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005752:	b089      	sub	sp, #36	; 0x24
 8005754:	af02      	add	r7, sp, #8
 8005756:	6078      	str	r0, [r7, #4]
 8005758:	6039      	str	r1, [r7, #0]
 800575a:	4669      	mov	r1, sp
 800575c:	460e      	mov	r6, r1
  uint32_t cmdarg;
  const size_t N = 64;
 800575e:	2140      	movs	r1, #64	; 0x40
 8005760:	6179      	str	r1, [r7, #20]
  uint8_t tmp[N];
 8005762:	6979      	ldr	r1, [r7, #20]
 8005764:	3901      	subs	r1, #1
 8005766:	6139      	str	r1, [r7, #16]
 8005768:	6979      	ldr	r1, [r7, #20]
 800576a:	4608      	mov	r0, r1
 800576c:	f04f 0100 	mov.w	r1, #0
 8005770:	00cd      	lsls	r5, r1, #3
 8005772:	ea45 7550 	orr.w	r5, r5, r0, lsr #29
 8005776:	00c4      	lsls	r4, r0, #3
 8005778:	6979      	ldr	r1, [r7, #20]
 800577a:	4608      	mov	r0, r1
 800577c:	f04f 0100 	mov.w	r1, #0
 8005780:	00cb      	lsls	r3, r1, #3
 8005782:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 8005786:	00c2      	lsls	r2, r0, #3
 8005788:	697b      	ldr	r3, [r7, #20]
 800578a:	3307      	adds	r3, #7
 800578c:	08db      	lsrs	r3, r3, #3
 800578e:	00db      	lsls	r3, r3, #3
 8005790:	ebad 0d03 	sub.w	sp, sp, r3
 8005794:	ab02      	add	r3, sp, #8
 8005796:	3300      	adds	r3, #0
 8005798:	60fb      	str	r3, [r7, #12]

  /* Safe default.*/
  *clk = SDC_CLK_25MHz;
 800579a:	683b      	ldr	r3, [r7, #0]
 800579c:	2200      	movs	r2, #0
 800579e:	701a      	strb	r2, [r3, #0]

  /* Looks like only "high capacity" cards produce meaningful results during
     this clock detection procedure.*/
  if (0U == _mmcsd_get_slice(sdcp->csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 80057a0:	687b      	ldr	r3, [r7, #4]
 80057a2:	3318      	adds	r3, #24
 80057a4:	4618      	mov	r0, r3
 80057a6:	217f      	movs	r1, #127	; 0x7f
 80057a8:	227e      	movs	r2, #126	; 0x7e
 80057aa:	f7fe ff69 	bl	8004680 <_mmcsd_get_slice>
 80057ae:	4603      	mov	r3, r0
 80057b0:	2b00      	cmp	r3, #0
 80057b2:	d104      	bne.n	80057be <sdc_detect_bus_clk+0x6e>
    *clk = SDC_CLK_25MHz;
 80057b4:	683b      	ldr	r3, [r7, #0]
 80057b6:	2200      	movs	r2, #0
 80057b8:	701a      	strb	r2, [r3, #0]
    return HAL_SUCCESS;
 80057ba:	2300      	movs	r3, #0
 80057bc:	e03e      	b.n	800583c <sdc_detect_bus_clk+0xec>
  }

  /* Read switch functions' register.*/
  if (sdc_lld_read_special(sdcp, tmp, N, MMCSD_CMD_SWITCH, 0)) {
 80057be:	68fb      	ldr	r3, [r7, #12]
 80057c0:	2200      	movs	r2, #0
 80057c2:	9200      	str	r2, [sp, #0]
 80057c4:	6878      	ldr	r0, [r7, #4]
 80057c6:	4619      	mov	r1, r3
 80057c8:	697a      	ldr	r2, [r7, #20]
 80057ca:	2306      	movs	r3, #6
 80057cc:	f005 f928 	bl	800aa20 <sdc_lld_read_special>
 80057d0:	4603      	mov	r3, r0
 80057d2:	2b00      	cmp	r3, #0
 80057d4:	d001      	beq.n	80057da <sdc_detect_bus_clk+0x8a>
    return HAL_FAILED;
 80057d6:	2301      	movs	r3, #1
 80057d8:	e030      	b.n	800583c <sdc_detect_bus_clk+0xec>
  }

  /* Check card capabilities parsing acquired data.*/
  if ((sdc_cmd6_extract_info(SD_SWITCH_FUNCTION_SPEED, tmp) & 2U) == 2U) {
 80057da:	68fb      	ldr	r3, [r7, #12]
 80057dc:	2000      	movs	r0, #0
 80057de:	4619      	mov	r1, r3
 80057e0:	f7ff ff6e 	bl	80056c0 <sdc_cmd6_extract_info>
 80057e4:	4603      	mov	r3, r0
 80057e6:	f003 0302 	and.w	r3, r3, #2
 80057ea:	2b00      	cmp	r3, #0
 80057ec:	d025      	beq.n	800583a <sdc_detect_bus_clk+0xea>
    /* Construct command to set the bus speed.*/
    cmdarg = sdc_cmd6_construct(SD_SWITCH_SET, SD_SWITCH_FUNCTION_SPEED, 1);
 80057ee:	2001      	movs	r0, #1
 80057f0:	2100      	movs	r1, #0
 80057f2:	2201      	movs	r2, #1
 80057f4:	f7ff ff3c 	bl	8005670 <sdc_cmd6_construct>
 80057f8:	60b8      	str	r0, [r7, #8]

    /* Write constructed command and read operation status in single call.*/
    if (sdc_lld_read_special(sdcp, tmp, N, MMCSD_CMD_SWITCH, cmdarg)) {
 80057fa:	68fb      	ldr	r3, [r7, #12]
 80057fc:	68ba      	ldr	r2, [r7, #8]
 80057fe:	9200      	str	r2, [sp, #0]
 8005800:	6878      	ldr	r0, [r7, #4]
 8005802:	4619      	mov	r1, r3
 8005804:	697a      	ldr	r2, [r7, #20]
 8005806:	2306      	movs	r3, #6
 8005808:	f005 f90a 	bl	800aa20 <sdc_lld_read_special>
 800580c:	4603      	mov	r3, r0
 800580e:	2b00      	cmp	r3, #0
 8005810:	d001      	beq.n	8005816 <sdc_detect_bus_clk+0xc6>
      return HAL_FAILED;
 8005812:	2301      	movs	r3, #1
 8005814:	e012      	b.n	800583c <sdc_detect_bus_clk+0xec>
    }

    /* Check card answer for success status bits.*/
    if (HAL_SUCCESS == sdc_cmd6_check_status(SD_SWITCH_FUNCTION_SPEED, tmp)) {
 8005816:	68fb      	ldr	r3, [r7, #12]
 8005818:	2000      	movs	r0, #0
 800581a:	4619      	mov	r1, r3
 800581c:	f7ff ff70 	bl	8005700 <sdc_cmd6_check_status>
 8005820:	4603      	mov	r3, r0
 8005822:	f083 0301 	eor.w	r3, r3, #1
 8005826:	b2db      	uxtb	r3, r3
 8005828:	2b00      	cmp	r3, #0
 800582a:	d003      	beq.n	8005834 <sdc_detect_bus_clk+0xe4>
      *clk = SDC_CLK_50MHz;
 800582c:	683b      	ldr	r3, [r7, #0]
 800582e:	2201      	movs	r2, #1
 8005830:	701a      	strb	r2, [r3, #0]
 8005832:	e002      	b.n	800583a <sdc_detect_bus_clk+0xea>
    }
    else {
      *clk = SDC_CLK_25MHz;
 8005834:	683b      	ldr	r3, [r7, #0]
 8005836:	2200      	movs	r2, #0
 8005838:	701a      	strb	r2, [r3, #0]
    }
  }

  return HAL_SUCCESS;
 800583a:	2300      	movs	r3, #0
 800583c:	46b5      	mov	sp, r6
}
 800583e:	4618      	mov	r0, r3
 8005840:	371c      	adds	r7, #28
 8005842:	46bd      	mov	sp, r7
 8005844:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005846:	bf00      	nop
 8005848:	f3af 8000 	nop.w
 800584c:	f3af 8000 	nop.w

08005850 <mmc_detect_bus_clk>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool mmc_detect_bus_clk(SDCDriver *sdcp, sdcbusclk_t *clk) {
 8005850:	b500      	push	{lr}
 8005852:	b087      	sub	sp, #28
 8005854:	9001      	str	r0, [sp, #4]
 8005856:	9100      	str	r1, [sp, #0]
  uint32_t cmdarg;
  uint32_t resp[1];
  uint8_t *scratchpad = sdcp->config->scratchpad;
 8005858:	9b01      	ldr	r3, [sp, #4]
 800585a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800585c:	681b      	ldr	r3, [r3, #0]
 800585e:	9305      	str	r3, [sp, #20]

  /* Safe default.*/
  *clk = SDC_CLK_25MHz;
 8005860:	9b00      	ldr	r3, [sp, #0]
 8005862:	2200      	movs	r2, #0
 8005864:	701a      	strb	r2, [r3, #0]

  /* Use safe default when there is no space for data.*/
  if (NULL == scratchpad) {
 8005866:	9b05      	ldr	r3, [sp, #20]
 8005868:	2b00      	cmp	r3, #0
 800586a:	d101      	bne.n	8005870 <mmc_detect_bus_clk+0x20>
    return HAL_SUCCESS;
 800586c:	2300      	movs	r3, #0
 800586e:	e01b      	b.n	80058a8 <mmc_detect_bus_clk+0x58>
  }

  cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 185, 1, 0);
 8005870:	2003      	movs	r0, #3
 8005872:	21b9      	movs	r1, #185	; 0xb9
 8005874:	2201      	movs	r2, #1
 8005876:	2300      	movs	r3, #0
 8005878:	f7ff fee2 	bl	8005640 <mmc_cmd6_construct>
 800587c:	9004      	str	r0, [sp, #16]
  if (!(sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 800587e:	ab03      	add	r3, sp, #12
 8005880:	9801      	ldr	r0, [sp, #4]
 8005882:	2106      	movs	r1, #6
 8005884:	9a04      	ldr	r2, [sp, #16]
 8005886:	f005 f83b 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 800588a:	4603      	mov	r3, r0
 800588c:	f083 0301 	eor.w	r3, r3, #1
 8005890:	b2db      	uxtb	r3, r3
 8005892:	2b00      	cmp	r3, #0
 8005894:	d007      	beq.n	80058a6 <mmc_detect_bus_clk+0x56>
                                   MMCSD_R1_ERROR(resp[0]))) {
 8005896:	9a03      	ldr	r2, [sp, #12]
 8005898:	4b05      	ldr	r3, [pc, #20]	; (80058b0 <mmc_detect_bus_clk+0x60>)
 800589a:	4013      	ands	r3, r2
  if (NULL == scratchpad) {
    return HAL_SUCCESS;
  }

  cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 185, 1, 0);
  if (!(sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 800589c:	2b00      	cmp	r3, #0
 800589e:	d102      	bne.n	80058a6 <mmc_detect_bus_clk+0x56>
                                   MMCSD_R1_ERROR(resp[0]))) {
    *clk = SDC_CLK_50MHz;
 80058a0:	9b00      	ldr	r3, [sp, #0]
 80058a2:	2201      	movs	r2, #1
 80058a4:	701a      	strb	r2, [r3, #0]
  }

  return HAL_SUCCESS;
 80058a6:	2300      	movs	r3, #0
}
 80058a8:	4618      	mov	r0, r3
 80058aa:	b007      	add	sp, #28
 80058ac:	f85d fb04 	ldr.w	pc, [sp], #4
 80058b0:	fdffe008 	.word	0xfdffe008
 80058b4:	f3af 8000 	nop.w
 80058b8:	f3af 8000 	nop.w
 80058bc:	f3af 8000 	nop.w

080058c0 <detect_bus_clk>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool detect_bus_clk(SDCDriver *sdcp, sdcbusclk_t *clk) {
 80058c0:	b500      	push	{lr}
 80058c2:	b083      	sub	sp, #12
 80058c4:	9001      	str	r0, [sp, #4]
 80058c6:	9100      	str	r1, [sp, #0]

  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
 80058c8:	9b01      	ldr	r3, [sp, #4]
 80058ca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80058cc:	f003 030f 	and.w	r3, r3, #15
 80058d0:	2b02      	cmp	r3, #2
 80058d2:	d105      	bne.n	80058e0 <detect_bus_clk+0x20>
    return mmc_detect_bus_clk(sdcp, clk);
 80058d4:	9801      	ldr	r0, [sp, #4]
 80058d6:	9900      	ldr	r1, [sp, #0]
 80058d8:	f7ff ffba 	bl	8005850 <mmc_detect_bus_clk>
 80058dc:	4603      	mov	r3, r0
 80058de:	e004      	b.n	80058ea <detect_bus_clk+0x2a>
  }
  return sdc_detect_bus_clk(sdcp, clk);
 80058e0:	9801      	ldr	r0, [sp, #4]
 80058e2:	9900      	ldr	r1, [sp, #0]
 80058e4:	f7ff ff34 	bl	8005750 <sdc_detect_bus_clk>
 80058e8:	4603      	mov	r3, r0
}
 80058ea:	4618      	mov	r0, r3
 80058ec:	b003      	add	sp, #12
 80058ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80058f2:	bf00      	nop
 80058f4:	f3af 8000 	nop.w
 80058f8:	f3af 8000 	nop.w
 80058fc:	f3af 8000 	nop.w

08005900 <sdc_set_bus_width>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_set_bus_width(SDCDriver *sdcp) {
 8005900:	b500      	push	{lr}
 8005902:	b085      	sub	sp, #20
 8005904:	9001      	str	r0, [sp, #4]
  uint32_t resp[1];

  if (SDC_MODE_1BIT == sdcp->config->bus_width) {
 8005906:	9b01      	ldr	r3, [sp, #4]
 8005908:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800590a:	791b      	ldrb	r3, [r3, #4]
 800590c:	2b00      	cmp	r3, #0
 800590e:	d101      	bne.n	8005914 <sdc_set_bus_width+0x14>
    /* Nothing to do. Bus is already in 1bit mode.*/
    return HAL_SUCCESS;
 8005910:	2300      	movs	r3, #0
 8005912:	e02c      	b.n	800596e <sdc_set_bus_width+0x6e>
  }
  else if (SDC_MODE_4BIT == sdcp->config->bus_width) {
 8005914:	9b01      	ldr	r3, [sp, #4]
 8005916:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005918:	791b      	ldrb	r3, [r3, #4]
 800591a:	2b01      	cmp	r3, #1
 800591c:	d124      	bne.n	8005968 <sdc_set_bus_width+0x68>
    sdc_lld_set_bus_mode(sdcp, SDC_MODE_4BIT);
 800591e:	9801      	ldr	r0, [sp, #4]
 8005920:	2101      	movs	r1, #1
 8005922:	f004 ff65 	bl	800a7f0 <sdc_lld_set_bus_mode>
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, sdcp->rca, resp) ||
 8005926:	9b01      	ldr	r3, [sp, #4]
 8005928:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800592a:	ab03      	add	r3, sp, #12
 800592c:	9801      	ldr	r0, [sp, #4]
 800592e:	2137      	movs	r1, #55	; 0x37
 8005930:	f004 ffe6 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005934:	4603      	mov	r3, r0
 8005936:	2b00      	cmp	r3, #0
 8005938:	d104      	bne.n	8005944 <sdc_set_bus_width+0x44>
        MMCSD_R1_ERROR(resp[0])) {
 800593a:	9a03      	ldr	r2, [sp, #12]
 800593c:	4b0e      	ldr	r3, [pc, #56]	; (8005978 <sdc_set_bus_width+0x78>)
 800593e:	4013      	ands	r3, r2
    /* Nothing to do. Bus is already in 1bit mode.*/
    return HAL_SUCCESS;
  }
  else if (SDC_MODE_4BIT == sdcp->config->bus_width) {
    sdc_lld_set_bus_mode(sdcp, SDC_MODE_4BIT);
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, sdcp->rca, resp) ||
 8005940:	2b00      	cmp	r3, #0
 8005942:	d001      	beq.n	8005948 <sdc_set_bus_width+0x48>
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
 8005944:	2301      	movs	r3, #1
 8005946:	e012      	b.n	800596e <sdc_set_bus_width+0x6e>
    }

    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BUS_WIDTH, 2, resp) ||
 8005948:	ab03      	add	r3, sp, #12
 800594a:	9801      	ldr	r0, [sp, #4]
 800594c:	2106      	movs	r1, #6
 800594e:	2202      	movs	r2, #2
 8005950:	f004 ffd6 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005954:	4603      	mov	r3, r0
 8005956:	2b00      	cmp	r3, #0
 8005958:	d104      	bne.n	8005964 <sdc_set_bus_width+0x64>
        MMCSD_R1_ERROR(resp[0])) {
 800595a:	9a03      	ldr	r2, [sp, #12]
 800595c:	4b06      	ldr	r3, [pc, #24]	; (8005978 <sdc_set_bus_width+0x78>)
 800595e:	4013      	ands	r3, r2
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, sdcp->rca, resp) ||
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
    }

    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BUS_WIDTH, 2, resp) ||
 8005960:	2b00      	cmp	r3, #0
 8005962:	d003      	beq.n	800596c <sdc_set_bus_width+0x6c>
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
 8005964:	2301      	movs	r3, #1
 8005966:	e002      	b.n	800596e <sdc_set_bus_width+0x6e>
    }
  }
  else {
    /* SD card does not support 8bit bus.*/
    return HAL_FAILED;
 8005968:	2301      	movs	r3, #1
 800596a:	e000      	b.n	800596e <sdc_set_bus_width+0x6e>
  }

  return HAL_SUCCESS;
 800596c:	2300      	movs	r3, #0
}
 800596e:	4618      	mov	r0, r3
 8005970:	b005      	add	sp, #20
 8005972:	f85d fb04 	ldr.w	pc, [sp], #4
 8005976:	bf00      	nop
 8005978:	fdffe008 	.word	0xfdffe008
 800597c:	f3af 8000 	nop.w

08005980 <mmc_set_bus_width>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool mmc_set_bus_width(SDCDriver *sdcp) {
 8005980:	b500      	push	{lr}
 8005982:	b085      	sub	sp, #20
 8005984:	9001      	str	r0, [sp, #4]
  uint32_t resp[1];
  uint32_t cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 0, 0);
 8005986:	2003      	movs	r0, #3
 8005988:	21b7      	movs	r1, #183	; 0xb7
 800598a:	2200      	movs	r2, #0
 800598c:	2300      	movs	r3, #0
 800598e:	f7ff fe57 	bl	8005640 <mmc_cmd6_construct>
 8005992:	9003      	str	r0, [sp, #12]

  switch(sdcp->config->bus_width){
 8005994:	9b01      	ldr	r3, [sp, #4]
 8005996:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005998:	791b      	ldrb	r3, [r3, #4]
 800599a:	2b01      	cmp	r3, #1
 800599c:	d006      	beq.n	80059ac <mmc_set_bus_width+0x2c>
 800599e:	2b02      	cmp	r3, #2
 80059a0:	d00c      	beq.n	80059bc <mmc_set_bus_width+0x3c>
 80059a2:	2b00      	cmp	r3, #0
 80059a4:	d000      	beq.n	80059a8 <mmc_set_bus_width+0x28>
  case SDC_MODE_8BIT:
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 2, 0);
    break;
  default:
    osalDbgAssert(false, "unexpected case");
    break;
 80059a6:	e011      	b.n	80059cc <mmc_set_bus_width+0x4c>
  uint32_t cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 0, 0);

  switch(sdcp->config->bus_width){
  case SDC_MODE_1BIT:
    /* Nothing to do. Bus is already in 1bit mode.*/
    return HAL_SUCCESS;
 80059a8:	2300      	movs	r3, #0
 80059aa:	e027      	b.n	80059fc <mmc_set_bus_width+0x7c>
  case SDC_MODE_4BIT:
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 1, 0);
 80059ac:	2003      	movs	r0, #3
 80059ae:	21b7      	movs	r1, #183	; 0xb7
 80059b0:	2201      	movs	r2, #1
 80059b2:	2300      	movs	r3, #0
 80059b4:	f7ff fe44 	bl	8005640 <mmc_cmd6_construct>
 80059b8:	9003      	str	r0, [sp, #12]
    break;
 80059ba:	e007      	b.n	80059cc <mmc_set_bus_width+0x4c>
  case SDC_MODE_8BIT:
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 2, 0);
 80059bc:	2003      	movs	r0, #3
 80059be:	21b7      	movs	r1, #183	; 0xb7
 80059c0:	2202      	movs	r2, #2
 80059c2:	2300      	movs	r3, #0
 80059c4:	f7ff fe3c 	bl	8005640 <mmc_cmd6_construct>
 80059c8:	9003      	str	r0, [sp, #12]
    break;
 80059ca:	bf00      	nop
  default:
    osalDbgAssert(false, "unexpected case");
    break;
  }

  sdc_lld_set_bus_mode(sdcp, sdcp->config->bus_width);
 80059cc:	9b01      	ldr	r3, [sp, #4]
 80059ce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80059d0:	791b      	ldrb	r3, [r3, #4]
 80059d2:	9801      	ldr	r0, [sp, #4]
 80059d4:	4619      	mov	r1, r3
 80059d6:	f004 ff0b 	bl	800a7f0 <sdc_lld_set_bus_mode>
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 80059da:	ab02      	add	r3, sp, #8
 80059dc:	9801      	ldr	r0, [sp, #4]
 80059de:	2106      	movs	r1, #6
 80059e0:	9a03      	ldr	r2, [sp, #12]
 80059e2:	f004 ff8d 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 80059e6:	4603      	mov	r3, r0
 80059e8:	2b00      	cmp	r3, #0
 80059ea:	d104      	bne.n	80059f6 <mmc_set_bus_width+0x76>
      MMCSD_R1_ERROR(resp[0])) {
 80059ec:	9a02      	ldr	r2, [sp, #8]
 80059ee:	4b05      	ldr	r3, [pc, #20]	; (8005a04 <mmc_set_bus_width+0x84>)
 80059f0:	4013      	ands	r3, r2
    osalDbgAssert(false, "unexpected case");
    break;
  }

  sdc_lld_set_bus_mode(sdcp, sdcp->config->bus_width);
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 80059f2:	2b00      	cmp	r3, #0
 80059f4:	d001      	beq.n	80059fa <mmc_set_bus_width+0x7a>
      MMCSD_R1_ERROR(resp[0])) {
    return HAL_FAILED;
 80059f6:	2301      	movs	r3, #1
 80059f8:	e000      	b.n	80059fc <mmc_set_bus_width+0x7c>
  }

  return HAL_SUCCESS;
 80059fa:	2300      	movs	r3, #0
}
 80059fc:	4618      	mov	r0, r3
 80059fe:	b005      	add	sp, #20
 8005a00:	f85d fb04 	ldr.w	pc, [sp], #4
 8005a04:	fdffe008 	.word	0xfdffe008
 8005a08:	f3af 8000 	nop.w
 8005a0c:	f3af 8000 	nop.w

08005a10 <_sdc_wait_for_transfer_state>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool _sdc_wait_for_transfer_state(SDCDriver *sdcp) {
 8005a10:	b500      	push	{lr}
 8005a12:	b085      	sub	sp, #20
 8005a14:	9001      	str	r0, [sp, #4]
  uint32_t resp[1];

  while (true) {
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_STATUS,
 8005a16:	9b01      	ldr	r3, [sp, #4]
 8005a18:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8005a1a:	ab03      	add	r3, sp, #12
 8005a1c:	9801      	ldr	r0, [sp, #4]
 8005a1e:	210d      	movs	r1, #13
 8005a20:	f004 ff6e 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005a24:	4603      	mov	r3, r0
 8005a26:	2b00      	cmp	r3, #0
 8005a28:	d104      	bne.n	8005a34 <_sdc_wait_for_transfer_state+0x24>
                                   sdcp->rca, resp) ||
        MMCSD_R1_ERROR(resp[0])) {
 8005a2a:	9a03      	ldr	r2, [sp, #12]
 8005a2c:	4b0d      	ldr	r3, [pc, #52]	; (8005a64 <_sdc_wait_for_transfer_state+0x54>)
 8005a2e:	4013      	ands	r3, r2
bool _sdc_wait_for_transfer_state(SDCDriver *sdcp) {
  uint32_t resp[1];

  while (true) {
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_STATUS,
                                   sdcp->rca, resp) ||
 8005a30:	2b00      	cmp	r3, #0
 8005a32:	d001      	beq.n	8005a38 <_sdc_wait_for_transfer_state+0x28>
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
 8005a34:	2301      	movs	r3, #1
 8005a36:	e011      	b.n	8005a5c <_sdc_wait_for_transfer_state+0x4c>
    }

    switch (MMCSD_R1_STS(resp[0])) {
 8005a38:	9b03      	ldr	r3, [sp, #12]
 8005a3a:	0a5b      	lsrs	r3, r3, #9
 8005a3c:	f003 030f 	and.w	r3, r3, #15
 8005a40:	2b04      	cmp	r3, #4
 8005a42:	d004      	beq.n	8005a4e <_sdc_wait_for_transfer_state+0x3e>
 8005a44:	2b04      	cmp	r3, #4
 8005a46:	d308      	bcc.n	8005a5a <_sdc_wait_for_transfer_state+0x4a>
 8005a48:	2b07      	cmp	r3, #7
 8005a4a:	d806      	bhi.n	8005a5a <_sdc_wait_for_transfer_state+0x4a>
 8005a4c:	e001      	b.n	8005a52 <_sdc_wait_for_transfer_state+0x42>
    case MMCSD_STS_TRAN:
      return HAL_SUCCESS;
 8005a4e:	2300      	movs	r3, #0
 8005a50:	e004      	b.n	8005a5c <_sdc_wait_for_transfer_state+0x4c>
    case MMCSD_STS_DATA:
    case MMCSD_STS_RCV:
    case MMCSD_STS_PRG:
#if SDC_NICE_WAITING == TRUE
      osalThreadSleepMilliseconds(1);
 8005a52:	2001      	movs	r0, #1
 8005a54:	f7ff fd04 	bl	8005460 <osalThreadSleep>
    default:
      /* The card should have been initialized so any other state is not
         valid and is reported as an error.*/
      return HAL_FAILED;
    }
  }
 8005a58:	e7dd      	b.n	8005a16 <_sdc_wait_for_transfer_state+0x6>
#endif
      continue;
    default:
      /* The card should have been initialized so any other state is not
         valid and is reported as an error.*/
      return HAL_FAILED;
 8005a5a:	2301      	movs	r3, #1
    }
  }
}
 8005a5c:	4618      	mov	r0, r3
 8005a5e:	b005      	add	sp, #20
 8005a60:	f85d fb04 	ldr.w	pc, [sp], #4
 8005a64:	fdffe008 	.word	0xfdffe008
 8005a68:	f3af 8000 	nop.w
 8005a6c:	f3af 8000 	nop.w

08005a70 <sdcInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdcInit(void) {
 8005a70:	b508      	push	{r3, lr}

  sdc_lld_init();
 8005a72:	f004 fded 	bl	800a650 <sdc_lld_init>
}
 8005a76:	bd08      	pop	{r3, pc}
 8005a78:	f3af 8000 	nop.w
 8005a7c:	f3af 8000 	nop.w

08005a80 <sdcObjectInit>:
 *
 * @param[out] sdcp     pointer to the @p SDCDriver object
 *
 * @init
 */
void sdcObjectInit(SDCDriver *sdcp) {
 8005a80:	b082      	sub	sp, #8
 8005a82:	9001      	str	r0, [sp, #4]

  sdcp->vmt      = &sdc_vmt;
 8005a84:	9b01      	ldr	r3, [sp, #4]
 8005a86:	4a08      	ldr	r2, [pc, #32]	; (8005aa8 <sdcObjectInit+0x28>)
 8005a88:	601a      	str	r2, [r3, #0]
  sdcp->state    = BLK_STOP;
 8005a8a:	9b01      	ldr	r3, [sp, #4]
 8005a8c:	2201      	movs	r2, #1
 8005a8e:	711a      	strb	r2, [r3, #4]
  sdcp->errors   = SDC_NO_ERROR;
 8005a90:	9b01      	ldr	r3, [sp, #4]
 8005a92:	2200      	movs	r2, #0
 8005a94:	635a      	str	r2, [r3, #52]	; 0x34
  sdcp->config   = NULL;
 8005a96:	9b01      	ldr	r3, [sp, #4]
 8005a98:	2200      	movs	r2, #0
 8005a9a:	62da      	str	r2, [r3, #44]	; 0x2c
  sdcp->capacity = 0;
 8005a9c:	9b01      	ldr	r3, [sp, #4]
 8005a9e:	2200      	movs	r2, #0
 8005aa0:	629a      	str	r2, [r3, #40]	; 0x28
}
 8005aa2:	b002      	add	sp, #8
 8005aa4:	4770      	bx	lr
 8005aa6:	bf00      	nop
 8005aa8:	08017820 	.word	0x08017820
 8005aac:	f3af 8000 	nop.w

08005ab0 <sdcStart>:
 *                      the driver supports a default configuration or
 *                      requires no configuration
 *
 * @api
 */
void sdcStart(SDCDriver *sdcp, const SDCConfig *config) {
 8005ab0:	b500      	push	{lr}
 8005ab2:	b083      	sub	sp, #12
 8005ab4:	9001      	str	r0, [sp, #4]
 8005ab6:	9100      	str	r1, [sp, #0]

  osalDbgCheck(sdcp != NULL);

  osalSysLock();
 8005ab8:	f7ff fcc2 	bl	8005440 <osalSysLock>
  osalDbgAssert((sdcp->state == BLK_STOP) || (sdcp->state == BLK_ACTIVE),
                "invalid state");
  sdcp->config = config;
 8005abc:	9b01      	ldr	r3, [sp, #4]
 8005abe:	9a00      	ldr	r2, [sp, #0]
 8005ac0:	62da      	str	r2, [r3, #44]	; 0x2c
  sdc_lld_start(sdcp);
 8005ac2:	9801      	ldr	r0, [sp, #4]
 8005ac4:	f004 fddc 	bl	800a680 <sdc_lld_start>
  sdcp->state = BLK_ACTIVE;
 8005ac8:	9b01      	ldr	r3, [sp, #4]
 8005aca:	2202      	movs	r2, #2
 8005acc:	711a      	strb	r2, [r3, #4]
  osalSysUnlock();
 8005ace:	f7ff fcbf 	bl	8005450 <osalSysUnlock>
}
 8005ad2:	b003      	add	sp, #12
 8005ad4:	f85d fb04 	ldr.w	pc, [sp], #4
 8005ad8:	f3af 8000 	nop.w
 8005adc:	f3af 8000 	nop.w

08005ae0 <sdcStop>:
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 *
 * @api
 */
void sdcStop(SDCDriver *sdcp) {
 8005ae0:	b500      	push	{lr}
 8005ae2:	b083      	sub	sp, #12
 8005ae4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(sdcp != NULL);

  osalSysLock();
 8005ae6:	f7ff fcab 	bl	8005440 <osalSysLock>
  osalDbgAssert((sdcp->state == BLK_STOP) || (sdcp->state == BLK_ACTIVE),
                "invalid state");
  sdc_lld_stop(sdcp);
 8005aea:	9801      	ldr	r0, [sp, #4]
 8005aec:	f004 fe10 	bl	800a710 <sdc_lld_stop>
  sdcp->state = BLK_STOP;
 8005af0:	9b01      	ldr	r3, [sp, #4]
 8005af2:	2201      	movs	r2, #1
 8005af4:	711a      	strb	r2, [r3, #4]
  osalSysUnlock();
 8005af6:	f7ff fcab 	bl	8005450 <osalSysUnlock>
}
 8005afa:	b003      	add	sp, #12
 8005afc:	f85d fb04 	ldr.w	pc, [sp], #4

08005b00 <sdcConnect>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcConnect(SDCDriver *sdcp) {
 8005b00:	b500      	push	{lr}
 8005b02:	b089      	sub	sp, #36	; 0x24
 8005b04:	9003      	str	r0, [sp, #12]
  uint32_t resp[1];
  sdcbusclk_t clk = SDC_CLK_25MHz;
 8005b06:	2300      	movs	r3, #0
 8005b08:	f88d 3017 	strb.w	r3, [sp, #23]
  osalDbgCheck(sdcp != NULL);
  osalDbgAssert((sdcp->state == BLK_ACTIVE) || (sdcp->state == BLK_READY),
                "invalid state");

  /* Connection procedure in progress.*/
  sdcp->state = BLK_CONNECTING;
 8005b0c:	9b03      	ldr	r3, [sp, #12]
 8005b0e:	2203      	movs	r2, #3
 8005b10:	711a      	strb	r2, [r3, #4]

  /* Card clock initialization.*/
  sdc_lld_start_clk(sdcp);
 8005b12:	9803      	ldr	r0, [sp, #12]
 8005b14:	f004 fe2c 	bl	800a770 <sdc_lld_start_clk>

  /* Enforces the initial card state.*/
  sdc_lld_send_cmd_none(sdcp, MMCSD_CMD_GO_IDLE_STATE, 0);
 8005b18:	9803      	ldr	r0, [sp, #12]
 8005b1a:	2100      	movs	r1, #0
 8005b1c:	2200      	movs	r2, #0
 8005b1e:	f004 fe8f 	bl	800a840 <sdc_lld_send_cmd_none>

  /* Detect card type.*/
  if (HAL_FAILED == mode_detect(sdcp)) {
 8005b22:	9803      	ldr	r0, [sp, #12]
 8005b24:	f7ff fcac 	bl	8005480 <mode_detect>
 8005b28:	4603      	mov	r3, r0
 8005b2a:	2b00      	cmp	r3, #0
 8005b2c:	d000      	beq.n	8005b30 <sdcConnect+0x30>
    goto failed;
 8005b2e:	e0ba      	b.n	8005ca6 <sdcConnect+0x1a6>
  }

  /* Perform specific initialization procedure.*/
  if ((sdcp->cardmode &  SDC_MODE_CARDTYPE_MASK) == SDC_MODE_CARDTYPE_MMC) {
 8005b30:	9b03      	ldr	r3, [sp, #12]
 8005b32:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005b34:	f003 030f 	and.w	r3, r3, #15
 8005b38:	2b02      	cmp	r3, #2
 8005b3a:	d106      	bne.n	8005b4a <sdcConnect+0x4a>
    if (HAL_FAILED == mmc_init(sdcp)) {
 8005b3c:	9803      	ldr	r0, [sp, #12]
 8005b3e:	f7ff fcef 	bl	8005520 <mmc_init>
 8005b42:	4603      	mov	r3, r0
 8005b44:	2b00      	cmp	r3, #0
 8005b46:	d007      	beq.n	8005b58 <sdcConnect+0x58>
      goto failed;
 8005b48:	e0ad      	b.n	8005ca6 <sdcConnect+0x1a6>
    }
  }
  else {
    if (HAL_FAILED == sdc_init(sdcp)) {
 8005b4a:	9803      	ldr	r0, [sp, #12]
 8005b4c:	f7ff fd20 	bl	8005590 <sdc_init>
 8005b50:	4603      	mov	r3, r0
 8005b52:	2b00      	cmp	r3, #0
 8005b54:	d000      	beq.n	8005b58 <sdcConnect+0x58>
      goto failed;
 8005b56:	e0a6      	b.n	8005ca6 <sdcConnect+0x1a6>
    }
  }

  /* Reads CID.*/
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_ALL_SEND_CID, 0, sdcp->cid)) {
 8005b58:	9b03      	ldr	r3, [sp, #12]
 8005b5a:	3308      	adds	r3, #8
 8005b5c:	9803      	ldr	r0, [sp, #12]
 8005b5e:	2102      	movs	r1, #2
 8005b60:	2200      	movs	r2, #0
 8005b62:	f004 ff0d 	bl	800a980 <sdc_lld_send_cmd_long_crc>
 8005b66:	4603      	mov	r3, r0
 8005b68:	2b00      	cmp	r3, #0
 8005b6a:	d000      	beq.n	8005b6e <sdcConnect+0x6e>
    goto failed;
 8005b6c:	e09b      	b.n	8005ca6 <sdcConnect+0x1a6>
  }

  /* Asks for the RCA.*/
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_RELATIVE_ADDR,
 8005b6e:	9b03      	ldr	r3, [sp, #12]
 8005b70:	3338      	adds	r3, #56	; 0x38
 8005b72:	9803      	ldr	r0, [sp, #12]
 8005b74:	2103      	movs	r1, #3
 8005b76:	2200      	movs	r2, #0
 8005b78:	f004 fec2 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005b7c:	4603      	mov	r3, r0
 8005b7e:	2b00      	cmp	r3, #0
 8005b80:	d000      	beq.n	8005b84 <sdcConnect+0x84>
                                 0, &sdcp->rca)) {
    goto failed;
 8005b82:	e090      	b.n	8005ca6 <sdcConnect+0x1a6>
  }

  /* Reads CSD.*/
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_SEND_CSD,
 8005b84:	9b03      	ldr	r3, [sp, #12]
 8005b86:	6b9a      	ldr	r2, [r3, #56]	; 0x38
                                sdcp->rca, sdcp->csd)) {
 8005b88:	9b03      	ldr	r3, [sp, #12]
 8005b8a:	3318      	adds	r3, #24
                                 0, &sdcp->rca)) {
    goto failed;
  }

  /* Reads CSD.*/
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_SEND_CSD,
 8005b8c:	9803      	ldr	r0, [sp, #12]
 8005b8e:	2109      	movs	r1, #9
 8005b90:	f004 fef6 	bl	800a980 <sdc_lld_send_cmd_long_crc>
 8005b94:	4603      	mov	r3, r0
 8005b96:	2b00      	cmp	r3, #0
 8005b98:	d000      	beq.n	8005b9c <sdcConnect+0x9c>
                                sdcp->rca, sdcp->csd)) {
    goto failed;
 8005b9a:	e084      	b.n	8005ca6 <sdcConnect+0x1a6>
  }

  /* Selects the card for operations.*/
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEL_DESEL_CARD,
 8005b9c:	9b03      	ldr	r3, [sp, #12]
 8005b9e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8005ba0:	ab06      	add	r3, sp, #24
 8005ba2:	9803      	ldr	r0, [sp, #12]
 8005ba4:	2107      	movs	r1, #7
 8005ba6:	f004 feab 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005baa:	4603      	mov	r3, r0
 8005bac:	2b00      	cmp	r3, #0
 8005bae:	d000      	beq.n	8005bb2 <sdcConnect+0xb2>
                                 sdcp->rca, resp)) {
    goto failed;
 8005bb0:	e079      	b.n	8005ca6 <sdcConnect+0x1a6>
  }

  /* Switches to high speed.*/
  if (HAL_SUCCESS != detect_bus_clk(sdcp, &clk)) {
 8005bb2:	f10d 0317 	add.w	r3, sp, #23
 8005bb6:	9803      	ldr	r0, [sp, #12]
 8005bb8:	4619      	mov	r1, r3
 8005bba:	f7ff fe81 	bl	80058c0 <detect_bus_clk>
 8005bbe:	4603      	mov	r3, r0
 8005bc0:	2b00      	cmp	r3, #0
 8005bc2:	d000      	beq.n	8005bc6 <sdcConnect+0xc6>
    goto failed;
 8005bc4:	e06f      	b.n	8005ca6 <sdcConnect+0x1a6>
  }
  sdc_lld_set_data_clk(sdcp, clk);
 8005bc6:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8005bca:	9803      	ldr	r0, [sp, #12]
 8005bcc:	4619      	mov	r1, r3
 8005bce:	f004 fdef 	bl	800a7b0 <sdc_lld_set_data_clk>

  /* Reads extended CSD if needed and possible.*/
  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
 8005bd2:	9b03      	ldr	r3, [sp, #12]
 8005bd4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005bd6:	f003 030f 	and.w	r3, r3, #15
 8005bda:	2b02      	cmp	r3, #2
 8005bdc:	d12e      	bne.n	8005c3c <sdcConnect+0x13c>

    /* The card is a MMC, checking if it is a large device.*/
    if (_mmcsd_get_slice(sdcp->csd, MMCSD_CSD_MMC_CSD_STRUCTURE_SLICE) > 1U) {
 8005bde:	9b03      	ldr	r3, [sp, #12]
 8005be0:	3318      	adds	r3, #24
 8005be2:	4618      	mov	r0, r3
 8005be4:	217f      	movs	r1, #127	; 0x7f
 8005be6:	227e      	movs	r2, #126	; 0x7e
 8005be8:	f7fe fd4a 	bl	8004680 <_mmcsd_get_slice>
 8005bec:	4603      	mov	r3, r0
 8005bee:	2b01      	cmp	r3, #1
 8005bf0:	d91b      	bls.n	8005c2a <sdcConnect+0x12a>
      uint8_t *ext_csd = sdcp->config->scratchpad;
 8005bf2:	9b03      	ldr	r3, [sp, #12]
 8005bf4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005bf6:	681b      	ldr	r3, [r3, #0]
 8005bf8:	9307      	str	r3, [sp, #28]

      /* Size detection requires the buffer.*/
      if (NULL == ext_csd) {
 8005bfa:	9b07      	ldr	r3, [sp, #28]
 8005bfc:	2b00      	cmp	r3, #0
 8005bfe:	d100      	bne.n	8005c02 <sdcConnect+0x102>
        goto failed;
 8005c00:	e051      	b.n	8005ca6 <sdcConnect+0x1a6>
      }

      if(sdc_lld_read_special(sdcp, ext_csd, 512, MMCSD_CMD_SEND_EXT_CSD, 0)) {
 8005c02:	2300      	movs	r3, #0
 8005c04:	9300      	str	r3, [sp, #0]
 8005c06:	9803      	ldr	r0, [sp, #12]
 8005c08:	9907      	ldr	r1, [sp, #28]
 8005c0a:	f44f 7200 	mov.w	r2, #512	; 0x200
 8005c0e:	2308      	movs	r3, #8
 8005c10:	f004 ff06 	bl	800aa20 <sdc_lld_read_special>
 8005c14:	4603      	mov	r3, r0
 8005c16:	2b00      	cmp	r3, #0
 8005c18:	d000      	beq.n	8005c1c <sdcConnect+0x11c>
        goto failed;
 8005c1a:	e044      	b.n	8005ca6 <sdcConnect+0x1a6>
      }

      /* Capacity from the EXT_CSD.*/
      sdcp->capacity = _mmcsd_get_capacity_ext(ext_csd);
 8005c1c:	9807      	ldr	r0, [sp, #28]
 8005c1e:	f7fe fda7 	bl	8004770 <_mmcsd_get_capacity_ext>
 8005c22:	4602      	mov	r2, r0
 8005c24:	9b03      	ldr	r3, [sp, #12]
 8005c26:	629a      	str	r2, [r3, #40]	; 0x28
 8005c28:	e010      	b.n	8005c4c <sdcConnect+0x14c>
    }
    else {
      /* Capacity from the normal CSD.*/
      sdcp->capacity = _mmcsd_get_capacity(sdcp->csd);
 8005c2a:	9b03      	ldr	r3, [sp, #12]
 8005c2c:	3318      	adds	r3, #24
 8005c2e:	4618      	mov	r0, r3
 8005c30:	f7fe fd66 	bl	8004700 <_mmcsd_get_capacity>
 8005c34:	4602      	mov	r2, r0
 8005c36:	9b03      	ldr	r3, [sp, #12]
 8005c38:	629a      	str	r2, [r3, #40]	; 0x28
 8005c3a:	e007      	b.n	8005c4c <sdcConnect+0x14c>
    }
  }
  else {
    /* The card is an SDC, capacity from the normal CSD.*/
    sdcp->capacity = _mmcsd_get_capacity(sdcp->csd);
 8005c3c:	9b03      	ldr	r3, [sp, #12]
 8005c3e:	3318      	adds	r3, #24
 8005c40:	4618      	mov	r0, r3
 8005c42:	f7fe fd5d 	bl	8004700 <_mmcsd_get_capacity>
 8005c46:	4602      	mov	r2, r0
 8005c48:	9b03      	ldr	r3, [sp, #12]
 8005c4a:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Block length fixed at 512 bytes.*/
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BLOCKLEN,
 8005c4c:	ab06      	add	r3, sp, #24
 8005c4e:	9803      	ldr	r0, [sp, #12]
 8005c50:	2110      	movs	r1, #16
 8005c52:	f44f 7200 	mov.w	r2, #512	; 0x200
 8005c56:	f004 fe53 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005c5a:	4603      	mov	r3, r0
 8005c5c:	2b00      	cmp	r3, #0
 8005c5e:	d122      	bne.n	8005ca6 <sdcConnect+0x1a6>
                                 MMCSD_BLOCK_SIZE, resp) ||
      MMCSD_R1_ERROR(resp[0])) {
 8005c60:	9a06      	ldr	r2, [sp, #24]
 8005c62:	4b16      	ldr	r3, [pc, #88]	; (8005cbc <sdcConnect+0x1bc>)
 8005c64:	4013      	ands	r3, r2
    sdcp->capacity = _mmcsd_get_capacity(sdcp->csd);
  }

  /* Block length fixed at 512 bytes.*/
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BLOCKLEN,
                                 MMCSD_BLOCK_SIZE, resp) ||
 8005c66:	2b00      	cmp	r3, #0
 8005c68:	d11d      	bne.n	8005ca6 <sdcConnect+0x1a6>
      MMCSD_R1_ERROR(resp[0])) {
    goto failed;
  }

  /* Switches to wide bus mode.*/
  switch (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK) {
 8005c6a:	9b03      	ldr	r3, [sp, #12]
 8005c6c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005c6e:	f003 030f 	and.w	r3, r3, #15
 8005c72:	2b01      	cmp	r3, #1
 8005c74:	d902      	bls.n	8005c7c <sdcConnect+0x17c>
 8005c76:	2b02      	cmp	r3, #2
 8005c78:	d008      	beq.n	8005c8c <sdcConnect+0x18c>
      goto failed;
    }
    break;
  default:
    /* Unknown type.*/
    goto failed;
 8005c7a:	e014      	b.n	8005ca6 <sdcConnect+0x1a6>

  /* Switches to wide bus mode.*/
  switch (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK) {
  case SDC_MODE_CARDTYPE_SDV11:
  case SDC_MODE_CARDTYPE_SDV20:
    if (HAL_FAILED == sdc_set_bus_width(sdcp)) {
 8005c7c:	9803      	ldr	r0, [sp, #12]
 8005c7e:	f7ff fe3f 	bl	8005900 <sdc_set_bus_width>
 8005c82:	4603      	mov	r3, r0
 8005c84:	2b00      	cmp	r3, #0
 8005c86:	d000      	beq.n	8005c8a <sdcConnect+0x18a>
      goto failed;
 8005c88:	e00d      	b.n	8005ca6 <sdcConnect+0x1a6>
    }
    break;
 8005c8a:	e007      	b.n	8005c9c <sdcConnect+0x19c>
  case SDC_MODE_CARDTYPE_MMC:
    if (HAL_FAILED == mmc_set_bus_width(sdcp)) {
 8005c8c:	9803      	ldr	r0, [sp, #12]
 8005c8e:	f7ff fe77 	bl	8005980 <mmc_set_bus_width>
 8005c92:	4603      	mov	r3, r0
 8005c94:	2b00      	cmp	r3, #0
 8005c96:	d000      	beq.n	8005c9a <sdcConnect+0x19a>
      goto failed;
 8005c98:	e005      	b.n	8005ca6 <sdcConnect+0x1a6>
    }
    break;
 8005c9a:	bf00      	nop
    /* Unknown type.*/
    goto failed;
  }

  /* Initialization complete.*/
  sdcp->state = BLK_READY;
 8005c9c:	9b03      	ldr	r3, [sp, #12]
 8005c9e:	2205      	movs	r2, #5
 8005ca0:	711a      	strb	r2, [r3, #4]
  return HAL_SUCCESS;
 8005ca2:	2300      	movs	r3, #0
 8005ca4:	e006      	b.n	8005cb4 <sdcConnect+0x1b4>

  /* Connection failed, state reset to BLK_ACTIVE.*/
failed:
  sdc_lld_stop_clk(sdcp);
 8005ca6:	9803      	ldr	r0, [sp, #12]
 8005ca8:	f004 fd92 	bl	800a7d0 <sdc_lld_stop_clk>
  sdcp->state = BLK_ACTIVE;
 8005cac:	9b03      	ldr	r3, [sp, #12]
 8005cae:	2202      	movs	r2, #2
 8005cb0:	711a      	strb	r2, [r3, #4]
  return HAL_FAILED;
 8005cb2:	2301      	movs	r3, #1
}
 8005cb4:	4618      	mov	r0, r3
 8005cb6:	b009      	add	sp, #36	; 0x24
 8005cb8:	f85d fb04 	ldr.w	pc, [sp], #4
 8005cbc:	fdffe008 	.word	0xfdffe008

08005cc0 <sdcDisconnect>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcDisconnect(SDCDriver *sdcp) {
 8005cc0:	b500      	push	{lr}
 8005cc2:	b083      	sub	sp, #12
 8005cc4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(sdcp != NULL);

  osalSysLock();
 8005cc6:	f7ff fbbb 	bl	8005440 <osalSysLock>
  osalDbgAssert((sdcp->state == BLK_ACTIVE) || (sdcp->state == BLK_READY),
                "invalid state");
  if (sdcp->state == BLK_ACTIVE) {
 8005cca:	9b01      	ldr	r3, [sp, #4]
 8005ccc:	791b      	ldrb	r3, [r3, #4]
 8005cce:	2b02      	cmp	r3, #2
 8005cd0:	d103      	bne.n	8005cda <sdcDisconnect+0x1a>
    osalSysUnlock();
 8005cd2:	f7ff fbbd 	bl	8005450 <osalSysUnlock>
    return HAL_SUCCESS;
 8005cd6:	2300      	movs	r3, #0
 8005cd8:	e019      	b.n	8005d0e <sdcDisconnect+0x4e>
  }
  sdcp->state = BLK_DISCONNECTING;
 8005cda:	9b01      	ldr	r3, [sp, #4]
 8005cdc:	2204      	movs	r2, #4
 8005cde:	711a      	strb	r2, [r3, #4]
  osalSysUnlock();
 8005ce0:	f7ff fbb6 	bl	8005450 <osalSysUnlock>

  /* Waits for eventual pending operations completion.*/
  if (_sdc_wait_for_transfer_state(sdcp)) {
 8005ce4:	9801      	ldr	r0, [sp, #4]
 8005ce6:	f7ff fe93 	bl	8005a10 <_sdc_wait_for_transfer_state>
 8005cea:	4603      	mov	r3, r0
 8005cec:	2b00      	cmp	r3, #0
 8005cee:	d007      	beq.n	8005d00 <sdcDisconnect+0x40>
    sdc_lld_stop_clk(sdcp);
 8005cf0:	9801      	ldr	r0, [sp, #4]
 8005cf2:	f004 fd6d 	bl	800a7d0 <sdc_lld_stop_clk>
    sdcp->state = BLK_ACTIVE;
 8005cf6:	9b01      	ldr	r3, [sp, #4]
 8005cf8:	2202      	movs	r2, #2
 8005cfa:	711a      	strb	r2, [r3, #4]
    return HAL_FAILED;
 8005cfc:	2301      	movs	r3, #1
 8005cfe:	e006      	b.n	8005d0e <sdcDisconnect+0x4e>
  }

  /* Card clock stopped.*/
  sdc_lld_stop_clk(sdcp);
 8005d00:	9801      	ldr	r0, [sp, #4]
 8005d02:	f004 fd65 	bl	800a7d0 <sdc_lld_stop_clk>
  sdcp->state = BLK_ACTIVE;
 8005d06:	9b01      	ldr	r3, [sp, #4]
 8005d08:	2202      	movs	r2, #2
 8005d0a:	711a      	strb	r2, [r3, #4]
  return HAL_SUCCESS;
 8005d0c:	2300      	movs	r3, #0
}
 8005d0e:	4618      	mov	r0, r3
 8005d10:	b003      	add	sp, #12
 8005d12:	f85d fb04 	ldr.w	pc, [sp], #4
 8005d16:	bf00      	nop
 8005d18:	f3af 8000 	nop.w
 8005d1c:	f3af 8000 	nop.w

08005d20 <sdcRead>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcRead(SDCDriver *sdcp, uint32_t startblk, uint8_t *buf, uint32_t n) {
 8005d20:	b500      	push	{lr}
 8005d22:	b087      	sub	sp, #28
 8005d24:	9003      	str	r0, [sp, #12]
 8005d26:	9102      	str	r1, [sp, #8]
 8005d28:	9201      	str	r2, [sp, #4]
 8005d2a:	9300      	str	r3, [sp, #0]
  bool status;

  osalDbgCheck((sdcp != NULL) && (buf != NULL) && (n > 0U));
  osalDbgAssert(sdcp->state == BLK_READY, "invalid state");

  if ((startblk + n - 1U) > sdcp->capacity){
 8005d2c:	9a02      	ldr	r2, [sp, #8]
 8005d2e:	9b00      	ldr	r3, [sp, #0]
 8005d30:	4413      	add	r3, r2
 8005d32:	1e5a      	subs	r2, r3, #1
 8005d34:	9b03      	ldr	r3, [sp, #12]
 8005d36:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005d38:	429a      	cmp	r2, r3
 8005d3a:	d907      	bls.n	8005d4c <sdcRead+0x2c>
    sdcp->errors |= SDC_OVERFLOW_ERROR;
 8005d3c:	9b03      	ldr	r3, [sp, #12]
 8005d3e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005d40:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 8005d44:	9b03      	ldr	r3, [sp, #12]
 8005d46:	635a      	str	r2, [r3, #52]	; 0x34
    return HAL_FAILED;
 8005d48:	2301      	movs	r3, #1
 8005d4a:	e010      	b.n	8005d6e <sdcRead+0x4e>
  }

  /* Read operation in progress.*/
  sdcp->state = BLK_READING;
 8005d4c:	9b03      	ldr	r3, [sp, #12]
 8005d4e:	2206      	movs	r2, #6
 8005d50:	711a      	strb	r2, [r3, #4]

  status = sdc_lld_read(sdcp, startblk, buf, n);
 8005d52:	9803      	ldr	r0, [sp, #12]
 8005d54:	9902      	ldr	r1, [sp, #8]
 8005d56:	9a01      	ldr	r2, [sp, #4]
 8005d58:	9b00      	ldr	r3, [sp, #0]
 8005d5a:	f004 ffb1 	bl	800acc0 <sdc_lld_read>
 8005d5e:	4603      	mov	r3, r0
 8005d60:	f88d 3017 	strb.w	r3, [sp, #23]

  /* Read operation finished.*/
  sdcp->state = BLK_READY;
 8005d64:	9b03      	ldr	r3, [sp, #12]
 8005d66:	2205      	movs	r2, #5
 8005d68:	711a      	strb	r2, [r3, #4]
  return status;
 8005d6a:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
 8005d6e:	4618      	mov	r0, r3
 8005d70:	b007      	add	sp, #28
 8005d72:	f85d fb04 	ldr.w	pc, [sp], #4
 8005d76:	bf00      	nop
 8005d78:	f3af 8000 	nop.w
 8005d7c:	f3af 8000 	nop.w

08005d80 <sdcWrite>:
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcWrite(SDCDriver *sdcp, uint32_t startblk,
              const uint8_t *buf, uint32_t n) {
 8005d80:	b500      	push	{lr}
 8005d82:	b087      	sub	sp, #28
 8005d84:	9003      	str	r0, [sp, #12]
 8005d86:	9102      	str	r1, [sp, #8]
 8005d88:	9201      	str	r2, [sp, #4]
 8005d8a:	9300      	str	r3, [sp, #0]
  bool status;

  osalDbgCheck((sdcp != NULL) && (buf != NULL) && (n > 0U));
  osalDbgAssert(sdcp->state == BLK_READY, "invalid state");

  if ((startblk + n - 1U) > sdcp->capacity){
 8005d8c:	9a02      	ldr	r2, [sp, #8]
 8005d8e:	9b00      	ldr	r3, [sp, #0]
 8005d90:	4413      	add	r3, r2
 8005d92:	1e5a      	subs	r2, r3, #1
 8005d94:	9b03      	ldr	r3, [sp, #12]
 8005d96:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005d98:	429a      	cmp	r2, r3
 8005d9a:	d907      	bls.n	8005dac <sdcWrite+0x2c>
    sdcp->errors |= SDC_OVERFLOW_ERROR;
 8005d9c:	9b03      	ldr	r3, [sp, #12]
 8005d9e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005da0:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 8005da4:	9b03      	ldr	r3, [sp, #12]
 8005da6:	635a      	str	r2, [r3, #52]	; 0x34
    return HAL_FAILED;
 8005da8:	2301      	movs	r3, #1
 8005daa:	e010      	b.n	8005dce <sdcWrite+0x4e>
  }

  /* Write operation in progress.*/
  sdcp->state = BLK_WRITING;
 8005dac:	9b03      	ldr	r3, [sp, #12]
 8005dae:	2207      	movs	r2, #7
 8005db0:	711a      	strb	r2, [r3, #4]

  status = sdc_lld_write(sdcp, startblk, buf, n);
 8005db2:	9803      	ldr	r0, [sp, #12]
 8005db4:	9902      	ldr	r1, [sp, #8]
 8005db6:	9a01      	ldr	r2, [sp, #4]
 8005db8:	9b00      	ldr	r3, [sp, #0]
 8005dba:	f004 ffc9 	bl	800ad50 <sdc_lld_write>
 8005dbe:	4603      	mov	r3, r0
 8005dc0:	f88d 3017 	strb.w	r3, [sp, #23]

  /* Write operation finished.*/
  sdcp->state = BLK_READY;
 8005dc4:	9b03      	ldr	r3, [sp, #12]
 8005dc6:	2205      	movs	r2, #5
 8005dc8:	711a      	strb	r2, [r3, #4]
  return status;
 8005dca:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
 8005dce:	4618      	mov	r0, r3
 8005dd0:	b007      	add	sp, #28
 8005dd2:	f85d fb04 	ldr.w	pc, [sp], #4
 8005dd6:	bf00      	nop
 8005dd8:	f3af 8000 	nop.w
 8005ddc:	f3af 8000 	nop.w

08005de0 <sdcGetAndClearErrors>:
 * @param[in] sdcp      pointer to the @p SDCDriver object
 * @return              The errors mask.
 *
 * @api
 */
sdcflags_t sdcGetAndClearErrors(SDCDriver *sdcp) {
 8005de0:	b500      	push	{lr}
 8005de2:	b085      	sub	sp, #20
 8005de4:	9001      	str	r0, [sp, #4]
  sdcflags_t flags;

  osalDbgCheck(sdcp != NULL);
  osalDbgAssert(sdcp->state == BLK_READY, "invalid state");

  osalSysLock();
 8005de6:	f7ff fb2b 	bl	8005440 <osalSysLock>
  flags = sdcp->errors;
 8005dea:	9b01      	ldr	r3, [sp, #4]
 8005dec:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005dee:	9303      	str	r3, [sp, #12]
  sdcp->errors = SDC_NO_ERROR;
 8005df0:	9b01      	ldr	r3, [sp, #4]
 8005df2:	2200      	movs	r2, #0
 8005df4:	635a      	str	r2, [r3, #52]	; 0x34
  osalSysUnlock();
 8005df6:	f7ff fb2b 	bl	8005450 <osalSysUnlock>
  return flags;
 8005dfa:	9b03      	ldr	r3, [sp, #12]
}
 8005dfc:	4618      	mov	r0, r3
 8005dfe:	b005      	add	sp, #20
 8005e00:	f85d fb04 	ldr.w	pc, [sp], #4
 8005e04:	f3af 8000 	nop.w
 8005e08:	f3af 8000 	nop.w
 8005e0c:	f3af 8000 	nop.w

08005e10 <sdcSync>:
 * @retval HAL_SUCCESS  the operation succeeded.
 * @retval HAL_FAILED   the operation failed.
 *
 * @api
 */
bool sdcSync(SDCDriver *sdcp) {
 8005e10:	b500      	push	{lr}
 8005e12:	b085      	sub	sp, #20
 8005e14:	9001      	str	r0, [sp, #4]
  bool result;

  osalDbgCheck(sdcp != NULL);

  if (sdcp->state != BLK_READY) {
 8005e16:	9b01      	ldr	r3, [sp, #4]
 8005e18:	791b      	ldrb	r3, [r3, #4]
 8005e1a:	2b05      	cmp	r3, #5
 8005e1c:	d001      	beq.n	8005e22 <sdcSync+0x12>
    return HAL_FAILED;
 8005e1e:	2301      	movs	r3, #1
 8005e20:	e00d      	b.n	8005e3e <sdcSync+0x2e>
  }

  /* Synchronization operation in progress.*/
  sdcp->state = BLK_SYNCING;
 8005e22:	9b01      	ldr	r3, [sp, #4]
 8005e24:	2208      	movs	r2, #8
 8005e26:	711a      	strb	r2, [r3, #4]

  result = sdc_lld_sync(sdcp);
 8005e28:	9801      	ldr	r0, [sp, #4]
 8005e2a:	f004 ffd9 	bl	800ade0 <sdc_lld_sync>
 8005e2e:	4603      	mov	r3, r0
 8005e30:	f88d 300f 	strb.w	r3, [sp, #15]

  /* Synchronization operation finished.*/
  sdcp->state = BLK_READY;
 8005e34:	9b01      	ldr	r3, [sp, #4]
 8005e36:	2205      	movs	r2, #5
 8005e38:	711a      	strb	r2, [r3, #4]
  return result;
 8005e3a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8005e3e:	4618      	mov	r0, r3
 8005e40:	b005      	add	sp, #20
 8005e42:	f85d fb04 	ldr.w	pc, [sp], #4
 8005e46:	bf00      	nop
 8005e48:	f3af 8000 	nop.w
 8005e4c:	f3af 8000 	nop.w

08005e50 <sdcGetInfo>:
 * @retval HAL_SUCCESS  the operation succeeded.
 * @retval HAL_FAILED   the operation failed.
 *
 * @api
 */
bool sdcGetInfo(SDCDriver *sdcp, BlockDeviceInfo *bdip) {
 8005e50:	b082      	sub	sp, #8
 8005e52:	9001      	str	r0, [sp, #4]
 8005e54:	9100      	str	r1, [sp, #0]

  osalDbgCheck((sdcp != NULL) && (bdip != NULL));

  if (sdcp->state != BLK_READY) {
 8005e56:	9b01      	ldr	r3, [sp, #4]
 8005e58:	791b      	ldrb	r3, [r3, #4]
 8005e5a:	2b05      	cmp	r3, #5
 8005e5c:	d001      	beq.n	8005e62 <sdcGetInfo+0x12>
    return HAL_FAILED;
 8005e5e:	2301      	movs	r3, #1
 8005e60:	e008      	b.n	8005e74 <sdcGetInfo+0x24>
  }

  bdip->blk_num = sdcp->capacity;
 8005e62:	9b01      	ldr	r3, [sp, #4]
 8005e64:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8005e66:	9b00      	ldr	r3, [sp, #0]
 8005e68:	605a      	str	r2, [r3, #4]
  bdip->blk_size = MMCSD_BLOCK_SIZE;
 8005e6a:	9b00      	ldr	r3, [sp, #0]
 8005e6c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8005e70:	601a      	str	r2, [r3, #0]

  return HAL_SUCCESS;
 8005e72:	2300      	movs	r3, #0
}
 8005e74:	4618      	mov	r0, r3
 8005e76:	b002      	add	sp, #8
 8005e78:	4770      	bx	lr
 8005e7a:	bf00      	nop
 8005e7c:	f3af 8000 	nop.w

08005e80 <sdcErase>:
 * @retval HAL_SUCCESS  the operation succeeded.
 * @retval HAL_FAILED   the operation failed.
 *
 * @api
 */
bool sdcErase(SDCDriver *sdcp, uint32_t startblk, uint32_t endblk) {
 8005e80:	b500      	push	{lr}
 8005e82:	b087      	sub	sp, #28
 8005e84:	9003      	str	r0, [sp, #12]
 8005e86:	9102      	str	r1, [sp, #8]
 8005e88:	9201      	str	r2, [sp, #4]

  osalDbgCheck((sdcp != NULL));
  osalDbgAssert(sdcp->state == BLK_READY, "invalid state");

  /* Erase operation in progress.*/
  sdcp->state = BLK_WRITING;
 8005e8a:	9b03      	ldr	r3, [sp, #12]
 8005e8c:	2207      	movs	r2, #7
 8005e8e:	711a      	strb	r2, [r3, #4]

  /* Handling command differences between HC and normal cards.*/
  if ((sdcp->cardmode & SDC_MODE_HIGH_CAPACITY) != 0U) {
 8005e90:	9b03      	ldr	r3, [sp, #12]
 8005e92:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005e94:	f003 0310 	and.w	r3, r3, #16
 8005e98:	2b00      	cmp	r3, #0
 8005e9a:	d005      	beq.n	8005ea8 <sdcErase+0x28>
    startblk *= MMCSD_BLOCK_SIZE;
 8005e9c:	9b02      	ldr	r3, [sp, #8]
 8005e9e:	025b      	lsls	r3, r3, #9
 8005ea0:	9302      	str	r3, [sp, #8]
    endblk *= MMCSD_BLOCK_SIZE;
 8005ea2:	9b01      	ldr	r3, [sp, #4]
 8005ea4:	025b      	lsls	r3, r3, #9
 8005ea6:	9301      	str	r3, [sp, #4]
  }

  if (_sdc_wait_for_transfer_state(sdcp)) {
 8005ea8:	9803      	ldr	r0, [sp, #12]
 8005eaa:	f7ff fdb1 	bl	8005a10 <_sdc_wait_for_transfer_state>
 8005eae:	4603      	mov	r3, r0
 8005eb0:	2b00      	cmp	r3, #0
 8005eb2:	d000      	beq.n	8005eb6 <sdcErase+0x36>
    goto failed;
 8005eb4:	e035      	b.n	8005f22 <sdcErase+0xa2>
  }

  if ((sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_ERASE_RW_BLK_START,
 8005eb6:	ab05      	add	r3, sp, #20
 8005eb8:	9803      	ldr	r0, [sp, #12]
 8005eba:	2120      	movs	r1, #32
 8005ebc:	9a02      	ldr	r2, [sp, #8]
 8005ebe:	f004 fd1f 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005ec2:	4603      	mov	r3, r0
 8005ec4:	2b00      	cmp	r3, #0
 8005ec6:	d12c      	bne.n	8005f22 <sdcErase+0xa2>
                                  startblk, resp) != HAL_SUCCESS) ||
      MMCSD_R1_ERROR(resp[0])) {
 8005ec8:	9a05      	ldr	r2, [sp, #20]
 8005eca:	4b1a      	ldr	r3, [pc, #104]	; (8005f34 <sdcErase+0xb4>)
 8005ecc:	4013      	ands	r3, r2
  if (_sdc_wait_for_transfer_state(sdcp)) {
    goto failed;
  }

  if ((sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_ERASE_RW_BLK_START,
                                  startblk, resp) != HAL_SUCCESS) ||
 8005ece:	2b00      	cmp	r3, #0
 8005ed0:	d127      	bne.n	8005f22 <sdcErase+0xa2>
      MMCSD_R1_ERROR(resp[0])) {
    goto failed;
  }

  if ((sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_ERASE_RW_BLK_END,
 8005ed2:	ab05      	add	r3, sp, #20
 8005ed4:	9803      	ldr	r0, [sp, #12]
 8005ed6:	2121      	movs	r1, #33	; 0x21
 8005ed8:	9a01      	ldr	r2, [sp, #4]
 8005eda:	f004 fd11 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005ede:	4603      	mov	r3, r0
 8005ee0:	2b00      	cmp	r3, #0
 8005ee2:	d11e      	bne.n	8005f22 <sdcErase+0xa2>
                                  endblk, resp) != HAL_SUCCESS) ||
      MMCSD_R1_ERROR(resp[0])) {
 8005ee4:	9a05      	ldr	r2, [sp, #20]
 8005ee6:	4b13      	ldr	r3, [pc, #76]	; (8005f34 <sdcErase+0xb4>)
 8005ee8:	4013      	ands	r3, r2
      MMCSD_R1_ERROR(resp[0])) {
    goto failed;
  }

  if ((sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_ERASE_RW_BLK_END,
                                  endblk, resp) != HAL_SUCCESS) ||
 8005eea:	2b00      	cmp	r3, #0
 8005eec:	d119      	bne.n	8005f22 <sdcErase+0xa2>
      MMCSD_R1_ERROR(resp[0])) {
    goto failed;
  }

  if ((sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_ERASE,
 8005eee:	ab05      	add	r3, sp, #20
 8005ef0:	9803      	ldr	r0, [sp, #12]
 8005ef2:	2126      	movs	r1, #38	; 0x26
 8005ef4:	2200      	movs	r2, #0
 8005ef6:	f004 fd03 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005efa:	4603      	mov	r3, r0
 8005efc:	2b00      	cmp	r3, #0
 8005efe:	d110      	bne.n	8005f22 <sdcErase+0xa2>
                                  0, resp) != HAL_SUCCESS) ||
      MMCSD_R1_ERROR(resp[0])) {
 8005f00:	9a05      	ldr	r2, [sp, #20]
 8005f02:	4b0c      	ldr	r3, [pc, #48]	; (8005f34 <sdcErase+0xb4>)
 8005f04:	4013      	ands	r3, r2
      MMCSD_R1_ERROR(resp[0])) {
    goto failed;
  }

  if ((sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_ERASE,
                                  0, resp) != HAL_SUCCESS) ||
 8005f06:	2b00      	cmp	r3, #0
 8005f08:	d10b      	bne.n	8005f22 <sdcErase+0xa2>

  /* Quick sleep to allow it to transition to programming or receiving state */
  /* TODO: ??????????????????????????? */

  /* Wait for it to return to transfer state to indicate it has finished erasing */
  if (_sdc_wait_for_transfer_state(sdcp)) {
 8005f0a:	9803      	ldr	r0, [sp, #12]
 8005f0c:	f7ff fd80 	bl	8005a10 <_sdc_wait_for_transfer_state>
 8005f10:	4603      	mov	r3, r0
 8005f12:	2b00      	cmp	r3, #0
 8005f14:	d000      	beq.n	8005f18 <sdcErase+0x98>
    goto failed;
 8005f16:	e004      	b.n	8005f22 <sdcErase+0xa2>
  }

  sdcp->state = BLK_READY;
 8005f18:	9b03      	ldr	r3, [sp, #12]
 8005f1a:	2205      	movs	r2, #5
 8005f1c:	711a      	strb	r2, [r3, #4]
  return HAL_SUCCESS;
 8005f1e:	2300      	movs	r3, #0
 8005f20:	e003      	b.n	8005f2a <sdcErase+0xaa>

failed:
  sdcp->state = BLK_READY;
 8005f22:	9b03      	ldr	r3, [sp, #12]
 8005f24:	2205      	movs	r2, #5
 8005f26:	711a      	strb	r2, [r3, #4]
  return HAL_FAILED;
 8005f28:	2301      	movs	r3, #1
}
 8005f2a:	4618      	mov	r0, r3
 8005f2c:	b007      	add	sp, #28
 8005f2e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005f32:	bf00      	nop
 8005f34:	fdffe008 	.word	0xfdffe008
 8005f38:	f3af 8000 	nop.w
 8005f3c:	f3af 8000 	nop.w

08005f40 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8005f40:	b082      	sub	sp, #8
 8005f42:	2320      	movs	r3, #32
 8005f44:	9301      	str	r3, [sp, #4]
 8005f46:	9b01      	ldr	r3, [sp, #4]
 8005f48:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8005f4c:	b002      	add	sp, #8
 8005f4e:	4770      	bx	lr

08005f50 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8005f50:	b082      	sub	sp, #8
 8005f52:	2300      	movs	r3, #0
 8005f54:	9301      	str	r3, [sp, #4]
 8005f56:	9b01      	ldr	r3, [sp, #4]
 8005f58:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8005f5c:	b002      	add	sp, #8
 8005f5e:	4770      	bx	lr

08005f60 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8005f60:	b508      	push	{r3, lr}

  port_lock();
 8005f62:	f7ff ffed 	bl	8005f40 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8005f66:	bd08      	pop	{r3, pc}
 8005f68:	f3af 8000 	nop.w
 8005f6c:	f3af 8000 	nop.w

08005f70 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8005f70:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8005f72:	f7ff ffed 	bl	8005f50 <port_unlock>
}
 8005f76:	bd08      	pop	{r3, pc}
 8005f78:	f3af 8000 	nop.w
 8005f7c:	f3af 8000 	nop.w

08005f80 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 8005f80:	b082      	sub	sp, #8
 8005f82:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 8005f84:	9b01      	ldr	r3, [sp, #4]
 8005f86:	9a01      	ldr	r2, [sp, #4]
 8005f88:	601a      	str	r2, [r3, #0]
}
 8005f8a:	b002      	add	sp, #8
 8005f8c:	4770      	bx	lr
 8005f8e:	bf00      	nop

08005f90 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 8005f90:	b082      	sub	sp, #8
 8005f92:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8005f94:	9b01      	ldr	r3, [sp, #4]
 8005f96:	689b      	ldr	r3, [r3, #8]
 8005f98:	2b00      	cmp	r3, #0
 8005f9a:	bf14      	ite	ne
 8005f9c:	2300      	movne	r3, #0
 8005f9e:	2301      	moveq	r3, #1
 8005fa0:	b2db      	uxtb	r3, r3
}
 8005fa2:	4618      	mov	r0, r3
 8005fa4:	b002      	add	sp, #8
 8005fa6:	4770      	bx	lr
 8005fa8:	f3af 8000 	nop.w
 8005fac:	f3af 8000 	nop.w

08005fb0 <chOQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
 8005fb0:	b082      	sub	sp, #8
 8005fb2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8005fb4:	9b01      	ldr	r3, [sp, #4]
 8005fb6:	689b      	ldr	r3, [r3, #8]
 8005fb8:	2b00      	cmp	r3, #0
 8005fba:	bf14      	ite	ne
 8005fbc:	2300      	movne	r3, #0
 8005fbe:	2301      	moveq	r3, #1
 8005fc0:	b2db      	uxtb	r3, r3
}
 8005fc2:	4618      	mov	r0, r3
 8005fc4:	b002      	add	sp, #8
 8005fc6:	4770      	bx	lr
 8005fc8:	f3af 8000 	nop.w
 8005fcc:	f3af 8000 	nop.w

08005fd0 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8005fd0:	b508      	push	{r3, lr}

  chSysLock();
 8005fd2:	f7ff ffc5 	bl	8005f60 <chSysLock>
}
 8005fd6:	bd08      	pop	{r3, pc}
 8005fd8:	f3af 8000 	nop.w
 8005fdc:	f3af 8000 	nop.w

08005fe0 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8005fe0:	b508      	push	{r3, lr}

  chSysUnlock();
 8005fe2:	f7ff ffc5 	bl	8005f70 <chSysUnlock>
}
 8005fe6:	bd08      	pop	{r3, pc}
 8005fe8:	f3af 8000 	nop.w
 8005fec:	f3af 8000 	nop.w

08005ff0 <osalOsRescheduleS>:
 *          required in this scenario.
 * @note    Not implemented in this simplified OSAL.
 *
 * @sclass
 */
static inline void osalOsRescheduleS(void) {
 8005ff0:	b508      	push	{r3, lr}

  chSchRescheduleS();
 8005ff2:	f7fa fec5 	bl	8000d80 <chSchRescheduleS>
}
 8005ff6:	bd08      	pop	{r3, pc}
 8005ff8:	f3af 8000 	nop.w
 8005ffc:	f3af 8000 	nop.w

08006000 <osalEventObjectInit>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
 8006000:	b500      	push	{lr}
 8006002:	b083      	sub	sp, #12
 8006004:	9001      	str	r0, [sp, #4]

  chEvtObjectInit(esp);
 8006006:	9801      	ldr	r0, [sp, #4]
 8006008:	f7ff ffba 	bl	8005f80 <chEvtObjectInit>
}
 800600c:	b003      	add	sp, #12
 800600e:	f85d fb04 	ldr.w	pc, [sp], #4
 8006012:	bf00      	nop
 8006014:	f3af 8000 	nop.w
 8006018:	f3af 8000 	nop.w
 800601c:	f3af 8000 	nop.w

08006020 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 8006020:	b500      	push	{lr}
 8006022:	b083      	sub	sp, #12
 8006024:	9001      	str	r0, [sp, #4]
 8006026:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 8006028:	9801      	ldr	r0, [sp, #4]
 800602a:	9900      	ldr	r1, [sp, #0]
 800602c:	f7fc fb28 	bl	8002680 <chEvtBroadcastFlagsI>
}
 8006030:	b003      	add	sp, #12
 8006032:	f85d fb04 	ldr.w	pc, [sp], #4
 8006036:	bf00      	nop
 8006038:	f3af 8000 	nop.w
 800603c:	f3af 8000 	nop.w

08006040 <write>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 8006040:	b500      	push	{lr}
 8006042:	b085      	sub	sp, #20
 8006044:	9003      	str	r0, [sp, #12]
 8006046:	9102      	str	r1, [sp, #8]
 8006048:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 800604a:	9b03      	ldr	r3, [sp, #12]
 800604c:	3330      	adds	r3, #48	; 0x30
 800604e:	4618      	mov	r0, r3
 8006050:	9902      	ldr	r1, [sp, #8]
 8006052:	9a01      	ldr	r2, [sp, #4]
 8006054:	f04f 33ff 	mov.w	r3, #4294967295
 8006058:	f7fd fa72 	bl	8003540 <chOQWriteTimeout>
 800605c:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
 800605e:	4618      	mov	r0, r3
 8006060:	b005      	add	sp, #20
 8006062:	f85d fb04 	ldr.w	pc, [sp], #4
 8006066:	bf00      	nop
 8006068:	f3af 8000 	nop.w
 800606c:	f3af 8000 	nop.w

08006070 <read>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
 8006070:	b500      	push	{lr}
 8006072:	b085      	sub	sp, #20
 8006074:	9003      	str	r0, [sp, #12]
 8006076:	9102      	str	r1, [sp, #8]
 8006078:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 800607a:	9b03      	ldr	r3, [sp, #12]
 800607c:	330c      	adds	r3, #12
 800607e:	4618      	mov	r0, r3
 8006080:	9902      	ldr	r1, [sp, #8]
 8006082:	9a01      	ldr	r2, [sp, #4]
 8006084:	f04f 33ff 	mov.w	r3, #4294967295
 8006088:	f7fd f942 	bl	8003310 <chIQReadTimeout>
 800608c:	4603      	mov	r3, r0
                       n, TIME_INFINITE);
}
 800608e:	4618      	mov	r0, r3
 8006090:	b005      	add	sp, #20
 8006092:	f85d fb04 	ldr.w	pc, [sp], #4
 8006096:	bf00      	nop
 8006098:	f3af 8000 	nop.w
 800609c:	f3af 8000 	nop.w

080060a0 <put>:

static msg_t put(void *ip, uint8_t b) {
 80060a0:	b500      	push	{lr}
 80060a2:	b083      	sub	sp, #12
 80060a4:	9001      	str	r0, [sp, #4]
 80060a6:	460b      	mov	r3, r1
 80060a8:	f88d 3003 	strb.w	r3, [sp, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 80060ac:	9b01      	ldr	r3, [sp, #4]
 80060ae:	f103 0230 	add.w	r2, r3, #48	; 0x30
 80060b2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80060b6:	4610      	mov	r0, r2
 80060b8:	4619      	mov	r1, r3
 80060ba:	f04f 32ff 	mov.w	r2, #4294967295
 80060be:	f7fd f9c7 	bl	8003450 <chOQPutTimeout>
 80060c2:	4603      	mov	r3, r0
}
 80060c4:	4618      	mov	r0, r3
 80060c6:	b003      	add	sp, #12
 80060c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80060cc:	f3af 8000 	nop.w

080060d0 <get>:

static msg_t get(void *ip) {
 80060d0:	b500      	push	{lr}
 80060d2:	b083      	sub	sp, #12
 80060d4:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80060d6:	9b01      	ldr	r3, [sp, #4]
 80060d8:	330c      	adds	r3, #12
 80060da:	4618      	mov	r0, r3
 80060dc:	f04f 31ff 	mov.w	r1, #4294967295
 80060e0:	f7fd f8ce 	bl	8003280 <chIQGetTimeout>
 80060e4:	4603      	mov	r3, r0
}
 80060e6:	4618      	mov	r0, r3
 80060e8:	b003      	add	sp, #12
 80060ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80060ee:	bf00      	nop

080060f0 <putt>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 80060f0:	b500      	push	{lr}
 80060f2:	b085      	sub	sp, #20
 80060f4:	9003      	str	r0, [sp, #12]
 80060f6:	460b      	mov	r3, r1
 80060f8:	9201      	str	r2, [sp, #4]
 80060fa:	f88d 300b 	strb.w	r3, [sp, #11]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80060fe:	9b03      	ldr	r3, [sp, #12]
 8006100:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8006104:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006108:	4610      	mov	r0, r2
 800610a:	4619      	mov	r1, r3
 800610c:	9a01      	ldr	r2, [sp, #4]
 800610e:	f7fd f99f 	bl	8003450 <chOQPutTimeout>
 8006112:	4603      	mov	r3, r0
}
 8006114:	4618      	mov	r0, r3
 8006116:	b005      	add	sp, #20
 8006118:	f85d fb04 	ldr.w	pc, [sp], #4
 800611c:	f3af 8000 	nop.w

08006120 <gett>:

static msg_t gett(void *ip, systime_t timeout) {
 8006120:	b500      	push	{lr}
 8006122:	b083      	sub	sp, #12
 8006124:	9001      	str	r0, [sp, #4]
 8006126:	9100      	str	r1, [sp, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8006128:	9b01      	ldr	r3, [sp, #4]
 800612a:	330c      	adds	r3, #12
 800612c:	4618      	mov	r0, r3
 800612e:	9900      	ldr	r1, [sp, #0]
 8006130:	f7fd f8a6 	bl	8003280 <chIQGetTimeout>
 8006134:	4603      	mov	r3, r0
}
 8006136:	4618      	mov	r0, r3
 8006138:	b003      	add	sp, #12
 800613a:	f85d fb04 	ldr.w	pc, [sp], #4
 800613e:	bf00      	nop

08006140 <writet>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8006140:	b500      	push	{lr}
 8006142:	b085      	sub	sp, #20
 8006144:	9003      	str	r0, [sp, #12]
 8006146:	9102      	str	r1, [sp, #8]
 8006148:	9201      	str	r2, [sp, #4]
 800614a:	9300      	str	r3, [sp, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 800614c:	9b03      	ldr	r3, [sp, #12]
 800614e:	3330      	adds	r3, #48	; 0x30
 8006150:	4618      	mov	r0, r3
 8006152:	9902      	ldr	r1, [sp, #8]
 8006154:	9a01      	ldr	r2, [sp, #4]
 8006156:	9b00      	ldr	r3, [sp, #0]
 8006158:	f7fd f9f2 	bl	8003540 <chOQWriteTimeout>
 800615c:	4603      	mov	r3, r0
}
 800615e:	4618      	mov	r0, r3
 8006160:	b005      	add	sp, #20
 8006162:	f85d fb04 	ldr.w	pc, [sp], #4
 8006166:	bf00      	nop
 8006168:	f3af 8000 	nop.w
 800616c:	f3af 8000 	nop.w

08006170 <readt>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8006170:	b500      	push	{lr}
 8006172:	b085      	sub	sp, #20
 8006174:	9003      	str	r0, [sp, #12]
 8006176:	9102      	str	r1, [sp, #8]
 8006178:	9201      	str	r2, [sp, #4]
 800617a:	9300      	str	r3, [sp, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 800617c:	9b03      	ldr	r3, [sp, #12]
 800617e:	330c      	adds	r3, #12
 8006180:	4618      	mov	r0, r3
 8006182:	9902      	ldr	r1, [sp, #8]
 8006184:	9a01      	ldr	r2, [sp, #4]
 8006186:	9b00      	ldr	r3, [sp, #0]
 8006188:	f7fd f8c2 	bl	8003310 <chIQReadTimeout>
 800618c:	4603      	mov	r3, r0
}
 800618e:	4618      	mov	r0, r3
 8006190:	b005      	add	sp, #20
 8006192:	f85d fb04 	ldr.w	pc, [sp], #4
 8006196:	bf00      	nop
 8006198:	f3af 8000 	nop.w
 800619c:	f3af 8000 	nop.w

080061a0 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
 80061a0:	b508      	push	{r3, lr}

  sd_lld_init();
 80061a2:	f005 fc85 	bl	800bab0 <sd_lld_init>
}
 80061a6:	bd08      	pop	{r3, pc}
 80061a8:	f3af 8000 	nop.w
 80061ac:	f3af 8000 	nop.w

080061b0 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 80061b0:	b500      	push	{lr}
 80061b2:	b087      	sub	sp, #28
 80061b4:	9005      	str	r0, [sp, #20]
 80061b6:	9104      	str	r1, [sp, #16]
 80061b8:	9203      	str	r2, [sp, #12]

  sdp->vmt = &vmt;
 80061ba:	9b05      	ldr	r3, [sp, #20]
 80061bc:	4a13      	ldr	r2, [pc, #76]	; (800620c <sdObjectInit+0x5c>)
 80061be:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
 80061c0:	9b05      	ldr	r3, [sp, #20]
 80061c2:	3304      	adds	r3, #4
 80061c4:	4618      	mov	r0, r3
 80061c6:	f7ff ff1b 	bl	8006000 <osalEventObjectInit>
  sdp->state = SD_STOP;
 80061ca:	9b05      	ldr	r3, [sp, #20]
 80061cc:	2201      	movs	r2, #1
 80061ce:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 80061d0:	9b05      	ldr	r3, [sp, #20]
 80061d2:	f103 020c 	add.w	r2, r3, #12
 80061d6:	9b05      	ldr	r3, [sp, #20]
 80061d8:	3354      	adds	r3, #84	; 0x54
 80061da:	9905      	ldr	r1, [sp, #20]
 80061dc:	9100      	str	r1, [sp, #0]
 80061de:	4610      	mov	r0, r2
 80061e0:	4619      	mov	r1, r3
 80061e2:	2210      	movs	r2, #16
 80061e4:	9b04      	ldr	r3, [sp, #16]
 80061e6:	f7fc ffdb 	bl	80031a0 <chIQObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 80061ea:	9b05      	ldr	r3, [sp, #20]
 80061ec:	f103 0230 	add.w	r2, r3, #48	; 0x30
 80061f0:	9b05      	ldr	r3, [sp, #20]
 80061f2:	3364      	adds	r3, #100	; 0x64
 80061f4:	9905      	ldr	r1, [sp, #20]
 80061f6:	9100      	str	r1, [sp, #0]
 80061f8:	4610      	mov	r0, r2
 80061fa:	4619      	mov	r1, r3
 80061fc:	2210      	movs	r2, #16
 80061fe:	9b03      	ldr	r3, [sp, #12]
 8006200:	f7fd f8de 	bl	80033c0 <chOQObjectInit>
}
 8006204:	b007      	add	sp, #28
 8006206:	f85d fb04 	ldr.w	pc, [sp], #4
 800620a:	bf00      	nop
 800620c:	08017840 	.word	0x08017840

08006210 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8006210:	b500      	push	{lr}
 8006212:	b083      	sub	sp, #12
 8006214:	9001      	str	r0, [sp, #4]
 8006216:	9100      	str	r1, [sp, #0]

  osalDbgCheck(sdp != NULL);

  osalSysLock();
 8006218:	f7ff feda 	bl	8005fd0 <osalSysLock>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
 800621c:	9801      	ldr	r0, [sp, #4]
 800621e:	9900      	ldr	r1, [sp, #0]
 8006220:	f005 fc66 	bl	800baf0 <sd_lld_start>
  sdp->state = SD_READY;
 8006224:	9b01      	ldr	r3, [sp, #4]
 8006226:	2202      	movs	r2, #2
 8006228:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
 800622a:	f7ff fed9 	bl	8005fe0 <osalSysUnlock>
}
 800622e:	b003      	add	sp, #12
 8006230:	f85d fb04 	ldr.w	pc, [sp], #4
 8006234:	f3af 8000 	nop.w
 8006238:	f3af 8000 	nop.w
 800623c:	f3af 8000 	nop.w

08006240 <sdStop>:
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 *
 * @api
 */
void sdStop(SerialDriver *sdp) {
 8006240:	b500      	push	{lr}
 8006242:	b083      	sub	sp, #12
 8006244:	9001      	str	r0, [sp, #4]

  osalDbgCheck(sdp != NULL);

  osalSysLock();
 8006246:	f7ff fec3 	bl	8005fd0 <osalSysLock>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_stop(sdp);
 800624a:	9801      	ldr	r0, [sp, #4]
 800624c:	f005 fc78 	bl	800bb40 <sd_lld_stop>
  sdp->state = SD_STOP;
 8006250:	9b01      	ldr	r3, [sp, #4]
 8006252:	2201      	movs	r2, #1
 8006254:	721a      	strb	r2, [r3, #8]
  oqResetI(&sdp->oqueue);
 8006256:	9b01      	ldr	r3, [sp, #4]
 8006258:	3330      	adds	r3, #48	; 0x30
 800625a:	4618      	mov	r0, r3
 800625c:	f7fd f8d8 	bl	8003410 <chOQResetI>
  iqResetI(&sdp->iqueue);
 8006260:	9b01      	ldr	r3, [sp, #4]
 8006262:	330c      	adds	r3, #12
 8006264:	4618      	mov	r0, r3
 8006266:	f7fc ffc3 	bl	80031f0 <chIQResetI>
  osalOsRescheduleS();
 800626a:	f7ff fec1 	bl	8005ff0 <osalOsRescheduleS>
  osalSysUnlock();
 800626e:	f7ff feb7 	bl	8005fe0 <osalSysUnlock>
}
 8006272:	b003      	add	sp, #12
 8006274:	f85d fb04 	ldr.w	pc, [sp], #4
 8006278:	f3af 8000 	nop.w
 800627c:	f3af 8000 	nop.w

08006280 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8006280:	b500      	push	{lr}
 8006282:	b083      	sub	sp, #12
 8006284:	9001      	str	r0, [sp, #4]
 8006286:	460b      	mov	r3, r1
 8006288:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 800628c:	9b01      	ldr	r3, [sp, #4]
 800628e:	330c      	adds	r3, #12
 8006290:	4618      	mov	r0, r3
 8006292:	f7ff fe7d 	bl	8005f90 <chIQIsEmptyI>
 8006296:	4603      	mov	r3, r0
 8006298:	2b00      	cmp	r3, #0
 800629a:	d005      	beq.n	80062a8 <sdIncomingDataI+0x28>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 800629c:	9b01      	ldr	r3, [sp, #4]
 800629e:	3304      	adds	r3, #4
 80062a0:	4618      	mov	r0, r3
 80062a2:	2104      	movs	r1, #4
 80062a4:	f7ff febc 	bl	8006020 <osalEventBroadcastFlagsI>
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 80062a8:	9b01      	ldr	r3, [sp, #4]
 80062aa:	f103 020c 	add.w	r2, r3, #12
 80062ae:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80062b2:	4610      	mov	r0, r2
 80062b4:	4619      	mov	r1, r3
 80062b6:	f7fc ffb3 	bl	8003220 <chIQPutI>
 80062ba:	4603      	mov	r3, r0
 80062bc:	2b00      	cmp	r3, #0
 80062be:	da05      	bge.n	80062cc <sdIncomingDataI+0x4c>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
 80062c0:	9b01      	ldr	r3, [sp, #4]
 80062c2:	3304      	adds	r3, #4
 80062c4:	4618      	mov	r0, r3
 80062c6:	2180      	movs	r1, #128	; 0x80
 80062c8:	f7ff feaa 	bl	8006020 <osalEventBroadcastFlagsI>
}
 80062cc:	b003      	add	sp, #12
 80062ce:	f85d fb04 	ldr.w	pc, [sp], #4
 80062d2:	bf00      	nop
 80062d4:	f3af 8000 	nop.w
 80062d8:	f3af 8000 	nop.w
 80062dc:	f3af 8000 	nop.w

080062e0 <sdRequestDataI>:
 * @retval Q_EMPTY      if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
 80062e0:	b500      	push	{lr}
 80062e2:	b085      	sub	sp, #20
 80062e4:	9001      	str	r0, [sp, #4]
  msg_t  b;

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  b = oqGetI(&sdp->oqueue);
 80062e6:	9b01      	ldr	r3, [sp, #4]
 80062e8:	3330      	adds	r3, #48	; 0x30
 80062ea:	4618      	mov	r0, r3
 80062ec:	f7fd f8f8 	bl	80034e0 <chOQGetI>
 80062f0:	9003      	str	r0, [sp, #12]
  if (b < Q_OK)
 80062f2:	9b03      	ldr	r3, [sp, #12]
 80062f4:	2b00      	cmp	r3, #0
 80062f6:	da05      	bge.n	8006304 <sdRequestDataI+0x24>
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 80062f8:	9b01      	ldr	r3, [sp, #4]
 80062fa:	3304      	adds	r3, #4
 80062fc:	4618      	mov	r0, r3
 80062fe:	2108      	movs	r1, #8
 8006300:	f7ff fe8e 	bl	8006020 <osalEventBroadcastFlagsI>
  return b;
 8006304:	9b03      	ldr	r3, [sp, #12]
}
 8006306:	4618      	mov	r0, r3
 8006308:	b005      	add	sp, #20
 800630a:	f85d fb04 	ldr.w	pc, [sp], #4
 800630e:	bf00      	nop

08006310 <sdPutWouldBlock>:
 *
 * @deprecated
 *
 * @api
 */
bool sdPutWouldBlock(SerialDriver *sdp) {
 8006310:	b500      	push	{lr}
 8006312:	b085      	sub	sp, #20
 8006314:	9001      	str	r0, [sp, #4]
  bool b;

  osalSysLock();
 8006316:	f7ff fe5b 	bl	8005fd0 <osalSysLock>
  b = oqIsFullI(&sdp->oqueue);
 800631a:	9b01      	ldr	r3, [sp, #4]
 800631c:	3330      	adds	r3, #48	; 0x30
 800631e:	4618      	mov	r0, r3
 8006320:	f7ff fe46 	bl	8005fb0 <chOQIsFullI>
 8006324:	4603      	mov	r3, r0
 8006326:	f88d 300f 	strb.w	r3, [sp, #15]
  osalSysUnlock();
 800632a:	f7ff fe59 	bl	8005fe0 <osalSysUnlock>

  return b;
 800632e:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8006332:	4618      	mov	r0, r3
 8006334:	b005      	add	sp, #20
 8006336:	f85d fb04 	ldr.w	pc, [sp], #4
 800633a:	bf00      	nop
 800633c:	f3af 8000 	nop.w

08006340 <sdGetWouldBlock>:
 *
 * @deprecated
 *
 * @api
 */
bool sdGetWouldBlock(SerialDriver *sdp) {
 8006340:	b500      	push	{lr}
 8006342:	b085      	sub	sp, #20
 8006344:	9001      	str	r0, [sp, #4]
  bool b;

  osalSysLock();
 8006346:	f7ff fe43 	bl	8005fd0 <osalSysLock>
  b = iqIsEmptyI(&sdp->iqueue);
 800634a:	9b01      	ldr	r3, [sp, #4]
 800634c:	330c      	adds	r3, #12
 800634e:	4618      	mov	r0, r3
 8006350:	f7ff fe1e 	bl	8005f90 <chIQIsEmptyI>
 8006354:	4603      	mov	r3, r0
 8006356:	f88d 300f 	strb.w	r3, [sp, #15]
  osalSysUnlock();
 800635a:	f7ff fe41 	bl	8005fe0 <osalSysUnlock>

  return b;
 800635e:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8006362:	4618      	mov	r0, r3
 8006364:	b005      	add	sp, #20
 8006366:	f85d fb04 	ldr.w	pc, [sp], #4
 800636a:	bf00      	nop
 800636c:	f3af 8000 	nop.w

08006370 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8006370:	b082      	sub	sp, #8
 8006372:	2320      	movs	r3, #32
 8006374:	9301      	str	r3, [sp, #4]
 8006376:	9b01      	ldr	r3, [sp, #4]
 8006378:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800637c:	b002      	add	sp, #8
 800637e:	4770      	bx	lr

08006380 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8006380:	b082      	sub	sp, #8
 8006382:	2300      	movs	r3, #0
 8006384:	9301      	str	r3, [sp, #4]
 8006386:	9b01      	ldr	r3, [sp, #4]
 8006388:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800638c:	b002      	add	sp, #8
 800638e:	4770      	bx	lr

08006390 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8006390:	b508      	push	{r3, lr}

  port_lock();
 8006392:	f7ff ffed 	bl	8006370 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8006396:	bd08      	pop	{r3, pc}
 8006398:	f3af 8000 	nop.w
 800639c:	f3af 8000 	nop.w

080063a0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80063a0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80063a2:	f7ff ffed 	bl	8006380 <port_unlock>
}
 80063a6:	bd08      	pop	{r3, pc}
 80063a8:	f3af 8000 	nop.w
 80063ac:	f3af 8000 	nop.w

080063b0 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 80063b0:	b508      	push	{r3, lr}

  chSysLock();
 80063b2:	f7ff ffed 	bl	8006390 <chSysLock>
}
 80063b6:	bd08      	pop	{r3, pc}
 80063b8:	f3af 8000 	nop.w
 80063bc:	f3af 8000 	nop.w

080063c0 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 80063c0:	b508      	push	{r3, lr}

  chSysUnlock();
 80063c2:	f7ff ffed 	bl	80063a0 <chSysUnlock>
}
 80063c6:	bd08      	pop	{r3, pc}
 80063c8:	f3af 8000 	nop.w
 80063cc:	f3af 8000 	nop.w

080063d0 <osalThreadSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 80063d0:	b500      	push	{lr}
 80063d2:	b083      	sub	sp, #12
 80063d4:	9001      	str	r0, [sp, #4]

  return chThdSuspendS(trp);
 80063d6:	9801      	ldr	r0, [sp, #4]
 80063d8:	f7fb f83a 	bl	8001450 <chThdSuspendS>
 80063dc:	4603      	mov	r3, r0
}
 80063de:	4618      	mov	r0, r3
 80063e0:	b003      	add	sp, #12
 80063e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80063e6:	bf00      	nop
 80063e8:	f3af 8000 	nop.w
 80063ec:	f3af 8000 	nop.w

080063f0 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
 80063f0:	b500      	push	{lr}
 80063f2:	b083      	sub	sp, #12
 80063f4:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 80063f6:	9801      	ldr	r0, [sp, #4]
 80063f8:	f7fb fd7a 	bl	8001ef0 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
 80063fc:	b003      	add	sp, #12
 80063fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8006402:	bf00      	nop
 8006404:	f3af 8000 	nop.w
 8006408:	f3af 8000 	nop.w
 800640c:	f3af 8000 	nop.w

08006410 <osalMutexLock>:
 *
 * @param[in,out] mp    pointer to the @p mutex_t object
 *
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {
 8006410:	b500      	push	{lr}
 8006412:	b083      	sub	sp, #12
 8006414:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 8006416:	9801      	ldr	r0, [sp, #4]
 8006418:	f7fb fd7a 	bl	8001f10 <chMtxLock>
#elif CH_CFG_USE_SEMAPHORES
  chSemWait((semaphore_t *)mp);
#else
  *mp = 1;
#endif
}
 800641c:	b003      	add	sp, #12
 800641e:	f85d fb04 	ldr.w	pc, [sp], #4
 8006422:	bf00      	nop
 8006424:	f3af 8000 	nop.w
 8006428:	f3af 8000 	nop.w
 800642c:	f3af 8000 	nop.w

08006430 <osalMutexUnlock>:
 *
 * @param[in,out] mp    pointer to the @p mutex_t object
 *
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {
 8006430:	b500      	push	{lr}
 8006432:	b083      	sub	sp, #12
 8006434:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 8006436:	9801      	ldr	r0, [sp, #4]
 8006438:	f7fb fe12 	bl	8002060 <chMtxUnlock>
#elif CH_CFG_USE_SEMAPHORES
  chSemSignal((semaphore_t *)mp);
#else
  *mp = 0;
#endif
}
 800643c:	b003      	add	sp, #12
 800643e:	f85d fb04 	ldr.w	pc, [sp], #4
 8006442:	bf00      	nop
 8006444:	f3af 8000 	nop.w
 8006448:	f3af 8000 	nop.w
 800644c:	f3af 8000 	nop.w

08006450 <spiInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void spiInit(void) {
 8006450:	b508      	push	{r3, lr}

  spi_lld_init();
 8006452:	f004 fdb5 	bl	800afc0 <spi_lld_init>
}
 8006456:	bd08      	pop	{r3, pc}
 8006458:	f3af 8000 	nop.w
 800645c:	f3af 8000 	nop.w

08006460 <spiObjectInit>:
 *
 * @param[out] spip     pointer to the @p SPIDriver object
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {
 8006460:	b500      	push	{lr}
 8006462:	b083      	sub	sp, #12
 8006464:	9001      	str	r0, [sp, #4]

  spip->state = SPI_STOP;
 8006466:	9b01      	ldr	r3, [sp, #4]
 8006468:	2201      	movs	r2, #1
 800646a:	701a      	strb	r2, [r3, #0]
  spip->config = NULL;
 800646c:	9b01      	ldr	r3, [sp, #4]
 800646e:	2200      	movs	r2, #0
 8006470:	605a      	str	r2, [r3, #4]
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
 8006472:	9b01      	ldr	r3, [sp, #4]
 8006474:	2200      	movs	r2, #0
 8006476:	609a      	str	r2, [r3, #8]
#endif
#if SPI_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&spip->mutex);
 8006478:	9b01      	ldr	r3, [sp, #4]
 800647a:	330c      	adds	r3, #12
 800647c:	4618      	mov	r0, r3
 800647e:	f7ff ffb7 	bl	80063f0 <osalMutexObjectInit>
#endif
#if defined(SPI_DRIVER_EXT_INIT_HOOK)
  SPI_DRIVER_EXT_INIT_HOOK(spip);
#endif
}
 8006482:	b003      	add	sp, #12
 8006484:	f85d fb04 	ldr.w	pc, [sp], #4
 8006488:	f3af 8000 	nop.w
 800648c:	f3af 8000 	nop.w

08006490 <spiStart>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] config    pointer to the @p SPIConfig object
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {
 8006490:	b500      	push	{lr}
 8006492:	b083      	sub	sp, #12
 8006494:	9001      	str	r0, [sp, #4]
 8006496:	9100      	str	r1, [sp, #0]

  osalDbgCheck((spip != NULL) && (config != NULL));

  osalSysLock();
 8006498:	f7ff ff8a 	bl	80063b0 <osalSysLock>
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");
  spip->config = config;
 800649c:	9b01      	ldr	r3, [sp, #4]
 800649e:	9a00      	ldr	r2, [sp, #0]
 80064a0:	605a      	str	r2, [r3, #4]
  spi_lld_start(spip);
 80064a2:	9801      	ldr	r0, [sp, #4]
 80064a4:	f004 fdcc 	bl	800b040 <spi_lld_start>
  spip->state = SPI_READY;
 80064a8:	9b01      	ldr	r3, [sp, #4]
 80064aa:	2202      	movs	r2, #2
 80064ac:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 80064ae:	f7ff ff87 	bl	80063c0 <osalSysUnlock>
}
 80064b2:	b003      	add	sp, #12
 80064b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80064b8:	f3af 8000 	nop.w
 80064bc:	f3af 8000 	nop.w

080064c0 <spiStop>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiStop(SPIDriver *spip) {
 80064c0:	b500      	push	{lr}
 80064c2:	b083      	sub	sp, #12
 80064c4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalSysLock();
 80064c6:	f7ff ff73 	bl	80063b0 <osalSysLock>
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");
  spi_lld_stop(spip);
 80064ca:	9801      	ldr	r0, [sp, #4]
 80064cc:	f004 fe68 	bl	800b1a0 <spi_lld_stop>
  spip->state = SPI_STOP;
 80064d0:	9b01      	ldr	r3, [sp, #4]
 80064d2:	2201      	movs	r2, #1
 80064d4:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 80064d6:	f7ff ff73 	bl	80063c0 <osalSysUnlock>
}
 80064da:	b003      	add	sp, #12
 80064dc:	f85d fb04 	ldr.w	pc, [sp], #4

080064e0 <spiSelect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiSelect(SPIDriver *spip) {
 80064e0:	b500      	push	{lr}
 80064e2:	b083      	sub	sp, #12
 80064e4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalSysLock();
 80064e6:	f7ff ff63 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiSelectI(spip);
 80064ea:	9801      	ldr	r0, [sp, #4]
 80064ec:	f004 fe90 	bl	800b210 <spi_lld_select>
  osalSysUnlock();
 80064f0:	f7ff ff66 	bl	80063c0 <osalSysUnlock>
}
 80064f4:	b003      	add	sp, #12
 80064f6:	f85d fb04 	ldr.w	pc, [sp], #4
 80064fa:	bf00      	nop
 80064fc:	f3af 8000 	nop.w

08006500 <spiUnselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiUnselect(SPIDriver *spip) {
 8006500:	b500      	push	{lr}
 8006502:	b083      	sub	sp, #12
 8006504:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalSysLock();
 8006506:	f7ff ff53 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiUnselectI(spip);
 800650a:	9801      	ldr	r0, [sp, #4]
 800650c:	f004 fe90 	bl	800b230 <spi_lld_unselect>
  osalSysUnlock();
 8006510:	f7ff ff56 	bl	80063c0 <osalSysUnlock>
}
 8006514:	b003      	add	sp, #12
 8006516:	f85d fb04 	ldr.w	pc, [sp], #4
 800651a:	bf00      	nop
 800651c:	f3af 8000 	nop.w

08006520 <spiStartIgnore>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] n         number of words to be ignored
 *
 * @api
 */
void spiStartIgnore(SPIDriver *spip, size_t n) {
 8006520:	b500      	push	{lr}
 8006522:	b083      	sub	sp, #12
 8006524:	9001      	str	r0, [sp, #4]
 8006526:	9100      	str	r1, [sp, #0]

  osalDbgCheck((spip != NULL) && (n > 0U));

  osalSysLock();
 8006528:	f7ff ff42 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiStartIgnoreI(spip, n);
 800652c:	9b01      	ldr	r3, [sp, #4]
 800652e:	2203      	movs	r2, #3
 8006530:	701a      	strb	r2, [r3, #0]
 8006532:	9801      	ldr	r0, [sp, #4]
 8006534:	9900      	ldr	r1, [sp, #0]
 8006536:	f004 fe8b 	bl	800b250 <spi_lld_ignore>
  osalSysUnlock();
 800653a:	f7ff ff41 	bl	80063c0 <osalSysUnlock>
}
 800653e:	b003      	add	sp, #12
 8006540:	f85d fb04 	ldr.w	pc, [sp], #4
 8006544:	f3af 8000 	nop.w
 8006548:	f3af 8000 	nop.w
 800654c:	f3af 8000 	nop.w

08006550 <spiStartExchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiStartExchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {
 8006550:	b500      	push	{lr}
 8006552:	b085      	sub	sp, #20
 8006554:	9003      	str	r0, [sp, #12]
 8006556:	9102      	str	r1, [sp, #8]
 8006558:	9201      	str	r2, [sp, #4]
 800655a:	9300      	str	r3, [sp, #0]

  osalDbgCheck((spip != NULL) && (n > 0U) &&
               (rxbuf != NULL) && (txbuf != NULL));

  osalSysLock();
 800655c:	f7ff ff28 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiStartExchangeI(spip, n, txbuf, rxbuf);
 8006560:	9b03      	ldr	r3, [sp, #12]
 8006562:	2203      	movs	r2, #3
 8006564:	701a      	strb	r2, [r3, #0]
 8006566:	9803      	ldr	r0, [sp, #12]
 8006568:	9902      	ldr	r1, [sp, #8]
 800656a:	9a01      	ldr	r2, [sp, #4]
 800656c:	9b00      	ldr	r3, [sp, #0]
 800656e:	f004 feef 	bl	800b350 <spi_lld_exchange>
  osalSysUnlock();
 8006572:	f7ff ff25 	bl	80063c0 <osalSysUnlock>
}
 8006576:	b005      	add	sp, #20
 8006578:	f85d fb04 	ldr.w	pc, [sp], #4
 800657c:	f3af 8000 	nop.w

08006580 <spiStartSend>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @api
 */
void spiStartSend(SPIDriver *spip, size_t n, const void *txbuf) {
 8006580:	b500      	push	{lr}
 8006582:	b085      	sub	sp, #20
 8006584:	9003      	str	r0, [sp, #12]
 8006586:	9102      	str	r1, [sp, #8]
 8006588:	9201      	str	r2, [sp, #4]

  osalDbgCheck((spip != NULL) && (n > 0U) && (txbuf != NULL));

  osalSysLock();
 800658a:	f7ff ff11 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiStartSendI(spip, n, txbuf);
 800658e:	9b03      	ldr	r3, [sp, #12]
 8006590:	2203      	movs	r2, #3
 8006592:	701a      	strb	r2, [r3, #0]
 8006594:	9803      	ldr	r0, [sp, #12]
 8006596:	9902      	ldr	r1, [sp, #8]
 8006598:	9a01      	ldr	r2, [sp, #4]
 800659a:	f004 ff61 	bl	800b460 <spi_lld_send>
  osalSysUnlock();
 800659e:	f7ff ff0f 	bl	80063c0 <osalSysUnlock>
}
 80065a2:	b005      	add	sp, #20
 80065a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80065a8:	f3af 8000 	nop.w
 80065ac:	f3af 8000 	nop.w

080065b0 <spiStartReceive>:
 * @param[in] n         number of words to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiStartReceive(SPIDriver *spip, size_t n, void *rxbuf) {
 80065b0:	b500      	push	{lr}
 80065b2:	b085      	sub	sp, #20
 80065b4:	9003      	str	r0, [sp, #12]
 80065b6:	9102      	str	r1, [sp, #8]
 80065b8:	9201      	str	r2, [sp, #4]

  osalDbgCheck((spip != NULL) && (n > 0U) && (rxbuf != NULL));

  osalSysLock();
 80065ba:	f7ff fef9 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiStartReceiveI(spip, n, rxbuf);
 80065be:	9b03      	ldr	r3, [sp, #12]
 80065c0:	2203      	movs	r2, #3
 80065c2:	701a      	strb	r2, [r3, #0]
 80065c4:	9803      	ldr	r0, [sp, #12]
 80065c6:	9902      	ldr	r1, [sp, #8]
 80065c8:	9a01      	ldr	r2, [sp, #4]
 80065ca:	f004 ffc9 	bl	800b560 <spi_lld_receive>
  osalSysUnlock();
 80065ce:	f7ff fef7 	bl	80063c0 <osalSysUnlock>
}
 80065d2:	b005      	add	sp, #20
 80065d4:	f85d fb04 	ldr.w	pc, [sp], #4
 80065d8:	f3af 8000 	nop.w
 80065dc:	f3af 8000 	nop.w

080065e0 <spiIgnore>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] n         number of words to be ignored
 *
 * @api
 */
void spiIgnore(SPIDriver *spip, size_t n) {
 80065e0:	b500      	push	{lr}
 80065e2:	b083      	sub	sp, #12
 80065e4:	9001      	str	r0, [sp, #4]
 80065e6:	9100      	str	r1, [sp, #0]

  osalDbgCheck((spip != NULL) && (n > 0U));

  osalSysLock();
 80065e8:	f7ff fee2 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartIgnoreI(spip, n);
 80065ec:	9b01      	ldr	r3, [sp, #4]
 80065ee:	2203      	movs	r2, #3
 80065f0:	701a      	strb	r2, [r3, #0]
 80065f2:	9801      	ldr	r0, [sp, #4]
 80065f4:	9900      	ldr	r1, [sp, #0]
 80065f6:	f004 fe2b 	bl	800b250 <spi_lld_ignore>
  (void) osalThreadSuspendS(&spip->thread);
 80065fa:	9b01      	ldr	r3, [sp, #4]
 80065fc:	3308      	adds	r3, #8
 80065fe:	4618      	mov	r0, r3
 8006600:	f7ff fee6 	bl	80063d0 <osalThreadSuspendS>
  osalSysUnlock();
 8006604:	f7ff fedc 	bl	80063c0 <osalSysUnlock>
}
 8006608:	b003      	add	sp, #12
 800660a:	f85d fb04 	ldr.w	pc, [sp], #4
 800660e:	bf00      	nop

08006610 <spiExchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiExchange(SPIDriver *spip, size_t n,
                 const void *txbuf, void *rxbuf) {
 8006610:	b500      	push	{lr}
 8006612:	b085      	sub	sp, #20
 8006614:	9003      	str	r0, [sp, #12]
 8006616:	9102      	str	r1, [sp, #8]
 8006618:	9201      	str	r2, [sp, #4]
 800661a:	9300      	str	r3, [sp, #0]

  osalDbgCheck((spip != NULL) && (n > 0U) &&
               (rxbuf != NULL) && (txbuf != NULL));

  osalSysLock();
 800661c:	f7ff fec8 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartExchangeI(spip, n, txbuf, rxbuf);
 8006620:	9b03      	ldr	r3, [sp, #12]
 8006622:	2203      	movs	r2, #3
 8006624:	701a      	strb	r2, [r3, #0]
 8006626:	9803      	ldr	r0, [sp, #12]
 8006628:	9902      	ldr	r1, [sp, #8]
 800662a:	9a01      	ldr	r2, [sp, #4]
 800662c:	9b00      	ldr	r3, [sp, #0]
 800662e:	f004 fe8f 	bl	800b350 <spi_lld_exchange>
  (void) osalThreadSuspendS(&spip->thread);
 8006632:	9b03      	ldr	r3, [sp, #12]
 8006634:	3308      	adds	r3, #8
 8006636:	4618      	mov	r0, r3
 8006638:	f7ff feca 	bl	80063d0 <osalThreadSuspendS>
  osalSysUnlock();
 800663c:	f7ff fec0 	bl	80063c0 <osalSysUnlock>
}
 8006640:	b005      	add	sp, #20
 8006642:	f85d fb04 	ldr.w	pc, [sp], #4
 8006646:	bf00      	nop
 8006648:	f3af 8000 	nop.w
 800664c:	f3af 8000 	nop.w

08006650 <spiSend>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @api
 */
void spiSend(SPIDriver *spip, size_t n, const void *txbuf) {
 8006650:	b500      	push	{lr}
 8006652:	b085      	sub	sp, #20
 8006654:	9003      	str	r0, [sp, #12]
 8006656:	9102      	str	r1, [sp, #8]
 8006658:	9201      	str	r2, [sp, #4]

  osalDbgCheck((spip != NULL) && (n > 0U) && (txbuf != NULL));

  osalSysLock();
 800665a:	f7ff fea9 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartSendI(spip, n, txbuf);
 800665e:	9b03      	ldr	r3, [sp, #12]
 8006660:	2203      	movs	r2, #3
 8006662:	701a      	strb	r2, [r3, #0]
 8006664:	9803      	ldr	r0, [sp, #12]
 8006666:	9902      	ldr	r1, [sp, #8]
 8006668:	9a01      	ldr	r2, [sp, #4]
 800666a:	f004 fef9 	bl	800b460 <spi_lld_send>
  (void) osalThreadSuspendS(&spip->thread);
 800666e:	9b03      	ldr	r3, [sp, #12]
 8006670:	3308      	adds	r3, #8
 8006672:	4618      	mov	r0, r3
 8006674:	f7ff feac 	bl	80063d0 <osalThreadSuspendS>
  osalSysUnlock();
 8006678:	f7ff fea2 	bl	80063c0 <osalSysUnlock>
}
 800667c:	b005      	add	sp, #20
 800667e:	f85d fb04 	ldr.w	pc, [sp], #4
 8006682:	bf00      	nop
 8006684:	f3af 8000 	nop.w
 8006688:	f3af 8000 	nop.w
 800668c:	f3af 8000 	nop.w

08006690 <spiReceive>:
 * @param[in] n         number of words to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiReceive(SPIDriver *spip, size_t n, void *rxbuf) {
 8006690:	b500      	push	{lr}
 8006692:	b085      	sub	sp, #20
 8006694:	9003      	str	r0, [sp, #12]
 8006696:	9102      	str	r1, [sp, #8]
 8006698:	9201      	str	r2, [sp, #4]

  osalDbgCheck((spip != NULL) && (n > 0U) && (rxbuf != NULL));

  osalSysLock();
 800669a:	f7ff fe89 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartReceiveI(spip, n, rxbuf);
 800669e:	9b03      	ldr	r3, [sp, #12]
 80066a0:	2203      	movs	r2, #3
 80066a2:	701a      	strb	r2, [r3, #0]
 80066a4:	9803      	ldr	r0, [sp, #12]
 80066a6:	9902      	ldr	r1, [sp, #8]
 80066a8:	9a01      	ldr	r2, [sp, #4]
 80066aa:	f004 ff59 	bl	800b560 <spi_lld_receive>
  (void) osalThreadSuspendS(&spip->thread);
 80066ae:	9b03      	ldr	r3, [sp, #12]
 80066b0:	3308      	adds	r3, #8
 80066b2:	4618      	mov	r0, r3
 80066b4:	f7ff fe8c 	bl	80063d0 <osalThreadSuspendS>
  osalSysUnlock();
 80066b8:	f7ff fe82 	bl	80063c0 <osalSysUnlock>
}
 80066bc:	b005      	add	sp, #20
 80066be:	f85d fb04 	ldr.w	pc, [sp], #4
 80066c2:	bf00      	nop
 80066c4:	f3af 8000 	nop.w
 80066c8:	f3af 8000 	nop.w
 80066cc:	f3af 8000 	nop.w

080066d0 <spiAcquireBus>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiAcquireBus(SPIDriver *spip) {
 80066d0:	b500      	push	{lr}
 80066d2:	b083      	sub	sp, #12
 80066d4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalMutexLock(&spip->mutex);
 80066d6:	9b01      	ldr	r3, [sp, #4]
 80066d8:	330c      	adds	r3, #12
 80066da:	4618      	mov	r0, r3
 80066dc:	f7ff fe98 	bl	8006410 <osalMutexLock>
}
 80066e0:	b003      	add	sp, #12
 80066e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80066e6:	bf00      	nop
 80066e8:	f3af 8000 	nop.w
 80066ec:	f3af 8000 	nop.w

080066f0 <spiReleaseBus>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiReleaseBus(SPIDriver *spip) {
 80066f0:	b500      	push	{lr}
 80066f2:	b083      	sub	sp, #12
 80066f4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalMutexUnlock(&spip->mutex);
 80066f6:	9b01      	ldr	r3, [sp, #4]
 80066f8:	330c      	adds	r3, #12
 80066fa:	4618      	mov	r0, r3
 80066fc:	f7ff fe98 	bl	8006430 <osalMutexUnlock>
}
 8006700:	b003      	add	sp, #12
 8006702:	f85d fb04 	ldr.w	pc, [sp], #4
 8006706:	bf00      	nop
 8006708:	f3af 8000 	nop.w
 800670c:	f3af 8000 	nop.w

08006710 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8006710:	b082      	sub	sp, #8
 8006712:	2320      	movs	r3, #32
 8006714:	9301      	str	r3, [sp, #4]
 8006716:	9b01      	ldr	r3, [sp, #4]
 8006718:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800671c:	b002      	add	sp, #8
 800671e:	4770      	bx	lr

08006720 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8006720:	b082      	sub	sp, #8
 8006722:	2300      	movs	r3, #0
 8006724:	9301      	str	r3, [sp, #4]
 8006726:	9b01      	ldr	r3, [sp, #4]
 8006728:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800672c:	b002      	add	sp, #8
 800672e:	4770      	bx	lr

08006730 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8006730:	b508      	push	{r3, lr}

  port_lock();
 8006732:	f7ff ffed 	bl	8006710 <port_lock>
}
 8006736:	bd08      	pop	{r3, pc}
 8006738:	f3af 8000 	nop.w
 800673c:	f3af 8000 	nop.w

08006740 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8006740:	b508      	push	{r3, lr}

  port_unlock();
 8006742:	f7ff ffed 	bl	8006720 <port_unlock>
}
 8006746:	bd08      	pop	{r3, pc}
 8006748:	f3af 8000 	nop.w
 800674c:	f3af 8000 	nop.w

08006750 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8006750:	b508      	push	{r3, lr}

  port_lock();
 8006752:	f7ff ffdd 	bl	8006710 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8006756:	bd08      	pop	{r3, pc}
 8006758:	f3af 8000 	nop.w
 800675c:	f3af 8000 	nop.w

08006760 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8006760:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8006762:	f7ff ffdd 	bl	8006720 <port_unlock>
}
 8006766:	bd08      	pop	{r3, pc}
 8006768:	f3af 8000 	nop.w
 800676c:	f3af 8000 	nop.w

08006770 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8006770:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8006772:	f7ff ffdd 	bl	8006730 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8006776:	bd08      	pop	{r3, pc}
 8006778:	f3af 8000 	nop.w
 800677c:	f3af 8000 	nop.w

08006780 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8006780:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8006782:	f7ff ffdd 	bl	8006740 <port_unlock_from_isr>
}
 8006786:	bd08      	pop	{r3, pc}
 8006788:	f3af 8000 	nop.w
 800678c:	f3af 8000 	nop.w

08006790 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8006790:	b508      	push	{r3, lr}

  chSysLock();
 8006792:	f7ff ffdd 	bl	8006750 <chSysLock>
}
 8006796:	bd08      	pop	{r3, pc}
 8006798:	f3af 8000 	nop.w
 800679c:	f3af 8000 	nop.w

080067a0 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 80067a0:	b508      	push	{r3, lr}

  chSysUnlock();
 80067a2:	f7ff ffdd 	bl	8006760 <chSysUnlock>
}
 80067a6:	bd08      	pop	{r3, pc}
 80067a8:	f3af 8000 	nop.w
 80067ac:	f3af 8000 	nop.w

080067b0 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 80067b0:	b508      	push	{r3, lr}

  chSysLockFromISR();
 80067b2:	f7ff ffdd 	bl	8006770 <chSysLockFromISR>
}
 80067b6:	bd08      	pop	{r3, pc}
 80067b8:	f3af 8000 	nop.w
 80067bc:	f3af 8000 	nop.w

080067c0 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 80067c0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 80067c2:	f7ff ffdd 	bl	8006780 <chSysUnlockFromISR>
}
 80067c6:	bd08      	pop	{r3, pc}
 80067c8:	f3af 8000 	nop.w
 80067cc:	f3af 8000 	nop.w

080067d0 <osalOsRescheduleS>:
 *          required in this scenario.
 * @note    Not implemented in this simplified OSAL.
 *
 * @sclass
 */
static inline void osalOsRescheduleS(void) {
 80067d0:	b508      	push	{r3, lr}

  chSchRescheduleS();
 80067d2:	f7fa fad5 	bl	8000d80 <chSchRescheduleS>
}
 80067d6:	bd08      	pop	{r3, pc}
 80067d8:	f3af 8000 	nop.w
 80067dc:	f3af 8000 	nop.w

080067e0 <get_hword>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static uint16_t get_hword(uint8_t *p) {
 80067e0:	b084      	sub	sp, #16
 80067e2:	9001      	str	r0, [sp, #4]
  uint16_t hw;

  hw  = (uint16_t)*p++;
 80067e4:	9b01      	ldr	r3, [sp, #4]
 80067e6:	1c5a      	adds	r2, r3, #1
 80067e8:	9201      	str	r2, [sp, #4]
 80067ea:	781b      	ldrb	r3, [r3, #0]
 80067ec:	f8ad 300e 	strh.w	r3, [sp, #14]
  hw |= (uint16_t)*p << 8U;
 80067f0:	9b01      	ldr	r3, [sp, #4]
 80067f2:	781b      	ldrb	r3, [r3, #0]
 80067f4:	021b      	lsls	r3, r3, #8
 80067f6:	b29a      	uxth	r2, r3
 80067f8:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 80067fc:	4313      	orrs	r3, r2
 80067fe:	b29b      	uxth	r3, r3
 8006800:	f8ad 300e 	strh.w	r3, [sp, #14]
  return hw;
 8006804:	f8bd 300e 	ldrh.w	r3, [sp, #14]
}
 8006808:	4618      	mov	r0, r3
 800680a:	b004      	add	sp, #16
 800680c:	4770      	bx	lr
 800680e:	bf00      	nop

08006810 <set_address>:
/**
 * @brief  SET ADDRESS transaction callback.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {
 8006810:	b500      	push	{lr}
 8006812:	b083      	sub	sp, #12
 8006814:	9001      	str	r0, [sp, #4]

  usbp->address = usbp->setup[2];
 8006816:	9b01      	ldr	r3, [sp, #4]
 8006818:	f893 205e 	ldrb.w	r2, [r3, #94]	; 0x5e
 800681c:	9b01      	ldr	r3, [sp, #4]
 800681e:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66
  usb_lld_set_address(usbp);
 8006822:	9801      	ldr	r0, [sp, #4]
 8006824:	f002 fcb4 	bl	8009190 <usb_lld_set_address>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8006828:	9b01      	ldr	r3, [sp, #4]
 800682a:	685b      	ldr	r3, [r3, #4]
 800682c:	681b      	ldr	r3, [r3, #0]
 800682e:	2b00      	cmp	r3, #0
 8006830:	d005      	beq.n	800683e <set_address+0x2e>
 8006832:	9b01      	ldr	r3, [sp, #4]
 8006834:	685b      	ldr	r3, [r3, #4]
 8006836:	681b      	ldr	r3, [r3, #0]
 8006838:	9801      	ldr	r0, [sp, #4]
 800683a:	2101      	movs	r1, #1
 800683c:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 800683e:	9b01      	ldr	r3, [sp, #4]
 8006840:	2203      	movs	r2, #3
 8006842:	701a      	strb	r2, [r3, #0]
}
 8006844:	b003      	add	sp, #12
 8006846:	f85d fb04 	ldr.w	pc, [sp], #4
 800684a:	bf00      	nop
 800684c:	f3af 8000 	nop.w

08006850 <default_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @return              The request handling exit code.
 * @retval false        Request not recognized by the handler or error.
 * @retval true         Request handled.
 */
static bool default_handler(USBDriver *usbp) {
 8006850:	b570      	push	{r4, r5, r6, lr}
 8006852:	b084      	sub	sp, #16
 8006854:	9001      	str	r0, [sp, #4]
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8006856:	9b01      	ldr	r3, [sp, #4]
 8006858:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800685c:	f003 027f 	and.w	r2, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
 8006860:	9b01      	ldr	r3, [sp, #4]
 8006862:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 8006866:	021b      	lsls	r3, r3, #8
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
                                        USB_RTYPE_TYPE_MASK)) |
 8006868:	4313      	orrs	r3, r2
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800686a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800686e:	d05a      	beq.n	8006926 <default_handler+0xd6>
 8006870:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8006874:	d812      	bhi.n	800689c <default_handler+0x4c>
 8006876:	2b02      	cmp	r3, #2
 8006878:	f000 810f 	beq.w	8006a9a <default_handler+0x24a>
 800687c:	2b02      	cmp	r3, #2
 800687e:	d805      	bhi.n	800688c <default_handler+0x3c>
 8006880:	2b00      	cmp	r3, #0
 8006882:	d028      	beq.n	80068d6 <default_handler+0x86>
 8006884:	2b01      	cmp	r3, #1
 8006886:	f000 80fd 	beq.w	8006a84 <default_handler+0x234>
 800688a:	e1c7      	b.n	8006c1c <default_handler+0x3cc>
 800688c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8006890:	d02e      	beq.n	80068f0 <default_handler+0xa0>
 8006892:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
 8006896:	f000 8157 	beq.w	8006b48 <default_handler+0x2f8>
 800689a:	e1bf      	b.n	8006c1c <default_handler+0x3cc>
 800689c:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 80068a0:	d074      	beq.n	800698c <default_handler+0x13c>
 80068a2:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 80068a6:	d808      	bhi.n	80068ba <default_handler+0x6a>
 80068a8:	f240 3202 	movw	r2, #770	; 0x302
 80068ac:	4293      	cmp	r3, r2
 80068ae:	f000 8180 	beq.w	8006bb2 <default_handler+0x362>
 80068b2:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 80068b6:	d051      	beq.n	800695c <default_handler+0x10c>
 80068b8:	e1b0      	b.n	8006c1c <default_handler+0x3cc>
 80068ba:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
 80068be:	f000 8098 	beq.w	80069f2 <default_handler+0x1a2>
 80068c2:	f640 4202 	movw	r2, #3074	; 0xc02
 80068c6:	4293      	cmp	r3, r2
 80068c8:	f000 80dc 	beq.w	8006a84 <default_handler+0x234>
 80068cc:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80068d0:	f000 8082 	beq.w	80069d8 <default_handler+0x188>
 80068d4:	e1a2      	b.n	8006c1c <default_handler+0x3cc>
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Just returns the current status word.*/
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 80068d6:	9b01      	ldr	r3, [sp, #4]
 80068d8:	f103 0264 	add.w	r2, r3, #100	; 0x64
 80068dc:	9b01      	ldr	r3, [sp, #4]
 80068de:	651a      	str	r2, [r3, #80]	; 0x50
 80068e0:	9b01      	ldr	r3, [sp, #4]
 80068e2:	2202      	movs	r2, #2
 80068e4:	655a      	str	r2, [r3, #84]	; 0x54
 80068e6:	9b01      	ldr	r3, [sp, #4]
 80068e8:	2200      	movs	r2, #0
 80068ea:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 80068ec:	2301      	movs	r3, #1
 80068ee:	e196      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 80068f0:	9b01      	ldr	r3, [sp, #4]
 80068f2:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 80068f6:	2b01      	cmp	r3, #1
 80068f8:	d113      	bne.n	8006922 <default_handler+0xd2>
      usbp->status &= ~2U;
 80068fa:	9b01      	ldr	r3, [sp, #4]
 80068fc:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
 8006900:	f023 0302 	bic.w	r3, r3, #2
 8006904:	b29a      	uxth	r2, r3
 8006906:	9b01      	ldr	r3, [sp, #4]
 8006908:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800690c:	9b01      	ldr	r3, [sp, #4]
 800690e:	2200      	movs	r2, #0
 8006910:	651a      	str	r2, [r3, #80]	; 0x50
 8006912:	9b01      	ldr	r3, [sp, #4]
 8006914:	2200      	movs	r2, #0
 8006916:	655a      	str	r2, [r3, #84]	; 0x54
 8006918:	9b01      	ldr	r3, [sp, #4]
 800691a:	2200      	movs	r2, #0
 800691c:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 800691e:	2301      	movs	r3, #1
 8006920:	e17d      	b.n	8006c1e <default_handler+0x3ce>
    }
    return false;
 8006922:	2300      	movs	r3, #0
 8006924:	e17b      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8006926:	9b01      	ldr	r3, [sp, #4]
 8006928:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 800692c:	2b01      	cmp	r3, #1
 800692e:	d113      	bne.n	8006958 <default_handler+0x108>
      usbp->status |= 2U;
 8006930:	9b01      	ldr	r3, [sp, #4]
 8006932:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
 8006936:	f043 0302 	orr.w	r3, r3, #2
 800693a:	b29a      	uxth	r2, r3
 800693c:	9b01      	ldr	r3, [sp, #4]
 800693e:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8006942:	9b01      	ldr	r3, [sp, #4]
 8006944:	2200      	movs	r2, #0
 8006946:	651a      	str	r2, [r3, #80]	; 0x50
 8006948:	9b01      	ldr	r3, [sp, #4]
 800694a:	2200      	movs	r2, #0
 800694c:	655a      	str	r2, [r3, #84]	; 0x54
 800694e:	9b01      	ldr	r3, [sp, #4]
 8006950:	2200      	movs	r2, #0
 8006952:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 8006954:	2301      	movs	r3, #1
 8006956:	e162      	b.n	8006c1e <default_handler+0x3ce>
    }
    return false;
 8006958:	2300      	movs	r3, #0
 800695a:	e160      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 800695c:	9b01      	ldr	r3, [sp, #4]
 800695e:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 8006962:	2b00      	cmp	r3, #0
 8006964:	d107      	bne.n	8006976 <default_handler+0x126>
        (usbp->setup[1] == USB_REQ_SET_ADDRESS)) {
 8006966:	9b01      	ldr	r3, [sp, #4]
 8006968:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 800696c:	2b05      	cmp	r3, #5
 800696e:	d102      	bne.n	8006976 <default_handler+0x126>
        (usbp->setup[1] == USB_REQ_SET_ADDRESS)) {
      set_address(usbp);
 8006970:	9801      	ldr	r0, [sp, #4]
 8006972:	f7ff ff4d 	bl	8006810 <set_address>
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8006976:	9b01      	ldr	r3, [sp, #4]
 8006978:	2200      	movs	r2, #0
 800697a:	651a      	str	r2, [r3, #80]	; 0x50
 800697c:	9b01      	ldr	r3, [sp, #4]
 800697e:	2200      	movs	r2, #0
 8006980:	655a      	str	r2, [r3, #84]	; 0x54
 8006982:	9b01      	ldr	r3, [sp, #4]
 8006984:	2200      	movs	r2, #0
 8006986:	659a      	str	r2, [r3, #88]	; 0x58
#else
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
 8006988:	2301      	movs	r3, #1
 800698a:	e148      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 800698c:	9b01      	ldr	r3, [sp, #4]
 800698e:	685b      	ldr	r3, [r3, #4]
 8006990:	685c      	ldr	r4, [r3, #4]
 8006992:	9b01      	ldr	r3, [sp, #4]
 8006994:	f893 605f 	ldrb.w	r6, [r3, #95]	; 0x5f
 8006998:	9b01      	ldr	r3, [sp, #4]
 800699a:	f893 505e 	ldrb.w	r5, [r3, #94]	; 0x5e
 800699e:	9b01      	ldr	r3, [sp, #4]
 80069a0:	3360      	adds	r3, #96	; 0x60
 80069a2:	4618      	mov	r0, r3
 80069a4:	f7ff ff1c 	bl	80067e0 <get_hword>
 80069a8:	4603      	mov	r3, r0
 80069aa:	9801      	ldr	r0, [sp, #4]
 80069ac:	4631      	mov	r1, r6
 80069ae:	462a      	mov	r2, r5
 80069b0:	47a0      	blx	r4
 80069b2:	9003      	str	r0, [sp, #12]
                                         usbp->setup[2],
                                         get_hword(&usbp->setup[4]));
    if (dp == NULL) {
 80069b4:	9b03      	ldr	r3, [sp, #12]
 80069b6:	2b00      	cmp	r3, #0
 80069b8:	d101      	bne.n	80069be <default_handler+0x16e>
      return false;
 80069ba:	2300      	movs	r3, #0
 80069bc:	e12f      	b.n	8006c1e <default_handler+0x3ce>
    }
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 80069be:	9b03      	ldr	r3, [sp, #12]
 80069c0:	685a      	ldr	r2, [r3, #4]
 80069c2:	9b01      	ldr	r3, [sp, #4]
 80069c4:	651a      	str	r2, [r3, #80]	; 0x50
 80069c6:	9b03      	ldr	r3, [sp, #12]
 80069c8:	681a      	ldr	r2, [r3, #0]
 80069ca:	9b01      	ldr	r3, [sp, #4]
 80069cc:	655a      	str	r2, [r3, #84]	; 0x54
 80069ce:	9b01      	ldr	r3, [sp, #4]
 80069d0:	2200      	movs	r2, #0
 80069d2:	659a      	str	r2, [r3, #88]	; 0x58
    /*lint -restore*/
    return true;
 80069d4:	2301      	movs	r3, #1
 80069d6:	e122      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_CONFIGURATION << 8):
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 80069d8:	9b01      	ldr	r3, [sp, #4]
 80069da:	f103 0267 	add.w	r2, r3, #103	; 0x67
 80069de:	9b01      	ldr	r3, [sp, #4]
 80069e0:	651a      	str	r2, [r3, #80]	; 0x50
 80069e2:	9b01      	ldr	r3, [sp, #4]
 80069e4:	2201      	movs	r2, #1
 80069e6:	655a      	str	r2, [r3, #84]	; 0x54
 80069e8:	9b01      	ldr	r3, [sp, #4]
 80069ea:	2200      	movs	r2, #0
 80069ec:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 80069ee:	2301      	movs	r3, #1
 80069f0:	e115      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_CONFIGURATION << 8):
    /* Handling configuration selection from the host only if it is different
       from the current configuration.*/
    if (usbp->configuration != usbp->setup[2]) {
 80069f2:	9b01      	ldr	r3, [sp, #4]
 80069f4:	f893 2067 	ldrb.w	r2, [r3, #103]	; 0x67
 80069f8:	9b01      	ldr	r3, [sp, #4]
 80069fa:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 80069fe:	429a      	cmp	r2, r3
 8006a00:	d035      	beq.n	8006a6e <default_handler+0x21e>
      /* If the USB device is already active then we have to perform the clear
         procedure on the current configuration.*/
      if (usbp->state == USB_ACTIVE) {
 8006a02:	9b01      	ldr	r3, [sp, #4]
 8006a04:	781b      	ldrb	r3, [r3, #0]
 8006a06:	2b04      	cmp	r3, #4
 8006a08:	d118      	bne.n	8006a3c <default_handler+0x1ec>
        /* Current configuration cleared.*/
        osalSysLockFromISR ();
 8006a0a:	f7ff fed1 	bl	80067b0 <osalSysLockFromISR>
        usbDisableEndpointsI(usbp);
 8006a0e:	9801      	ldr	r0, [sp, #4]
 8006a10:	f000 f9be 	bl	8006d90 <usbDisableEndpointsI>
        osalSysUnlockFromISR ();
 8006a14:	f7ff fed4 	bl	80067c0 <osalSysUnlockFromISR>
        usbp->configuration = 0U;
 8006a18:	9b01      	ldr	r3, [sp, #4]
 8006a1a:	2200      	movs	r2, #0
 8006a1c:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
        usbp->state = USB_SELECTED;
 8006a20:	9b01      	ldr	r3, [sp, #4]
 8006a22:	2203      	movs	r2, #3
 8006a24:	701a      	strb	r2, [r3, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8006a26:	9b01      	ldr	r3, [sp, #4]
 8006a28:	685b      	ldr	r3, [r3, #4]
 8006a2a:	681b      	ldr	r3, [r3, #0]
 8006a2c:	2b00      	cmp	r3, #0
 8006a2e:	d005      	beq.n	8006a3c <default_handler+0x1ec>
 8006a30:	9b01      	ldr	r3, [sp, #4]
 8006a32:	685b      	ldr	r3, [r3, #4]
 8006a34:	681b      	ldr	r3, [r3, #0]
 8006a36:	9801      	ldr	r0, [sp, #4]
 8006a38:	2103      	movs	r1, #3
 8006a3a:	4798      	blx	r3
      }
      if (usbp->setup[2] != 0U) {
 8006a3c:	9b01      	ldr	r3, [sp, #4]
 8006a3e:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 8006a42:	2b00      	cmp	r3, #0
 8006a44:	d013      	beq.n	8006a6e <default_handler+0x21e>
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
 8006a46:	9b01      	ldr	r3, [sp, #4]
 8006a48:	f893 205e 	ldrb.w	r2, [r3, #94]	; 0x5e
 8006a4c:	9b01      	ldr	r3, [sp, #4]
 8006a4e:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
        usbp->state = USB_ACTIVE;
 8006a52:	9b01      	ldr	r3, [sp, #4]
 8006a54:	2204      	movs	r2, #4
 8006a56:	701a      	strb	r2, [r3, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8006a58:	9b01      	ldr	r3, [sp, #4]
 8006a5a:	685b      	ldr	r3, [r3, #4]
 8006a5c:	681b      	ldr	r3, [r3, #0]
 8006a5e:	2b00      	cmp	r3, #0
 8006a60:	d005      	beq.n	8006a6e <default_handler+0x21e>
 8006a62:	9b01      	ldr	r3, [sp, #4]
 8006a64:	685b      	ldr	r3, [r3, #4]
 8006a66:	681b      	ldr	r3, [r3, #0]
 8006a68:	9801      	ldr	r0, [sp, #4]
 8006a6a:	2102      	movs	r1, #2
 8006a6c:	4798      	blx	r3
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8006a6e:	9b01      	ldr	r3, [sp, #4]
 8006a70:	2200      	movs	r2, #0
 8006a72:	651a      	str	r2, [r3, #80]	; 0x50
 8006a74:	9b01      	ldr	r3, [sp, #4]
 8006a76:	2200      	movs	r2, #0
 8006a78:	655a      	str	r2, [r3, #84]	; 0x54
 8006a7a:	9b01      	ldr	r3, [sp, #4]
 8006a7c:	2200      	movs	r2, #0
 8006a7e:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 8006a80:	2301      	movs	r3, #1
 8006a82:	e0cc      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_STATUS << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SYNCH_FRAME << 8):
    /* Just sending two zero bytes, the application can change the behavior
       using a hook..*/
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 8006a84:	9b01      	ldr	r3, [sp, #4]
 8006a86:	4a67      	ldr	r2, [pc, #412]	; (8006c24 <default_handler+0x3d4>)
 8006a88:	651a      	str	r2, [r3, #80]	; 0x50
 8006a8a:	9b01      	ldr	r3, [sp, #4]
 8006a8c:	2202      	movs	r2, #2
 8006a8e:	655a      	str	r2, [r3, #84]	; 0x54
 8006a90:	9b01      	ldr	r3, [sp, #4]
 8006a92:	2200      	movs	r2, #0
 8006a94:	659a      	str	r2, [r3, #88]	; 0x58
    /*lint -restore*/
    return true;
 8006a96:	2301      	movs	r3, #1
 8006a98:	e0c1      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 8006a9a:	9b01      	ldr	r3, [sp, #4]
 8006a9c:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006aa0:	b2db      	uxtb	r3, r3
 8006aa2:	b25b      	sxtb	r3, r3
 8006aa4:	2b00      	cmp	r3, #0
 8006aa6:	da27      	bge.n	8006af8 <default_handler+0x2a8>
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 8006aa8:	9b01      	ldr	r3, [sp, #4]
 8006aaa:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006aae:	f003 030f 	and.w	r3, r3, #15
 8006ab2:	b2db      	uxtb	r3, r3
 8006ab4:	9801      	ldr	r0, [sp, #4]
 8006ab6:	4619      	mov	r1, r3
 8006ab8:	f002 fce2 	bl	8009480 <usb_lld_get_status_in>
 8006abc:	4603      	mov	r3, r0
 8006abe:	2b01      	cmp	r3, #1
 8006ac0:	d002      	beq.n	8006ac8 <default_handler+0x278>
 8006ac2:	2b02      	cmp	r3, #2
 8006ac4:	d00b      	beq.n	8006ade <default_handler+0x28e>
 8006ac6:	e015      	b.n	8006af4 <default_handler+0x2a4>
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8006ac8:	9b01      	ldr	r3, [sp, #4]
 8006aca:	4a57      	ldr	r2, [pc, #348]	; (8006c28 <default_handler+0x3d8>)
 8006acc:	651a      	str	r2, [r3, #80]	; 0x50
 8006ace:	9b01      	ldr	r3, [sp, #4]
 8006ad0:	2202      	movs	r2, #2
 8006ad2:	655a      	str	r2, [r3, #84]	; 0x54
 8006ad4:	9b01      	ldr	r3, [sp, #4]
 8006ad6:	2200      	movs	r2, #0
 8006ad8:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 8006ada:	2301      	movs	r3, #1
 8006adc:	e09f      	b.n	8006c1e <default_handler+0x3ce>
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8006ade:	9b01      	ldr	r3, [sp, #4]
 8006ae0:	4a52      	ldr	r2, [pc, #328]	; (8006c2c <default_handler+0x3dc>)
 8006ae2:	651a      	str	r2, [r3, #80]	; 0x50
 8006ae4:	9b01      	ldr	r3, [sp, #4]
 8006ae6:	2202      	movs	r2, #2
 8006ae8:	655a      	str	r2, [r3, #84]	; 0x54
 8006aea:	9b01      	ldr	r3, [sp, #4]
 8006aec:	2200      	movs	r2, #0
 8006aee:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 8006af0:	2301      	movs	r3, #1
 8006af2:	e094      	b.n	8006c1e <default_handler+0x3ce>
      case EP_STATUS_DISABLED:
      default:
        return false;
 8006af4:	2300      	movs	r3, #0
 8006af6:	e092      	b.n	8006c1e <default_handler+0x3ce>
      }
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
 8006af8:	9b01      	ldr	r3, [sp, #4]
 8006afa:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006afe:	f003 030f 	and.w	r3, r3, #15
 8006b02:	b2db      	uxtb	r3, r3
 8006b04:	9801      	ldr	r0, [sp, #4]
 8006b06:	4619      	mov	r1, r3
 8006b08:	f002 fc9a 	bl	8009440 <usb_lld_get_status_out>
 8006b0c:	4603      	mov	r3, r0
 8006b0e:	2b01      	cmp	r3, #1
 8006b10:	d002      	beq.n	8006b18 <default_handler+0x2c8>
 8006b12:	2b02      	cmp	r3, #2
 8006b14:	d00b      	beq.n	8006b2e <default_handler+0x2de>
 8006b16:	e015      	b.n	8006b44 <default_handler+0x2f4>
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8006b18:	9b01      	ldr	r3, [sp, #4]
 8006b1a:	4a43      	ldr	r2, [pc, #268]	; (8006c28 <default_handler+0x3d8>)
 8006b1c:	651a      	str	r2, [r3, #80]	; 0x50
 8006b1e:	9b01      	ldr	r3, [sp, #4]
 8006b20:	2202      	movs	r2, #2
 8006b22:	655a      	str	r2, [r3, #84]	; 0x54
 8006b24:	9b01      	ldr	r3, [sp, #4]
 8006b26:	2200      	movs	r2, #0
 8006b28:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 8006b2a:	2301      	movs	r3, #1
 8006b2c:	e077      	b.n	8006c1e <default_handler+0x3ce>
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8006b2e:	9b01      	ldr	r3, [sp, #4]
 8006b30:	4a3e      	ldr	r2, [pc, #248]	; (8006c2c <default_handler+0x3dc>)
 8006b32:	651a      	str	r2, [r3, #80]	; 0x50
 8006b34:	9b01      	ldr	r3, [sp, #4]
 8006b36:	2202      	movs	r2, #2
 8006b38:	655a      	str	r2, [r3, #84]	; 0x54
 8006b3a:	9b01      	ldr	r3, [sp, #4]
 8006b3c:	2200      	movs	r2, #0
 8006b3e:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 8006b40:	2301      	movs	r3, #1
 8006b42:	e06c      	b.n	8006c1e <default_handler+0x3ce>
      case EP_STATUS_DISABLED:
      default:
        return false;
 8006b44:	2300      	movs	r3, #0
 8006b46:	e06a      	b.n	8006c1e <default_handler+0x3ce>
      }
    }
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8006b48:	9b01      	ldr	r3, [sp, #4]
 8006b4a:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 8006b4e:	2b00      	cmp	r3, #0
 8006b50:	d001      	beq.n	8006b56 <default_handler+0x306>
      return false;
 8006b52:	2300      	movs	r3, #0
 8006b54:	e063      	b.n	8006c1e <default_handler+0x3ce>
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8006b56:	9b01      	ldr	r3, [sp, #4]
 8006b58:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006b5c:	f003 030f 	and.w	r3, r3, #15
 8006b60:	2b00      	cmp	r3, #0
 8006b62:	d01b      	beq.n	8006b9c <default_handler+0x34c>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8006b64:	9b01      	ldr	r3, [sp, #4]
 8006b66:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006b6a:	b2db      	uxtb	r3, r3
 8006b6c:	b25b      	sxtb	r3, r3
 8006b6e:	2b00      	cmp	r3, #0
 8006b70:	da0a      	bge.n	8006b88 <default_handler+0x338>
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 8006b72:	9b01      	ldr	r3, [sp, #4]
 8006b74:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006b78:	f003 030f 	and.w	r3, r3, #15
 8006b7c:	b2db      	uxtb	r3, r3
 8006b7e:	9801      	ldr	r0, [sp, #4]
 8006b80:	4619      	mov	r1, r3
 8006b82:	f002 fe65 	bl	8009850 <usb_lld_clear_in>
 8006b86:	e009      	b.n	8006b9c <default_handler+0x34c>
      }
      else {
        usb_lld_clear_out(usbp, usbp->setup[4] & 0x0FU);
 8006b88:	9b01      	ldr	r3, [sp, #4]
 8006b8a:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006b8e:	f003 030f 	and.w	r3, r3, #15
 8006b92:	b2db      	uxtb	r3, r3
 8006b94:	9801      	ldr	r0, [sp, #4]
 8006b96:	4619      	mov	r1, r3
 8006b98:	f002 fe3a 	bl	8009810 <usb_lld_clear_out>
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8006b9c:	9b01      	ldr	r3, [sp, #4]
 8006b9e:	2200      	movs	r2, #0
 8006ba0:	651a      	str	r2, [r3, #80]	; 0x50
 8006ba2:	9b01      	ldr	r3, [sp, #4]
 8006ba4:	2200      	movs	r2, #0
 8006ba6:	655a      	str	r2, [r3, #84]	; 0x54
 8006ba8:	9b01      	ldr	r3, [sp, #4]
 8006baa:	2200      	movs	r2, #0
 8006bac:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 8006bae:	2301      	movs	r3, #1
 8006bb0:	e035      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8006bb2:	9b01      	ldr	r3, [sp, #4]
 8006bb4:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 8006bb8:	2b00      	cmp	r3, #0
 8006bba:	d001      	beq.n	8006bc0 <default_handler+0x370>
      return false;
 8006bbc:	2300      	movs	r3, #0
 8006bbe:	e02e      	b.n	8006c1e <default_handler+0x3ce>
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8006bc0:	9b01      	ldr	r3, [sp, #4]
 8006bc2:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006bc6:	f003 030f 	and.w	r3, r3, #15
 8006bca:	2b00      	cmp	r3, #0
 8006bcc:	d01b      	beq.n	8006c06 <default_handler+0x3b6>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8006bce:	9b01      	ldr	r3, [sp, #4]
 8006bd0:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006bd4:	b2db      	uxtb	r3, r3
 8006bd6:	b25b      	sxtb	r3, r3
 8006bd8:	2b00      	cmp	r3, #0
 8006bda:	da0a      	bge.n	8006bf2 <default_handler+0x3a2>
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 8006bdc:	9b01      	ldr	r3, [sp, #4]
 8006bde:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006be2:	f003 030f 	and.w	r3, r3, #15
 8006be6:	b2db      	uxtb	r3, r3
 8006be8:	9801      	ldr	r0, [sp, #4]
 8006bea:	4619      	mov	r1, r3
 8006bec:	f002 fdf0 	bl	80097d0 <usb_lld_stall_in>
 8006bf0:	e009      	b.n	8006c06 <default_handler+0x3b6>
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
 8006bf2:	9b01      	ldr	r3, [sp, #4]
 8006bf4:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006bf8:	f003 030f 	and.w	r3, r3, #15
 8006bfc:	b2db      	uxtb	r3, r3
 8006bfe:	9801      	ldr	r0, [sp, #4]
 8006c00:	4619      	mov	r1, r3
 8006c02:	f002 fdc5 	bl	8009790 <usb_lld_stall_out>
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8006c06:	9b01      	ldr	r3, [sp, #4]
 8006c08:	2200      	movs	r2, #0
 8006c0a:	651a      	str	r2, [r3, #80]	; 0x50
 8006c0c:	9b01      	ldr	r3, [sp, #4]
 8006c0e:	2200      	movs	r2, #0
 8006c10:	655a      	str	r2, [r3, #84]	; 0x54
 8006c12:	9b01      	ldr	r3, [sp, #4]
 8006c14:	2200      	movs	r2, #0
 8006c16:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 8006c18:	2301      	movs	r3, #1
 8006c1a:	e000      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_INTERFACE << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_SET_INTERFACE << 8):
    /* All the above requests are not handled here, if you need them then
       use the hook mechanism and provide handling.*/
  default:
    return false;
 8006c1c:	2300      	movs	r3, #0
  }
}
 8006c1e:	4618      	mov	r0, r3
 8006c20:	b004      	add	sp, #16
 8006c22:	bd70      	pop	{r4, r5, r6, pc}
 8006c24:	08017860 	.word	0x08017860
 8006c28:	08017868 	.word	0x08017868
 8006c2c:	08017864 	.word	0x08017864

08006c30 <usbInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void usbInit(void) {
 8006c30:	b508      	push	{r3, lr}

  usb_lld_init();
 8006c32:	f002 f93d 	bl	8008eb0 <usb_lld_init>
}
 8006c36:	bd08      	pop	{r3, pc}
 8006c38:	f3af 8000 	nop.w
 8006c3c:	f3af 8000 	nop.w

08006c40 <usbObjectInit>:
 *
 * @param[out] usbp     pointer to the @p USBDriver object
 *
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
 8006c40:	b084      	sub	sp, #16
 8006c42:	9001      	str	r0, [sp, #4]
  unsigned i;

  usbp->state        = USB_STOP;
 8006c44:	9b01      	ldr	r3, [sp, #4]
 8006c46:	2201      	movs	r2, #1
 8006c48:	701a      	strb	r2, [r3, #0]
  usbp->config       = NULL;
 8006c4a:	9b01      	ldr	r3, [sp, #4]
 8006c4c:	2200      	movs	r2, #0
 8006c4e:	605a      	str	r2, [r3, #4]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006c50:	2300      	movs	r3, #0
 8006c52:	9303      	str	r3, [sp, #12]
 8006c54:	e00f      	b.n	8006c76 <usbObjectInit+0x36>
    usbp->in_params[i]  = NULL;
 8006c56:	9a01      	ldr	r2, [sp, #4]
 8006c58:	9b03      	ldr	r3, [sp, #12]
 8006c5a:	3308      	adds	r3, #8
 8006c5c:	009b      	lsls	r3, r3, #2
 8006c5e:	4413      	add	r3, r2
 8006c60:	2200      	movs	r2, #0
 8006c62:	605a      	str	r2, [r3, #4]
    usbp->out_params[i] = NULL;
 8006c64:	9b01      	ldr	r3, [sp, #4]
 8006c66:	9a03      	ldr	r2, [sp, #12]
 8006c68:	320e      	adds	r2, #14
 8006c6a:	2100      	movs	r1, #0
 8006c6c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006c70:	9b03      	ldr	r3, [sp, #12]
 8006c72:	3301      	adds	r3, #1
 8006c74:	9303      	str	r3, [sp, #12]
 8006c76:	9b03      	ldr	r3, [sp, #12]
 8006c78:	2b04      	cmp	r3, #4
 8006c7a:	d9ec      	bls.n	8006c56 <usbObjectInit+0x16>
    usbp->in_params[i]  = NULL;
    usbp->out_params[i] = NULL;
  }
  usbp->transmitting = 0;
 8006c7c:	9b01      	ldr	r3, [sp, #4]
 8006c7e:	2200      	movs	r2, #0
 8006c80:	811a      	strh	r2, [r3, #8]
  usbp->receiving    = 0;
 8006c82:	9b01      	ldr	r3, [sp, #4]
 8006c84:	2200      	movs	r2, #0
 8006c86:	815a      	strh	r2, [r3, #10]
}
 8006c88:	b004      	add	sp, #16
 8006c8a:	4770      	bx	lr
 8006c8c:	f3af 8000 	nop.w

08006c90 <usbStart>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] config    pointer to the @p USBConfig object
 *
 * @api
 */
void usbStart(USBDriver *usbp, const USBConfig *config) {
 8006c90:	b500      	push	{lr}
 8006c92:	b085      	sub	sp, #20
 8006c94:	9001      	str	r0, [sp, #4]
 8006c96:	9100      	str	r1, [sp, #0]
  unsigned i;

  osalDbgCheck((usbp != NULL) && (config != NULL));

  osalSysLock();
 8006c98:	f7ff fd7a 	bl	8006790 <osalSysLock>
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
 8006c9c:	9b01      	ldr	r3, [sp, #4]
 8006c9e:	9a00      	ldr	r2, [sp, #0]
 8006ca0:	605a      	str	r2, [r3, #4]
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006ca2:	2300      	movs	r3, #0
 8006ca4:	9303      	str	r3, [sp, #12]
 8006ca6:	e009      	b.n	8006cbc <usbStart+0x2c>
    usbp->epc[i] = NULL;
 8006ca8:	9a01      	ldr	r2, [sp, #4]
 8006caa:	9b03      	ldr	r3, [sp, #12]
 8006cac:	3302      	adds	r3, #2
 8006cae:	009b      	lsls	r3, r3, #2
 8006cb0:	4413      	add	r3, r2
 8006cb2:	2200      	movs	r2, #0
 8006cb4:	605a      	str	r2, [r3, #4]

  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006cb6:	9b03      	ldr	r3, [sp, #12]
 8006cb8:	3301      	adds	r3, #1
 8006cba:	9303      	str	r3, [sp, #12]
 8006cbc:	9b03      	ldr	r3, [sp, #12]
 8006cbe:	2b05      	cmp	r3, #5
 8006cc0:	d9f2      	bls.n	8006ca8 <usbStart+0x18>
    usbp->epc[i] = NULL;
  }
  usb_lld_start(usbp);
 8006cc2:	9801      	ldr	r0, [sp, #4]
 8006cc4:	f002 f90c 	bl	8008ee0 <usb_lld_start>
  usbp->state = USB_READY;
 8006cc8:	9b01      	ldr	r3, [sp, #4]
 8006cca:	2202      	movs	r2, #2
 8006ccc:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 8006cce:	f7ff fd67 	bl	80067a0 <osalSysUnlock>
}
 8006cd2:	b005      	add	sp, #20
 8006cd4:	f85d fb04 	ldr.w	pc, [sp], #4
 8006cd8:	f3af 8000 	nop.w
 8006cdc:	f3af 8000 	nop.w

08006ce0 <usbStop>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @api
 */
void usbStop(USBDriver *usbp) {
 8006ce0:	b500      	push	{lr}
 8006ce2:	b085      	sub	sp, #20
 8006ce4:	9001      	str	r0, [sp, #4]
  unsigned i;

  osalDbgCheck(usbp != NULL);

  osalSysLock();
 8006ce6:	f7ff fd53 	bl	8006790 <osalSysLock>
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY) ||
                (usbp->state == USB_SELECTED) || (usbp->state == USB_ACTIVE) ||
                (usbp->state == USB_SUSPENDED),
                "invalid state");

  usb_lld_stop(usbp);
 8006cea:	9801      	ldr	r0, [sp, #4]
 8006cec:	f002 f988 	bl	8009000 <usb_lld_stop>
  usbp->state = USB_STOP;
 8006cf0:	9b01      	ldr	r3, [sp, #4]
 8006cf2:	2201      	movs	r2, #1
 8006cf4:	701a      	strb	r2, [r3, #0]

  /* Resetting all ongoing synchronous operations.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006cf6:	2300      	movs	r3, #0
 8006cf8:	9303      	str	r3, [sp, #12]
 8006cfa:	e009      	b.n	8006d10 <usbStop+0x30>
      if (usbp->epc[i]->out_state != NULL) {
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
    }
#endif
    usbp->epc[i] = NULL;
 8006cfc:	9a01      	ldr	r2, [sp, #4]
 8006cfe:	9b03      	ldr	r3, [sp, #12]
 8006d00:	3302      	adds	r3, #2
 8006d02:	009b      	lsls	r3, r3, #2
 8006d04:	4413      	add	r3, r2
 8006d06:	2200      	movs	r2, #0
 8006d08:	605a      	str	r2, [r3, #4]

  usb_lld_stop(usbp);
  usbp->state = USB_STOP;

  /* Resetting all ongoing synchronous operations.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006d0a:	9b03      	ldr	r3, [sp, #12]
 8006d0c:	3301      	adds	r3, #1
 8006d0e:	9303      	str	r3, [sp, #12]
 8006d10:	9b03      	ldr	r3, [sp, #12]
 8006d12:	2b05      	cmp	r3, #5
 8006d14:	d9f2      	bls.n	8006cfc <usbStop+0x1c>
      }
    }
#endif
    usbp->epc[i] = NULL;
  }
  osalOsRescheduleS();
 8006d16:	f7ff fd5b 	bl	80067d0 <osalOsRescheduleS>

  osalSysUnlock();
 8006d1a:	f7ff fd41 	bl	80067a0 <osalSysUnlock>
}
 8006d1e:	b005      	add	sp, #20
 8006d20:	f85d fb04 	ldr.w	pc, [sp], #4
 8006d24:	f3af 8000 	nop.w
 8006d28:	f3af 8000 	nop.w
 8006d2c:	f3af 8000 	nop.w

08006d30 <usbInitEndpointI>:
 * @param[in] epcp      the endpoint configuration
 *
 * @iclass
 */
void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
                      const USBEndpointConfig *epcp) {
 8006d30:	b500      	push	{lr}
 8006d32:	b085      	sub	sp, #20
 8006d34:	9003      	str	r0, [sp, #12]
 8006d36:	460b      	mov	r3, r1
 8006d38:	9201      	str	r2, [sp, #4]
 8006d3a:	f88d 300b 	strb.w	r3, [sp, #11]
  osalDbgAssert(usbp->state == USB_ACTIVE,
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");

  /* Logically enabling the endpoint in the USBDriver structure.*/
  usbp->epc[ep] = epcp;
 8006d3e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006d42:	9a03      	ldr	r2, [sp, #12]
 8006d44:	3302      	adds	r3, #2
 8006d46:	009b      	lsls	r3, r3, #2
 8006d48:	4413      	add	r3, r2
 8006d4a:	9a01      	ldr	r2, [sp, #4]
 8006d4c:	605a      	str	r2, [r3, #4]

  /* Clearing the state structures, custom fields as well.*/
  if (epcp->in_state != NULL) {
 8006d4e:	9b01      	ldr	r3, [sp, #4]
 8006d50:	695b      	ldr	r3, [r3, #20]
 8006d52:	2b00      	cmp	r3, #0
 8006d54:	d006      	beq.n	8006d64 <usbInitEndpointI+0x34>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 8006d56:	9b01      	ldr	r3, [sp, #4]
 8006d58:	695b      	ldr	r3, [r3, #20]
 8006d5a:	4618      	mov	r0, r3
 8006d5c:	2100      	movs	r1, #0
 8006d5e:	2210      	movs	r2, #16
 8006d60:	f010 fb4e 	bl	8017400 <memset>
  }
  if (epcp->out_state != NULL) {
 8006d64:	9b01      	ldr	r3, [sp, #4]
 8006d66:	699b      	ldr	r3, [r3, #24]
 8006d68:	2b00      	cmp	r3, #0
 8006d6a:	d006      	beq.n	8006d7a <usbInitEndpointI+0x4a>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 8006d6c:	9b01      	ldr	r3, [sp, #4]
 8006d6e:	699b      	ldr	r3, [r3, #24]
 8006d70:	4618      	mov	r0, r3
 8006d72:	2100      	movs	r1, #0
 8006d74:	2210      	movs	r2, #16
 8006d76:	f010 fb43 	bl	8017400 <memset>
  }

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
 8006d7a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006d7e:	9803      	ldr	r0, [sp, #12]
 8006d80:	4619      	mov	r1, r3
 8006d82:	f002 fa1d 	bl	80091c0 <usb_lld_init_endpoint>
}
 8006d86:	b005      	add	sp, #20
 8006d88:	f85d fb04 	ldr.w	pc, [sp], #4
 8006d8c:	f3af 8000 	nop.w

08006d90 <usbDisableEndpointsI>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @iclass
 */
void usbDisableEndpointsI(USBDriver *usbp) {
 8006d90:	b500      	push	{lr}
 8006d92:	b085      	sub	sp, #20
 8006d94:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
 8006d96:	9b01      	ldr	r3, [sp, #4]
 8006d98:	891b      	ldrh	r3, [r3, #8]
 8006d9a:	f003 0301 	and.w	r3, r3, #1
 8006d9e:	b29a      	uxth	r2, r3
 8006da0:	9b01      	ldr	r3, [sp, #4]
 8006da2:	811a      	strh	r2, [r3, #8]
  usbp->receiving    &= 1U;
 8006da4:	9b01      	ldr	r3, [sp, #4]
 8006da6:	895b      	ldrh	r3, [r3, #10]
 8006da8:	f003 0301 	and.w	r3, r3, #1
 8006dac:	b29a      	uxth	r2, r3
 8006dae:	9b01      	ldr	r3, [sp, #4]
 8006db0:	815a      	strh	r2, [r3, #10]

  for (i = 1; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006db2:	2301      	movs	r3, #1
 8006db4:	9303      	str	r3, [sp, #12]
 8006db6:	e009      	b.n	8006dcc <usbDisableEndpointsI+0x3c>
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 8006db8:	9a01      	ldr	r2, [sp, #4]
 8006dba:	9b03      	ldr	r3, [sp, #12]
 8006dbc:	3302      	adds	r3, #2
 8006dbe:	009b      	lsls	r3, r3, #2
 8006dc0:	4413      	add	r3, r2
 8006dc2:	2200      	movs	r2, #0
 8006dc4:	605a      	str	r2, [r3, #4]
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
  usbp->receiving    &= 1U;

  for (i = 1; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006dc6:	9b03      	ldr	r3, [sp, #12]
 8006dc8:	3301      	adds	r3, #1
 8006dca:	9303      	str	r3, [sp, #12]
 8006dcc:	9b03      	ldr	r3, [sp, #12]
 8006dce:	2b05      	cmp	r3, #5
 8006dd0:	d9f2      	bls.n	8006db8 <usbDisableEndpointsI+0x28>
#endif
    usbp->epc[i] = NULL;
  }

  /* Low level endpoints deactivation.*/
  usb_lld_disable_endpoints(usbp);
 8006dd2:	9801      	ldr	r0, [sp, #4]
 8006dd4:	f002 fb24 	bl	8009420 <usb_lld_disable_endpoints>
}
 8006dd8:	b005      	add	sp, #20
 8006dda:	f85d fb04 	ldr.w	pc, [sp], #4
 8006dde:	bf00      	nop

08006de0 <usbStartReceiveI>:
 *                      the packet size because the excess is discarded.
 *
 * @iclass
 */
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
                      uint8_t *buf, size_t n) {
 8006de0:	b500      	push	{lr}
 8006de2:	b087      	sub	sp, #28
 8006de4:	9003      	str	r0, [sp, #12]
 8006de6:	9201      	str	r2, [sp, #4]
 8006de8:	9300      	str	r3, [sp, #0]
 8006dea:	460b      	mov	r3, r1
 8006dec:	f88d 300b 	strb.w	r3, [sp, #11]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8006df0:	9b03      	ldr	r3, [sp, #12]
 8006df2:	895a      	ldrh	r2, [r3, #10]
 8006df4:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006df8:	2101      	movs	r1, #1
 8006dfa:	fa01 f303 	lsl.w	r3, r1, r3
 8006dfe:	b29b      	uxth	r3, r3
 8006e00:	4313      	orrs	r3, r2
 8006e02:	b29a      	uxth	r2, r3
 8006e04:	9b03      	ldr	r3, [sp, #12]
 8006e06:	815a      	strh	r2, [r3, #10]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 8006e08:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006e0c:	9a03      	ldr	r2, [sp, #12]
 8006e0e:	3302      	adds	r3, #2
 8006e10:	009b      	lsls	r3, r3, #2
 8006e12:	4413      	add	r3, r2
 8006e14:	685b      	ldr	r3, [r3, #4]
 8006e16:	699b      	ldr	r3, [r3, #24]
 8006e18:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  osp->rxbuf  = buf;
 8006e1a:	9b05      	ldr	r3, [sp, #20]
 8006e1c:	9a01      	ldr	r2, [sp, #4]
 8006e1e:	609a      	str	r2, [r3, #8]
  osp->rxsize = n;
 8006e20:	9b05      	ldr	r3, [sp, #20]
 8006e22:	9a00      	ldr	r2, [sp, #0]
 8006e24:	601a      	str	r2, [r3, #0]
  osp->rxcnt  = 0;
 8006e26:	9b05      	ldr	r3, [sp, #20]
 8006e28:	2200      	movs	r2, #0
 8006e2a:	605a      	str	r2, [r3, #4]
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 8006e2c:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006e30:	9803      	ldr	r0, [sp, #12]
 8006e32:	4619      	mov	r1, r3
 8006e34:	f002 fb5c 	bl	80094f0 <usb_lld_start_out>
}
 8006e38:	b007      	add	sp, #28
 8006e3a:	f85d fb04 	ldr.w	pc, [sp], #4
 8006e3e:	bf00      	nop

08006e40 <usbStartTransmitI>:
 * @param[in] n         transaction size
 *
 * @iclass
 */
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
 8006e40:	b500      	push	{lr}
 8006e42:	b087      	sub	sp, #28
 8006e44:	9003      	str	r0, [sp, #12]
 8006e46:	9201      	str	r2, [sp, #4]
 8006e48:	9300      	str	r3, [sp, #0]
 8006e4a:	460b      	mov	r3, r1
 8006e4c:	f88d 300b 	strb.w	r3, [sp, #11]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8006e50:	9b03      	ldr	r3, [sp, #12]
 8006e52:	891a      	ldrh	r2, [r3, #8]
 8006e54:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006e58:	2101      	movs	r1, #1
 8006e5a:	fa01 f303 	lsl.w	r3, r1, r3
 8006e5e:	b29b      	uxth	r3, r3
 8006e60:	4313      	orrs	r3, r2
 8006e62:	b29a      	uxth	r2, r3
 8006e64:	9b03      	ldr	r3, [sp, #12]
 8006e66:	811a      	strh	r2, [r3, #8]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 8006e68:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006e6c:	9a03      	ldr	r2, [sp, #12]
 8006e6e:	3302      	adds	r3, #2
 8006e70:	009b      	lsls	r3, r3, #2
 8006e72:	4413      	add	r3, r2
 8006e74:	685b      	ldr	r3, [r3, #4]
 8006e76:	695b      	ldr	r3, [r3, #20]
 8006e78:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  isp->txbuf  = buf;
 8006e7a:	9b05      	ldr	r3, [sp, #20]
 8006e7c:	9a01      	ldr	r2, [sp, #4]
 8006e7e:	609a      	str	r2, [r3, #8]
  isp->txsize = n;
 8006e80:	9b05      	ldr	r3, [sp, #20]
 8006e82:	9a00      	ldr	r2, [sp, #0]
 8006e84:	601a      	str	r2, [r3, #0]
  isp->txcnt  = 0;
 8006e86:	9b05      	ldr	r3, [sp, #20]
 8006e88:	2200      	movs	r2, #0
 8006e8a:	605a      	str	r2, [r3, #4]
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 8006e8c:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006e90:	9803      	ldr	r0, [sp, #12]
 8006e92:	4619      	mov	r1, r3
 8006e94:	f002 fbcc 	bl	8009630 <usb_lld_start_in>
}
 8006e98:	b007      	add	sp, #28
 8006e9a:	f85d fb04 	ldr.w	pc, [sp], #4
 8006e9e:	bf00      	nop

08006ea0 <usbStallReceiveI>:
 * @retval false        Endpoint stalled.
 * @retval true         Endpoint busy, not stalled.
 *
 * @iclass
 */
bool usbStallReceiveI(USBDriver *usbp, usbep_t ep) {
 8006ea0:	b500      	push	{lr}
 8006ea2:	b083      	sub	sp, #12
 8006ea4:	9001      	str	r0, [sp, #4]
 8006ea6:	460b      	mov	r3, r1
 8006ea8:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetReceiveStatusI(usbp, ep)) {
 8006eac:	9b01      	ldr	r3, [sp, #4]
 8006eae:	895a      	ldrh	r2, [r3, #10]
 8006eb0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006eb4:	2101      	movs	r1, #1
 8006eb6:	fa01 f303 	lsl.w	r3, r1, r3
 8006eba:	b29b      	uxth	r3, r3
 8006ebc:	4013      	ands	r3, r2
 8006ebe:	b29b      	uxth	r3, r3
 8006ec0:	2b00      	cmp	r3, #0
 8006ec2:	d001      	beq.n	8006ec8 <usbStallReceiveI+0x28>
    return true;
 8006ec4:	2301      	movs	r3, #1
 8006ec6:	e006      	b.n	8006ed6 <usbStallReceiveI+0x36>
  }

  usb_lld_stall_out(usbp, ep);
 8006ec8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006ecc:	9801      	ldr	r0, [sp, #4]
 8006ece:	4619      	mov	r1, r3
 8006ed0:	f002 fc5e 	bl	8009790 <usb_lld_stall_out>
  return false;
 8006ed4:	2300      	movs	r3, #0
}
 8006ed6:	4618      	mov	r0, r3
 8006ed8:	b003      	add	sp, #12
 8006eda:	f85d fb04 	ldr.w	pc, [sp], #4
 8006ede:	bf00      	nop

08006ee0 <usbStallTransmitI>:
 * @retval false        Endpoint stalled.
 * @retval true         Endpoint busy, not stalled.
 *
 * @iclass
 */
bool usbStallTransmitI(USBDriver *usbp, usbep_t ep) {
 8006ee0:	b500      	push	{lr}
 8006ee2:	b083      	sub	sp, #12
 8006ee4:	9001      	str	r0, [sp, #4]
 8006ee6:	460b      	mov	r3, r1
 8006ee8:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetTransmitStatusI(usbp, ep)) {
 8006eec:	9b01      	ldr	r3, [sp, #4]
 8006eee:	891a      	ldrh	r2, [r3, #8]
 8006ef0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006ef4:	2101      	movs	r1, #1
 8006ef6:	fa01 f303 	lsl.w	r3, r1, r3
 8006efa:	b29b      	uxth	r3, r3
 8006efc:	4013      	ands	r3, r2
 8006efe:	b29b      	uxth	r3, r3
 8006f00:	2b00      	cmp	r3, #0
 8006f02:	d001      	beq.n	8006f08 <usbStallTransmitI+0x28>
    return true;
 8006f04:	2301      	movs	r3, #1
 8006f06:	e006      	b.n	8006f16 <usbStallTransmitI+0x36>
  }

  usb_lld_stall_in(usbp, ep);
 8006f08:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006f0c:	9801      	ldr	r0, [sp, #4]
 8006f0e:	4619      	mov	r1, r3
 8006f10:	f002 fc5e 	bl	80097d0 <usb_lld_stall_in>
  return false;
 8006f14:	2300      	movs	r3, #0
}
 8006f16:	4618      	mov	r0, r3
 8006f18:	b003      	add	sp, #12
 8006f1a:	f85d fb04 	ldr.w	pc, [sp], #4
 8006f1e:	bf00      	nop

08006f20 <_usb_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_reset(USBDriver *usbp) {
 8006f20:	b500      	push	{lr}
 8006f22:	b085      	sub	sp, #20
 8006f24:	9001      	str	r0, [sp, #4]
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 8006f26:	9b01      	ldr	r3, [sp, #4]
 8006f28:	2202      	movs	r2, #2
 8006f2a:	701a      	strb	r2, [r3, #0]

  /* Resetting internal state.*/
  usbp->status        = 0;
 8006f2c:	9b01      	ldr	r3, [sp, #4]
 8006f2e:	2200      	movs	r2, #0
 8006f30:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
  usbp->address       = 0;
 8006f34:	9b01      	ldr	r3, [sp, #4]
 8006f36:	2200      	movs	r2, #0
 8006f38:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66
  usbp->configuration = 0;
 8006f3c:	9b01      	ldr	r3, [sp, #4]
 8006f3e:	2200      	movs	r2, #0
 8006f40:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
  usbp->transmitting  = 0;
 8006f44:	9b01      	ldr	r3, [sp, #4]
 8006f46:	2200      	movs	r2, #0
 8006f48:	811a      	strh	r2, [r3, #8]
  usbp->receiving     = 0;
 8006f4a:	9b01      	ldr	r3, [sp, #4]
 8006f4c:	2200      	movs	r2, #0
 8006f4e:	815a      	strh	r2, [r3, #10]

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006f50:	2300      	movs	r3, #0
 8006f52:	9303      	str	r3, [sp, #12]
 8006f54:	e009      	b.n	8006f6a <_usb_reset+0x4a>
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 8006f56:	9a01      	ldr	r2, [sp, #4]
 8006f58:	9b03      	ldr	r3, [sp, #12]
 8006f5a:	3302      	adds	r3, #2
 8006f5c:	009b      	lsls	r3, r3, #2
 8006f5e:	4413      	add	r3, r2
 8006f60:	2200      	movs	r2, #0
 8006f62:	605a      	str	r2, [r3, #4]
  usbp->configuration = 0;
  usbp->transmitting  = 0;
  usbp->receiving     = 0;

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006f64:	9b03      	ldr	r3, [sp, #12]
 8006f66:	3301      	adds	r3, #1
 8006f68:	9303      	str	r3, [sp, #12]
 8006f6a:	9b03      	ldr	r3, [sp, #12]
 8006f6c:	2b05      	cmp	r3, #5
 8006f6e:	d9f2      	bls.n	8006f56 <_usb_reset+0x36>
#endif
    usbp->epc[i] = NULL;
  }

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8006f70:	9b01      	ldr	r3, [sp, #4]
 8006f72:	2200      	movs	r2, #0
 8006f74:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c

  /* Low level reset.*/
  usb_lld_reset(usbp);
 8006f78:	9801      	ldr	r0, [sp, #4]
 8006f7a:	f002 f871 	bl	8009060 <usb_lld_reset>

  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8006f7e:	9b01      	ldr	r3, [sp, #4]
 8006f80:	685b      	ldr	r3, [r3, #4]
 8006f82:	681b      	ldr	r3, [r3, #0]
 8006f84:	2b00      	cmp	r3, #0
 8006f86:	d005      	beq.n	8006f94 <_usb_reset+0x74>
 8006f88:	9b01      	ldr	r3, [sp, #4]
 8006f8a:	685b      	ldr	r3, [r3, #4]
 8006f8c:	681b      	ldr	r3, [r3, #0]
 8006f8e:	9801      	ldr	r0, [sp, #4]
 8006f90:	2100      	movs	r1, #0
 8006f92:	4798      	blx	r3
}
 8006f94:	b005      	add	sp, #20
 8006f96:	f85d fb04 	ldr.w	pc, [sp], #4
 8006f9a:	bf00      	nop
 8006f9c:	f3af 8000 	nop.w

08006fa0 <_usb_suspend>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_suspend(USBDriver *usbp) {
 8006fa0:	b500      	push	{lr}
 8006fa2:	b083      	sub	sp, #12
 8006fa4:	9001      	str	r0, [sp, #4]
  /* No state change, suspend always returns to previous state. */

  /* State transition.*/
  usbp->saved_state = usbp->state;
 8006fa6:	9b01      	ldr	r3, [sp, #4]
 8006fa8:	781a      	ldrb	r2, [r3, #0]
 8006faa:	9b01      	ldr	r3, [sp, #4]
 8006fac:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
  usbp->state       = USB_SUSPENDED;
 8006fb0:	9b01      	ldr	r3, [sp, #4]
 8006fb2:	2205      	movs	r2, #5
 8006fb4:	701a      	strb	r2, [r3, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8006fb6:	9b01      	ldr	r3, [sp, #4]
 8006fb8:	685b      	ldr	r3, [r3, #4]
 8006fba:	681b      	ldr	r3, [r3, #0]
 8006fbc:	2b00      	cmp	r3, #0
 8006fbe:	d005      	beq.n	8006fcc <_usb_suspend+0x2c>
 8006fc0:	9b01      	ldr	r3, [sp, #4]
 8006fc2:	685b      	ldr	r3, [r3, #4]
 8006fc4:	681b      	ldr	r3, [r3, #0]
 8006fc6:	9801      	ldr	r0, [sp, #4]
 8006fc8:	2104      	movs	r1, #4
 8006fca:	4798      	blx	r3
        osalSysUnlockFromISR();
      }
    }
  }
#endif
}
 8006fcc:	b003      	add	sp, #12
 8006fce:	f85d fb04 	ldr.w	pc, [sp], #4
 8006fd2:	bf00      	nop
 8006fd4:	f3af 8000 	nop.w
 8006fd8:	f3af 8000 	nop.w
 8006fdc:	f3af 8000 	nop.w

08006fe0 <_usb_wakeup>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {
 8006fe0:	b500      	push	{lr}
 8006fe2:	b083      	sub	sp, #12
 8006fe4:	9001      	str	r0, [sp, #4]

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;
 8006fe6:	9b01      	ldr	r3, [sp, #4]
 8006fe8:	f893 2068 	ldrb.w	r2, [r3, #104]	; 0x68
 8006fec:	9b01      	ldr	r3, [sp, #4]
 8006fee:	701a      	strb	r2, [r3, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8006ff0:	9b01      	ldr	r3, [sp, #4]
 8006ff2:	685b      	ldr	r3, [r3, #4]
 8006ff4:	681b      	ldr	r3, [r3, #0]
 8006ff6:	2b00      	cmp	r3, #0
 8006ff8:	d005      	beq.n	8007006 <_usb_wakeup+0x26>
 8006ffa:	9b01      	ldr	r3, [sp, #4]
 8006ffc:	685b      	ldr	r3, [r3, #4]
 8006ffe:	681b      	ldr	r3, [r3, #0]
 8007000:	9801      	ldr	r0, [sp, #4]
 8007002:	2105      	movs	r1, #5
 8007004:	4798      	blx	r3
}
 8007006:	b003      	add	sp, #12
 8007008:	f85d fb04 	ldr.w	pc, [sp], #4
 800700c:	f3af 8000 	nop.w

08007010 <_usb_ep0setup>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8007010:	b500      	push	{lr}
 8007012:	b085      	sub	sp, #20
 8007014:	9001      	str	r0, [sp, #4]
 8007016:	460b      	mov	r3, r1
 8007018:	f88d 3003 	strb.w	r3, [sp, #3]
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 800701c:	9b01      	ldr	r3, [sp, #4]
 800701e:	2200      	movs	r2, #0
 8007020:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
  usbReadSetup(usbp, ep, usbp->setup);
 8007024:	9b01      	ldr	r3, [sp, #4]
 8007026:	335c      	adds	r3, #92	; 0x5c
 8007028:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800702c:	9801      	ldr	r0, [sp, #4]
 800702e:	4611      	mov	r1, r2
 8007030:	461a      	mov	r2, r3
 8007032:	f002 fa45 	bl	80094c0 <usb_lld_read_setup>

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8007036:	9b01      	ldr	r3, [sp, #4]
 8007038:	685b      	ldr	r3, [r3, #4]
 800703a:	689b      	ldr	r3, [r3, #8]
 800703c:	2b00      	cmp	r3, #0
 800703e:	d00a      	beq.n	8007056 <_usb_ep0setup+0x46>
      !(usbp->config->requests_hook_cb(usbp))) {
 8007040:	9b01      	ldr	r3, [sp, #4]
 8007042:	685b      	ldr	r3, [r3, #4]
 8007044:	689b      	ldr	r3, [r3, #8]
 8007046:	9801      	ldr	r0, [sp, #4]
 8007048:	4798      	blx	r3
 800704a:	4603      	mov	r3, r0
 800704c:	f083 0301 	eor.w	r3, r3, #1
 8007050:	b2db      	uxtb	r3, r3
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8007052:	2b00      	cmp	r3, #0
 8007054:	d027      	beq.n	80070a6 <_usb_ep0setup+0x96>
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8007056:	9b01      	ldr	r3, [sp, #4]
 8007058:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800705c:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8007060:	2b00      	cmp	r3, #0
 8007062:	d108      	bne.n	8007076 <_usb_ep0setup+0x66>
        !default_handler(usbp)) {
 8007064:	9801      	ldr	r0, [sp, #4]
 8007066:	f7ff fbf3 	bl	8006850 <default_handler>
 800706a:	4603      	mov	r3, r0
 800706c:	f083 0301 	eor.w	r3, r3, #1
 8007070:	b2db      	uxtb	r3, r3
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8007072:	2b00      	cmp	r3, #0
 8007074:	d017      	beq.n	80070a6 <_usb_ep0setup+0x96>
        !default_handler(usbp)) {
    /*lint -restore*/
      /* Error response, the state machine goes into an error state, the low
         level layer will have to reset it to USB_EP0_WAITING_SETUP after
         receiving a SETUP packet.*/
      usb_lld_stall_in(usbp, 0);
 8007076:	9801      	ldr	r0, [sp, #4]
 8007078:	2100      	movs	r1, #0
 800707a:	f002 fba9 	bl	80097d0 <usb_lld_stall_in>
      usb_lld_stall_out(usbp, 0);
 800707e:	9801      	ldr	r0, [sp, #4]
 8007080:	2100      	movs	r1, #0
 8007082:	f002 fb85 	bl	8009790 <usb_lld_stall_out>
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8007086:	9b01      	ldr	r3, [sp, #4]
 8007088:	685b      	ldr	r3, [r3, #4]
 800708a:	681b      	ldr	r3, [r3, #0]
 800708c:	2b00      	cmp	r3, #0
 800708e:	d005      	beq.n	800709c <_usb_ep0setup+0x8c>
 8007090:	9b01      	ldr	r3, [sp, #4]
 8007092:	685b      	ldr	r3, [r3, #4]
 8007094:	681b      	ldr	r3, [r3, #0]
 8007096:	9801      	ldr	r0, [sp, #4]
 8007098:	2106      	movs	r1, #6
 800709a:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 800709c:	9b01      	ldr	r3, [sp, #4]
 800709e:	2206      	movs	r2, #6
 80070a0:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      return;
 80070a4:	e05c      	b.n	8007160 <_usb_ep0setup+0x150>
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
 80070a6:	9b01      	ldr	r3, [sp, #4]
 80070a8:	3362      	adds	r3, #98	; 0x62
 80070aa:	4618      	mov	r0, r3
 80070ac:	f7ff fb98 	bl	80067e0 <get_hword>
 80070b0:	4603      	mov	r3, r0
 80070b2:	9303      	str	r3, [sp, #12]
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 80070b4:	9b01      	ldr	r3, [sp, #4]
 80070b6:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80070b8:	9b03      	ldr	r3, [sp, #12]
 80070ba:	429a      	cmp	r2, r3
 80070bc:	d902      	bls.n	80070c4 <_usb_ep0setup+0xb4>
    usbp->ep0n = max;
 80070be:	9b01      	ldr	r3, [sp, #4]
 80070c0:	9a03      	ldr	r2, [sp, #12]
 80070c2:	655a      	str	r2, [r3, #84]	; 0x54
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 80070c4:	9b01      	ldr	r3, [sp, #4]
 80070c6:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 80070ca:	b2db      	uxtb	r3, r3
 80070cc:	b25b      	sxtb	r3, r3
 80070ce:	2b00      	cmp	r3, #0
 80070d0:	da23      	bge.n	800711a <_usb_ep0setup+0x10a>
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
 80070d2:	9b01      	ldr	r3, [sp, #4]
 80070d4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80070d6:	2b00      	cmp	r3, #0
 80070d8:	d010      	beq.n	80070fc <_usb_ep0setup+0xec>
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
 80070da:	9b01      	ldr	r3, [sp, #4]
 80070dc:	2201      	movs	r2, #1
 80070de:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      osalSysLockFromISR();
 80070e2:	f7ff fb65 	bl	80067b0 <osalSysLockFromISR>
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 80070e6:	9b01      	ldr	r3, [sp, #4]
 80070e8:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80070ea:	9b01      	ldr	r3, [sp, #4]
 80070ec:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80070ee:	9801      	ldr	r0, [sp, #4]
 80070f0:	2100      	movs	r1, #0
 80070f2:	f7ff fea5 	bl	8006e40 <usbStartTransmitI>
      osalSysUnlockFromISR();
 80070f6:	f7ff fb63 	bl	80067c0 <osalSysUnlockFromISR>
 80070fa:	e031      	b.n	8007160 <_usb_ep0setup+0x150>
    }
    else {
      /* No transmission phase, directly receiving the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_WAITING_STS;
 80070fc:	9b01      	ldr	r3, [sp, #4]
 80070fe:	2203      	movs	r2, #3
 8007100:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
 8007104:	f7ff fb54 	bl	80067b0 <osalSysLockFromISR>
      usbStartReceiveI(usbp, 0, NULL, 0);
 8007108:	9801      	ldr	r0, [sp, #4]
 800710a:	2100      	movs	r1, #0
 800710c:	2200      	movs	r2, #0
 800710e:	2300      	movs	r3, #0
 8007110:	f7ff fe66 	bl	8006de0 <usbStartReceiveI>
      osalSysUnlockFromISR();
 8007114:	f7ff fb54 	bl	80067c0 <osalSysUnlockFromISR>
 8007118:	e022      	b.n	8007160 <_usb_ep0setup+0x150>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 800711a:	9b01      	ldr	r3, [sp, #4]
 800711c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800711e:	2b00      	cmp	r3, #0
 8007120:	d010      	beq.n	8007144 <_usb_ep0setup+0x134>
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
 8007122:	9b01      	ldr	r3, [sp, #4]
 8007124:	2204      	movs	r2, #4
 8007126:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      osalSysLockFromISR();
 800712a:	f7ff fb41 	bl	80067b0 <osalSysLockFromISR>
      usbStartReceiveI(usbp, 0, usbp->ep0next, usbp->ep0n);
 800712e:	9b01      	ldr	r3, [sp, #4]
 8007130:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8007132:	9b01      	ldr	r3, [sp, #4]
 8007134:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8007136:	9801      	ldr	r0, [sp, #4]
 8007138:	2100      	movs	r1, #0
 800713a:	f7ff fe51 	bl	8006de0 <usbStartReceiveI>
      osalSysUnlockFromISR();
 800713e:	f7ff fb3f 	bl	80067c0 <osalSysUnlockFromISR>
 8007142:	e00d      	b.n	8007160 <_usb_ep0setup+0x150>
    }
    else {
      /* No receive phase, directly sending the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_SENDING_STS;
 8007144:	9b01      	ldr	r3, [sp, #4]
 8007146:	2205      	movs	r2, #5
 8007148:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
 800714c:	f7ff fb30 	bl	80067b0 <osalSysLockFromISR>
      usbStartTransmitI(usbp, 0, NULL, 0);
 8007150:	9801      	ldr	r0, [sp, #4]
 8007152:	2100      	movs	r1, #0
 8007154:	2200      	movs	r2, #0
 8007156:	2300      	movs	r3, #0
 8007158:	f7ff fe72 	bl	8006e40 <usbStartTransmitI>
      osalSysUnlockFromISR();
 800715c:	f7ff fb30 	bl	80067c0 <osalSysUnlockFromISR>
#else
      usb_lld_end_setup(usbp, ep);
#endif
    }
  }
}
 8007160:	b005      	add	sp, #20
 8007162:	f85d fb04 	ldr.w	pc, [sp], #4
 8007166:	bf00      	nop
 8007168:	f3af 8000 	nop.w
 800716c:	f3af 8000 	nop.w

08007170 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8007170:	b500      	push	{lr}
 8007172:	b085      	sub	sp, #20
 8007174:	9001      	str	r0, [sp, #4]
 8007176:	460b      	mov	r3, r1
 8007178:	f88d 3003 	strb.w	r3, [sp, #3]
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 800717c:	9b01      	ldr	r3, [sp, #4]
 800717e:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 8007182:	2b06      	cmp	r3, #6
 8007184:	d86b      	bhi.n	800725e <_usb_ep0in+0xee>
 8007186:	a201      	add	r2, pc, #4	; (adr r2, 800718c <_usb_ep0in+0x1c>)
 8007188:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800718c:	0800722f 	.word	0x0800722f
 8007190:	080071a9 	.word	0x080071a9
 8007194:	080071f7 	.word	0x080071f7
 8007198:	0800722f 	.word	0x0800722f
 800719c:	0800722f 	.word	0x0800722f
 80071a0:	08007215 	.word	0x08007215
 80071a4:	0800722f 	.word	0x0800722f
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
 80071a8:	9b01      	ldr	r3, [sp, #4]
 80071aa:	3362      	adds	r3, #98	; 0x62
 80071ac:	4618      	mov	r0, r3
 80071ae:	f7ff fb17 	bl	80067e0 <get_hword>
 80071b2:	4603      	mov	r3, r0
 80071b4:	9303      	str	r3, [sp, #12]
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 80071b6:	9b01      	ldr	r3, [sp, #4]
 80071b8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80071ba:	9b03      	ldr	r3, [sp, #12]
 80071bc:	429a      	cmp	r2, r3
 80071be:	d21a      	bcs.n	80071f6 <_usb_ep0in+0x86>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 80071c0:	9b01      	ldr	r3, [sp, #4]
 80071c2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80071c4:	9a01      	ldr	r2, [sp, #4]
 80071c6:	68d2      	ldr	r2, [r2, #12]
 80071c8:	8a12      	ldrh	r2, [r2, #16]
 80071ca:	fbb3 f1f2 	udiv	r1, r3, r2
 80071ce:	fb02 f201 	mul.w	r2, r2, r1
 80071d2:	1a9b      	subs	r3, r3, r2
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 80071d4:	2b00      	cmp	r3, #0
 80071d6:	d10e      	bne.n	80071f6 <_usb_ep0in+0x86>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
      osalSysLockFromISR();
 80071d8:	f7ff faea 	bl	80067b0 <osalSysLockFromISR>
      usbStartTransmitI(usbp, 0, NULL, 0);
 80071dc:	9801      	ldr	r0, [sp, #4]
 80071de:	2100      	movs	r1, #0
 80071e0:	2200      	movs	r2, #0
 80071e2:	2300      	movs	r3, #0
 80071e4:	f7ff fe2c 	bl	8006e40 <usbStartTransmitI>
      osalSysUnlockFromISR();
 80071e8:	f7ff faea 	bl	80067c0 <osalSysUnlockFromISR>
      usbp->ep0state = USB_EP0_WAITING_TX0;
 80071ec:	9b01      	ldr	r3, [sp, #4]
 80071ee:	2202      	movs	r2, #2
 80071f0:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      return;
 80071f4:	e033      	b.n	800725e <_usb_ep0in+0xee>
    }
    /* Falls into, it is intentional.*/
  case USB_EP0_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_WAITING_STS;
 80071f6:	9b01      	ldr	r3, [sp, #4]
 80071f8:	2203      	movs	r2, #3
 80071fa:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
 80071fe:	f7ff fad7 	bl	80067b0 <osalSysLockFromISR>
    usbStartReceiveI(usbp, 0, NULL, 0);
 8007202:	9801      	ldr	r0, [sp, #4]
 8007204:	2100      	movs	r1, #0
 8007206:	2200      	movs	r2, #0
 8007208:	2300      	movs	r3, #0
 800720a:	f7ff fde9 	bl	8006de0 <usbStartReceiveI>
    osalSysUnlockFromISR();
 800720e:	f7ff fad7 	bl	80067c0 <osalSysUnlockFromISR>
#else
    usb_lld_end_setup(usbp, ep);
#endif
    return;
 8007212:	e024      	b.n	800725e <_usb_ep0in+0xee>
  case USB_EP0_SENDING_STS:
    /* Status packet sent, invoking the callback if defined.*/
    if (usbp->ep0endcb != NULL) {
 8007214:	9b01      	ldr	r3, [sp, #4]
 8007216:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8007218:	2b00      	cmp	r3, #0
 800721a:	d003      	beq.n	8007224 <_usb_ep0in+0xb4>
      usbp->ep0endcb(usbp);
 800721c:	9b01      	ldr	r3, [sp, #4]
 800721e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8007220:	9801      	ldr	r0, [sp, #4]
 8007222:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8007224:	9b01      	ldr	r3, [sp, #4]
 8007226:	2200      	movs	r2, #0
 8007228:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
    return;
 800722c:	e017      	b.n	800725e <_usb_ep0in+0xee>
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 800722e:	9801      	ldr	r0, [sp, #4]
 8007230:	2100      	movs	r1, #0
 8007232:	f002 facd 	bl	80097d0 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 8007236:	9801      	ldr	r0, [sp, #4]
 8007238:	2100      	movs	r1, #0
 800723a:	f002 faa9 	bl	8009790 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800723e:	9b01      	ldr	r3, [sp, #4]
 8007240:	685b      	ldr	r3, [r3, #4]
 8007242:	681b      	ldr	r3, [r3, #0]
 8007244:	2b00      	cmp	r3, #0
 8007246:	d005      	beq.n	8007254 <_usb_ep0in+0xe4>
 8007248:	9b01      	ldr	r3, [sp, #4]
 800724a:	685b      	ldr	r3, [r3, #4]
 800724c:	681b      	ldr	r3, [r3, #0]
 800724e:	9801      	ldr	r0, [sp, #4]
 8007250:	2106      	movs	r1, #6
 8007252:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8007254:	9b01      	ldr	r3, [sp, #4]
 8007256:	2206      	movs	r2, #6
 8007258:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
    return;
 800725c:	bf00      	nop
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 800725e:	b005      	add	sp, #20
 8007260:	f85d fb04 	ldr.w	pc, [sp], #4
 8007264:	f3af 8000 	nop.w
 8007268:	f3af 8000 	nop.w
 800726c:	f3af 8000 	nop.w

08007270 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8007270:	b500      	push	{lr}
 8007272:	b083      	sub	sp, #12
 8007274:	9001      	str	r0, [sp, #4]
 8007276:	460b      	mov	r3, r1
 8007278:	f88d 3003 	strb.w	r3, [sp, #3]

  (void)ep;
  switch (usbp->ep0state) {
 800727c:	9b01      	ldr	r3, [sp, #4]
 800727e:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 8007282:	2b06      	cmp	r3, #6
 8007284:	d84b      	bhi.n	800731e <_usb_ep0out+0xae>
 8007286:	a201      	add	r2, pc, #4	; (adr r2, 800728c <_usb_ep0out+0x1c>)
 8007288:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800728c:	080072ef 	.word	0x080072ef
 8007290:	080072ef 	.word	0x080072ef
 8007294:	080072ef 	.word	0x080072ef
 8007298:	080072c7 	.word	0x080072c7
 800729c:	080072a9 	.word	0x080072a9
 80072a0:	080072ef 	.word	0x080072ef
 80072a4:	080072ef 	.word	0x080072ef
  case USB_EP0_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_SENDING_STS;
 80072a8:	9b01      	ldr	r3, [sp, #4]
 80072aa:	2205      	movs	r2, #5
 80072ac:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
 80072b0:	f7ff fa7e 	bl	80067b0 <osalSysLockFromISR>
    usbStartTransmitI(usbp, 0, NULL, 0);
 80072b4:	9801      	ldr	r0, [sp, #4]
 80072b6:	2100      	movs	r1, #0
 80072b8:	2200      	movs	r2, #0
 80072ba:	2300      	movs	r3, #0
 80072bc:	f7ff fdc0 	bl	8006e40 <usbStartTransmitI>
    osalSysUnlockFromISR();
 80072c0:	f7ff fa7e 	bl	80067c0 <osalSysUnlockFromISR>
#else
    usb_lld_end_setup(usbp, ep);
#endif
    return;
 80072c4:	e02b      	b.n	800731e <_usb_ep0out+0xae>
  case USB_EP0_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 80072c6:	9b01      	ldr	r3, [sp, #4]
 80072c8:	68db      	ldr	r3, [r3, #12]
 80072ca:	699b      	ldr	r3, [r3, #24]
 80072cc:	685b      	ldr	r3, [r3, #4]
 80072ce:	2b00      	cmp	r3, #0
 80072d0:	d000      	beq.n	80072d4 <_usb_ep0out+0x64>
      break;
 80072d2:	e024      	b.n	800731e <_usb_ep0out+0xae>
    }
#endif
    if (usbp->ep0endcb != NULL) {
 80072d4:	9b01      	ldr	r3, [sp, #4]
 80072d6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80072d8:	2b00      	cmp	r3, #0
 80072da:	d003      	beq.n	80072e4 <_usb_ep0out+0x74>
      usbp->ep0endcb(usbp);
 80072dc:	9b01      	ldr	r3, [sp, #4]
 80072de:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80072e0:	9801      	ldr	r0, [sp, #4]
 80072e2:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 80072e4:	9b01      	ldr	r3, [sp, #4]
 80072e6:	2200      	movs	r2, #0
 80072e8:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
    return;
 80072ec:	e017      	b.n	800731e <_usb_ep0out+0xae>
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 80072ee:	9801      	ldr	r0, [sp, #4]
 80072f0:	2100      	movs	r1, #0
 80072f2:	f002 fa6d 	bl	80097d0 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 80072f6:	9801      	ldr	r0, [sp, #4]
 80072f8:	2100      	movs	r1, #0
 80072fa:	f002 fa49 	bl	8009790 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 80072fe:	9b01      	ldr	r3, [sp, #4]
 8007300:	685b      	ldr	r3, [r3, #4]
 8007302:	681b      	ldr	r3, [r3, #0]
 8007304:	2b00      	cmp	r3, #0
 8007306:	d005      	beq.n	8007314 <_usb_ep0out+0xa4>
 8007308:	9b01      	ldr	r3, [sp, #4]
 800730a:	685b      	ldr	r3, [r3, #4]
 800730c:	681b      	ldr	r3, [r3, #0]
 800730e:	9801      	ldr	r0, [sp, #4]
 8007310:	2106      	movs	r1, #6
 8007312:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8007314:	9b01      	ldr	r3, [sp, #4]
 8007316:	2206      	movs	r2, #6
 8007318:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
    return;
 800731c:	bf00      	nop
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 800731e:	b003      	add	sp, #12
 8007320:	f85d fb04 	ldr.w	pc, [sp], #4
 8007324:	f3af 8000 	nop.w
 8007328:	f3af 8000 	nop.w
 800732c:	f3af 8000 	nop.w

08007330 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8007330:	b082      	sub	sp, #8
 8007332:	9001      	str	r0, [sp, #4]
 8007334:	9100      	str	r1, [sp, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8007336:	4911      	ldr	r1, [pc, #68]	; (800737c <nvicEnableVector+0x4c>)
 8007338:	9b00      	ldr	r3, [sp, #0]
 800733a:	b2db      	uxtb	r3, r3
 800733c:	011b      	lsls	r3, r3, #4
 800733e:	b2da      	uxtb	r2, r3
 8007340:	9b01      	ldr	r3, [sp, #4]
 8007342:	440b      	add	r3, r1
 8007344:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8007348:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800734a:	4b0c      	ldr	r3, [pc, #48]	; (800737c <nvicEnableVector+0x4c>)
 800734c:	9a01      	ldr	r2, [sp, #4]
 800734e:	0952      	lsrs	r2, r2, #5
 8007350:	9901      	ldr	r1, [sp, #4]
 8007352:	f001 011f 	and.w	r1, r1, #31
 8007356:	2001      	movs	r0, #1
 8007358:	fa00 f101 	lsl.w	r1, r0, r1
 800735c:	3260      	adds	r2, #96	; 0x60
 800735e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8007362:	4b06      	ldr	r3, [pc, #24]	; (800737c <nvicEnableVector+0x4c>)
 8007364:	9a01      	ldr	r2, [sp, #4]
 8007366:	0952      	lsrs	r2, r2, #5
 8007368:	9901      	ldr	r1, [sp, #4]
 800736a:	f001 011f 	and.w	r1, r1, #31
 800736e:	2001      	movs	r0, #1
 8007370:	fa00 f101 	lsl.w	r1, r0, r1
 8007374:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8007378:	b002      	add	sp, #8
 800737a:	4770      	bx	lr
 800737c:	e000e100 	.word	0xe000e100

08007380 <nvicDisableVector>:
/**
 * @brief   Disables an interrupt handler.
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {
 8007380:	b082      	sub	sp, #8
 8007382:	9001      	str	r0, [sp, #4]

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8007384:	4b0a      	ldr	r3, [pc, #40]	; (80073b0 <nvicDisableVector+0x30>)
 8007386:	9a01      	ldr	r2, [sp, #4]
 8007388:	0952      	lsrs	r2, r2, #5
 800738a:	9901      	ldr	r1, [sp, #4]
 800738c:	f001 011f 	and.w	r1, r1, #31
 8007390:	2001      	movs	r0, #1
 8007392:	fa00 f101 	lsl.w	r1, r0, r1
 8007396:	3220      	adds	r2, #32
 8007398:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 800739c:	4a04      	ldr	r2, [pc, #16]	; (80073b0 <nvicDisableVector+0x30>)
 800739e:	9b01      	ldr	r3, [sp, #4]
 80073a0:	4413      	add	r3, r2
 80073a2:	f503 7340 	add.w	r3, r3, #768	; 0x300
 80073a6:	2200      	movs	r2, #0
 80073a8:	701a      	strb	r2, [r3, #0]
#endif
}
 80073aa:	b002      	add	sp, #8
 80073ac:	4770      	bx	lr
 80073ae:	bf00      	nop
 80073b0:	e000e100 	.word	0xe000e100
 80073b4:	f3af 8000 	nop.w
 80073b8:	f3af 8000 	nop.w
 80073bc:	f3af 8000 	nop.w

080073c0 <nvicSetSystemHandlerPriority>:
 * @brief   Changes the priority of a system handler.
 *
 * @param[in] handler   the system handler number
 * @param[in] prio      the system handler priority
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
 80073c0:	b082      	sub	sp, #8
 80073c2:	9001      	str	r0, [sp, #4]
 80073c4:	9100      	str	r1, [sp, #0]
  SCB->SHP[_SHP_IDX(handler)] = (SCB->SHP[_SHP_IDX(handler)] & ~(0xFFU << _BIT_SHIFT(handler))) |
                                (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(handler));
#elif defined(__CORE_CM7_H_GENERIC)
  SCB->SHPR[handler] = NVIC_PRIORITY_MASK(prio);
#else
  SCB->SHP[handler] = NVIC_PRIORITY_MASK(prio);
 80073c6:	4905      	ldr	r1, [pc, #20]	; (80073dc <nvicSetSystemHandlerPriority+0x1c>)
 80073c8:	9b00      	ldr	r3, [sp, #0]
 80073ca:	b2db      	uxtb	r3, r3
 80073cc:	011b      	lsls	r3, r3, #4
 80073ce:	b2da      	uxtb	r2, r3
 80073d0:	9b01      	ldr	r3, [sp, #4]
 80073d2:	440b      	add	r3, r1
 80073d4:	3318      	adds	r3, #24
 80073d6:	701a      	strb	r2, [r3, #0]
#endif
}
 80073d8:	b002      	add	sp, #8
 80073da:	4770      	bx	lr
 80073dc:	e000ed00 	.word	0xe000ed00

080073e0 <nvicClearPending>:
/**
 * @brief   Clears a pending interrupt source.
 *
 * @param[in] n         the interrupt number
 */
void nvicClearPending(uint32_t n) {
 80073e0:	b082      	sub	sp, #8
 80073e2:	9001      	str	r0, [sp, #4]

  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 80073e4:	4b06      	ldr	r3, [pc, #24]	; (8007400 <nvicClearPending+0x20>)
 80073e6:	9a01      	ldr	r2, [sp, #4]
 80073e8:	0952      	lsrs	r2, r2, #5
 80073ea:	9901      	ldr	r1, [sp, #4]
 80073ec:	f001 011f 	and.w	r1, r1, #31
 80073f0:	2001      	movs	r0, #1
 80073f2:	fa00 f101 	lsl.w	r1, r0, r1
 80073f6:	3260      	adds	r2, #96	; 0x60
 80073f8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 80073fc:	b002      	add	sp, #8
 80073fe:	4770      	bx	lr
 8007400:	e000e100 	.word	0xe000e100
 8007404:	f3af 8000 	nop.w
 8007408:	f3af 8000 	nop.w
 800740c:	f3af 8000 	nop.w

08007410 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8007410:	4b22      	ldr	r3, [pc, #136]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 8007412:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8007416:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800741a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800741e:	d008      	beq.n	8007432 <hal_lld_backup_domain_init+0x22>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8007420:	4b1e      	ldr	r3, [pc, #120]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 8007422:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8007426:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    RCC->BDCR = 0;
 800742a:	4b1c      	ldr	r3, [pc, #112]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 800742c:	2200      	movs	r2, #0
 800742e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#if defined(STM32_LSE_BYPASS)
  /* LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON | RCC_BDCR_LSEBYP;
#else
  /* No LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON;
 8007432:	4b1a      	ldr	r3, [pc, #104]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 8007434:	4a19      	ldr	r2, [pc, #100]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 8007436:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 800743a:	f042 0219 	orr.w	r2, r2, #25
 800743e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#endif
  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
 8007442:	bf00      	nop
 8007444:	4b15      	ldr	r3, [pc, #84]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 8007446:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800744a:	f003 0302 	and.w	r3, r3, #2
 800744e:	2b00      	cmp	r3, #0
 8007450:	d0f8      	beq.n	8007444 <hal_lld_backup_domain_init+0x34>
#endif

#if STM32_MSIPLL_ENABLED
  /* MSI PLL activation depends on LSE. Reactivating and checking for
     MSI stability.*/
  RCC->CR |= RCC_CR_MSIPLLEN;
 8007452:	4b12      	ldr	r3, [pc, #72]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 8007454:	4a11      	ldr	r2, [pc, #68]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 8007456:	6812      	ldr	r2, [r2, #0]
 8007458:	f042 0204 	orr.w	r2, r2, #4
 800745c:	601a      	str	r2, [r3, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0)
 800745e:	bf00      	nop
 8007460:	4b0e      	ldr	r3, [pc, #56]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 8007462:	681b      	ldr	r3, [r3, #0]
 8007464:	f003 0302 	and.w	r3, r3, #2
 8007468:	2b00      	cmp	r3, #0
 800746a:	d0f9      	beq.n	8007460 <hal_lld_backup_domain_init+0x50>
#endif

#if HAL_USE_RTC
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 800746c:	4b0b      	ldr	r3, [pc, #44]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 800746e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8007472:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8007476:	2b00      	cmp	r3, #0
 8007478:	d10f      	bne.n	800749a <hal_lld_backup_domain_init+0x8a>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 800747a:	4b08      	ldr	r3, [pc, #32]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 800747c:	4a07      	ldr	r2, [pc, #28]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 800747e:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 8007482:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8007486:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 800748a:	4b04      	ldr	r3, [pc, #16]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 800748c:	4a03      	ldr	r2, [pc, #12]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 800748e:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 8007492:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8007496:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  }
#endif /* HAL_USE_RTC */
}
 800749a:	4770      	bx	lr
 800749c:	40021000 	.word	0x40021000

080074a0 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 80074a0:	b508      	push	{r3, lr}

  /* Reset of all peripherals.*/
  rccResetAHB1(~0);
 80074a2:	4b28      	ldr	r3, [pc, #160]	; (8007544 <hal_lld_init+0xa4>)
 80074a4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80074a6:	4b27      	ldr	r3, [pc, #156]	; (8007544 <hal_lld_init+0xa4>)
 80074a8:	f04f 32ff 	mov.w	r2, #4294967295
 80074ac:	629a      	str	r2, [r3, #40]	; 0x28
 80074ae:	4b25      	ldr	r3, [pc, #148]	; (8007544 <hal_lld_init+0xa4>)
 80074b0:	2200      	movs	r2, #0
 80074b2:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAHB2(~0);
 80074b4:	4b23      	ldr	r3, [pc, #140]	; (8007544 <hal_lld_init+0xa4>)
 80074b6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80074b8:	4b22      	ldr	r3, [pc, #136]	; (8007544 <hal_lld_init+0xa4>)
 80074ba:	f04f 32ff 	mov.w	r2, #4294967295
 80074be:	62da      	str	r2, [r3, #44]	; 0x2c
 80074c0:	4b20      	ldr	r3, [pc, #128]	; (8007544 <hal_lld_init+0xa4>)
 80074c2:	2200      	movs	r2, #0
 80074c4:	62da      	str	r2, [r3, #44]	; 0x2c
  rccResetAHB3(~0);
 80074c6:	4b1f      	ldr	r3, [pc, #124]	; (8007544 <hal_lld_init+0xa4>)
 80074c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80074ca:	4b1e      	ldr	r3, [pc, #120]	; (8007544 <hal_lld_init+0xa4>)
 80074cc:	f04f 32ff 	mov.w	r2, #4294967295
 80074d0:	631a      	str	r2, [r3, #48]	; 0x30
 80074d2:	4b1c      	ldr	r3, [pc, #112]	; (8007544 <hal_lld_init+0xa4>)
 80074d4:	2200      	movs	r2, #0
 80074d6:	631a      	str	r2, [r3, #48]	; 0x30
  rccResetAPB1R1(~RCC_APB1RSTR1_PWRRST);
 80074d8:	4b1a      	ldr	r3, [pc, #104]	; (8007544 <hal_lld_init+0xa4>)
 80074da:	4a1a      	ldr	r2, [pc, #104]	; (8007544 <hal_lld_init+0xa4>)
 80074dc:	6b92      	ldr	r2, [r2, #56]	; 0x38
 80074de:	f062 5280 	orn	r2, r2, #268435456	; 0x10000000
 80074e2:	639a      	str	r2, [r3, #56]	; 0x38
 80074e4:	4b17      	ldr	r3, [pc, #92]	; (8007544 <hal_lld_init+0xa4>)
 80074e6:	2200      	movs	r2, #0
 80074e8:	639a      	str	r2, [r3, #56]	; 0x38
  rccResetAPB1R2(~0);
 80074ea:	4b16      	ldr	r3, [pc, #88]	; (8007544 <hal_lld_init+0xa4>)
 80074ec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80074ee:	4b15      	ldr	r3, [pc, #84]	; (8007544 <hal_lld_init+0xa4>)
 80074f0:	f04f 32ff 	mov.w	r2, #4294967295
 80074f4:	63da      	str	r2, [r3, #60]	; 0x3c
 80074f6:	4b13      	ldr	r3, [pc, #76]	; (8007544 <hal_lld_init+0xa4>)
 80074f8:	2200      	movs	r2, #0
 80074fa:	63da      	str	r2, [r3, #60]	; 0x3c
  rccResetAPB2(~0);
 80074fc:	4b11      	ldr	r3, [pc, #68]	; (8007544 <hal_lld_init+0xa4>)
 80074fe:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8007500:	4b10      	ldr	r3, [pc, #64]	; (8007544 <hal_lld_init+0xa4>)
 8007502:	f04f 32ff 	mov.w	r2, #4294967295
 8007506:	641a      	str	r2, [r3, #64]	; 0x40
 8007508:	4b0e      	ldr	r3, [pc, #56]	; (8007544 <hal_lld_init+0xa4>)
 800750a:	2200      	movs	r2, #0
 800750c:	641a      	str	r2, [r3, #64]	; 0x40

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 800750e:	4b0d      	ldr	r3, [pc, #52]	; (8007544 <hal_lld_init+0xa4>)
 8007510:	4a0c      	ldr	r2, [pc, #48]	; (8007544 <hal_lld_init+0xa4>)
 8007512:	6d92      	ldr	r2, [r2, #88]	; 0x58
 8007514:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8007518:	659a      	str	r2, [r3, #88]	; 0x58

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 800751a:	f7ff ff79 	bl	8007410 <hal_lld_backup_domain_init>

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 800751e:	f000 fbf7 	bl	8007d10 <dmaInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR2 = PWR_CR2_PVDE | (STM32_PLS & STM32_PLS_MASK);
#else
  PWR->CR2 = 0;
 8007522:	4b09      	ldr	r3, [pc, #36]	; (8007548 <hal_lld_init+0xa8>)
 8007524:	2200      	movs	r2, #0
 8007526:	605a      	str	r2, [r3, #4]
#endif /* STM32_PVD_ENABLE */

  /* Enabling independent VDDUSB.*/
#if HAL_USE_USB
  PWR->CR2 |= PWR_CR2_USV;
 8007528:	4b07      	ldr	r3, [pc, #28]	; (8007548 <hal_lld_init+0xa8>)
 800752a:	4a07      	ldr	r2, [pc, #28]	; (8007548 <hal_lld_init+0xa8>)
 800752c:	6852      	ldr	r2, [r2, #4]
 800752e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8007532:	605a      	str	r2, [r3, #4]
#endif /* HAL_USE_USB */

  /* Enabling independent VDDIO2 required by GPIOG.*/
#if STM32_HAS_GPIOG
  PWR->CR2 |= PWR_CR2_IOSV;
 8007534:	4b04      	ldr	r3, [pc, #16]	; (8007548 <hal_lld_init+0xa8>)
 8007536:	4a04      	ldr	r2, [pc, #16]	; (8007548 <hal_lld_init+0xa8>)
 8007538:	6852      	ldr	r2, [r2, #4]
 800753a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800753e:	605a      	str	r2, [r3, #4]
#endif /* STM32_HAS_GPIOG */
}
 8007540:	bd08      	pop	{r3, pc}
 8007542:	bf00      	nop
 8007544:	40021000 	.word	0x40021000
 8007548:	40007000 	.word	0x40007000
 800754c:	f3af 8000 	nop.w

08007550 <stm32_clock_init>:
 * @note    All the involved constants come from the file @p board.h.
 * @note    This function should be invoked just after the system reset.
 *
 * @special
 */
void stm32_clock_init(void) {
 8007550:	b082      	sub	sp, #8

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR1 |= RCC_APB1ENR1_PWREN;
 8007552:	4b5e      	ldr	r3, [pc, #376]	; (80076cc <stm32_clock_init+0x17c>)
 8007554:	4a5d      	ldr	r2, [pc, #372]	; (80076cc <stm32_clock_init+0x17c>)
 8007556:	6d92      	ldr	r2, [r2, #88]	; 0x58
 8007558:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800755c:	659a      	str	r2, [r3, #88]	; 0x58
  /* Initial clocks setup and wait for MSI stabilization, the MSI clock is
     always enabled because it is the fall back clock when PLL the fails.
     Trim fields are not altered from reset values.*/

  /* MSIRANGE can be set only when MSI is OFF or READY.*/
  RCC->CR = RCC_CR_MSION;
 800755e:	4b5b      	ldr	r3, [pc, #364]	; (80076cc <stm32_clock_init+0x17c>)
 8007560:	2201      	movs	r2, #1
 8007562:	601a      	str	r2, [r3, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0)
 8007564:	bf00      	nop
 8007566:	4b59      	ldr	r3, [pc, #356]	; (80076cc <stm32_clock_init+0x17c>)
 8007568:	681b      	ldr	r3, [r3, #0]
 800756a:	f003 0302 	and.w	r3, r3, #2
 800756e:	2b00      	cmp	r3, #0
 8007570:	d0f9      	beq.n	8007566 <stm32_clock_init+0x16>
    ;                                       /* Wait until MSI is stable.    */

  /* Clocking from MSI, in case MSI was not the default source.*/
  RCC->CFGR = 0;
 8007572:	4b56      	ldr	r3, [pc, #344]	; (80076cc <stm32_clock_init+0x17c>)
 8007574:	2200      	movs	r2, #0
 8007576:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI)
 8007578:	bf00      	nop
 800757a:	4b54      	ldr	r3, [pc, #336]	; (80076cc <stm32_clock_init+0x17c>)
 800757c:	689b      	ldr	r3, [r3, #8]
 800757e:	f003 030c 	and.w	r3, r3, #12
 8007582:	2b00      	cmp	r3, #0
 8007584:	d1f9      	bne.n	800757a <stm32_clock_init+0x2a>
    ;                                       /* Wait until MSI is selected.  */

  /* Core voltage setup.*/
  PWR->CR1 = STM32_VOS;
 8007586:	4b52      	ldr	r3, [pc, #328]	; (80076d0 <stm32_clock_init+0x180>)
 8007588:	f44f 7200 	mov.w	r2, #512	; 0x200
 800758c:	601a      	str	r2, [r3, #0]
  while ((PWR->SR2 & PWR_SR2_VOSF) != 0)    /* Wait until regulator is      */
 800758e:	bf00      	nop
 8007590:	4b4f      	ldr	r3, [pc, #316]	; (80076d0 <stm32_clock_init+0x180>)
 8007592:	695b      	ldr	r3, [r3, #20]
 8007594:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8007598:	2b00      	cmp	r3, #0
 800759a:	d1f9      	bne.n	8007590 <stm32_clock_init+0x40>
    ;                                       /* Wait until HSE is stable.    */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 800759c:	4b4b      	ldr	r3, [pc, #300]	; (80076cc <stm32_clock_init+0x17c>)
 800759e:	4a4b      	ldr	r2, [pc, #300]	; (80076cc <stm32_clock_init+0x17c>)
 80075a0:	f8d2 2094 	ldr.w	r2, [r2, #148]	; 0x94
 80075a4:	f042 0201 	orr.w	r2, r2, #1
 80075a8:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 80075ac:	bf00      	nop
 80075ae:	4b47      	ldr	r3, [pc, #284]	; (80076cc <stm32_clock_init+0x17c>)
 80075b0:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80075b4:	f003 0302 	and.w	r3, r3, #2
 80075b8:	2b00      	cmp	r3, #0
 80075ba:	d0f8      	beq.n	80075ae <stm32_clock_init+0x5e>
    ;                                       /* Wait until LSI is stable.    */
#endif

  /* Backup domain access enabled and left open.*/
  PWR->CR1 |= PWR_CR1_DBP;
 80075bc:	4b44      	ldr	r3, [pc, #272]	; (80076d0 <stm32_clock_init+0x180>)
 80075be:	4a44      	ldr	r2, [pc, #272]	; (80076d0 <stm32_clock_init+0x180>)
 80075c0:	6812      	ldr	r2, [r2, #0]
 80075c2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80075c6:	601a      	str	r2, [r3, #0]
#if defined(STM32_LSE_BYPASS)
  /* LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON | RCC_BDCR_LSEBYP;
#else
  /* No LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON;
 80075c8:	4b40      	ldr	r3, [pc, #256]	; (80076cc <stm32_clock_init+0x17c>)
 80075ca:	4a40      	ldr	r2, [pc, #256]	; (80076cc <stm32_clock_init+0x17c>)
 80075cc:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 80075d0:	f042 0219 	orr.w	r2, r2, #25
 80075d4:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#endif
  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
 80075d8:	bf00      	nop
 80075da:	4b3c      	ldr	r3, [pc, #240]	; (80076cc <stm32_clock_init+0x17c>)
 80075dc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80075e0:	f003 0302 	and.w	r3, r3, #2
 80075e4:	2b00      	cmp	r3, #0
 80075e6:	d0f8      	beq.n	80075da <stm32_clock_init+0x8a>
    ;                                       /* Wait until LSE is stable.    */
#endif

  /* Flash setup for selected MSI speed setting.*/
  FLASH->ACR = FLASH_ACR_DCEN | FLASH_ACR_ICEN | FLASH_ACR_PRFTEN |
 80075e8:	4b3a      	ldr	r3, [pc, #232]	; (80076d4 <stm32_clock_init+0x184>)
 80075ea:	f44f 62e0 	mov.w	r2, #1792	; 0x700
 80075ee:	601a      	str	r2, [r3, #0]
               STM32_MSI_FLASHBITS;

  /* Changing MSIRANGE to configured value.*/
  RCC->CR |= STM32_MSIRANGE;
 80075f0:	4b36      	ldr	r3, [pc, #216]	; (80076cc <stm32_clock_init+0x17c>)
 80075f2:	4a36      	ldr	r2, [pc, #216]	; (80076cc <stm32_clock_init+0x17c>)
 80075f4:	6812      	ldr	r2, [r2, #0]
 80075f6:	f042 0260 	orr.w	r2, r2, #96	; 0x60
 80075fa:	601a      	str	r2, [r3, #0]

  /* Switching from MSISRANGE to MSIRANGE.*/
  RCC->CR |= RCC_CR_MSIRGSEL;
 80075fc:	4b33      	ldr	r3, [pc, #204]	; (80076cc <stm32_clock_init+0x17c>)
 80075fe:	4a33      	ldr	r2, [pc, #204]	; (80076cc <stm32_clock_init+0x17c>)
 8007600:	6812      	ldr	r2, [r2, #0]
 8007602:	f042 0208 	orr.w	r2, r2, #8
 8007606:	601a      	str	r2, [r3, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0)
 8007608:	bf00      	nop
 800760a:	4b30      	ldr	r3, [pc, #192]	; (80076cc <stm32_clock_init+0x17c>)
 800760c:	681b      	ldr	r3, [r3, #0]
 800760e:	f003 0302 	and.w	r3, r3, #2
 8007612:	2b00      	cmp	r3, #0
 8007614:	d0f9      	beq.n	800760a <stm32_clock_init+0xba>
    ;

  /* MSI is configured SYSCLK source so wait for it to be stable as well.*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI)
 8007616:	bf00      	nop
 8007618:	4b2c      	ldr	r3, [pc, #176]	; (80076cc <stm32_clock_init+0x17c>)
 800761a:	689b      	ldr	r3, [r3, #8]
 800761c:	f003 030c 	and.w	r3, r3, #12
 8007620:	2b00      	cmp	r3, #0
 8007622:	d1f9      	bne.n	8007618 <stm32_clock_init+0xc8>
    ;

#if STM32_MSIPLL_ENABLED
  /* MSI PLL (to LSE) activation */
  RCC->CR |= RCC_CR_MSIPLLEN;
 8007624:	4b29      	ldr	r3, [pc, #164]	; (80076cc <stm32_clock_init+0x17c>)
 8007626:	4a29      	ldr	r2, [pc, #164]	; (80076cc <stm32_clock_init+0x17c>)
 8007628:	6812      	ldr	r2, [r2, #0]
 800762a:	f042 0204 	orr.w	r2, r2, #4
 800762e:	601a      	str	r2, [r3, #0]
#endif

  /* Updating MSISRANGE value. MSISRANGE can be set only when MSIRGSEL is high.
     This range is used exiting the Standby mode until MSIRGSEL is set.*/
  RCC->CSR |= STM32_MSISRANGE;
 8007630:	4b26      	ldr	r3, [pc, #152]	; (80076cc <stm32_clock_init+0x17c>)
 8007632:	4a26      	ldr	r2, [pc, #152]	; (80076cc <stm32_clock_init+0x17c>)
 8007634:	f8d2 2094 	ldr.w	r2, [r2, #148]	; 0x94
 8007638:	f442 62c0 	orr.w	r2, r2, #1536	; 0x600
 800763c:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

#if STM32_ACTIVATE_PLL || STM32_ACTIVATE_PLLSAI1 || STM32_ACTIVATE_PLLSAI2
  /* PLLM and PLLSRC are common to all PLLs.*/
  RCC->PLLCFGR = STM32_PLLR   | STM32_PLLREN |
 8007640:	4b22      	ldr	r3, [pc, #136]	; (80076cc <stm32_clock_init+0x17c>)
 8007642:	4a25      	ldr	r2, [pc, #148]	; (80076d8 <stm32_clock_init+0x188>)
 8007644:	60da      	str	r2, [r3, #12]
                 STM32_PLLSRC;
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR |= RCC_CR_PLLON;
 8007646:	4b21      	ldr	r3, [pc, #132]	; (80076cc <stm32_clock_init+0x17c>)
 8007648:	4a20      	ldr	r2, [pc, #128]	; (80076cc <stm32_clock_init+0x17c>)
 800764a:	6812      	ldr	r2, [r2, #0]
 800764c:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8007650:	601a      	str	r2, [r3, #0]

  /* Waiting for PLL lock.*/
  while ((RCC->CR & RCC_CR_PLLRDY) == 0)
 8007652:	bf00      	nop
 8007654:	4b1d      	ldr	r3, [pc, #116]	; (80076cc <stm32_clock_init+0x17c>)
 8007656:	681b      	ldr	r3, [r3, #0]
 8007658:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800765c:	2b00      	cmp	r3, #0
 800765e:	d0f9      	beq.n	8007654 <stm32_clock_init+0x104>
    ;
#endif

#if STM32_ACTIVATE_PLLSAI1
  /* PLLSAI1 activation.*/
  RCC->PLLSAI1CFGR = STM32_PLLSAI1R | STM32_PLLSAI1REN |
 8007660:	4b1a      	ldr	r3, [pc, #104]	; (80076cc <stm32_clock_init+0x17c>)
 8007662:	4a1e      	ldr	r2, [pc, #120]	; (80076dc <stm32_clock_init+0x18c>)
 8007664:	611a      	str	r2, [r3, #16]
                     STM32_PLLSAI1Q | STM32_PLLSAI1QEN |
                     STM32_PLLSAI1P | STM32_PLLSAI1PEN |
                     STM32_PLLSAI1N;
  RCC->CR |= RCC_CR_PLLSAI1ON;
 8007666:	4b19      	ldr	r3, [pc, #100]	; (80076cc <stm32_clock_init+0x17c>)
 8007668:	4a18      	ldr	r2, [pc, #96]	; (80076cc <stm32_clock_init+0x17c>)
 800766a:	6812      	ldr	r2, [r2, #0]
 800766c:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8007670:	601a      	str	r2, [r3, #0]

  /* Waiting for PLL lock.*/
  while ((RCC->CR & RCC_CR_PLLSAI1RDY) == 0)
 8007672:	bf00      	nop
 8007674:	4b15      	ldr	r3, [pc, #84]	; (80076cc <stm32_clock_init+0x17c>)
 8007676:	681b      	ldr	r3, [r3, #0]
 8007678:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 800767c:	2b00      	cmp	r3, #0
 800767e:	d0f9      	beq.n	8007674 <stm32_clock_init+0x124>
  while ((RCC->CR & RCC_CR_PLLSAI2RDY) == 0)
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCOPRE | STM32_MCOSEL | STM32_STOPWUCK |
 8007680:	4b12      	ldr	r3, [pc, #72]	; (80076cc <stm32_clock_init+0x17c>)
 8007682:	2200      	movs	r2, #0
 8007684:	609a      	str	r2, [r3, #8]
              STM32_PPRE2  | STM32_PPRE1  | STM32_HPRE;

  /* CCIPR register initialization, note, must take care of the _OFF
     pseudo settings.*/
  {
    uint32_t ccipr = STM32_DFSDMSEL  | STM32_SWPMI1SEL | STM32_ADCSEL    |
 8007686:	4b16      	ldr	r3, [pc, #88]	; (80076e0 <stm32_clock_init+0x190>)
 8007688:	9301      	str	r3, [sp, #4]
    ccipr |= STM32_SAI2SEL;
#endif
#if STM32_SAI1SEL != STM32_SAI1SEL_OFF
    ccipr |= STM32_SAI1SEL;
#endif
    RCC->CCIPR = ccipr;
 800768a:	4b10      	ldr	r3, [pc, #64]	; (80076cc <stm32_clock_init+0x17c>)
 800768c:	9a01      	ldr	r2, [sp, #4]
 800768e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  }

  /* Set flash WS's for SYSCLK source */
  if (STM32_FLASHBITS > STM32_MSI_FLASHBITS)
    FLASH->ACR = (FLASH->ACR & ~FLASH_ACR_LATENCY_Msk) | STM32_FLASHBITS;
 8007692:	4b10      	ldr	r3, [pc, #64]	; (80076d4 <stm32_clock_init+0x184>)
 8007694:	4a0f      	ldr	r2, [pc, #60]	; (80076d4 <stm32_clock_init+0x184>)
 8007696:	6812      	ldr	r2, [r2, #0]
 8007698:	f022 0207 	bic.w	r2, r2, #7
 800769c:	f042 0204 	orr.w	r2, r2, #4
 80076a0:	601a      	str	r2, [r3, #0]

  /* Switching to the configured SYSCLK source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_MSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 80076a2:	4b0a      	ldr	r3, [pc, #40]	; (80076cc <stm32_clock_init+0x17c>)
 80076a4:	4a09      	ldr	r2, [pc, #36]	; (80076cc <stm32_clock_init+0x17c>)
 80076a6:	6892      	ldr	r2, [r2, #8]
 80076a8:	f042 0203 	orr.w	r2, r2, #3
 80076ac:	609a      	str	r2, [r3, #8]
  /* Wait until SYSCLK is stable.*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80076ae:	bf00      	nop
 80076b0:	4b06      	ldr	r3, [pc, #24]	; (80076cc <stm32_clock_init+0x17c>)
 80076b2:	689b      	ldr	r3, [r3, #8]
 80076b4:	f003 030c 	and.w	r3, r3, #12
 80076b8:	2b0c      	cmp	r3, #12
 80076ba:	d1f9      	bne.n	80076b0 <stm32_clock_init+0x160>

#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 80076bc:	4b03      	ldr	r3, [pc, #12]	; (80076cc <stm32_clock_init+0x17c>)
 80076be:	4a03      	ldr	r2, [pc, #12]	; (80076cc <stm32_clock_init+0x17c>)
 80076c0:	6e12      	ldr	r2, [r2, #96]	; 0x60
 80076c2:	f042 0201 	orr.w	r2, r2, #1
 80076c6:	661a      	str	r2, [r3, #96]	; 0x60
}
 80076c8:	b002      	add	sp, #8
 80076ca:	4770      	bx	lr
 80076cc:	40021000 	.word	0x40021000
 80076d0:	40007000 	.word	0x40007000
 80076d4:	40022000 	.word	0x40022000
 80076d8:	03405001 	.word	0x03405001
 80076dc:	04504800 	.word	0x04504800
 80076e0:	34015555 	.word	0x34015555
 80076e4:	f3af 8000 	nop.w
 80076e8:	f3af 8000 	nop.w
 80076ec:	f3af 8000 	nop.w

080076f0 <Vector6C>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 80076f0:	b500      	push	{lr}
 80076f2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 80076f4:	2300      	movs	r3, #0
 80076f6:	9301      	str	r3, [sp, #4]
 80076f8:	4b14      	ldr	r3, [pc, #80]	; (800774c <Vector6C+0x5c>)
 80076fa:	681a      	ldr	r2, [r3, #0]
 80076fc:	2300      	movs	r3, #0
 80076fe:	fa22 f303 	lsr.w	r3, r2, r3
 8007702:	f003 030f 	and.w	r3, r3, #15
 8007706:	9300      	str	r3, [sp, #0]
 8007708:	9b00      	ldr	r3, [sp, #0]
 800770a:	f003 030f 	and.w	r3, r3, #15
 800770e:	2b00      	cmp	r3, #0
 8007710:	d017      	beq.n	8007742 <Vector6C+0x52>
 8007712:	4b0e      	ldr	r3, [pc, #56]	; (800774c <Vector6C+0x5c>)
 8007714:	2200      	movs	r2, #0
 8007716:	9900      	ldr	r1, [sp, #0]
 8007718:	fa01 f202 	lsl.w	r2, r1, r2
 800771c:	605a      	str	r2, [r3, #4]
 800771e:	4b0c      	ldr	r3, [pc, #48]	; (8007750 <Vector6C+0x60>)
 8007720:	9a01      	ldr	r2, [sp, #4]
 8007722:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007726:	2b00      	cmp	r3, #0
 8007728:	d00b      	beq.n	8007742 <Vector6C+0x52>
 800772a:	4b09      	ldr	r3, [pc, #36]	; (8007750 <Vector6C+0x60>)
 800772c:	9a01      	ldr	r2, [sp, #4]
 800772e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007732:	4907      	ldr	r1, [pc, #28]	; (8007750 <Vector6C+0x60>)
 8007734:	9b01      	ldr	r3, [sp, #4]
 8007736:	00db      	lsls	r3, r3, #3
 8007738:	440b      	add	r3, r1
 800773a:	685b      	ldr	r3, [r3, #4]
 800773c:	4618      	mov	r0, r3
 800773e:	9900      	ldr	r1, [sp, #0]
 8007740:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007742:	f7fc fa05 	bl	8003b50 <_port_irq_epilogue>
}
 8007746:	b003      	add	sp, #12
 8007748:	f85d fb04 	ldr.w	pc, [sp], #4
 800774c:	40020000 	.word	0x40020000
 8007750:	20001830 	.word	0x20001830
 8007754:	f3af 8000 	nop.w
 8007758:	f3af 8000 	nop.w
 800775c:	f3af 8000 	nop.w

08007760 <Vector70>:
/**
 * @brief   DMA1 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8007760:	b500      	push	{lr}
 8007762:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 8007764:	2301      	movs	r3, #1
 8007766:	9301      	str	r3, [sp, #4]
 8007768:	4b14      	ldr	r3, [pc, #80]	; (80077bc <Vector70+0x5c>)
 800776a:	681a      	ldr	r2, [r3, #0]
 800776c:	2304      	movs	r3, #4
 800776e:	fa22 f303 	lsr.w	r3, r2, r3
 8007772:	f003 030f 	and.w	r3, r3, #15
 8007776:	9300      	str	r3, [sp, #0]
 8007778:	9b00      	ldr	r3, [sp, #0]
 800777a:	f003 030f 	and.w	r3, r3, #15
 800777e:	2b00      	cmp	r3, #0
 8007780:	d017      	beq.n	80077b2 <Vector70+0x52>
 8007782:	4b0e      	ldr	r3, [pc, #56]	; (80077bc <Vector70+0x5c>)
 8007784:	2204      	movs	r2, #4
 8007786:	9900      	ldr	r1, [sp, #0]
 8007788:	fa01 f202 	lsl.w	r2, r1, r2
 800778c:	605a      	str	r2, [r3, #4]
 800778e:	4b0c      	ldr	r3, [pc, #48]	; (80077c0 <Vector70+0x60>)
 8007790:	9a01      	ldr	r2, [sp, #4]
 8007792:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007796:	2b00      	cmp	r3, #0
 8007798:	d00b      	beq.n	80077b2 <Vector70+0x52>
 800779a:	4b09      	ldr	r3, [pc, #36]	; (80077c0 <Vector70+0x60>)
 800779c:	9a01      	ldr	r2, [sp, #4]
 800779e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 80077a2:	4907      	ldr	r1, [pc, #28]	; (80077c0 <Vector70+0x60>)
 80077a4:	9b01      	ldr	r3, [sp, #4]
 80077a6:	00db      	lsls	r3, r3, #3
 80077a8:	440b      	add	r3, r1
 80077aa:	685b      	ldr	r3, [r3, #4]
 80077ac:	4618      	mov	r0, r3
 80077ae:	9900      	ldr	r1, [sp, #0]
 80077b0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80077b2:	f7fc f9cd 	bl	8003b50 <_port_irq_epilogue>
}
 80077b6:	b003      	add	sp, #12
 80077b8:	f85d fb04 	ldr.w	pc, [sp], #4
 80077bc:	40020000 	.word	0x40020000
 80077c0:	20001830 	.word	0x20001830
 80077c4:	f3af 8000 	nop.w
 80077c8:	f3af 8000 	nop.w
 80077cc:	f3af 8000 	nop.w

080077d0 <Vector74>:
/**
 * @brief   DMA1 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 80077d0:	b500      	push	{lr}
 80077d2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 80077d4:	2302      	movs	r3, #2
 80077d6:	9301      	str	r3, [sp, #4]
 80077d8:	4b14      	ldr	r3, [pc, #80]	; (800782c <Vector74+0x5c>)
 80077da:	681a      	ldr	r2, [r3, #0]
 80077dc:	2308      	movs	r3, #8
 80077de:	fa22 f303 	lsr.w	r3, r2, r3
 80077e2:	f003 030f 	and.w	r3, r3, #15
 80077e6:	9300      	str	r3, [sp, #0]
 80077e8:	9b00      	ldr	r3, [sp, #0]
 80077ea:	f003 030f 	and.w	r3, r3, #15
 80077ee:	2b00      	cmp	r3, #0
 80077f0:	d017      	beq.n	8007822 <Vector74+0x52>
 80077f2:	4b0e      	ldr	r3, [pc, #56]	; (800782c <Vector74+0x5c>)
 80077f4:	2208      	movs	r2, #8
 80077f6:	9900      	ldr	r1, [sp, #0]
 80077f8:	fa01 f202 	lsl.w	r2, r1, r2
 80077fc:	605a      	str	r2, [r3, #4]
 80077fe:	4b0c      	ldr	r3, [pc, #48]	; (8007830 <Vector74+0x60>)
 8007800:	9a01      	ldr	r2, [sp, #4]
 8007802:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007806:	2b00      	cmp	r3, #0
 8007808:	d00b      	beq.n	8007822 <Vector74+0x52>
 800780a:	4b09      	ldr	r3, [pc, #36]	; (8007830 <Vector74+0x60>)
 800780c:	9a01      	ldr	r2, [sp, #4]
 800780e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007812:	4907      	ldr	r1, [pc, #28]	; (8007830 <Vector74+0x60>)
 8007814:	9b01      	ldr	r3, [sp, #4]
 8007816:	00db      	lsls	r3, r3, #3
 8007818:	440b      	add	r3, r1
 800781a:	685b      	ldr	r3, [r3, #4]
 800781c:	4618      	mov	r0, r3
 800781e:	9900      	ldr	r1, [sp, #0]
 8007820:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007822:	f7fc f995 	bl	8003b50 <_port_irq_epilogue>
}
 8007826:	b003      	add	sp, #12
 8007828:	f85d fb04 	ldr.w	pc, [sp], #4
 800782c:	40020000 	.word	0x40020000
 8007830:	20001830 	.word	0x20001830
 8007834:	f3af 8000 	nop.w
 8007838:	f3af 8000 	nop.w
 800783c:	f3af 8000 	nop.w

08007840 <Vector78>:
/**
 * @brief   DMA1 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8007840:	b500      	push	{lr}
 8007842:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 8007844:	2303      	movs	r3, #3
 8007846:	9301      	str	r3, [sp, #4]
 8007848:	4b14      	ldr	r3, [pc, #80]	; (800789c <Vector78+0x5c>)
 800784a:	681a      	ldr	r2, [r3, #0]
 800784c:	230c      	movs	r3, #12
 800784e:	fa22 f303 	lsr.w	r3, r2, r3
 8007852:	f003 030f 	and.w	r3, r3, #15
 8007856:	9300      	str	r3, [sp, #0]
 8007858:	9b00      	ldr	r3, [sp, #0]
 800785a:	f003 030f 	and.w	r3, r3, #15
 800785e:	2b00      	cmp	r3, #0
 8007860:	d017      	beq.n	8007892 <Vector78+0x52>
 8007862:	4b0e      	ldr	r3, [pc, #56]	; (800789c <Vector78+0x5c>)
 8007864:	220c      	movs	r2, #12
 8007866:	9900      	ldr	r1, [sp, #0]
 8007868:	fa01 f202 	lsl.w	r2, r1, r2
 800786c:	605a      	str	r2, [r3, #4]
 800786e:	4b0c      	ldr	r3, [pc, #48]	; (80078a0 <Vector78+0x60>)
 8007870:	9a01      	ldr	r2, [sp, #4]
 8007872:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007876:	2b00      	cmp	r3, #0
 8007878:	d00b      	beq.n	8007892 <Vector78+0x52>
 800787a:	4b09      	ldr	r3, [pc, #36]	; (80078a0 <Vector78+0x60>)
 800787c:	9a01      	ldr	r2, [sp, #4]
 800787e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007882:	4907      	ldr	r1, [pc, #28]	; (80078a0 <Vector78+0x60>)
 8007884:	9b01      	ldr	r3, [sp, #4]
 8007886:	00db      	lsls	r3, r3, #3
 8007888:	440b      	add	r3, r1
 800788a:	685b      	ldr	r3, [r3, #4]
 800788c:	4618      	mov	r0, r3
 800788e:	9900      	ldr	r1, [sp, #0]
 8007890:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007892:	f7fc f95d 	bl	8003b50 <_port_irq_epilogue>
}
 8007896:	b003      	add	sp, #12
 8007898:	f85d fb04 	ldr.w	pc, [sp], #4
 800789c:	40020000 	.word	0x40020000
 80078a0:	20001830 	.word	0x20001830
 80078a4:	f3af 8000 	nop.w
 80078a8:	f3af 8000 	nop.w
 80078ac:	f3af 8000 	nop.w

080078b0 <Vector7C>:
/**
 * @brief   DMA1 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 80078b0:	b500      	push	{lr}
 80078b2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 80078b4:	2304      	movs	r3, #4
 80078b6:	9301      	str	r3, [sp, #4]
 80078b8:	4b14      	ldr	r3, [pc, #80]	; (800790c <Vector7C+0x5c>)
 80078ba:	681a      	ldr	r2, [r3, #0]
 80078bc:	2310      	movs	r3, #16
 80078be:	fa22 f303 	lsr.w	r3, r2, r3
 80078c2:	f003 030f 	and.w	r3, r3, #15
 80078c6:	9300      	str	r3, [sp, #0]
 80078c8:	9b00      	ldr	r3, [sp, #0]
 80078ca:	f003 030f 	and.w	r3, r3, #15
 80078ce:	2b00      	cmp	r3, #0
 80078d0:	d017      	beq.n	8007902 <Vector7C+0x52>
 80078d2:	4b0e      	ldr	r3, [pc, #56]	; (800790c <Vector7C+0x5c>)
 80078d4:	2210      	movs	r2, #16
 80078d6:	9900      	ldr	r1, [sp, #0]
 80078d8:	fa01 f202 	lsl.w	r2, r1, r2
 80078dc:	605a      	str	r2, [r3, #4]
 80078de:	4b0c      	ldr	r3, [pc, #48]	; (8007910 <Vector7C+0x60>)
 80078e0:	9a01      	ldr	r2, [sp, #4]
 80078e2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 80078e6:	2b00      	cmp	r3, #0
 80078e8:	d00b      	beq.n	8007902 <Vector7C+0x52>
 80078ea:	4b09      	ldr	r3, [pc, #36]	; (8007910 <Vector7C+0x60>)
 80078ec:	9a01      	ldr	r2, [sp, #4]
 80078ee:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 80078f2:	4907      	ldr	r1, [pc, #28]	; (8007910 <Vector7C+0x60>)
 80078f4:	9b01      	ldr	r3, [sp, #4]
 80078f6:	00db      	lsls	r3, r3, #3
 80078f8:	440b      	add	r3, r1
 80078fa:	685b      	ldr	r3, [r3, #4]
 80078fc:	4618      	mov	r0, r3
 80078fe:	9900      	ldr	r1, [sp, #0]
 8007900:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007902:	f7fc f925 	bl	8003b50 <_port_irq_epilogue>
}
 8007906:	b003      	add	sp, #12
 8007908:	f85d fb04 	ldr.w	pc, [sp], #4
 800790c:	40020000 	.word	0x40020000
 8007910:	20001830 	.word	0x20001830
 8007914:	f3af 8000 	nop.w
 8007918:	f3af 8000 	nop.w
 800791c:	f3af 8000 	nop.w

08007920 <Vector80>:
/**
 * @brief   DMA1 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8007920:	b500      	push	{lr}
 8007922:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 8007924:	2305      	movs	r3, #5
 8007926:	9301      	str	r3, [sp, #4]
 8007928:	4b14      	ldr	r3, [pc, #80]	; (800797c <Vector80+0x5c>)
 800792a:	681a      	ldr	r2, [r3, #0]
 800792c:	2314      	movs	r3, #20
 800792e:	fa22 f303 	lsr.w	r3, r2, r3
 8007932:	f003 030f 	and.w	r3, r3, #15
 8007936:	9300      	str	r3, [sp, #0]
 8007938:	9b00      	ldr	r3, [sp, #0]
 800793a:	f003 030f 	and.w	r3, r3, #15
 800793e:	2b00      	cmp	r3, #0
 8007940:	d017      	beq.n	8007972 <Vector80+0x52>
 8007942:	4b0e      	ldr	r3, [pc, #56]	; (800797c <Vector80+0x5c>)
 8007944:	2214      	movs	r2, #20
 8007946:	9900      	ldr	r1, [sp, #0]
 8007948:	fa01 f202 	lsl.w	r2, r1, r2
 800794c:	605a      	str	r2, [r3, #4]
 800794e:	4b0c      	ldr	r3, [pc, #48]	; (8007980 <Vector80+0x60>)
 8007950:	9a01      	ldr	r2, [sp, #4]
 8007952:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007956:	2b00      	cmp	r3, #0
 8007958:	d00b      	beq.n	8007972 <Vector80+0x52>
 800795a:	4b09      	ldr	r3, [pc, #36]	; (8007980 <Vector80+0x60>)
 800795c:	9a01      	ldr	r2, [sp, #4]
 800795e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007962:	4907      	ldr	r1, [pc, #28]	; (8007980 <Vector80+0x60>)
 8007964:	9b01      	ldr	r3, [sp, #4]
 8007966:	00db      	lsls	r3, r3, #3
 8007968:	440b      	add	r3, r1
 800796a:	685b      	ldr	r3, [r3, #4]
 800796c:	4618      	mov	r0, r3
 800796e:	9900      	ldr	r1, [sp, #0]
 8007970:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007972:	f7fc f8ed 	bl	8003b50 <_port_irq_epilogue>
}
 8007976:	b003      	add	sp, #12
 8007978:	f85d fb04 	ldr.w	pc, [sp], #4
 800797c:	40020000 	.word	0x40020000
 8007980:	20001830 	.word	0x20001830
 8007984:	f3af 8000 	nop.w
 8007988:	f3af 8000 	nop.w
 800798c:	f3af 8000 	nop.w

08007990 <Vector84>:
/**
 * @brief   DMA1 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8007990:	b500      	push	{lr}
 8007992:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 8007994:	2306      	movs	r3, #6
 8007996:	9301      	str	r3, [sp, #4]
 8007998:	4b14      	ldr	r3, [pc, #80]	; (80079ec <Vector84+0x5c>)
 800799a:	681a      	ldr	r2, [r3, #0]
 800799c:	2318      	movs	r3, #24
 800799e:	fa22 f303 	lsr.w	r3, r2, r3
 80079a2:	f003 030f 	and.w	r3, r3, #15
 80079a6:	9300      	str	r3, [sp, #0]
 80079a8:	9b00      	ldr	r3, [sp, #0]
 80079aa:	f003 030f 	and.w	r3, r3, #15
 80079ae:	2b00      	cmp	r3, #0
 80079b0:	d017      	beq.n	80079e2 <Vector84+0x52>
 80079b2:	4b0e      	ldr	r3, [pc, #56]	; (80079ec <Vector84+0x5c>)
 80079b4:	2218      	movs	r2, #24
 80079b6:	9900      	ldr	r1, [sp, #0]
 80079b8:	fa01 f202 	lsl.w	r2, r1, r2
 80079bc:	605a      	str	r2, [r3, #4]
 80079be:	4b0c      	ldr	r3, [pc, #48]	; (80079f0 <Vector84+0x60>)
 80079c0:	9a01      	ldr	r2, [sp, #4]
 80079c2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 80079c6:	2b00      	cmp	r3, #0
 80079c8:	d00b      	beq.n	80079e2 <Vector84+0x52>
 80079ca:	4b09      	ldr	r3, [pc, #36]	; (80079f0 <Vector84+0x60>)
 80079cc:	9a01      	ldr	r2, [sp, #4]
 80079ce:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 80079d2:	4907      	ldr	r1, [pc, #28]	; (80079f0 <Vector84+0x60>)
 80079d4:	9b01      	ldr	r3, [sp, #4]
 80079d6:	00db      	lsls	r3, r3, #3
 80079d8:	440b      	add	r3, r1
 80079da:	685b      	ldr	r3, [r3, #4]
 80079dc:	4618      	mov	r0, r3
 80079de:	9900      	ldr	r1, [sp, #0]
 80079e0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80079e2:	f7fc f8b5 	bl	8003b50 <_port_irq_epilogue>
}
 80079e6:	b003      	add	sp, #12
 80079e8:	f85d fb04 	ldr.w	pc, [sp], #4
 80079ec:	40020000 	.word	0x40020000
 80079f0:	20001830 	.word	0x20001830
 80079f4:	f3af 8000 	nop.w
 80079f8:	f3af 8000 	nop.w
 80079fc:	f3af 8000 	nop.w

08007a00 <Vector120>:
/**
 * @brief   DMA2 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8007a00:	b500      	push	{lr}
 8007a02:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM1);
 8007a04:	2307      	movs	r3, #7
 8007a06:	9301      	str	r3, [sp, #4]
 8007a08:	4b14      	ldr	r3, [pc, #80]	; (8007a5c <Vector120+0x5c>)
 8007a0a:	681a      	ldr	r2, [r3, #0]
 8007a0c:	2300      	movs	r3, #0
 8007a0e:	fa22 f303 	lsr.w	r3, r2, r3
 8007a12:	f003 030f 	and.w	r3, r3, #15
 8007a16:	9300      	str	r3, [sp, #0]
 8007a18:	9b00      	ldr	r3, [sp, #0]
 8007a1a:	f003 030f 	and.w	r3, r3, #15
 8007a1e:	2b00      	cmp	r3, #0
 8007a20:	d017      	beq.n	8007a52 <Vector120+0x52>
 8007a22:	4b0e      	ldr	r3, [pc, #56]	; (8007a5c <Vector120+0x5c>)
 8007a24:	2200      	movs	r2, #0
 8007a26:	9900      	ldr	r1, [sp, #0]
 8007a28:	fa01 f202 	lsl.w	r2, r1, r2
 8007a2c:	605a      	str	r2, [r3, #4]
 8007a2e:	4b0c      	ldr	r3, [pc, #48]	; (8007a60 <Vector120+0x60>)
 8007a30:	9a01      	ldr	r2, [sp, #4]
 8007a32:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007a36:	2b00      	cmp	r3, #0
 8007a38:	d00b      	beq.n	8007a52 <Vector120+0x52>
 8007a3a:	4b09      	ldr	r3, [pc, #36]	; (8007a60 <Vector120+0x60>)
 8007a3c:	9a01      	ldr	r2, [sp, #4]
 8007a3e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007a42:	4907      	ldr	r1, [pc, #28]	; (8007a60 <Vector120+0x60>)
 8007a44:	9b01      	ldr	r3, [sp, #4]
 8007a46:	00db      	lsls	r3, r3, #3
 8007a48:	440b      	add	r3, r1
 8007a4a:	685b      	ldr	r3, [r3, #4]
 8007a4c:	4618      	mov	r0, r3
 8007a4e:	9900      	ldr	r1, [sp, #0]
 8007a50:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007a52:	f7fc f87d 	bl	8003b50 <_port_irq_epilogue>
}
 8007a56:	b003      	add	sp, #12
 8007a58:	f85d fb04 	ldr.w	pc, [sp], #4
 8007a5c:	40020400 	.word	0x40020400
 8007a60:	20001830 	.word	0x20001830
 8007a64:	f3af 8000 	nop.w
 8007a68:	f3af 8000 	nop.w
 8007a6c:	f3af 8000 	nop.w

08007a70 <Vector124>:
/**
 * @brief   DMA2 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8007a70:	b500      	push	{lr}
 8007a72:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM2);
 8007a74:	2308      	movs	r3, #8
 8007a76:	9301      	str	r3, [sp, #4]
 8007a78:	4b14      	ldr	r3, [pc, #80]	; (8007acc <Vector124+0x5c>)
 8007a7a:	681a      	ldr	r2, [r3, #0]
 8007a7c:	2304      	movs	r3, #4
 8007a7e:	fa22 f303 	lsr.w	r3, r2, r3
 8007a82:	f003 030f 	and.w	r3, r3, #15
 8007a86:	9300      	str	r3, [sp, #0]
 8007a88:	9b00      	ldr	r3, [sp, #0]
 8007a8a:	f003 030f 	and.w	r3, r3, #15
 8007a8e:	2b00      	cmp	r3, #0
 8007a90:	d017      	beq.n	8007ac2 <Vector124+0x52>
 8007a92:	4b0e      	ldr	r3, [pc, #56]	; (8007acc <Vector124+0x5c>)
 8007a94:	2204      	movs	r2, #4
 8007a96:	9900      	ldr	r1, [sp, #0]
 8007a98:	fa01 f202 	lsl.w	r2, r1, r2
 8007a9c:	605a      	str	r2, [r3, #4]
 8007a9e:	4b0c      	ldr	r3, [pc, #48]	; (8007ad0 <Vector124+0x60>)
 8007aa0:	9a01      	ldr	r2, [sp, #4]
 8007aa2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007aa6:	2b00      	cmp	r3, #0
 8007aa8:	d00b      	beq.n	8007ac2 <Vector124+0x52>
 8007aaa:	4b09      	ldr	r3, [pc, #36]	; (8007ad0 <Vector124+0x60>)
 8007aac:	9a01      	ldr	r2, [sp, #4]
 8007aae:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007ab2:	4907      	ldr	r1, [pc, #28]	; (8007ad0 <Vector124+0x60>)
 8007ab4:	9b01      	ldr	r3, [sp, #4]
 8007ab6:	00db      	lsls	r3, r3, #3
 8007ab8:	440b      	add	r3, r1
 8007aba:	685b      	ldr	r3, [r3, #4]
 8007abc:	4618      	mov	r0, r3
 8007abe:	9900      	ldr	r1, [sp, #0]
 8007ac0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007ac2:	f7fc f845 	bl	8003b50 <_port_irq_epilogue>
}
 8007ac6:	b003      	add	sp, #12
 8007ac8:	f85d fb04 	ldr.w	pc, [sp], #4
 8007acc:	40020400 	.word	0x40020400
 8007ad0:	20001830 	.word	0x20001830
 8007ad4:	f3af 8000 	nop.w
 8007ad8:	f3af 8000 	nop.w
 8007adc:	f3af 8000 	nop.w

08007ae0 <Vector128>:
/**
 * @brief   DMA2 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8007ae0:	b500      	push	{lr}
 8007ae2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM3);
 8007ae4:	2309      	movs	r3, #9
 8007ae6:	9301      	str	r3, [sp, #4]
 8007ae8:	4b14      	ldr	r3, [pc, #80]	; (8007b3c <Vector128+0x5c>)
 8007aea:	681a      	ldr	r2, [r3, #0]
 8007aec:	2308      	movs	r3, #8
 8007aee:	fa22 f303 	lsr.w	r3, r2, r3
 8007af2:	f003 030f 	and.w	r3, r3, #15
 8007af6:	9300      	str	r3, [sp, #0]
 8007af8:	9b00      	ldr	r3, [sp, #0]
 8007afa:	f003 030f 	and.w	r3, r3, #15
 8007afe:	2b00      	cmp	r3, #0
 8007b00:	d017      	beq.n	8007b32 <Vector128+0x52>
 8007b02:	4b0e      	ldr	r3, [pc, #56]	; (8007b3c <Vector128+0x5c>)
 8007b04:	2208      	movs	r2, #8
 8007b06:	9900      	ldr	r1, [sp, #0]
 8007b08:	fa01 f202 	lsl.w	r2, r1, r2
 8007b0c:	605a      	str	r2, [r3, #4]
 8007b0e:	4b0c      	ldr	r3, [pc, #48]	; (8007b40 <Vector128+0x60>)
 8007b10:	9a01      	ldr	r2, [sp, #4]
 8007b12:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007b16:	2b00      	cmp	r3, #0
 8007b18:	d00b      	beq.n	8007b32 <Vector128+0x52>
 8007b1a:	4b09      	ldr	r3, [pc, #36]	; (8007b40 <Vector128+0x60>)
 8007b1c:	9a01      	ldr	r2, [sp, #4]
 8007b1e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007b22:	4907      	ldr	r1, [pc, #28]	; (8007b40 <Vector128+0x60>)
 8007b24:	9b01      	ldr	r3, [sp, #4]
 8007b26:	00db      	lsls	r3, r3, #3
 8007b28:	440b      	add	r3, r1
 8007b2a:	685b      	ldr	r3, [r3, #4]
 8007b2c:	4618      	mov	r0, r3
 8007b2e:	9900      	ldr	r1, [sp, #0]
 8007b30:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007b32:	f7fc f80d 	bl	8003b50 <_port_irq_epilogue>
}
 8007b36:	b003      	add	sp, #12
 8007b38:	f85d fb04 	ldr.w	pc, [sp], #4
 8007b3c:	40020400 	.word	0x40020400
 8007b40:	20001830 	.word	0x20001830
 8007b44:	f3af 8000 	nop.w
 8007b48:	f3af 8000 	nop.w
 8007b4c:	f3af 8000 	nop.w

08007b50 <Vector12C>:
/**
 * @brief   DMA2 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8007b50:	b500      	push	{lr}
 8007b52:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM4);
 8007b54:	230a      	movs	r3, #10
 8007b56:	9301      	str	r3, [sp, #4]
 8007b58:	4b14      	ldr	r3, [pc, #80]	; (8007bac <Vector12C+0x5c>)
 8007b5a:	681a      	ldr	r2, [r3, #0]
 8007b5c:	230c      	movs	r3, #12
 8007b5e:	fa22 f303 	lsr.w	r3, r2, r3
 8007b62:	f003 030f 	and.w	r3, r3, #15
 8007b66:	9300      	str	r3, [sp, #0]
 8007b68:	9b00      	ldr	r3, [sp, #0]
 8007b6a:	f003 030f 	and.w	r3, r3, #15
 8007b6e:	2b00      	cmp	r3, #0
 8007b70:	d017      	beq.n	8007ba2 <Vector12C+0x52>
 8007b72:	4b0e      	ldr	r3, [pc, #56]	; (8007bac <Vector12C+0x5c>)
 8007b74:	220c      	movs	r2, #12
 8007b76:	9900      	ldr	r1, [sp, #0]
 8007b78:	fa01 f202 	lsl.w	r2, r1, r2
 8007b7c:	605a      	str	r2, [r3, #4]
 8007b7e:	4b0c      	ldr	r3, [pc, #48]	; (8007bb0 <Vector12C+0x60>)
 8007b80:	9a01      	ldr	r2, [sp, #4]
 8007b82:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007b86:	2b00      	cmp	r3, #0
 8007b88:	d00b      	beq.n	8007ba2 <Vector12C+0x52>
 8007b8a:	4b09      	ldr	r3, [pc, #36]	; (8007bb0 <Vector12C+0x60>)
 8007b8c:	9a01      	ldr	r2, [sp, #4]
 8007b8e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007b92:	4907      	ldr	r1, [pc, #28]	; (8007bb0 <Vector12C+0x60>)
 8007b94:	9b01      	ldr	r3, [sp, #4]
 8007b96:	00db      	lsls	r3, r3, #3
 8007b98:	440b      	add	r3, r1
 8007b9a:	685b      	ldr	r3, [r3, #4]
 8007b9c:	4618      	mov	r0, r3
 8007b9e:	9900      	ldr	r1, [sp, #0]
 8007ba0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007ba2:	f7fb ffd5 	bl	8003b50 <_port_irq_epilogue>
}
 8007ba6:	b003      	add	sp, #12
 8007ba8:	f85d fb04 	ldr.w	pc, [sp], #4
 8007bac:	40020400 	.word	0x40020400
 8007bb0:	20001830 	.word	0x20001830
 8007bb4:	f3af 8000 	nop.w
 8007bb8:	f3af 8000 	nop.w
 8007bbc:	f3af 8000 	nop.w

08007bc0 <Vector130>:
/**
 * @brief   DMA2 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8007bc0:	b500      	push	{lr}
 8007bc2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM5);
 8007bc4:	230b      	movs	r3, #11
 8007bc6:	9301      	str	r3, [sp, #4]
 8007bc8:	4b14      	ldr	r3, [pc, #80]	; (8007c1c <Vector130+0x5c>)
 8007bca:	681a      	ldr	r2, [r3, #0]
 8007bcc:	2310      	movs	r3, #16
 8007bce:	fa22 f303 	lsr.w	r3, r2, r3
 8007bd2:	f003 030f 	and.w	r3, r3, #15
 8007bd6:	9300      	str	r3, [sp, #0]
 8007bd8:	9b00      	ldr	r3, [sp, #0]
 8007bda:	f003 030f 	and.w	r3, r3, #15
 8007bde:	2b00      	cmp	r3, #0
 8007be0:	d017      	beq.n	8007c12 <Vector130+0x52>
 8007be2:	4b0e      	ldr	r3, [pc, #56]	; (8007c1c <Vector130+0x5c>)
 8007be4:	2210      	movs	r2, #16
 8007be6:	9900      	ldr	r1, [sp, #0]
 8007be8:	fa01 f202 	lsl.w	r2, r1, r2
 8007bec:	605a      	str	r2, [r3, #4]
 8007bee:	4b0c      	ldr	r3, [pc, #48]	; (8007c20 <Vector130+0x60>)
 8007bf0:	9a01      	ldr	r2, [sp, #4]
 8007bf2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007bf6:	2b00      	cmp	r3, #0
 8007bf8:	d00b      	beq.n	8007c12 <Vector130+0x52>
 8007bfa:	4b09      	ldr	r3, [pc, #36]	; (8007c20 <Vector130+0x60>)
 8007bfc:	9a01      	ldr	r2, [sp, #4]
 8007bfe:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007c02:	4907      	ldr	r1, [pc, #28]	; (8007c20 <Vector130+0x60>)
 8007c04:	9b01      	ldr	r3, [sp, #4]
 8007c06:	00db      	lsls	r3, r3, #3
 8007c08:	440b      	add	r3, r1
 8007c0a:	685b      	ldr	r3, [r3, #4]
 8007c0c:	4618      	mov	r0, r3
 8007c0e:	9900      	ldr	r1, [sp, #0]
 8007c10:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007c12:	f7fb ff9d 	bl	8003b50 <_port_irq_epilogue>
}
 8007c16:	b003      	add	sp, #12
 8007c18:	f85d fb04 	ldr.w	pc, [sp], #4
 8007c1c:	40020400 	.word	0x40020400
 8007c20:	20001830 	.word	0x20001830
 8007c24:	f3af 8000 	nop.w
 8007c28:	f3af 8000 	nop.w
 8007c2c:	f3af 8000 	nop.w

08007c30 <Vector150>:
/**
 * @brief   DMA2 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8007c30:	b500      	push	{lr}
 8007c32:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM6);
 8007c34:	230c      	movs	r3, #12
 8007c36:	9301      	str	r3, [sp, #4]
 8007c38:	4b14      	ldr	r3, [pc, #80]	; (8007c8c <Vector150+0x5c>)
 8007c3a:	681a      	ldr	r2, [r3, #0]
 8007c3c:	2314      	movs	r3, #20
 8007c3e:	fa22 f303 	lsr.w	r3, r2, r3
 8007c42:	f003 030f 	and.w	r3, r3, #15
 8007c46:	9300      	str	r3, [sp, #0]
 8007c48:	9b00      	ldr	r3, [sp, #0]
 8007c4a:	f003 030f 	and.w	r3, r3, #15
 8007c4e:	2b00      	cmp	r3, #0
 8007c50:	d017      	beq.n	8007c82 <Vector150+0x52>
 8007c52:	4b0e      	ldr	r3, [pc, #56]	; (8007c8c <Vector150+0x5c>)
 8007c54:	2214      	movs	r2, #20
 8007c56:	9900      	ldr	r1, [sp, #0]
 8007c58:	fa01 f202 	lsl.w	r2, r1, r2
 8007c5c:	605a      	str	r2, [r3, #4]
 8007c5e:	4b0c      	ldr	r3, [pc, #48]	; (8007c90 <Vector150+0x60>)
 8007c60:	9a01      	ldr	r2, [sp, #4]
 8007c62:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007c66:	2b00      	cmp	r3, #0
 8007c68:	d00b      	beq.n	8007c82 <Vector150+0x52>
 8007c6a:	4b09      	ldr	r3, [pc, #36]	; (8007c90 <Vector150+0x60>)
 8007c6c:	9a01      	ldr	r2, [sp, #4]
 8007c6e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007c72:	4907      	ldr	r1, [pc, #28]	; (8007c90 <Vector150+0x60>)
 8007c74:	9b01      	ldr	r3, [sp, #4]
 8007c76:	00db      	lsls	r3, r3, #3
 8007c78:	440b      	add	r3, r1
 8007c7a:	685b      	ldr	r3, [r3, #4]
 8007c7c:	4618      	mov	r0, r3
 8007c7e:	9900      	ldr	r1, [sp, #0]
 8007c80:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007c82:	f7fb ff65 	bl	8003b50 <_port_irq_epilogue>
}
 8007c86:	b003      	add	sp, #12
 8007c88:	f85d fb04 	ldr.w	pc, [sp], #4
 8007c8c:	40020400 	.word	0x40020400
 8007c90:	20001830 	.word	0x20001830
 8007c94:	f3af 8000 	nop.w
 8007c98:	f3af 8000 	nop.w
 8007c9c:	f3af 8000 	nop.w

08007ca0 <Vector154>:
/**
 * @brief   DMA2 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 8007ca0:	b500      	push	{lr}
 8007ca2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM7);
 8007ca4:	230d      	movs	r3, #13
 8007ca6:	9301      	str	r3, [sp, #4]
 8007ca8:	4b14      	ldr	r3, [pc, #80]	; (8007cfc <Vector154+0x5c>)
 8007caa:	681a      	ldr	r2, [r3, #0]
 8007cac:	2318      	movs	r3, #24
 8007cae:	fa22 f303 	lsr.w	r3, r2, r3
 8007cb2:	f003 030f 	and.w	r3, r3, #15
 8007cb6:	9300      	str	r3, [sp, #0]
 8007cb8:	9b00      	ldr	r3, [sp, #0]
 8007cba:	f003 030f 	and.w	r3, r3, #15
 8007cbe:	2b00      	cmp	r3, #0
 8007cc0:	d017      	beq.n	8007cf2 <Vector154+0x52>
 8007cc2:	4b0e      	ldr	r3, [pc, #56]	; (8007cfc <Vector154+0x5c>)
 8007cc4:	2218      	movs	r2, #24
 8007cc6:	9900      	ldr	r1, [sp, #0]
 8007cc8:	fa01 f202 	lsl.w	r2, r1, r2
 8007ccc:	605a      	str	r2, [r3, #4]
 8007cce:	4b0c      	ldr	r3, [pc, #48]	; (8007d00 <Vector154+0x60>)
 8007cd0:	9a01      	ldr	r2, [sp, #4]
 8007cd2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007cd6:	2b00      	cmp	r3, #0
 8007cd8:	d00b      	beq.n	8007cf2 <Vector154+0x52>
 8007cda:	4b09      	ldr	r3, [pc, #36]	; (8007d00 <Vector154+0x60>)
 8007cdc:	9a01      	ldr	r2, [sp, #4]
 8007cde:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007ce2:	4907      	ldr	r1, [pc, #28]	; (8007d00 <Vector154+0x60>)
 8007ce4:	9b01      	ldr	r3, [sp, #4]
 8007ce6:	00db      	lsls	r3, r3, #3
 8007ce8:	440b      	add	r3, r1
 8007cea:	685b      	ldr	r3, [r3, #4]
 8007cec:	4618      	mov	r0, r3
 8007cee:	9900      	ldr	r1, [sp, #0]
 8007cf0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007cf2:	f7fb ff2d 	bl	8003b50 <_port_irq_epilogue>
}
 8007cf6:	b003      	add	sp, #12
 8007cf8:	f85d fb04 	ldr.w	pc, [sp], #4
 8007cfc:	40020400 	.word	0x40020400
 8007d00:	20001830 	.word	0x20001830
 8007d04:	f3af 8000 	nop.w
 8007d08:	f3af 8000 	nop.w
 8007d0c:	f3af 8000 	nop.w

08007d10 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8007d10:	b082      	sub	sp, #8
  int i;

  dma_streams_mask = 0U;
 8007d12:	4b12      	ldr	r3, [pc, #72]	; (8007d5c <dmaInit+0x4c>)
 8007d14:	2200      	movs	r2, #0
 8007d16:	601a      	str	r2, [r3, #0]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8007d18:	2300      	movs	r3, #0
 8007d1a:	9301      	str	r3, [sp, #4]
 8007d1c:	e011      	b.n	8007d42 <dmaInit+0x32>
    _stm32_dma_streams[i].channel->CCR = 0U;
 8007d1e:	4910      	ldr	r1, [pc, #64]	; (8007d60 <dmaInit+0x50>)
 8007d20:	9a01      	ldr	r2, [sp, #4]
 8007d22:	4613      	mov	r3, r2
 8007d24:	009b      	lsls	r3, r3, #2
 8007d26:	4413      	add	r3, r2
 8007d28:	009b      	lsls	r3, r3, #2
 8007d2a:	440b      	add	r3, r1
 8007d2c:	685b      	ldr	r3, [r3, #4]
 8007d2e:	2200      	movs	r2, #0
 8007d30:	601a      	str	r2, [r3, #0]
    _stm32_dma_isr_redir[i].dma_func = NULL;
 8007d32:	4b0c      	ldr	r3, [pc, #48]	; (8007d64 <dmaInit+0x54>)
 8007d34:	9a01      	ldr	r2, [sp, #4]
 8007d36:	2100      	movs	r1, #0
 8007d38:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8007d3c:	9b01      	ldr	r3, [sp, #4]
 8007d3e:	3301      	adds	r3, #1
 8007d40:	9301      	str	r3, [sp, #4]
 8007d42:	9b01      	ldr	r3, [sp, #4]
 8007d44:	2b0d      	cmp	r3, #13
 8007d46:	ddea      	ble.n	8007d1e <dmaInit+0xe>
    _stm32_dma_streams[i].channel->CCR = 0U;
    _stm32_dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 8007d48:	4b07      	ldr	r3, [pc, #28]	; (8007d68 <dmaInit+0x58>)
 8007d4a:	f04f 32ff 	mov.w	r2, #4294967295
 8007d4e:	605a      	str	r2, [r3, #4]
#if STM32_DMA2_NUM_CHANNELS > 0
  DMA2->IFCR = 0xFFFFFFFFU;
 8007d50:	4b06      	ldr	r3, [pc, #24]	; (8007d6c <dmaInit+0x5c>)
 8007d52:	f04f 32ff 	mov.w	r2, #4294967295
 8007d56:	605a      	str	r2, [r3, #4]
#endif
}
 8007d58:	b002      	add	sp, #8
 8007d5a:	4770      	bx	lr
 8007d5c:	20000d70 	.word	0x20000d70
 8007d60:	08017870 	.word	0x08017870
 8007d64:	20001830 	.word	0x20001830
 8007d68:	40020000 	.word	0x40020000
 8007d6c:	40020400 	.word	0x40020400

08007d70 <dmaStreamAllocate>:
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {
 8007d70:	b500      	push	{lr}
 8007d72:	b085      	sub	sp, #20
 8007d74:	9003      	str	r0, [sp, #12]
 8007d76:	9102      	str	r1, [sp, #8]
 8007d78:	9201      	str	r2, [sp, #4]
 8007d7a:	9300      	str	r3, [sp, #0]

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 8007d7c:	9b03      	ldr	r3, [sp, #12]
 8007d7e:	7c5b      	ldrb	r3, [r3, #17]
 8007d80:	2201      	movs	r2, #1
 8007d82:	409a      	lsls	r2, r3
 8007d84:	4b2f      	ldr	r3, [pc, #188]	; (8007e44 <dmaStreamAllocate+0xd4>)
 8007d86:	681b      	ldr	r3, [r3, #0]
 8007d88:	4013      	ands	r3, r2
 8007d8a:	2b00      	cmp	r3, #0
 8007d8c:	d001      	beq.n	8007d92 <dmaStreamAllocate+0x22>
    return true;
 8007d8e:	2301      	movs	r3, #1
 8007d90:	e053      	b.n	8007e3a <dmaStreamAllocate+0xca>

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8007d92:	9b03      	ldr	r3, [sp, #12]
 8007d94:	7c5b      	ldrb	r3, [r3, #17]
 8007d96:	461a      	mov	r2, r3
 8007d98:	4b2b      	ldr	r3, [pc, #172]	; (8007e48 <dmaStreamAllocate+0xd8>)
 8007d9a:	9901      	ldr	r1, [sp, #4]
 8007d9c:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 8007da0:	9b03      	ldr	r3, [sp, #12]
 8007da2:	7c5b      	ldrb	r3, [r3, #17]
 8007da4:	4a28      	ldr	r2, [pc, #160]	; (8007e48 <dmaStreamAllocate+0xd8>)
 8007da6:	00db      	lsls	r3, r3, #3
 8007da8:	4413      	add	r3, r2
 8007daa:	9a00      	ldr	r2, [sp, #0]
 8007dac:	605a      	str	r2, [r3, #4]

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8007dae:	4b25      	ldr	r3, [pc, #148]	; (8007e44 <dmaStreamAllocate+0xd4>)
 8007db0:	681b      	ldr	r3, [r3, #0]
 8007db2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8007db6:	2b00      	cmp	r3, #0
 8007db8:	d105      	bne.n	8007dc6 <dmaStreamAllocate+0x56>
    rccEnableDMA1(false);
 8007dba:	4b24      	ldr	r3, [pc, #144]	; (8007e4c <dmaStreamAllocate+0xdc>)
 8007dbc:	4a23      	ldr	r2, [pc, #140]	; (8007e4c <dmaStreamAllocate+0xdc>)
 8007dbe:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8007dc0:	f042 0201 	orr.w	r2, r2, #1
 8007dc4:	649a      	str	r2, [r3, #72]	; 0x48
  }
#if STM32_DMA2_NUM_CHANNELS > 0
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
 8007dc6:	4b1f      	ldr	r3, [pc, #124]	; (8007e44 <dmaStreamAllocate+0xd4>)
 8007dc8:	681b      	ldr	r3, [r3, #0]
 8007dca:	f403 537e 	and.w	r3, r3, #16256	; 0x3f80
 8007dce:	2b00      	cmp	r3, #0
 8007dd0:	d105      	bne.n	8007dde <dmaStreamAllocate+0x6e>
    rccEnableDMA2(false);
 8007dd2:	4b1e      	ldr	r3, [pc, #120]	; (8007e4c <dmaStreamAllocate+0xdc>)
 8007dd4:	4a1d      	ldr	r2, [pc, #116]	; (8007e4c <dmaStreamAllocate+0xdc>)
 8007dd6:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8007dd8:	f042 0202 	orr.w	r2, r2, #2
 8007ddc:	649a      	str	r2, [r3, #72]	; 0x48
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8007dde:	9b03      	ldr	r3, [sp, #12]
 8007de0:	685b      	ldr	r3, [r3, #4]
 8007de2:	9a03      	ldr	r2, [sp, #12]
 8007de4:	6852      	ldr	r2, [r2, #4]
 8007de6:	6812      	ldr	r2, [r2, #0]
 8007de8:	f022 020f 	bic.w	r2, r2, #15
 8007dec:	601a      	str	r2, [r3, #0]
 8007dee:	9b03      	ldr	r3, [sp, #12]
 8007df0:	681b      	ldr	r3, [r3, #0]
 8007df2:	9a03      	ldr	r2, [sp, #12]
 8007df4:	7c12      	ldrb	r2, [r2, #16]
 8007df6:	210f      	movs	r1, #15
 8007df8:	fa01 f202 	lsl.w	r2, r1, r2
 8007dfc:	605a      	str	r2, [r3, #4]
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8007dfe:	9b03      	ldr	r3, [sp, #12]
 8007e00:	685b      	ldr	r3, [r3, #4]
 8007e02:	2200      	movs	r2, #0
 8007e04:	601a      	str	r2, [r3, #0]

  /* Enables the associated IRQ vector if not alread enabled and if a
     callback is defined.*/
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 8007e06:	9b03      	ldr	r3, [sp, #12]
 8007e08:	689a      	ldr	r2, [r3, #8]
 8007e0a:	4b0e      	ldr	r3, [pc, #56]	; (8007e44 <dmaStreamAllocate+0xd4>)
 8007e0c:	681b      	ldr	r3, [r3, #0]
 8007e0e:	4013      	ands	r3, r2
 8007e10:	2b00      	cmp	r3, #0
 8007e12:	d108      	bne.n	8007e26 <dmaStreamAllocate+0xb6>
 8007e14:	9b01      	ldr	r3, [sp, #4]
 8007e16:	2b00      	cmp	r3, #0
 8007e18:	d005      	beq.n	8007e26 <dmaStreamAllocate+0xb6>
      (func != NULL)) {
    nvicEnableVector(dmastp->vector, priority);
 8007e1a:	9b03      	ldr	r3, [sp, #12]
 8007e1c:	7c9b      	ldrb	r3, [r3, #18]
 8007e1e:	4618      	mov	r0, r3
 8007e20:	9902      	ldr	r1, [sp, #8]
 8007e22:	f7ff fa85 	bl	8007330 <nvicEnableVector>
  }

  /* Marks the stream as allocated.*/
  dma_streams_mask |= (1U << dmastp->selfindex);
 8007e26:	9b03      	ldr	r3, [sp, #12]
 8007e28:	7c5b      	ldrb	r3, [r3, #17]
 8007e2a:	2201      	movs	r2, #1
 8007e2c:	409a      	lsls	r2, r3
 8007e2e:	4b05      	ldr	r3, [pc, #20]	; (8007e44 <dmaStreamAllocate+0xd4>)
 8007e30:	681b      	ldr	r3, [r3, #0]
 8007e32:	431a      	orrs	r2, r3
 8007e34:	4b03      	ldr	r3, [pc, #12]	; (8007e44 <dmaStreamAllocate+0xd4>)
 8007e36:	601a      	str	r2, [r3, #0]

  return false;
 8007e38:	2300      	movs	r3, #0
}
 8007e3a:	4618      	mov	r0, r3
 8007e3c:	b005      	add	sp, #20
 8007e3e:	f85d fb04 	ldr.w	pc, [sp], #4
 8007e42:	bf00      	nop
 8007e44:	20000d70 	.word	0x20000d70
 8007e48:	20001830 	.word	0x20001830
 8007e4c:	40021000 	.word	0x40021000

08007e50 <dmaStreamRelease>:
 *
 * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
 *
 * @special
 */
void dmaStreamRelease(const stm32_dma_stream_t *dmastp) {
 8007e50:	b500      	push	{lr}
 8007e52:	b083      	sub	sp, #12
 8007e54:	9001      	str	r0, [sp, #4]
  /* Check if the streams is not taken.*/
  osalDbgAssert((dma_streams_mask & (1 << dmastp->selfindex)) != 0U,
                "not allocated");

  /* Marks the stream as not allocated.*/
  dma_streams_mask &= ~(1U << dmastp->selfindex);
 8007e56:	9b01      	ldr	r3, [sp, #4]
 8007e58:	7c5b      	ldrb	r3, [r3, #17]
 8007e5a:	2201      	movs	r2, #1
 8007e5c:	fa02 f303 	lsl.w	r3, r2, r3
 8007e60:	43da      	mvns	r2, r3
 8007e62:	4b1d      	ldr	r3, [pc, #116]	; (8007ed8 <dmaStreamRelease+0x88>)
 8007e64:	681b      	ldr	r3, [r3, #0]
 8007e66:	401a      	ands	r2, r3
 8007e68:	4b1b      	ldr	r3, [pc, #108]	; (8007ed8 <dmaStreamRelease+0x88>)
 8007e6a:	601a      	str	r2, [r3, #0]

  /* Disables the associated IRQ vector if it is no more in use.*/
  if ((dma_streams_mask & dmastp->cmask) == 0U) {
 8007e6c:	9b01      	ldr	r3, [sp, #4]
 8007e6e:	689a      	ldr	r2, [r3, #8]
 8007e70:	4b19      	ldr	r3, [pc, #100]	; (8007ed8 <dmaStreamRelease+0x88>)
 8007e72:	681b      	ldr	r3, [r3, #0]
 8007e74:	4013      	ands	r3, r2
 8007e76:	2b00      	cmp	r3, #0
 8007e78:	d104      	bne.n	8007e84 <dmaStreamRelease+0x34>
    nvicDisableVector(dmastp->vector);
 8007e7a:	9b01      	ldr	r3, [sp, #4]
 8007e7c:	7c9b      	ldrb	r3, [r3, #18]
 8007e7e:	4618      	mov	r0, r3
 8007e80:	f7ff fa7e 	bl	8007380 <nvicDisableVector>
  }

  /* Removes the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = NULL;
 8007e84:	9b01      	ldr	r3, [sp, #4]
 8007e86:	7c5b      	ldrb	r3, [r3, #17]
 8007e88:	461a      	mov	r2, r3
 8007e8a:	4b14      	ldr	r3, [pc, #80]	; (8007edc <dmaStreamRelease+0x8c>)
 8007e8c:	2100      	movs	r1, #0
 8007e8e:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = NULL;
 8007e92:	9b01      	ldr	r3, [sp, #4]
 8007e94:	7c5b      	ldrb	r3, [r3, #17]
 8007e96:	4a11      	ldr	r2, [pc, #68]	; (8007edc <dmaStreamRelease+0x8c>)
 8007e98:	00db      	lsls	r3, r3, #3
 8007e9a:	4413      	add	r3, r2
 8007e9c:	2200      	movs	r2, #0
 8007e9e:	605a      	str	r2, [r3, #4]

  /* Shutting down clocks that are no more required, if any.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8007ea0:	4b0d      	ldr	r3, [pc, #52]	; (8007ed8 <dmaStreamRelease+0x88>)
 8007ea2:	681b      	ldr	r3, [r3, #0]
 8007ea4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8007ea8:	2b00      	cmp	r3, #0
 8007eaa:	d105      	bne.n	8007eb8 <dmaStreamRelease+0x68>
    rccDisableDMA1(false);
 8007eac:	4b0c      	ldr	r3, [pc, #48]	; (8007ee0 <dmaStreamRelease+0x90>)
 8007eae:	4a0c      	ldr	r2, [pc, #48]	; (8007ee0 <dmaStreamRelease+0x90>)
 8007eb0:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8007eb2:	f022 0201 	bic.w	r2, r2, #1
 8007eb6:	649a      	str	r2, [r3, #72]	; 0x48
  }
#if STM32_DMA2_NUM_CHANNELS > 0
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
 8007eb8:	4b07      	ldr	r3, [pc, #28]	; (8007ed8 <dmaStreamRelease+0x88>)
 8007eba:	681b      	ldr	r3, [r3, #0]
 8007ebc:	f403 537e 	and.w	r3, r3, #16256	; 0x3f80
 8007ec0:	2b00      	cmp	r3, #0
 8007ec2:	d105      	bne.n	8007ed0 <dmaStreamRelease+0x80>
    rccDisableDMA2(false);
 8007ec4:	4b06      	ldr	r3, [pc, #24]	; (8007ee0 <dmaStreamRelease+0x90>)
 8007ec6:	4a06      	ldr	r2, [pc, #24]	; (8007ee0 <dmaStreamRelease+0x90>)
 8007ec8:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8007eca:	f022 0202 	bic.w	r2, r2, #2
 8007ece:	649a      	str	r2, [r3, #72]	; 0x48
  }
#endif
}
 8007ed0:	b003      	add	sp, #12
 8007ed2:	f85d fb04 	ldr.w	pc, [sp], #4
 8007ed6:	bf00      	nop
 8007ed8:	20000d70 	.word	0x20000d70
 8007edc:	20001830 	.word	0x20001830
 8007ee0:	40021000 	.word	0x40021000
 8007ee4:	f3af 8000 	nop.w
 8007ee8:	f3af 8000 	nop.w
 8007eec:	f3af 8000 	nop.w

08007ef0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8007ef0:	b082      	sub	sp, #8
 8007ef2:	2320      	movs	r3, #32
 8007ef4:	9301      	str	r3, [sp, #4]
 8007ef6:	9b01      	ldr	r3, [sp, #4]
 8007ef8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8007efc:	b002      	add	sp, #8
 8007efe:	4770      	bx	lr

08007f00 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8007f00:	b082      	sub	sp, #8
 8007f02:	2300      	movs	r3, #0
 8007f04:	9301      	str	r3, [sp, #4]
 8007f06:	9b01      	ldr	r3, [sp, #4]
 8007f08:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8007f0c:	b002      	add	sp, #8
 8007f0e:	4770      	bx	lr

08007f10 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8007f10:	b508      	push	{r3, lr}

  port_lock();
 8007f12:	f7ff ffed 	bl	8007ef0 <port_lock>
}
 8007f16:	bd08      	pop	{r3, pc}
 8007f18:	f3af 8000 	nop.w
 8007f1c:	f3af 8000 	nop.w

08007f20 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8007f20:	b508      	push	{r3, lr}

  port_unlock();
 8007f22:	f7ff ffed 	bl	8007f00 <port_unlock>
}
 8007f26:	bd08      	pop	{r3, pc}
 8007f28:	f3af 8000 	nop.w
 8007f2c:	f3af 8000 	nop.w

08007f30 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8007f30:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8007f32:	f7ff ffed 	bl	8007f10 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8007f36:	bd08      	pop	{r3, pc}
 8007f38:	f3af 8000 	nop.w
 8007f3c:	f3af 8000 	nop.w

08007f40 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8007f40:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8007f42:	f7ff ffed 	bl	8007f20 <port_unlock_from_isr>
}
 8007f46:	bd08      	pop	{r3, pc}
 8007f48:	f3af 8000 	nop.w
 8007f4c:	f3af 8000 	nop.w

08007f50 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8007f50:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8007f52:	f7ff ffed 	bl	8007f30 <chSysLockFromISR>
}
 8007f56:	bd08      	pop	{r3, pc}
 8007f58:	f3af 8000 	nop.w
 8007f5c:	f3af 8000 	nop.w

08007f60 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8007f60:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8007f62:	f7ff ffed 	bl	8007f40 <chSysUnlockFromISR>
}
 8007f66:	bd08      	pop	{r3, pc}
 8007f68:	f3af 8000 	nop.w
 8007f6c:	f3af 8000 	nop.w

08007f70 <osalOsTimerHandlerI>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
 8007f70:	b508      	push	{r3, lr}

  chSysTimerHandlerI();
 8007f72:	f7f8 fc6d 	bl	8000850 <chSysTimerHandlerI>
}
 8007f76:	bd08      	pop	{r3, pc}
 8007f78:	f3af 8000 	nop.w
 8007f7c:	f3af 8000 	nop.w

08007f80 <SysTick_Handler>:
 * @brief   System Timer vector.
 * @details This interrupt is used for system tick in periodic mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(SysTick_Handler) {
 8007f80:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  osalSysLockFromISR();
 8007f82:	f7ff ffe5 	bl	8007f50 <osalSysLockFromISR>
  osalOsTimerHandlerI();
 8007f86:	f7ff fff3 	bl	8007f70 <osalOsTimerHandlerI>
  osalSysUnlockFromISR();
 8007f8a:	f7ff ffe9 	bl	8007f60 <osalSysUnlockFromISR>

  OSAL_IRQ_EPILOGUE();
 8007f8e:	f7fb fddf 	bl	8003b50 <_port_irq_epilogue>
}
 8007f92:	bd08      	pop	{r3, pc}
 8007f94:	f3af 8000 	nop.w
 8007f98:	f3af 8000 	nop.w
 8007f9c:	f3af 8000 	nop.w

08007fa0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 8007fa0:	b508      	push	{r3, lr}
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */

#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
 8007fa2:	4b07      	ldr	r3, [pc, #28]	; (8007fc0 <st_lld_init+0x20>)
 8007fa4:	4a07      	ldr	r2, [pc, #28]	; (8007fc4 <st_lld_init+0x24>)
 8007fa6:	605a      	str	r2, [r3, #4]
  SysTick->VAL = 0;
 8007fa8:	4b05      	ldr	r3, [pc, #20]	; (8007fc0 <st_lld_init+0x20>)
 8007faa:	2200      	movs	r2, #0
 8007fac:	609a      	str	r2, [r3, #8]
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
 8007fae:	4b04      	ldr	r3, [pc, #16]	; (8007fc0 <st_lld_init+0x20>)
 8007fb0:	2207      	movs	r2, #7
 8007fb2:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
 8007fb4:	200b      	movs	r0, #11
 8007fb6:	2108      	movs	r1, #8
 8007fb8:	f7ff fa02 	bl	80073c0 <nvicSetSystemHandlerPriority>
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8007fbc:	bd08      	pop	{r3, pc}
 8007fbe:	bf00      	nop
 8007fc0:	e000e010 	.word	0xe000e010
 8007fc4:	0001387f 	.word	0x0001387f
 8007fc8:	f3af 8000 	nop.w
 8007fcc:	f3af 8000 	nop.w

08007fd0 <initgpio>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
 8007fd0:	b082      	sub	sp, #8
 8007fd2:	9001      	str	r0, [sp, #4]
 8007fd4:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8007fd6:	9b00      	ldr	r3, [sp, #0]
 8007fd8:	685a      	ldr	r2, [r3, #4]
 8007fda:	9b01      	ldr	r3, [sp, #4]
 8007fdc:	605a      	str	r2, [r3, #4]
  gpiop->ASCR    = config->ascr;
 8007fde:	9b00      	ldr	r3, [sp, #0]
 8007fe0:	69da      	ldr	r2, [r3, #28]
 8007fe2:	9b01      	ldr	r3, [sp, #4]
 8007fe4:	62da      	str	r2, [r3, #44]	; 0x2c
  gpiop->OSPEEDR = config->ospeedr;
 8007fe6:	9b00      	ldr	r3, [sp, #0]
 8007fe8:	689a      	ldr	r2, [r3, #8]
 8007fea:	9b01      	ldr	r3, [sp, #4]
 8007fec:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8007fee:	9b00      	ldr	r3, [sp, #0]
 8007ff0:	68da      	ldr	r2, [r3, #12]
 8007ff2:	9b01      	ldr	r3, [sp, #4]
 8007ff4:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 8007ff6:	9b00      	ldr	r3, [sp, #0]
 8007ff8:	691a      	ldr	r2, [r3, #16]
 8007ffa:	9b01      	ldr	r3, [sp, #4]
 8007ffc:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8007ffe:	9b00      	ldr	r3, [sp, #0]
 8008000:	695a      	ldr	r2, [r3, #20]
 8008002:	9b01      	ldr	r3, [sp, #4]
 8008004:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8008006:	9b00      	ldr	r3, [sp, #0]
 8008008:	699a      	ldr	r2, [r3, #24]
 800800a:	9b01      	ldr	r3, [sp, #4]
 800800c:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800800e:	9b00      	ldr	r3, [sp, #0]
 8008010:	681a      	ldr	r2, [r3, #0]
 8008012:	9b01      	ldr	r3, [sp, #4]
 8008014:	601a      	str	r2, [r3, #0]
  gpiop->LOCKR   = config->lockr;
 8008016:	9b00      	ldr	r3, [sp, #0]
 8008018:	6a1a      	ldr	r2, [r3, #32]
 800801a:	9b01      	ldr	r3, [sp, #4]
 800801c:	61da      	str	r2, [r3, #28]
}
 800801e:	b002      	add	sp, #8
 8008020:	4770      	bx	lr
 8008022:	bf00      	nop
 8008024:	f3af 8000 	nop.w
 8008028:	f3af 8000 	nop.w
 800802c:	f3af 8000 	nop.w

08008030 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 8008030:	b500      	push	{lr}
 8008032:	b083      	sub	sp, #12
 8008034:	9001      	str	r0, [sp, #4]

  /*
   * Enables the GPIO related clocks.
   */
#if defined(STM32L4XX)
  RCC->AHB2ENR   |= AHB1_EN_MASK;
 8008036:	4b1c      	ldr	r3, [pc, #112]	; (80080a8 <_pal_lld_init+0x78>)
 8008038:	4a1b      	ldr	r2, [pc, #108]	; (80080a8 <_pal_lld_init+0x78>)
 800803a:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 800803c:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
 8008040:	64da      	str	r2, [r3, #76]	; 0x4c

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
 8008042:	9b01      	ldr	r3, [sp, #4]
 8008044:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8008048:	4619      	mov	r1, r3
 800804a:	f7ff ffc1 	bl	8007fd0 <initgpio>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
 800804e:	9b01      	ldr	r3, [sp, #4]
 8008050:	3324      	adds	r3, #36	; 0x24
 8008052:	4816      	ldr	r0, [pc, #88]	; (80080ac <_pal_lld_init+0x7c>)
 8008054:	4619      	mov	r1, r3
 8008056:	f7ff ffbb 	bl	8007fd0 <initgpio>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
 800805a:	9b01      	ldr	r3, [sp, #4]
 800805c:	3348      	adds	r3, #72	; 0x48
 800805e:	4814      	ldr	r0, [pc, #80]	; (80080b0 <_pal_lld_init+0x80>)
 8008060:	4619      	mov	r1, r3
 8008062:	f7ff ffb5 	bl	8007fd0 <initgpio>
#endif
#if STM32_HAS_GPIOD
  initgpio(GPIOD, &config->PDData);
 8008066:	9b01      	ldr	r3, [sp, #4]
 8008068:	336c      	adds	r3, #108	; 0x6c
 800806a:	4812      	ldr	r0, [pc, #72]	; (80080b4 <_pal_lld_init+0x84>)
 800806c:	4619      	mov	r1, r3
 800806e:	f7ff ffaf 	bl	8007fd0 <initgpio>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
 8008072:	9b01      	ldr	r3, [sp, #4]
 8008074:	3390      	adds	r3, #144	; 0x90
 8008076:	4810      	ldr	r0, [pc, #64]	; (80080b8 <_pal_lld_init+0x88>)
 8008078:	4619      	mov	r1, r3
 800807a:	f7ff ffa9 	bl	8007fd0 <initgpio>
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
 800807e:	9b01      	ldr	r3, [sp, #4]
 8008080:	33b4      	adds	r3, #180	; 0xb4
 8008082:	480e      	ldr	r0, [pc, #56]	; (80080bc <_pal_lld_init+0x8c>)
 8008084:	4619      	mov	r1, r3
 8008086:	f7ff ffa3 	bl	8007fd0 <initgpio>
#endif
#if STM32_HAS_GPIOG
  initgpio(GPIOG, &config->PGData);
 800808a:	9b01      	ldr	r3, [sp, #4]
 800808c:	33d8      	adds	r3, #216	; 0xd8
 800808e:	480c      	ldr	r0, [pc, #48]	; (80080c0 <_pal_lld_init+0x90>)
 8008090:	4619      	mov	r1, r3
 8008092:	f7ff ff9d 	bl	8007fd0 <initgpio>
#endif
#if STM32_HAS_GPIOH
  initgpio(GPIOH, &config->PHData);
 8008096:	9b01      	ldr	r3, [sp, #4]
 8008098:	33fc      	adds	r3, #252	; 0xfc
 800809a:	480a      	ldr	r0, [pc, #40]	; (80080c4 <_pal_lld_init+0x94>)
 800809c:	4619      	mov	r1, r3
 800809e:	f7ff ff97 	bl	8007fd0 <initgpio>
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
 80080a2:	b003      	add	sp, #12
 80080a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80080a8:	40021000 	.word	0x40021000
 80080ac:	48000400 	.word	0x48000400
 80080b0:	48000800 	.word	0x48000800
 80080b4:	48000c00 	.word	0x48000c00
 80080b8:	48001000 	.word	0x48001000
 80080bc:	48001400 	.word	0x48001400
 80080c0:	48001800 	.word	0x48001800
 80080c4:	48001c00 	.word	0x48001c00
 80080c8:	f3af 8000 	nop.w
 80080cc:	f3af 8000 	nop.w

080080d0 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 80080d0:	b090      	sub	sp, #64	; 0x40
 80080d2:	9003      	str	r0, [sp, #12]
 80080d4:	9102      	str	r1, [sp, #8]
 80080d6:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 80080d8:	9b01      	ldr	r3, [sp, #4]
 80080da:	f003 0303 	and.w	r3, r3, #3
 80080de:	930f      	str	r3, [sp, #60]	; 0x3c
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 80080e0:	9b01      	ldr	r3, [sp, #4]
 80080e2:	f003 0304 	and.w	r3, r3, #4
 80080e6:	089b      	lsrs	r3, r3, #2
 80080e8:	930e      	str	r3, [sp, #56]	; 0x38
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 80080ea:	9b01      	ldr	r3, [sp, #4]
 80080ec:	f003 0318 	and.w	r3, r3, #24
 80080f0:	08db      	lsrs	r3, r3, #3
 80080f2:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 80080f4:	9b01      	ldr	r3, [sp, #4]
 80080f6:	f003 0360 	and.w	r3, r3, #96	; 0x60
 80080fa:	095b      	lsrs	r3, r3, #5
 80080fc:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 80080fe:	9b01      	ldr	r3, [sp, #4]
 8008100:	f403 63f0 	and.w	r3, r3, #1920	; 0x780
 8008104:	09db      	lsrs	r3, r3, #7
 8008106:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t ascr    = (mode & PAL_STM32_ASCR_MASK) >> 11;
 8008108:	9b01      	ldr	r3, [sp, #4]
 800810a:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800810e:	0adb      	lsrs	r3, r3, #11
 8008110:	9309      	str	r3, [sp, #36]	; 0x24
  uint32_t lockr   = (mode & PAL_STM32_LOCKR_MASK) >> 12;
 8008112:	9b01      	ldr	r3, [sp, #4]
 8008114:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8008118:	0b1b      	lsrs	r3, r3, #12
 800811a:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 800811c:	2300      	movs	r3, #0
 800811e:	930b      	str	r3, [sp, #44]	; 0x2c
  while (true) {
    if ((mask & 1) != 0) {
 8008120:	9b02      	ldr	r3, [sp, #8]
 8008122:	f003 0301 	and.w	r3, r3, #1
 8008126:	2b00      	cmp	r3, #0
 8008128:	f000 808a 	beq.w	8008240 <_pal_lld_setgroupmode+0x170>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 800812c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800812e:	f003 0307 	and.w	r3, r3, #7
 8008132:	009b      	lsls	r3, r3, #2
 8008134:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8008136:	fa02 f303 	lsl.w	r3, r2, r3
 800813a:	9307      	str	r3, [sp, #28]
      m1 = 1 << bit;
 800813c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800813e:	2201      	movs	r2, #1
 8008140:	fa02 f303 	lsl.w	r3, r2, r3
 8008144:	9306      	str	r3, [sp, #24]
      m2 = 3 << (bit * 2);
 8008146:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008148:	005b      	lsls	r3, r3, #1
 800814a:	2203      	movs	r2, #3
 800814c:	fa02 f303 	lsl.w	r3, r2, r3
 8008150:	9305      	str	r3, [sp, #20]
      m4 = 15 << ((bit & 7) * 4);
 8008152:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008154:	f003 0307 	and.w	r3, r3, #7
 8008158:	009b      	lsls	r3, r3, #2
 800815a:	220f      	movs	r2, #15
 800815c:	fa02 f303 	lsl.w	r3, r2, r3
 8008160:	9304      	str	r3, [sp, #16]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8008162:	9b03      	ldr	r3, [sp, #12]
 8008164:	685a      	ldr	r2, [r3, #4]
 8008166:	9b06      	ldr	r3, [sp, #24]
 8008168:	43db      	mvns	r3, r3
 800816a:	401a      	ands	r2, r3
 800816c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800816e:	431a      	orrs	r2, r3
 8008170:	9b03      	ldr	r3, [sp, #12]
 8008172:	605a      	str	r2, [r3, #4]
      port->ASCR    = (port->ASCR & ~m1) | ascr;
 8008174:	9b03      	ldr	r3, [sp, #12]
 8008176:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8008178:	9b06      	ldr	r3, [sp, #24]
 800817a:	43db      	mvns	r3, r3
 800817c:	401a      	ands	r2, r3
 800817e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008180:	431a      	orrs	r2, r3
 8008182:	9b03      	ldr	r3, [sp, #12]
 8008184:	62da      	str	r2, [r3, #44]	; 0x2c
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8008186:	9b03      	ldr	r3, [sp, #12]
 8008188:	689a      	ldr	r2, [r3, #8]
 800818a:	9b05      	ldr	r3, [sp, #20]
 800818c:	43db      	mvns	r3, r3
 800818e:	401a      	ands	r2, r3
 8008190:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8008192:	431a      	orrs	r2, r3
 8008194:	9b03      	ldr	r3, [sp, #12]
 8008196:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8008198:	9b03      	ldr	r3, [sp, #12]
 800819a:	68da      	ldr	r2, [r3, #12]
 800819c:	9b05      	ldr	r3, [sp, #20]
 800819e:	43db      	mvns	r3, r3
 80081a0:	401a      	ands	r2, r3
 80081a2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80081a4:	431a      	orrs	r2, r3
 80081a6:	9b03      	ldr	r3, [sp, #12]
 80081a8:	60da      	str	r2, [r3, #12]
       if (moder == PAL_STM32_MODE_ALTERNATE) {
 80081aa:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80081ac:	2b02      	cmp	r3, #2
 80081ae:	d11f      	bne.n	80081f0 <_pal_lld_setgroupmode+0x120>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 80081b0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80081b2:	2b07      	cmp	r3, #7
 80081b4:	d809      	bhi.n	80081ca <_pal_lld_setgroupmode+0xfa>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80081b6:	9b03      	ldr	r3, [sp, #12]
 80081b8:	6a1a      	ldr	r2, [r3, #32]
 80081ba:	9b04      	ldr	r3, [sp, #16]
 80081bc:	43db      	mvns	r3, r3
 80081be:	401a      	ands	r2, r3
 80081c0:	9b07      	ldr	r3, [sp, #28]
 80081c2:	431a      	orrs	r2, r3
 80081c4:	9b03      	ldr	r3, [sp, #12]
 80081c6:	621a      	str	r2, [r3, #32]
 80081c8:	e008      	b.n	80081dc <_pal_lld_setgroupmode+0x10c>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80081ca:	9b03      	ldr	r3, [sp, #12]
 80081cc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80081ce:	9b04      	ldr	r3, [sp, #16]
 80081d0:	43db      	mvns	r3, r3
 80081d2:	401a      	ands	r2, r3
 80081d4:	9b07      	ldr	r3, [sp, #28]
 80081d6:	431a      	orrs	r2, r3
 80081d8:	9b03      	ldr	r3, [sp, #12]
 80081da:	625a      	str	r2, [r3, #36]	; 0x24
        port->MODER   = (port->MODER & ~m2) | moder;
 80081dc:	9b03      	ldr	r3, [sp, #12]
 80081de:	681a      	ldr	r2, [r3, #0]
 80081e0:	9b05      	ldr	r3, [sp, #20]
 80081e2:	43db      	mvns	r3, r3
 80081e4:	401a      	ands	r2, r3
 80081e6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80081e8:	431a      	orrs	r2, r3
 80081ea:	9b03      	ldr	r3, [sp, #12]
 80081ec:	601a      	str	r2, [r3, #0]
 80081ee:	e01e      	b.n	800822e <_pal_lld_setgroupmode+0x15e>
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 80081f0:	9b03      	ldr	r3, [sp, #12]
 80081f2:	681a      	ldr	r2, [r3, #0]
 80081f4:	9b05      	ldr	r3, [sp, #20]
 80081f6:	43db      	mvns	r3, r3
 80081f8:	401a      	ands	r2, r3
 80081fa:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80081fc:	431a      	orrs	r2, r3
 80081fe:	9b03      	ldr	r3, [sp, #12]
 8008200:	601a      	str	r2, [r3, #0]
        if (bit < 8)
 8008202:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008204:	2b07      	cmp	r3, #7
 8008206:	d809      	bhi.n	800821c <_pal_lld_setgroupmode+0x14c>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8008208:	9b03      	ldr	r3, [sp, #12]
 800820a:	6a1a      	ldr	r2, [r3, #32]
 800820c:	9b04      	ldr	r3, [sp, #16]
 800820e:	43db      	mvns	r3, r3
 8008210:	401a      	ands	r2, r3
 8008212:	9b07      	ldr	r3, [sp, #28]
 8008214:	431a      	orrs	r2, r3
 8008216:	9b03      	ldr	r3, [sp, #12]
 8008218:	621a      	str	r2, [r3, #32]
 800821a:	e008      	b.n	800822e <_pal_lld_setgroupmode+0x15e>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 800821c:	9b03      	ldr	r3, [sp, #12]
 800821e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8008220:	9b04      	ldr	r3, [sp, #16]
 8008222:	43db      	mvns	r3, r3
 8008224:	401a      	ands	r2, r3
 8008226:	9b07      	ldr	r3, [sp, #28]
 8008228:	431a      	orrs	r2, r3
 800822a:	9b03      	ldr	r3, [sp, #12]
 800822c:	625a      	str	r2, [r3, #36]	; 0x24
      }
      port->LOCKR   = (port->LOCKR & ~m1) | lockr;
 800822e:	9b03      	ldr	r3, [sp, #12]
 8008230:	69da      	ldr	r2, [r3, #28]
 8008232:	9b06      	ldr	r3, [sp, #24]
 8008234:	43db      	mvns	r3, r3
 8008236:	401a      	ands	r2, r3
 8008238:	9b08      	ldr	r3, [sp, #32]
 800823a:	431a      	orrs	r2, r3
 800823c:	9b03      	ldr	r3, [sp, #12]
 800823e:	61da      	str	r2, [r3, #28]
    }
    mask >>= 1;
 8008240:	9b02      	ldr	r3, [sp, #8]
 8008242:	085b      	lsrs	r3, r3, #1
 8008244:	9302      	str	r3, [sp, #8]
    if (!mask)
 8008246:	9b02      	ldr	r3, [sp, #8]
 8008248:	2b00      	cmp	r3, #0
 800824a:	d100      	bne.n	800824e <_pal_lld_setgroupmode+0x17e>
      return;
 800824c:	e00f      	b.n	800826e <_pal_lld_setgroupmode+0x19e>
    otyper <<= 1;
 800824e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8008250:	005b      	lsls	r3, r3, #1
 8008252:	930e      	str	r3, [sp, #56]	; 0x38
    ospeedr <<= 2;
 8008254:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8008256:	009b      	lsls	r3, r3, #2
 8008258:	930d      	str	r3, [sp, #52]	; 0x34
    pupdr <<= 2;
 800825a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800825c:	009b      	lsls	r3, r3, #2
 800825e:	930c      	str	r3, [sp, #48]	; 0x30
    moder <<= 2;
 8008260:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8008262:	009b      	lsls	r3, r3, #2
 8008264:	930f      	str	r3, [sp, #60]	; 0x3c
    bit++;
 8008266:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008268:	3301      	adds	r3, #1
 800826a:	930b      	str	r3, [sp, #44]	; 0x2c
  }
 800826c:	e758      	b.n	8008120 <_pal_lld_setgroupmode+0x50>
}
 800826e:	b010      	add	sp, #64	; 0x40
 8008270:	4770      	bx	lr
 8008272:	bf00      	nop
 8008274:	f3af 8000 	nop.w
 8008278:	f3af 8000 	nop.w
 800827c:	f3af 8000 	nop.w

08008280 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8008280:	b082      	sub	sp, #8
 8008282:	2320      	movs	r3, #32
 8008284:	9301      	str	r3, [sp, #4]
 8008286:	9b01      	ldr	r3, [sp, #4]
 8008288:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800828c:	b002      	add	sp, #8
 800828e:	4770      	bx	lr

08008290 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8008290:	b082      	sub	sp, #8
 8008292:	2300      	movs	r3, #0
 8008294:	9301      	str	r3, [sp, #4]
 8008296:	9b01      	ldr	r3, [sp, #4]
 8008298:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800829c:	b002      	add	sp, #8
 800829e:	4770      	bx	lr

080082a0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80082a0:	b508      	push	{r3, lr}

  port_lock();
 80082a2:	f7ff ffed 	bl	8008280 <port_lock>
}
 80082a6:	bd08      	pop	{r3, pc}
 80082a8:	f3af 8000 	nop.w
 80082ac:	f3af 8000 	nop.w

080082b0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 80082b0:	b508      	push	{r3, lr}

  port_unlock();
 80082b2:	f7ff ffed 	bl	8008290 <port_unlock>
}
 80082b6:	bd08      	pop	{r3, pc}
 80082b8:	f3af 8000 	nop.w
 80082bc:	f3af 8000 	nop.w

080082c0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80082c0:	b508      	push	{r3, lr}

  port_lock();
 80082c2:	f7ff ffdd 	bl	8008280 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80082c6:	bd08      	pop	{r3, pc}
 80082c8:	f3af 8000 	nop.w
 80082cc:	f3af 8000 	nop.w

080082d0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80082d0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80082d2:	f7ff ffdd 	bl	8008290 <port_unlock>
}
 80082d6:	bd08      	pop	{r3, pc}
 80082d8:	f3af 8000 	nop.w
 80082dc:	f3af 8000 	nop.w

080082e0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 80082e0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 80082e2:	f7ff ffdd 	bl	80082a0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 80082e6:	bd08      	pop	{r3, pc}
 80082e8:	f3af 8000 	nop.w
 80082ec:	f3af 8000 	nop.w

080082f0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80082f0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 80082f2:	f7ff ffdd 	bl	80082b0 <port_unlock_from_isr>
}
 80082f6:	bd08      	pop	{r3, pc}
 80082f8:	f3af 8000 	nop.w
 80082fc:	f3af 8000 	nop.w

08008300 <chThdStartI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
static inline thread_t *chThdStartI(thread_t *tp) {
 8008300:	b500      	push	{lr}
 8008302:	b083      	sub	sp, #12
 8008304:	9001      	str	r0, [sp, #4]

  chDbgAssert(tp->p_state == CH_STATE_WTSTART, "wrong state");

  return chSchReadyI(tp);
 8008306:	9801      	ldr	r0, [sp, #4]
 8008308:	f7f8 fc4a 	bl	8000ba0 <chSchReadyI>
 800830c:	4603      	mov	r3, r0
}
 800830e:	4618      	mov	r0, r3
 8008310:	b003      	add	sp, #12
 8008312:	f85d fb04 	ldr.w	pc, [sp], #4
 8008316:	bf00      	nop
 8008318:	f3af 8000 	nop.w
 800831c:	f3af 8000 	nop.w

08008320 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8008320:	b082      	sub	sp, #8
 8008322:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8008324:	4b02      	ldr	r3, [pc, #8]	; (8008330 <chRegSetThreadName+0x10>)
 8008326:	699b      	ldr	r3, [r3, #24]
 8008328:	9a01      	ldr	r2, [sp, #4]
 800832a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 800832c:	b002      	add	sp, #8
 800832e:	4770      	bx	lr
 8008330:	200016e0 	.word	0x200016e0
 8008334:	f3af 8000 	nop.w
 8008338:	f3af 8000 	nop.w
 800833c:	f3af 8000 	nop.w

08008340 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8008340:	b508      	push	{r3, lr}

  chSysLock();
 8008342:	f7ff ffbd 	bl	80082c0 <chSysLock>
}
 8008346:	bd08      	pop	{r3, pc}
 8008348:	f3af 8000 	nop.w
 800834c:	f3af 8000 	nop.w

08008350 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8008350:	b508      	push	{r3, lr}

  chSysUnlock();
 8008352:	f7ff ffbd 	bl	80082d0 <chSysUnlock>
}
 8008356:	bd08      	pop	{r3, pc}
 8008358:	f3af 8000 	nop.w
 800835c:	f3af 8000 	nop.w

08008360 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8008360:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8008362:	f7ff ffbd 	bl	80082e0 <chSysLockFromISR>
}
 8008366:	bd08      	pop	{r3, pc}
 8008368:	f3af 8000 	nop.w
 800836c:	f3af 8000 	nop.w

08008370 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8008370:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8008372:	f7ff ffbd 	bl	80082f0 <chSysUnlockFromISR>
}
 8008376:	bd08      	pop	{r3, pc}
 8008378:	f3af 8000 	nop.w
 800837c:	f3af 8000 	nop.w

08008380 <osalSysPolledDelayX>:
 * @param[in] cycles    number of cycles
 *
 * @xclass
 */
#if PORT_SUPPORTS_RT || defined(__DOXYGEN__)
static inline void osalSysPolledDelayX(rtcnt_t cycles) {
 8008380:	b500      	push	{lr}
 8008382:	b083      	sub	sp, #12
 8008384:	9001      	str	r0, [sp, #4]

  chSysPolledDelayX(cycles);
 8008386:	9801      	ldr	r0, [sp, #4]
 8008388:	f7f8 faca 	bl	8000920 <chSysPolledDelayX>
}
 800838c:	b003      	add	sp, #12
 800838e:	f85d fb04 	ldr.w	pc, [sp], #4
 8008392:	bf00      	nop
 8008394:	f3af 8000 	nop.w
 8008398:	f3af 8000 	nop.w
 800839c:	f3af 8000 	nop.w

080083a0 <osalThreadSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 80083a0:	b500      	push	{lr}
 80083a2:	b083      	sub	sp, #12
 80083a4:	9001      	str	r0, [sp, #4]

  return chThdSuspendS(trp);
 80083a6:	9801      	ldr	r0, [sp, #4]
 80083a8:	f7f9 f852 	bl	8001450 <chThdSuspendS>
 80083ac:	4603      	mov	r3, r0
}
 80083ae:	4618      	mov	r0, r3
 80083b0:	b003      	add	sp, #12
 80083b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80083b6:	bf00      	nop
 80083b8:	f3af 8000 	nop.w
 80083bc:	f3af 8000 	nop.w

080083c0 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 80083c0:	b500      	push	{lr}
 80083c2:	b083      	sub	sp, #12
 80083c4:	9001      	str	r0, [sp, #4]
 80083c6:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
 80083c8:	9801      	ldr	r0, [sp, #4]
 80083ca:	9900      	ldr	r1, [sp, #0]
 80083cc:	f7f9 f878 	bl	80014c0 <chThdResumeI>
}
 80083d0:	b003      	add	sp, #12
 80083d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80083d6:	bf00      	nop
 80083d8:	f3af 8000 	nop.w
 80083dc:	f3af 8000 	nop.w

080083e0 <otg_core_reset>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void otg_core_reset(USBDriver *usbp) {
 80083e0:	b500      	push	{lr}
 80083e2:	b085      	sub	sp, #20
 80083e4:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 80083e6:	9b01      	ldr	r3, [sp, #4]
 80083e8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80083ea:	9303      	str	r3, [sp, #12]

  osalSysPolledDelayX(32);
 80083ec:	2020      	movs	r0, #32
 80083ee:	f7ff ffc7 	bl	8008380 <osalSysPolledDelayX>

  /* Core reset and delay of at least 3 PHY cycles.*/
  otgp->GRSTCTL = GRSTCTL_CSRST;
 80083f2:	9b03      	ldr	r3, [sp, #12]
 80083f4:	2201      	movs	r2, #1
 80083f6:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
 80083f8:	bf00      	nop
 80083fa:	9b03      	ldr	r3, [sp, #12]
 80083fc:	691b      	ldr	r3, [r3, #16]
 80083fe:	f003 0301 	and.w	r3, r3, #1
 8008402:	2b00      	cmp	r3, #0
 8008404:	d1f9      	bne.n	80083fa <otg_core_reset+0x1a>
    ;

  osalSysPolledDelayX(18);
 8008406:	2012      	movs	r0, #18
 8008408:	f7ff ffba 	bl	8008380 <osalSysPolledDelayX>

  /* Wait AHB idle condition.*/
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 800840c:	bf00      	nop
 800840e:	9b03      	ldr	r3, [sp, #12]
 8008410:	691b      	ldr	r3, [r3, #16]
 8008412:	2b00      	cmp	r3, #0
 8008414:	dafb      	bge.n	800840e <otg_core_reset+0x2e>
    ;
}
 8008416:	b005      	add	sp, #20
 8008418:	f85d fb04 	ldr.w	pc, [sp], #4
 800841c:	f3af 8000 	nop.w

08008420 <otg_disable_ep>:

static void otg_disable_ep(USBDriver *usbp) {
 8008420:	b084      	sub	sp, #16
 8008422:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8008424:	9b01      	ldr	r3, [sp, #4]
 8008426:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008428:	9302      	str	r3, [sp, #8]
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800842a:	2300      	movs	r3, #0
 800842c:	9303      	str	r3, [sp, #12]
 800842e:	e032      	b.n	8008496 <otg_disable_ep+0x76>
    otgp->ie[i].DIEPCTL = 0;
 8008430:	9a02      	ldr	r2, [sp, #8]
 8008432:	9b03      	ldr	r3, [sp, #12]
 8008434:	3348      	adds	r3, #72	; 0x48
 8008436:	015b      	lsls	r3, r3, #5
 8008438:	4413      	add	r3, r2
 800843a:	2200      	movs	r2, #0
 800843c:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPTSIZ = 0;
 800843e:	9a02      	ldr	r2, [sp, #8]
 8008440:	9b03      	ldr	r3, [sp, #12]
 8008442:	015b      	lsls	r3, r3, #5
 8008444:	4413      	add	r3, r2
 8008446:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 800844a:	2200      	movs	r2, #0
 800844c:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800844e:	9a02      	ldr	r2, [sp, #8]
 8008450:	9b03      	ldr	r3, [sp, #12]
 8008452:	015b      	lsls	r3, r3, #5
 8008454:	4413      	add	r3, r2
 8008456:	f603 1308 	addw	r3, r3, #2312	; 0x908
 800845a:	f04f 32ff 	mov.w	r2, #4294967295
 800845e:	601a      	str	r2, [r3, #0]

    otgp->oe[i].DOEPCTL = 0;
 8008460:	9a02      	ldr	r2, [sp, #8]
 8008462:	9b03      	ldr	r3, [sp, #12]
 8008464:	3358      	adds	r3, #88	; 0x58
 8008466:	015b      	lsls	r3, r3, #5
 8008468:	4413      	add	r3, r2
 800846a:	2200      	movs	r2, #0
 800846c:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPTSIZ = 0;
 800846e:	9a02      	ldr	r2, [sp, #8]
 8008470:	9b03      	ldr	r3, [sp, #12]
 8008472:	015b      	lsls	r3, r3, #5
 8008474:	4413      	add	r3, r2
 8008476:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 800847a:	2200      	movs	r2, #0
 800847c:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 800847e:	9a02      	ldr	r2, [sp, #8]
 8008480:	9b03      	ldr	r3, [sp, #12]
 8008482:	015b      	lsls	r3, r3, #5
 8008484:	4413      	add	r3, r2
 8008486:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 800848a:	f04f 32ff 	mov.w	r2, #4294967295
 800848e:	601a      	str	r2, [r3, #0]

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8008490:	9b03      	ldr	r3, [sp, #12]
 8008492:	3301      	adds	r3, #1
 8008494:	9303      	str	r3, [sp, #12]
 8008496:	9b01      	ldr	r3, [sp, #4]
 8008498:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800849a:	689a      	ldr	r2, [r3, #8]
 800849c:	9b03      	ldr	r3, [sp, #12]
 800849e:	429a      	cmp	r2, r3
 80084a0:	d2c6      	bcs.n	8008430 <otg_disable_ep+0x10>

    otgp->oe[i].DOEPCTL = 0;
    otgp->oe[i].DOEPTSIZ = 0;
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  }
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 80084a2:	9b02      	ldr	r3, [sp, #8]
 80084a4:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 80084a8:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
}
 80084ac:	b004      	add	sp, #16
 80084ae:	4770      	bx	lr

080084b0 <otg_rxfifo_flush>:

static void otg_rxfifo_flush(USBDriver *usbp) {
 80084b0:	b500      	push	{lr}
 80084b2:	b085      	sub	sp, #20
 80084b4:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 80084b6:	9b01      	ldr	r3, [sp, #4]
 80084b8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80084ba:	9303      	str	r3, [sp, #12]

  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 80084bc:	9b03      	ldr	r3, [sp, #12]
 80084be:	2210      	movs	r2, #16
 80084c0:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 80084c2:	bf00      	nop
 80084c4:	9b03      	ldr	r3, [sp, #12]
 80084c6:	691b      	ldr	r3, [r3, #16]
 80084c8:	f003 0310 	and.w	r3, r3, #16
 80084cc:	2b00      	cmp	r3, #0
 80084ce:	d1f9      	bne.n	80084c4 <otg_rxfifo_flush+0x14>
    ;
  /* Wait for 3 PHY Clocks.*/
  osalSysPolledDelayX(18);
 80084d0:	2012      	movs	r0, #18
 80084d2:	f7ff ff55 	bl	8008380 <osalSysPolledDelayX>
}
 80084d6:	b005      	add	sp, #20
 80084d8:	f85d fb04 	ldr.w	pc, [sp], #4
 80084dc:	f3af 8000 	nop.w

080084e0 <otg_txfifo_flush>:

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
 80084e0:	b500      	push	{lr}
 80084e2:	b085      	sub	sp, #20
 80084e4:	9001      	str	r0, [sp, #4]
 80084e6:	9100      	str	r1, [sp, #0]
  stm32_otg_t *otgp = usbp->otg;
 80084e8:	9b01      	ldr	r3, [sp, #4]
 80084ea:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80084ec:	9303      	str	r3, [sp, #12]

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 80084ee:	9b00      	ldr	r3, [sp, #0]
 80084f0:	019b      	lsls	r3, r3, #6
 80084f2:	f043 0220 	orr.w	r2, r3, #32
 80084f6:	9b03      	ldr	r3, [sp, #12]
 80084f8:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 80084fa:	bf00      	nop
 80084fc:	9b03      	ldr	r3, [sp, #12]
 80084fe:	691b      	ldr	r3, [r3, #16]
 8008500:	f003 0320 	and.w	r3, r3, #32
 8008504:	2b00      	cmp	r3, #0
 8008506:	d1f9      	bne.n	80084fc <otg_txfifo_flush+0x1c>
    ;
  /* Wait for 3 PHY Clocks.*/
  osalSysPolledDelayX(18);
 8008508:	2012      	movs	r0, #18
 800850a:	f7ff ff39 	bl	8008380 <osalSysPolledDelayX>
}
 800850e:	b005      	add	sp, #20
 8008510:	f85d fb04 	ldr.w	pc, [sp], #4
 8008514:	f3af 8000 	nop.w
 8008518:	f3af 8000 	nop.w
 800851c:	f3af 8000 	nop.w

08008520 <otg_ram_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_ram_reset(USBDriver *usbp) {
 8008520:	b082      	sub	sp, #8
 8008522:	9001      	str	r0, [sp, #4]

  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8008524:	9b01      	ldr	r3, [sp, #4]
 8008526:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008528:	681a      	ldr	r2, [r3, #0]
 800852a:	9b01      	ldr	r3, [sp, #4]
 800852c:	675a      	str	r2, [r3, #116]	; 0x74
}
 800852e:	b002      	add	sp, #8
 8008530:	4770      	bx	lr
 8008532:	bf00      	nop
 8008534:	f3af 8000 	nop.w
 8008538:	f3af 8000 	nop.w
 800853c:	f3af 8000 	nop.w

08008540 <otg_ram_alloc>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] size      size of the packet buffer to allocate in words
 *
 * @notapi
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
 8008540:	b084      	sub	sp, #16
 8008542:	9001      	str	r0, [sp, #4]
 8008544:	9100      	str	r1, [sp, #0]
  uint32_t next;

  next = usbp->pmnext;
 8008546:	9b01      	ldr	r3, [sp, #4]
 8008548:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800854a:	9303      	str	r3, [sp, #12]
  usbp->pmnext += size;
 800854c:	9b01      	ldr	r3, [sp, #4]
 800854e:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8008550:	9b00      	ldr	r3, [sp, #0]
 8008552:	441a      	add	r2, r3
 8008554:	9b01      	ldr	r3, [sp, #4]
 8008556:	675a      	str	r2, [r3, #116]	; 0x74
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
                "OTG FIFO memory overflow");
  return next;
 8008558:	9b03      	ldr	r3, [sp, #12]
}
 800855a:	4618      	mov	r0, r3
 800855c:	b004      	add	sp, #16
 800855e:	4770      	bx	lr

08008560 <otg_fifo_write_from_buffer>:
 *
 * @notapi
 */
static void otg_fifo_write_from_buffer(volatile uint32_t *fifop,
                                       const uint8_t *buf,
                                       size_t n) {
 8008560:	b084      	sub	sp, #16
 8008562:	9003      	str	r0, [sp, #12]
 8008564:	9102      	str	r1, [sp, #8]
 8008566:	9201      	str	r2, [sp, #4]

  osalDbgAssert(n > 0, "is zero");

  while (true) {
    *fifop = *((uint32_t *)buf);
 8008568:	9b02      	ldr	r3, [sp, #8]
 800856a:	681a      	ldr	r2, [r3, #0]
 800856c:	9b03      	ldr	r3, [sp, #12]
 800856e:	601a      	str	r2, [r3, #0]
    if (n <= 4) {
 8008570:	9b01      	ldr	r3, [sp, #4]
 8008572:	2b04      	cmp	r3, #4
 8008574:	d800      	bhi.n	8008578 <otg_fifo_write_from_buffer+0x18>
      break;
 8008576:	e006      	b.n	8008586 <otg_fifo_write_from_buffer+0x26>
    }
    n -= 4;
 8008578:	9b01      	ldr	r3, [sp, #4]
 800857a:	3b04      	subs	r3, #4
 800857c:	9301      	str	r3, [sp, #4]
    buf += 4;
 800857e:	9b02      	ldr	r3, [sp, #8]
 8008580:	3304      	adds	r3, #4
 8008582:	9302      	str	r3, [sp, #8]
  }
 8008584:	e7f0      	b.n	8008568 <otg_fifo_write_from_buffer+0x8>
}
 8008586:	b004      	add	sp, #16
 8008588:	4770      	bx	lr
 800858a:	bf00      	nop
 800858c:	f3af 8000 	nop.w

08008590 <otg_fifo_read_to_buffer>:
 * @notapi
 */
static void otg_fifo_read_to_buffer(volatile uint32_t *fifop,
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {
 8008590:	b086      	sub	sp, #24
 8008592:	9003      	str	r0, [sp, #12]
 8008594:	9102      	str	r1, [sp, #8]
 8008596:	9201      	str	r2, [sp, #4]
 8008598:	9300      	str	r3, [sp, #0]
  uint32_t w = 0;
 800859a:	2300      	movs	r3, #0
 800859c:	9305      	str	r3, [sp, #20]
  size_t i = 0;
 800859e:	2300      	movs	r3, #0
 80085a0:	9304      	str	r3, [sp, #16]

  while (i < n) {
 80085a2:	e017      	b.n	80085d4 <otg_fifo_read_to_buffer+0x44>
    if ((i & 3) == 0){
 80085a4:	9b04      	ldr	r3, [sp, #16]
 80085a6:	f003 0303 	and.w	r3, r3, #3
 80085aa:	2b00      	cmp	r3, #0
 80085ac:	d102      	bne.n	80085b4 <otg_fifo_read_to_buffer+0x24>
      w = *fifop;
 80085ae:	9b03      	ldr	r3, [sp, #12]
 80085b0:	681b      	ldr	r3, [r3, #0]
 80085b2:	9305      	str	r3, [sp, #20]
    }
    if (i < max) {
 80085b4:	9a04      	ldr	r2, [sp, #16]
 80085b6:	9b00      	ldr	r3, [sp, #0]
 80085b8:	429a      	cmp	r2, r3
 80085ba:	d208      	bcs.n	80085ce <otg_fifo_read_to_buffer+0x3e>
      *buf++ = (uint8_t)w;
 80085bc:	9b02      	ldr	r3, [sp, #8]
 80085be:	1c5a      	adds	r2, r3, #1
 80085c0:	9202      	str	r2, [sp, #8]
 80085c2:	9a05      	ldr	r2, [sp, #20]
 80085c4:	b2d2      	uxtb	r2, r2
 80085c6:	701a      	strb	r2, [r3, #0]
      w >>= 8;
 80085c8:	9b05      	ldr	r3, [sp, #20]
 80085ca:	0a1b      	lsrs	r3, r3, #8
 80085cc:	9305      	str	r3, [sp, #20]
    }
    i++;
 80085ce:	9b04      	ldr	r3, [sp, #16]
 80085d0:	3301      	adds	r3, #1
 80085d2:	9304      	str	r3, [sp, #16]
                                    size_t n,
                                    size_t max) {
  uint32_t w = 0;
  size_t i = 0;

  while (i < n) {
 80085d4:	9a04      	ldr	r2, [sp, #16]
 80085d6:	9b01      	ldr	r3, [sp, #4]
 80085d8:	429a      	cmp	r2, r3
 80085da:	d3e3      	bcc.n	80085a4 <otg_fifo_read_to_buffer+0x14>
      *buf++ = (uint8_t)w;
      w >>= 8;
    }
    i++;
  }
}
 80085dc:	b006      	add	sp, #24
 80085de:	4770      	bx	lr

080085e0 <otg_rxfifo_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_rxfifo_handler(USBDriver *usbp) {
 80085e0:	b510      	push	{r4, lr}
 80085e2:	b086      	sub	sp, #24
 80085e4:	9001      	str	r0, [sp, #4]
  uint32_t sts, cnt, ep;

  sts = usbp->otg->GRXSTSP;
 80085e6:	9b01      	ldr	r3, [sp, #4]
 80085e8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80085ea:	6a1b      	ldr	r3, [r3, #32]
 80085ec:	9305      	str	r3, [sp, #20]
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 80085ee:	9b05      	ldr	r3, [sp, #20]
 80085f0:	f403 13f0 	and.w	r3, r3, #1966080	; 0x1e0000
 80085f4:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 80085f8:	d074      	beq.n	80086e4 <otg_rxfifo_handler+0x104>
 80085fa:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
 80085fe:	d003      	beq.n	8008608 <otg_rxfifo_handler+0x28>
 8008600:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8008604:	d01c      	beq.n	8008640 <otg_rxfifo_handler+0x60>
 8008606:	e06e      	b.n	80086e6 <otg_rxfifo_handler+0x106>
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_SETUP_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8008608:	9a05      	ldr	r2, [sp, #20]
 800860a:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 800860e:	4013      	ands	r3, r2
 8008610:	091b      	lsrs	r3, r3, #4
 8008612:	9304      	str	r3, [sp, #16]
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 8008614:	9b05      	ldr	r3, [sp, #20]
 8008616:	f003 030f 	and.w	r3, r3, #15
 800861a:	9303      	str	r3, [sp, #12]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 800861c:	9b01      	ldr	r3, [sp, #4]
 800861e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008620:	f503 5280 	add.w	r2, r3, #4096	; 0x1000
 8008624:	9901      	ldr	r1, [sp, #4]
 8008626:	9b03      	ldr	r3, [sp, #12]
 8008628:	3302      	adds	r3, #2
 800862a:	009b      	lsls	r3, r3, #2
 800862c:	440b      	add	r3, r1
 800862e:	685b      	ldr	r3, [r3, #4]
 8008630:	6a1b      	ldr	r3, [r3, #32]
 8008632:	4610      	mov	r0, r2
 8008634:	4619      	mov	r1, r3
 8008636:	9a04      	ldr	r2, [sp, #16]
 8008638:	2308      	movs	r3, #8
 800863a:	f7ff ffa9 	bl	8008590 <otg_fifo_read_to_buffer>
                            cnt, 8);
    break;
 800863e:	e052      	b.n	80086e6 <otg_rxfifo_handler+0x106>
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8008640:	9a05      	ldr	r2, [sp, #20]
 8008642:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 8008646:	4013      	ands	r3, r2
 8008648:	091b      	lsrs	r3, r3, #4
 800864a:	9304      	str	r3, [sp, #16]
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 800864c:	9b05      	ldr	r3, [sp, #20]
 800864e:	f003 030f 	and.w	r3, r3, #15
 8008652:	9303      	str	r3, [sp, #12]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 8008654:	9b01      	ldr	r3, [sp, #4]
 8008656:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008658:	f503 5180 	add.w	r1, r3, #4096	; 0x1000
                            usbp->epc[ep]->out_state->rxbuf,
 800865c:	9a01      	ldr	r2, [sp, #4]
 800865e:	9b03      	ldr	r3, [sp, #12]
 8008660:	3302      	adds	r3, #2
 8008662:	009b      	lsls	r3, r3, #2
 8008664:	4413      	add	r3, r2
 8008666:	685b      	ldr	r3, [r3, #4]
 8008668:	699b      	ldr	r3, [r3, #24]
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 800866a:	689a      	ldr	r2, [r3, #8]
                            usbp->epc[ep]->out_state->rxbuf,
                            cnt,
                            usbp->epc[ep]->out_state->rxsize -
 800866c:	9801      	ldr	r0, [sp, #4]
 800866e:	9b03      	ldr	r3, [sp, #12]
 8008670:	3302      	adds	r3, #2
 8008672:	009b      	lsls	r3, r3, #2
 8008674:	4403      	add	r3, r0
 8008676:	685b      	ldr	r3, [r3, #4]
 8008678:	699b      	ldr	r3, [r3, #24]
 800867a:	6818      	ldr	r0, [r3, #0]
                            usbp->epc[ep]->out_state->rxcnt);
 800867c:	9c01      	ldr	r4, [sp, #4]
 800867e:	9b03      	ldr	r3, [sp, #12]
 8008680:	3302      	adds	r3, #2
 8008682:	009b      	lsls	r3, r3, #2
 8008684:	4423      	add	r3, r4
 8008686:	685b      	ldr	r3, [r3, #4]
 8008688:	699b      	ldr	r3, [r3, #24]
 800868a:	685b      	ldr	r3, [r3, #4]
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 800868c:	1ac3      	subs	r3, r0, r3
 800868e:	4608      	mov	r0, r1
 8008690:	4611      	mov	r1, r2
 8008692:	9a04      	ldr	r2, [sp, #16]
 8008694:	f7ff ff7c 	bl	8008590 <otg_fifo_read_to_buffer>
                            usbp->epc[ep]->out_state->rxbuf,
                            cnt,
                            usbp->epc[ep]->out_state->rxsize -
                            usbp->epc[ep]->out_state->rxcnt);
    usbp->epc[ep]->out_state->rxbuf += cnt;
 8008698:	9a01      	ldr	r2, [sp, #4]
 800869a:	9b03      	ldr	r3, [sp, #12]
 800869c:	3302      	adds	r3, #2
 800869e:	009b      	lsls	r3, r3, #2
 80086a0:	4413      	add	r3, r2
 80086a2:	685b      	ldr	r3, [r3, #4]
 80086a4:	699a      	ldr	r2, [r3, #24]
 80086a6:	9901      	ldr	r1, [sp, #4]
 80086a8:	9b03      	ldr	r3, [sp, #12]
 80086aa:	3302      	adds	r3, #2
 80086ac:	009b      	lsls	r3, r3, #2
 80086ae:	440b      	add	r3, r1
 80086b0:	685b      	ldr	r3, [r3, #4]
 80086b2:	699b      	ldr	r3, [r3, #24]
 80086b4:	6899      	ldr	r1, [r3, #8]
 80086b6:	9b04      	ldr	r3, [sp, #16]
 80086b8:	440b      	add	r3, r1
 80086ba:	6093      	str	r3, [r2, #8]
    usbp->epc[ep]->out_state->rxcnt += cnt;
 80086bc:	9a01      	ldr	r2, [sp, #4]
 80086be:	9b03      	ldr	r3, [sp, #12]
 80086c0:	3302      	adds	r3, #2
 80086c2:	009b      	lsls	r3, r3, #2
 80086c4:	4413      	add	r3, r2
 80086c6:	685b      	ldr	r3, [r3, #4]
 80086c8:	699a      	ldr	r2, [r3, #24]
 80086ca:	9901      	ldr	r1, [sp, #4]
 80086cc:	9b03      	ldr	r3, [sp, #12]
 80086ce:	3302      	adds	r3, #2
 80086d0:	009b      	lsls	r3, r3, #2
 80086d2:	440b      	add	r3, r1
 80086d4:	685b      	ldr	r3, [r3, #4]
 80086d6:	699b      	ldr	r3, [r3, #24]
 80086d8:	6859      	ldr	r1, [r3, #4]
 80086da:	9b04      	ldr	r3, [sp, #16]
 80086dc:	440b      	add	r3, r1
 80086de:	6053      	str	r3, [r2, #4]
    break;
 80086e0:	bf00      	nop
 80086e2:	e000      	b.n	80086e6 <otg_rxfifo_handler+0x106>
  uint32_t sts, cnt, ep;

  sts = usbp->otg->GRXSTSP;
  switch (sts & GRXSTSP_PKTSTS_MASK) {
  case GRXSTSP_SETUP_COMP:
    break;
 80086e4:	bf00      	nop
  case GRXSTSP_OUT_GLOBAL_NAK:
  case GRXSTSP_OUT_COMP:
  default:
    ;
  }
}
 80086e6:	b006      	add	sp, #24
 80086e8:	bd10      	pop	{r4, pc}
 80086ea:	bf00      	nop
 80086ec:	f3af 8000 	nop.w

080086f0 <otg_txfifo_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static bool otg_txfifo_handler(USBDriver *usbp, usbep_t ep) {
 80086f0:	b500      	push	{lr}
 80086f2:	b085      	sub	sp, #20
 80086f4:	9001      	str	r0, [sp, #4]
 80086f6:	460b      	mov	r3, r1
 80086f8:	f88d 3003 	strb.w	r3, [sp, #3]
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (true) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 80086fc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008700:	9a01      	ldr	r2, [sp, #4]
 8008702:	3302      	adds	r3, #2
 8008704:	009b      	lsls	r3, r3, #2
 8008706:	4413      	add	r3, r2
 8008708:	685b      	ldr	r3, [r3, #4]
 800870a:	695b      	ldr	r3, [r3, #20]
 800870c:	685a      	ldr	r2, [r3, #4]
 800870e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008712:	9901      	ldr	r1, [sp, #4]
 8008714:	3302      	adds	r3, #2
 8008716:	009b      	lsls	r3, r3, #2
 8008718:	440b      	add	r3, r1
 800871a:	685b      	ldr	r3, [r3, #4]
 800871c:	695b      	ldr	r3, [r3, #20]
 800871e:	681b      	ldr	r3, [r3, #0]
 8008720:	429a      	cmp	r2, r3
 8008722:	d301      	bcc.n	8008728 <otg_txfifo_handler+0x38>
      return true;
 8008724:	2301      	movs	r3, #1
 8008726:	e076      	b.n	8008816 <otg_txfifo_handler+0x126>

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 8008728:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800872c:	9a01      	ldr	r2, [sp, #4]
 800872e:	3302      	adds	r3, #2
 8008730:	009b      	lsls	r3, r3, #2
 8008732:	4413      	add	r3, r2
 8008734:	685b      	ldr	r3, [r3, #4]
 8008736:	695b      	ldr	r3, [r3, #20]
 8008738:	681a      	ldr	r2, [r3, #0]
 800873a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800873e:	9901      	ldr	r1, [sp, #4]
 8008740:	3302      	adds	r3, #2
 8008742:	009b      	lsls	r3, r3, #2
 8008744:	440b      	add	r3, r1
 8008746:	685b      	ldr	r3, [r3, #4]
 8008748:	695b      	ldr	r3, [r3, #20]
 800874a:	685b      	ldr	r3, [r3, #4]
 800874c:	1ad3      	subs	r3, r2, r3
 800874e:	9303      	str	r3, [sp, #12]
    if (n > usbp->epc[ep]->in_maxsize)
 8008750:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008754:	9a01      	ldr	r2, [sp, #4]
 8008756:	3302      	adds	r3, #2
 8008758:	009b      	lsls	r3, r3, #2
 800875a:	4413      	add	r3, r2
 800875c:	685b      	ldr	r3, [r3, #4]
 800875e:	8a1b      	ldrh	r3, [r3, #16]
 8008760:	461a      	mov	r2, r3
 8008762:	9b03      	ldr	r3, [sp, #12]
 8008764:	429a      	cmp	r2, r3
 8008766:	d208      	bcs.n	800877a <otg_txfifo_handler+0x8a>
      n = usbp->epc[ep]->in_maxsize;
 8008768:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800876c:	9a01      	ldr	r2, [sp, #4]
 800876e:	3302      	adds	r3, #2
 8008770:	009b      	lsls	r3, r3, #2
 8008772:	4413      	add	r3, r2
 8008774:	685b      	ldr	r3, [r3, #4]
 8008776:	8a1b      	ldrh	r3, [r3, #16]
 8008778:	9303      	str	r3, [sp, #12]

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 800877a:	9b01      	ldr	r3, [sp, #4]
 800877c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800877e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008782:	015b      	lsls	r3, r3, #5
 8008784:	4413      	add	r3, r2
 8008786:	f603 1318 	addw	r3, r3, #2328	; 0x918
 800878a:	681b      	ldr	r3, [r3, #0]
 800878c:	b29b      	uxth	r3, r3
 800878e:	009a      	lsls	r2, r3, #2
 8008790:	9b03      	ldr	r3, [sp, #12]
 8008792:	429a      	cmp	r2, r3
 8008794:	d201      	bcs.n	800879a <otg_txfifo_handler+0xaa>
      return false;
 8008796:	2300      	movs	r3, #0
 8008798:	e03d      	b.n	8008816 <otg_txfifo_handler+0x126>

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 800879a:	9b01      	ldr	r3, [sp, #4]
 800879c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800879e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80087a2:	3301      	adds	r3, #1
 80087a4:	031b      	lsls	r3, r3, #12
 80087a6:	441a      	add	r2, r3
                               usbp->epc[ep]->in_state->txbuf,
 80087a8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80087ac:	9901      	ldr	r1, [sp, #4]
 80087ae:	3302      	adds	r3, #2
 80087b0:	009b      	lsls	r3, r3, #2
 80087b2:	440b      	add	r3, r1
 80087b4:	685b      	ldr	r3, [r3, #4]
 80087b6:	695b      	ldr	r3, [r3, #20]
      return false;

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 80087b8:	689b      	ldr	r3, [r3, #8]
 80087ba:	4610      	mov	r0, r2
 80087bc:	4619      	mov	r1, r3
 80087be:	9a03      	ldr	r2, [sp, #12]
 80087c0:	f7ff fece 	bl	8008560 <otg_fifo_write_from_buffer>
                               usbp->epc[ep]->in_state->txbuf,
                               n);
    usbp->epc[ep]->in_state->txbuf += n;
 80087c4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80087c8:	9a01      	ldr	r2, [sp, #4]
 80087ca:	3302      	adds	r3, #2
 80087cc:	009b      	lsls	r3, r3, #2
 80087ce:	4413      	add	r3, r2
 80087d0:	685b      	ldr	r3, [r3, #4]
 80087d2:	695a      	ldr	r2, [r3, #20]
 80087d4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80087d8:	9901      	ldr	r1, [sp, #4]
 80087da:	3302      	adds	r3, #2
 80087dc:	009b      	lsls	r3, r3, #2
 80087de:	440b      	add	r3, r1
 80087e0:	685b      	ldr	r3, [r3, #4]
 80087e2:	695b      	ldr	r3, [r3, #20]
 80087e4:	6899      	ldr	r1, [r3, #8]
 80087e6:	9b03      	ldr	r3, [sp, #12]
 80087e8:	440b      	add	r3, r1
 80087ea:	6093      	str	r3, [r2, #8]
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
    usbp->epc[ep]->in_state->txcnt += n;
 80087ec:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80087f0:	9a01      	ldr	r2, [sp, #4]
 80087f2:	3302      	adds	r3, #2
 80087f4:	009b      	lsls	r3, r3, #2
 80087f6:	4413      	add	r3, r2
 80087f8:	685b      	ldr	r3, [r3, #4]
 80087fa:	695a      	ldr	r2, [r3, #20]
 80087fc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008800:	9901      	ldr	r1, [sp, #4]
 8008802:	3302      	adds	r3, #2
 8008804:	009b      	lsls	r3, r3, #2
 8008806:	440b      	add	r3, r1
 8008808:	685b      	ldr	r3, [r3, #4]
 800880a:	695b      	ldr	r3, [r3, #20]
 800880c:	6859      	ldr	r1, [r3, #4]
 800880e:	9b03      	ldr	r3, [sp, #12]
 8008810:	440b      	add	r3, r1
 8008812:	6053      	str	r3, [r2, #4]
  }
 8008814:	e772      	b.n	80086fc <otg_txfifo_handler+0xc>
}
 8008816:	4618      	mov	r0, r3
 8008818:	b005      	add	sp, #20
 800881a:	f85d fb04 	ldr.w	pc, [sp], #4
 800881e:	bf00      	nop

08008820 <otg_epin_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8008820:	b500      	push	{lr}
 8008822:	b087      	sub	sp, #28
 8008824:	9001      	str	r0, [sp, #4]
 8008826:	460b      	mov	r3, r1
 8008828:	f88d 3003 	strb.w	r3, [sp, #3]
  stm32_otg_t *otgp = usbp->otg;
 800882c:	9b01      	ldr	r3, [sp, #4]
 800882e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008830:	9305      	str	r3, [sp, #20]
  uint32_t epint = otgp->ie[ep].DIEPINT;
 8008832:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008836:	9a05      	ldr	r2, [sp, #20]
 8008838:	015b      	lsls	r3, r3, #5
 800883a:	4413      	add	r3, r2
 800883c:	f603 1308 	addw	r3, r3, #2312	; 0x908
 8008840:	681b      	ldr	r3, [r3, #0]
 8008842:	9304      	str	r3, [sp, #16]

  otgp->ie[ep].DIEPINT = epint;
 8008844:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008848:	9a05      	ldr	r2, [sp, #20]
 800884a:	015b      	lsls	r3, r3, #5
 800884c:	4413      	add	r3, r2
 800884e:	f603 1308 	addw	r3, r3, #2312	; 0x908
 8008852:	9a04      	ldr	r2, [sp, #16]
 8008854:	601a      	str	r2, [r3, #0]

  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8008856:	9b04      	ldr	r3, [sp, #16]
 8008858:	f003 0301 	and.w	r3, r3, #1
 800885c:	2b00      	cmp	r3, #0
 800885e:	d051      	beq.n	8008904 <otg_epin_handler+0xe4>
 8008860:	9b05      	ldr	r3, [sp, #20]
 8008862:	f8d3 3810 	ldr.w	r3, [r3, #2064]	; 0x810
 8008866:	f003 0301 	and.w	r3, r3, #1
 800886a:	2b00      	cmp	r3, #0
 800886c:	d04a      	beq.n	8008904 <otg_epin_handler+0xe4>
    /* Transmit transfer complete.*/
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800886e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008872:	9a01      	ldr	r2, [sp, #4]
 8008874:	3302      	adds	r3, #2
 8008876:	009b      	lsls	r3, r3, #2
 8008878:	4413      	add	r3, r2
 800887a:	685b      	ldr	r3, [r3, #4]
 800887c:	695b      	ldr	r3, [r3, #20]
 800887e:	9303      	str	r3, [sp, #12]

    if (isp->txsize < isp->totsize) {
 8008880:	9b03      	ldr	r3, [sp, #12]
 8008882:	681a      	ldr	r2, [r3, #0]
 8008884:	9b03      	ldr	r3, [sp, #12]
 8008886:	68db      	ldr	r3, [r3, #12]
 8008888:	429a      	cmp	r2, r3
 800888a:	d214      	bcs.n	80088b6 <otg_epin_handler+0x96>
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      isp->txsize = isp->totsize - isp->txsize;
 800888c:	9b03      	ldr	r3, [sp, #12]
 800888e:	68da      	ldr	r2, [r3, #12]
 8008890:	9b03      	ldr	r3, [sp, #12]
 8008892:	681b      	ldr	r3, [r3, #0]
 8008894:	1ad2      	subs	r2, r2, r3
 8008896:	9b03      	ldr	r3, [sp, #12]
 8008898:	601a      	str	r2, [r3, #0]
      isp->txcnt  = 0;
 800889a:	9b03      	ldr	r3, [sp, #12]
 800889c:	2200      	movs	r2, #0
 800889e:	605a      	str	r2, [r3, #4]
      osalSysLockFromISR();
 80088a0:	f7ff fd5e 	bl	8008360 <osalSysLockFromISR>
      usb_lld_start_in(usbp, ep);
 80088a4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80088a8:	9801      	ldr	r0, [sp, #4]
 80088aa:	4619      	mov	r1, r3
 80088ac:	f000 fec0 	bl	8009630 <usb_lld_start_in>
      osalSysUnlockFromISR();
 80088b0:	f7ff fd5e 	bl	8008370 <osalSysUnlockFromISR>
 80088b4:	e026      	b.n	8008904 <otg_epin_handler+0xe4>
    }
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
 80088b6:	9b01      	ldr	r3, [sp, #4]
 80088b8:	891b      	ldrh	r3, [r3, #8]
 80088ba:	b29a      	uxth	r2, r3
 80088bc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80088c0:	2101      	movs	r1, #1
 80088c2:	fa01 f303 	lsl.w	r3, r1, r3
 80088c6:	b29b      	uxth	r3, r3
 80088c8:	43db      	mvns	r3, r3
 80088ca:	b29b      	uxth	r3, r3
 80088cc:	4013      	ands	r3, r2
 80088ce:	b29b      	uxth	r3, r3
 80088d0:	b29a      	uxth	r2, r3
 80088d2:	9b01      	ldr	r3, [sp, #4]
 80088d4:	811a      	strh	r2, [r3, #8]
 80088d6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80088da:	9a01      	ldr	r2, [sp, #4]
 80088dc:	3302      	adds	r3, #2
 80088de:	009b      	lsls	r3, r3, #2
 80088e0:	4413      	add	r3, r2
 80088e2:	685b      	ldr	r3, [r3, #4]
 80088e4:	689b      	ldr	r3, [r3, #8]
 80088e6:	2b00      	cmp	r3, #0
 80088e8:	d00c      	beq.n	8008904 <otg_epin_handler+0xe4>
 80088ea:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80088ee:	9a01      	ldr	r2, [sp, #4]
 80088f0:	3302      	adds	r3, #2
 80088f2:	009b      	lsls	r3, r3, #2
 80088f4:	4413      	add	r3, r2
 80088f6:	685b      	ldr	r3, [r3, #4]
 80088f8:	689b      	ldr	r3, [r3, #8]
 80088fa:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80088fe:	9801      	ldr	r0, [sp, #4]
 8008900:	4611      	mov	r1, r2
 8008902:	4798      	blx	r3
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 8008904:	9b04      	ldr	r3, [sp, #16]
 8008906:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800890a:	2b00      	cmp	r3, #0
 800890c:	d02b      	beq.n	8008966 <otg_epin_handler+0x146>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 800890e:	9b05      	ldr	r3, [sp, #20]
 8008910:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 8008914:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008918:	2101      	movs	r1, #1
 800891a:	fa01 f303 	lsl.w	r3, r1, r3
 800891e:	4013      	ands	r3, r2
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 8008920:	2b00      	cmp	r3, #0
 8008922:	d020      	beq.n	8008966 <otg_epin_handler+0x146>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
 8008924:	f7ff fd1c 	bl	8008360 <osalSysLockFromISR>
    usbp->txpending |= (1 << ep);
 8008928:	9b01      	ldr	r3, [sp, #4]
 800892a:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800892c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008930:	2101      	movs	r1, #1
 8008932:	fa01 f303 	lsl.w	r3, r1, r3
 8008936:	431a      	orrs	r2, r3
 8008938:	9b01      	ldr	r3, [sp, #4]
 800893a:	679a      	str	r2, [r3, #120]	; 0x78
    otgp->DIEPEMPMSK &= ~(1 << ep);
 800893c:	9b05      	ldr	r3, [sp, #20]
 800893e:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 8008942:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008946:	2101      	movs	r1, #1
 8008948:	fa01 f303 	lsl.w	r3, r1, r3
 800894c:	43db      	mvns	r3, r3
 800894e:	401a      	ands	r2, r3
 8008950:	9b05      	ldr	r3, [sp, #20]
 8008952:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
    osalThreadResumeI(&usbp->wait, MSG_OK);
 8008956:	9b01      	ldr	r3, [sp, #4]
 8008958:	337c      	adds	r3, #124	; 0x7c
 800895a:	4618      	mov	r0, r3
 800895c:	2100      	movs	r1, #0
 800895e:	f7ff fd2f 	bl	80083c0 <osalThreadResumeI>
    osalSysUnlockFromISR();
 8008962:	f7ff fd05 	bl	8008370 <osalSysUnlockFromISR>
  }
}
 8008966:	b007      	add	sp, #28
 8008968:	f85d fb04 	ldr.w	pc, [sp], #4
 800896c:	f3af 8000 	nop.w

08008970 <otg_epout_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8008970:	b500      	push	{lr}
 8008972:	b087      	sub	sp, #28
 8008974:	9001      	str	r0, [sp, #4]
 8008976:	460b      	mov	r3, r1
 8008978:	f88d 3003 	strb.w	r3, [sp, #3]
  stm32_otg_t *otgp = usbp->otg;
 800897c:	9b01      	ldr	r3, [sp, #4]
 800897e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008980:	9305      	str	r3, [sp, #20]
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8008982:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008986:	9a05      	ldr	r2, [sp, #20]
 8008988:	015b      	lsls	r3, r3, #5
 800898a:	4413      	add	r3, r2
 800898c:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 8008990:	681b      	ldr	r3, [r3, #0]
 8008992:	9304      	str	r3, [sp, #16]

  /* Resets all EP IRQ sources.*/
  otgp->oe[ep].DOEPINT = epint;
 8008994:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008998:	9a05      	ldr	r2, [sp, #20]
 800899a:	015b      	lsls	r3, r3, #5
 800899c:	4413      	add	r3, r2
 800899e:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 80089a2:	9a04      	ldr	r2, [sp, #16]
 80089a4:	601a      	str	r2, [r3, #0]

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 80089a6:	9b04      	ldr	r3, [sp, #16]
 80089a8:	f003 0308 	and.w	r3, r3, #8
 80089ac:	2b00      	cmp	r3, #0
 80089ae:	d013      	beq.n	80089d8 <otg_epout_handler+0x68>
 80089b0:	9b05      	ldr	r3, [sp, #20]
 80089b2:	f8d3 3814 	ldr.w	r3, [r3, #2068]	; 0x814
 80089b6:	f003 0308 	and.w	r3, r3, #8
 80089ba:	2b00      	cmp	r3, #0
 80089bc:	d00c      	beq.n	80089d8 <otg_epout_handler+0x68>
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);
 80089be:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80089c2:	9a01      	ldr	r2, [sp, #4]
 80089c4:	3302      	adds	r3, #2
 80089c6:	009b      	lsls	r3, r3, #2
 80089c8:	4413      	add	r3, r2
 80089ca:	685b      	ldr	r3, [r3, #4]
 80089cc:	685b      	ldr	r3, [r3, #4]
 80089ce:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80089d2:	9801      	ldr	r0, [sp, #4]
 80089d4:	4611      	mov	r1, r2
 80089d6:	4798      	blx	r3
  }
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 80089d8:	9b04      	ldr	r3, [sp, #16]
 80089da:	f003 0301 	and.w	r3, r3, #1
 80089de:	2b00      	cmp	r3, #0
 80089e0:	d06c      	beq.n	8008abc <otg_epout_handler+0x14c>
 80089e2:	9b05      	ldr	r3, [sp, #20]
 80089e4:	f8d3 3814 	ldr.w	r3, [r3, #2068]	; 0x814
 80089e8:	f003 0301 	and.w	r3, r3, #1
 80089ec:	2b00      	cmp	r3, #0
 80089ee:	d065      	beq.n	8008abc <otg_epout_handler+0x14c>
    USBOutEndpointState *osp;

    /* Receive transfer complete, checking if it is a SETUP transfer on EP0,
       that it must be ignored, the STUPM handler will take care of it.*/
    if ((ep == 0) && (usbp->ep0state == USB_EP0_WAITING_SETUP))
 80089f0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80089f4:	2b00      	cmp	r3, #0
 80089f6:	d105      	bne.n	8008a04 <otg_epout_handler+0x94>
 80089f8:	9b01      	ldr	r3, [sp, #4]
 80089fa:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 80089fe:	2b00      	cmp	r3, #0
 8008a00:	d100      	bne.n	8008a04 <otg_epout_handler+0x94>
      return;
 8008a02:	e05b      	b.n	8008abc <otg_epout_handler+0x14c>

    /* OUT state structure pointer for this endpoint.*/
    osp = usbp->epc[ep]->out_state;
 8008a04:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008a08:	9a01      	ldr	r2, [sp, #4]
 8008a0a:	3302      	adds	r3, #2
 8008a0c:	009b      	lsls	r3, r3, #2
 8008a0e:	4413      	add	r3, r2
 8008a10:	685b      	ldr	r3, [r3, #4]
 8008a12:	699b      	ldr	r3, [r3, #24]
 8008a14:	9303      	str	r3, [sp, #12]

    /* A short packet always terminates a transaction.*/
    if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 8008a16:	9b03      	ldr	r3, [sp, #12]
 8008a18:	685a      	ldr	r2, [r3, #4]
 8008a1a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008a1e:	9901      	ldr	r1, [sp, #4]
 8008a20:	3302      	adds	r3, #2
 8008a22:	009b      	lsls	r3, r3, #2
 8008a24:	440b      	add	r3, r1
 8008a26:	685b      	ldr	r3, [r3, #4]
 8008a28:	8a5b      	ldrh	r3, [r3, #18]
 8008a2a:	fbb2 f1f3 	udiv	r1, r2, r3
 8008a2e:	fb03 f301 	mul.w	r3, r3, r1
 8008a32:	1ad3      	subs	r3, r2, r3
 8008a34:	2b00      	cmp	r3, #0
 8008a36:	d11a      	bne.n	8008a6e <otg_epout_handler+0xfe>
        (osp->rxsize < osp->totsize)) {
 8008a38:	9b03      	ldr	r3, [sp, #12]
 8008a3a:	681a      	ldr	r2, [r3, #0]
 8008a3c:	9b03      	ldr	r3, [sp, #12]
 8008a3e:	68db      	ldr	r3, [r3, #12]

    /* OUT state structure pointer for this endpoint.*/
    osp = usbp->epc[ep]->out_state;

    /* A short packet always terminates a transaction.*/
    if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 8008a40:	429a      	cmp	r2, r3
 8008a42:	d214      	bcs.n	8008a6e <otg_epout_handler+0xfe>
        (osp->rxsize < osp->totsize)) {
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      osp->rxsize = osp->totsize - osp->rxsize;
 8008a44:	9b03      	ldr	r3, [sp, #12]
 8008a46:	68da      	ldr	r2, [r3, #12]
 8008a48:	9b03      	ldr	r3, [sp, #12]
 8008a4a:	681b      	ldr	r3, [r3, #0]
 8008a4c:	1ad2      	subs	r2, r2, r3
 8008a4e:	9b03      	ldr	r3, [sp, #12]
 8008a50:	601a      	str	r2, [r3, #0]
      osp->rxcnt  = 0;
 8008a52:	9b03      	ldr	r3, [sp, #12]
 8008a54:	2200      	movs	r2, #0
 8008a56:	605a      	str	r2, [r3, #4]
      osalSysLockFromISR();
 8008a58:	f7ff fc82 	bl	8008360 <osalSysLockFromISR>
      usb_lld_start_out(usbp, ep);
 8008a5c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008a60:	9801      	ldr	r0, [sp, #4]
 8008a62:	4619      	mov	r1, r3
 8008a64:	f000 fd44 	bl	80094f0 <usb_lld_start_out>
      osalSysUnlockFromISR();
 8008a68:	f7ff fc82 	bl	8008370 <osalSysUnlockFromISR>
 8008a6c:	e026      	b.n	8008abc <otg_epout_handler+0x14c>
    }
    else {
      /* End on OUT transfer.*/
      _usb_isr_invoke_out_cb(usbp, ep);
 8008a6e:	9b01      	ldr	r3, [sp, #4]
 8008a70:	895b      	ldrh	r3, [r3, #10]
 8008a72:	b29a      	uxth	r2, r3
 8008a74:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008a78:	2101      	movs	r1, #1
 8008a7a:	fa01 f303 	lsl.w	r3, r1, r3
 8008a7e:	b29b      	uxth	r3, r3
 8008a80:	43db      	mvns	r3, r3
 8008a82:	b29b      	uxth	r3, r3
 8008a84:	4013      	ands	r3, r2
 8008a86:	b29b      	uxth	r3, r3
 8008a88:	b29a      	uxth	r2, r3
 8008a8a:	9b01      	ldr	r3, [sp, #4]
 8008a8c:	815a      	strh	r2, [r3, #10]
 8008a8e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008a92:	9a01      	ldr	r2, [sp, #4]
 8008a94:	3302      	adds	r3, #2
 8008a96:	009b      	lsls	r3, r3, #2
 8008a98:	4413      	add	r3, r2
 8008a9a:	685b      	ldr	r3, [r3, #4]
 8008a9c:	68db      	ldr	r3, [r3, #12]
 8008a9e:	2b00      	cmp	r3, #0
 8008aa0:	d00c      	beq.n	8008abc <otg_epout_handler+0x14c>
 8008aa2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008aa6:	9a01      	ldr	r2, [sp, #4]
 8008aa8:	3302      	adds	r3, #2
 8008aaa:	009b      	lsls	r3, r3, #2
 8008aac:	4413      	add	r3, r2
 8008aae:	685b      	ldr	r3, [r3, #4]
 8008ab0:	68db      	ldr	r3, [r3, #12]
 8008ab2:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8008ab6:	9801      	ldr	r0, [sp, #4]
 8008ab8:	4611      	mov	r1, r2
 8008aba:	4798      	blx	r3
    }
  }
}
 8008abc:	b007      	add	sp, #28
 8008abe:	f85d fb04 	ldr.w	pc, [sp], #4
 8008ac2:	bf00      	nop
 8008ac4:	f3af 8000 	nop.w
 8008ac8:	f3af 8000 	nop.w
 8008acc:	f3af 8000 	nop.w

08008ad0 <otg_isoc_in_failed_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
 8008ad0:	b500      	push	{lr}
 8008ad2:	b085      	sub	sp, #20
 8008ad4:	9001      	str	r0, [sp, #4]
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 8008ad6:	9b01      	ldr	r3, [sp, #4]
 8008ad8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008ada:	9302      	str	r3, [sp, #8]

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8008adc:	2300      	movs	r3, #0
 8008ade:	f88d 300f 	strb.w	r3, [sp, #15]
 8008ae2:	e081      	b.n	8008be8 <otg_isoc_in_failed_handler+0x118>
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8008ae4:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008ae8:	9a02      	ldr	r2, [sp, #8]
 8008aea:	3348      	adds	r3, #72	; 0x48
 8008aec:	015b      	lsls	r3, r3, #5
 8008aee:	4413      	add	r3, r2
 8008af0:	681b      	ldr	r3, [r3, #0]
 8008af2:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8008af6:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8008afa:	d170      	bne.n	8008bde <otg_isoc_in_failed_handler+0x10e>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
 8008afc:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008b00:	9a02      	ldr	r2, [sp, #8]
 8008b02:	3348      	adds	r3, #72	; 0x48
 8008b04:	015b      	lsls	r3, r3, #5
 8008b06:	4413      	add	r3, r2
 8008b08:	681b      	ldr	r3, [r3, #0]
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8008b0a:	2b00      	cmp	r3, #0
 8008b0c:	da67      	bge.n	8008bde <otg_isoc_in_failed_handler+0x10e>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
      /* Endpoint enabled -> ISOC IN transfer failed */
      /* Disable endpoint */
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
 8008b0e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008b12:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8008b16:	9902      	ldr	r1, [sp, #8]
 8008b18:	3248      	adds	r2, #72	; 0x48
 8008b1a:	0152      	lsls	r2, r2, #5
 8008b1c:	440a      	add	r2, r1
 8008b1e:	6812      	ldr	r2, [r2, #0]
 8008b20:	f042 4290 	orr.w	r2, r2, #1207959552	; 0x48000000
 8008b24:	9902      	ldr	r1, [sp, #8]
 8008b26:	3348      	adds	r3, #72	; 0x48
 8008b28:	015b      	lsls	r3, r3, #5
 8008b2a:	440b      	add	r3, r1
 8008b2c:	601a      	str	r2, [r3, #0]
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
 8008b2e:	bf00      	nop
 8008b30:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008b34:	9a02      	ldr	r2, [sp, #8]
 8008b36:	3348      	adds	r3, #72	; 0x48
 8008b38:	015b      	lsls	r3, r3, #5
 8008b3a:	4413      	add	r3, r2
 8008b3c:	681b      	ldr	r3, [r3, #0]
 8008b3e:	2b00      	cmp	r3, #0
 8008b40:	dbf6      	blt.n	8008b30 <otg_isoc_in_failed_handler+0x60>
        ;

      /* Flush FIFO */
      otg_txfifo_flush(usbp, ep);
 8008b42:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008b46:	9801      	ldr	r0, [sp, #4]
 8008b48:	4619      	mov	r1, r3
 8008b4a:	f7ff fcc9 	bl	80084e0 <otg_txfifo_flush>

      /* Prepare data for next frame */
      _usb_isr_invoke_in_cb(usbp, ep);
 8008b4e:	9b01      	ldr	r3, [sp, #4]
 8008b50:	891b      	ldrh	r3, [r3, #8]
 8008b52:	b29a      	uxth	r2, r3
 8008b54:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008b58:	2101      	movs	r1, #1
 8008b5a:	fa01 f303 	lsl.w	r3, r1, r3
 8008b5e:	b29b      	uxth	r3, r3
 8008b60:	43db      	mvns	r3, r3
 8008b62:	b29b      	uxth	r3, r3
 8008b64:	4013      	ands	r3, r2
 8008b66:	b29b      	uxth	r3, r3
 8008b68:	b29a      	uxth	r2, r3
 8008b6a:	9b01      	ldr	r3, [sp, #4]
 8008b6c:	811a      	strh	r2, [r3, #8]
 8008b6e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008b72:	9a01      	ldr	r2, [sp, #4]
 8008b74:	3302      	adds	r3, #2
 8008b76:	009b      	lsls	r3, r3, #2
 8008b78:	4413      	add	r3, r2
 8008b7a:	685b      	ldr	r3, [r3, #4]
 8008b7c:	689b      	ldr	r3, [r3, #8]
 8008b7e:	2b00      	cmp	r3, #0
 8008b80:	d00c      	beq.n	8008b9c <otg_isoc_in_failed_handler+0xcc>
 8008b82:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008b86:	9a01      	ldr	r2, [sp, #4]
 8008b88:	3302      	adds	r3, #2
 8008b8a:	009b      	lsls	r3, r3, #2
 8008b8c:	4413      	add	r3, r2
 8008b8e:	685b      	ldr	r3, [r3, #4]
 8008b90:	689b      	ldr	r3, [r3, #8]
 8008b92:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8008b96:	9801      	ldr	r0, [sp, #4]
 8008b98:	4611      	mov	r1, r2
 8008b9a:	4798      	blx	r3

      /* Pump out data for next frame */
      osalSysLockFromISR();
 8008b9c:	f7ff fbe0 	bl	8008360 <osalSysLockFromISR>
      otgp->DIEPEMPMSK &= ~(1 << ep);
 8008ba0:	9b02      	ldr	r3, [sp, #8]
 8008ba2:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 8008ba6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008baa:	2101      	movs	r1, #1
 8008bac:	fa01 f303 	lsl.w	r3, r1, r3
 8008bb0:	43db      	mvns	r3, r3
 8008bb2:	401a      	ands	r2, r3
 8008bb4:	9b02      	ldr	r3, [sp, #8]
 8008bb6:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
      usbp->txpending |= (1 << ep);
 8008bba:	9b01      	ldr	r3, [sp, #4]
 8008bbc:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 8008bbe:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008bc2:	2101      	movs	r1, #1
 8008bc4:	fa01 f303 	lsl.w	r3, r1, r3
 8008bc8:	431a      	orrs	r2, r3
 8008bca:	9b01      	ldr	r3, [sp, #4]
 8008bcc:	679a      	str	r2, [r3, #120]	; 0x78
      osalThreadResumeI(&usbp->wait, MSG_OK);
 8008bce:	9b01      	ldr	r3, [sp, #4]
 8008bd0:	337c      	adds	r3, #124	; 0x7c
 8008bd2:	4618      	mov	r0, r3
 8008bd4:	2100      	movs	r1, #0
 8008bd6:	f7ff fbf3 	bl	80083c0 <osalThreadResumeI>
      osalSysUnlockFromISR();
 8008bda:	f7ff fbc9 	bl	8008370 <osalSysUnlockFromISR>
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8008bde:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008be2:	3301      	adds	r3, #1
 8008be4:	f88d 300f 	strb.w	r3, [sp, #15]
 8008be8:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8008bec:	9b01      	ldr	r3, [sp, #4]
 8008bee:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008bf0:	689b      	ldr	r3, [r3, #8]
 8008bf2:	429a      	cmp	r2, r3
 8008bf4:	f67f af76 	bls.w	8008ae4 <otg_isoc_in_failed_handler+0x14>
      usbp->txpending |= (1 << ep);
      osalThreadResumeI(&usbp->wait, MSG_OK);
      osalSysUnlockFromISR();
    }
  }
}
 8008bf8:	b005      	add	sp, #20
 8008bfa:	f85d fb04 	ldr.w	pc, [sp], #4
 8008bfe:	bf00      	nop

08008c00 <otg_isoc_out_failed_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
 8008c00:	b500      	push	{lr}
 8008c02:	b085      	sub	sp, #20
 8008c04:	9001      	str	r0, [sp, #4]
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 8008c06:	9b01      	ldr	r3, [sp, #4]
 8008c08:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008c0a:	9302      	str	r3, [sp, #8]

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8008c0c:	2300      	movs	r3, #0
 8008c0e:	f88d 300f 	strb.w	r3, [sp, #15]
 8008c12:	e040      	b.n	8008c96 <otg_isoc_out_failed_handler+0x96>
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8008c14:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008c18:	9a02      	ldr	r2, [sp, #8]
 8008c1a:	3358      	adds	r3, #88	; 0x58
 8008c1c:	015b      	lsls	r3, r3, #5
 8008c1e:	4413      	add	r3, r2
 8008c20:	681b      	ldr	r3, [r3, #0]
 8008c22:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8008c26:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8008c2a:	d12f      	bne.n	8008c8c <otg_isoc_out_failed_handler+0x8c>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
 8008c2c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008c30:	9a02      	ldr	r2, [sp, #8]
 8008c32:	3358      	adds	r3, #88	; 0x58
 8008c34:	015b      	lsls	r3, r3, #5
 8008c36:	4413      	add	r3, r2
 8008c38:	681b      	ldr	r3, [r3, #0]
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8008c3a:	2b00      	cmp	r3, #0
 8008c3c:	da26      	bge.n	8008c8c <otg_isoc_out_failed_handler+0x8c>
      /* FIXME: Core stucks here */
      /*otgp->oe[ep].DOEPCTL |= (DOEPCTL_EPDIS | DOEPCTL_SNAK);
      while (otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA)
        ;*/
      /* Prepare transfer for next frame */
      _usb_isr_invoke_out_cb(usbp, ep);
 8008c3e:	9b01      	ldr	r3, [sp, #4]
 8008c40:	895b      	ldrh	r3, [r3, #10]
 8008c42:	b29a      	uxth	r2, r3
 8008c44:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008c48:	2101      	movs	r1, #1
 8008c4a:	fa01 f303 	lsl.w	r3, r1, r3
 8008c4e:	b29b      	uxth	r3, r3
 8008c50:	43db      	mvns	r3, r3
 8008c52:	b29b      	uxth	r3, r3
 8008c54:	4013      	ands	r3, r2
 8008c56:	b29b      	uxth	r3, r3
 8008c58:	b29a      	uxth	r2, r3
 8008c5a:	9b01      	ldr	r3, [sp, #4]
 8008c5c:	815a      	strh	r2, [r3, #10]
 8008c5e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008c62:	9a01      	ldr	r2, [sp, #4]
 8008c64:	3302      	adds	r3, #2
 8008c66:	009b      	lsls	r3, r3, #2
 8008c68:	4413      	add	r3, r2
 8008c6a:	685b      	ldr	r3, [r3, #4]
 8008c6c:	68db      	ldr	r3, [r3, #12]
 8008c6e:	2b00      	cmp	r3, #0
 8008c70:	d00c      	beq.n	8008c8c <otg_isoc_out_failed_handler+0x8c>
 8008c72:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008c76:	9a01      	ldr	r2, [sp, #4]
 8008c78:	3302      	adds	r3, #2
 8008c7a:	009b      	lsls	r3, r3, #2
 8008c7c:	4413      	add	r3, r2
 8008c7e:	685b      	ldr	r3, [r3, #4]
 8008c80:	68db      	ldr	r3, [r3, #12]
 8008c82:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8008c86:	9801      	ldr	r0, [sp, #4]
 8008c88:	4611      	mov	r1, r2
 8008c8a:	4798      	blx	r3
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8008c8c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008c90:	3301      	adds	r3, #1
 8008c92:	f88d 300f 	strb.w	r3, [sp, #15]
 8008c96:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8008c9a:	9b01      	ldr	r3, [sp, #4]
 8008c9c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008c9e:	689b      	ldr	r3, [r3, #8]
 8008ca0:	429a      	cmp	r2, r3
 8008ca2:	d9b7      	bls.n	8008c14 <otg_isoc_out_failed_handler+0x14>
        ;*/
      /* Prepare transfer for next frame */
      _usb_isr_invoke_out_cb(usbp, ep);
    }
  }
}
 8008ca4:	b005      	add	sp, #20
 8008ca6:	f85d fb04 	ldr.w	pc, [sp], #4
 8008caa:	bf00      	nop
 8008cac:	f3af 8000 	nop.w

08008cb0 <usb_lld_serve_interrupt>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void usb_lld_serve_interrupt(USBDriver *usbp) {
 8008cb0:	b500      	push	{lr}
 8008cb2:	b087      	sub	sp, #28
 8008cb4:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8008cb6:	9b01      	ldr	r3, [sp, #4]
 8008cb8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008cba:	9305      	str	r3, [sp, #20]
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
 8008cbc:	9b05      	ldr	r3, [sp, #20]
 8008cbe:	695b      	ldr	r3, [r3, #20]
 8008cc0:	9304      	str	r3, [sp, #16]
  sts &= otgp->GINTMSK;
 8008cc2:	9b05      	ldr	r3, [sp, #20]
 8008cc4:	699b      	ldr	r3, [r3, #24]
 8008cc6:	9a04      	ldr	r2, [sp, #16]
 8008cc8:	4013      	ands	r3, r2
 8008cca:	9304      	str	r3, [sp, #16]
  otgp->GINTSTS = sts;
 8008ccc:	9b05      	ldr	r3, [sp, #20]
 8008cce:	9a04      	ldr	r2, [sp, #16]
 8008cd0:	615a      	str	r2, [r3, #20]

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 8008cd2:	9b04      	ldr	r3, [sp, #16]
 8008cd4:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8008cd8:	2b00      	cmp	r3, #0
 8008cda:	d006      	beq.n	8008cea <usb_lld_serve_interrupt+0x3a>

    /* Resetting pending operations.*/
    usbp->txpending = 0;
 8008cdc:	9b01      	ldr	r3, [sp, #4]
 8008cde:	2200      	movs	r2, #0
 8008ce0:	679a      	str	r2, [r3, #120]	; 0x78

    /* Default reset action.*/
    _usb_reset(usbp);
 8008ce2:	9801      	ldr	r0, [sp, #4]
 8008ce4:	f7fe f91c 	bl	8006f20 <_usb_reset>

    /* Preventing execution of more handlers, the core has been reset.*/
    return;
 8008ce8:	e0ce      	b.n	8008e88 <usb_lld_serve_interrupt+0x1d8>
  }

  /* Wake-up handling.*/
  if (sts & GINTSTS_WKUPINT) {
 8008cea:	9b04      	ldr	r3, [sp, #16]
 8008cec:	2b00      	cmp	r3, #0
 8008cee:	da19      	bge.n	8008d24 <usb_lld_serve_interrupt+0x74>
    /* If clocks are gated off, turn them back on (may be the case if
       coming out of suspend mode).*/
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
 8008cf0:	9b05      	ldr	r3, [sp, #20]
 8008cf2:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
 8008cf6:	f003 0303 	and.w	r3, r3, #3
 8008cfa:	2b00      	cmp	r3, #0
 8008cfc:	d007      	beq.n	8008d0e <usb_lld_serve_interrupt+0x5e>
      /* Set to zero to un-gate the USB core clocks.*/
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 8008cfe:	9b05      	ldr	r3, [sp, #20]
 8008d00:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
 8008d04:	f023 0203 	bic.w	r2, r3, #3
 8008d08:	9b05      	ldr	r3, [sp, #20]
 8008d0a:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00
    }

    /* Clear the Remote Wake-up Signaling.*/
    otgp->DCTL |= DCTL_RWUSIG;
 8008d0e:	9b05      	ldr	r3, [sp, #20]
 8008d10:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
 8008d14:	f043 0201 	orr.w	r2, r3, #1
 8008d18:	9b05      	ldr	r3, [sp, #20]
 8008d1a:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804

    _usb_wakeup(usbp);
 8008d1e:	9801      	ldr	r0, [sp, #4]
 8008d20:	f7fe f95e 	bl	8006fe0 <_usb_wakeup>
  }

  /* Suspend handling.*/
  if (sts & GINTSTS_USBSUSP) {
 8008d24:	9b04      	ldr	r3, [sp, #16]
 8008d26:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8008d2a:	2b00      	cmp	r3, #0
 8008d2c:	d005      	beq.n	8008d3a <usb_lld_serve_interrupt+0x8a>

    /* Resetting pending operations.*/
    usbp->txpending = 0;
 8008d2e:	9b01      	ldr	r3, [sp, #4]
 8008d30:	2200      	movs	r2, #0
 8008d32:	679a      	str	r2, [r3, #120]	; 0x78

    /* Default suspend action.*/
    _usb_suspend(usbp);
 8008d34:	9801      	ldr	r0, [sp, #4]
 8008d36:	f7fe f933 	bl	8006fa0 <_usb_suspend>
  }

  /* Enumeration done.*/
  if (sts & GINTSTS_ENUMDNE) {
 8008d3a:	9b04      	ldr	r3, [sp, #16]
 8008d3c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8008d40:	2b00      	cmp	r3, #0
 8008d42:	d017      	beq.n	8008d74 <usb_lld_serve_interrupt+0xc4>
    /* Full or High speed timing selection.*/
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
 8008d44:	9b05      	ldr	r3, [sp, #20]
 8008d46:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 8008d4a:	f003 0306 	and.w	r3, r3, #6
 8008d4e:	2b00      	cmp	r3, #0
 8008d50:	d108      	bne.n	8008d64 <usb_lld_serve_interrupt+0xb4>
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8008d52:	9b05      	ldr	r3, [sp, #20]
 8008d54:	68db      	ldr	r3, [r3, #12]
 8008d56:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8008d5a:	f443 5210 	orr.w	r2, r3, #9216	; 0x2400
 8008d5e:	9b05      	ldr	r3, [sp, #20]
 8008d60:	60da      	str	r2, [r3, #12]
 8008d62:	e007      	b.n	8008d74 <usb_lld_serve_interrupt+0xc4>
                      GUSBCFG_TRDT(TRDT_VALUE_HS);
    }
    else {
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8008d64:	9b05      	ldr	r3, [sp, #20]
 8008d66:	68db      	ldr	r3, [r3, #12]
 8008d68:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8008d6c:	f443 52a0 	orr.w	r2, r3, #5120	; 0x1400
 8008d70:	9b05      	ldr	r3, [sp, #20]
 8008d72:	60da      	str	r2, [r3, #12]
                      GUSBCFG_TRDT(TRDT_VALUE_FS);
    }
  }

  /* SOF interrupt handling.*/
  if (sts & GINTSTS_SOF) {
 8008d74:	9b04      	ldr	r3, [sp, #16]
 8008d76:	f003 0308 	and.w	r3, r3, #8
 8008d7a:	2b00      	cmp	r3, #0
 8008d7c:	d009      	beq.n	8008d92 <usb_lld_serve_interrupt+0xe2>
    _usb_isr_invoke_sof_cb(usbp);
 8008d7e:	9b01      	ldr	r3, [sp, #4]
 8008d80:	685b      	ldr	r3, [r3, #4]
 8008d82:	68db      	ldr	r3, [r3, #12]
 8008d84:	2b00      	cmp	r3, #0
 8008d86:	d004      	beq.n	8008d92 <usb_lld_serve_interrupt+0xe2>
 8008d88:	9b01      	ldr	r3, [sp, #4]
 8008d8a:	685b      	ldr	r3, [r3, #4]
 8008d8c:	68db      	ldr	r3, [r3, #12]
 8008d8e:	9801      	ldr	r0, [sp, #4]
 8008d90:	4798      	blx	r3
  }

  /* Isochronous IN failed handling */
  if (sts & GINTSTS_IISOIXFR) {
 8008d92:	9b04      	ldr	r3, [sp, #16]
 8008d94:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8008d98:	2b00      	cmp	r3, #0
 8008d9a:	d002      	beq.n	8008da2 <usb_lld_serve_interrupt+0xf2>
    otg_isoc_in_failed_handler(usbp);
 8008d9c:	9801      	ldr	r0, [sp, #4]
 8008d9e:	f7ff fe97 	bl	8008ad0 <otg_isoc_in_failed_handler>
  }

  /* Isochronous OUT failed handling */
  if (sts & GINTSTS_IISOOXFR) {
 8008da2:	9b04      	ldr	r3, [sp, #16]
 8008da4:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8008da8:	2b00      	cmp	r3, #0
 8008daa:	d002      	beq.n	8008db2 <usb_lld_serve_interrupt+0x102>
    otg_isoc_out_failed_handler(usbp);
 8008dac:	9801      	ldr	r0, [sp, #4]
 8008dae:	f7ff ff27 	bl	8008c00 <otg_isoc_out_failed_handler>
  }

  /* RX FIFO not empty handling.*/
  if (sts & GINTSTS_RXFLVL) {
 8008db2:	9b04      	ldr	r3, [sp, #16]
 8008db4:	f003 0310 	and.w	r3, r3, #16
 8008db8:	2b00      	cmp	r3, #0
 8008dba:	d00f      	beq.n	8008ddc <usb_lld_serve_interrupt+0x12c>
    /* The interrupt is masked while the thread has control or it would
       be triggered again.*/
    osalSysLockFromISR();
 8008dbc:	f7ff fad0 	bl	8008360 <osalSysLockFromISR>
    otgp->GINTMSK &= ~GINTMSK_RXFLVLM;
 8008dc0:	9b05      	ldr	r3, [sp, #20]
 8008dc2:	699b      	ldr	r3, [r3, #24]
 8008dc4:	f023 0210 	bic.w	r2, r3, #16
 8008dc8:	9b05      	ldr	r3, [sp, #20]
 8008dca:	619a      	str	r2, [r3, #24]
    osalThreadResumeI(&usbp->wait, MSG_OK);
 8008dcc:	9b01      	ldr	r3, [sp, #4]
 8008dce:	337c      	adds	r3, #124	; 0x7c
 8008dd0:	4618      	mov	r0, r3
 8008dd2:	2100      	movs	r1, #0
 8008dd4:	f7ff faf4 	bl	80083c0 <osalThreadResumeI>
    osalSysUnlockFromISR();
 8008dd8:	f7ff faca 	bl	8008370 <osalSysUnlockFromISR>
  }

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
 8008ddc:	9b05      	ldr	r3, [sp, #20]
 8008dde:	f8d3 3818 	ldr.w	r3, [r3, #2072]	; 0x818
 8008de2:	9303      	str	r3, [sp, #12]
  if (sts & GINTSTS_IEPINT) {
 8008de4:	9b04      	ldr	r3, [sp, #16]
 8008de6:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8008dea:	2b00      	cmp	r3, #0
 8008dec:	d023      	beq.n	8008e36 <usb_lld_serve_interrupt+0x186>
    if (src & (1 << 0))
 8008dee:	9b03      	ldr	r3, [sp, #12]
 8008df0:	f003 0301 	and.w	r3, r3, #1
 8008df4:	2b00      	cmp	r3, #0
 8008df6:	d003      	beq.n	8008e00 <usb_lld_serve_interrupt+0x150>
      otg_epin_handler(usbp, 0);
 8008df8:	9801      	ldr	r0, [sp, #4]
 8008dfa:	2100      	movs	r1, #0
 8008dfc:	f7ff fd10 	bl	8008820 <otg_epin_handler>
    if (src & (1 << 1))
 8008e00:	9b03      	ldr	r3, [sp, #12]
 8008e02:	f003 0302 	and.w	r3, r3, #2
 8008e06:	2b00      	cmp	r3, #0
 8008e08:	d003      	beq.n	8008e12 <usb_lld_serve_interrupt+0x162>
      otg_epin_handler(usbp, 1);
 8008e0a:	9801      	ldr	r0, [sp, #4]
 8008e0c:	2101      	movs	r1, #1
 8008e0e:	f7ff fd07 	bl	8008820 <otg_epin_handler>
    if (src & (1 << 2))
 8008e12:	9b03      	ldr	r3, [sp, #12]
 8008e14:	f003 0304 	and.w	r3, r3, #4
 8008e18:	2b00      	cmp	r3, #0
 8008e1a:	d003      	beq.n	8008e24 <usb_lld_serve_interrupt+0x174>
      otg_epin_handler(usbp, 2);
 8008e1c:	9801      	ldr	r0, [sp, #4]
 8008e1e:	2102      	movs	r1, #2
 8008e20:	f7ff fcfe 	bl	8008820 <otg_epin_handler>
    if (src & (1 << 3))
 8008e24:	9b03      	ldr	r3, [sp, #12]
 8008e26:	f003 0308 	and.w	r3, r3, #8
 8008e2a:	2b00      	cmp	r3, #0
 8008e2c:	d003      	beq.n	8008e36 <usb_lld_serve_interrupt+0x186>
      otg_epin_handler(usbp, 3);
 8008e2e:	9801      	ldr	r0, [sp, #4]
 8008e30:	2103      	movs	r1, #3
 8008e32:	f7ff fcf5 	bl	8008820 <otg_epin_handler>
      otg_epin_handler(usbp, 4);
    if (src & (1 << 5))
      otg_epin_handler(usbp, 5);
#endif
  }
  if (sts & GINTSTS_OEPINT) {
 8008e36:	9b04      	ldr	r3, [sp, #16]
 8008e38:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8008e3c:	2b00      	cmp	r3, #0
 8008e3e:	d023      	beq.n	8008e88 <usb_lld_serve_interrupt+0x1d8>
    if (src & (1 << 16))
 8008e40:	9b03      	ldr	r3, [sp, #12]
 8008e42:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8008e46:	2b00      	cmp	r3, #0
 8008e48:	d003      	beq.n	8008e52 <usb_lld_serve_interrupt+0x1a2>
      otg_epout_handler(usbp, 0);
 8008e4a:	9801      	ldr	r0, [sp, #4]
 8008e4c:	2100      	movs	r1, #0
 8008e4e:	f7ff fd8f 	bl	8008970 <otg_epout_handler>
    if (src & (1 << 17))
 8008e52:	9b03      	ldr	r3, [sp, #12]
 8008e54:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8008e58:	2b00      	cmp	r3, #0
 8008e5a:	d003      	beq.n	8008e64 <usb_lld_serve_interrupt+0x1b4>
      otg_epout_handler(usbp, 1);
 8008e5c:	9801      	ldr	r0, [sp, #4]
 8008e5e:	2101      	movs	r1, #1
 8008e60:	f7ff fd86 	bl	8008970 <otg_epout_handler>
    if (src & (1 << 18))
 8008e64:	9b03      	ldr	r3, [sp, #12]
 8008e66:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8008e6a:	2b00      	cmp	r3, #0
 8008e6c:	d003      	beq.n	8008e76 <usb_lld_serve_interrupt+0x1c6>
      otg_epout_handler(usbp, 2);
 8008e6e:	9801      	ldr	r0, [sp, #4]
 8008e70:	2102      	movs	r1, #2
 8008e72:	f7ff fd7d 	bl	8008970 <otg_epout_handler>
    if (src & (1 << 19))
 8008e76:	9b03      	ldr	r3, [sp, #12]
 8008e78:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8008e7c:	2b00      	cmp	r3, #0
 8008e7e:	d003      	beq.n	8008e88 <usb_lld_serve_interrupt+0x1d8>
      otg_epout_handler(usbp, 3);
 8008e80:	9801      	ldr	r0, [sp, #4]
 8008e82:	2103      	movs	r1, #3
 8008e84:	f7ff fd74 	bl	8008970 <otg_epout_handler>
      otg_epout_handler(usbp, 4);
    if (src & (1 << 21))
      otg_epout_handler(usbp, 5);
#endif
  }
}
 8008e88:	b007      	add	sp, #28
 8008e8a:	f85d fb04 	ldr.w	pc, [sp], #4
 8008e8e:	bf00      	nop

08008e90 <Vector14C>:
/**
 * @brief   OTG1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 8008e90:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);
 8008e92:	4803      	ldr	r0, [pc, #12]	; (8008ea0 <Vector14C+0x10>)
 8008e94:	f7ff ff0c 	bl	8008cb0 <usb_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8008e98:	f7fa fe5a 	bl	8003b50 <_port_irq_epilogue>
}
 8008e9c:	bd08      	pop	{r3, pc}
 8008e9e:	bf00      	nop
 8008ea0:	200018a0 	.word	0x200018a0
 8008ea4:	f3af 8000 	nop.w
 8008ea8:	f3af 8000 	nop.w
 8008eac:	f3af 8000 	nop.w

08008eb0 <usb_lld_init>:
/**
 * @brief   Low level USB driver initialization.
 *
 * @notapi
 */
void usb_lld_init(void) {
 8008eb0:	b508      	push	{r3, lr}

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
 8008eb2:	4809      	ldr	r0, [pc, #36]	; (8008ed8 <usb_lld_init+0x28>)
 8008eb4:	f7fd fec4 	bl	8006c40 <usbObjectInit>
  USBD1.wait      = NULL;
 8008eb8:	4b07      	ldr	r3, [pc, #28]	; (8008ed8 <usb_lld_init+0x28>)
 8008eba:	2200      	movs	r2, #0
 8008ebc:	67da      	str	r2, [r3, #124]	; 0x7c
  USBD1.otg       = OTG_FS;
 8008ebe:	4b06      	ldr	r3, [pc, #24]	; (8008ed8 <usb_lld_init+0x28>)
 8008ec0:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
 8008ec4:	66da      	str	r2, [r3, #108]	; 0x6c
  USBD1.otgparams = &fsparams;
 8008ec6:	4b04      	ldr	r3, [pc, #16]	; (8008ed8 <usb_lld_init+0x28>)
 8008ec8:	4a04      	ldr	r2, [pc, #16]	; (8008edc <usb_lld_init+0x2c>)
 8008eca:	671a      	str	r2, [r3, #112]	; 0x70

#if defined(_CHIBIOS_RT_)
  USBD1.tr = NULL;
 8008ecc:	4b02      	ldr	r3, [pc, #8]	; (8008ed8 <usb_lld_init+0x28>)
 8008ece:	2200      	movs	r2, #0
 8008ed0:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
                    CH_DBG_STACK_FILL_VALUE);
  }
#endif /* CH_DBG_FILL_THREADS */
#endif /* defined(_CHIBIOS_RT_) */
#endif
}
 8008ed4:	bd08      	pop	{r3, pc}
 8008ed6:	bf00      	nop
 8008ed8:	200018a0 	.word	0x200018a0
 8008edc:	080179b4 	.word	0x080179b4

08008ee0 <usb_lld_start>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
 8008ee0:	b500      	push	{lr}
 8008ee2:	b087      	sub	sp, #28
 8008ee4:	9003      	str	r0, [sp, #12]
  stm32_otg_t *otgp = usbp->otg;
 8008ee6:	9b03      	ldr	r3, [sp, #12]
 8008ee8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008eea:	9305      	str	r3, [sp, #20]

  if (usbp->state == USB_STOP) {
 8008eec:	9b03      	ldr	r3, [sp, #12]
 8008eee:	781b      	ldrb	r3, [r3, #0]
 8008ef0:	2b01      	cmp	r3, #1
 8008ef2:	d172      	bne.n	8008fda <usb_lld_start+0xfa>
    /* Clock activation.*/

#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
 8008ef4:	9a03      	ldr	r2, [sp, #12]
 8008ef6:	4b3a      	ldr	r3, [pc, #232]	; (8008fe0 <usb_lld_start+0x100>)
 8008ef8:	429a      	cmp	r2, r3
 8008efa:	d119      	bne.n	8008f30 <usb_lld_start+0x50>
      /* OTG FS clock enable and reset.*/
      rccEnableOTG_FS(false);
 8008efc:	4b39      	ldr	r3, [pc, #228]	; (8008fe4 <usb_lld_start+0x104>)
 8008efe:	4a39      	ldr	r2, [pc, #228]	; (8008fe4 <usb_lld_start+0x104>)
 8008f00:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 8008f02:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8008f06:	64da      	str	r2, [r3, #76]	; 0x4c
      rccResetOTG_FS();
 8008f08:	4b36      	ldr	r3, [pc, #216]	; (8008fe4 <usb_lld_start+0x104>)
 8008f0a:	4a36      	ldr	r2, [pc, #216]	; (8008fe4 <usb_lld_start+0x104>)
 8008f0c:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8008f0e:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8008f12:	62da      	str	r2, [r3, #44]	; 0x2c
 8008f14:	4b33      	ldr	r3, [pc, #204]	; (8008fe4 <usb_lld_start+0x104>)
 8008f16:	2200      	movs	r2, #0
 8008f18:	62da      	str	r2, [r3, #44]	; 0x2c

      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG1_NUMBER, STM32_USB_OTG1_IRQ_PRIORITY);
 8008f1a:	2043      	movs	r0, #67	; 0x43
 8008f1c:	210e      	movs	r1, #14
 8008f1e:	f7fe fa07 	bl	8007330 <nvicEnableVector>

      /* - Forced device mode.
         - USB turn-around time = TRDT_VALUE_FS.
         - Full Speed 1.1 PHY.*/
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 8008f22:	9b05      	ldr	r3, [sp, #20]
 8008f24:	4a30      	ldr	r2, [pc, #192]	; (8008fe8 <usb_lld_start+0x108>)
 8008f26:	60da      	str	r2, [r3, #12]
                      GUSBCFG_PHYSEL;

      /* 48MHz 1.1 PHY.*/
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 8008f28:	9b05      	ldr	r3, [sp, #20]
 8008f2a:	4a30      	ldr	r2, [pc, #192]	; (8008fec <usb_lld_start+0x10c>)
 8008f2c:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
#endif
    }
#endif

    /* Clearing mask of TXFIFOs to be filled.*/
    usbp->txpending = 0;
 8008f30:	9b03      	ldr	r3, [sp, #12]
 8008f32:	2200      	movs	r2, #0
 8008f34:	679a      	str	r2, [r3, #120]	; 0x78

    /* PHY enabled.*/
    otgp->PCGCCTL = 0;
 8008f36:	9b05      	ldr	r3, [sp, #20]
 8008f38:	2200      	movs	r2, #0
 8008f3a:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00

    /* VBUS sensing and transceiver enabled.*/
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 8008f3e:	9b05      	ldr	r3, [sp, #20]
 8008f40:	22c0      	movs	r2, #192	; 0xc0
 8008f42:	601a      	str	r2, [r3, #0]
    if (&USBD2 == usbp) {
      otgp->GCCFG = 0;
    }
#endif
#else
    otgp->GCCFG = GCCFG_INIT_VALUE;
 8008f44:	9b05      	ldr	r3, [sp, #20]
 8008f46:	f44f 1204 	mov.w	r2, #2162688	; 0x210000
 8008f4a:	639a      	str	r2, [r3, #56]	; 0x38
#endif

    /* Soft core reset.*/
    otg_core_reset(usbp);
 8008f4c:	9803      	ldr	r0, [sp, #12]
 8008f4e:	f7ff fa47 	bl	80083e0 <otg_core_reset>

    /* Interrupts on TXFIFOs half empty.*/
    otgp->GAHBCFG = 0;
 8008f52:	9b05      	ldr	r3, [sp, #20]
 8008f54:	2200      	movs	r2, #0
 8008f56:	609a      	str	r2, [r3, #8]

    /* Endpoints re-initialization.*/
    otg_disable_ep(usbp);
 8008f58:	9803      	ldr	r0, [sp, #12]
 8008f5a:	f7ff fa61 	bl	8008420 <otg_disable_ep>

    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
 8008f5e:	9b05      	ldr	r3, [sp, #20]
 8008f60:	2200      	movs	r2, #0
 8008f62:	f8c3 2810 	str.w	r2, [r3, #2064]	; 0x810
    otgp->DOEPMSK  = 0;
 8008f66:	9b05      	ldr	r3, [sp, #20]
 8008f68:	2200      	movs	r2, #0
 8008f6a:	f8c3 2814 	str.w	r2, [r3, #2068]	; 0x814
    otgp->DAINTMSK = 0;
 8008f6e:	9b05      	ldr	r3, [sp, #20]
 8008f70:	2200      	movs	r2, #0
 8008f72:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
 8008f76:	9b03      	ldr	r3, [sp, #12]
 8008f78:	685b      	ldr	r3, [r3, #4]
 8008f7a:	68db      	ldr	r3, [r3, #12]
 8008f7c:	2b00      	cmp	r3, #0
 8008f7e:	d103      	bne.n	8008f88 <usb_lld_start+0xa8>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8008f80:	9b05      	ldr	r3, [sp, #20]
 8008f82:	4a1b      	ldr	r2, [pc, #108]	; (8008ff0 <usb_lld_start+0x110>)
 8008f84:	619a      	str	r2, [r3, #24]
 8008f86:	e002      	b.n	8008f8e <usb_lld_start+0xae>
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM;
    else
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8008f88:	9b05      	ldr	r3, [sp, #20]
 8008f8a:	4a1a      	ldr	r2, [pc, #104]	; (8008ff4 <usb_lld_start+0x114>)
 8008f8c:	619a      	str	r2, [r3, #24]
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM |
                       GINTMSK_SOFM;

    /* Clears all pending IRQs, if any. */
    otgp->GINTSTS  = 0xFFFFFFFF;
 8008f8e:	9b05      	ldr	r3, [sp, #20]
 8008f90:	f04f 32ff 	mov.w	r2, #4294967295
 8008f94:	615a      	str	r2, [r3, #20]

#if defined(_CHIBIOS_RT_)
    /* Creates the data pump thread. Note, it is created only once.*/
    if (usbp->tr == NULL) {
 8008f96:	9b03      	ldr	r3, [sp, #12]
 8008f98:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8008f9c:	2b00      	cmp	r3, #0
 8008f9e:	d116      	bne.n	8008fce <usb_lld_start+0xee>
      usbp->tr = chThdCreateI(usbp->wa_pump, sizeof usbp->wa_pump,
 8008fa0:	9b03      	ldr	r3, [sp, #12]
 8008fa2:	3388      	adds	r3, #136	; 0x88
 8008fa4:	9a03      	ldr	r2, [sp, #12]
 8008fa6:	9200      	str	r2, [sp, #0]
 8008fa8:	4618      	mov	r0, r3
 8008faa:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008fae:	2202      	movs	r2, #2
 8008fb0:	4b11      	ldr	r3, [pc, #68]	; (8008ff8 <usb_lld_start+0x118>)
 8008fb2:	f7f8 f8ed 	bl	8001190 <chThdCreateI>
 8008fb6:	4602      	mov	r2, r0
 8008fb8:	9b03      	ldr	r3, [sp, #12]
 8008fba:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
                              STM32_USB_OTG_THREAD_PRIO,
                              usb_lld_pump, usbp);
      chThdStartI(usbp->tr);
 8008fbe:	9b03      	ldr	r3, [sp, #12]
 8008fc0:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8008fc4:	4618      	mov	r0, r3
 8008fc6:	f7ff f99b 	bl	8008300 <chThdStartI>
      chSchRescheduleS();
 8008fca:	f7f7 fed9 	bl	8000d80 <chSchRescheduleS>
  }
#endif

    /* Global interrupts enable.*/
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 8008fce:	9b05      	ldr	r3, [sp, #20]
 8008fd0:	689b      	ldr	r3, [r3, #8]
 8008fd2:	f043 0201 	orr.w	r2, r3, #1
 8008fd6:	9b05      	ldr	r3, [sp, #20]
 8008fd8:	609a      	str	r2, [r3, #8]
  }
}
 8008fda:	b007      	add	sp, #28
 8008fdc:	f85d fb04 	ldr.w	pc, [sp], #4
 8008fe0:	200018a0 	.word	0x200018a0
 8008fe4:	40021000 	.word	0x40021000
 8008fe8:	40001440 	.word	0x40001440
 8008fec:	02200003 	.word	0x02200003
 8008ff0:	c0303c00 	.word	0xc0303c00
 8008ff4:	c0303c08 	.word	0xc0303c08
 8008ff8:	08009891 	.word	0x08009891
 8008ffc:	f3af 8000 	nop.w

08009000 <usb_lld_stop>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_stop(USBDriver *usbp) {
 8009000:	b500      	push	{lr}
 8009002:	b085      	sub	sp, #20
 8009004:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8009006:	9b01      	ldr	r3, [sp, #4]
 8009008:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800900a:	9303      	str	r3, [sp, #12]

  /* If in ready state then disables the USB clock.*/
  if (usbp->state != USB_STOP) {
 800900c:	9b01      	ldr	r3, [sp, #4]
 800900e:	781b      	ldrb	r3, [r3, #0]
 8009010:	2b01      	cmp	r3, #1
 8009012:	d01c      	beq.n	800904e <usb_lld_stop+0x4e>

    /* Disabling all endpoints in case the driver has been stopped while
       active.*/
    otg_disable_ep(usbp);
 8009014:	9801      	ldr	r0, [sp, #4]
 8009016:	f7ff fa03 	bl	8008420 <otg_disable_ep>

    usbp->txpending = 0;
 800901a:	9b01      	ldr	r3, [sp, #4]
 800901c:	2200      	movs	r2, #0
 800901e:	679a      	str	r2, [r3, #120]	; 0x78

    otgp->DAINTMSK   = 0;
 8009020:	9b03      	ldr	r3, [sp, #12]
 8009022:	2200      	movs	r2, #0
 8009024:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
    otgp->GAHBCFG    = 0;
 8009028:	9b03      	ldr	r3, [sp, #12]
 800902a:	2200      	movs	r2, #0
 800902c:	609a      	str	r2, [r3, #8]
    otgp->GCCFG      = 0;
 800902e:	9b03      	ldr	r3, [sp, #12]
 8009030:	2200      	movs	r2, #0
 8009032:	639a      	str	r2, [r3, #56]	; 0x38

#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
 8009034:	9a01      	ldr	r2, [sp, #4]
 8009036:	4b07      	ldr	r3, [pc, #28]	; (8009054 <usb_lld_stop+0x54>)
 8009038:	429a      	cmp	r2, r3
 800903a:	d108      	bne.n	800904e <usb_lld_stop+0x4e>
      nvicDisableVector(STM32_OTG1_NUMBER);
 800903c:	2043      	movs	r0, #67	; 0x43
 800903e:	f7fe f99f 	bl	8007380 <nvicDisableVector>
      rccDisableOTG_FS(false);
 8009042:	4b05      	ldr	r3, [pc, #20]	; (8009058 <usb_lld_stop+0x58>)
 8009044:	4a04      	ldr	r2, [pc, #16]	; (8009058 <usb_lld_stop+0x58>)
 8009046:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 8009048:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 800904c:	64da      	str	r2, [r3, #76]	; 0x4c
      rccDisableOTG_HSULPI(true)
#endif
    }
#endif
  }
}
 800904e:	b005      	add	sp, #20
 8009050:	f85d fb04 	ldr.w	pc, [sp], #4
 8009054:	200018a0 	.word	0x200018a0
 8009058:	40021000 	.word	0x40021000
 800905c:	f3af 8000 	nop.w

08009060 <usb_lld_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_reset(USBDriver *usbp) {
 8009060:	b510      	push	{r4, lr}
 8009062:	b084      	sub	sp, #16
 8009064:	9001      	str	r0, [sp, #4]
  unsigned i;
  stm32_otg_t *otgp = usbp->otg;
 8009066:	9b01      	ldr	r3, [sp, #4]
 8009068:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800906a:	9302      	str	r3, [sp, #8]

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);
 800906c:	9801      	ldr	r0, [sp, #4]
 800906e:	2100      	movs	r1, #0
 8009070:	f7ff fa36 	bl	80084e0 <otg_txfifo_flush>

  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
 8009074:	9b02      	ldr	r3, [sp, #8]
 8009076:	2200      	movs	r2, #0
 8009078:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 800907c:	9b02      	ldr	r3, [sp, #8]
 800907e:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 8009082:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8009086:	2300      	movs	r3, #0
 8009088:	9303      	str	r3, [sp, #12]
 800908a:	e024      	b.n	80090d6 <usb_lld_reset+0x76>
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 800908c:	9a02      	ldr	r2, [sp, #8]
 800908e:	9b03      	ldr	r3, [sp, #12]
 8009090:	3348      	adds	r3, #72	; 0x48
 8009092:	015b      	lsls	r3, r3, #5
 8009094:	4413      	add	r3, r2
 8009096:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 800909a:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 800909c:	9a02      	ldr	r2, [sp, #8]
 800909e:	9b03      	ldr	r3, [sp, #12]
 80090a0:	3358      	adds	r3, #88	; 0x58
 80090a2:	015b      	lsls	r3, r3, #5
 80090a4:	4413      	add	r3, r2
 80090a6:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80090aa:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80090ac:	9a02      	ldr	r2, [sp, #8]
 80090ae:	9b03      	ldr	r3, [sp, #12]
 80090b0:	015b      	lsls	r3, r3, #5
 80090b2:	4413      	add	r3, r2
 80090b4:	f603 1308 	addw	r3, r3, #2312	; 0x908
 80090b8:	f04f 32ff 	mov.w	r2, #4294967295
 80090bc:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 80090be:	9a02      	ldr	r2, [sp, #8]
 80090c0:	9b03      	ldr	r3, [sp, #12]
 80090c2:	015b      	lsls	r3, r3, #5
 80090c4:	4413      	add	r3, r2
 80090c6:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 80090ca:	f04f 32ff 	mov.w	r2, #4294967295
 80090ce:	601a      	str	r2, [r3, #0]
  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80090d0:	9b03      	ldr	r3, [sp, #12]
 80090d2:	3301      	adds	r3, #1
 80090d4:	9303      	str	r3, [sp, #12]
 80090d6:	9b01      	ldr	r3, [sp, #4]
 80090d8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80090da:	689a      	ldr	r2, [r3, #8]
 80090dc:	9b03      	ldr	r3, [sp, #12]
 80090de:	429a      	cmp	r2, r3
 80090e0:	d2d4      	bcs.n	800908c <usb_lld_reset+0x2c>
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  }

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);
 80090e2:	9801      	ldr	r0, [sp, #4]
 80090e4:	f7ff fa1c 	bl	8008520 <otg_ram_reset>

  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 80090e8:	9b01      	ldr	r3, [sp, #4]
 80090ea:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80090ec:	681a      	ldr	r2, [r3, #0]
 80090ee:	9b02      	ldr	r3, [sp, #8]
 80090f0:	625a      	str	r2, [r3, #36]	; 0x24
  otg_rxfifo_flush(usbp);
 80090f2:	9801      	ldr	r0, [sp, #4]
 80090f4:	f7ff f9dc 	bl	80084b0 <otg_rxfifo_flush>

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 80090f8:	9b02      	ldr	r3, [sp, #8]
 80090fa:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
 80090fe:	f423 62fe 	bic.w	r2, r3, #2032	; 0x7f0
 8009102:	9b02      	ldr	r3, [sp, #8]
 8009104:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8009108:	9b02      	ldr	r3, [sp, #8]
 800910a:	699b      	ldr	r3, [r3, #24]
 800910c:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 8009110:	f043 0310 	orr.w	r3, r3, #16
 8009114:	9a02      	ldr	r2, [sp, #8]
 8009116:	6193      	str	r3, [r2, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8009118:	9b02      	ldr	r3, [sp, #8]
 800911a:	2209      	movs	r2, #9
 800911c:	f8c3 2810 	str.w	r2, [r3, #2064]	; 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 8009120:	9b02      	ldr	r3, [sp, #8]
 8009122:	2209      	movs	r2, #9
 8009124:	f8c3 2814 	str.w	r2, [r3, #2068]	; 0x814

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 8009128:	9b01      	ldr	r3, [sp, #4]
 800912a:	4a16      	ldr	r2, [pc, #88]	; (8009184 <usb_lld_reset+0x124>)
 800912c:	60da      	str	r2, [r3, #12]
  otgp->oe[0].DOEPTSIZ = 0;
 800912e:	9b02      	ldr	r3, [sp, #8]
 8009130:	2200      	movs	r2, #0
 8009132:	f8c3 2b10 	str.w	r2, [r3, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
 8009136:	2340      	movs	r3, #64	; 0x40
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
  otgp->oe[0].DOEPTSIZ = 0;
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 8009138:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800913c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8009140:	9a02      	ldr	r2, [sp, #8]
 8009142:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
 8009146:	9b02      	ldr	r3, [sp, #8]
 8009148:	2200      	movs	r2, #0
 800914a:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
 800914e:	2340      	movs	r3, #64	; 0x40
 8009150:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8009154:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  usbp->epc[0] = &ep0config;
  otgp->oe[0].DOEPTSIZ = 0;
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 8009158:	9a02      	ldr	r2, [sp, #8]
 800915a:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 800915e:	2340      	movs	r3, #64	; 0x40
 8009160:	089b      	lsrs	r3, r3, #2
 8009162:	b29b      	uxth	r3, r3
 8009164:	041b      	lsls	r3, r3, #16
 8009166:	461c      	mov	r4, r3
                   DIEPTXF_INEPTXSA(otg_ram_alloc(usbp,
 8009168:	2340      	movs	r3, #64	; 0x40
 800916a:	089b      	lsrs	r3, r3, #2
 800916c:	b29b      	uxth	r3, r3
 800916e:	9801      	ldr	r0, [sp, #4]
 8009170:	4619      	mov	r1, r3
 8009172:	f7ff f9e5 	bl	8008540 <otg_ram_alloc>
 8009176:	4603      	mov	r3, r0
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8009178:	ea44 0203 	orr.w	r2, r4, r3
 800917c:	9b02      	ldr	r3, [sp, #8]
 800917e:	629a      	str	r2, [r3, #40]	; 0x28
                   DIEPTXF_INEPTXSA(otg_ram_alloc(usbp,
                                                  ep0config.in_maxsize / 4));
}
 8009180:	b004      	add	sp, #16
 8009182:	bd10      	pop	{r4, pc}
 8009184:	08017990 	.word	0x08017990
 8009188:	f3af 8000 	nop.w
 800918c:	f3af 8000 	nop.w

08009190 <usb_lld_set_address>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {
 8009190:	b084      	sub	sp, #16
 8009192:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8009194:	9b01      	ldr	r3, [sp, #4]
 8009196:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8009198:	9303      	str	r3, [sp, #12]

  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 800919a:	9b03      	ldr	r3, [sp, #12]
 800919c:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
 80091a0:	f423 62fe 	bic.w	r2, r3, #2032	; 0x7f0
 80091a4:	9b01      	ldr	r3, [sp, #4]
 80091a6:	f893 3066 	ldrb.w	r3, [r3, #102]	; 0x66
 80091aa:	011b      	lsls	r3, r3, #4
 80091ac:	431a      	orrs	r2, r3
 80091ae:	9b03      	ldr	r3, [sp, #12]
 80091b0:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
}
 80091b4:	b004      	add	sp, #16
 80091b6:	4770      	bx	lr
 80091b8:	f3af 8000 	nop.w
 80091bc:	f3af 8000 	nop.w

080091c0 <usb_lld_init_endpoint>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 80091c0:	b530      	push	{r4, r5, lr}
 80091c2:	b087      	sub	sp, #28
 80091c4:	9001      	str	r0, [sp, #4]
 80091c6:	460b      	mov	r3, r1
 80091c8:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl, fsize;
  stm32_otg_t *otgp = usbp->otg;
 80091cc:	9b01      	ldr	r3, [sp, #4]
 80091ce:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80091d0:	9303      	str	r3, [sp, #12]

  /* IN and OUT common parameters.*/
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 80091d2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80091d6:	9a01      	ldr	r2, [sp, #4]
 80091d8:	3302      	adds	r3, #2
 80091da:	009b      	lsls	r3, r3, #2
 80091dc:	4413      	add	r3, r2
 80091de:	685b      	ldr	r3, [r3, #4]
 80091e0:	681b      	ldr	r3, [r3, #0]
 80091e2:	f003 0303 	and.w	r3, r3, #3
 80091e6:	2b03      	cmp	r3, #3
 80091e8:	f200 8108 	bhi.w	80093fc <usb_lld_init_endpoint+0x23c>
 80091ec:	a201      	add	r2, pc, #4	; (adr r2, 80091f4 <usb_lld_init_endpoint+0x34>)
 80091ee:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80091f2:	bf00      	nop
 80091f4:	08009205 	.word	0x08009205
 80091f8:	0800920b 	.word	0x0800920b
 80091fc:	08009211 	.word	0x08009211
 8009200:	08009217 	.word	0x08009217
  case USB_EP_MODE_TYPE_CTRL:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL;
 8009204:	4b7f      	ldr	r3, [pc, #508]	; (8009404 <usb_lld_init_endpoint+0x244>)
 8009206:	9305      	str	r3, [sp, #20]
    break;
 8009208:	e008      	b.n	800921c <usb_lld_init_endpoint+0x5c>
  case USB_EP_MODE_TYPE_ISOC:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_ISO;
 800920a:	4b7f      	ldr	r3, [pc, #508]	; (8009408 <usb_lld_init_endpoint+0x248>)
 800920c:	9305      	str	r3, [sp, #20]
    break;
 800920e:	e005      	b.n	800921c <usb_lld_init_endpoint+0x5c>
  case USB_EP_MODE_TYPE_BULK:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_BULK;
 8009210:	4b7e      	ldr	r3, [pc, #504]	; (800940c <usb_lld_init_endpoint+0x24c>)
 8009212:	9305      	str	r3, [sp, #20]
    break;
 8009214:	e002      	b.n	800921c <usb_lld_init_endpoint+0x5c>
  case USB_EP_MODE_TYPE_INTR:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
 8009216:	4b7e      	ldr	r3, [pc, #504]	; (8009410 <usb_lld_init_endpoint+0x250>)
 8009218:	9305      	str	r3, [sp, #20]
    break;
 800921a:	bf00      	nop
  default:
    return;
  }

  /* OUT endpoint activation or deactivation.*/
  otgp->oe[ep].DOEPTSIZ = 0;
 800921c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009220:	9a03      	ldr	r2, [sp, #12]
 8009222:	015b      	lsls	r3, r3, #5
 8009224:	4413      	add	r3, r2
 8009226:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 800922a:	2200      	movs	r2, #0
 800922c:	601a      	str	r2, [r3, #0]
  if (usbp->epc[ep]->out_state != NULL) {
 800922e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009232:	9a01      	ldr	r2, [sp, #4]
 8009234:	3302      	adds	r3, #2
 8009236:	009b      	lsls	r3, r3, #2
 8009238:	4413      	add	r3, r2
 800923a:	685b      	ldr	r3, [r3, #4]
 800923c:	699b      	ldr	r3, [r3, #24]
 800923e:	2b00      	cmp	r3, #0
 8009240:	d020      	beq.n	8009284 <usb_lld_init_endpoint+0xc4>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 8009242:	f89d 0003 	ldrb.w	r0, [sp, #3]
 8009246:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800924a:	9a01      	ldr	r2, [sp, #4]
 800924c:	3302      	adds	r3, #2
 800924e:	009b      	lsls	r3, r3, #2
 8009250:	4413      	add	r3, r2
 8009252:	685b      	ldr	r3, [r3, #4]
 8009254:	8a5b      	ldrh	r3, [r3, #18]
 8009256:	461a      	mov	r2, r3
 8009258:	9b05      	ldr	r3, [sp, #20]
 800925a:	431a      	orrs	r2, r3
 800925c:	9903      	ldr	r1, [sp, #12]
 800925e:	f100 0358 	add.w	r3, r0, #88	; 0x58
 8009262:	015b      	lsls	r3, r3, #5
 8009264:	440b      	add	r3, r1
 8009266:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 8009268:	9b03      	ldr	r3, [sp, #12]
 800926a:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 800926e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009272:	3310      	adds	r3, #16
 8009274:	2101      	movs	r1, #1
 8009276:	fa01 f303 	lsl.w	r3, r1, r3
 800927a:	431a      	orrs	r2, r3
 800927c:	9b03      	ldr	r3, [sp, #12]
 800927e:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 8009282:	e01d      	b.n	80092c0 <usb_lld_init_endpoint+0x100>
  }
  else {
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 8009284:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009288:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800928c:	9903      	ldr	r1, [sp, #12]
 800928e:	3258      	adds	r2, #88	; 0x58
 8009290:	0152      	lsls	r2, r2, #5
 8009292:	440a      	add	r2, r1
 8009294:	6812      	ldr	r2, [r2, #0]
 8009296:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800929a:	9903      	ldr	r1, [sp, #12]
 800929c:	3358      	adds	r3, #88	; 0x58
 800929e:	015b      	lsls	r3, r3, #5
 80092a0:	440b      	add	r3, r1
 80092a2:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 80092a4:	9b03      	ldr	r3, [sp, #12]
 80092a6:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 80092aa:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80092ae:	3310      	adds	r3, #16
 80092b0:	2101      	movs	r1, #1
 80092b2:	fa01 f303 	lsl.w	r3, r1, r3
 80092b6:	43db      	mvns	r3, r3
 80092b8:	401a      	ands	r2, r3
 80092ba:	9b03      	ldr	r3, [sp, #12]
 80092bc:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
  }

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
 80092c0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80092c4:	9a03      	ldr	r2, [sp, #12]
 80092c6:	015b      	lsls	r3, r3, #5
 80092c8:	4413      	add	r3, r2
 80092ca:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 80092ce:	2200      	movs	r2, #0
 80092d0:	601a      	str	r2, [r3, #0]
  if (usbp->epc[ep]->in_state != NULL) {
 80092d2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80092d6:	9a01      	ldr	r2, [sp, #4]
 80092d8:	3302      	adds	r3, #2
 80092da:	009b      	lsls	r3, r3, #2
 80092dc:	4413      	add	r3, r2
 80092de:	685b      	ldr	r3, [r3, #4]
 80092e0:	695b      	ldr	r3, [r3, #20]
 80092e2:	2b00      	cmp	r3, #0
 80092e4:	d05d      	beq.n	80093a2 <usb_lld_init_endpoint+0x1e2>
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
 80092e6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80092ea:	9a01      	ldr	r2, [sp, #4]
 80092ec:	3302      	adds	r3, #2
 80092ee:	009b      	lsls	r3, r3, #2
 80092f0:	4413      	add	r3, r2
 80092f2:	685b      	ldr	r3, [r3, #4]
 80092f4:	8a1b      	ldrh	r3, [r3, #16]
 80092f6:	089b      	lsrs	r3, r3, #2
 80092f8:	b29b      	uxth	r3, r3
 80092fa:	9304      	str	r3, [sp, #16]
    if (usbp->epc[ep]->in_multiplier > 1)
 80092fc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009300:	9a01      	ldr	r2, [sp, #4]
 8009302:	3302      	adds	r3, #2
 8009304:	009b      	lsls	r3, r3, #2
 8009306:	4413      	add	r3, r2
 8009308:	685b      	ldr	r3, [r3, #4]
 800930a:	8b9b      	ldrh	r3, [r3, #28]
 800930c:	2b01      	cmp	r3, #1
 800930e:	d90c      	bls.n	800932a <usb_lld_init_endpoint+0x16a>
      fsize *= usbp->epc[ep]->in_multiplier;
 8009310:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009314:	9a01      	ldr	r2, [sp, #4]
 8009316:	3302      	adds	r3, #2
 8009318:	009b      	lsls	r3, r3, #2
 800931a:	4413      	add	r3, r2
 800931c:	685b      	ldr	r3, [r3, #4]
 800931e:	8b9b      	ldrh	r3, [r3, #28]
 8009320:	461a      	mov	r2, r3
 8009322:	9b04      	ldr	r3, [sp, #16]
 8009324:	fb02 f303 	mul.w	r3, r2, r3
 8009328:	9304      	str	r3, [sp, #16]
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 800932a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800932e:	1e5c      	subs	r4, r3, #1
 8009330:	9b04      	ldr	r3, [sp, #16]
 8009332:	041d      	lsls	r5, r3, #16
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
 8009334:	9801      	ldr	r0, [sp, #4]
 8009336:	9904      	ldr	r1, [sp, #16]
 8009338:	f7ff f902 	bl	8008540 <otg_ram_alloc>
 800933c:	4603      	mov	r3, r0
  if (usbp->epc[ep]->in_state != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 800933e:	ea45 0203 	orr.w	r2, r5, r3
 8009342:	9903      	ldr	r1, [sp, #12]
 8009344:	f104 0340 	add.w	r3, r4, #64	; 0x40
 8009348:	009b      	lsls	r3, r3, #2
 800934a:	440b      	add	r3, r1
 800934c:	605a      	str	r2, [r3, #4]
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);
 800934e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009352:	9801      	ldr	r0, [sp, #4]
 8009354:	4619      	mov	r1, r3
 8009356:	f7ff f8c3 	bl	80084e0 <otg_txfifo_flush>

    otgp->ie[ep].DIEPCTL = ctl |
 800935a:	f89d 0003 	ldrb.w	r0, [sp, #3]
                           DIEPCTL_TXFNUM(ep) |
 800935e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009362:	059b      	lsls	r3, r3, #22
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 8009364:	461a      	mov	r2, r3
 8009366:	9b05      	ldr	r3, [sp, #20]
 8009368:	431a      	orrs	r2, r3
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
 800936a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800936e:	9901      	ldr	r1, [sp, #4]
 8009370:	3302      	adds	r3, #2
 8009372:	009b      	lsls	r3, r3, #2
 8009374:	440b      	add	r3, r1
 8009376:	685b      	ldr	r3, [r3, #4]
 8009378:	8a1b      	ldrh	r3, [r3, #16]
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
                           DIEPCTL_TXFNUM(ep) |
 800937a:	431a      	orrs	r2, r3
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 800937c:	9903      	ldr	r1, [sp, #12]
 800937e:	f100 0348 	add.w	r3, r0, #72	; 0x48
 8009382:	015b      	lsls	r3, r3, #5
 8009384:	440b      	add	r3, r1
 8009386:	601a      	str	r2, [r3, #0]
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 8009388:	9b03      	ldr	r3, [sp, #12]
 800938a:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 800938e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009392:	2101      	movs	r1, #1
 8009394:	fa01 f303 	lsl.w	r3, r1, r3
 8009398:	431a      	orrs	r2, r3
 800939a:	9b03      	ldr	r3, [sp, #12]
 800939c:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 80093a0:	e02d      	b.n	80093fe <usb_lld_init_endpoint+0x23e>
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 80093a2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80093a6:	3b01      	subs	r3, #1
 80093a8:	9a03      	ldr	r2, [sp, #12]
 80093aa:	3340      	adds	r3, #64	; 0x40
 80093ac:	009b      	lsls	r3, r3, #2
 80093ae:	4413      	add	r3, r2
 80093b0:	4a18      	ldr	r2, [pc, #96]	; (8009414 <usb_lld_init_endpoint+0x254>)
 80093b2:	605a      	str	r2, [r3, #4]
    otg_txfifo_flush(usbp, ep);
 80093b4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80093b8:	9801      	ldr	r0, [sp, #4]
 80093ba:	4619      	mov	r1, r3
 80093bc:	f7ff f890 	bl	80084e0 <otg_txfifo_flush>
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 80093c0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80093c4:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80093c8:	9903      	ldr	r1, [sp, #12]
 80093ca:	3248      	adds	r2, #72	; 0x48
 80093cc:	0152      	lsls	r2, r2, #5
 80093ce:	440a      	add	r2, r1
 80093d0:	6812      	ldr	r2, [r2, #0]
 80093d2:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80093d6:	9903      	ldr	r1, [sp, #12]
 80093d8:	3348      	adds	r3, #72	; 0x48
 80093da:	015b      	lsls	r3, r3, #5
 80093dc:	440b      	add	r3, r1
 80093de:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 80093e0:	9b03      	ldr	r3, [sp, #12]
 80093e2:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 80093e6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80093ea:	2101      	movs	r1, #1
 80093ec:	fa01 f303 	lsl.w	r3, r1, r3
 80093f0:	43db      	mvns	r3, r3
 80093f2:	401a      	ands	r2, r3
 80093f4:	9b03      	ldr	r3, [sp, #12]
 80093f6:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 80093fa:	e000      	b.n	80093fe <usb_lld_init_endpoint+0x23e>
    break;
  case USB_EP_MODE_TYPE_INTR:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
    break;
  default:
    return;
 80093fc:	bf00      	nop
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
    otg_txfifo_flush(usbp, ep);
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
  }
}
 80093fe:	b007      	add	sp, #28
 8009400:	bd30      	pop	{r4, r5, pc}
 8009402:	bf00      	nop
 8009404:	10008000 	.word	0x10008000
 8009408:	10048000 	.word	0x10048000
 800940c:	10088000 	.word	0x10088000
 8009410:	100c8000 	.word	0x100c8000
 8009414:	02000400 	.word	0x02000400
 8009418:	f3af 8000 	nop.w
 800941c:	f3af 8000 	nop.w

08009420 <usb_lld_disable_endpoints>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_disable_endpoints(USBDriver *usbp) {
 8009420:	b500      	push	{lr}
 8009422:	b083      	sub	sp, #12
 8009424:	9001      	str	r0, [sp, #4]

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);
 8009426:	9801      	ldr	r0, [sp, #4]
 8009428:	f7ff f87a 	bl	8008520 <otg_ram_reset>

  /* Disabling all endpoints.*/
  otg_disable_ep(usbp);
 800942c:	9801      	ldr	r0, [sp, #4]
 800942e:	f7fe fff7 	bl	8008420 <otg_disable_ep>
}
 8009432:	b003      	add	sp, #12
 8009434:	f85d fb04 	ldr.w	pc, [sp], #4
 8009438:	f3af 8000 	nop.w
 800943c:	f3af 8000 	nop.w

08009440 <usb_lld_get_status_out>:
 * @retval EP_STATUS_STALLED  The endpoint is stalled.
 * @retval EP_STATUS_ACTIVE   The endpoint is active.
 *
 * @notapi
 */
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {
 8009440:	b084      	sub	sp, #16
 8009442:	9001      	str	r0, [sp, #4]
 8009444:	460b      	mov	r3, r1
 8009446:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->oe[ep].DOEPCTL;
 800944a:	9b01      	ldr	r3, [sp, #4]
 800944c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800944e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009452:	3358      	adds	r3, #88	; 0x58
 8009454:	015b      	lsls	r3, r3, #5
 8009456:	4413      	add	r3, r2
 8009458:	681b      	ldr	r3, [r3, #0]
 800945a:	9303      	str	r3, [sp, #12]
  if (!(ctl & DOEPCTL_USBAEP))
 800945c:	9b03      	ldr	r3, [sp, #12]
 800945e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8009462:	2b00      	cmp	r3, #0
 8009464:	d101      	bne.n	800946a <usb_lld_get_status_out+0x2a>
    return EP_STATUS_DISABLED;
 8009466:	2300      	movs	r3, #0
 8009468:	e007      	b.n	800947a <usb_lld_get_status_out+0x3a>
  if (ctl & DOEPCTL_STALL)
 800946a:	9b03      	ldr	r3, [sp, #12]
 800946c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8009470:	2b00      	cmp	r3, #0
 8009472:	d001      	beq.n	8009478 <usb_lld_get_status_out+0x38>
    return EP_STATUS_STALLED;
 8009474:	2301      	movs	r3, #1
 8009476:	e000      	b.n	800947a <usb_lld_get_status_out+0x3a>
  return EP_STATUS_ACTIVE;
 8009478:	2302      	movs	r3, #2
}
 800947a:	4618      	mov	r0, r3
 800947c:	b004      	add	sp, #16
 800947e:	4770      	bx	lr

08009480 <usb_lld_get_status_in>:
 * @retval EP_STATUS_STALLED  The endpoint is stalled.
 * @retval EP_STATUS_ACTIVE   The endpoint is active.
 *
 * @notapi
 */
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {
 8009480:	b084      	sub	sp, #16
 8009482:	9001      	str	r0, [sp, #4]
 8009484:	460b      	mov	r3, r1
 8009486:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->ie[ep].DIEPCTL;
 800948a:	9b01      	ldr	r3, [sp, #4]
 800948c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800948e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009492:	3348      	adds	r3, #72	; 0x48
 8009494:	015b      	lsls	r3, r3, #5
 8009496:	4413      	add	r3, r2
 8009498:	681b      	ldr	r3, [r3, #0]
 800949a:	9303      	str	r3, [sp, #12]
  if (!(ctl & DIEPCTL_USBAEP))
 800949c:	9b03      	ldr	r3, [sp, #12]
 800949e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 80094a2:	2b00      	cmp	r3, #0
 80094a4:	d101      	bne.n	80094aa <usb_lld_get_status_in+0x2a>
    return EP_STATUS_DISABLED;
 80094a6:	2300      	movs	r3, #0
 80094a8:	e007      	b.n	80094ba <usb_lld_get_status_in+0x3a>
  if (ctl & DIEPCTL_STALL)
 80094aa:	9b03      	ldr	r3, [sp, #12]
 80094ac:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80094b0:	2b00      	cmp	r3, #0
 80094b2:	d001      	beq.n	80094b8 <usb_lld_get_status_in+0x38>
    return EP_STATUS_STALLED;
 80094b4:	2301      	movs	r3, #1
 80094b6:	e000      	b.n	80094ba <usb_lld_get_status_in+0x3a>
  return EP_STATUS_ACTIVE;
 80094b8:	2302      	movs	r3, #2
}
 80094ba:	4618      	mov	r0, r3
 80094bc:	b004      	add	sp, #16
 80094be:	4770      	bx	lr

080094c0 <usb_lld_read_setup>:
 * @param[in] ep        endpoint number
 * @param[out] buf      buffer where to copy the packet data
 *
 * @notapi
 */
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {
 80094c0:	b500      	push	{lr}
 80094c2:	b085      	sub	sp, #20
 80094c4:	9003      	str	r0, [sp, #12]
 80094c6:	460b      	mov	r3, r1
 80094c8:	9201      	str	r2, [sp, #4]
 80094ca:	f88d 300b 	strb.w	r3, [sp, #11]

  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 80094ce:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80094d2:	9a03      	ldr	r2, [sp, #12]
 80094d4:	3302      	adds	r3, #2
 80094d6:	009b      	lsls	r3, r3, #2
 80094d8:	4413      	add	r3, r2
 80094da:	685b      	ldr	r3, [r3, #4]
 80094dc:	6a1b      	ldr	r3, [r3, #32]
 80094de:	9801      	ldr	r0, [sp, #4]
 80094e0:	4619      	mov	r1, r3
 80094e2:	2208      	movs	r2, #8
 80094e4:	f00d fdcc 	bl	8017080 <memcpy>
}
 80094e8:	b005      	add	sp, #20
 80094ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80094ee:	bf00      	nop

080094f0 <usb_lld_start_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 80094f0:	b086      	sub	sp, #24
 80094f2:	9001      	str	r0, [sp, #4]
 80094f4:	460b      	mov	r3, r1
 80094f6:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t pcnt, rxsize;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 80094fa:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80094fe:	9a01      	ldr	r2, [sp, #4]
 8009500:	3302      	adds	r3, #2
 8009502:	009b      	lsls	r3, r3, #2
 8009504:	4413      	add	r3, r2
 8009506:	685b      	ldr	r3, [r3, #4]
 8009508:	699b      	ldr	r3, [r3, #24]
 800950a:	9305      	str	r3, [sp, #20]

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
 800950c:	9b05      	ldr	r3, [sp, #20]
 800950e:	681a      	ldr	r2, [r3, #0]
 8009510:	9b05      	ldr	r3, [sp, #20]
 8009512:	60da      	str	r2, [r3, #12]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
 8009514:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009518:	2b00      	cmp	r3, #0
 800951a:	d106      	bne.n	800952a <usb_lld_start_out+0x3a>
 800951c:	9b05      	ldr	r3, [sp, #20]
 800951e:	681b      	ldr	r3, [r3, #0]
 8009520:	2b40      	cmp	r3, #64	; 0x40
 8009522:	d902      	bls.n	800952a <usb_lld_start_out+0x3a>
      osp->rxsize = EP0_MAX_OUTSIZE;
 8009524:	9b05      	ldr	r3, [sp, #20]
 8009526:	2240      	movs	r2, #64	; 0x40
 8009528:	601a      	str	r2, [r3, #0]
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 800952a:	9b05      	ldr	r3, [sp, #20]
 800952c:	681a      	ldr	r2, [r3, #0]
 800952e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009532:	9901      	ldr	r1, [sp, #4]
 8009534:	3302      	adds	r3, #2
 8009536:	009b      	lsls	r3, r3, #2
 8009538:	440b      	add	r3, r1
 800953a:	685b      	ldr	r3, [r3, #4]
 800953c:	8a5b      	ldrh	r3, [r3, #18]
 800953e:	4413      	add	r3, r2
 8009540:	1e5a      	subs	r2, r3, #1
           usbp->epc[ep]->out_maxsize;
 8009542:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009546:	9901      	ldr	r1, [sp, #4]
 8009548:	3302      	adds	r3, #2
 800954a:	009b      	lsls	r3, r3, #2
 800954c:	440b      	add	r3, r1
 800954e:	685b      	ldr	r3, [r3, #4]
 8009550:	8a5b      	ldrh	r3, [r3, #18]
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8009552:	fbb2 f3f3 	udiv	r3, r2, r3
 8009556:	9304      	str	r3, [sp, #16]
           usbp->epc[ep]->out_maxsize;
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
 8009558:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800955c:	9a01      	ldr	r2, [sp, #4]
 800955e:	3302      	adds	r3, #2
 8009560:	009b      	lsls	r3, r3, #2
 8009562:	4413      	add	r3, r2
 8009564:	685b      	ldr	r3, [r3, #4]
 8009566:	8a5b      	ldrh	r3, [r3, #18]
 8009568:	9a04      	ldr	r2, [sp, #16]
 800956a:	fb02 f303 	mul.w	r3, r2, r3
 800956e:	3303      	adds	r3, #3
 8009570:	f023 0303 	bic.w	r3, r3, #3
 8009574:	9303      	str	r3, [sp, #12]

  /*Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8009576:	9b01      	ldr	r3, [sp, #4]
 8009578:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800957a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800957e:	9a04      	ldr	r2, [sp, #16]
 8009580:	04d0      	lsls	r0, r2, #19
 8009582:	9a03      	ldr	r2, [sp, #12]
 8009584:	4302      	orrs	r2, r0
 8009586:	f042 42c0 	orr.w	r2, r2, #1610612736	; 0x60000000
 800958a:	015b      	lsls	r3, r3, #5
 800958c:	440b      	add	r3, r1
 800958e:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 8009592:	601a      	str	r2, [r3, #0]
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8009594:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009598:	9a01      	ldr	r2, [sp, #4]
 800959a:	3302      	adds	r3, #2
 800959c:	009b      	lsls	r3, r3, #2
 800959e:	4413      	add	r3, r2
 80095a0:	685b      	ldr	r3, [r3, #4]
 80095a2:	681b      	ldr	r3, [r3, #0]
 80095a4:	f003 0303 	and.w	r3, r3, #3
 80095a8:	2b01      	cmp	r3, #1
 80095aa:	d12c      	bne.n	8009606 <usb_lld_start_out+0x116>
    /* Odd/even bit toggling for isochronous endpoint.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 80095ac:	9b01      	ldr	r3, [sp, #4]
 80095ae:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80095b0:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 80095b4:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80095b8:	2b00      	cmp	r3, #0
 80095ba:	d012      	beq.n	80095e2 <usb_lld_start_out+0xf2>
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
 80095bc:	9b01      	ldr	r3, [sp, #4]
 80095be:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 80095c0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80095c4:	9a01      	ldr	r2, [sp, #4]
 80095c6:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 80095c8:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80095cc:	3258      	adds	r2, #88	; 0x58
 80095ce:	0152      	lsls	r2, r2, #5
 80095d0:	4402      	add	r2, r0
 80095d2:	6812      	ldr	r2, [r2, #0]
 80095d4:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80095d8:	3358      	adds	r3, #88	; 0x58
 80095da:	015b      	lsls	r3, r3, #5
 80095dc:	440b      	add	r3, r1
 80095de:	601a      	str	r2, [r3, #0]
 80095e0:	e011      	b.n	8009606 <usb_lld_start_out+0x116>
    else
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
 80095e2:	9b01      	ldr	r3, [sp, #4]
 80095e4:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 80095e6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80095ea:	9a01      	ldr	r2, [sp, #4]
 80095ec:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 80095ee:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80095f2:	3258      	adds	r2, #88	; 0x58
 80095f4:	0152      	lsls	r2, r2, #5
 80095f6:	4402      	add	r2, r0
 80095f8:	6812      	ldr	r2, [r2, #0]
 80095fa:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 80095fe:	3358      	adds	r3, #88	; 0x58
 8009600:	015b      	lsls	r3, r3, #5
 8009602:	440b      	add	r3, r1
 8009604:	601a      	str	r2, [r3, #0]
  }

  /* Starting operation.*/
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 8009606:	9b01      	ldr	r3, [sp, #4]
 8009608:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800960a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800960e:	9a01      	ldr	r2, [sp, #4]
 8009610:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8009612:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8009616:	3258      	adds	r2, #88	; 0x58
 8009618:	0152      	lsls	r2, r2, #5
 800961a:	4402      	add	r2, r0
 800961c:	6812      	ldr	r2, [r2, #0]
 800961e:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8009622:	3358      	adds	r3, #88	; 0x58
 8009624:	015b      	lsls	r3, r3, #5
 8009626:	440b      	add	r3, r1
 8009628:	601a      	str	r2, [r3, #0]
}
 800962a:	b006      	add	sp, #24
 800962c:	4770      	bx	lr
 800962e:	bf00      	nop

08009630 <usb_lld_start_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8009630:	b084      	sub	sp, #16
 8009632:	9001      	str	r0, [sp, #4]
 8009634:	460b      	mov	r3, r1
 8009636:	f88d 3003 	strb.w	r3, [sp, #3]
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800963a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800963e:	9a01      	ldr	r2, [sp, #4]
 8009640:	3302      	adds	r3, #2
 8009642:	009b      	lsls	r3, r3, #2
 8009644:	4413      	add	r3, r2
 8009646:	685b      	ldr	r3, [r3, #4]
 8009648:	695b      	ldr	r3, [r3, #20]
 800964a:	9303      	str	r3, [sp, #12]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
 800964c:	9b03      	ldr	r3, [sp, #12]
 800964e:	681a      	ldr	r2, [r3, #0]
 8009650:	9b03      	ldr	r3, [sp, #12]
 8009652:	60da      	str	r2, [r3, #12]
  if (isp->txsize == 0) {
 8009654:	9b03      	ldr	r3, [sp, #12]
 8009656:	681b      	ldr	r3, [r3, #0]
 8009658:	2b00      	cmp	r3, #0
 800965a:	d10b      	bne.n	8009674 <usb_lld_start_in+0x44>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 800965c:	9b01      	ldr	r3, [sp, #4]
 800965e:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8009660:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009664:	015b      	lsls	r3, r3, #5
 8009666:	4413      	add	r3, r2
 8009668:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 800966c:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8009670:	601a      	str	r2, [r3, #0]
 8009672:	e031      	b.n	80096d8 <usb_lld_start_in+0xa8>
  }
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 8009674:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009678:	2b00      	cmp	r3, #0
 800967a:	d106      	bne.n	800968a <usb_lld_start_in+0x5a>
 800967c:	9b03      	ldr	r3, [sp, #12]
 800967e:	681b      	ldr	r3, [r3, #0]
 8009680:	2b40      	cmp	r3, #64	; 0x40
 8009682:	d902      	bls.n	800968a <usb_lld_start_in+0x5a>
      isp->txsize = EP0_MAX_INSIZE;
 8009684:	9b03      	ldr	r3, [sp, #12]
 8009686:	2240      	movs	r2, #64	; 0x40
 8009688:	601a      	str	r2, [r3, #0]

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 800968a:	9b03      	ldr	r3, [sp, #12]
 800968c:	681a      	ldr	r2, [r3, #0]
 800968e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009692:	9901      	ldr	r1, [sp, #4]
 8009694:	3302      	adds	r3, #2
 8009696:	009b      	lsls	r3, r3, #2
 8009698:	440b      	add	r3, r1
 800969a:	685b      	ldr	r3, [r3, #4]
 800969c:	8a1b      	ldrh	r3, [r3, #16]
 800969e:	4413      	add	r3, r2
 80096a0:	1e5a      	subs	r2, r3, #1
                    usbp->epc[ep]->in_maxsize;
 80096a2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80096a6:	9901      	ldr	r1, [sp, #4]
 80096a8:	3302      	adds	r3, #2
 80096aa:	009b      	lsls	r3, r3, #2
 80096ac:	440b      	add	r3, r1
 80096ae:	685b      	ldr	r3, [r3, #4]
 80096b0:	8a1b      	ldrh	r3, [r3, #16]
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
      isp->txsize = EP0_MAX_INSIZE;

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 80096b2:	fbb2 f3f3 	udiv	r3, r2, r3
 80096b6:	9302      	str	r3, [sp, #8]
                    usbp->epc[ep]->in_maxsize;
    /* TODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 80096b8:	9b01      	ldr	r3, [sp, #4]
 80096ba:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 80096bc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80096c0:	9a02      	ldr	r2, [sp, #8]
 80096c2:	04d0      	lsls	r0, r2, #19
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
 80096c4:	9a03      	ldr	r2, [sp, #12]
 80096c6:	6812      	ldr	r2, [r2, #0]

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
                    usbp->epc[ep]->in_maxsize;
    /* TODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 80096c8:	4302      	orrs	r2, r0
 80096ca:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 80096ce:	015b      	lsls	r3, r3, #5
 80096d0:	440b      	add	r3, r1
 80096d2:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 80096d6:	601a      	str	r2, [r3, #0]
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 80096d8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80096dc:	9a01      	ldr	r2, [sp, #4]
 80096de:	3302      	adds	r3, #2
 80096e0:	009b      	lsls	r3, r3, #2
 80096e2:	4413      	add	r3, r2
 80096e4:	685b      	ldr	r3, [r3, #4]
 80096e6:	681b      	ldr	r3, [r3, #0]
 80096e8:	f003 0303 	and.w	r3, r3, #3
 80096ec:	2b01      	cmp	r3, #1
 80096ee:	d12c      	bne.n	800974a <usb_lld_start_in+0x11a>
    /* Odd/even bit toggling.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 80096f0:	9b01      	ldr	r3, [sp, #4]
 80096f2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80096f4:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 80096f8:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80096fc:	2b00      	cmp	r3, #0
 80096fe:	d012      	beq.n	8009726 <usb_lld_start_in+0xf6>
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
 8009700:	9b01      	ldr	r3, [sp, #4]
 8009702:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 8009704:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009708:	9a01      	ldr	r2, [sp, #4]
 800970a:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 800970c:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8009710:	3248      	adds	r2, #72	; 0x48
 8009712:	0152      	lsls	r2, r2, #5
 8009714:	4402      	add	r2, r0
 8009716:	6812      	ldr	r2, [r2, #0]
 8009718:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800971c:	3348      	adds	r3, #72	; 0x48
 800971e:	015b      	lsls	r3, r3, #5
 8009720:	440b      	add	r3, r1
 8009722:	601a      	str	r2, [r3, #0]
 8009724:	e011      	b.n	800974a <usb_lld_start_in+0x11a>
    else
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
 8009726:	9b01      	ldr	r3, [sp, #4]
 8009728:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800972a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800972e:	9a01      	ldr	r2, [sp, #4]
 8009730:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8009732:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8009736:	3248      	adds	r2, #72	; 0x48
 8009738:	0152      	lsls	r2, r2, #5
 800973a:	4402      	add	r2, r0
 800973c:	6812      	ldr	r2, [r2, #0]
 800973e:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8009742:	3348      	adds	r3, #72	; 0x48
 8009744:	015b      	lsls	r3, r3, #5
 8009746:	440b      	add	r3, r1
 8009748:	601a      	str	r2, [r3, #0]
  }

  /* Starting operation.*/
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 800974a:	9b01      	ldr	r3, [sp, #4]
 800974c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800974e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009752:	9a01      	ldr	r2, [sp, #4]
 8009754:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8009756:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800975a:	3248      	adds	r2, #72	; 0x48
 800975c:	0152      	lsls	r2, r2, #5
 800975e:	4402      	add	r2, r0
 8009760:	6812      	ldr	r2, [r2, #0]
 8009762:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8009766:	3348      	adds	r3, #72	; 0x48
 8009768:	015b      	lsls	r3, r3, #5
 800976a:	440b      	add	r3, r1
 800976c:	601a      	str	r2, [r3, #0]
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 800976e:	9b01      	ldr	r3, [sp, #4]
 8009770:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8009772:	9a01      	ldr	r2, [sp, #4]
 8009774:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
 8009776:	f8d2 1834 	ldr.w	r1, [r2, #2100]	; 0x834
 800977a:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800977e:	2001      	movs	r0, #1
 8009780:	fa00 f202 	lsl.w	r2, r0, r2
 8009784:	430a      	orrs	r2, r1
 8009786:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
}
 800978a:	b004      	add	sp, #16
 800978c:	4770      	bx	lr
 800978e:	bf00      	nop

08009790 <usb_lld_stall_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {
 8009790:	b082      	sub	sp, #8
 8009792:	9001      	str	r0, [sp, #4]
 8009794:	460b      	mov	r3, r1
 8009796:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 800979a:	9b01      	ldr	r3, [sp, #4]
 800979c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800979e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80097a2:	9a01      	ldr	r2, [sp, #4]
 80097a4:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 80097a6:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80097aa:	3258      	adds	r2, #88	; 0x58
 80097ac:	0152      	lsls	r2, r2, #5
 80097ae:	4402      	add	r2, r0
 80097b0:	6812      	ldr	r2, [r2, #0]
 80097b2:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80097b6:	3358      	adds	r3, #88	; 0x58
 80097b8:	015b      	lsls	r3, r3, #5
 80097ba:	440b      	add	r3, r1
 80097bc:	601a      	str	r2, [r3, #0]
}
 80097be:	b002      	add	sp, #8
 80097c0:	4770      	bx	lr
 80097c2:	bf00      	nop
 80097c4:	f3af 8000 	nop.w
 80097c8:	f3af 8000 	nop.w
 80097cc:	f3af 8000 	nop.w

080097d0 <usb_lld_stall_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {
 80097d0:	b082      	sub	sp, #8
 80097d2:	9001      	str	r0, [sp, #4]
 80097d4:	460b      	mov	r3, r1
 80097d6:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 80097da:	9b01      	ldr	r3, [sp, #4]
 80097dc:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 80097de:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80097e2:	9a01      	ldr	r2, [sp, #4]
 80097e4:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 80097e6:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80097ea:	3248      	adds	r2, #72	; 0x48
 80097ec:	0152      	lsls	r2, r2, #5
 80097ee:	4402      	add	r2, r0
 80097f0:	6812      	ldr	r2, [r2, #0]
 80097f2:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80097f6:	3348      	adds	r3, #72	; 0x48
 80097f8:	015b      	lsls	r3, r3, #5
 80097fa:	440b      	add	r3, r1
 80097fc:	601a      	str	r2, [r3, #0]
}
 80097fe:	b002      	add	sp, #8
 8009800:	4770      	bx	lr
 8009802:	bf00      	nop
 8009804:	f3af 8000 	nop.w
 8009808:	f3af 8000 	nop.w
 800980c:	f3af 8000 	nop.w

08009810 <usb_lld_clear_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {
 8009810:	b082      	sub	sp, #8
 8009812:	9001      	str	r0, [sp, #4]
 8009814:	460b      	mov	r3, r1
 8009816:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 800981a:	9b01      	ldr	r3, [sp, #4]
 800981c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800981e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009822:	9a01      	ldr	r2, [sp, #4]
 8009824:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8009826:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800982a:	3258      	adds	r2, #88	; 0x58
 800982c:	0152      	lsls	r2, r2, #5
 800982e:	4402      	add	r2, r0
 8009830:	6812      	ldr	r2, [r2, #0]
 8009832:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8009836:	3358      	adds	r3, #88	; 0x58
 8009838:	015b      	lsls	r3, r3, #5
 800983a:	440b      	add	r3, r1
 800983c:	601a      	str	r2, [r3, #0]
}
 800983e:	b002      	add	sp, #8
 8009840:	4770      	bx	lr
 8009842:	bf00      	nop
 8009844:	f3af 8000 	nop.w
 8009848:	f3af 8000 	nop.w
 800984c:	f3af 8000 	nop.w

08009850 <usb_lld_clear_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {
 8009850:	b082      	sub	sp, #8
 8009852:	9001      	str	r0, [sp, #4]
 8009854:	460b      	mov	r3, r1
 8009856:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 800985a:	9b01      	ldr	r3, [sp, #4]
 800985c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800985e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009862:	9a01      	ldr	r2, [sp, #4]
 8009864:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8009866:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800986a:	3248      	adds	r2, #72	; 0x48
 800986c:	0152      	lsls	r2, r2, #5
 800986e:	4402      	add	r2, r0
 8009870:	6812      	ldr	r2, [r2, #0]
 8009872:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8009876:	3348      	adds	r3, #72	; 0x48
 8009878:	015b      	lsls	r3, r3, #5
 800987a:	440b      	add	r3, r1
 800987c:	601a      	str	r2, [r3, #0]
}
 800987e:	b002      	add	sp, #8
 8009880:	4770      	bx	lr
 8009882:	bf00      	nop
 8009884:	f3af 8000 	nop.w
 8009888:	f3af 8000 	nop.w
 800988c:	f3af 8000 	nop.w

08009890 <usb_lld_pump>:
 *
 * @param[in] p         pointer to the @p USBDriver object
 *
 * @special
 */
void usb_lld_pump(void *p) {
 8009890:	b500      	push	{lr}
 8009892:	b089      	sub	sp, #36	; 0x24
 8009894:	9001      	str	r0, [sp, #4]
  USBDriver *usbp = (USBDriver *)p;
 8009896:	9b01      	ldr	r3, [sp, #4]
 8009898:	9306      	str	r3, [sp, #24]
  stm32_otg_t *otgp = usbp->otg;
 800989a:	9b06      	ldr	r3, [sp, #24]
 800989c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800989e:	9305      	str	r3, [sp, #20]

#if defined(_CHIBIOS_RT_)
  chRegSetThreadName("usb_lld_pump");
 80098a0:	483d      	ldr	r0, [pc, #244]	; (8009998 <usb_lld_pump+0x108>)
 80098a2:	f7fe fd3d 	bl	8008320 <chRegSetThreadName>
#endif
  osalSysLock();
 80098a6:	f7fe fd4b 	bl	8008340 <osalSysLock>
  while (true) {
    usbep_t ep;
    uint32_t epmask;

    /* Nothing to do, going to sleep.*/
    if ((usbp->state == USB_STOP) ||
 80098aa:	9b06      	ldr	r3, [sp, #24]
 80098ac:	781b      	ldrb	r3, [r3, #0]
 80098ae:	2b01      	cmp	r3, #1
 80098b0:	d009      	beq.n	80098c6 <usb_lld_pump+0x36>
        ((usbp->txpending == 0) && !(otgp->GINTSTS & GINTSTS_RXFLVL))) {
 80098b2:	9b06      	ldr	r3, [sp, #24]
 80098b4:	6f9b      	ldr	r3, [r3, #120]	; 0x78
  while (true) {
    usbep_t ep;
    uint32_t epmask;

    /* Nothing to do, going to sleep.*/
    if ((usbp->state == USB_STOP) ||
 80098b6:	2b00      	cmp	r3, #0
 80098b8:	d110      	bne.n	80098dc <usb_lld_pump+0x4c>
        ((usbp->txpending == 0) && !(otgp->GINTSTS & GINTSTS_RXFLVL))) {
 80098ba:	9b05      	ldr	r3, [sp, #20]
 80098bc:	695b      	ldr	r3, [r3, #20]
 80098be:	f003 0310 	and.w	r3, r3, #16
 80098c2:	2b00      	cmp	r3, #0
 80098c4:	d10a      	bne.n	80098dc <usb_lld_pump+0x4c>
      otgp->GINTMSK |= GINTMSK_RXFLVLM;
 80098c6:	9b05      	ldr	r3, [sp, #20]
 80098c8:	699b      	ldr	r3, [r3, #24]
 80098ca:	f043 0210 	orr.w	r2, r3, #16
 80098ce:	9b05      	ldr	r3, [sp, #20]
 80098d0:	619a      	str	r2, [r3, #24]
      osalThreadSuspendS(&usbp->wait);
 80098d2:	9b06      	ldr	r3, [sp, #24]
 80098d4:	337c      	adds	r3, #124	; 0x7c
 80098d6:	4618      	mov	r0, r3
 80098d8:	f7fe fd62 	bl	80083a0 <osalThreadSuspendS>
    }
    osalSysUnlock();
 80098dc:	f7fe fd38 	bl	8008350 <osalSysUnlock>

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80098e0:	2300      	movs	r3, #0
 80098e2:	f88d 301f 	strb.w	r3, [sp, #31]
 80098e6:	e04d      	b.n	8009984 <usb_lld_pump+0xf4>

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 80098e8:	e002      	b.n	80098f0 <usb_lld_pump+0x60>
        otg_rxfifo_handler(usbp);
 80098ea:	9806      	ldr	r0, [sp, #24]
 80098ec:	f7fe fe78 	bl	80085e0 <otg_rxfifo_handler>

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 80098f0:	9b05      	ldr	r3, [sp, #20]
 80098f2:	695b      	ldr	r3, [r3, #20]
 80098f4:	f003 0310 	and.w	r3, r3, #16
 80098f8:	2b00      	cmp	r3, #0
 80098fa:	d1f6      	bne.n	80098ea <usb_lld_pump+0x5a>
        otg_rxfifo_handler(usbp);
      }

      epmask = (1 << ep);
 80098fc:	f89d 301f 	ldrb.w	r3, [sp, #31]
 8009900:	2201      	movs	r2, #1
 8009902:	fa02 f303 	lsl.w	r3, r2, r3
 8009906:	9304      	str	r3, [sp, #16]
      if (usbp->txpending & epmask) {
 8009908:	9b06      	ldr	r3, [sp, #24]
 800990a:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800990c:	9b04      	ldr	r3, [sp, #16]
 800990e:	4013      	ands	r3, r2
 8009910:	2b00      	cmp	r3, #0
 8009912:	d032      	beq.n	800997a <usb_lld_pump+0xea>
        bool done;

        osalSysLock();
 8009914:	f7fe fd14 	bl	8008340 <osalSysLock>
           operation.
           Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
             "The application has to finish writing one complete packet before
              switching to a different channel/endpoint FIFO. Violating this
              rule results in an error.".*/
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 8009918:	9b05      	ldr	r3, [sp, #20]
 800991a:	689b      	ldr	r3, [r3, #8]
 800991c:	f023 0201 	bic.w	r2, r3, #1
 8009920:	9b05      	ldr	r3, [sp, #20]
 8009922:	609a      	str	r2, [r3, #8]
        usbp->txpending &= ~epmask;
 8009924:	9b06      	ldr	r3, [sp, #24]
 8009926:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 8009928:	9b04      	ldr	r3, [sp, #16]
 800992a:	43db      	mvns	r3, r3
 800992c:	401a      	ands	r2, r3
 800992e:	9b06      	ldr	r3, [sp, #24]
 8009930:	679a      	str	r2, [r3, #120]	; 0x78
        osalSysUnlock();
 8009932:	f7fe fd0d 	bl	8008350 <osalSysUnlock>

        done = otg_txfifo_handler(usbp, ep);
 8009936:	f89d 301f 	ldrb.w	r3, [sp, #31]
 800993a:	9806      	ldr	r0, [sp, #24]
 800993c:	4619      	mov	r1, r3
 800993e:	f7fe fed7 	bl	80086f0 <otg_txfifo_handler>
 8009942:	4603      	mov	r3, r0
 8009944:	f88d 300f 	strb.w	r3, [sp, #15]

        osalSysLock();
 8009948:	f7fe fcfa 	bl	8008340 <osalSysLock>
        otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 800994c:	9b05      	ldr	r3, [sp, #20]
 800994e:	689b      	ldr	r3, [r3, #8]
 8009950:	f043 0201 	orr.w	r2, r3, #1
 8009954:	9b05      	ldr	r3, [sp, #20]
 8009956:	609a      	str	r2, [r3, #8]
        if (!done)
 8009958:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800995c:	f083 0301 	eor.w	r3, r3, #1
 8009960:	b2db      	uxtb	r3, r3
 8009962:	2b00      	cmp	r3, #0
 8009964:	d007      	beq.n	8009976 <usb_lld_pump+0xe6>
          otgp->DIEPEMPMSK |= epmask;
 8009966:	9b05      	ldr	r3, [sp, #20]
 8009968:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 800996c:	9b04      	ldr	r3, [sp, #16]
 800996e:	431a      	orrs	r2, r3
 8009970:	9b05      	ldr	r3, [sp, #20]
 8009972:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
        osalSysUnlock();
 8009976:	f7fe fceb 	bl	8008350 <osalSysUnlock>
      osalThreadSuspendS(&usbp->wait);
    }
    osalSysUnlock();

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 800997a:	f89d 301f 	ldrb.w	r3, [sp, #31]
 800997e:	3301      	adds	r3, #1
 8009980:	f88d 301f 	strb.w	r3, [sp, #31]
 8009984:	f89d 201f 	ldrb.w	r2, [sp, #31]
 8009988:	9b06      	ldr	r3, [sp, #24]
 800998a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800998c:	689b      	ldr	r3, [r3, #8]
 800998e:	429a      	cmp	r2, r3
 8009990:	d9aa      	bls.n	80098e8 <usb_lld_pump+0x58>
        if (!done)
          otgp->DIEPEMPMSK |= epmask;
        osalSysUnlock();
      }
    }
    osalSysLock();
 8009992:	f7fe fcd5 	bl	8008340 <osalSysLock>
  }
 8009996:	e788      	b.n	80098aa <usb_lld_pump+0x1a>
 8009998:	080179c0 	.word	0x080179c0
 800999c:	f3af 8000 	nop.w

080099a0 <osalSysGetStatusAndLockX>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
static inline syssts_t osalSysGetStatusAndLockX(void) {
 80099a0:	b508      	push	{r3, lr}

  return chSysGetStatusAndLockX();
 80099a2:	f7f6 ff6d 	bl	8000880 <chSysGetStatusAndLockX>
 80099a6:	4603      	mov	r3, r0
}
 80099a8:	4618      	mov	r0, r3
 80099aa:	bd08      	pop	{r3, pc}
 80099ac:	f3af 8000 	nop.w

080099b0 <osalSysRestoreStatusX>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
static inline void osalSysRestoreStatusX(syssts_t sts) {
 80099b0:	b500      	push	{lr}
 80099b2:	b083      	sub	sp, #12
 80099b4:	9001      	str	r0, [sp, #4]

  chSysRestoreStatusX(sts);
 80099b6:	9801      	ldr	r0, [sp, #4]
 80099b8:	f7f6 ff82 	bl	80008c0 <chSysRestoreStatusX>
}
 80099bc:	b003      	add	sp, #12
 80099be:	f85d fb04 	ldr.w	pc, [sp], #4
 80099c2:	bf00      	nop
 80099c4:	f3af 8000 	nop.w
 80099c8:	f3af 8000 	nop.w
 80099cc:	f3af 8000 	nop.w

080099d0 <rtc_enter_init>:
 *
 * @notapi
 */
static void rtc_enter_init(void) {

  RTCD1.rtc->ISR |= RTC_ISR_INIT;
 80099d0:	4b08      	ldr	r3, [pc, #32]	; (80099f4 <rtc_enter_init+0x24>)
 80099d2:	681b      	ldr	r3, [r3, #0]
 80099d4:	4a07      	ldr	r2, [pc, #28]	; (80099f4 <rtc_enter_init+0x24>)
 80099d6:	6812      	ldr	r2, [r2, #0]
 80099d8:	68d2      	ldr	r2, [r2, #12]
 80099da:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80099de:	60da      	str	r2, [r3, #12]
  while ((RTCD1.rtc->ISR & RTC_ISR_INITF) == 0)
 80099e0:	bf00      	nop
 80099e2:	4b04      	ldr	r3, [pc, #16]	; (80099f4 <rtc_enter_init+0x24>)
 80099e4:	681b      	ldr	r3, [r3, #0]
 80099e6:	68db      	ldr	r3, [r3, #12]
 80099e8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80099ec:	2b00      	cmp	r3, #0
 80099ee:	d0f8      	beq.n	80099e2 <rtc_enter_init+0x12>
    ;
}
 80099f0:	4770      	bx	lr
 80099f2:	bf00      	nop
 80099f4:	20001a70 	.word	0x20001a70
 80099f8:	f3af 8000 	nop.w
 80099fc:	f3af 8000 	nop.w

08009a00 <rtc_exit_init>:
 *
 * @notapi
 */
static inline void rtc_exit_init(void) {

  RTCD1.rtc->ISR &= ~RTC_ISR_INIT;
 8009a00:	4b04      	ldr	r3, [pc, #16]	; (8009a14 <rtc_exit_init+0x14>)
 8009a02:	681b      	ldr	r3, [r3, #0]
 8009a04:	4a03      	ldr	r2, [pc, #12]	; (8009a14 <rtc_exit_init+0x14>)
 8009a06:	6812      	ldr	r2, [r2, #0]
 8009a08:	68d2      	ldr	r2, [r2, #12]
 8009a0a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8009a0e:	60da      	str	r2, [r3, #12]
}
 8009a10:	4770      	bx	lr
 8009a12:	bf00      	nop
 8009a14:	20001a70 	.word	0x20001a70
 8009a18:	f3af 8000 	nop.w
 8009a1c:	f3af 8000 	nop.w

08009a20 <rtc_decode_time>:
 * @param[in] tr        TR register value
 * @param[out] timespec pointer to a @p RTCDateTime structure
 *
 * @notapi
 */
static void rtc_decode_time(uint32_t tr, RTCDateTime *timespec) {
 8009a20:	b084      	sub	sp, #16
 8009a22:	9001      	str	r0, [sp, #4]
 8009a24:	9100      	str	r1, [sp, #0]
  uint32_t n;

  n  = ((tr >> RTC_TR_HT_OFFSET) & 3)   * 36000000;
 8009a26:	9b01      	ldr	r3, [sp, #4]
 8009a28:	0d1b      	lsrs	r3, r3, #20
 8009a2a:	f003 0303 	and.w	r3, r3, #3
 8009a2e:	4a21      	ldr	r2, [pc, #132]	; (8009ab4 <rtc_decode_time+0x94>)
 8009a30:	fb02 f303 	mul.w	r3, r2, r3
 8009a34:	9303      	str	r3, [sp, #12]
  n += ((tr >> RTC_TR_HU_OFFSET) & 15)  * 3600000;
 8009a36:	9b01      	ldr	r3, [sp, #4]
 8009a38:	0c1b      	lsrs	r3, r3, #16
 8009a3a:	f003 030f 	and.w	r3, r3, #15
 8009a3e:	4a1e      	ldr	r2, [pc, #120]	; (8009ab8 <rtc_decode_time+0x98>)
 8009a40:	fb02 f303 	mul.w	r3, r2, r3
 8009a44:	9a03      	ldr	r2, [sp, #12]
 8009a46:	4413      	add	r3, r2
 8009a48:	9303      	str	r3, [sp, #12]
  n += ((tr >> RTC_TR_MNT_OFFSET) & 7)  * 600000;
 8009a4a:	9b01      	ldr	r3, [sp, #4]
 8009a4c:	0b1b      	lsrs	r3, r3, #12
 8009a4e:	f003 0307 	and.w	r3, r3, #7
 8009a52:	4a1a      	ldr	r2, [pc, #104]	; (8009abc <rtc_decode_time+0x9c>)
 8009a54:	fb02 f303 	mul.w	r3, r2, r3
 8009a58:	9a03      	ldr	r2, [sp, #12]
 8009a5a:	4413      	add	r3, r2
 8009a5c:	9303      	str	r3, [sp, #12]
  n += ((tr >> RTC_TR_MNU_OFFSET) & 15) * 60000;
 8009a5e:	9b01      	ldr	r3, [sp, #4]
 8009a60:	0a1b      	lsrs	r3, r3, #8
 8009a62:	f003 030f 	and.w	r3, r3, #15
 8009a66:	f64e 2260 	movw	r2, #60000	; 0xea60
 8009a6a:	fb02 f303 	mul.w	r3, r2, r3
 8009a6e:	9a03      	ldr	r2, [sp, #12]
 8009a70:	4413      	add	r3, r2
 8009a72:	9303      	str	r3, [sp, #12]
  n += ((tr >> RTC_TR_ST_OFFSET) & 7)   * 10000;
 8009a74:	9b01      	ldr	r3, [sp, #4]
 8009a76:	091b      	lsrs	r3, r3, #4
 8009a78:	f003 0307 	and.w	r3, r3, #7
 8009a7c:	f242 7210 	movw	r2, #10000	; 0x2710
 8009a80:	fb02 f303 	mul.w	r3, r2, r3
 8009a84:	9a03      	ldr	r2, [sp, #12]
 8009a86:	4413      	add	r3, r2
 8009a88:	9303      	str	r3, [sp, #12]
  n += ((tr >> RTC_TR_SU_OFFSET) & 15)  * 1000;
 8009a8a:	9b01      	ldr	r3, [sp, #4]
 8009a8c:	f003 030f 	and.w	r3, r3, #15
 8009a90:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8009a94:	fb02 f303 	mul.w	r3, r2, r3
 8009a98:	9a03      	ldr	r2, [sp, #12]
 8009a9a:	4413      	add	r3, r2
 8009a9c:	9303      	str	r3, [sp, #12]
  timespec->millisecond = n;
 8009a9e:	9b03      	ldr	r3, [sp, #12]
 8009aa0:	f023 4178 	bic.w	r1, r3, #4160749568	; 0xf8000000
 8009aa4:	9a00      	ldr	r2, [sp, #0]
 8009aa6:	6853      	ldr	r3, [r2, #4]
 8009aa8:	f361 031a 	bfi	r3, r1, #0, #27
 8009aac:	6053      	str	r3, [r2, #4]
}
 8009aae:	b004      	add	sp, #16
 8009ab0:	4770      	bx	lr
 8009ab2:	bf00      	nop
 8009ab4:	02255100 	.word	0x02255100
 8009ab8:	0036ee80 	.word	0x0036ee80
 8009abc:	000927c0 	.word	0x000927c0

08009ac0 <rtc_decode_date>:
 * @param[in] dr        DR register value
 * @param[out] timespec pointer to a @p RTCDateTime structure
 *
 * @notapi
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {
 8009ac0:	b082      	sub	sp, #8
 8009ac2:	9001      	str	r0, [sp, #4]
 8009ac4:	9100      	str	r1, [sp, #0]

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
 8009ac6:	9b01      	ldr	r3, [sp, #4]
 8009ac8:	0d1b      	lsrs	r3, r3, #20
 8009aca:	b2db      	uxtb	r3, r3
 8009acc:	f003 030f 	and.w	r3, r3, #15
 8009ad0:	b2db      	uxtb	r3, r3
 8009ad2:	461a      	mov	r2, r3
 8009ad4:	0092      	lsls	r2, r2, #2
 8009ad6:	4413      	add	r3, r2
 8009ad8:	005b      	lsls	r3, r3, #1
 8009ada:	b2da      	uxtb	r2, r3
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
 8009adc:	9b01      	ldr	r3, [sp, #4]
 8009ade:	0c1b      	lsrs	r3, r3, #16
 *
 * @notapi
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
 8009ae0:	b2db      	uxtb	r3, r3
 8009ae2:	f003 030f 	and.w	r3, r3, #15
 8009ae6:	b2db      	uxtb	r3, r3
 8009ae8:	4413      	add	r3, r2
 8009aea:	b2d9      	uxtb	r1, r3
 8009aec:	9a00      	ldr	r2, [sp, #0]
 8009aee:	7813      	ldrb	r3, [r2, #0]
 8009af0:	f361 0307 	bfi	r3, r1, #0, #8
 8009af4:	7013      	strb	r3, [r2, #0]
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
 8009af6:	9b01      	ldr	r3, [sp, #4]
 8009af8:	0b1b      	lsrs	r3, r3, #12
 8009afa:	b2db      	uxtb	r3, r3
 8009afc:	f003 0301 	and.w	r3, r3, #1
 8009b00:	b2db      	uxtb	r3, r3
 8009b02:	461a      	mov	r2, r3
 8009b04:	0092      	lsls	r2, r2, #2
 8009b06:	4413      	add	r3, r2
 8009b08:	005b      	lsls	r3, r3, #1
 8009b0a:	b2da      	uxtb	r2, r3
                     ((dr >> RTC_TR_MNU_OFFSET) & 15);
 8009b0c:	9b01      	ldr	r3, [sp, #4]
 8009b0e:	0a1b      	lsrs	r3, r3, #8
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
 8009b10:	b2db      	uxtb	r3, r3
 8009b12:	f003 030f 	and.w	r3, r3, #15
 8009b16:	b2db      	uxtb	r3, r3
 8009b18:	4413      	add	r3, r2
 8009b1a:	b2db      	uxtb	r3, r3
 8009b1c:	f003 030f 	and.w	r3, r3, #15
 8009b20:	b2d9      	uxtb	r1, r3
 8009b22:	9a00      	ldr	r2, [sp, #0]
 8009b24:	7853      	ldrb	r3, [r2, #1]
 8009b26:	f361 0303 	bfi	r3, r1, #0, #4
 8009b2a:	7053      	strb	r3, [r2, #1]
                     ((dr >> RTC_TR_MNU_OFFSET) & 15);
  timespec->day   = (((dr >> RTC_DR_DT_OFFSET) & 3) * 10) +
 8009b2c:	9b01      	ldr	r3, [sp, #4]
 8009b2e:	091b      	lsrs	r3, r3, #4
 8009b30:	b2db      	uxtb	r3, r3
 8009b32:	f003 0303 	and.w	r3, r3, #3
 8009b36:	b2db      	uxtb	r3, r3
 8009b38:	461a      	mov	r2, r3
 8009b3a:	0092      	lsls	r2, r2, #2
 8009b3c:	4413      	add	r3, r2
 8009b3e:	005b      	lsls	r3, r3, #1
 8009b40:	b2da      	uxtb	r2, r3
 8009b42:	9b01      	ldr	r3, [sp, #4]
 8009b44:	b2db      	uxtb	r3, r3
 8009b46:	f003 030f 	and.w	r3, r3, #15
 8009b4a:	b2db      	uxtb	r3, r3
 8009b4c:	4413      	add	r3, r2
 8009b4e:	b2db      	uxtb	r3, r3
 8009b50:	f003 031f 	and.w	r3, r3, #31
 8009b54:	b2d9      	uxtb	r1, r3
 8009b56:	9a00      	ldr	r2, [sp, #0]
 8009b58:	7893      	ldrb	r3, [r2, #2]
 8009b5a:	f361 0304 	bfi	r3, r1, #0, #5
 8009b5e:	7093      	strb	r3, [r2, #2]
                     ((dr >> RTC_DR_DU_OFFSET) & 15);
  timespec->dayofweek = (dr >> RTC_DR_WDU_OFFSET) & 7;
 8009b60:	9b01      	ldr	r3, [sp, #4]
 8009b62:	0b5b      	lsrs	r3, r3, #13
 8009b64:	b2db      	uxtb	r3, r3
 8009b66:	f003 0307 	and.w	r3, r3, #7
 8009b6a:	b2d9      	uxtb	r1, r3
 8009b6c:	9a00      	ldr	r2, [sp, #0]
 8009b6e:	7853      	ldrb	r3, [r2, #1]
 8009b70:	f361 1347 	bfi	r3, r1, #5, #3
 8009b74:	7053      	strb	r3, [r2, #1]
}
 8009b76:	b002      	add	sp, #8
 8009b78:	4770      	bx	lr
 8009b7a:	bf00      	nop
 8009b7c:	f3af 8000 	nop.w

08009b80 <rtc_encode_time>:
 * @param[in] timespec  pointer to a @p RTCDateTime structure
 * @return              the TR register encoding.
 *
 * @notapi
 */
static uint32_t rtc_encode_time(const RTCDateTime *timespec) {
 8009b80:	b084      	sub	sp, #16
 8009b82:	9001      	str	r0, [sp, #4]
  uint32_t n, tr = 0;
 8009b84:	2300      	movs	r3, #0
 8009b86:	9303      	str	r3, [sp, #12]

  /* Subseconds cannot be set.*/
  n = timespec->millisecond / 1000;
 8009b88:	9b01      	ldr	r3, [sp, #4]
 8009b8a:	685b      	ldr	r3, [r3, #4]
 8009b8c:	f3c3 031a 	ubfx	r3, r3, #0, #27
 8009b90:	4a39      	ldr	r2, [pc, #228]	; (8009c78 <rtc_encode_time+0xf8>)
 8009b92:	fb82 1203 	smull	r1, r2, r2, r3
 8009b96:	1192      	asrs	r2, r2, #6
 8009b98:	17db      	asrs	r3, r3, #31
 8009b9a:	1ad3      	subs	r3, r2, r3
 8009b9c:	9302      	str	r3, [sp, #8]

  /* Seconds conversion.*/
  tr = tr | ((n % 10) << RTC_TR_SU_OFFSET);
 8009b9e:	9902      	ldr	r1, [sp, #8]
 8009ba0:	4b36      	ldr	r3, [pc, #216]	; (8009c7c <rtc_encode_time+0xfc>)
 8009ba2:	fba3 2301 	umull	r2, r3, r3, r1
 8009ba6:	08da      	lsrs	r2, r3, #3
 8009ba8:	4613      	mov	r3, r2
 8009baa:	009b      	lsls	r3, r3, #2
 8009bac:	4413      	add	r3, r2
 8009bae:	005b      	lsls	r3, r3, #1
 8009bb0:	1aca      	subs	r2, r1, r3
 8009bb2:	9b03      	ldr	r3, [sp, #12]
 8009bb4:	4313      	orrs	r3, r2
 8009bb6:	9303      	str	r3, [sp, #12]
  n /= 10;
 8009bb8:	9a02      	ldr	r2, [sp, #8]
 8009bba:	4b30      	ldr	r3, [pc, #192]	; (8009c7c <rtc_encode_time+0xfc>)
 8009bbc:	fba3 1302 	umull	r1, r3, r3, r2
 8009bc0:	08db      	lsrs	r3, r3, #3
 8009bc2:	9302      	str	r3, [sp, #8]
  tr = tr | ((n % 6) << RTC_TR_ST_OFFSET);
 8009bc4:	9902      	ldr	r1, [sp, #8]
 8009bc6:	4b2e      	ldr	r3, [pc, #184]	; (8009c80 <rtc_encode_time+0x100>)
 8009bc8:	fba3 2301 	umull	r2, r3, r3, r1
 8009bcc:	089a      	lsrs	r2, r3, #2
 8009bce:	4613      	mov	r3, r2
 8009bd0:	005b      	lsls	r3, r3, #1
 8009bd2:	4413      	add	r3, r2
 8009bd4:	005b      	lsls	r3, r3, #1
 8009bd6:	1aca      	subs	r2, r1, r3
 8009bd8:	0113      	lsls	r3, r2, #4
 8009bda:	9a03      	ldr	r2, [sp, #12]
 8009bdc:	4313      	orrs	r3, r2
 8009bde:	9303      	str	r3, [sp, #12]
  n /= 6;
 8009be0:	9a02      	ldr	r2, [sp, #8]
 8009be2:	4b27      	ldr	r3, [pc, #156]	; (8009c80 <rtc_encode_time+0x100>)
 8009be4:	fba3 1302 	umull	r1, r3, r3, r2
 8009be8:	089b      	lsrs	r3, r3, #2
 8009bea:	9302      	str	r3, [sp, #8]

  /* Minutes conversion.*/
  tr = tr | ((n % 10) << RTC_TR_MNU_OFFSET);
 8009bec:	9902      	ldr	r1, [sp, #8]
 8009bee:	4b23      	ldr	r3, [pc, #140]	; (8009c7c <rtc_encode_time+0xfc>)
 8009bf0:	fba3 2301 	umull	r2, r3, r3, r1
 8009bf4:	08da      	lsrs	r2, r3, #3
 8009bf6:	4613      	mov	r3, r2
 8009bf8:	009b      	lsls	r3, r3, #2
 8009bfa:	4413      	add	r3, r2
 8009bfc:	005b      	lsls	r3, r3, #1
 8009bfe:	1aca      	subs	r2, r1, r3
 8009c00:	0213      	lsls	r3, r2, #8
 8009c02:	9a03      	ldr	r2, [sp, #12]
 8009c04:	4313      	orrs	r3, r2
 8009c06:	9303      	str	r3, [sp, #12]
  n /= 10;
 8009c08:	9a02      	ldr	r2, [sp, #8]
 8009c0a:	4b1c      	ldr	r3, [pc, #112]	; (8009c7c <rtc_encode_time+0xfc>)
 8009c0c:	fba3 1302 	umull	r1, r3, r3, r2
 8009c10:	08db      	lsrs	r3, r3, #3
 8009c12:	9302      	str	r3, [sp, #8]
  tr = tr | ((n % 6) << RTC_TR_MNT_OFFSET);
 8009c14:	9902      	ldr	r1, [sp, #8]
 8009c16:	4b1a      	ldr	r3, [pc, #104]	; (8009c80 <rtc_encode_time+0x100>)
 8009c18:	fba3 2301 	umull	r2, r3, r3, r1
 8009c1c:	089a      	lsrs	r2, r3, #2
 8009c1e:	4613      	mov	r3, r2
 8009c20:	005b      	lsls	r3, r3, #1
 8009c22:	4413      	add	r3, r2
 8009c24:	005b      	lsls	r3, r3, #1
 8009c26:	1aca      	subs	r2, r1, r3
 8009c28:	0313      	lsls	r3, r2, #12
 8009c2a:	9a03      	ldr	r2, [sp, #12]
 8009c2c:	4313      	orrs	r3, r2
 8009c2e:	9303      	str	r3, [sp, #12]
  n /= 6;
 8009c30:	9a02      	ldr	r2, [sp, #8]
 8009c32:	4b13      	ldr	r3, [pc, #76]	; (8009c80 <rtc_encode_time+0x100>)
 8009c34:	fba3 1302 	umull	r1, r3, r3, r2
 8009c38:	089b      	lsrs	r3, r3, #2
 8009c3a:	9302      	str	r3, [sp, #8]

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
 8009c3c:	9902      	ldr	r1, [sp, #8]
 8009c3e:	4b0f      	ldr	r3, [pc, #60]	; (8009c7c <rtc_encode_time+0xfc>)
 8009c40:	fba3 2301 	umull	r2, r3, r3, r1
 8009c44:	08da      	lsrs	r2, r3, #3
 8009c46:	4613      	mov	r3, r2
 8009c48:	009b      	lsls	r3, r3, #2
 8009c4a:	4413      	add	r3, r2
 8009c4c:	005b      	lsls	r3, r3, #1
 8009c4e:	1aca      	subs	r2, r1, r3
 8009c50:	0413      	lsls	r3, r2, #16
 8009c52:	9a03      	ldr	r2, [sp, #12]
 8009c54:	4313      	orrs	r3, r2
 8009c56:	9303      	str	r3, [sp, #12]
  n /= 10;
 8009c58:	9a02      	ldr	r2, [sp, #8]
 8009c5a:	4b08      	ldr	r3, [pc, #32]	; (8009c7c <rtc_encode_time+0xfc>)
 8009c5c:	fba3 1302 	umull	r1, r3, r3, r2
 8009c60:	08db      	lsrs	r3, r3, #3
 8009c62:	9302      	str	r3, [sp, #8]
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8009c64:	9b02      	ldr	r3, [sp, #8]
 8009c66:	051b      	lsls	r3, r3, #20
 8009c68:	9a03      	ldr	r2, [sp, #12]
 8009c6a:	4313      	orrs	r3, r2
 8009c6c:	9303      	str	r3, [sp, #12]

  return tr;
 8009c6e:	9b03      	ldr	r3, [sp, #12]
}
 8009c70:	4618      	mov	r0, r3
 8009c72:	b004      	add	sp, #16
 8009c74:	4770      	bx	lr
 8009c76:	bf00      	nop
 8009c78:	10624dd3 	.word	0x10624dd3
 8009c7c:	cccccccd 	.word	0xcccccccd
 8009c80:	aaaaaaab 	.word	0xaaaaaaab
 8009c84:	f3af 8000 	nop.w
 8009c88:	f3af 8000 	nop.w
 8009c8c:	f3af 8000 	nop.w

08009c90 <rtc_encode_date>:
 * @param[in] timespec  pointer to a @p RTCDateTime structure
 * @return              the DR register encoding.
 *
 * @notapi
 */
static uint32_t rtc_encode_date(const RTCDateTime *timespec) {
 8009c90:	b084      	sub	sp, #16
 8009c92:	9001      	str	r0, [sp, #4]
  uint32_t n, dr = 0;
 8009c94:	2300      	movs	r3, #0
 8009c96:	9303      	str	r3, [sp, #12]

  /* Year conversion. Note, only years last two digits are considered.*/
  n = timespec->year;
 8009c98:	9b01      	ldr	r3, [sp, #4]
 8009c9a:	781b      	ldrb	r3, [r3, #0]
 8009c9c:	9302      	str	r3, [sp, #8]
  dr = dr | ((n % 10) << RTC_DR_YU_OFFSET);
 8009c9e:	9902      	ldr	r1, [sp, #8]
 8009ca0:	4b3e      	ldr	r3, [pc, #248]	; (8009d9c <rtc_encode_date+0x10c>)
 8009ca2:	fba3 2301 	umull	r2, r3, r3, r1
 8009ca6:	08da      	lsrs	r2, r3, #3
 8009ca8:	4613      	mov	r3, r2
 8009caa:	009b      	lsls	r3, r3, #2
 8009cac:	4413      	add	r3, r2
 8009cae:	005b      	lsls	r3, r3, #1
 8009cb0:	1aca      	subs	r2, r1, r3
 8009cb2:	0413      	lsls	r3, r2, #16
 8009cb4:	9a03      	ldr	r2, [sp, #12]
 8009cb6:	4313      	orrs	r3, r2
 8009cb8:	9303      	str	r3, [sp, #12]
  n /= 10;
 8009cba:	9a02      	ldr	r2, [sp, #8]
 8009cbc:	4b37      	ldr	r3, [pc, #220]	; (8009d9c <rtc_encode_date+0x10c>)
 8009cbe:	fba3 1302 	umull	r1, r3, r3, r2
 8009cc2:	08db      	lsrs	r3, r3, #3
 8009cc4:	9302      	str	r3, [sp, #8]
  dr = dr | ((n % 10) << RTC_DR_YT_OFFSET);
 8009cc6:	9902      	ldr	r1, [sp, #8]
 8009cc8:	4b34      	ldr	r3, [pc, #208]	; (8009d9c <rtc_encode_date+0x10c>)
 8009cca:	fba3 2301 	umull	r2, r3, r3, r1
 8009cce:	08da      	lsrs	r2, r3, #3
 8009cd0:	4613      	mov	r3, r2
 8009cd2:	009b      	lsls	r3, r3, #2
 8009cd4:	4413      	add	r3, r2
 8009cd6:	005b      	lsls	r3, r3, #1
 8009cd8:	1aca      	subs	r2, r1, r3
 8009cda:	0513      	lsls	r3, r2, #20
 8009cdc:	9a03      	ldr	r2, [sp, #12]
 8009cde:	4313      	orrs	r3, r2
 8009ce0:	9303      	str	r3, [sp, #12]

  /* Months conversion.*/
  n = timespec->month;
 8009ce2:	9b01      	ldr	r3, [sp, #4]
 8009ce4:	785b      	ldrb	r3, [r3, #1]
 8009ce6:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8009cea:	b2db      	uxtb	r3, r3
 8009cec:	9302      	str	r3, [sp, #8]
  dr = dr | ((n % 10) << RTC_DR_MU_OFFSET);
 8009cee:	9902      	ldr	r1, [sp, #8]
 8009cf0:	4b2a      	ldr	r3, [pc, #168]	; (8009d9c <rtc_encode_date+0x10c>)
 8009cf2:	fba3 2301 	umull	r2, r3, r3, r1
 8009cf6:	08da      	lsrs	r2, r3, #3
 8009cf8:	4613      	mov	r3, r2
 8009cfa:	009b      	lsls	r3, r3, #2
 8009cfc:	4413      	add	r3, r2
 8009cfe:	005b      	lsls	r3, r3, #1
 8009d00:	1aca      	subs	r2, r1, r3
 8009d02:	0213      	lsls	r3, r2, #8
 8009d04:	9a03      	ldr	r2, [sp, #12]
 8009d06:	4313      	orrs	r3, r2
 8009d08:	9303      	str	r3, [sp, #12]
  n /= 10;
 8009d0a:	9a02      	ldr	r2, [sp, #8]
 8009d0c:	4b23      	ldr	r3, [pc, #140]	; (8009d9c <rtc_encode_date+0x10c>)
 8009d0e:	fba3 1302 	umull	r1, r3, r3, r2
 8009d12:	08db      	lsrs	r3, r3, #3
 8009d14:	9302      	str	r3, [sp, #8]
  dr = dr | ((n % 10) << RTC_DR_MT_OFFSET);
 8009d16:	9902      	ldr	r1, [sp, #8]
 8009d18:	4b20      	ldr	r3, [pc, #128]	; (8009d9c <rtc_encode_date+0x10c>)
 8009d1a:	fba3 2301 	umull	r2, r3, r3, r1
 8009d1e:	08da      	lsrs	r2, r3, #3
 8009d20:	4613      	mov	r3, r2
 8009d22:	009b      	lsls	r3, r3, #2
 8009d24:	4413      	add	r3, r2
 8009d26:	005b      	lsls	r3, r3, #1
 8009d28:	1aca      	subs	r2, r1, r3
 8009d2a:	0313      	lsls	r3, r2, #12
 8009d2c:	9a03      	ldr	r2, [sp, #12]
 8009d2e:	4313      	orrs	r3, r2
 8009d30:	9303      	str	r3, [sp, #12]

  /* Days conversion.*/
  n = timespec->day;
 8009d32:	9b01      	ldr	r3, [sp, #4]
 8009d34:	789b      	ldrb	r3, [r3, #2]
 8009d36:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8009d3a:	b2db      	uxtb	r3, r3
 8009d3c:	9302      	str	r3, [sp, #8]
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
 8009d3e:	9902      	ldr	r1, [sp, #8]
 8009d40:	4b16      	ldr	r3, [pc, #88]	; (8009d9c <rtc_encode_date+0x10c>)
 8009d42:	fba3 2301 	umull	r2, r3, r3, r1
 8009d46:	08da      	lsrs	r2, r3, #3
 8009d48:	4613      	mov	r3, r2
 8009d4a:	009b      	lsls	r3, r3, #2
 8009d4c:	4413      	add	r3, r2
 8009d4e:	005b      	lsls	r3, r3, #1
 8009d50:	1aca      	subs	r2, r1, r3
 8009d52:	9b03      	ldr	r3, [sp, #12]
 8009d54:	4313      	orrs	r3, r2
 8009d56:	9303      	str	r3, [sp, #12]
  n /= 10;
 8009d58:	9a02      	ldr	r2, [sp, #8]
 8009d5a:	4b10      	ldr	r3, [pc, #64]	; (8009d9c <rtc_encode_date+0x10c>)
 8009d5c:	fba3 1302 	umull	r1, r3, r3, r2
 8009d60:	08db      	lsrs	r3, r3, #3
 8009d62:	9302      	str	r3, [sp, #8]
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);
 8009d64:	9902      	ldr	r1, [sp, #8]
 8009d66:	4b0d      	ldr	r3, [pc, #52]	; (8009d9c <rtc_encode_date+0x10c>)
 8009d68:	fba3 2301 	umull	r2, r3, r3, r1
 8009d6c:	08da      	lsrs	r2, r3, #3
 8009d6e:	4613      	mov	r3, r2
 8009d70:	009b      	lsls	r3, r3, #2
 8009d72:	4413      	add	r3, r2
 8009d74:	005b      	lsls	r3, r3, #1
 8009d76:	1aca      	subs	r2, r1, r3
 8009d78:	0113      	lsls	r3, r2, #4
 8009d7a:	9a03      	ldr	r2, [sp, #12]
 8009d7c:	4313      	orrs	r3, r2
 8009d7e:	9303      	str	r3, [sp, #12]

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8009d80:	9b01      	ldr	r3, [sp, #4]
 8009d82:	785b      	ldrb	r3, [r3, #1]
 8009d84:	f3c3 1342 	ubfx	r3, r3, #5, #3
 8009d88:	b2db      	uxtb	r3, r3
 8009d8a:	035b      	lsls	r3, r3, #13
 8009d8c:	9a03      	ldr	r2, [sp, #12]
 8009d8e:	4313      	orrs	r3, r2
 8009d90:	9303      	str	r3, [sp, #12]

  return dr;
 8009d92:	9b03      	ldr	r3, [sp, #12]
}
 8009d94:	4618      	mov	r0, r3
 8009d96:	b004      	add	sp, #16
 8009d98:	4770      	bx	lr
 8009d9a:	bf00      	nop
 8009d9c:	cccccccd 	.word	0xcccccccd

08009da0 <rtc_lld_init>:
/**
 * @brief   Enable access to registers.
 *
 * @notapi
 */
void rtc_lld_init(void) {
 8009da0:	b508      	push	{r3, lr}

  /* RTC object initialization.*/
  rtcObjectInit(&RTCD1);
 8009da2:	4819      	ldr	r0, [pc, #100]	; (8009e08 <rtc_lld_init+0x68>)
 8009da4:	f7fb f964 	bl	8005070 <rtcObjectInit>

  /* RTC pointer initialization.*/
  RTCD1.rtc = RTC;
 8009da8:	4b17      	ldr	r3, [pc, #92]	; (8009e08 <rtc_lld_init+0x68>)
 8009daa:	4a18      	ldr	r2, [pc, #96]	; (8009e0c <rtc_lld_init+0x6c>)
 8009dac:	601a      	str	r2, [r3, #0]

  /* Disable write protection. */
  RTCD1.rtc->WPR = 0xCA;
 8009dae:	4b16      	ldr	r3, [pc, #88]	; (8009e08 <rtc_lld_init+0x68>)
 8009db0:	681b      	ldr	r3, [r3, #0]
 8009db2:	22ca      	movs	r2, #202	; 0xca
 8009db4:	625a      	str	r2, [r3, #36]	; 0x24
  RTCD1.rtc->WPR = 0x53;
 8009db6:	4b14      	ldr	r3, [pc, #80]	; (8009e08 <rtc_lld_init+0x68>)
 8009db8:	681b      	ldr	r3, [r3, #0]
 8009dba:	2253      	movs	r2, #83	; 0x53
 8009dbc:	625a      	str	r2, [r3, #36]	; 0x24

  /* If calendar has not been initialized yet then proceed with the
     initial setup.*/
  if (!(RTCD1.rtc->ISR & RTC_ISR_INITS)) {
 8009dbe:	4b12      	ldr	r3, [pc, #72]	; (8009e08 <rtc_lld_init+0x68>)
 8009dc0:	681b      	ldr	r3, [r3, #0]
 8009dc2:	68db      	ldr	r3, [r3, #12]
 8009dc4:	f003 0310 	and.w	r3, r3, #16
 8009dc8:	2b00      	cmp	r3, #0
 8009dca:	d114      	bne.n	8009df6 <rtc_lld_init+0x56>

    rtc_enter_init();
 8009dcc:	f7ff fe00 	bl	80099d0 <rtc_enter_init>

    RTCD1.rtc->CR   = 0;
 8009dd0:	4b0d      	ldr	r3, [pc, #52]	; (8009e08 <rtc_lld_init+0x68>)
 8009dd2:	681b      	ldr	r3, [r3, #0]
 8009dd4:	2200      	movs	r2, #0
 8009dd6:	609a      	str	r2, [r3, #8]
    RTCD1.rtc->ISR  = RTC_ISR_INIT;     /* Clearing all but RTC_ISR_INIT.   */
 8009dd8:	4b0b      	ldr	r3, [pc, #44]	; (8009e08 <rtc_lld_init+0x68>)
 8009dda:	681b      	ldr	r3, [r3, #0]
 8009ddc:	2280      	movs	r2, #128	; 0x80
 8009dde:	60da      	str	r2, [r3, #12]
    RTCD1.rtc->PRER = STM32_RTC_PRER_BITS;
 8009de0:	4b09      	ldr	r3, [pc, #36]	; (8009e08 <rtc_lld_init+0x68>)
 8009de2:	681b      	ldr	r3, [r3, #0]
 8009de4:	4a0a      	ldr	r2, [pc, #40]	; (8009e10 <rtc_lld_init+0x70>)
 8009de6:	611a      	str	r2, [r3, #16]
    RTCD1.rtc->PRER = STM32_RTC_PRER_BITS;
 8009de8:	4b07      	ldr	r3, [pc, #28]	; (8009e08 <rtc_lld_init+0x68>)
 8009dea:	681b      	ldr	r3, [r3, #0]
 8009dec:	4a08      	ldr	r2, [pc, #32]	; (8009e10 <rtc_lld_init+0x70>)
 8009dee:	611a      	str	r2, [r3, #16]

    rtc_exit_init();
 8009df0:	f7ff fe06 	bl	8009a00 <rtc_exit_init>
 8009df4:	e007      	b.n	8009e06 <rtc_lld_init+0x66>
  }
  else
    RTCD1.rtc->ISR &= ~RTC_ISR_RSF;
 8009df6:	4b04      	ldr	r3, [pc, #16]	; (8009e08 <rtc_lld_init+0x68>)
 8009df8:	681b      	ldr	r3, [r3, #0]
 8009dfa:	4a03      	ldr	r2, [pc, #12]	; (8009e08 <rtc_lld_init+0x68>)
 8009dfc:	6812      	ldr	r2, [r2, #0]
 8009dfe:	68d2      	ldr	r2, [r2, #12]
 8009e00:	f022 0220 	bic.w	r2, r2, #32
 8009e04:	60da      	str	r2, [r3, #12]
}
 8009e06:	bd08      	pop	{r3, pc}
 8009e08:	20001a70 	.word	0x20001a70
 8009e0c:	40002800 	.word	0x40002800
 8009e10:	001f03ff 	.word	0x001f03ff
 8009e14:	f3af 8000 	nop.w
 8009e18:	f3af 8000 	nop.w
 8009e1c:	f3af 8000 	nop.w

08009e20 <rtc_lld_set_time>:
 * @param[in] rtcp      pointer to RTC driver structure
 * @param[in] timespec  pointer to a @p RTCDateTime structure
 *
 * @notapi
 */
void rtc_lld_set_time(RTCDriver *rtcp, const RTCDateTime *timespec) {
 8009e20:	b500      	push	{lr}
 8009e22:	b087      	sub	sp, #28
 8009e24:	9001      	str	r0, [sp, #4]
 8009e26:	9100      	str	r1, [sp, #0]
  uint32_t dr, tr;
  syssts_t sts;

  tr = rtc_encode_time(timespec);
 8009e28:	9800      	ldr	r0, [sp, #0]
 8009e2a:	f7ff fea9 	bl	8009b80 <rtc_encode_time>
 8009e2e:	9005      	str	r0, [sp, #20]
  dr = rtc_encode_date(timespec);
 8009e30:	9800      	ldr	r0, [sp, #0]
 8009e32:	f7ff ff2d 	bl	8009c90 <rtc_encode_date>
 8009e36:	9004      	str	r0, [sp, #16]

  /* Entering a reentrant critical zone.*/
  sts = osalSysGetStatusAndLockX();
 8009e38:	f7ff fdb2 	bl	80099a0 <osalSysGetStatusAndLockX>
 8009e3c:	9003      	str	r0, [sp, #12]

  /* Writing the registers.*/
  rtc_enter_init();
 8009e3e:	f7ff fdc7 	bl	80099d0 <rtc_enter_init>
  rtcp->rtc->TR  = tr;
 8009e42:	9b01      	ldr	r3, [sp, #4]
 8009e44:	681b      	ldr	r3, [r3, #0]
 8009e46:	9a05      	ldr	r2, [sp, #20]
 8009e48:	601a      	str	r2, [r3, #0]
  rtcp->rtc->DR  = dr;
 8009e4a:	9b01      	ldr	r3, [sp, #4]
 8009e4c:	681b      	ldr	r3, [r3, #0]
 8009e4e:	9a04      	ldr	r2, [sp, #16]
 8009e50:	605a      	str	r2, [r3, #4]
  rtcp->rtc->CR |= timespec->dstflag << RTC_CR_BKP_OFFSET;
 8009e52:	9b01      	ldr	r3, [sp, #4]
 8009e54:	681b      	ldr	r3, [r3, #0]
 8009e56:	9a01      	ldr	r2, [sp, #4]
 8009e58:	6812      	ldr	r2, [r2, #0]
 8009e5a:	6891      	ldr	r1, [r2, #8]
 8009e5c:	9a00      	ldr	r2, [sp, #0]
 8009e5e:	7852      	ldrb	r2, [r2, #1]
 8009e60:	f3c2 1200 	ubfx	r2, r2, #4, #1
 8009e64:	b2d2      	uxtb	r2, r2
 8009e66:	0492      	lsls	r2, r2, #18
 8009e68:	430a      	orrs	r2, r1
 8009e6a:	609a      	str	r2, [r3, #8]
  rtc_exit_init();
 8009e6c:	f7ff fdc8 	bl	8009a00 <rtc_exit_init>

  /* Leaving a reentrant critical zone.*/
  osalSysRestoreStatusX(sts);
 8009e70:	9803      	ldr	r0, [sp, #12]
 8009e72:	f7ff fd9d 	bl	80099b0 <osalSysRestoreStatusX>
}
 8009e76:	b007      	add	sp, #28
 8009e78:	f85d fb04 	ldr.w	pc, [sp], #4
 8009e7c:	f3af 8000 	nop.w

08009e80 <rtc_lld_get_time>:
 * @param[in] rtcp      pointer to RTC driver structure
 * @param[out] timespec pointer to a @p RTCDateTime structure
 *
 * @notapi
 */
void rtc_lld_get_time(RTCDriver *rtcp, RTCDateTime *timespec) {
 8009e80:	b500      	push	{lr}
 8009e82:	b089      	sub	sp, #36	; 0x24
 8009e84:	9001      	str	r0, [sp, #4]
 8009e86:	9100      	str	r1, [sp, #0]
  uint32_t ssr;
#endif /* STM32_RTC_HAS_SUBSECONDS */
  syssts_t sts;

  /* Entering a reentrant critical zone.*/
  sts = osalSysGetStatusAndLockX();
 8009e88:	f7ff fd8a 	bl	80099a0 <osalSysGetStatusAndLockX>
 8009e8c:	9007      	str	r0, [sp, #28]

  /* Synchronization with the RTC and reading the registers, note
     DR must be read last.*/
  while ((rtcp->rtc->ISR & RTC_ISR_RSF) == 0)
 8009e8e:	bf00      	nop
 8009e90:	9b01      	ldr	r3, [sp, #4]
 8009e92:	681b      	ldr	r3, [r3, #0]
 8009e94:	68db      	ldr	r3, [r3, #12]
 8009e96:	f003 0320 	and.w	r3, r3, #32
 8009e9a:	2b00      	cmp	r3, #0
 8009e9c:	d0f8      	beq.n	8009e90 <rtc_lld_get_time+0x10>
    ;
#if STM32_RTC_HAS_SUBSECONDS
  ssr = rtcp->rtc->SSR;
 8009e9e:	9b01      	ldr	r3, [sp, #4]
 8009ea0:	681b      	ldr	r3, [r3, #0]
 8009ea2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009ea4:	9306      	str	r3, [sp, #24]
#endif /* STM32_RTC_HAS_SUBSECONDS */
  tr  = rtcp->rtc->TR;
 8009ea6:	9b01      	ldr	r3, [sp, #4]
 8009ea8:	681b      	ldr	r3, [r3, #0]
 8009eaa:	681b      	ldr	r3, [r3, #0]
 8009eac:	9305      	str	r3, [sp, #20]
  dr  = rtcp->rtc->DR;
 8009eae:	9b01      	ldr	r3, [sp, #4]
 8009eb0:	681b      	ldr	r3, [r3, #0]
 8009eb2:	685b      	ldr	r3, [r3, #4]
 8009eb4:	9304      	str	r3, [sp, #16]
  cr  = rtcp->rtc->CR;
 8009eb6:	9b01      	ldr	r3, [sp, #4]
 8009eb8:	681b      	ldr	r3, [r3, #0]
 8009eba:	689b      	ldr	r3, [r3, #8]
 8009ebc:	9303      	str	r3, [sp, #12]
  rtcp->rtc->ISR &= ~RTC_ISR_RSF;
 8009ebe:	9b01      	ldr	r3, [sp, #4]
 8009ec0:	681b      	ldr	r3, [r3, #0]
 8009ec2:	9a01      	ldr	r2, [sp, #4]
 8009ec4:	6812      	ldr	r2, [r2, #0]
 8009ec6:	68d2      	ldr	r2, [r2, #12]
 8009ec8:	f022 0220 	bic.w	r2, r2, #32
 8009ecc:	60da      	str	r2, [r3, #12]

  /* Leaving a reentrant critical zone.*/
  osalSysRestoreStatusX(sts);
 8009ece:	9807      	ldr	r0, [sp, #28]
 8009ed0:	f7ff fd6e 	bl	80099b0 <osalSysRestoreStatusX>

  /* Decoding day time, this starts the atomic read sequence, see "Reading
     the calendar" in the RTC documentation.*/
  rtc_decode_time(tr, timespec);
 8009ed4:	9805      	ldr	r0, [sp, #20]
 8009ed6:	9900      	ldr	r1, [sp, #0]
 8009ed8:	f7ff fda2 	bl	8009a20 <rtc_decode_time>

  /* If the RTC is capable of sub-second counting then the value is
     normalized in milliseconds and added to the time.*/
#if STM32_RTC_HAS_SUBSECONDS
  subs = (((STM32_RTC_PRESS_VALUE - 1U) - ssr) * 1000U) / STM32_RTC_PRESS_VALUE;
 8009edc:	9b06      	ldr	r3, [sp, #24]
 8009ede:	4a14      	ldr	r2, [pc, #80]	; (8009f30 <rtc_lld_get_time+0xb0>)
 8009ee0:	fb02 f303 	mul.w	r3, r2, r3
 8009ee4:	f503 2379 	add.w	r3, r3, #1019904	; 0xf9000
 8009ee8:	f603 4318 	addw	r3, r3, #3096	; 0xc18
 8009eec:	0a9b      	lsrs	r3, r3, #10
 8009eee:	9302      	str	r3, [sp, #8]
#else
  subs = 0;
#endif /* STM32_RTC_HAS_SUBSECONDS */
  timespec->millisecond += subs;
 8009ef0:	9b00      	ldr	r3, [sp, #0]
 8009ef2:	685b      	ldr	r3, [r3, #4]
 8009ef4:	f3c3 031a 	ubfx	r3, r3, #0, #27
 8009ef8:	461a      	mov	r2, r3
 8009efa:	9b02      	ldr	r3, [sp, #8]
 8009efc:	4413      	add	r3, r2
 8009efe:	f023 4178 	bic.w	r1, r3, #4160749568	; 0xf8000000
 8009f02:	9a00      	ldr	r2, [sp, #0]
 8009f04:	6853      	ldr	r3, [r2, #4]
 8009f06:	f361 031a 	bfi	r3, r1, #0, #27
 8009f0a:	6053      	str	r3, [r2, #4]

  /* Decoding date, this concludes the atomic read sequence.*/
  rtc_decode_date(dr, timespec);
 8009f0c:	9804      	ldr	r0, [sp, #16]
 8009f0e:	9900      	ldr	r1, [sp, #0]
 8009f10:	f7ff fdd6 	bl	8009ac0 <rtc_decode_date>

  /* Retrieving the DST bit.*/
  timespec->dstflag = (cr >> RTC_CR_BKP_OFFSET) & 1;
 8009f14:	9b03      	ldr	r3, [sp, #12]
 8009f16:	0c9b      	lsrs	r3, r3, #18
 8009f18:	b2db      	uxtb	r3, r3
 8009f1a:	f003 0301 	and.w	r3, r3, #1
 8009f1e:	b2d9      	uxtb	r1, r3
 8009f20:	9a00      	ldr	r2, [sp, #0]
 8009f22:	7853      	ldrb	r3, [r2, #1]
 8009f24:	f361 1304 	bfi	r3, r1, #4, #1
 8009f28:	7053      	strb	r3, [r2, #1]
}
 8009f2a:	b009      	add	sp, #36	; 0x24
 8009f2c:	f85d fb04 	ldr.w	pc, [sp], #4
 8009f30:	fffffc18 	.word	0xfffffc18
 8009f34:	f3af 8000 	nop.w
 8009f38:	f3af 8000 	nop.w
 8009f3c:	f3af 8000 	nop.w

08009f40 <rtc_lld_set_alarm>:
 *
 * @notapi
 */
void rtc_lld_set_alarm(RTCDriver *rtcp,
                       rtcalarm_t alarm,
                       const RTCAlarm *alarmspec) {
 8009f40:	b500      	push	{lr}
 8009f42:	b087      	sub	sp, #28
 8009f44:	9003      	str	r0, [sp, #12]
 8009f46:	9102      	str	r1, [sp, #8]
 8009f48:	9201      	str	r2, [sp, #4]
  syssts_t sts;

  /* Entering a reentrant critical zone.*/
  sts = osalSysGetStatusAndLockX();
 8009f4a:	f7ff fd29 	bl	80099a0 <osalSysGetStatusAndLockX>
 8009f4e:	9005      	str	r0, [sp, #20]

  if (alarm == 0) {
 8009f50:	9b02      	ldr	r3, [sp, #8]
 8009f52:	2b00      	cmp	r3, #0
 8009f54:	d139      	bne.n	8009fca <rtc_lld_set_alarm+0x8a>
    if (alarmspec != NULL) {
 8009f56:	9b01      	ldr	r3, [sp, #4]
 8009f58:	2b00      	cmp	r3, #0
 8009f5a:	d025      	beq.n	8009fa8 <rtc_lld_set_alarm+0x68>
      rtcp->rtc->CR &= ~RTC_CR_ALRAE;
 8009f5c:	9b03      	ldr	r3, [sp, #12]
 8009f5e:	681b      	ldr	r3, [r3, #0]
 8009f60:	9a03      	ldr	r2, [sp, #12]
 8009f62:	6812      	ldr	r2, [r2, #0]
 8009f64:	6892      	ldr	r2, [r2, #8]
 8009f66:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8009f6a:	609a      	str	r2, [r3, #8]
      while (!(rtcp->rtc->ISR & RTC_ISR_ALRAWF))
 8009f6c:	bf00      	nop
 8009f6e:	9b03      	ldr	r3, [sp, #12]
 8009f70:	681b      	ldr	r3, [r3, #0]
 8009f72:	68db      	ldr	r3, [r3, #12]
 8009f74:	f003 0301 	and.w	r3, r3, #1
 8009f78:	2b00      	cmp	r3, #0
 8009f7a:	d0f8      	beq.n	8009f6e <rtc_lld_set_alarm+0x2e>
        ;
      rtcp->rtc->ALRMAR = alarmspec->alrmr;
 8009f7c:	9b03      	ldr	r3, [sp, #12]
 8009f7e:	681b      	ldr	r3, [r3, #0]
 8009f80:	9a01      	ldr	r2, [sp, #4]
 8009f82:	6812      	ldr	r2, [r2, #0]
 8009f84:	61da      	str	r2, [r3, #28]
      rtcp->rtc->CR |= RTC_CR_ALRAE;
 8009f86:	9b03      	ldr	r3, [sp, #12]
 8009f88:	681b      	ldr	r3, [r3, #0]
 8009f8a:	9a03      	ldr	r2, [sp, #12]
 8009f8c:	6812      	ldr	r2, [r2, #0]
 8009f8e:	6892      	ldr	r2, [r2, #8]
 8009f90:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8009f94:	609a      	str	r2, [r3, #8]
      rtcp->rtc->CR |= RTC_CR_ALRAIE;
 8009f96:	9b03      	ldr	r3, [sp, #12]
 8009f98:	681b      	ldr	r3, [r3, #0]
 8009f9a:	9a03      	ldr	r2, [sp, #12]
 8009f9c:	6812      	ldr	r2, [r2, #0]
 8009f9e:	6892      	ldr	r2, [r2, #8]
 8009fa0:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8009fa4:	609a      	str	r2, [r3, #8]
 8009fa6:	e049      	b.n	800a03c <rtc_lld_set_alarm+0xfc>
    }
    else {
      rtcp->rtc->CR &= ~RTC_CR_ALRAIE;
 8009fa8:	9b03      	ldr	r3, [sp, #12]
 8009faa:	681b      	ldr	r3, [r3, #0]
 8009fac:	9a03      	ldr	r2, [sp, #12]
 8009fae:	6812      	ldr	r2, [r2, #0]
 8009fb0:	6892      	ldr	r2, [r2, #8]
 8009fb2:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8009fb6:	609a      	str	r2, [r3, #8]
      rtcp->rtc->CR &= ~RTC_CR_ALRAE;
 8009fb8:	9b03      	ldr	r3, [sp, #12]
 8009fba:	681b      	ldr	r3, [r3, #0]
 8009fbc:	9a03      	ldr	r2, [sp, #12]
 8009fbe:	6812      	ldr	r2, [r2, #0]
 8009fc0:	6892      	ldr	r2, [r2, #8]
 8009fc2:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8009fc6:	609a      	str	r2, [r3, #8]
 8009fc8:	e038      	b.n	800a03c <rtc_lld_set_alarm+0xfc>
    }
  }
#if RTC_ALARMS > 1
  else {
    if (alarmspec != NULL) {
 8009fca:	9b01      	ldr	r3, [sp, #4]
 8009fcc:	2b00      	cmp	r3, #0
 8009fce:	d025      	beq.n	800a01c <rtc_lld_set_alarm+0xdc>
      rtcp->rtc->CR &= ~RTC_CR_ALRBE;
 8009fd0:	9b03      	ldr	r3, [sp, #12]
 8009fd2:	681b      	ldr	r3, [r3, #0]
 8009fd4:	9a03      	ldr	r2, [sp, #12]
 8009fd6:	6812      	ldr	r2, [r2, #0]
 8009fd8:	6892      	ldr	r2, [r2, #8]
 8009fda:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8009fde:	609a      	str	r2, [r3, #8]
      while (!(rtcp->rtc->ISR & RTC_ISR_ALRBWF))
 8009fe0:	bf00      	nop
 8009fe2:	9b03      	ldr	r3, [sp, #12]
 8009fe4:	681b      	ldr	r3, [r3, #0]
 8009fe6:	68db      	ldr	r3, [r3, #12]
 8009fe8:	f003 0302 	and.w	r3, r3, #2
 8009fec:	2b00      	cmp	r3, #0
 8009fee:	d0f8      	beq.n	8009fe2 <rtc_lld_set_alarm+0xa2>
        ;
      rtcp->rtc->ALRMBR = alarmspec->alrmr;
 8009ff0:	9b03      	ldr	r3, [sp, #12]
 8009ff2:	681b      	ldr	r3, [r3, #0]
 8009ff4:	9a01      	ldr	r2, [sp, #4]
 8009ff6:	6812      	ldr	r2, [r2, #0]
 8009ff8:	621a      	str	r2, [r3, #32]
      rtcp->rtc->CR |= RTC_CR_ALRBE;
 8009ffa:	9b03      	ldr	r3, [sp, #12]
 8009ffc:	681b      	ldr	r3, [r3, #0]
 8009ffe:	9a03      	ldr	r2, [sp, #12]
 800a000:	6812      	ldr	r2, [r2, #0]
 800a002:	6892      	ldr	r2, [r2, #8]
 800a004:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800a008:	609a      	str	r2, [r3, #8]
      rtcp->rtc->CR |= RTC_CR_ALRBIE;
 800a00a:	9b03      	ldr	r3, [sp, #12]
 800a00c:	681b      	ldr	r3, [r3, #0]
 800a00e:	9a03      	ldr	r2, [sp, #12]
 800a010:	6812      	ldr	r2, [r2, #0]
 800a012:	6892      	ldr	r2, [r2, #8]
 800a014:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800a018:	609a      	str	r2, [r3, #8]
 800a01a:	e00f      	b.n	800a03c <rtc_lld_set_alarm+0xfc>
    }
    else {
      rtcp->rtc->CR &= ~RTC_CR_ALRBIE;
 800a01c:	9b03      	ldr	r3, [sp, #12]
 800a01e:	681b      	ldr	r3, [r3, #0]
 800a020:	9a03      	ldr	r2, [sp, #12]
 800a022:	6812      	ldr	r2, [r2, #0]
 800a024:	6892      	ldr	r2, [r2, #8]
 800a026:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800a02a:	609a      	str	r2, [r3, #8]
      rtcp->rtc->CR &= ~RTC_CR_ALRBE;
 800a02c:	9b03      	ldr	r3, [sp, #12]
 800a02e:	681b      	ldr	r3, [r3, #0]
 800a030:	9a03      	ldr	r2, [sp, #12]
 800a032:	6812      	ldr	r2, [r2, #0]
 800a034:	6892      	ldr	r2, [r2, #8]
 800a036:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 800a03a:	609a      	str	r2, [r3, #8]
    }
  }
#endif /* RTC_ALARMS > 1 */

  /* Leaving a reentrant critical zone.*/
  osalSysRestoreStatusX(sts);
 800a03c:	9805      	ldr	r0, [sp, #20]
 800a03e:	f7ff fcb7 	bl	80099b0 <osalSysRestoreStatusX>
}
 800a042:	b007      	add	sp, #28
 800a044:	f85d fb04 	ldr.w	pc, [sp], #4
 800a048:	f3af 8000 	nop.w
 800a04c:	f3af 8000 	nop.w

0800a050 <rtc_lld_get_alarm>:
 *
 * @notapi
 */
void rtc_lld_get_alarm(RTCDriver *rtcp,
                       rtcalarm_t alarm,
                       RTCAlarm *alarmspec) {
 800a050:	b084      	sub	sp, #16
 800a052:	9003      	str	r0, [sp, #12]
 800a054:	9102      	str	r1, [sp, #8]
 800a056:	9201      	str	r2, [sp, #4]

  if (alarm == 0)
 800a058:	9b02      	ldr	r3, [sp, #8]
 800a05a:	2b00      	cmp	r3, #0
 800a05c:	d105      	bne.n	800a06a <rtc_lld_get_alarm+0x1a>
    alarmspec->alrmr = rtcp->rtc->ALRMAR;
 800a05e:	9b03      	ldr	r3, [sp, #12]
 800a060:	681b      	ldr	r3, [r3, #0]
 800a062:	69da      	ldr	r2, [r3, #28]
 800a064:	9b01      	ldr	r3, [sp, #4]
 800a066:	601a      	str	r2, [r3, #0]
 800a068:	e004      	b.n	800a074 <rtc_lld_get_alarm+0x24>
#if RTC_ALARMS > 1
  else
    alarmspec->alrmr = rtcp->rtc->ALRMBR;
 800a06a:	9b03      	ldr	r3, [sp, #12]
 800a06c:	681b      	ldr	r3, [r3, #0]
 800a06e:	6a1a      	ldr	r2, [r3, #32]
 800a070:	9b01      	ldr	r3, [sp, #4]
 800a072:	601a      	str	r2, [r3, #0]
#endif /* RTC_ALARMS > 1 */
}
 800a074:	b004      	add	sp, #16
 800a076:	4770      	bx	lr
 800a078:	f3af 8000 	nop.w
 800a07c:	f3af 8000 	nop.w

0800a080 <rtcSTM32SetPeriodicWakeup>:
 * @param[in] rtcp       pointer to RTC driver structure
 * @param[in] wakeupspec pointer to a @p RTCWakeup structure
 *
 * @api
 */
void rtcSTM32SetPeriodicWakeup(RTCDriver *rtcp, const RTCWakeup *wakeupspec) {
 800a080:	b500      	push	{lr}
 800a082:	b085      	sub	sp, #20
 800a084:	9001      	str	r0, [sp, #4]
 800a086:	9100      	str	r1, [sp, #0]
  syssts_t sts;

  /* Entering a reentrant critical zone.*/
  sts = osalSysGetStatusAndLockX();
 800a088:	f7ff fc8a 	bl	80099a0 <osalSysGetStatusAndLockX>
 800a08c:	9003      	str	r0, [sp, #12]

  if (wakeupspec != NULL) {
 800a08e:	9b00      	ldr	r3, [sp, #0]
 800a090:	2b00      	cmp	r3, #0
 800a092:	d02e      	beq.n	800a0f2 <rtcSTM32SetPeriodicWakeup+0x72>
    osalDbgCheck(wakeupspec->wutr != 0x30000);

    rtcp->rtc->CR &= ~RTC_CR_WUTE;
 800a094:	9b01      	ldr	r3, [sp, #4]
 800a096:	681b      	ldr	r3, [r3, #0]
 800a098:	9a01      	ldr	r2, [sp, #4]
 800a09a:	6812      	ldr	r2, [r2, #0]
 800a09c:	6892      	ldr	r2, [r2, #8]
 800a09e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800a0a2:	609a      	str	r2, [r3, #8]
    while (!(rtcp->rtc->ISR & RTC_ISR_WUTWF))
 800a0a4:	bf00      	nop
 800a0a6:	9b01      	ldr	r3, [sp, #4]
 800a0a8:	681b      	ldr	r3, [r3, #0]
 800a0aa:	68db      	ldr	r3, [r3, #12]
 800a0ac:	f003 0304 	and.w	r3, r3, #4
 800a0b0:	2b00      	cmp	r3, #0
 800a0b2:	d0f8      	beq.n	800a0a6 <rtcSTM32SetPeriodicWakeup+0x26>
      ;
    rtcp->rtc->WUTR = wakeupspec->wutr & 0xFFFF;
 800a0b4:	9b01      	ldr	r3, [sp, #4]
 800a0b6:	681b      	ldr	r3, [r3, #0]
 800a0b8:	9a00      	ldr	r2, [sp, #0]
 800a0ba:	6812      	ldr	r2, [r2, #0]
 800a0bc:	b292      	uxth	r2, r2
 800a0be:	615a      	str	r2, [r3, #20]
    rtcp->rtc->CR   = (wakeupspec->wutr >> 16) & 0x7;
 800a0c0:	9b01      	ldr	r3, [sp, #4]
 800a0c2:	681b      	ldr	r3, [r3, #0]
 800a0c4:	9a00      	ldr	r2, [sp, #0]
 800a0c6:	6812      	ldr	r2, [r2, #0]
 800a0c8:	0c12      	lsrs	r2, r2, #16
 800a0ca:	f002 0207 	and.w	r2, r2, #7
 800a0ce:	609a      	str	r2, [r3, #8]
    rtcp->rtc->CR |= RTC_CR_WUTIE;
 800a0d0:	9b01      	ldr	r3, [sp, #4]
 800a0d2:	681b      	ldr	r3, [r3, #0]
 800a0d4:	9a01      	ldr	r2, [sp, #4]
 800a0d6:	6812      	ldr	r2, [r2, #0]
 800a0d8:	6892      	ldr	r2, [r2, #8]
 800a0da:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800a0de:	609a      	str	r2, [r3, #8]
    rtcp->rtc->CR |= RTC_CR_WUTE;
 800a0e0:	9b01      	ldr	r3, [sp, #4]
 800a0e2:	681b      	ldr	r3, [r3, #0]
 800a0e4:	9a01      	ldr	r2, [sp, #4]
 800a0e6:	6812      	ldr	r2, [r2, #0]
 800a0e8:	6892      	ldr	r2, [r2, #8]
 800a0ea:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800a0ee:	609a      	str	r2, [r3, #8]
 800a0f0:	e00f      	b.n	800a112 <rtcSTM32SetPeriodicWakeup+0x92>
  }
  else {
    rtcp->rtc->CR &= ~RTC_CR_WUTIE;
 800a0f2:	9b01      	ldr	r3, [sp, #4]
 800a0f4:	681b      	ldr	r3, [r3, #0]
 800a0f6:	9a01      	ldr	r2, [sp, #4]
 800a0f8:	6812      	ldr	r2, [r2, #0]
 800a0fa:	6892      	ldr	r2, [r2, #8]
 800a0fc:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 800a100:	609a      	str	r2, [r3, #8]
    rtcp->rtc->CR &= ~RTC_CR_WUTE;
 800a102:	9b01      	ldr	r3, [sp, #4]
 800a104:	681b      	ldr	r3, [r3, #0]
 800a106:	9a01      	ldr	r2, [sp, #4]
 800a108:	6812      	ldr	r2, [r2, #0]
 800a10a:	6892      	ldr	r2, [r2, #8]
 800a10c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800a110:	609a      	str	r2, [r3, #8]
  }

  /* Leaving a reentrant critical zone.*/
  osalSysRestoreStatusX(sts);
 800a112:	9803      	ldr	r0, [sp, #12]
 800a114:	f7ff fc4c 	bl	80099b0 <osalSysRestoreStatusX>
}
 800a118:	b005      	add	sp, #20
 800a11a:	f85d fb04 	ldr.w	pc, [sp], #4
 800a11e:	bf00      	nop

0800a120 <rtcSTM32GetPeriodicWakeup>:
 * @param[in] rtcp        pointer to RTC driver structure
 * @param[out] wakeupspec pointer to a @p RTCWakeup structure
 *
 * @api
 */
void rtcSTM32GetPeriodicWakeup(RTCDriver *rtcp, RTCWakeup *wakeupspec) {
 800a120:	b500      	push	{lr}
 800a122:	b085      	sub	sp, #20
 800a124:	9001      	str	r0, [sp, #4]
 800a126:	9100      	str	r1, [sp, #0]
  syssts_t sts;

  /* Entering a reentrant critical zone.*/
  sts = osalSysGetStatusAndLockX();
 800a128:	f7ff fc3a 	bl	80099a0 <osalSysGetStatusAndLockX>
 800a12c:	9003      	str	r0, [sp, #12]

  wakeupspec->wutr  = 0;
 800a12e:	9b00      	ldr	r3, [sp, #0]
 800a130:	2200      	movs	r2, #0
 800a132:	601a      	str	r2, [r3, #0]
  wakeupspec->wutr |= rtcp->rtc->WUTR;
 800a134:	9b00      	ldr	r3, [sp, #0]
 800a136:	681a      	ldr	r2, [r3, #0]
 800a138:	9b01      	ldr	r3, [sp, #4]
 800a13a:	681b      	ldr	r3, [r3, #0]
 800a13c:	695b      	ldr	r3, [r3, #20]
 800a13e:	431a      	orrs	r2, r3
 800a140:	9b00      	ldr	r3, [sp, #0]
 800a142:	601a      	str	r2, [r3, #0]
  wakeupspec->wutr |= (((uint32_t)rtcp->rtc->CR) & 0x7) << 16;
 800a144:	9b00      	ldr	r3, [sp, #0]
 800a146:	681a      	ldr	r2, [r3, #0]
 800a148:	9b01      	ldr	r3, [sp, #4]
 800a14a:	681b      	ldr	r3, [r3, #0]
 800a14c:	689b      	ldr	r3, [r3, #8]
 800a14e:	f003 0307 	and.w	r3, r3, #7
 800a152:	041b      	lsls	r3, r3, #16
 800a154:	431a      	orrs	r2, r3
 800a156:	9b00      	ldr	r3, [sp, #0]
 800a158:	601a      	str	r2, [r3, #0]

  /* Leaving a reentrant critical zone.*/
  osalSysRestoreStatusX(sts);
 800a15a:	9803      	ldr	r0, [sp, #12]
 800a15c:	f7ff fc28 	bl	80099b0 <osalSysRestoreStatusX>
}
 800a160:	b005      	add	sp, #20
 800a162:	f85d fb04 	ldr.w	pc, [sp], #4
 800a166:	bf00      	nop
 800a168:	f3af 8000 	nop.w
 800a16c:	f3af 8000 	nop.w

0800a170 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800a170:	b082      	sub	sp, #8
 800a172:	2320      	movs	r3, #32
 800a174:	9301      	str	r3, [sp, #4]
 800a176:	9b01      	ldr	r3, [sp, #4]
 800a178:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a17c:	b002      	add	sp, #8
 800a17e:	4770      	bx	lr

0800a180 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800a180:	b082      	sub	sp, #8
 800a182:	2300      	movs	r3, #0
 800a184:	9301      	str	r3, [sp, #4]
 800a186:	9b01      	ldr	r3, [sp, #4]
 800a188:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a18c:	b002      	add	sp, #8
 800a18e:	4770      	bx	lr

0800a190 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800a190:	b508      	push	{r3, lr}

  port_lock();
 800a192:	f7ff ffed 	bl	800a170 <port_lock>
}
 800a196:	bd08      	pop	{r3, pc}
 800a198:	f3af 8000 	nop.w
 800a19c:	f3af 8000 	nop.w

0800a1a0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800a1a0:	b508      	push	{r3, lr}

  port_unlock();
 800a1a2:	f7ff ffed 	bl	800a180 <port_unlock>
}
 800a1a6:	bd08      	pop	{r3, pc}
 800a1a8:	f3af 8000 	nop.w
 800a1ac:	f3af 8000 	nop.w

0800a1b0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800a1b0:	b508      	push	{r3, lr}

  port_lock();
 800a1b2:	f7ff ffdd 	bl	800a170 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800a1b6:	bd08      	pop	{r3, pc}
 800a1b8:	f3af 8000 	nop.w
 800a1bc:	f3af 8000 	nop.w

0800a1c0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800a1c0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800a1c2:	f7ff ffdd 	bl	800a180 <port_unlock>
}
 800a1c6:	bd08      	pop	{r3, pc}
 800a1c8:	f3af 8000 	nop.w
 800a1cc:	f3af 8000 	nop.w

0800a1d0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 800a1d0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800a1d2:	f7ff ffdd 	bl	800a190 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 800a1d6:	bd08      	pop	{r3, pc}
 800a1d8:	f3af 8000 	nop.w
 800a1dc:	f3af 8000 	nop.w

0800a1e0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 800a1e0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 800a1e2:	f7ff ffdd 	bl	800a1a0 <port_unlock_from_isr>
}
 800a1e6:	bd08      	pop	{r3, pc}
 800a1e8:	f3af 8000 	nop.w
 800a1ec:	f3af 8000 	nop.w

0800a1f0 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 800a1f0:	b508      	push	{r3, lr}

  chSysLock();
 800a1f2:	f7ff ffdd 	bl	800a1b0 <chSysLock>
}
 800a1f6:	bd08      	pop	{r3, pc}
 800a1f8:	f3af 8000 	nop.w
 800a1fc:	f3af 8000 	nop.w

0800a200 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 800a200:	b508      	push	{r3, lr}

  chSysUnlock();
 800a202:	f7ff ffdd 	bl	800a1c0 <chSysUnlock>
}
 800a206:	bd08      	pop	{r3, pc}
 800a208:	f3af 8000 	nop.w
 800a20c:	f3af 8000 	nop.w

0800a210 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 800a210:	b508      	push	{r3, lr}

  chSysLockFromISR();
 800a212:	f7ff ffdd 	bl	800a1d0 <chSysLockFromISR>
}
 800a216:	bd08      	pop	{r3, pc}
 800a218:	f3af 8000 	nop.w
 800a21c:	f3af 8000 	nop.w

0800a220 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 800a220:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 800a222:	f7ff ffdd 	bl	800a1e0 <chSysUnlockFromISR>
}
 800a226:	bd08      	pop	{r3, pc}
 800a228:	f3af 8000 	nop.w
 800a22c:	f3af 8000 	nop.w

0800a230 <osalThreadSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
static inline void osalThreadSleep(systime_t time) {
 800a230:	b500      	push	{lr}
 800a232:	b083      	sub	sp, #12
 800a234:	9001      	str	r0, [sp, #4]

  chThdSleep(time);
 800a236:	9801      	ldr	r0, [sp, #4]
 800a238:	f7f7 f84a 	bl	80012d0 <chThdSleep>
}
 800a23c:	b003      	add	sp, #12
 800a23e:	f85d fb04 	ldr.w	pc, [sp], #4
 800a242:	bf00      	nop
 800a244:	f3af 8000 	nop.w
 800a248:	f3af 8000 	nop.w
 800a24c:	f3af 8000 	nop.w

0800a250 <osalThreadSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 800a250:	b500      	push	{lr}
 800a252:	b083      	sub	sp, #12
 800a254:	9001      	str	r0, [sp, #4]

  return chThdSuspendS(trp);
 800a256:	9801      	ldr	r0, [sp, #4]
 800a258:	f7f7 f8fa 	bl	8001450 <chThdSuspendS>
 800a25c:	4603      	mov	r3, r0
}
 800a25e:	4618      	mov	r0, r3
 800a260:	b003      	add	sp, #12
 800a262:	f85d fb04 	ldr.w	pc, [sp], #4
 800a266:	bf00      	nop
 800a268:	f3af 8000 	nop.w
 800a26c:	f3af 8000 	nop.w

0800a270 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 800a270:	b500      	push	{lr}
 800a272:	b083      	sub	sp, #12
 800a274:	9001      	str	r0, [sp, #4]
 800a276:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
 800a278:	9801      	ldr	r0, [sp, #4]
 800a27a:	9900      	ldr	r1, [sp, #0]
 800a27c:	f7f7 f920 	bl	80014c0 <chThdResumeI>
}
 800a280:	b003      	add	sp, #12
 800a282:	f85d fb04 	ldr.w	pc, [sp], #4
 800a286:	bf00      	nop
 800a288:	f3af 8000 	nop.w
 800a28c:	f3af 8000 	nop.w

0800a290 <sdc_lld_prepare_read_bytes>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_lld_prepare_read_bytes(SDCDriver *sdcp,
                                       uint8_t *buf, uint32_t bytes) {
 800a290:	b500      	push	{lr}
 800a292:	b087      	sub	sp, #28
 800a294:	9003      	str	r0, [sp, #12]
 800a296:	9102      	str	r1, [sp, #8]
 800a298:	9201      	str	r2, [sp, #4]
  osalDbgCheck(bytes < 0x1000000);

  sdcp->sdmmc->DTIMER = SDMMC_READ_TIMEOUT;
 800a29a:	9b03      	ldr	r3, [sp, #12]
 800a29c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a29e:	4a2d      	ldr	r2, [pc, #180]	; (800a354 <sdc_lld_prepare_read_bytes+0xc4>)
 800a2a0:	625a      	str	r2, [r3, #36]	; 0x24

  /* Checks for errors and waits for the card to be ready for reading.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 800a2a2:	9803      	ldr	r0, [sp, #12]
 800a2a4:	f7fb fbb4 	bl	8005a10 <_sdc_wait_for_transfer_state>
 800a2a8:	4603      	mov	r3, r0
 800a2aa:	2b00      	cmp	r3, #0
 800a2ac:	d001      	beq.n	800a2b2 <sdc_lld_prepare_read_bytes+0x22>
    return HAL_FAILED;
 800a2ae:	2301      	movs	r3, #1
 800a2b0:	e04b      	b.n	800a34a <sdc_lld_prepare_read_bytes+0xba>

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 800a2b2:	9b03      	ldr	r3, [sp, #12]
 800a2b4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a2b6:	685b      	ldr	r3, [r3, #4]
 800a2b8:	9a02      	ldr	r2, [sp, #8]
 800a2ba:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(sdcp->dma, bytes / sizeof (uint32_t));
 800a2bc:	9b03      	ldr	r3, [sp, #12]
 800a2be:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a2c0:	685b      	ldr	r3, [r3, #4]
 800a2c2:	9a01      	ldr	r2, [sp, #4]
 800a2c4:	0892      	lsrs	r2, r2, #2
 800a2c6:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
 800a2c8:	9b03      	ldr	r3, [sp, #12]
 800a2ca:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a2cc:	68db      	ldr	r3, [r3, #12]
 800a2ce:	681b      	ldr	r3, [r3, #0]
 800a2d0:	9305      	str	r3, [sp, #20]
 800a2d2:	9b03      	ldr	r3, [sp, #12]
 800a2d4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a2d6:	7c1b      	ldrb	r3, [r3, #16]
 800a2d8:	220f      	movs	r2, #15
 800a2da:	fa02 f303 	lsl.w	r3, r2, r3
 800a2de:	43db      	mvns	r3, r3
 800a2e0:	9a05      	ldr	r2, [sp, #20]
 800a2e2:	4013      	ands	r3, r2
 800a2e4:	9305      	str	r3, [sp, #20]
 800a2e6:	9b03      	ldr	r3, [sp, #12]
 800a2e8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800a2ea:	0c1a      	lsrs	r2, r3, #16
 800a2ec:	9b03      	ldr	r3, [sp, #12]
 800a2ee:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a2f0:	7c1b      	ldrb	r3, [r3, #16]
 800a2f2:	fa02 f303 	lsl.w	r3, r2, r3
 800a2f6:	9a05      	ldr	r2, [sp, #20]
 800a2f8:	4313      	orrs	r3, r2
 800a2fa:	9305      	str	r3, [sp, #20]
 800a2fc:	9b03      	ldr	r3, [sp, #12]
 800a2fe:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a300:	68db      	ldr	r3, [r3, #12]
 800a302:	9a05      	ldr	r2, [sp, #20]
 800a304:	601a      	str	r2, [r3, #0]
 800a306:	9b03      	ldr	r3, [sp, #12]
 800a308:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a30a:	685b      	ldr	r3, [r3, #4]
 800a30c:	9a03      	ldr	r2, [sp, #12]
 800a30e:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800a310:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(sdcp->dma);
 800a312:	9b03      	ldr	r3, [sp, #12]
 800a314:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a316:	685b      	ldr	r3, [r3, #4]
 800a318:	9a03      	ldr	r2, [sp, #12]
 800a31a:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800a31c:	6852      	ldr	r2, [r2, #4]
 800a31e:	6812      	ldr	r2, [r2, #0]
 800a320:	f042 0201 	orr.w	r2, r2, #1
 800a324:	601a      	str	r2, [r3, #0]

  /* Setting up data transfer.*/
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 800a326:	9b03      	ldr	r3, [sp, #12]
 800a328:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a32a:	4a0b      	ldr	r2, [pc, #44]	; (800a358 <sdc_lld_prepare_read_bytes+0xc8>)
 800a32c:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdmmc->MASK  = SDMMC_MASK_DCRCFAILIE |
 800a32e:	9b03      	ldr	r3, [sp, #12]
 800a330:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a332:	f44f 7295 	mov.w	r2, #298	; 0x12a
 800a336:	63da      	str	r2, [r3, #60]	; 0x3c
                       SDMMC_MASK_DTIMEOUTIE |
                       SDMMC_MASK_RXOVERRIE |
                       SDMMC_MASK_DATAENDIE;
  sdcp->sdmmc->DLEN  = bytes;
 800a338:	9b03      	ldr	r3, [sp, #12]
 800a33a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a33c:	9a01      	ldr	r2, [sp, #4]
 800a33e:	629a      	str	r2, [r3, #40]	; 0x28

  /* Transaction starts just after DTEN bit setting.*/
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DTDIR |
 800a340:	9b03      	ldr	r3, [sp, #12]
 800a342:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a344:	220f      	movs	r2, #15
 800a346:	62da      	str	r2, [r3, #44]	; 0x2c
                       SDMMC_DCTRL_DTMODE |   /* multibyte data transfer */
                       SDMMC_DCTRL_DMAEN |
                       SDMMC_DCTRL_DTEN;

  return HAL_SUCCESS;
 800a348:	2300      	movs	r3, #0
}
 800a34a:	4618      	mov	r0, r3
 800a34c:	b007      	add	sp, #28
 800a34e:	f85d fb04 	ldr.w	pc, [sp], #4
 800a352:	bf00      	nop
 800a354:	000927c0 	.word	0x000927c0
 800a358:	004005ff 	.word	0x004005ff
 800a35c:	f3af 8000 	nop.w

0800a360 <sdc_lld_prepare_read>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_lld_prepare_read(SDCDriver *sdcp, uint32_t startblk,
                                 uint32_t n, uint32_t *resp) {
 800a360:	b500      	push	{lr}
 800a362:	b085      	sub	sp, #20
 800a364:	9003      	str	r0, [sp, #12]
 800a366:	9102      	str	r1, [sp, #8]
 800a368:	9201      	str	r2, [sp, #4]
 800a36a:	9300      	str	r3, [sp, #0]

  /* Driver handles data in 512 bytes blocks (just like HC cards). But if we
     have not HC card than we must convert address from blocks to bytes.*/
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
 800a36c:	9b03      	ldr	r3, [sp, #12]
 800a36e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a370:	f003 0310 	and.w	r3, r3, #16
 800a374:	2b00      	cmp	r3, #0
 800a376:	d102      	bne.n	800a37e <sdc_lld_prepare_read+0x1e>
    startblk *= MMCSD_BLOCK_SIZE;
 800a378:	9b02      	ldr	r3, [sp, #8]
 800a37a:	025b      	lsls	r3, r3, #9
 800a37c:	9302      	str	r3, [sp, #8]

  if (n > 1) {
 800a37e:	9b01      	ldr	r3, [sp, #4]
 800a380:	2b01      	cmp	r3, #1
 800a382:	d910      	bls.n	800a3a6 <sdc_lld_prepare_read+0x46>
    /* Send read multiple blocks command to card.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_MULTIPLE_BLOCK,
 800a384:	9803      	ldr	r0, [sp, #12]
 800a386:	2112      	movs	r1, #18
 800a388:	9a02      	ldr	r2, [sp, #8]
 800a38a:	9b00      	ldr	r3, [sp, #0]
 800a38c:	f000 fab8 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 800a390:	4603      	mov	r3, r0
 800a392:	2b00      	cmp	r3, #0
 800a394:	d105      	bne.n	800a3a2 <sdc_lld_prepare_read+0x42>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 800a396:	9b00      	ldr	r3, [sp, #0]
 800a398:	681a      	ldr	r2, [r3, #0]
 800a39a:	4b0e      	ldr	r3, [pc, #56]	; (800a3d4 <sdc_lld_prepare_read+0x74>)
 800a39c:	4013      	ands	r3, r2
 800a39e:	2b00      	cmp	r3, #0
 800a3a0:	d012      	beq.n	800a3c8 <sdc_lld_prepare_read+0x68>
      return HAL_FAILED;
 800a3a2:	2301      	movs	r3, #1
 800a3a4:	e011      	b.n	800a3ca <sdc_lld_prepare_read+0x6a>
  }
  else{
    /* Send read single block command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_SINGLE_BLOCK,
 800a3a6:	9803      	ldr	r0, [sp, #12]
 800a3a8:	2111      	movs	r1, #17
 800a3aa:	9a02      	ldr	r2, [sp, #8]
 800a3ac:	9b00      	ldr	r3, [sp, #0]
 800a3ae:	f000 faa7 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 800a3b2:	4603      	mov	r3, r0
 800a3b4:	2b00      	cmp	r3, #0
 800a3b6:	d105      	bne.n	800a3c4 <sdc_lld_prepare_read+0x64>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 800a3b8:	9b00      	ldr	r3, [sp, #0]
 800a3ba:	681a      	ldr	r2, [r3, #0]
 800a3bc:	4b05      	ldr	r3, [pc, #20]	; (800a3d4 <sdc_lld_prepare_read+0x74>)
 800a3be:	4013      	ands	r3, r2
 800a3c0:	2b00      	cmp	r3, #0
 800a3c2:	d001      	beq.n	800a3c8 <sdc_lld_prepare_read+0x68>
      return HAL_FAILED;
 800a3c4:	2301      	movs	r3, #1
 800a3c6:	e000      	b.n	800a3ca <sdc_lld_prepare_read+0x6a>
  }

  return HAL_SUCCESS;
 800a3c8:	2300      	movs	r3, #0
}
 800a3ca:	4618      	mov	r0, r3
 800a3cc:	b005      	add	sp, #20
 800a3ce:	f85d fb04 	ldr.w	pc, [sp], #4
 800a3d2:	bf00      	nop
 800a3d4:	fdffe008 	.word	0xfdffe008
 800a3d8:	f3af 8000 	nop.w
 800a3dc:	f3af 8000 	nop.w

0800a3e0 <sdc_lld_prepare_write>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_lld_prepare_write(SDCDriver *sdcp, uint32_t startblk,
                                  uint32_t n, uint32_t *resp) {
 800a3e0:	b500      	push	{lr}
 800a3e2:	b085      	sub	sp, #20
 800a3e4:	9003      	str	r0, [sp, #12]
 800a3e6:	9102      	str	r1, [sp, #8]
 800a3e8:	9201      	str	r2, [sp, #4]
 800a3ea:	9300      	str	r3, [sp, #0]

  /* Driver handles data in 512 bytes blocks (just like HC cards). But if we
     have not HC card than we must convert address from blocks to bytes.*/
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
 800a3ec:	9b03      	ldr	r3, [sp, #12]
 800a3ee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a3f0:	f003 0310 	and.w	r3, r3, #16
 800a3f4:	2b00      	cmp	r3, #0
 800a3f6:	d102      	bne.n	800a3fe <sdc_lld_prepare_write+0x1e>
    startblk *= MMCSD_BLOCK_SIZE;
 800a3f8:	9b02      	ldr	r3, [sp, #8]
 800a3fa:	025b      	lsls	r3, r3, #9
 800a3fc:	9302      	str	r3, [sp, #8]

  if (n > 1) {
 800a3fe:	9b01      	ldr	r3, [sp, #4]
 800a400:	2b01      	cmp	r3, #1
 800a402:	d910      	bls.n	800a426 <sdc_lld_prepare_write+0x46>
    /* Write multiple blocks command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_MULTIPLE_BLOCK,
 800a404:	9803      	ldr	r0, [sp, #12]
 800a406:	2119      	movs	r1, #25
 800a408:	9a02      	ldr	r2, [sp, #8]
 800a40a:	9b00      	ldr	r3, [sp, #0]
 800a40c:	f000 fa78 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 800a410:	4603      	mov	r3, r0
 800a412:	2b00      	cmp	r3, #0
 800a414:	d105      	bne.n	800a422 <sdc_lld_prepare_write+0x42>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 800a416:	9b00      	ldr	r3, [sp, #0]
 800a418:	681a      	ldr	r2, [r3, #0]
 800a41a:	4b0e      	ldr	r3, [pc, #56]	; (800a454 <sdc_lld_prepare_write+0x74>)
 800a41c:	4013      	ands	r3, r2
 800a41e:	2b00      	cmp	r3, #0
 800a420:	d012      	beq.n	800a448 <sdc_lld_prepare_write+0x68>
      return HAL_FAILED;
 800a422:	2301      	movs	r3, #1
 800a424:	e011      	b.n	800a44a <sdc_lld_prepare_write+0x6a>
  }
  else{
    /* Write single block command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_BLOCK,
 800a426:	9803      	ldr	r0, [sp, #12]
 800a428:	2118      	movs	r1, #24
 800a42a:	9a02      	ldr	r2, [sp, #8]
 800a42c:	9b00      	ldr	r3, [sp, #0]
 800a42e:	f000 fa67 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 800a432:	4603      	mov	r3, r0
 800a434:	2b00      	cmp	r3, #0
 800a436:	d105      	bne.n	800a444 <sdc_lld_prepare_write+0x64>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 800a438:	9b00      	ldr	r3, [sp, #0]
 800a43a:	681a      	ldr	r2, [r3, #0]
 800a43c:	4b05      	ldr	r3, [pc, #20]	; (800a454 <sdc_lld_prepare_write+0x74>)
 800a43e:	4013      	ands	r3, r2
 800a440:	2b00      	cmp	r3, #0
 800a442:	d001      	beq.n	800a448 <sdc_lld_prepare_write+0x68>
      return HAL_FAILED;
 800a444:	2301      	movs	r3, #1
 800a446:	e000      	b.n	800a44a <sdc_lld_prepare_write+0x6a>
  }

  return HAL_SUCCESS;
 800a448:	2300      	movs	r3, #0
}
 800a44a:	4618      	mov	r0, r3
 800a44c:	b005      	add	sp, #20
 800a44e:	f85d fb04 	ldr.w	pc, [sp], #4
 800a452:	bf00      	nop
 800a454:	fdffe008 	.word	0xfdffe008
 800a458:	f3af 8000 	nop.w
 800a45c:	f3af 8000 	nop.w

0800a460 <sdc_lld_wait_transaction_end>:
 * @return              The operation status.
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 */
static bool sdc_lld_wait_transaction_end(SDCDriver *sdcp, uint32_t n,
                                         uint32_t *resp) {
 800a460:	b500      	push	{lr}
 800a462:	b085      	sub	sp, #20
 800a464:	9003      	str	r0, [sp, #12]
 800a466:	9102      	str	r1, [sp, #8]
 800a468:	9201      	str	r2, [sp, #4]

  /* Note the mask is checked before going to sleep because the interrupt
     may have occurred before reaching the critical zone.*/
  osalSysLock();
 800a46a:	f7ff fec1 	bl	800a1f0 <osalSysLock>
  if (sdcp->sdmmc->MASK != 0)
 800a46e:	9b03      	ldr	r3, [sp, #12]
 800a470:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a472:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800a474:	2b00      	cmp	r3, #0
 800a476:	d004      	beq.n	800a482 <sdc_lld_wait_transaction_end+0x22>
    osalThreadSuspendS(&sdcp->thread);
 800a478:	9b03      	ldr	r3, [sp, #12]
 800a47a:	333c      	adds	r3, #60	; 0x3c
 800a47c:	4618      	mov	r0, r3
 800a47e:	f7ff fee7 	bl	800a250 <osalThreadSuspendS>
  if ((sdcp->sdmmc->STA & SDMMC_STA_DATAEND) == 0) {
 800a482:	9b03      	ldr	r3, [sp, #12]
 800a484:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a486:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a488:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800a48c:	2b00      	cmp	r3, #0
 800a48e:	d103      	bne.n	800a498 <sdc_lld_wait_transaction_end+0x38>
    osalSysUnlock();
 800a490:	f7ff feb6 	bl	800a200 <osalSysUnlock>
    return HAL_FAILED;
 800a494:	2301      	movs	r3, #1
 800a496:	e030      	b.n	800a4fa <sdc_lld_wait_transaction_end+0x9a>
  }

  /* Waits for transfer completion at DMA level, then the stream is
     disabled and cleared.*/
  dmaWaitCompletion(sdcp->dma);
 800a498:	bf00      	nop
 800a49a:	9b03      	ldr	r3, [sp, #12]
 800a49c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a49e:	685b      	ldr	r3, [r3, #4]
 800a4a0:	685b      	ldr	r3, [r3, #4]
 800a4a2:	2b00      	cmp	r3, #0
 800a4a4:	d1f9      	bne.n	800a49a <sdc_lld_wait_transaction_end+0x3a>
 800a4a6:	9b03      	ldr	r3, [sp, #12]
 800a4a8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a4aa:	685b      	ldr	r3, [r3, #4]
 800a4ac:	9a03      	ldr	r2, [sp, #12]
 800a4ae:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800a4b0:	6852      	ldr	r2, [r2, #4]
 800a4b2:	6812      	ldr	r2, [r2, #0]
 800a4b4:	f022 020f 	bic.w	r2, r2, #15
 800a4b8:	601a      	str	r2, [r3, #0]
 800a4ba:	9b03      	ldr	r3, [sp, #12]
 800a4bc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a4be:	681b      	ldr	r3, [r3, #0]
 800a4c0:	9a03      	ldr	r2, [sp, #12]
 800a4c2:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800a4c4:	7c12      	ldrb	r2, [r2, #16]
 800a4c6:	210f      	movs	r1, #15
 800a4c8:	fa01 f202 	lsl.w	r2, r1, r2
 800a4cc:	605a      	str	r2, [r3, #4]

  sdcp->sdmmc->ICR = SDMMC_ICR_ALL_FLAGS;
 800a4ce:	9b03      	ldr	r3, [sp, #12]
 800a4d0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a4d2:	4a0c      	ldr	r2, [pc, #48]	; (800a504 <sdc_lld_wait_transaction_end+0xa4>)
 800a4d4:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdmmc->DCTRL = 0;
 800a4d6:	9b03      	ldr	r3, [sp, #12]
 800a4d8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a4da:	2200      	movs	r2, #0
 800a4dc:	62da      	str	r2, [r3, #44]	; 0x2c
  osalSysUnlock();
 800a4de:	f7ff fe8f 	bl	800a200 <osalSysUnlock>

  /* Finalize transaction.*/
  if (n > 1)
 800a4e2:	9b02      	ldr	r3, [sp, #8]
 800a4e4:	2b01      	cmp	r3, #1
 800a4e6:	d907      	bls.n	800a4f8 <sdc_lld_wait_transaction_end+0x98>
    return sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_STOP_TRANSMISSION, 0, resp);
 800a4e8:	9803      	ldr	r0, [sp, #12]
 800a4ea:	210c      	movs	r1, #12
 800a4ec:	2200      	movs	r2, #0
 800a4ee:	9b01      	ldr	r3, [sp, #4]
 800a4f0:	f000 fa06 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 800a4f4:	4603      	mov	r3, r0
 800a4f6:	e000      	b.n	800a4fa <sdc_lld_wait_transaction_end+0x9a>

  return HAL_SUCCESS;
 800a4f8:	2300      	movs	r3, #0
}
 800a4fa:	4618      	mov	r0, r3
 800a4fc:	b005      	add	sp, #20
 800a4fe:	f85d fb04 	ldr.w	pc, [sp], #4
 800a502:	bf00      	nop
 800a504:	004005ff 	.word	0x004005ff
 800a508:	f3af 8000 	nop.w
 800a50c:	f3af 8000 	nop.w

0800a510 <sdc_lld_collect_errors>:
 * @param[in] sdcp      pointer to the @p SDCDriver object
 * @param[in] sta       value of the STA register
 *
 * @notapi
 */
static void sdc_lld_collect_errors(SDCDriver *sdcp, uint32_t sta) {
 800a510:	b084      	sub	sp, #16
 800a512:	9001      	str	r0, [sp, #4]
 800a514:	9100      	str	r1, [sp, #0]
  uint32_t errors = SDC_NO_ERROR;
 800a516:	2300      	movs	r3, #0
 800a518:	9303      	str	r3, [sp, #12]

  if (sta & SDMMC_STA_CCRCFAIL)
 800a51a:	9b00      	ldr	r3, [sp, #0]
 800a51c:	f003 0301 	and.w	r3, r3, #1
 800a520:	2b00      	cmp	r3, #0
 800a522:	d003      	beq.n	800a52c <sdc_lld_collect_errors+0x1c>
    errors |= SDC_CMD_CRC_ERROR;
 800a524:	9b03      	ldr	r3, [sp, #12]
 800a526:	f043 0301 	orr.w	r3, r3, #1
 800a52a:	9303      	str	r3, [sp, #12]
  if (sta & SDMMC_STA_DCRCFAIL)
 800a52c:	9b00      	ldr	r3, [sp, #0]
 800a52e:	f003 0302 	and.w	r3, r3, #2
 800a532:	2b00      	cmp	r3, #0
 800a534:	d003      	beq.n	800a53e <sdc_lld_collect_errors+0x2e>
    errors |= SDC_DATA_CRC_ERROR;
 800a536:	9b03      	ldr	r3, [sp, #12]
 800a538:	f043 0302 	orr.w	r3, r3, #2
 800a53c:	9303      	str	r3, [sp, #12]
  if (sta & SDMMC_STA_CTIMEOUT)
 800a53e:	9b00      	ldr	r3, [sp, #0]
 800a540:	f003 0304 	and.w	r3, r3, #4
 800a544:	2b00      	cmp	r3, #0
 800a546:	d003      	beq.n	800a550 <sdc_lld_collect_errors+0x40>
    errors |= SDC_COMMAND_TIMEOUT;
 800a548:	9b03      	ldr	r3, [sp, #12]
 800a54a:	f043 0308 	orr.w	r3, r3, #8
 800a54e:	9303      	str	r3, [sp, #12]
  if (sta & SDMMC_STA_DTIMEOUT)
 800a550:	9b00      	ldr	r3, [sp, #0]
 800a552:	f003 0308 	and.w	r3, r3, #8
 800a556:	2b00      	cmp	r3, #0
 800a558:	d003      	beq.n	800a562 <sdc_lld_collect_errors+0x52>
    errors |= SDC_DATA_TIMEOUT;
 800a55a:	9b03      	ldr	r3, [sp, #12]
 800a55c:	f043 0304 	orr.w	r3, r3, #4
 800a560:	9303      	str	r3, [sp, #12]
  if (sta & SDMMC_STA_TXUNDERR)
 800a562:	9b00      	ldr	r3, [sp, #0]
 800a564:	f003 0310 	and.w	r3, r3, #16
 800a568:	2b00      	cmp	r3, #0
 800a56a:	d003      	beq.n	800a574 <sdc_lld_collect_errors+0x64>
    errors |= SDC_TX_UNDERRUN;
 800a56c:	9b03      	ldr	r3, [sp, #12]
 800a56e:	f043 0310 	orr.w	r3, r3, #16
 800a572:	9303      	str	r3, [sp, #12]
  if (sta & SDMMC_STA_RXOVERR)
 800a574:	9b00      	ldr	r3, [sp, #0]
 800a576:	f003 0320 	and.w	r3, r3, #32
 800a57a:	2b00      	cmp	r3, #0
 800a57c:	d003      	beq.n	800a586 <sdc_lld_collect_errors+0x76>
    errors |= SDC_RX_OVERRUN;
 800a57e:	9b03      	ldr	r3, [sp, #12]
 800a580:	f043 0320 	orr.w	r3, r3, #32
 800a584:	9303      	str	r3, [sp, #12]
/*  if (sta & SDMMC_STA_STBITERR)
    errors |= SDC_STARTBIT_ERROR;*/

  sdcp->errors |= errors;
 800a586:	9b01      	ldr	r3, [sp, #4]
 800a588:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800a58a:	9b03      	ldr	r3, [sp, #12]
 800a58c:	431a      	orrs	r2, r3
 800a58e:	9b01      	ldr	r3, [sp, #4]
 800a590:	635a      	str	r2, [r3, #52]	; 0x34
}
 800a592:	b004      	add	sp, #16
 800a594:	4770      	bx	lr
 800a596:	bf00      	nop
 800a598:	f3af 8000 	nop.w
 800a59c:	f3af 8000 	nop.w

0800a5a0 <sdc_lld_error_cleanup>:
 *
 * @notapi
 */
static void sdc_lld_error_cleanup(SDCDriver *sdcp,
                                  uint32_t n,
                                  uint32_t *resp) {
 800a5a0:	b500      	push	{lr}
 800a5a2:	b087      	sub	sp, #28
 800a5a4:	9003      	str	r0, [sp, #12]
 800a5a6:	9102      	str	r1, [sp, #8]
 800a5a8:	9201      	str	r2, [sp, #4]
  uint32_t sta = sdcp->sdmmc->STA;
 800a5aa:	9b03      	ldr	r3, [sp, #12]
 800a5ac:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a5ae:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a5b0:	9305      	str	r3, [sp, #20]

  dmaStreamDisable(sdcp->dma);
 800a5b2:	9b03      	ldr	r3, [sp, #12]
 800a5b4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a5b6:	685b      	ldr	r3, [r3, #4]
 800a5b8:	9a03      	ldr	r2, [sp, #12]
 800a5ba:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800a5bc:	6852      	ldr	r2, [r2, #4]
 800a5be:	6812      	ldr	r2, [r2, #0]
 800a5c0:	f022 020f 	bic.w	r2, r2, #15
 800a5c4:	601a      	str	r2, [r3, #0]
 800a5c6:	9b03      	ldr	r3, [sp, #12]
 800a5c8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a5ca:	681b      	ldr	r3, [r3, #0]
 800a5cc:	9a03      	ldr	r2, [sp, #12]
 800a5ce:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800a5d0:	7c12      	ldrb	r2, [r2, #16]
 800a5d2:	210f      	movs	r1, #15
 800a5d4:	fa01 f202 	lsl.w	r2, r1, r2
 800a5d8:	605a      	str	r2, [r3, #4]
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 800a5da:	9b03      	ldr	r3, [sp, #12]
 800a5dc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a5de:	4a0d      	ldr	r2, [pc, #52]	; (800a614 <sdc_lld_error_cleanup+0x74>)
 800a5e0:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdmmc->MASK  = 0;
 800a5e2:	9b03      	ldr	r3, [sp, #12]
 800a5e4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a5e6:	2200      	movs	r2, #0
 800a5e8:	63da      	str	r2, [r3, #60]	; 0x3c
  sdcp->sdmmc->DCTRL = 0;
 800a5ea:	9b03      	ldr	r3, [sp, #12]
 800a5ec:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a5ee:	2200      	movs	r2, #0
 800a5f0:	62da      	str	r2, [r3, #44]	; 0x2c
  sdc_lld_collect_errors(sdcp, sta);
 800a5f2:	9803      	ldr	r0, [sp, #12]
 800a5f4:	9905      	ldr	r1, [sp, #20]
 800a5f6:	f7ff ff8b 	bl	800a510 <sdc_lld_collect_errors>

  if (n > 1)
 800a5fa:	9b02      	ldr	r3, [sp, #8]
 800a5fc:	2b01      	cmp	r3, #1
 800a5fe:	d905      	bls.n	800a60c <sdc_lld_error_cleanup+0x6c>
    sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_STOP_TRANSMISSION, 0, resp);
 800a600:	9803      	ldr	r0, [sp, #12]
 800a602:	210c      	movs	r1, #12
 800a604:	2200      	movs	r2, #0
 800a606:	9b01      	ldr	r3, [sp, #4]
 800a608:	f000 f97a 	bl	800a900 <sdc_lld_send_cmd_short_crc>
}
 800a60c:	b007      	add	sp, #28
 800a60e:	f85d fb04 	ldr.w	pc, [sp], #4
 800a612:	bf00      	nop
 800a614:	004005ff 	.word	0x004005ff
 800a618:	f3af 8000 	nop.w
 800a61c:	f3af 8000 	nop.w

0800a620 <Vector104>:
 * @details It just wakes transaction thread. All error  handling performs in
 *          that thread.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SDMMC1_HANDLER) {
 800a620:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  osalSysLockFromISR();
 800a622:	f7ff fdf5 	bl	800a210 <osalSysLockFromISR>

  /* Disables the source but the status flags are not reset because the
     read/write functions needs to check them.*/
  SDMMC1->MASK = 0;
 800a626:	4b06      	ldr	r3, [pc, #24]	; (800a640 <Vector104+0x20>)
 800a628:	2200      	movs	r2, #0
 800a62a:	63da      	str	r2, [r3, #60]	; 0x3c

  osalThreadResumeI(&SDCD1.thread, MSG_OK);
 800a62c:	4805      	ldr	r0, [pc, #20]	; (800a644 <Vector104+0x24>)
 800a62e:	2100      	movs	r1, #0
 800a630:	f7ff fe1e 	bl	800a270 <osalThreadResumeI>

  osalSysUnlockFromISR();
 800a634:	f7ff fdf4 	bl	800a220 <osalSysUnlockFromISR>

  OSAL_IRQ_EPILOGUE();
 800a638:	f7f9 fa8a 	bl	8003b50 <_port_irq_epilogue>
}
 800a63c:	bd08      	pop	{r3, pc}
 800a63e:	bf00      	nop
 800a640:	40012800 	.word	0x40012800
 800a644:	20001ab0 	.word	0x20001ab0
 800a648:	f3af 8000 	nop.w
 800a64c:	f3af 8000 	nop.w

0800a650 <sdc_lld_init>:
/**
 * @brief   Low level SDC driver initialization.
 *
 * @notapi
 */
void sdc_lld_init(void) {
 800a650:	b508      	push	{r3, lr}

  sdcObjectInit(&SDCD1);
 800a652:	4806      	ldr	r0, [pc, #24]	; (800a66c <sdc_lld_init+0x1c>)
 800a654:	f7fb fa14 	bl	8005a80 <sdcObjectInit>
  SDCD1.thread = NULL;
 800a658:	4b04      	ldr	r3, [pc, #16]	; (800a66c <sdc_lld_init+0x1c>)
 800a65a:	2200      	movs	r2, #0
 800a65c:	63da      	str	r2, [r3, #60]	; 0x3c
  SDCD1.dma    = STM32_DMA_STREAM(STM32_SDC_SDMMC1_DMA_STREAM);
 800a65e:	4b03      	ldr	r3, [pc, #12]	; (800a66c <sdc_lld_init+0x1c>)
 800a660:	4a03      	ldr	r2, [pc, #12]	; (800a670 <sdc_lld_init+0x20>)
 800a662:	645a      	str	r2, [r3, #68]	; 0x44
  SDCD1.sdmmc  = SDMMC1;
 800a664:	4b01      	ldr	r3, [pc, #4]	; (800a66c <sdc_lld_init+0x1c>)
 800a666:	4a03      	ldr	r2, [pc, #12]	; (800a674 <sdc_lld_init+0x24>)
 800a668:	649a      	str	r2, [r3, #72]	; 0x48
}
 800a66a:	bd08      	pop	{r3, pc}
 800a66c:	20001a74 	.word	0x20001a74
 800a670:	08017938 	.word	0x08017938
 800a674:	40012800 	.word	0x40012800
 800a678:	f3af 8000 	nop.w
 800a67c:	f3af 8000 	nop.w

0800a680 <sdc_lld_start>:
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 *
 * @notapi
 */
void sdc_lld_start(SDCDriver *sdcp) {
 800a680:	b500      	push	{lr}
 800a682:	b085      	sub	sp, #20
 800a684:	9001      	str	r0, [sp, #4]

  /* Checking configuration, using a default if NULL has been passed.*/
  if (sdcp->config == NULL) {
 800a686:	9b01      	ldr	r3, [sp, #4]
 800a688:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a68a:	2b00      	cmp	r3, #0
 800a68c:	d102      	bne.n	800a694 <sdc_lld_start+0x14>
    sdcp->config = &sdc_default_cfg;
 800a68e:	9b01      	ldr	r3, [sp, #4]
 800a690:	4a1b      	ldr	r2, [pc, #108]	; (800a700 <sdc_lld_start+0x80>)
 800a692:	62da      	str	r2, [r3, #44]	; 0x2c
  }

  sdcp->dmamode = STM32_DMA_CR_CHSEL(DMA_CHANNEL) |
 800a694:	9b01      	ldr	r3, [sp, #4]
 800a696:	4a1b      	ldr	r2, [pc, #108]	; (800a704 <sdc_lld_start+0x84>)
 800a698:	641a      	str	r2, [r3, #64]	; 0x40
  sdcp->dmamode |= STM32_DMA_CR_PFCTRL |
                   STM32_DMA_CR_PBURST_INCR4 |
                   STM32_DMA_CR_MBURST_INCR4;
#endif

  if (sdcp->state == BLK_STOP) {
 800a69a:	9b01      	ldr	r3, [sp, #4]
 800a69c:	791b      	ldrb	r3, [r3, #4]
 800a69e:	2b01      	cmp	r3, #1
 800a6a0:	d11b      	bne.n	800a6da <sdc_lld_start+0x5a>
    /* Note, the DMA must be enabled before the IRQs.*/
    bool b;
    b = dmaStreamAllocate(sdcp->dma, STM32_SDC_SDMMC1_IRQ_PRIORITY, NULL, NULL);
 800a6a2:	9b01      	ldr	r3, [sp, #4]
 800a6a4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a6a6:	4618      	mov	r0, r3
 800a6a8:	2109      	movs	r1, #9
 800a6aa:	2200      	movs	r2, #0
 800a6ac:	2300      	movs	r3, #0
 800a6ae:	f7fd fb5f 	bl	8007d70 <dmaStreamAllocate>
 800a6b2:	4603      	mov	r3, r0
 800a6b4:	f88d 300f 	strb.w	r3, [sp, #15]
    osalDbgAssert(!b, "stream already allocated");
    dmaStreamSetPeripheral(sdcp->dma, &sdcp->sdmmc->FIFO);
 800a6b8:	9b01      	ldr	r3, [sp, #4]
 800a6ba:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a6bc:	685b      	ldr	r3, [r3, #4]
 800a6be:	9a01      	ldr	r2, [sp, #4]
 800a6c0:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800a6c2:	3280      	adds	r2, #128	; 0x80
 800a6c4:	609a      	str	r2, [r3, #8]
#if STM32_DMA_ADVANCED
    dmaStreamSetFIFO(sdcp->dma, STM32_DMA_FCR_DMDIS | STM32_DMA_FCR_FTH_FULL);
#endif
    nvicEnableVector(STM32_SDMMC1_NUMBER, STM32_SDC_SDMMC1_IRQ_PRIORITY);
 800a6c6:	2031      	movs	r0, #49	; 0x31
 800a6c8:	2109      	movs	r1, #9
 800a6ca:	f7fc fe31 	bl	8007330 <nvicEnableVector>
    rccEnableSDMMC1(FALSE);
 800a6ce:	4b0e      	ldr	r3, [pc, #56]	; (800a708 <sdc_lld_start+0x88>)
 800a6d0:	4a0d      	ldr	r2, [pc, #52]	; (800a708 <sdc_lld_start+0x88>)
 800a6d2:	6e12      	ldr	r2, [r2, #96]	; 0x60
 800a6d4:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800a6d8:	661a      	str	r2, [r3, #96]	; 0x60
  }

  /* Configuration, card clock is initially stopped.*/
  sdcp->sdmmc->POWER  = 0;
 800a6da:	9b01      	ldr	r3, [sp, #4]
 800a6dc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a6de:	2200      	movs	r2, #0
 800a6e0:	601a      	str	r2, [r3, #0]
  sdcp->sdmmc->CLKCR  = 0;
 800a6e2:	9b01      	ldr	r3, [sp, #4]
 800a6e4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a6e6:	2200      	movs	r2, #0
 800a6e8:	605a      	str	r2, [r3, #4]
  sdcp->sdmmc->DCTRL  = 0;
 800a6ea:	9b01      	ldr	r3, [sp, #4]
 800a6ec:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a6ee:	2200      	movs	r2, #0
 800a6f0:	62da      	str	r2, [r3, #44]	; 0x2c
  sdcp->sdmmc->DTIMER = 0;
 800a6f2:	9b01      	ldr	r3, [sp, #4]
 800a6f4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a6f6:	2200      	movs	r2, #0
 800a6f8:	625a      	str	r2, [r3, #36]	; 0x24
}
 800a6fa:	b005      	add	sp, #20
 800a6fc:	f85d fb04 	ldr.w	pc, [sp], #4
 800a700:	080179d0 	.word	0x080179d0
 800a704:	00073a80 	.word	0x00073a80
 800a708:	40021000 	.word	0x40021000
 800a70c:	f3af 8000 	nop.w

0800a710 <sdc_lld_stop>:
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 *
 * @notapi
 */
void sdc_lld_stop(SDCDriver *sdcp) {
 800a710:	b500      	push	{lr}
 800a712:	b083      	sub	sp, #12
 800a714:	9001      	str	r0, [sp, #4]

  if (sdcp->state != BLK_STOP) {
 800a716:	9b01      	ldr	r3, [sp, #4]
 800a718:	791b      	ldrb	r3, [r3, #4]
 800a71a:	2b01      	cmp	r3, #1
 800a71c:	d01d      	beq.n	800a75a <sdc_lld_stop+0x4a>

    /* SDIO deactivation.*/
    sdcp->sdmmc->POWER  = 0;
 800a71e:	9b01      	ldr	r3, [sp, #4]
 800a720:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a722:	2200      	movs	r2, #0
 800a724:	601a      	str	r2, [r3, #0]
    sdcp->sdmmc->CLKCR  = 0;
 800a726:	9b01      	ldr	r3, [sp, #4]
 800a728:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a72a:	2200      	movs	r2, #0
 800a72c:	605a      	str	r2, [r3, #4]
    sdcp->sdmmc->DCTRL  = 0;
 800a72e:	9b01      	ldr	r3, [sp, #4]
 800a730:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a732:	2200      	movs	r2, #0
 800a734:	62da      	str	r2, [r3, #44]	; 0x2c
    sdcp->sdmmc->DTIMER = 0;
 800a736:	9b01      	ldr	r3, [sp, #4]
 800a738:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a73a:	2200      	movs	r2, #0
 800a73c:	625a      	str	r2, [r3, #36]	; 0x24

    /* Clock deactivation.*/
    nvicDisableVector(STM32_SDMMC1_NUMBER);
 800a73e:	2031      	movs	r0, #49	; 0x31
 800a740:	f7fc fe1e 	bl	8007380 <nvicDisableVector>
    dmaStreamRelease(sdcp->dma);
 800a744:	9b01      	ldr	r3, [sp, #4]
 800a746:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a748:	4618      	mov	r0, r3
 800a74a:	f7fd fb81 	bl	8007e50 <dmaStreamRelease>
    rccDisableSDMMC1(FALSE);
 800a74e:	4b04      	ldr	r3, [pc, #16]	; (800a760 <sdc_lld_stop+0x50>)
 800a750:	4a03      	ldr	r2, [pc, #12]	; (800a760 <sdc_lld_stop+0x50>)
 800a752:	6e12      	ldr	r2, [r2, #96]	; 0x60
 800a754:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800a758:	661a      	str	r2, [r3, #96]	; 0x60
  }
}
 800a75a:	b003      	add	sp, #12
 800a75c:	f85d fb04 	ldr.w	pc, [sp], #4
 800a760:	40021000 	.word	0x40021000
 800a764:	f3af 8000 	nop.w
 800a768:	f3af 8000 	nop.w
 800a76c:	f3af 8000 	nop.w

0800a770 <sdc_lld_start_clk>:
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 *
 * @notapi
 */
void sdc_lld_start_clk(SDCDriver *sdcp) {
 800a770:	b500      	push	{lr}
 800a772:	b083      	sub	sp, #12
 800a774:	9001      	str	r0, [sp, #4]

  /* Initial clock setting: 400kHz, 1bit mode.*/
  sdcp->sdmmc->CLKCR  = SDMMC_CLKDIV_LS;
 800a776:	9b01      	ldr	r3, [sp, #4]
 800a778:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a77a:	2276      	movs	r2, #118	; 0x76
 800a77c:	605a      	str	r2, [r3, #4]
  sdcp->sdmmc->POWER |= SDMMC_POWER_PWRCTRL_0 | SDMMC_POWER_PWRCTRL_1;
 800a77e:	9b01      	ldr	r3, [sp, #4]
 800a780:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a782:	9a01      	ldr	r2, [sp, #4]
 800a784:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800a786:	6812      	ldr	r2, [r2, #0]
 800a788:	f042 0203 	orr.w	r2, r2, #3
 800a78c:	601a      	str	r2, [r3, #0]
  sdcp->sdmmc->CLKCR |= SDMMC_CLKCR_CLKEN;
 800a78e:	9b01      	ldr	r3, [sp, #4]
 800a790:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a792:	9a01      	ldr	r2, [sp, #4]
 800a794:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800a796:	6852      	ldr	r2, [r2, #4]
 800a798:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800a79c:	605a      	str	r2, [r3, #4]

  /* Clock activation delay.*/
  osalThreadSleep(OSAL_MS2ST(STM32_SDC_SDMMC_CLOCK_DELAY));
 800a79e:	200a      	movs	r0, #10
 800a7a0:	f7ff fd46 	bl	800a230 <osalThreadSleep>
}
 800a7a4:	b003      	add	sp, #12
 800a7a6:	f85d fb04 	ldr.w	pc, [sp], #4
 800a7aa:	bf00      	nop
 800a7ac:	f3af 8000 	nop.w

0800a7b0 <sdc_lld_set_data_clk>:
 * @param[in] sdcp      pointer to the @p SDCDriver object
 * @param[in] clk       the clock mode
 *
 * @notapi
 */
void sdc_lld_set_data_clk(SDCDriver *sdcp, sdcbusclk_t clk) {
 800a7b0:	b082      	sub	sp, #8
 800a7b2:	9001      	str	r0, [sp, #4]
 800a7b4:	460b      	mov	r3, r1
 800a7b6:	f88d 3003 	strb.w	r3, [sp, #3]
  else
    sdcp->sdmmc->CLKCR = (sdcp->sdmmc->CLKCR & 0xFFFFFF00U) | SDMMC_CLKDIV_HS;
#else
  (void)clk;

  sdcp->sdmmc->CLKCR = (sdcp->sdmmc->CLKCR & 0xFFFFFF00U) | SDMMC_CLKDIV_HS;
 800a7ba:	9b01      	ldr	r3, [sp, #4]
 800a7bc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a7be:	9a01      	ldr	r2, [sp, #4]
 800a7c0:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800a7c2:	6852      	ldr	r2, [r2, #4]
 800a7c4:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 800a7c8:	605a      	str	r2, [r3, #4]
#endif
}
 800a7ca:	b002      	add	sp, #8
 800a7cc:	4770      	bx	lr
 800a7ce:	bf00      	nop

0800a7d0 <sdc_lld_stop_clk>:
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 *
 * @notapi
 */
void sdc_lld_stop_clk(SDCDriver *sdcp) {
 800a7d0:	b082      	sub	sp, #8
 800a7d2:	9001      	str	r0, [sp, #4]

  sdcp->sdmmc->CLKCR = 0;
 800a7d4:	9b01      	ldr	r3, [sp, #4]
 800a7d6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a7d8:	2200      	movs	r2, #0
 800a7da:	605a      	str	r2, [r3, #4]
  sdcp->sdmmc->POWER = 0;
 800a7dc:	9b01      	ldr	r3, [sp, #4]
 800a7de:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a7e0:	2200      	movs	r2, #0
 800a7e2:	601a      	str	r2, [r3, #0]
}
 800a7e4:	b002      	add	sp, #8
 800a7e6:	4770      	bx	lr
 800a7e8:	f3af 8000 	nop.w
 800a7ec:	f3af 8000 	nop.w

0800a7f0 <sdc_lld_set_bus_mode>:
 * @param[in] sdcp      pointer to the @p SDCDriver object
 * @param[in] mode      bus mode
 *
 * @notapi
 */
void sdc_lld_set_bus_mode(SDCDriver *sdcp, sdcbusmode_t mode) {
 800a7f0:	b084      	sub	sp, #16
 800a7f2:	9001      	str	r0, [sp, #4]
 800a7f4:	460b      	mov	r3, r1
 800a7f6:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t clk = sdcp->sdmmc->CLKCR & ~SDMMC_CLKCR_WIDBUS;
 800a7fa:	9b01      	ldr	r3, [sp, #4]
 800a7fc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a7fe:	685b      	ldr	r3, [r3, #4]
 800a800:	f423 53c0 	bic.w	r3, r3, #6144	; 0x1800
 800a804:	9303      	str	r3, [sp, #12]

  switch (mode) {
 800a806:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800a80a:	2b01      	cmp	r3, #1
 800a80c:	d008      	beq.n	800a820 <sdc_lld_set_bus_mode+0x30>
 800a80e:	2b02      	cmp	r3, #2
 800a810:	d00d      	beq.n	800a82e <sdc_lld_set_bus_mode+0x3e>
 800a812:	2b00      	cmp	r3, #0
 800a814:	d112      	bne.n	800a83c <sdc_lld_set_bus_mode+0x4c>
  case SDC_MODE_1BIT:
    sdcp->sdmmc->CLKCR = clk;
 800a816:	9b01      	ldr	r3, [sp, #4]
 800a818:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a81a:	9a03      	ldr	r2, [sp, #12]
 800a81c:	605a      	str	r2, [r3, #4]
    break;
 800a81e:	e00d      	b.n	800a83c <sdc_lld_set_bus_mode+0x4c>
  case SDC_MODE_4BIT:
    sdcp->sdmmc->CLKCR = clk | SDMMC_CLKCR_WIDBUS_0;
 800a820:	9b01      	ldr	r3, [sp, #4]
 800a822:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a824:	9a03      	ldr	r2, [sp, #12]
 800a826:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800a82a:	605a      	str	r2, [r3, #4]
    break;
 800a82c:	e006      	b.n	800a83c <sdc_lld_set_bus_mode+0x4c>
  case SDC_MODE_8BIT:
    sdcp->sdmmc->CLKCR = clk | SDMMC_CLKCR_WIDBUS_1;
 800a82e:	9b01      	ldr	r3, [sp, #4]
 800a830:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a832:	9a03      	ldr	r2, [sp, #12]
 800a834:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800a838:	605a      	str	r2, [r3, #4]
    break;
 800a83a:	bf00      	nop
  }
}
 800a83c:	b004      	add	sp, #16
 800a83e:	4770      	bx	lr

0800a840 <sdc_lld_send_cmd_none>:
 * @param[in] cmd       card command
 * @param[in] arg       command argument
 *
 * @notapi
 */
void sdc_lld_send_cmd_none(SDCDriver *sdcp, uint8_t cmd, uint32_t arg) {
 800a840:	b084      	sub	sp, #16
 800a842:	9003      	str	r0, [sp, #12]
 800a844:	460b      	mov	r3, r1
 800a846:	9201      	str	r2, [sp, #4]
 800a848:	f88d 300b 	strb.w	r3, [sp, #11]

  sdcp->sdmmc->ARG = arg;
 800a84c:	9b03      	ldr	r3, [sp, #12]
 800a84e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a850:	9a01      	ldr	r2, [sp, #4]
 800a852:	609a      	str	r2, [r3, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_CPSMEN;
 800a854:	9b03      	ldr	r3, [sp, #12]
 800a856:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a858:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800a85c:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800a860:	60da      	str	r2, [r3, #12]
  while ((sdcp->sdmmc->STA & SDMMC_STA_CMDSENT) == 0)
 800a862:	bf00      	nop
 800a864:	9b03      	ldr	r3, [sp, #12]
 800a866:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a868:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a86a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800a86e:	2b00      	cmp	r3, #0
 800a870:	d0f8      	beq.n	800a864 <sdc_lld_send_cmd_none+0x24>
    ;
  sdcp->sdmmc->ICR = SDMMC_ICR_CMDSENTC;
 800a872:	9b03      	ldr	r3, [sp, #12]
 800a874:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a876:	2280      	movs	r2, #128	; 0x80
 800a878:	639a      	str	r2, [r3, #56]	; 0x38
}
 800a87a:	b004      	add	sp, #16
 800a87c:	4770      	bx	lr
 800a87e:	bf00      	nop

0800a880 <sdc_lld_send_cmd_short>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_send_cmd_short(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                            uint32_t *resp) {
 800a880:	b500      	push	{lr}
 800a882:	b087      	sub	sp, #28
 800a884:	9003      	str	r0, [sp, #12]
 800a886:	9201      	str	r2, [sp, #4]
 800a888:	9300      	str	r3, [sp, #0]
 800a88a:	460b      	mov	r3, r1
 800a88c:	f88d 300b 	strb.w	r3, [sp, #11]
  uint32_t sta;

  sdcp->sdmmc->ARG = arg;
 800a890:	9b03      	ldr	r3, [sp, #12]
 800a892:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a894:	9a01      	ldr	r2, [sp, #4]
 800a896:	609a      	str	r2, [r3, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 800a898:	9b03      	ldr	r3, [sp, #12]
 800a89a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a89c:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800a8a0:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800a8a4:	b2d2      	uxtb	r2, r2
 800a8a6:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800a8aa:	60da      	str	r2, [r3, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800a8ac:	bf00      	nop
 800a8ae:	9b03      	ldr	r3, [sp, #12]
 800a8b0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a8b2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a8b4:	9305      	str	r3, [sp, #20]
 800a8b6:	9b05      	ldr	r3, [sp, #20]
 800a8b8:	f003 0345 	and.w	r3, r3, #69	; 0x45
 800a8bc:	2b00      	cmp	r3, #0
 800a8be:	d0f6      	beq.n	800a8ae <sdc_lld_send_cmd_short+0x2e>
                                     SDMMC_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800a8c0:	9b03      	ldr	r3, [sp, #12]
 800a8c2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a8c4:	9a05      	ldr	r2, [sp, #20]
 800a8c6:	f002 0245 	and.w	r2, r2, #69	; 0x45
 800a8ca:	639a      	str	r2, [r3, #56]	; 0x38
                           SDMMC_STA_CCRCFAIL);
  if ((sta & (SDMMC_STA_CTIMEOUT)) != 0) {
 800a8cc:	9b05      	ldr	r3, [sp, #20]
 800a8ce:	f003 0304 	and.w	r3, r3, #4
 800a8d2:	2b00      	cmp	r3, #0
 800a8d4:	d005      	beq.n	800a8e2 <sdc_lld_send_cmd_short+0x62>
    sdc_lld_collect_errors(sdcp, sta);
 800a8d6:	9803      	ldr	r0, [sp, #12]
 800a8d8:	9905      	ldr	r1, [sp, #20]
 800a8da:	f7ff fe19 	bl	800a510 <sdc_lld_collect_errors>
    return HAL_FAILED;
 800a8de:	2301      	movs	r3, #1
 800a8e0:	e005      	b.n	800a8ee <sdc_lld_send_cmd_short+0x6e>
  }
  *resp = sdcp->sdmmc->RESP1;
 800a8e2:	9b03      	ldr	r3, [sp, #12]
 800a8e4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a8e6:	695a      	ldr	r2, [r3, #20]
 800a8e8:	9b00      	ldr	r3, [sp, #0]
 800a8ea:	601a      	str	r2, [r3, #0]
  return HAL_SUCCESS;
 800a8ec:	2300      	movs	r3, #0
}
 800a8ee:	4618      	mov	r0, r3
 800a8f0:	b007      	add	sp, #28
 800a8f2:	f85d fb04 	ldr.w	pc, [sp], #4
 800a8f6:	bf00      	nop
 800a8f8:	f3af 8000 	nop.w
 800a8fc:	f3af 8000 	nop.w

0800a900 <sdc_lld_send_cmd_short_crc>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_send_cmd_short_crc(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                                uint32_t *resp) {
 800a900:	b500      	push	{lr}
 800a902:	b087      	sub	sp, #28
 800a904:	9003      	str	r0, [sp, #12]
 800a906:	9201      	str	r2, [sp, #4]
 800a908:	9300      	str	r3, [sp, #0]
 800a90a:	460b      	mov	r3, r1
 800a90c:	f88d 300b 	strb.w	r3, [sp, #11]
  uint32_t sta;

  sdcp->sdmmc->ARG = arg;
 800a910:	9b03      	ldr	r3, [sp, #12]
 800a912:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a914:	9a01      	ldr	r2, [sp, #4]
 800a916:	609a      	str	r2, [r3, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 800a918:	9b03      	ldr	r3, [sp, #12]
 800a91a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a91c:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800a920:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800a924:	b2d2      	uxtb	r2, r2
 800a926:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800a92a:	60da      	str	r2, [r3, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800a92c:	bf00      	nop
 800a92e:	9b03      	ldr	r3, [sp, #12]
 800a930:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a932:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a934:	9305      	str	r3, [sp, #20]
 800a936:	9b05      	ldr	r3, [sp, #20]
 800a938:	f003 0345 	and.w	r3, r3, #69	; 0x45
 800a93c:	2b00      	cmp	r3, #0
 800a93e:	d0f6      	beq.n	800a92e <sdc_lld_send_cmd_short_crc+0x2e>
                                     SDMMC_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL);
 800a940:	9b03      	ldr	r3, [sp, #12]
 800a942:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a944:	9a05      	ldr	r2, [sp, #20]
 800a946:	f002 0245 	and.w	r2, r2, #69	; 0x45
 800a94a:	639a      	str	r2, [r3, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 800a94c:	9b05      	ldr	r3, [sp, #20]
 800a94e:	f003 0305 	and.w	r3, r3, #5
 800a952:	2b00      	cmp	r3, #0
 800a954:	d005      	beq.n	800a962 <sdc_lld_send_cmd_short_crc+0x62>
    sdc_lld_collect_errors(sdcp, sta);
 800a956:	9803      	ldr	r0, [sp, #12]
 800a958:	9905      	ldr	r1, [sp, #20]
 800a95a:	f7ff fdd9 	bl	800a510 <sdc_lld_collect_errors>
    return HAL_FAILED;
 800a95e:	2301      	movs	r3, #1
 800a960:	e005      	b.n	800a96e <sdc_lld_send_cmd_short_crc+0x6e>
  }
  *resp = sdcp->sdmmc->RESP1;
 800a962:	9b03      	ldr	r3, [sp, #12]
 800a964:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a966:	695a      	ldr	r2, [r3, #20]
 800a968:	9b00      	ldr	r3, [sp, #0]
 800a96a:	601a      	str	r2, [r3, #0]
  return HAL_SUCCESS;
 800a96c:	2300      	movs	r3, #0
}
 800a96e:	4618      	mov	r0, r3
 800a970:	b007      	add	sp, #28
 800a972:	f85d fb04 	ldr.w	pc, [sp], #4
 800a976:	bf00      	nop
 800a978:	f3af 8000 	nop.w
 800a97c:	f3af 8000 	nop.w

0800a980 <sdc_lld_send_cmd_long_crc>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_send_cmd_long_crc(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                               uint32_t *resp) {
 800a980:	b500      	push	{lr}
 800a982:	b087      	sub	sp, #28
 800a984:	9003      	str	r0, [sp, #12]
 800a986:	9201      	str	r2, [sp, #4]
 800a988:	9300      	str	r3, [sp, #0]
 800a98a:	460b      	mov	r3, r1
 800a98c:	f88d 300b 	strb.w	r3, [sp, #11]
  uint32_t sta;

  (void)sdcp;

  sdcp->sdmmc->ARG = arg;
 800a990:	9b03      	ldr	r3, [sp, #12]
 800a992:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a994:	9a01      	ldr	r2, [sp, #4]
 800a996:	609a      	str	r2, [r3, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_WAITRESP_1 |
 800a998:	9b03      	ldr	r3, [sp, #12]
 800a99a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a99c:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800a9a0:	f062 023f 	orn	r2, r2, #63	; 0x3f
 800a9a4:	b2d2      	uxtb	r2, r2
 800a9a6:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800a9aa:	60da      	str	r2, [r3, #12]
                                    SDMMC_CMD_CPSMEN;
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800a9ac:	bf00      	nop
 800a9ae:	9b03      	ldr	r3, [sp, #12]
 800a9b0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a9b2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a9b4:	9305      	str	r3, [sp, #20]
 800a9b6:	9b05      	ldr	r3, [sp, #20]
 800a9b8:	f003 0345 	and.w	r3, r3, #69	; 0x45
 800a9bc:	2b00      	cmp	r3, #0
 800a9be:	d0f6      	beq.n	800a9ae <sdc_lld_send_cmd_long_crc+0x2e>
                                     SDMMC_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800a9c0:	9b03      	ldr	r3, [sp, #12]
 800a9c2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a9c4:	9a05      	ldr	r2, [sp, #20]
 800a9c6:	f002 0245 	and.w	r2, r2, #69	; 0x45
 800a9ca:	639a      	str	r2, [r3, #56]	; 0x38
                           SDMMC_STA_CCRCFAIL);
  if ((sta & (SDMMC_STA_ERROR_MASK)) != 0) {
 800a9cc:	9b05      	ldr	r3, [sp, #20]
 800a9ce:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800a9d2:	2b00      	cmp	r3, #0
 800a9d4:	d005      	beq.n	800a9e2 <sdc_lld_send_cmd_long_crc+0x62>
    sdc_lld_collect_errors(sdcp, sta);
 800a9d6:	9803      	ldr	r0, [sp, #12]
 800a9d8:	9905      	ldr	r1, [sp, #20]
 800a9da:	f7ff fd99 	bl	800a510 <sdc_lld_collect_errors>
    return HAL_FAILED;
 800a9de:	2301      	movs	r3, #1
 800a9e0:	e01a      	b.n	800aa18 <sdc_lld_send_cmd_long_crc+0x98>
  }
  /* Save bytes in reverse order because MSB in response comes first.*/
  *resp++ = sdcp->sdmmc->RESP4;
 800a9e2:	9b00      	ldr	r3, [sp, #0]
 800a9e4:	1d1a      	adds	r2, r3, #4
 800a9e6:	9200      	str	r2, [sp, #0]
 800a9e8:	9a03      	ldr	r2, [sp, #12]
 800a9ea:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800a9ec:	6a12      	ldr	r2, [r2, #32]
 800a9ee:	601a      	str	r2, [r3, #0]
  *resp++ = sdcp->sdmmc->RESP3;
 800a9f0:	9b00      	ldr	r3, [sp, #0]
 800a9f2:	1d1a      	adds	r2, r3, #4
 800a9f4:	9200      	str	r2, [sp, #0]
 800a9f6:	9a03      	ldr	r2, [sp, #12]
 800a9f8:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800a9fa:	69d2      	ldr	r2, [r2, #28]
 800a9fc:	601a      	str	r2, [r3, #0]
  *resp++ = sdcp->sdmmc->RESP2;
 800a9fe:	9b00      	ldr	r3, [sp, #0]
 800aa00:	1d1a      	adds	r2, r3, #4
 800aa02:	9200      	str	r2, [sp, #0]
 800aa04:	9a03      	ldr	r2, [sp, #12]
 800aa06:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800aa08:	6992      	ldr	r2, [r2, #24]
 800aa0a:	601a      	str	r2, [r3, #0]
  *resp   = sdcp->sdmmc->RESP1;
 800aa0c:	9b03      	ldr	r3, [sp, #12]
 800aa0e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800aa10:	695a      	ldr	r2, [r3, #20]
 800aa12:	9b00      	ldr	r3, [sp, #0]
 800aa14:	601a      	str	r2, [r3, #0]
  return HAL_SUCCESS;
 800aa16:	2300      	movs	r3, #0
}
 800aa18:	4618      	mov	r0, r3
 800aa1a:	b007      	add	sp, #28
 800aa1c:	f85d fb04 	ldr.w	pc, [sp], #4

0800aa20 <sdc_lld_read_special>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_read_special(SDCDriver *sdcp, uint8_t *buf, size_t bytes,
                          uint8_t cmd, uint32_t arg) {
 800aa20:	b500      	push	{lr}
 800aa22:	b087      	sub	sp, #28
 800aa24:	9003      	str	r0, [sp, #12]
 800aa26:	9102      	str	r1, [sp, #8]
 800aa28:	9201      	str	r2, [sp, #4]
 800aa2a:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t resp[1];

  if(sdc_lld_prepare_read_bytes(sdcp, buf, bytes))
 800aa2e:	9803      	ldr	r0, [sp, #12]
 800aa30:	9902      	ldr	r1, [sp, #8]
 800aa32:	9a01      	ldr	r2, [sp, #4]
 800aa34:	f7ff fc2c 	bl	800a290 <sdc_lld_prepare_read_bytes>
 800aa38:	4603      	mov	r3, r0
 800aa3a:	2b00      	cmp	r3, #0
 800aa3c:	d000      	beq.n	800aa40 <sdc_lld_read_special+0x20>
    goto error;
 800aa3e:	e01b      	b.n	800aa78 <sdc_lld_read_special+0x58>

  if (sdc_lld_send_cmd_short_crc(sdcp, cmd, arg, resp)
 800aa40:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800aa44:	ab05      	add	r3, sp, #20
 800aa46:	9803      	ldr	r0, [sp, #12]
 800aa48:	4611      	mov	r1, r2
 800aa4a:	9a08      	ldr	r2, [sp, #32]
 800aa4c:	f7ff ff58 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 800aa50:	4603      	mov	r3, r0
 800aa52:	2b00      	cmp	r3, #0
 800aa54:	d110      	bne.n	800aa78 <sdc_lld_read_special+0x58>
                                 || MMCSD_R1_ERROR(resp[0]))
 800aa56:	9a05      	ldr	r2, [sp, #20]
 800aa58:	4b0d      	ldr	r3, [pc, #52]	; (800aa90 <sdc_lld_read_special+0x70>)
 800aa5a:	4013      	ands	r3, r2
 800aa5c:	2b00      	cmp	r3, #0
 800aa5e:	d10b      	bne.n	800aa78 <sdc_lld_read_special+0x58>
    goto error;

  if (sdc_lld_wait_transaction_end(sdcp, 1, resp))
 800aa60:	ab05      	add	r3, sp, #20
 800aa62:	9803      	ldr	r0, [sp, #12]
 800aa64:	2101      	movs	r1, #1
 800aa66:	461a      	mov	r2, r3
 800aa68:	f7ff fcfa 	bl	800a460 <sdc_lld_wait_transaction_end>
 800aa6c:	4603      	mov	r3, r0
 800aa6e:	2b00      	cmp	r3, #0
 800aa70:	d000      	beq.n	800aa74 <sdc_lld_read_special+0x54>
    goto error;
 800aa72:	e001      	b.n	800aa78 <sdc_lld_read_special+0x58>

  return HAL_SUCCESS;
 800aa74:	2300      	movs	r3, #0
 800aa76:	e006      	b.n	800aa86 <sdc_lld_read_special+0x66>

error:
  sdc_lld_error_cleanup(sdcp, 1, resp);
 800aa78:	ab05      	add	r3, sp, #20
 800aa7a:	9803      	ldr	r0, [sp, #12]
 800aa7c:	2101      	movs	r1, #1
 800aa7e:	461a      	mov	r2, r3
 800aa80:	f7ff fd8e 	bl	800a5a0 <sdc_lld_error_cleanup>
  return HAL_FAILED;
 800aa84:	2301      	movs	r3, #1
}
 800aa86:	4618      	mov	r0, r3
 800aa88:	b007      	add	sp, #28
 800aa8a:	f85d fb04 	ldr.w	pc, [sp], #4
 800aa8e:	bf00      	nop
 800aa90:	fdffe008 	.word	0xfdffe008
 800aa94:	f3af 8000 	nop.w
 800aa98:	f3af 8000 	nop.w
 800aa9c:	f3af 8000 	nop.w

0800aaa0 <sdc_lld_read_aligned>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_read_aligned(SDCDriver *sdcp, uint32_t startblk,
                          uint8_t *buf, uint32_t blocks) {
 800aaa0:	b500      	push	{lr}
 800aaa2:	b087      	sub	sp, #28
 800aaa4:	9003      	str	r0, [sp, #12]
 800aaa6:	9102      	str	r1, [sp, #8]
 800aaa8:	9201      	str	r2, [sp, #4]
 800aaaa:	9300      	str	r3, [sp, #0]
  uint32_t resp[1];

  osalDbgCheck(blocks < 0x1000000 / MMCSD_BLOCK_SIZE);

  sdcp->sdmmc->DTIMER = SDMMC_READ_TIMEOUT;
 800aaac:	9b03      	ldr	r3, [sp, #12]
 800aaae:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800aab0:	4a3b      	ldr	r2, [pc, #236]	; (800aba0 <sdc_lld_read_aligned+0x100>)
 800aab2:	625a      	str	r2, [r3, #36]	; 0x24

  /* Checks for errors and waits for the card to be ready for reading.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 800aab4:	9803      	ldr	r0, [sp, #12]
 800aab6:	f7fa ffab 	bl	8005a10 <_sdc_wait_for_transfer_state>
 800aaba:	4603      	mov	r3, r0
 800aabc:	2b00      	cmp	r3, #0
 800aabe:	d001      	beq.n	800aac4 <sdc_lld_read_aligned+0x24>
    return HAL_FAILED;
 800aac0:	2301      	movs	r3, #1
 800aac2:	e069      	b.n	800ab98 <sdc_lld_read_aligned+0xf8>

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 800aac4:	9b03      	ldr	r3, [sp, #12]
 800aac6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800aac8:	685b      	ldr	r3, [r3, #4]
 800aaca:	9a01      	ldr	r2, [sp, #4]
 800aacc:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(sdcp->dma,
 800aace:	9b03      	ldr	r3, [sp, #12]
 800aad0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800aad2:	685b      	ldr	r3, [r3, #4]
 800aad4:	9a00      	ldr	r2, [sp, #0]
 800aad6:	0252      	lsls	r2, r2, #9
 800aad8:	0892      	lsrs	r2, r2, #2
 800aada:	605a      	str	r2, [r3, #4]
                              (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
 800aadc:	9b03      	ldr	r3, [sp, #12]
 800aade:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800aae0:	68db      	ldr	r3, [r3, #12]
 800aae2:	681b      	ldr	r3, [r3, #0]
 800aae4:	9305      	str	r3, [sp, #20]
 800aae6:	9b03      	ldr	r3, [sp, #12]
 800aae8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800aaea:	7c1b      	ldrb	r3, [r3, #16]
 800aaec:	220f      	movs	r2, #15
 800aaee:	fa02 f303 	lsl.w	r3, r2, r3
 800aaf2:	43db      	mvns	r3, r3
 800aaf4:	9a05      	ldr	r2, [sp, #20]
 800aaf6:	4013      	ands	r3, r2
 800aaf8:	9305      	str	r3, [sp, #20]
 800aafa:	9b03      	ldr	r3, [sp, #12]
 800aafc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800aafe:	0c1a      	lsrs	r2, r3, #16
 800ab00:	9b03      	ldr	r3, [sp, #12]
 800ab02:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ab04:	7c1b      	ldrb	r3, [r3, #16]
 800ab06:	fa02 f303 	lsl.w	r3, r2, r3
 800ab0a:	9a05      	ldr	r2, [sp, #20]
 800ab0c:	4313      	orrs	r3, r2
 800ab0e:	9305      	str	r3, [sp, #20]
 800ab10:	9b03      	ldr	r3, [sp, #12]
 800ab12:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ab14:	68db      	ldr	r3, [r3, #12]
 800ab16:	9a05      	ldr	r2, [sp, #20]
 800ab18:	601a      	str	r2, [r3, #0]
 800ab1a:	9b03      	ldr	r3, [sp, #12]
 800ab1c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ab1e:	685b      	ldr	r3, [r3, #4]
 800ab20:	9a03      	ldr	r2, [sp, #12]
 800ab22:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800ab24:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(sdcp->dma);
 800ab26:	9b03      	ldr	r3, [sp, #12]
 800ab28:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ab2a:	685b      	ldr	r3, [r3, #4]
 800ab2c:	9a03      	ldr	r2, [sp, #12]
 800ab2e:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800ab30:	6852      	ldr	r2, [r2, #4]
 800ab32:	6812      	ldr	r2, [r2, #0]
 800ab34:	f042 0201 	orr.w	r2, r2, #1
 800ab38:	601a      	str	r2, [r3, #0]

  /* Setting up data transfer.*/
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 800ab3a:	9b03      	ldr	r3, [sp, #12]
 800ab3c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ab3e:	4a19      	ldr	r2, [pc, #100]	; (800aba4 <sdc_lld_read_aligned+0x104>)
 800ab40:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdmmc->MASK  = SDMMC_MASK_DCRCFAILIE |
 800ab42:	9b03      	ldr	r3, [sp, #12]
 800ab44:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ab46:	f44f 7295 	mov.w	r2, #298	; 0x12a
 800ab4a:	63da      	str	r2, [r3, #60]	; 0x3c
                       SDMMC_MASK_DTIMEOUTIE |
                       SDMMC_MASK_RXOVERRIE |
                       SDMMC_MASK_DATAENDIE;
  sdcp->sdmmc->DLEN  = blocks * MMCSD_BLOCK_SIZE;
 800ab4c:	9b03      	ldr	r3, [sp, #12]
 800ab4e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ab50:	9a00      	ldr	r2, [sp, #0]
 800ab52:	0252      	lsls	r2, r2, #9
 800ab54:	629a      	str	r2, [r3, #40]	; 0x28

  /* Transaction starts just after DTEN bit setting.*/
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DTDIR |
 800ab56:	9b03      	ldr	r3, [sp, #12]
 800ab58:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ab5a:	229b      	movs	r2, #155	; 0x9b
 800ab5c:	62da      	str	r2, [r3, #44]	; 0x2c
                       SDMMC_DCTRL_DBLOCKSIZE_3 |
                       SDMMC_DCTRL_DBLOCKSIZE_0 |
                       SDMMC_DCTRL_DMAEN |
                       SDMMC_DCTRL_DTEN;

  if (sdc_lld_prepare_read(sdcp, startblk, blocks, resp) == TRUE)
 800ab5e:	ab04      	add	r3, sp, #16
 800ab60:	9803      	ldr	r0, [sp, #12]
 800ab62:	9902      	ldr	r1, [sp, #8]
 800ab64:	9a00      	ldr	r2, [sp, #0]
 800ab66:	f7ff fbfb 	bl	800a360 <sdc_lld_prepare_read>
 800ab6a:	4603      	mov	r3, r0
 800ab6c:	2b00      	cmp	r3, #0
 800ab6e:	d000      	beq.n	800ab72 <sdc_lld_read_aligned+0xd2>
    goto error;
 800ab70:	e00b      	b.n	800ab8a <sdc_lld_read_aligned+0xea>

  if (sdc_lld_wait_transaction_end(sdcp, blocks, resp) == TRUE)
 800ab72:	ab04      	add	r3, sp, #16
 800ab74:	9803      	ldr	r0, [sp, #12]
 800ab76:	9900      	ldr	r1, [sp, #0]
 800ab78:	461a      	mov	r2, r3
 800ab7a:	f7ff fc71 	bl	800a460 <sdc_lld_wait_transaction_end>
 800ab7e:	4603      	mov	r3, r0
 800ab80:	2b00      	cmp	r3, #0
 800ab82:	d000      	beq.n	800ab86 <sdc_lld_read_aligned+0xe6>
    goto error;
 800ab84:	e001      	b.n	800ab8a <sdc_lld_read_aligned+0xea>

  return HAL_SUCCESS;
 800ab86:	2300      	movs	r3, #0
 800ab88:	e006      	b.n	800ab98 <sdc_lld_read_aligned+0xf8>

error:
  sdc_lld_error_cleanup(sdcp, blocks, resp);
 800ab8a:	ab04      	add	r3, sp, #16
 800ab8c:	9803      	ldr	r0, [sp, #12]
 800ab8e:	9900      	ldr	r1, [sp, #0]
 800ab90:	461a      	mov	r2, r3
 800ab92:	f7ff fd05 	bl	800a5a0 <sdc_lld_error_cleanup>
  return HAL_FAILED;
 800ab96:	2301      	movs	r3, #1
}
 800ab98:	4618      	mov	r0, r3
 800ab9a:	b007      	add	sp, #28
 800ab9c:	f85d fb04 	ldr.w	pc, [sp], #4
 800aba0:	000927c0 	.word	0x000927c0
 800aba4:	004005ff 	.word	0x004005ff
 800aba8:	f3af 8000 	nop.w
 800abac:	f3af 8000 	nop.w

0800abb0 <sdc_lld_write_aligned>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_write_aligned(SDCDriver *sdcp, uint32_t startblk,
                           const uint8_t *buf, uint32_t blocks) {
 800abb0:	b500      	push	{lr}
 800abb2:	b087      	sub	sp, #28
 800abb4:	9003      	str	r0, [sp, #12]
 800abb6:	9102      	str	r1, [sp, #8]
 800abb8:	9201      	str	r2, [sp, #4]
 800abba:	9300      	str	r3, [sp, #0]
  uint32_t resp[1];

  osalDbgCheck(blocks < 0x1000000 / MMCSD_BLOCK_SIZE);

  sdcp->sdmmc->DTIMER = SDMMC_WRITE_TIMEOUT;
 800abbc:	9b03      	ldr	r3, [sp, #12]
 800abbe:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800abc0:	4a3d      	ldr	r2, [pc, #244]	; (800acb8 <sdc_lld_write_aligned+0x108>)
 800abc2:	625a      	str	r2, [r3, #36]	; 0x24

  /* Checks for errors and waits for the card to be ready for writing.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 800abc4:	9803      	ldr	r0, [sp, #12]
 800abc6:	f7fa ff23 	bl	8005a10 <_sdc_wait_for_transfer_state>
 800abca:	4603      	mov	r3, r0
 800abcc:	2b00      	cmp	r3, #0
 800abce:	d001      	beq.n	800abd4 <sdc_lld_write_aligned+0x24>
    return HAL_FAILED;
 800abd0:	2301      	movs	r3, #1
 800abd2:	e06d      	b.n	800acb0 <sdc_lld_write_aligned+0x100>

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 800abd4:	9b03      	ldr	r3, [sp, #12]
 800abd6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800abd8:	685b      	ldr	r3, [r3, #4]
 800abda:	9a01      	ldr	r2, [sp, #4]
 800abdc:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(sdcp->dma,
 800abde:	9b03      	ldr	r3, [sp, #12]
 800abe0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800abe2:	685b      	ldr	r3, [r3, #4]
 800abe4:	9a00      	ldr	r2, [sp, #0]
 800abe6:	0252      	lsls	r2, r2, #9
 800abe8:	0892      	lsrs	r2, r2, #2
 800abea:	605a      	str	r2, [r3, #4]
                             (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_M2P);
 800abec:	9b03      	ldr	r3, [sp, #12]
 800abee:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800abf0:	68db      	ldr	r3, [r3, #12]
 800abf2:	681b      	ldr	r3, [r3, #0]
 800abf4:	9305      	str	r3, [sp, #20]
 800abf6:	9b03      	ldr	r3, [sp, #12]
 800abf8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800abfa:	7c1b      	ldrb	r3, [r3, #16]
 800abfc:	220f      	movs	r2, #15
 800abfe:	fa02 f303 	lsl.w	r3, r2, r3
 800ac02:	43db      	mvns	r3, r3
 800ac04:	9a05      	ldr	r2, [sp, #20]
 800ac06:	4013      	ands	r3, r2
 800ac08:	9305      	str	r3, [sp, #20]
 800ac0a:	9b03      	ldr	r3, [sp, #12]
 800ac0c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ac0e:	f043 0310 	orr.w	r3, r3, #16
 800ac12:	0c1a      	lsrs	r2, r3, #16
 800ac14:	9b03      	ldr	r3, [sp, #12]
 800ac16:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ac18:	7c1b      	ldrb	r3, [r3, #16]
 800ac1a:	fa02 f303 	lsl.w	r3, r2, r3
 800ac1e:	9a05      	ldr	r2, [sp, #20]
 800ac20:	4313      	orrs	r3, r2
 800ac22:	9305      	str	r3, [sp, #20]
 800ac24:	9b03      	ldr	r3, [sp, #12]
 800ac26:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ac28:	68db      	ldr	r3, [r3, #12]
 800ac2a:	9a05      	ldr	r2, [sp, #20]
 800ac2c:	601a      	str	r2, [r3, #0]
 800ac2e:	9b03      	ldr	r3, [sp, #12]
 800ac30:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ac32:	685b      	ldr	r3, [r3, #4]
 800ac34:	9a03      	ldr	r2, [sp, #12]
 800ac36:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800ac38:	f042 0210 	orr.w	r2, r2, #16
 800ac3c:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(sdcp->dma);
 800ac3e:	9b03      	ldr	r3, [sp, #12]
 800ac40:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ac42:	685b      	ldr	r3, [r3, #4]
 800ac44:	9a03      	ldr	r2, [sp, #12]
 800ac46:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800ac48:	6852      	ldr	r2, [r2, #4]
 800ac4a:	6812      	ldr	r2, [r2, #0]
 800ac4c:	f042 0201 	orr.w	r2, r2, #1
 800ac50:	601a      	str	r2, [r3, #0]

  /* Setting up data transfer.*/
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 800ac52:	9b03      	ldr	r3, [sp, #12]
 800ac54:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ac56:	4a19      	ldr	r2, [pc, #100]	; (800acbc <sdc_lld_write_aligned+0x10c>)
 800ac58:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdmmc->MASK  = SDMMC_MASK_DCRCFAILIE |
 800ac5a:	9b03      	ldr	r3, [sp, #12]
 800ac5c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ac5e:	f44f 728d 	mov.w	r2, #282	; 0x11a
 800ac62:	63da      	str	r2, [r3, #60]	; 0x3c
                       SDMMC_MASK_DTIMEOUTIE |
                       SDMMC_MASK_TXUNDERRIE |
                       SDMMC_MASK_DATAENDIE;
  sdcp->sdmmc->DLEN  = blocks * MMCSD_BLOCK_SIZE;
 800ac64:	9b03      	ldr	r3, [sp, #12]
 800ac66:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ac68:	9a00      	ldr	r2, [sp, #0]
 800ac6a:	0252      	lsls	r2, r2, #9
 800ac6c:	629a      	str	r2, [r3, #40]	; 0x28

  /* Talk to card what we want from it.*/
  if (sdc_lld_prepare_write(sdcp, startblk, blocks, resp) == TRUE)
 800ac6e:	ab04      	add	r3, sp, #16
 800ac70:	9803      	ldr	r0, [sp, #12]
 800ac72:	9902      	ldr	r1, [sp, #8]
 800ac74:	9a00      	ldr	r2, [sp, #0]
 800ac76:	f7ff fbb3 	bl	800a3e0 <sdc_lld_prepare_write>
 800ac7a:	4603      	mov	r3, r0
 800ac7c:	2b00      	cmp	r3, #0
 800ac7e:	d000      	beq.n	800ac82 <sdc_lld_write_aligned+0xd2>
    goto error;
 800ac80:	e00f      	b.n	800aca2 <sdc_lld_write_aligned+0xf2>

  /* Transaction starts just after DTEN bit setting.*/
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DBLOCKSIZE_3 |
 800ac82:	9b03      	ldr	r3, [sp, #12]
 800ac84:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ac86:	2299      	movs	r2, #153	; 0x99
 800ac88:	62da      	str	r2, [r3, #44]	; 0x2c
                       SDMMC_DCTRL_DBLOCKSIZE_0 |
                       SDMMC_DCTRL_DMAEN |
                       SDMMC_DCTRL_DTEN;

  if (sdc_lld_wait_transaction_end(sdcp, blocks, resp) == TRUE)
 800ac8a:	ab04      	add	r3, sp, #16
 800ac8c:	9803      	ldr	r0, [sp, #12]
 800ac8e:	9900      	ldr	r1, [sp, #0]
 800ac90:	461a      	mov	r2, r3
 800ac92:	f7ff fbe5 	bl	800a460 <sdc_lld_wait_transaction_end>
 800ac96:	4603      	mov	r3, r0
 800ac98:	2b00      	cmp	r3, #0
 800ac9a:	d000      	beq.n	800ac9e <sdc_lld_write_aligned+0xee>
    goto error;
 800ac9c:	e001      	b.n	800aca2 <sdc_lld_write_aligned+0xf2>

  return HAL_SUCCESS;
 800ac9e:	2300      	movs	r3, #0
 800aca0:	e006      	b.n	800acb0 <sdc_lld_write_aligned+0x100>

error:
  sdc_lld_error_cleanup(sdcp, blocks, resp);
 800aca2:	ab04      	add	r3, sp, #16
 800aca4:	9803      	ldr	r0, [sp, #12]
 800aca6:	9900      	ldr	r1, [sp, #0]
 800aca8:	461a      	mov	r2, r3
 800acaa:	f7ff fc79 	bl	800a5a0 <sdc_lld_error_cleanup>
  return HAL_FAILED;
 800acae:	2301      	movs	r3, #1
}
 800acb0:	4618      	mov	r0, r3
 800acb2:	b007      	add	sp, #28
 800acb4:	f85d fb04 	ldr.w	pc, [sp], #4
 800acb8:	005b8d80 	.word	0x005b8d80
 800acbc:	004005ff 	.word	0x004005ff

0800acc0 <sdc_lld_read>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_read(SDCDriver *sdcp, uint32_t startblk,
                  uint8_t *buf, uint32_t blocks) {
 800acc0:	b500      	push	{lr}
 800acc2:	b087      	sub	sp, #28
 800acc4:	9003      	str	r0, [sp, #12]
 800acc6:	9102      	str	r1, [sp, #8]
 800acc8:	9201      	str	r2, [sp, #4]
 800acca:	9300      	str	r3, [sp, #0]

#if STM32_SDC_SDMMC_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
 800accc:	9b01      	ldr	r3, [sp, #4]
 800acce:	f003 0303 	and.w	r3, r3, #3
 800acd2:	2b00      	cmp	r3, #0
 800acd4:	d028      	beq.n	800ad28 <sdc_lld_read+0x68>
    uint32_t i;
    for (i = 0; i < blocks; i++) {
 800acd6:	2300      	movs	r3, #0
 800acd8:	9305      	str	r3, [sp, #20]
 800acda:	e01f      	b.n	800ad1c <sdc_lld_read+0x5c>
      if (sdc_lld_read_aligned(sdcp, startblk, u.buf, 1))
 800acdc:	9803      	ldr	r0, [sp, #12]
 800acde:	9902      	ldr	r1, [sp, #8]
 800ace0:	4a17      	ldr	r2, [pc, #92]	; (800ad40 <sdc_lld_read+0x80>)
 800ace2:	2301      	movs	r3, #1
 800ace4:	f7ff fedc 	bl	800aaa0 <sdc_lld_read_aligned>
 800ace8:	4603      	mov	r3, r0
 800acea:	2b00      	cmp	r3, #0
 800acec:	d001      	beq.n	800acf2 <sdc_lld_read+0x32>
        return HAL_FAILED;
 800acee:	2301      	movs	r3, #1
 800acf0:	e021      	b.n	800ad36 <sdc_lld_read+0x76>
      memcpy(buf, u.buf, MMCSD_BLOCK_SIZE);
 800acf2:	9a01      	ldr	r2, [sp, #4]
 800acf4:	4b12      	ldr	r3, [pc, #72]	; (800ad40 <sdc_lld_read+0x80>)
 800acf6:	4611      	mov	r1, r2
 800acf8:	461a      	mov	r2, r3
 800acfa:	f44f 7300 	mov.w	r3, #512	; 0x200
 800acfe:	4608      	mov	r0, r1
 800ad00:	4611      	mov	r1, r2
 800ad02:	461a      	mov	r2, r3
 800ad04:	f00c f9bc 	bl	8017080 <memcpy>
      buf += MMCSD_BLOCK_SIZE;
 800ad08:	9b01      	ldr	r3, [sp, #4]
 800ad0a:	f503 7300 	add.w	r3, r3, #512	; 0x200
 800ad0e:	9301      	str	r3, [sp, #4]
      startblk++;
 800ad10:	9b02      	ldr	r3, [sp, #8]
 800ad12:	3301      	adds	r3, #1
 800ad14:	9302      	str	r3, [sp, #8]
                  uint8_t *buf, uint32_t blocks) {

#if STM32_SDC_SDMMC_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
    uint32_t i;
    for (i = 0; i < blocks; i++) {
 800ad16:	9b05      	ldr	r3, [sp, #20]
 800ad18:	3301      	adds	r3, #1
 800ad1a:	9305      	str	r3, [sp, #20]
 800ad1c:	9a05      	ldr	r2, [sp, #20]
 800ad1e:	9b00      	ldr	r3, [sp, #0]
 800ad20:	429a      	cmp	r2, r3
 800ad22:	d3db      	bcc.n	800acdc <sdc_lld_read+0x1c>
        return HAL_FAILED;
      memcpy(buf, u.buf, MMCSD_BLOCK_SIZE);
      buf += MMCSD_BLOCK_SIZE;
      startblk++;
    }
    return HAL_SUCCESS;
 800ad24:	2300      	movs	r3, #0
 800ad26:	e006      	b.n	800ad36 <sdc_lld_read+0x76>
  }
#endif /* STM32_SDC_SDMMC_UNALIGNED_SUPPORT */
  return sdc_lld_read_aligned(sdcp, startblk, buf, blocks);
 800ad28:	9803      	ldr	r0, [sp, #12]
 800ad2a:	9902      	ldr	r1, [sp, #8]
 800ad2c:	9a01      	ldr	r2, [sp, #4]
 800ad2e:	9b00      	ldr	r3, [sp, #0]
 800ad30:	f7ff feb6 	bl	800aaa0 <sdc_lld_read_aligned>
 800ad34:	4603      	mov	r3, r0
}
 800ad36:	4618      	mov	r0, r3
 800ad38:	b007      	add	sp, #28
 800ad3a:	f85d fb04 	ldr.w	pc, [sp], #4
 800ad3e:	bf00      	nop
 800ad40:	20000d8c 	.word	0x20000d8c
 800ad44:	f3af 8000 	nop.w
 800ad48:	f3af 8000 	nop.w
 800ad4c:	f3af 8000 	nop.w

0800ad50 <sdc_lld_write>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_write(SDCDriver *sdcp, uint32_t startblk,
                   const uint8_t *buf, uint32_t blocks) {
 800ad50:	b500      	push	{lr}
 800ad52:	b087      	sub	sp, #28
 800ad54:	9003      	str	r0, [sp, #12]
 800ad56:	9102      	str	r1, [sp, #8]
 800ad58:	9201      	str	r2, [sp, #4]
 800ad5a:	9300      	str	r3, [sp, #0]

#if STM32_SDC_SDMMC_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
 800ad5c:	9b01      	ldr	r3, [sp, #4]
 800ad5e:	f003 0303 	and.w	r3, r3, #3
 800ad62:	2b00      	cmp	r3, #0
 800ad64:	d028      	beq.n	800adb8 <sdc_lld_write+0x68>
    uint32_t i;
    for (i = 0; i < blocks; i++) {
 800ad66:	2300      	movs	r3, #0
 800ad68:	9305      	str	r3, [sp, #20]
 800ad6a:	e01f      	b.n	800adac <sdc_lld_write+0x5c>
      memcpy(u.buf, buf, MMCSD_BLOCK_SIZE);
 800ad6c:	4a18      	ldr	r2, [pc, #96]	; (800add0 <sdc_lld_write+0x80>)
 800ad6e:	9b01      	ldr	r3, [sp, #4]
 800ad70:	4611      	mov	r1, r2
 800ad72:	461a      	mov	r2, r3
 800ad74:	f44f 7300 	mov.w	r3, #512	; 0x200
 800ad78:	4608      	mov	r0, r1
 800ad7a:	4611      	mov	r1, r2
 800ad7c:	461a      	mov	r2, r3
 800ad7e:	f00c f97f 	bl	8017080 <memcpy>
      buf += MMCSD_BLOCK_SIZE;
 800ad82:	9b01      	ldr	r3, [sp, #4]
 800ad84:	f503 7300 	add.w	r3, r3, #512	; 0x200
 800ad88:	9301      	str	r3, [sp, #4]
      if (sdc_lld_write_aligned(sdcp, startblk, u.buf, 1))
 800ad8a:	9803      	ldr	r0, [sp, #12]
 800ad8c:	9902      	ldr	r1, [sp, #8]
 800ad8e:	4a10      	ldr	r2, [pc, #64]	; (800add0 <sdc_lld_write+0x80>)
 800ad90:	2301      	movs	r3, #1
 800ad92:	f7ff ff0d 	bl	800abb0 <sdc_lld_write_aligned>
 800ad96:	4603      	mov	r3, r0
 800ad98:	2b00      	cmp	r3, #0
 800ad9a:	d001      	beq.n	800ada0 <sdc_lld_write+0x50>
        return HAL_FAILED;
 800ad9c:	2301      	movs	r3, #1
 800ad9e:	e012      	b.n	800adc6 <sdc_lld_write+0x76>
      startblk++;
 800ada0:	9b02      	ldr	r3, [sp, #8]
 800ada2:	3301      	adds	r3, #1
 800ada4:	9302      	str	r3, [sp, #8]
                   const uint8_t *buf, uint32_t blocks) {

#if STM32_SDC_SDMMC_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
    uint32_t i;
    for (i = 0; i < blocks; i++) {
 800ada6:	9b05      	ldr	r3, [sp, #20]
 800ada8:	3301      	adds	r3, #1
 800adaa:	9305      	str	r3, [sp, #20]
 800adac:	9a05      	ldr	r2, [sp, #20]
 800adae:	9b00      	ldr	r3, [sp, #0]
 800adb0:	429a      	cmp	r2, r3
 800adb2:	d3db      	bcc.n	800ad6c <sdc_lld_write+0x1c>
      buf += MMCSD_BLOCK_SIZE;
      if (sdc_lld_write_aligned(sdcp, startblk, u.buf, 1))
        return HAL_FAILED;
      startblk++;
    }
    return HAL_SUCCESS;
 800adb4:	2300      	movs	r3, #0
 800adb6:	e006      	b.n	800adc6 <sdc_lld_write+0x76>
  }
#endif /* STM32_SDC_SDMMC_UNALIGNED_SUPPORT */
  return sdc_lld_write_aligned(sdcp, startblk, buf, blocks);
 800adb8:	9803      	ldr	r0, [sp, #12]
 800adba:	9902      	ldr	r1, [sp, #8]
 800adbc:	9a01      	ldr	r2, [sp, #4]
 800adbe:	9b00      	ldr	r3, [sp, #0]
 800adc0:	f7ff fef6 	bl	800abb0 <sdc_lld_write_aligned>
 800adc4:	4603      	mov	r3, r0
}
 800adc6:	4618      	mov	r0, r3
 800adc8:	b007      	add	sp, #28
 800adca:	f85d fb04 	ldr.w	pc, [sp], #4
 800adce:	bf00      	nop
 800add0:	20000d8c 	.word	0x20000d8c
 800add4:	f3af 8000 	nop.w
 800add8:	f3af 8000 	nop.w
 800addc:	f3af 8000 	nop.w

0800ade0 <sdc_lld_sync>:
 * @retval HAL_SUCCESS  the operation succeeded.
 * @retval HAL_FAILED   the operation failed.
 *
 * @api
 */
bool sdc_lld_sync(SDCDriver *sdcp) {
 800ade0:	b082      	sub	sp, #8
 800ade2:	9001      	str	r0, [sp, #4]

  /* TODO: Implement.*/
  (void)sdcp;
  return HAL_SUCCESS;
 800ade4:	2300      	movs	r3, #0
}
 800ade6:	4618      	mov	r0, r3
 800ade8:	b002      	add	sp, #8
 800adea:	4770      	bx	lr
 800adec:	f3af 8000 	nop.w

0800adf0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800adf0:	b082      	sub	sp, #8
 800adf2:	2320      	movs	r3, #32
 800adf4:	9301      	str	r3, [sp, #4]
 800adf6:	9b01      	ldr	r3, [sp, #4]
 800adf8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800adfc:	b002      	add	sp, #8
 800adfe:	4770      	bx	lr

0800ae00 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800ae00:	b082      	sub	sp, #8
 800ae02:	2300      	movs	r3, #0
 800ae04:	9301      	str	r3, [sp, #4]
 800ae06:	9b01      	ldr	r3, [sp, #4]
 800ae08:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800ae0c:	b002      	add	sp, #8
 800ae0e:	4770      	bx	lr

0800ae10 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800ae10:	b508      	push	{r3, lr}

  port_lock();
 800ae12:	f7ff ffed 	bl	800adf0 <port_lock>
}
 800ae16:	bd08      	pop	{r3, pc}
 800ae18:	f3af 8000 	nop.w
 800ae1c:	f3af 8000 	nop.w

0800ae20 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800ae20:	b508      	push	{r3, lr}

  port_unlock();
 800ae22:	f7ff ffed 	bl	800ae00 <port_unlock>
}
 800ae26:	bd08      	pop	{r3, pc}
 800ae28:	f3af 8000 	nop.w
 800ae2c:	f3af 8000 	nop.w

0800ae30 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800ae30:	b508      	push	{r3, lr}

  port_lock();
 800ae32:	f7ff ffdd 	bl	800adf0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800ae36:	bd08      	pop	{r3, pc}
 800ae38:	f3af 8000 	nop.w
 800ae3c:	f3af 8000 	nop.w

0800ae40 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800ae40:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800ae42:	f7ff ffdd 	bl	800ae00 <port_unlock>
}
 800ae46:	bd08      	pop	{r3, pc}
 800ae48:	f3af 8000 	nop.w
 800ae4c:	f3af 8000 	nop.w

0800ae50 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 800ae50:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800ae52:	f7ff ffdd 	bl	800ae10 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 800ae56:	bd08      	pop	{r3, pc}
 800ae58:	f3af 8000 	nop.w
 800ae5c:	f3af 8000 	nop.w

0800ae60 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 800ae60:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 800ae62:	f7ff ffdd 	bl	800ae20 <port_unlock_from_isr>
}
 800ae66:	bd08      	pop	{r3, pc}
 800ae68:	f3af 8000 	nop.w
 800ae6c:	f3af 8000 	nop.w

0800ae70 <osalSysHalt>:
 *
 * @param[in] reason    the halt message pointer
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {
 800ae70:	b500      	push	{lr}
 800ae72:	b083      	sub	sp, #12
 800ae74:	9001      	str	r0, [sp, #4]

  chSysHalt(reason);
 800ae76:	9801      	ldr	r0, [sp, #4]
 800ae78:	f7f5 fc52 	bl	8000720 <chSysHalt>
}
 800ae7c:	b003      	add	sp, #12
 800ae7e:	f85d fb04 	ldr.w	pc, [sp], #4
 800ae82:	bf00      	nop
 800ae84:	f3af 8000 	nop.w
 800ae88:	f3af 8000 	nop.w
 800ae8c:	f3af 8000 	nop.w

0800ae90 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 800ae90:	b508      	push	{r3, lr}

  chSysLockFromISR();
 800ae92:	f7ff ffdd 	bl	800ae50 <chSysLockFromISR>
}
 800ae96:	bd08      	pop	{r3, pc}
 800ae98:	f3af 8000 	nop.w
 800ae9c:	f3af 8000 	nop.w

0800aea0 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 800aea0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 800aea2:	f7ff ffdd 	bl	800ae60 <chSysUnlockFromISR>
}
 800aea6:	bd08      	pop	{r3, pc}
 800aea8:	f3af 8000 	nop.w
 800aeac:	f3af 8000 	nop.w

0800aeb0 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 800aeb0:	b500      	push	{lr}
 800aeb2:	b083      	sub	sp, #12
 800aeb4:	9001      	str	r0, [sp, #4]
 800aeb6:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
 800aeb8:	9801      	ldr	r0, [sp, #4]
 800aeba:	9900      	ldr	r1, [sp, #0]
 800aebc:	f7f6 fb00 	bl	80014c0 <chThdResumeI>
}
 800aec0:	b003      	add	sp, #12
 800aec2:	f85d fb04 	ldr.w	pc, [sp], #4
 800aec6:	bf00      	nop
 800aec8:	f3af 8000 	nop.w
 800aecc:	f3af 8000 	nop.w

0800aed0 <spi_lld_serve_rx_interrupt>:
 * @brief   Shared end-of-rx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {
 800aed0:	b500      	push	{lr}
 800aed2:	b083      	sub	sp, #12
 800aed4:	9001      	str	r0, [sp, #4]
 800aed6:	9100      	str	r1, [sp, #0]

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800aed8:	9b00      	ldr	r3, [sp, #0]
 800aeda:	f003 0308 	and.w	r3, r3, #8
 800aede:	2b00      	cmp	r3, #0
 800aee0:	d002      	beq.n	800aee8 <spi_lld_serve_rx_interrupt+0x18>
    STM32_SPI_DMA_ERROR_HOOK(spip);
 800aee2:	4828      	ldr	r0, [pc, #160]	; (800af84 <spi_lld_serve_rx_interrupt+0xb4>)
 800aee4:	f7ff ffc4 	bl	800ae70 <osalSysHalt>
#else
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
 800aee8:	9b01      	ldr	r3, [sp, #4]
 800aeea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800aeec:	685b      	ldr	r3, [r3, #4]
 800aeee:	9a01      	ldr	r2, [sp, #4]
 800aef0:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800aef2:	6852      	ldr	r2, [r2, #4]
 800aef4:	6812      	ldr	r2, [r2, #0]
 800aef6:	f022 020f 	bic.w	r2, r2, #15
 800aefa:	601a      	str	r2, [r3, #0]
 800aefc:	9b01      	ldr	r3, [sp, #4]
 800aefe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800af00:	681b      	ldr	r3, [r3, #0]
 800af02:	9a01      	ldr	r2, [sp, #4]
 800af04:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800af06:	7c12      	ldrb	r2, [r2, #16]
 800af08:	210f      	movs	r1, #15
 800af0a:	fa01 f202 	lsl.w	r2, r1, r2
 800af0e:	605a      	str	r2, [r3, #4]
  dmaStreamDisable(spip->dmarx);
 800af10:	9b01      	ldr	r3, [sp, #4]
 800af12:	6a1b      	ldr	r3, [r3, #32]
 800af14:	685b      	ldr	r3, [r3, #4]
 800af16:	9a01      	ldr	r2, [sp, #4]
 800af18:	6a12      	ldr	r2, [r2, #32]
 800af1a:	6852      	ldr	r2, [r2, #4]
 800af1c:	6812      	ldr	r2, [r2, #0]
 800af1e:	f022 020f 	bic.w	r2, r2, #15
 800af22:	601a      	str	r2, [r3, #0]
 800af24:	9b01      	ldr	r3, [sp, #4]
 800af26:	6a1b      	ldr	r3, [r3, #32]
 800af28:	681b      	ldr	r3, [r3, #0]
 800af2a:	9a01      	ldr	r2, [sp, #4]
 800af2c:	6a12      	ldr	r2, [r2, #32]
 800af2e:	7c12      	ldrb	r2, [r2, #16]
 800af30:	210f      	movs	r1, #15
 800af32:	fa01 f202 	lsl.w	r2, r1, r2
 800af36:	605a      	str	r2, [r3, #4]

  /* Portable SPI ISR code defined in the high level driver, note, it is
     a macro.*/
  _spi_isr_code(spip);
 800af38:	9b01      	ldr	r3, [sp, #4]
 800af3a:	685b      	ldr	r3, [r3, #4]
 800af3c:	681b      	ldr	r3, [r3, #0]
 800af3e:	2b00      	cmp	r3, #0
 800af40:	d00f      	beq.n	800af62 <spi_lld_serve_rx_interrupt+0x92>
 800af42:	9b01      	ldr	r3, [sp, #4]
 800af44:	2204      	movs	r2, #4
 800af46:	701a      	strb	r2, [r3, #0]
 800af48:	9b01      	ldr	r3, [sp, #4]
 800af4a:	685b      	ldr	r3, [r3, #4]
 800af4c:	681b      	ldr	r3, [r3, #0]
 800af4e:	9801      	ldr	r0, [sp, #4]
 800af50:	4798      	blx	r3
 800af52:	9b01      	ldr	r3, [sp, #4]
 800af54:	781b      	ldrb	r3, [r3, #0]
 800af56:	2b04      	cmp	r3, #4
 800af58:	d106      	bne.n	800af68 <spi_lld_serve_rx_interrupt+0x98>
 800af5a:	9b01      	ldr	r3, [sp, #4]
 800af5c:	2202      	movs	r2, #2
 800af5e:	701a      	strb	r2, [r3, #0]
 800af60:	e002      	b.n	800af68 <spi_lld_serve_rx_interrupt+0x98>
 800af62:	9b01      	ldr	r3, [sp, #4]
 800af64:	2202      	movs	r2, #2
 800af66:	701a      	strb	r2, [r3, #0]
 800af68:	f7ff ff92 	bl	800ae90 <osalSysLockFromISR>
 800af6c:	9b01      	ldr	r3, [sp, #4]
 800af6e:	3308      	adds	r3, #8
 800af70:	4618      	mov	r0, r3
 800af72:	2100      	movs	r1, #0
 800af74:	f7ff ff9c 	bl	800aeb0 <osalThreadResumeI>
 800af78:	f7ff ff92 	bl	800aea0 <osalSysUnlockFromISR>
}
 800af7c:	b003      	add	sp, #12
 800af7e:	f85d fb04 	ldr.w	pc, [sp], #4
 800af82:	bf00      	nop
 800af84:	080179e4 	.word	0x080179e4
 800af88:	f3af 8000 	nop.w
 800af8c:	f3af 8000 	nop.w

0800af90 <spi_lld_serve_tx_interrupt>:
 * @brief   Shared end-of-tx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {
 800af90:	b500      	push	{lr}
 800af92:	b083      	sub	sp, #12
 800af94:	9001      	str	r0, [sp, #4]
 800af96:	9100      	str	r1, [sp, #0]

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  (void)spip;
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800af98:	9b00      	ldr	r3, [sp, #0]
 800af9a:	f003 0308 	and.w	r3, r3, #8
 800af9e:	2b00      	cmp	r3, #0
 800afa0:	d002      	beq.n	800afa8 <spi_lld_serve_tx_interrupt+0x18>
    STM32_SPI_DMA_ERROR_HOOK(spip);
 800afa2:	4803      	ldr	r0, [pc, #12]	; (800afb0 <spi_lld_serve_tx_interrupt+0x20>)
 800afa4:	f7ff ff64 	bl	800ae70 <osalSysHalt>
  }
#else
  (void)spip;
  (void)flags;
#endif
}
 800afa8:	b003      	add	sp, #12
 800afaa:	f85d fb04 	ldr.w	pc, [sp], #4
 800afae:	bf00      	nop
 800afb0:	080179e4 	.word	0x080179e4
 800afb4:	f3af 8000 	nop.w
 800afb8:	f3af 8000 	nop.w
 800afbc:	f3af 8000 	nop.w

0800afc0 <spi_lld_init>:
/**
 * @brief   Low level SPI driver initialization.
 *
 * @notapi
 */
void spi_lld_init(void) {
 800afc0:	b508      	push	{r3, lr}

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
 800afc2:	4812      	ldr	r0, [pc, #72]	; (800b00c <spi_lld_init+0x4c>)
 800afc4:	f7fb fa4c 	bl	8006460 <spiObjectInit>
  SPID1.spi       = SPI1;
 800afc8:	4b10      	ldr	r3, [pc, #64]	; (800b00c <spi_lld_init+0x4c>)
 800afca:	4a11      	ldr	r2, [pc, #68]	; (800b010 <spi_lld_init+0x50>)
 800afcc:	61da      	str	r2, [r3, #28]
  SPID1.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI1_RX_DMA_STREAM);
 800afce:	4b0f      	ldr	r3, [pc, #60]	; (800b00c <spi_lld_init+0x4c>)
 800afd0:	4a10      	ldr	r2, [pc, #64]	; (800b014 <spi_lld_init+0x54>)
 800afd2:	621a      	str	r2, [r3, #32]
  SPID1.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
 800afd4:	4b0d      	ldr	r3, [pc, #52]	; (800b00c <spi_lld_init+0x4c>)
 800afd6:	4a10      	ldr	r2, [pc, #64]	; (800b018 <spi_lld_init+0x58>)
 800afd8:	625a      	str	r2, [r3, #36]	; 0x24
  SPID1.rxdmamode = STM32_DMA_CR_CHSEL(SPI1_RX_DMA_CHANNEL) |
 800afda:	4b0c      	ldr	r3, [pc, #48]	; (800b00c <spi_lld_init+0x4c>)
 800afdc:	4a0f      	ldr	r2, [pc, #60]	; (800b01c <spi_lld_init+0x5c>)
 800afde:	629a      	str	r2, [r3, #40]	; 0x28
                    STM32_DMA_CR_PL(STM32_SPI_SPI1_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 800afe0:	4b0a      	ldr	r3, [pc, #40]	; (800b00c <spi_lld_init+0x4c>)
 800afe2:	4a0f      	ldr	r2, [pc, #60]	; (800b020 <spi_lld_init+0x60>)
 800afe4:	62da      	str	r2, [r3, #44]	; 0x2c
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
 800afe6:	480f      	ldr	r0, [pc, #60]	; (800b024 <spi_lld_init+0x64>)
 800afe8:	f7fb fa3a 	bl	8006460 <spiObjectInit>
  SPID2.spi       = SPI2;
 800afec:	4b0d      	ldr	r3, [pc, #52]	; (800b024 <spi_lld_init+0x64>)
 800afee:	4a0e      	ldr	r2, [pc, #56]	; (800b028 <spi_lld_init+0x68>)
 800aff0:	61da      	str	r2, [r3, #28]
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
 800aff2:	4b0c      	ldr	r3, [pc, #48]	; (800b024 <spi_lld_init+0x64>)
 800aff4:	4a0d      	ldr	r2, [pc, #52]	; (800b02c <spi_lld_init+0x6c>)
 800aff6:	621a      	str	r2, [r3, #32]
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
 800aff8:	4b0a      	ldr	r3, [pc, #40]	; (800b024 <spi_lld_init+0x64>)
 800affa:	4a0d      	ldr	r2, [pc, #52]	; (800b030 <spi_lld_init+0x70>)
 800affc:	625a      	str	r2, [r3, #36]	; 0x24
  SPID2.rxdmamode = STM32_DMA_CR_CHSEL(SPI2_RX_DMA_CHANNEL) |
 800affe:	4b09      	ldr	r3, [pc, #36]	; (800b024 <spi_lld_init+0x64>)
 800b000:	4a0c      	ldr	r2, [pc, #48]	; (800b034 <spi_lld_init+0x74>)
 800b002:	629a      	str	r2, [r3, #40]	; 0x28
                    STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_CHANNEL) |
 800b004:	4b07      	ldr	r3, [pc, #28]	; (800b024 <spi_lld_init+0x64>)
 800b006:	4a0c      	ldr	r2, [pc, #48]	; (800b038 <spi_lld_init+0x78>)
 800b008:	62da      	str	r2, [r3, #44]	; 0x2c
                    STM32_DMA_CR_PL(STM32_SPI_SPI6_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_M2P |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif
}
 800b00a:	bd08      	pop	{r3, pc}
 800b00c:	20001ac0 	.word	0x20001ac0
 800b010:	40013000 	.word	0x40013000
 800b014:	08017924 	.word	0x08017924
 800b018:	08017938 	.word	0x08017938
 800b01c:	0004100a 	.word	0x0004100a
 800b020:	00041018 	.word	0x00041018
 800b024:	20001af0 	.word	0x20001af0
 800b028:	40003800 	.word	0x40003800
 800b02c:	080178ac 	.word	0x080178ac
 800b030:	080178c0 	.word	0x080178c0
 800b034:	0001100a 	.word	0x0001100a
 800b038:	00011018 	.word	0x00011018
 800b03c:	f3af 8000 	nop.w

0800b040 <spi_lld_start>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_start(SPIDriver *spip) {
 800b040:	b500      	push	{lr}
 800b042:	b085      	sub	sp, #20
 800b044:	9001      	str	r0, [sp, #4]
  uint32_t ds;

  /* If in stopped state then enables the SPI and DMA clocks.*/
  if (spip->state == SPI_STOP) {
 800b046:	9b01      	ldr	r3, [sp, #4]
 800b048:	781b      	ldrb	r3, [r3, #0]
 800b04a:	2b01      	cmp	r3, #1
 800b04c:	d14d      	bne.n	800b0ea <spi_lld_start+0xaa>
#if STM32_SPI_USE_SPI1
    if (&SPID1 == spip) {
 800b04e:	9a01      	ldr	r2, [sp, #4]
 800b050:	4b4c      	ldr	r3, [pc, #304]	; (800b184 <spi_lld_start+0x144>)
 800b052:	429a      	cmp	r2, r3
 800b054:	d11b      	bne.n	800b08e <spi_lld_start+0x4e>
      bool b;
      b = dmaStreamAllocate(spip->dmarx,
 800b056:	9b01      	ldr	r3, [sp, #4]
 800b058:	6a1b      	ldr	r3, [r3, #32]
 800b05a:	4618      	mov	r0, r3
 800b05c:	210a      	movs	r1, #10
 800b05e:	4a4a      	ldr	r2, [pc, #296]	; (800b188 <spi_lld_start+0x148>)
 800b060:	9b01      	ldr	r3, [sp, #4]
 800b062:	f7fc fe85 	bl	8007d70 <dmaStreamAllocate>
 800b066:	4603      	mov	r3, r0
 800b068:	f88d 300f 	strb.w	r3, [sp, #15]
                            STM32_SPI_SPI1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_rx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      b = dmaStreamAllocate(spip->dmatx,
 800b06c:	9b01      	ldr	r3, [sp, #4]
 800b06e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b070:	4618      	mov	r0, r3
 800b072:	210a      	movs	r1, #10
 800b074:	4a45      	ldr	r2, [pc, #276]	; (800b18c <spi_lld_start+0x14c>)
 800b076:	9b01      	ldr	r3, [sp, #4]
 800b078:	f7fc fe7a 	bl	8007d70 <dmaStreamAllocate>
 800b07c:	4603      	mov	r3, r0
 800b07e:	f88d 300f 	strb.w	r3, [sp, #15]
                            STM32_SPI_SPI1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableSPI1(FALSE);
 800b082:	4b43      	ldr	r3, [pc, #268]	; (800b190 <spi_lld_start+0x150>)
 800b084:	4a42      	ldr	r2, [pc, #264]	; (800b190 <spi_lld_start+0x150>)
 800b086:	6e12      	ldr	r2, [r2, #96]	; 0x60
 800b088:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800b08c:	661a      	str	r2, [r3, #96]	; 0x60
    }
#endif
#if STM32_SPI_USE_SPI2
    if (&SPID2 == spip) {
 800b08e:	9a01      	ldr	r2, [sp, #4]
 800b090:	4b40      	ldr	r3, [pc, #256]	; (800b194 <spi_lld_start+0x154>)
 800b092:	429a      	cmp	r2, r3
 800b094:	d11b      	bne.n	800b0ce <spi_lld_start+0x8e>
      bool b;
      b = dmaStreamAllocate(spip->dmarx,
 800b096:	9b01      	ldr	r3, [sp, #4]
 800b098:	6a1b      	ldr	r3, [r3, #32]
 800b09a:	4618      	mov	r0, r3
 800b09c:	210a      	movs	r1, #10
 800b09e:	4a3a      	ldr	r2, [pc, #232]	; (800b188 <spi_lld_start+0x148>)
 800b0a0:	9b01      	ldr	r3, [sp, #4]
 800b0a2:	f7fc fe65 	bl	8007d70 <dmaStreamAllocate>
 800b0a6:	4603      	mov	r3, r0
 800b0a8:	f88d 300e 	strb.w	r3, [sp, #14]
                            STM32_SPI_SPI2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_rx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      b = dmaStreamAllocate(spip->dmatx,
 800b0ac:	9b01      	ldr	r3, [sp, #4]
 800b0ae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b0b0:	4618      	mov	r0, r3
 800b0b2:	210a      	movs	r1, #10
 800b0b4:	4a35      	ldr	r2, [pc, #212]	; (800b18c <spi_lld_start+0x14c>)
 800b0b6:	9b01      	ldr	r3, [sp, #4]
 800b0b8:	f7fc fe5a 	bl	8007d70 <dmaStreamAllocate>
 800b0bc:	4603      	mov	r3, r0
 800b0be:	f88d 300e 	strb.w	r3, [sp, #14]
                            STM32_SPI_SPI2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableSPI2(FALSE);
 800b0c2:	4b33      	ldr	r3, [pc, #204]	; (800b190 <spi_lld_start+0x150>)
 800b0c4:	4a32      	ldr	r2, [pc, #200]	; (800b190 <spi_lld_start+0x150>)
 800b0c6:	6d92      	ldr	r2, [r2, #88]	; 0x58
 800b0c8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800b0cc:	659a      	str	r2, [r3, #88]	; 0x58
      rccEnableSPI6(FALSE);
    }
#endif

    /* DMA setup.*/
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 800b0ce:	9b01      	ldr	r3, [sp, #4]
 800b0d0:	6a1b      	ldr	r3, [r3, #32]
 800b0d2:	685b      	ldr	r3, [r3, #4]
 800b0d4:	9a01      	ldr	r2, [sp, #4]
 800b0d6:	69d2      	ldr	r2, [r2, #28]
 800b0d8:	320c      	adds	r2, #12
 800b0da:	609a      	str	r2, [r3, #8]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 800b0dc:	9b01      	ldr	r3, [sp, #4]
 800b0de:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b0e0:	685b      	ldr	r3, [r3, #4]
 800b0e2:	9a01      	ldr	r2, [sp, #4]
 800b0e4:	69d2      	ldr	r2, [r2, #28]
 800b0e6:	320c      	adds	r2, #12
 800b0e8:	609a      	str	r2, [r3, #8]
  }

  /* Configuration-specific DMA setup.*/
  ds = spip->config->cr2 & SPI_CR2_DS;
 800b0ea:	9b01      	ldr	r3, [sp, #4]
 800b0ec:	685b      	ldr	r3, [r3, #4]
 800b0ee:	899b      	ldrh	r3, [r3, #12]
 800b0f0:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 800b0f4:	9302      	str	r3, [sp, #8]
  if (!ds || (ds <= (SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0))) {
 800b0f6:	9b02      	ldr	r3, [sp, #8]
 800b0f8:	2b00      	cmp	r3, #0
 800b0fa:	d003      	beq.n	800b104 <spi_lld_start+0xc4>
 800b0fc:	9b02      	ldr	r3, [sp, #8]
 800b0fe:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 800b102:	d80c      	bhi.n	800b11e <spi_lld_start+0xde>
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800b104:	9b01      	ldr	r3, [sp, #4]
 800b106:	6a9b      	ldr	r3, [r3, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 800b108:	f423 6270 	bic.w	r2, r3, #3840	; 0xf00

  /* Configuration-specific DMA setup.*/
  ds = spip->config->cr2 & SPI_CR2_DS;
  if (!ds || (ds <= (SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0))) {
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800b10c:	9b01      	ldr	r3, [sp, #4]
 800b10e:	629a      	str	r2, [r3, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800b110:	9b01      	ldr	r3, [sp, #4]
 800b112:	6adb      	ldr	r3, [r3, #44]	; 0x2c
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 800b114:	f423 6270 	bic.w	r2, r3, #3840	; 0xf00
  ds = spip->config->cr2 & SPI_CR2_DS;
  if (!ds || (ds <= (SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0))) {
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800b118:	9b01      	ldr	r3, [sp, #4]
 800b11a:	62da      	str	r2, [r3, #44]	; 0x2c
 800b11c:	e00f      	b.n	800b13e <spi_lld_start+0xfe>
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800b11e:	9b01      	ldr	r3, [sp, #4]
 800b120:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b122:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 800b126:	f443 62a0 	orr.w	r2, r3, #1280	; 0x500
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800b12a:	9b01      	ldr	r3, [sp, #4]
 800b12c:	629a      	str	r2, [r3, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800b12e:	9b01      	ldr	r3, [sp, #4]
 800b130:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b132:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 800b136:	f443 62a0 	orr.w	r2, r3, #1280	; 0x500
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800b13a:	9b01      	ldr	r3, [sp, #4]
 800b13c:	62da      	str	r2, [r3, #44]	; 0x2c
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
  }

  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
 800b13e:	9b01      	ldr	r3, [sp, #4]
 800b140:	69db      	ldr	r3, [r3, #28]
 800b142:	2200      	movs	r2, #0
 800b144:	601a      	str	r2, [r3, #0]
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR;
 800b146:	9b01      	ldr	r3, [sp, #4]
 800b148:	69db      	ldr	r3, [r3, #28]
 800b14a:	9a01      	ldr	r2, [sp, #4]
 800b14c:	6852      	ldr	r2, [r2, #4]
 800b14e:	8952      	ldrh	r2, [r2, #10]
 800b150:	f042 0204 	orr.w	r2, r2, #4
 800b154:	b292      	uxth	r2, r2
 800b156:	601a      	str	r2, [r3, #0]
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_FRXTH | SPI_CR2_SSOE |
 800b158:	9b01      	ldr	r3, [sp, #4]
 800b15a:	69da      	ldr	r2, [r3, #28]
 800b15c:	9b01      	ldr	r3, [sp, #4]
 800b15e:	685b      	ldr	r3, [r3, #4]
 800b160:	899b      	ldrh	r3, [r3, #12]
 800b162:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800b166:	f043 0307 	orr.w	r3, r3, #7
 800b16a:	b29b      	uxth	r3, r3
 800b16c:	6053      	str	r3, [r2, #4]
                    SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN;
  spip->spi->CR1 |= SPI_CR1_SPE;
 800b16e:	9b01      	ldr	r3, [sp, #4]
 800b170:	69db      	ldr	r3, [r3, #28]
 800b172:	9a01      	ldr	r2, [sp, #4]
 800b174:	69d2      	ldr	r2, [r2, #28]
 800b176:	6812      	ldr	r2, [r2, #0]
 800b178:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800b17c:	601a      	str	r2, [r3, #0]
}
 800b17e:	b005      	add	sp, #20
 800b180:	f85d fb04 	ldr.w	pc, [sp], #4
 800b184:	20001ac0 	.word	0x20001ac0
 800b188:	0800aed1 	.word	0x0800aed1
 800b18c:	0800af91 	.word	0x0800af91
 800b190:	40021000 	.word	0x40021000
 800b194:	20001af0 	.word	0x20001af0
 800b198:	f3af 8000 	nop.w
 800b19c:	f3af 8000 	nop.w

0800b1a0 <spi_lld_stop>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_stop(SPIDriver *spip) {
 800b1a0:	b500      	push	{lr}
 800b1a2:	b083      	sub	sp, #12
 800b1a4:	9001      	str	r0, [sp, #4]

  /* If in ready state then disables the SPI clock.*/
  if (spip->state == SPI_READY) {
 800b1a6:	9b01      	ldr	r3, [sp, #4]
 800b1a8:	781b      	ldrb	r3, [r3, #0]
 800b1aa:	2b02      	cmp	r3, #2
 800b1ac:	d125      	bne.n	800b1fa <spi_lld_stop+0x5a>

    /* SPI disable.*/
    spip->spi->CR1 = 0;
 800b1ae:	9b01      	ldr	r3, [sp, #4]
 800b1b0:	69db      	ldr	r3, [r3, #28]
 800b1b2:	2200      	movs	r2, #0
 800b1b4:	601a      	str	r2, [r3, #0]
    spip->spi->CR2 = 0;
 800b1b6:	9b01      	ldr	r3, [sp, #4]
 800b1b8:	69db      	ldr	r3, [r3, #28]
 800b1ba:	2200      	movs	r2, #0
 800b1bc:	605a      	str	r2, [r3, #4]
    dmaStreamRelease(spip->dmarx);
 800b1be:	9b01      	ldr	r3, [sp, #4]
 800b1c0:	6a1b      	ldr	r3, [r3, #32]
 800b1c2:	4618      	mov	r0, r3
 800b1c4:	f7fc fe44 	bl	8007e50 <dmaStreamRelease>
    dmaStreamRelease(spip->dmatx);
 800b1c8:	9b01      	ldr	r3, [sp, #4]
 800b1ca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b1cc:	4618      	mov	r0, r3
 800b1ce:	f7fc fe3f 	bl	8007e50 <dmaStreamRelease>

#if STM32_SPI_USE_SPI1
    if (&SPID1 == spip)
 800b1d2:	9a01      	ldr	r2, [sp, #4]
 800b1d4:	4b0a      	ldr	r3, [pc, #40]	; (800b200 <spi_lld_stop+0x60>)
 800b1d6:	429a      	cmp	r2, r3
 800b1d8:	d105      	bne.n	800b1e6 <spi_lld_stop+0x46>
      rccDisableSPI1(FALSE);
 800b1da:	4b0a      	ldr	r3, [pc, #40]	; (800b204 <spi_lld_stop+0x64>)
 800b1dc:	4a09      	ldr	r2, [pc, #36]	; (800b204 <spi_lld_stop+0x64>)
 800b1de:	6e12      	ldr	r2, [r2, #96]	; 0x60
 800b1e0:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 800b1e4:	661a      	str	r2, [r3, #96]	; 0x60
#endif
#if STM32_SPI_USE_SPI2
    if (&SPID2 == spip)
 800b1e6:	9a01      	ldr	r2, [sp, #4]
 800b1e8:	4b07      	ldr	r3, [pc, #28]	; (800b208 <spi_lld_stop+0x68>)
 800b1ea:	429a      	cmp	r2, r3
 800b1ec:	d105      	bne.n	800b1fa <spi_lld_stop+0x5a>
      rccDisableSPI2(FALSE);
 800b1ee:	4b05      	ldr	r3, [pc, #20]	; (800b204 <spi_lld_stop+0x64>)
 800b1f0:	4a04      	ldr	r2, [pc, #16]	; (800b204 <spi_lld_stop+0x64>)
 800b1f2:	6d92      	ldr	r2, [r2, #88]	; 0x58
 800b1f4:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 800b1f8:	659a      	str	r2, [r3, #88]	; 0x58
#if STM32_SPI_USE_SPI6
    if (&SPID6 == spip)
      rccDisableSPI6(FALSE);
#endif
  }
}
 800b1fa:	b003      	add	sp, #12
 800b1fc:	f85d fb04 	ldr.w	pc, [sp], #4
 800b200:	20001ac0 	.word	0x20001ac0
 800b204:	40021000 	.word	0x40021000
 800b208:	20001af0 	.word	0x20001af0
 800b20c:	f3af 8000 	nop.w

0800b210 <spi_lld_select>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_select(SPIDriver *spip) {
 800b210:	b082      	sub	sp, #8
 800b212:	9001      	str	r0, [sp, #4]

  palClearPad(spip->config->ssport, spip->config->sspad);
 800b214:	9b01      	ldr	r3, [sp, #4]
 800b216:	685b      	ldr	r3, [r3, #4]
 800b218:	685b      	ldr	r3, [r3, #4]
 800b21a:	9a01      	ldr	r2, [sp, #4]
 800b21c:	6852      	ldr	r2, [r2, #4]
 800b21e:	8912      	ldrh	r2, [r2, #8]
 800b220:	2101      	movs	r1, #1
 800b222:	fa01 f202 	lsl.w	r2, r1, r2
 800b226:	b292      	uxth	r2, r2
 800b228:	835a      	strh	r2, [r3, #26]
}
 800b22a:	b002      	add	sp, #8
 800b22c:	4770      	bx	lr
 800b22e:	bf00      	nop

0800b230 <spi_lld_unselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_unselect(SPIDriver *spip) {
 800b230:	b082      	sub	sp, #8
 800b232:	9001      	str	r0, [sp, #4]

  palSetPad(spip->config->ssport, spip->config->sspad);
 800b234:	9b01      	ldr	r3, [sp, #4]
 800b236:	685b      	ldr	r3, [r3, #4]
 800b238:	685b      	ldr	r3, [r3, #4]
 800b23a:	9a01      	ldr	r2, [sp, #4]
 800b23c:	6852      	ldr	r2, [r2, #4]
 800b23e:	8912      	ldrh	r2, [r2, #8]
 800b240:	2101      	movs	r1, #1
 800b242:	fa01 f202 	lsl.w	r2, r1, r2
 800b246:	b292      	uxth	r2, r2
 800b248:	831a      	strh	r2, [r3, #24]
}
 800b24a:	b002      	add	sp, #8
 800b24c:	4770      	bx	lr
 800b24e:	bf00      	nop

0800b250 <spi_lld_ignore>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] n         number of words to be ignored
 *
 * @notapi
 */
void spi_lld_ignore(SPIDriver *spip, size_t n) {
 800b250:	b084      	sub	sp, #16
 800b252:	9001      	str	r0, [sp, #4]
 800b254:	9100      	str	r1, [sp, #0]

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 800b256:	9b01      	ldr	r3, [sp, #4]
 800b258:	6a1b      	ldr	r3, [r3, #32]
 800b25a:	685b      	ldr	r3, [r3, #4]
 800b25c:	4a38      	ldr	r2, [pc, #224]	; (800b340 <spi_lld_ignore+0xf0>)
 800b25e:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800b260:	9b01      	ldr	r3, [sp, #4]
 800b262:	6a1b      	ldr	r3, [r3, #32]
 800b264:	685b      	ldr	r3, [r3, #4]
 800b266:	9a00      	ldr	r2, [sp, #0]
 800b268:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 800b26a:	9b01      	ldr	r3, [sp, #4]
 800b26c:	6a1b      	ldr	r3, [r3, #32]
 800b26e:	68db      	ldr	r3, [r3, #12]
 800b270:	681b      	ldr	r3, [r3, #0]
 800b272:	9303      	str	r3, [sp, #12]
 800b274:	9b01      	ldr	r3, [sp, #4]
 800b276:	6a1b      	ldr	r3, [r3, #32]
 800b278:	7c1b      	ldrb	r3, [r3, #16]
 800b27a:	220f      	movs	r2, #15
 800b27c:	fa02 f303 	lsl.w	r3, r2, r3
 800b280:	43db      	mvns	r3, r3
 800b282:	9a03      	ldr	r2, [sp, #12]
 800b284:	4013      	ands	r3, r2
 800b286:	9303      	str	r3, [sp, #12]
 800b288:	9b01      	ldr	r3, [sp, #4]
 800b28a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b28c:	0c1a      	lsrs	r2, r3, #16
 800b28e:	9b01      	ldr	r3, [sp, #4]
 800b290:	6a1b      	ldr	r3, [r3, #32]
 800b292:	7c1b      	ldrb	r3, [r3, #16]
 800b294:	fa02 f303 	lsl.w	r3, r2, r3
 800b298:	9a03      	ldr	r2, [sp, #12]
 800b29a:	4313      	orrs	r3, r2
 800b29c:	9303      	str	r3, [sp, #12]
 800b29e:	9b01      	ldr	r3, [sp, #4]
 800b2a0:	6a1b      	ldr	r3, [r3, #32]
 800b2a2:	68db      	ldr	r3, [r3, #12]
 800b2a4:	9a03      	ldr	r2, [sp, #12]
 800b2a6:	601a      	str	r2, [r3, #0]
 800b2a8:	9b01      	ldr	r3, [sp, #4]
 800b2aa:	6a1b      	ldr	r3, [r3, #32]
 800b2ac:	685b      	ldr	r3, [r3, #4]
 800b2ae:	9a01      	ldr	r2, [sp, #4]
 800b2b0:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800b2b2:	601a      	str	r2, [r3, #0]

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800b2b4:	9b01      	ldr	r3, [sp, #4]
 800b2b6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b2b8:	685b      	ldr	r3, [r3, #4]
 800b2ba:	4a22      	ldr	r2, [pc, #136]	; (800b344 <spi_lld_ignore+0xf4>)
 800b2bc:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800b2be:	9b01      	ldr	r3, [sp, #4]
 800b2c0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b2c2:	685b      	ldr	r3, [r3, #4]
 800b2c4:	9a00      	ldr	r2, [sp, #0]
 800b2c6:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 800b2c8:	9b01      	ldr	r3, [sp, #4]
 800b2ca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b2cc:	68db      	ldr	r3, [r3, #12]
 800b2ce:	681b      	ldr	r3, [r3, #0]
 800b2d0:	9302      	str	r3, [sp, #8]
 800b2d2:	9b01      	ldr	r3, [sp, #4]
 800b2d4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b2d6:	7c1b      	ldrb	r3, [r3, #16]
 800b2d8:	220f      	movs	r2, #15
 800b2da:	fa02 f303 	lsl.w	r3, r2, r3
 800b2de:	43db      	mvns	r3, r3
 800b2e0:	9a02      	ldr	r2, [sp, #8]
 800b2e2:	4013      	ands	r3, r2
 800b2e4:	9302      	str	r3, [sp, #8]
 800b2e6:	9b01      	ldr	r3, [sp, #4]
 800b2e8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b2ea:	0c1a      	lsrs	r2, r3, #16
 800b2ec:	9b01      	ldr	r3, [sp, #4]
 800b2ee:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b2f0:	7c1b      	ldrb	r3, [r3, #16]
 800b2f2:	fa02 f303 	lsl.w	r3, r2, r3
 800b2f6:	9a02      	ldr	r2, [sp, #8]
 800b2f8:	4313      	orrs	r3, r2
 800b2fa:	9302      	str	r3, [sp, #8]
 800b2fc:	9b01      	ldr	r3, [sp, #4]
 800b2fe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b300:	68db      	ldr	r3, [r3, #12]
 800b302:	9a02      	ldr	r2, [sp, #8]
 800b304:	601a      	str	r2, [r3, #0]
 800b306:	9b01      	ldr	r3, [sp, #4]
 800b308:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b30a:	685b      	ldr	r3, [r3, #4]
 800b30c:	9a01      	ldr	r2, [sp, #4]
 800b30e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800b310:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800b312:	9b01      	ldr	r3, [sp, #4]
 800b314:	6a1b      	ldr	r3, [r3, #32]
 800b316:	685b      	ldr	r3, [r3, #4]
 800b318:	9a01      	ldr	r2, [sp, #4]
 800b31a:	6a12      	ldr	r2, [r2, #32]
 800b31c:	6852      	ldr	r2, [r2, #4]
 800b31e:	6812      	ldr	r2, [r2, #0]
 800b320:	f042 0201 	orr.w	r2, r2, #1
 800b324:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(spip->dmatx);
 800b326:	9b01      	ldr	r3, [sp, #4]
 800b328:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b32a:	685b      	ldr	r3, [r3, #4]
 800b32c:	9a01      	ldr	r2, [sp, #4]
 800b32e:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800b330:	6852      	ldr	r2, [r2, #4]
 800b332:	6812      	ldr	r2, [r2, #0]
 800b334:	f042 0201 	orr.w	r2, r2, #1
 800b338:	601a      	str	r2, [r3, #0]
}
 800b33a:	b004      	add	sp, #16
 800b33c:	4770      	bx	lr
 800b33e:	bf00      	nop
 800b340:	20000f8c 	.word	0x20000f8c
 800b344:	080179e0 	.word	0x080179e0
 800b348:	f3af 8000 	nop.w
 800b34c:	f3af 8000 	nop.w

0800b350 <spi_lld_exchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {
 800b350:	b086      	sub	sp, #24
 800b352:	9003      	str	r0, [sp, #12]
 800b354:	9102      	str	r1, [sp, #8]
 800b356:	9201      	str	r2, [sp, #4]
 800b358:	9300      	str	r3, [sp, #0]

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 800b35a:	9b03      	ldr	r3, [sp, #12]
 800b35c:	6a1b      	ldr	r3, [r3, #32]
 800b35e:	685b      	ldr	r3, [r3, #4]
 800b360:	9a00      	ldr	r2, [sp, #0]
 800b362:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800b364:	9b03      	ldr	r3, [sp, #12]
 800b366:	6a1b      	ldr	r3, [r3, #32]
 800b368:	685b      	ldr	r3, [r3, #4]
 800b36a:	9a02      	ldr	r2, [sp, #8]
 800b36c:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 800b36e:	9b03      	ldr	r3, [sp, #12]
 800b370:	6a1b      	ldr	r3, [r3, #32]
 800b372:	68db      	ldr	r3, [r3, #12]
 800b374:	681b      	ldr	r3, [r3, #0]
 800b376:	9305      	str	r3, [sp, #20]
 800b378:	9b03      	ldr	r3, [sp, #12]
 800b37a:	6a1b      	ldr	r3, [r3, #32]
 800b37c:	7c1b      	ldrb	r3, [r3, #16]
 800b37e:	220f      	movs	r2, #15
 800b380:	fa02 f303 	lsl.w	r3, r2, r3
 800b384:	43db      	mvns	r3, r3
 800b386:	9a05      	ldr	r2, [sp, #20]
 800b388:	4013      	ands	r3, r2
 800b38a:	9305      	str	r3, [sp, #20]
 800b38c:	9b03      	ldr	r3, [sp, #12]
 800b38e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b390:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b394:	0c1a      	lsrs	r2, r3, #16
 800b396:	9b03      	ldr	r3, [sp, #12]
 800b398:	6a1b      	ldr	r3, [r3, #32]
 800b39a:	7c1b      	ldrb	r3, [r3, #16]
 800b39c:	fa02 f303 	lsl.w	r3, r2, r3
 800b3a0:	9a05      	ldr	r2, [sp, #20]
 800b3a2:	4313      	orrs	r3, r2
 800b3a4:	9305      	str	r3, [sp, #20]
 800b3a6:	9b03      	ldr	r3, [sp, #12]
 800b3a8:	6a1b      	ldr	r3, [r3, #32]
 800b3aa:	68db      	ldr	r3, [r3, #12]
 800b3ac:	9a05      	ldr	r2, [sp, #20]
 800b3ae:	601a      	str	r2, [r3, #0]
 800b3b0:	9b03      	ldr	r3, [sp, #12]
 800b3b2:	6a1b      	ldr	r3, [r3, #32]
 800b3b4:	685b      	ldr	r3, [r3, #4]
 800b3b6:	9a03      	ldr	r2, [sp, #12]
 800b3b8:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800b3ba:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800b3be:	601a      	str	r2, [r3, #0]

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 800b3c0:	9b03      	ldr	r3, [sp, #12]
 800b3c2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b3c4:	685b      	ldr	r3, [r3, #4]
 800b3c6:	9a01      	ldr	r2, [sp, #4]
 800b3c8:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800b3ca:	9b03      	ldr	r3, [sp, #12]
 800b3cc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b3ce:	685b      	ldr	r3, [r3, #4]
 800b3d0:	9a02      	ldr	r2, [sp, #8]
 800b3d2:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 800b3d4:	9b03      	ldr	r3, [sp, #12]
 800b3d6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b3d8:	68db      	ldr	r3, [r3, #12]
 800b3da:	681b      	ldr	r3, [r3, #0]
 800b3dc:	9304      	str	r3, [sp, #16]
 800b3de:	9b03      	ldr	r3, [sp, #12]
 800b3e0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b3e2:	7c1b      	ldrb	r3, [r3, #16]
 800b3e4:	220f      	movs	r2, #15
 800b3e6:	fa02 f303 	lsl.w	r3, r2, r3
 800b3ea:	43db      	mvns	r3, r3
 800b3ec:	9a04      	ldr	r2, [sp, #16]
 800b3ee:	4013      	ands	r3, r2
 800b3f0:	9304      	str	r3, [sp, #16]
 800b3f2:	9b03      	ldr	r3, [sp, #12]
 800b3f4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b3f6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b3fa:	0c1a      	lsrs	r2, r3, #16
 800b3fc:	9b03      	ldr	r3, [sp, #12]
 800b3fe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b400:	7c1b      	ldrb	r3, [r3, #16]
 800b402:	fa02 f303 	lsl.w	r3, r2, r3
 800b406:	9a04      	ldr	r2, [sp, #16]
 800b408:	4313      	orrs	r3, r2
 800b40a:	9304      	str	r3, [sp, #16]
 800b40c:	9b03      	ldr	r3, [sp, #12]
 800b40e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b410:	68db      	ldr	r3, [r3, #12]
 800b412:	9a04      	ldr	r2, [sp, #16]
 800b414:	601a      	str	r2, [r3, #0]
 800b416:	9b03      	ldr	r3, [sp, #12]
 800b418:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b41a:	685b      	ldr	r3, [r3, #4]
 800b41c:	9a03      	ldr	r2, [sp, #12]
 800b41e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800b420:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800b424:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800b426:	9b03      	ldr	r3, [sp, #12]
 800b428:	6a1b      	ldr	r3, [r3, #32]
 800b42a:	685b      	ldr	r3, [r3, #4]
 800b42c:	9a03      	ldr	r2, [sp, #12]
 800b42e:	6a12      	ldr	r2, [r2, #32]
 800b430:	6852      	ldr	r2, [r2, #4]
 800b432:	6812      	ldr	r2, [r2, #0]
 800b434:	f042 0201 	orr.w	r2, r2, #1
 800b438:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(spip->dmatx);
 800b43a:	9b03      	ldr	r3, [sp, #12]
 800b43c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b43e:	685b      	ldr	r3, [r3, #4]
 800b440:	9a03      	ldr	r2, [sp, #12]
 800b442:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800b444:	6852      	ldr	r2, [r2, #4]
 800b446:	6812      	ldr	r2, [r2, #0]
 800b448:	f042 0201 	orr.w	r2, r2, #1
 800b44c:	601a      	str	r2, [r3, #0]
}
 800b44e:	b006      	add	sp, #24
 800b450:	4770      	bx	lr
 800b452:	bf00      	nop
 800b454:	f3af 8000 	nop.w
 800b458:	f3af 8000 	nop.w
 800b45c:	f3af 8000 	nop.w

0800b460 <spi_lld_send>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {
 800b460:	b086      	sub	sp, #24
 800b462:	9003      	str	r0, [sp, #12]
 800b464:	9102      	str	r1, [sp, #8]
 800b466:	9201      	str	r2, [sp, #4]

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 800b468:	9b03      	ldr	r3, [sp, #12]
 800b46a:	6a1b      	ldr	r3, [r3, #32]
 800b46c:	685b      	ldr	r3, [r3, #4]
 800b46e:	4a3a      	ldr	r2, [pc, #232]	; (800b558 <spi_lld_send+0xf8>)
 800b470:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800b472:	9b03      	ldr	r3, [sp, #12]
 800b474:	6a1b      	ldr	r3, [r3, #32]
 800b476:	685b      	ldr	r3, [r3, #4]
 800b478:	9a02      	ldr	r2, [sp, #8]
 800b47a:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 800b47c:	9b03      	ldr	r3, [sp, #12]
 800b47e:	6a1b      	ldr	r3, [r3, #32]
 800b480:	68db      	ldr	r3, [r3, #12]
 800b482:	681b      	ldr	r3, [r3, #0]
 800b484:	9305      	str	r3, [sp, #20]
 800b486:	9b03      	ldr	r3, [sp, #12]
 800b488:	6a1b      	ldr	r3, [r3, #32]
 800b48a:	7c1b      	ldrb	r3, [r3, #16]
 800b48c:	220f      	movs	r2, #15
 800b48e:	fa02 f303 	lsl.w	r3, r2, r3
 800b492:	43db      	mvns	r3, r3
 800b494:	9a05      	ldr	r2, [sp, #20]
 800b496:	4013      	ands	r3, r2
 800b498:	9305      	str	r3, [sp, #20]
 800b49a:	9b03      	ldr	r3, [sp, #12]
 800b49c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b49e:	0c1a      	lsrs	r2, r3, #16
 800b4a0:	9b03      	ldr	r3, [sp, #12]
 800b4a2:	6a1b      	ldr	r3, [r3, #32]
 800b4a4:	7c1b      	ldrb	r3, [r3, #16]
 800b4a6:	fa02 f303 	lsl.w	r3, r2, r3
 800b4aa:	9a05      	ldr	r2, [sp, #20]
 800b4ac:	4313      	orrs	r3, r2
 800b4ae:	9305      	str	r3, [sp, #20]
 800b4b0:	9b03      	ldr	r3, [sp, #12]
 800b4b2:	6a1b      	ldr	r3, [r3, #32]
 800b4b4:	68db      	ldr	r3, [r3, #12]
 800b4b6:	9a05      	ldr	r2, [sp, #20]
 800b4b8:	601a      	str	r2, [r3, #0]
 800b4ba:	9b03      	ldr	r3, [sp, #12]
 800b4bc:	6a1b      	ldr	r3, [r3, #32]
 800b4be:	685b      	ldr	r3, [r3, #4]
 800b4c0:	9a03      	ldr	r2, [sp, #12]
 800b4c2:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800b4c4:	601a      	str	r2, [r3, #0]

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 800b4c6:	9b03      	ldr	r3, [sp, #12]
 800b4c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b4ca:	685b      	ldr	r3, [r3, #4]
 800b4cc:	9a01      	ldr	r2, [sp, #4]
 800b4ce:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800b4d0:	9b03      	ldr	r3, [sp, #12]
 800b4d2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b4d4:	685b      	ldr	r3, [r3, #4]
 800b4d6:	9a02      	ldr	r2, [sp, #8]
 800b4d8:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 800b4da:	9b03      	ldr	r3, [sp, #12]
 800b4dc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b4de:	68db      	ldr	r3, [r3, #12]
 800b4e0:	681b      	ldr	r3, [r3, #0]
 800b4e2:	9304      	str	r3, [sp, #16]
 800b4e4:	9b03      	ldr	r3, [sp, #12]
 800b4e6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b4e8:	7c1b      	ldrb	r3, [r3, #16]
 800b4ea:	220f      	movs	r2, #15
 800b4ec:	fa02 f303 	lsl.w	r3, r2, r3
 800b4f0:	43db      	mvns	r3, r3
 800b4f2:	9a04      	ldr	r2, [sp, #16]
 800b4f4:	4013      	ands	r3, r2
 800b4f6:	9304      	str	r3, [sp, #16]
 800b4f8:	9b03      	ldr	r3, [sp, #12]
 800b4fa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b4fc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b500:	0c1a      	lsrs	r2, r3, #16
 800b502:	9b03      	ldr	r3, [sp, #12]
 800b504:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b506:	7c1b      	ldrb	r3, [r3, #16]
 800b508:	fa02 f303 	lsl.w	r3, r2, r3
 800b50c:	9a04      	ldr	r2, [sp, #16]
 800b50e:	4313      	orrs	r3, r2
 800b510:	9304      	str	r3, [sp, #16]
 800b512:	9b03      	ldr	r3, [sp, #12]
 800b514:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b516:	68db      	ldr	r3, [r3, #12]
 800b518:	9a04      	ldr	r2, [sp, #16]
 800b51a:	601a      	str	r2, [r3, #0]
 800b51c:	9b03      	ldr	r3, [sp, #12]
 800b51e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b520:	685b      	ldr	r3, [r3, #4]
 800b522:	9a03      	ldr	r2, [sp, #12]
 800b524:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800b526:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800b52a:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800b52c:	9b03      	ldr	r3, [sp, #12]
 800b52e:	6a1b      	ldr	r3, [r3, #32]
 800b530:	685b      	ldr	r3, [r3, #4]
 800b532:	9a03      	ldr	r2, [sp, #12]
 800b534:	6a12      	ldr	r2, [r2, #32]
 800b536:	6852      	ldr	r2, [r2, #4]
 800b538:	6812      	ldr	r2, [r2, #0]
 800b53a:	f042 0201 	orr.w	r2, r2, #1
 800b53e:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(spip->dmatx);
 800b540:	9b03      	ldr	r3, [sp, #12]
 800b542:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b544:	685b      	ldr	r3, [r3, #4]
 800b546:	9a03      	ldr	r2, [sp, #12]
 800b548:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800b54a:	6852      	ldr	r2, [r2, #4]
 800b54c:	6812      	ldr	r2, [r2, #0]
 800b54e:	f042 0201 	orr.w	r2, r2, #1
 800b552:	601a      	str	r2, [r3, #0]
}
 800b554:	b006      	add	sp, #24
 800b556:	4770      	bx	lr
 800b558:	20000f8c 	.word	0x20000f8c
 800b55c:	f3af 8000 	nop.w

0800b560 <spi_lld_receive>:
 * @param[in] n         number of words to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void spi_lld_receive(SPIDriver *spip, size_t n, void *rxbuf) {
 800b560:	b086      	sub	sp, #24
 800b562:	9003      	str	r0, [sp, #12]
 800b564:	9102      	str	r1, [sp, #8]
 800b566:	9201      	str	r2, [sp, #4]

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 800b568:	9b03      	ldr	r3, [sp, #12]
 800b56a:	6a1b      	ldr	r3, [r3, #32]
 800b56c:	685b      	ldr	r3, [r3, #4]
 800b56e:	9a01      	ldr	r2, [sp, #4]
 800b570:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800b572:	9b03      	ldr	r3, [sp, #12]
 800b574:	6a1b      	ldr	r3, [r3, #32]
 800b576:	685b      	ldr	r3, [r3, #4]
 800b578:	9a02      	ldr	r2, [sp, #8]
 800b57a:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 800b57c:	9b03      	ldr	r3, [sp, #12]
 800b57e:	6a1b      	ldr	r3, [r3, #32]
 800b580:	68db      	ldr	r3, [r3, #12]
 800b582:	681b      	ldr	r3, [r3, #0]
 800b584:	9305      	str	r3, [sp, #20]
 800b586:	9b03      	ldr	r3, [sp, #12]
 800b588:	6a1b      	ldr	r3, [r3, #32]
 800b58a:	7c1b      	ldrb	r3, [r3, #16]
 800b58c:	220f      	movs	r2, #15
 800b58e:	fa02 f303 	lsl.w	r3, r2, r3
 800b592:	43db      	mvns	r3, r3
 800b594:	9a05      	ldr	r2, [sp, #20]
 800b596:	4013      	ands	r3, r2
 800b598:	9305      	str	r3, [sp, #20]
 800b59a:	9b03      	ldr	r3, [sp, #12]
 800b59c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b59e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b5a2:	0c1a      	lsrs	r2, r3, #16
 800b5a4:	9b03      	ldr	r3, [sp, #12]
 800b5a6:	6a1b      	ldr	r3, [r3, #32]
 800b5a8:	7c1b      	ldrb	r3, [r3, #16]
 800b5aa:	fa02 f303 	lsl.w	r3, r2, r3
 800b5ae:	9a05      	ldr	r2, [sp, #20]
 800b5b0:	4313      	orrs	r3, r2
 800b5b2:	9305      	str	r3, [sp, #20]
 800b5b4:	9b03      	ldr	r3, [sp, #12]
 800b5b6:	6a1b      	ldr	r3, [r3, #32]
 800b5b8:	68db      	ldr	r3, [r3, #12]
 800b5ba:	9a05      	ldr	r2, [sp, #20]
 800b5bc:	601a      	str	r2, [r3, #0]
 800b5be:	9b03      	ldr	r3, [sp, #12]
 800b5c0:	6a1b      	ldr	r3, [r3, #32]
 800b5c2:	685b      	ldr	r3, [r3, #4]
 800b5c4:	9a03      	ldr	r2, [sp, #12]
 800b5c6:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800b5c8:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800b5cc:	601a      	str	r2, [r3, #0]

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800b5ce:	9b03      	ldr	r3, [sp, #12]
 800b5d0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b5d2:	685b      	ldr	r3, [r3, #4]
 800b5d4:	4a20      	ldr	r2, [pc, #128]	; (800b658 <spi_lld_receive+0xf8>)
 800b5d6:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800b5d8:	9b03      	ldr	r3, [sp, #12]
 800b5da:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b5dc:	685b      	ldr	r3, [r3, #4]
 800b5de:	9a02      	ldr	r2, [sp, #8]
 800b5e0:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 800b5e2:	9b03      	ldr	r3, [sp, #12]
 800b5e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b5e6:	68db      	ldr	r3, [r3, #12]
 800b5e8:	681b      	ldr	r3, [r3, #0]
 800b5ea:	9304      	str	r3, [sp, #16]
 800b5ec:	9b03      	ldr	r3, [sp, #12]
 800b5ee:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b5f0:	7c1b      	ldrb	r3, [r3, #16]
 800b5f2:	220f      	movs	r2, #15
 800b5f4:	fa02 f303 	lsl.w	r3, r2, r3
 800b5f8:	43db      	mvns	r3, r3
 800b5fa:	9a04      	ldr	r2, [sp, #16]
 800b5fc:	4013      	ands	r3, r2
 800b5fe:	9304      	str	r3, [sp, #16]
 800b600:	9b03      	ldr	r3, [sp, #12]
 800b602:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b604:	0c1a      	lsrs	r2, r3, #16
 800b606:	9b03      	ldr	r3, [sp, #12]
 800b608:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b60a:	7c1b      	ldrb	r3, [r3, #16]
 800b60c:	fa02 f303 	lsl.w	r3, r2, r3
 800b610:	9a04      	ldr	r2, [sp, #16]
 800b612:	4313      	orrs	r3, r2
 800b614:	9304      	str	r3, [sp, #16]
 800b616:	9b03      	ldr	r3, [sp, #12]
 800b618:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b61a:	68db      	ldr	r3, [r3, #12]
 800b61c:	9a04      	ldr	r2, [sp, #16]
 800b61e:	601a      	str	r2, [r3, #0]
 800b620:	9b03      	ldr	r3, [sp, #12]
 800b622:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b624:	685b      	ldr	r3, [r3, #4]
 800b626:	9a03      	ldr	r2, [sp, #12]
 800b628:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800b62a:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800b62c:	9b03      	ldr	r3, [sp, #12]
 800b62e:	6a1b      	ldr	r3, [r3, #32]
 800b630:	685b      	ldr	r3, [r3, #4]
 800b632:	9a03      	ldr	r2, [sp, #12]
 800b634:	6a12      	ldr	r2, [r2, #32]
 800b636:	6852      	ldr	r2, [r2, #4]
 800b638:	6812      	ldr	r2, [r2, #0]
 800b63a:	f042 0201 	orr.w	r2, r2, #1
 800b63e:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(spip->dmatx);
 800b640:	9b03      	ldr	r3, [sp, #12]
 800b642:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b644:	685b      	ldr	r3, [r3, #4]
 800b646:	9a03      	ldr	r2, [sp, #12]
 800b648:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800b64a:	6852      	ldr	r2, [r2, #4]
 800b64c:	6812      	ldr	r2, [r2, #0]
 800b64e:	f042 0201 	orr.w	r2, r2, #1
 800b652:	601a      	str	r2, [r3, #0]
}
 800b654:	b006      	add	sp, #24
 800b656:	4770      	bx	lr
 800b658:	080179e0 	.word	0x080179e0
 800b65c:	f3af 8000 	nop.w

0800b660 <spi_lld_polled_exchange>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] frame     the data frame to send over the SPI bus
 * @return              The received data frame from the SPI bus.
 */
uint16_t spi_lld_polled_exchange(SPIDriver *spip, uint16_t frame) {
 800b660:	b084      	sub	sp, #16
 800b662:	9001      	str	r0, [sp, #4]
 800b664:	460b      	mov	r3, r1
 800b666:	f8ad 3002 	strh.w	r3, [sp, #2]
  /*
   * Data register must be accessed with the appropriate data size.
   * Byte size access (uint8_t *) for transactions that are <= 8-bit.
   * Halfword size access (uint16_t) for transactions that are <= 8-bit.
   */
  if ((spip->config->cr2 & SPI_CR2_DS) <= (SPI_CR2_DS_2 |
 800b66a:	9b01      	ldr	r3, [sp, #4]
 800b66c:	685b      	ldr	r3, [r3, #4]
 800b66e:	899b      	ldrh	r3, [r3, #12]
 800b670:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 800b674:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 800b678:	d814      	bhi.n	800b6a4 <spi_lld_polled_exchange+0x44>
                                           SPI_CR2_DS_1 |
                                           SPI_CR2_DS_0)) {
    volatile uint8_t *spidr = (volatile uint8_t *)&spip->spi->DR;
 800b67a:	9b01      	ldr	r3, [sp, #4]
 800b67c:	69db      	ldr	r3, [r3, #28]
 800b67e:	330c      	adds	r3, #12
 800b680:	9303      	str	r3, [sp, #12]
    *spidr = (uint8_t)frame;
 800b682:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 800b686:	b2da      	uxtb	r2, r3
 800b688:	9b03      	ldr	r3, [sp, #12]
 800b68a:	701a      	strb	r2, [r3, #0]
    while ((spip->spi->SR & SPI_SR_RXNE) == 0)
 800b68c:	bf00      	nop
 800b68e:	9b01      	ldr	r3, [sp, #4]
 800b690:	69db      	ldr	r3, [r3, #28]
 800b692:	689b      	ldr	r3, [r3, #8]
 800b694:	f003 0301 	and.w	r3, r3, #1
 800b698:	2b00      	cmp	r3, #0
 800b69a:	d0f8      	beq.n	800b68e <spi_lld_polled_exchange+0x2e>
      ;
    return (uint16_t)*spidr;
 800b69c:	9b03      	ldr	r3, [sp, #12]
 800b69e:	781b      	ldrb	r3, [r3, #0]
 800b6a0:	b2db      	uxtb	r3, r3
 800b6a2:	e010      	b.n	800b6c6 <spi_lld_polled_exchange+0x66>
  }
  else {
    spip->spi->DR = frame;
 800b6a4:	9b01      	ldr	r3, [sp, #4]
 800b6a6:	69db      	ldr	r3, [r3, #28]
 800b6a8:	f8bd 2002 	ldrh.w	r2, [sp, #2]
 800b6ac:	60da      	str	r2, [r3, #12]
    while ((spip->spi->SR & SPI_SR_RXNE) == 0)
 800b6ae:	bf00      	nop
 800b6b0:	9b01      	ldr	r3, [sp, #4]
 800b6b2:	69db      	ldr	r3, [r3, #28]
 800b6b4:	689b      	ldr	r3, [r3, #8]
 800b6b6:	f003 0301 	and.w	r3, r3, #1
 800b6ba:	2b00      	cmp	r3, #0
 800b6bc:	d0f8      	beq.n	800b6b0 <spi_lld_polled_exchange+0x50>
      ;
    return spip->spi->DR;
 800b6be:	9b01      	ldr	r3, [sp, #4]
 800b6c0:	69db      	ldr	r3, [r3, #28]
 800b6c2:	68db      	ldr	r3, [r3, #12]
 800b6c4:	b29b      	uxth	r3, r3
  }
}
 800b6c6:	4618      	mov	r0, r3
 800b6c8:	b004      	add	sp, #16
 800b6ca:	4770      	bx	lr
 800b6cc:	f3af 8000 	nop.w

0800b6d0 <spi_lld_polled_tx>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] frame     the data frame to send over the SPI bus
 * @return              The received data frame from the SPI bus.
 */

int spi_lld_polled_tx(SPIDriver *spip, uint8_t val) {
 800b6d0:	b084      	sub	sp, #16
 800b6d2:	9001      	str	r0, [sp, #4]
 800b6d4:	460b      	mov	r3, r1
 800b6d6:	f88d 3003 	strb.w	r3, [sp, #3]

  /* check TXE flag */
  while ((spip->spi->SR & SPI_SR_TXE) != SPI_SR_TXE);
 800b6da:	bf00      	nop
 800b6dc:	9b01      	ldr	r3, [sp, #4]
 800b6de:	69db      	ldr	r3, [r3, #28]
 800b6e0:	689b      	ldr	r3, [r3, #8]
 800b6e2:	f003 0302 	and.w	r3, r3, #2
 800b6e6:	2b00      	cmp	r3, #0
 800b6e8:	d0f8      	beq.n	800b6dc <spi_lld_polled_tx+0xc>

  /* Write the data */
  volatile uint8_t *spidr = (volatile uint8_t *)&spip->spi->DR;
 800b6ea:	9b01      	ldr	r3, [sp, #4]
 800b6ec:	69db      	ldr	r3, [r3, #28]
 800b6ee:	330c      	adds	r3, #12
 800b6f0:	9303      	str	r3, [sp, #12]
  *spidr = val;
 800b6f2:	9b03      	ldr	r3, [sp, #12]
 800b6f4:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800b6f8:	701a      	strb	r2, [r3, #0]

  /* Check to see that the Transmitter is empty */
  while (spip->spi->SR & SPI_SR_FTLVL);
 800b6fa:	bf00      	nop
 800b6fc:	9b01      	ldr	r3, [sp, #4]
 800b6fe:	69db      	ldr	r3, [r3, #28]
 800b700:	689b      	ldr	r3, [r3, #8]
 800b702:	f403 53c0 	and.w	r3, r3, #6144	; 0x1800
 800b706:	2b00      	cmp	r3, #0
 800b708:	d1f8      	bne.n	800b6fc <spi_lld_polled_tx+0x2c>
  while ((spip->spi->SR & SPI_SR_BSY) == SPI_SR_BSY);
 800b70a:	bf00      	nop
 800b70c:	9b01      	ldr	r3, [sp, #4]
 800b70e:	69db      	ldr	r3, [r3, #28]
 800b710:	689b      	ldr	r3, [r3, #8]
 800b712:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800b716:	2b00      	cmp	r3, #0
 800b718:	d1f8      	bne.n	800b70c <spi_lld_polled_tx+0x3c>

  return (0);
 800b71a:	2300      	movs	r3, #0
}
 800b71c:	4618      	mov	r0, r3
 800b71e:	b004      	add	sp, #16
 800b720:	4770      	bx	lr
 800b722:	bf00      	nop
 800b724:	f3af 8000 	nop.w
 800b728:	f3af 8000 	nop.w
 800b72c:	f3af 8000 	nop.w

0800b730 <spi_lld_polled_rx>:

int spi_lld_polled_rx(SPIDriver *spip) {
 800b730:	b500      	push	{lr}
 800b732:	b085      	sub	sp, #20
 800b734:	9001      	str	r0, [sp, #4]
  /* In master RX mode the clock is automaticaly generated on the SPI enable.
  So to guarantee the clock generation for only one data, the clock must be
  disabled after the first bit and before the latest bit */
  /* Interrupts should be disabled during this operation */

  chSysLock();
 800b736:	f7ff fb7b 	bl	800ae30 <chSysLock>
  spip->spi->CR1 |= SPI_CR1_SPE;   // Turn on the SPI 
 800b73a:	9b01      	ldr	r3, [sp, #4]
 800b73c:	69db      	ldr	r3, [r3, #28]
 800b73e:	9a01      	ldr	r2, [sp, #4]
 800b740:	69d2      	ldr	r2, [r2, #28]
 800b742:	6812      	ldr	r2, [r2, #0]
 800b744:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800b748:	601a      	str	r2, [r3, #0]
  __asm("dsb\n");
 800b74a:	f3bf 8f4f 	dsb	sy
  __asm("dsb\n");
 800b74e:	f3bf 8f4f 	dsb	sy
  spip->spi->CR1 &= ~SPI_CR1_SPE;   // Turn off the SPI
 800b752:	9b01      	ldr	r3, [sp, #4]
 800b754:	69db      	ldr	r3, [r3, #28]
 800b756:	9a01      	ldr	r2, [sp, #4]
 800b758:	69d2      	ldr	r2, [r2, #28]
 800b75a:	6812      	ldr	r2, [r2, #0]
 800b75c:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800b760:	601a      	str	r2, [r3, #0]
  chSysUnlock();
 800b762:	f7ff fb6d 	bl	800ae40 <chSysUnlock>
  
  while ((spip->spi->SR & SPI_SR_RXNE) != SPI_SR_RXNE);
 800b766:	bf00      	nop
 800b768:	9b01      	ldr	r3, [sp, #4]
 800b76a:	69db      	ldr	r3, [r3, #28]
 800b76c:	689b      	ldr	r3, [r3, #8]
 800b76e:	f003 0301 	and.w	r3, r3, #1
 800b772:	2b00      	cmp	r3, #0
 800b774:	d0f8      	beq.n	800b768 <spi_lld_polled_rx+0x38>
  /* read the received data */
  volatile uint8_t *spidr = (volatile uint8_t *)&spip->spi->DR;
 800b776:	9b01      	ldr	r3, [sp, #4]
 800b778:	69db      	ldr	r3, [r3, #28]
 800b77a:	330c      	adds	r3, #12
 800b77c:	9303      	str	r3, [sp, #12]
  val = *spidr;
 800b77e:	9b03      	ldr	r3, [sp, #12]
 800b780:	781b      	ldrb	r3, [r3, #0]
 800b782:	f88d 300b 	strb.w	r3, [sp, #11]
  while ((spip->spi->SR & SPI_SR_BSY) == SPI_SR_BSY);
 800b786:	bf00      	nop
 800b788:	9b01      	ldr	r3, [sp, #4]
 800b78a:	69db      	ldr	r3, [r3, #28]
 800b78c:	689b      	ldr	r3, [r3, #8]
 800b78e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800b792:	2b00      	cmp	r3, #0
 800b794:	d1f8      	bne.n	800b788 <spi_lld_polled_rx+0x58>
  return (val);
 800b796:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 800b79a:	4618      	mov	r0, r3
 800b79c:	b005      	add	sp, #20
 800b79e:	f85d fb04 	ldr.w	pc, [sp], #4
 800b7a2:	bf00      	nop
 800b7a4:	f3af 8000 	nop.w
 800b7a8:	f3af 8000 	nop.w
 800b7ac:	f3af 8000 	nop.w

0800b7b0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800b7b0:	b082      	sub	sp, #8
 800b7b2:	2320      	movs	r3, #32
 800b7b4:	9301      	str	r3, [sp, #4]
 800b7b6:	9b01      	ldr	r3, [sp, #4]
 800b7b8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800b7bc:	b002      	add	sp, #8
 800b7be:	4770      	bx	lr

0800b7c0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800b7c0:	b082      	sub	sp, #8
 800b7c2:	2300      	movs	r3, #0
 800b7c4:	9301      	str	r3, [sp, #4]
 800b7c6:	9b01      	ldr	r3, [sp, #4]
 800b7c8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800b7cc:	b002      	add	sp, #8
 800b7ce:	4770      	bx	lr

0800b7d0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800b7d0:	b508      	push	{r3, lr}

  port_lock();
 800b7d2:	f7ff ffed 	bl	800b7b0 <port_lock>
}
 800b7d6:	bd08      	pop	{r3, pc}
 800b7d8:	f3af 8000 	nop.w
 800b7dc:	f3af 8000 	nop.w

0800b7e0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800b7e0:	b508      	push	{r3, lr}

  port_unlock();
 800b7e2:	f7ff ffed 	bl	800b7c0 <port_unlock>
}
 800b7e6:	bd08      	pop	{r3, pc}
 800b7e8:	f3af 8000 	nop.w
 800b7ec:	f3af 8000 	nop.w

0800b7f0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 800b7f0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800b7f2:	f7ff ffed 	bl	800b7d0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 800b7f6:	bd08      	pop	{r3, pc}
 800b7f8:	f3af 8000 	nop.w
 800b7fc:	f3af 8000 	nop.w

0800b800 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 800b800:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 800b802:	f7ff ffed 	bl	800b7e0 <port_unlock_from_isr>
}
 800b806:	bd08      	pop	{r3, pc}
 800b808:	f3af 8000 	nop.w
 800b80c:	f3af 8000 	nop.w

0800b810 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 800b810:	b082      	sub	sp, #8
 800b812:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 800b814:	9b01      	ldr	r3, [sp, #4]
 800b816:	695a      	ldr	r2, [r3, #20]
 800b818:	9b01      	ldr	r3, [sp, #4]
 800b81a:	699b      	ldr	r3, [r3, #24]
 800b81c:	429a      	cmp	r2, r3
 800b81e:	d105      	bne.n	800b82c <chOQIsEmptyI+0x1c>
 800b820:	9b01      	ldr	r3, [sp, #4]
 800b822:	689b      	ldr	r3, [r3, #8]
 800b824:	2b00      	cmp	r3, #0
 800b826:	d001      	beq.n	800b82c <chOQIsEmptyI+0x1c>
 800b828:	2301      	movs	r3, #1
 800b82a:	e000      	b.n	800b82e <chOQIsEmptyI+0x1e>
 800b82c:	2300      	movs	r3, #0
 800b82e:	f003 0301 	and.w	r3, r3, #1
 800b832:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 800b834:	4618      	mov	r0, r3
 800b836:	b002      	add	sp, #8
 800b838:	4770      	bx	lr
 800b83a:	bf00      	nop
 800b83c:	f3af 8000 	nop.w

0800b840 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 800b840:	b508      	push	{r3, lr}

  chSysLockFromISR();
 800b842:	f7ff ffd5 	bl	800b7f0 <chSysLockFromISR>
}
 800b846:	bd08      	pop	{r3, pc}
 800b848:	f3af 8000 	nop.w
 800b84c:	f3af 8000 	nop.w

0800b850 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 800b850:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 800b852:	f7ff ffd5 	bl	800b800 <chSysUnlockFromISR>
}
 800b856:	bd08      	pop	{r3, pc}
 800b858:	f3af 8000 	nop.w
 800b85c:	f3af 8000 	nop.w

0800b860 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 800b860:	b500      	push	{lr}
 800b862:	b083      	sub	sp, #12
 800b864:	9001      	str	r0, [sp, #4]
 800b866:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 800b868:	9801      	ldr	r0, [sp, #4]
 800b86a:	9900      	ldr	r1, [sp, #0]
 800b86c:	f7f6 ff08 	bl	8002680 <chEvtBroadcastFlagsI>
}
 800b870:	b003      	add	sp, #12
 800b872:	f85d fb04 	ldr.w	pc, [sp], #4
 800b876:	bf00      	nop
 800b878:	f3af 8000 	nop.w
 800b87c:	f3af 8000 	nop.w

0800b880 <usart_init>:
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
 800b880:	b084      	sub	sp, #16
 800b882:	9001      	str	r0, [sp, #4]
 800b884:	9100      	str	r1, [sp, #0]
  USART_TypeDef *u = sdp->usart;
 800b886:	9b01      	ldr	r3, [sp, #4]
 800b888:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b88a:	9303      	str	r3, [sp, #12]
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 800b88c:	9b01      	ldr	r3, [sp, #4]
 800b88e:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800b890:	9b00      	ldr	r3, [sp, #0]
 800b892:	681b      	ldr	r3, [r3, #0]
 800b894:	fbb2 f2f3 	udiv	r2, r2, r3
 800b898:	9b03      	ldr	r3, [sp, #12]
 800b89a:	60da      	str	r2, [r3, #12]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800b89c:	9b00      	ldr	r3, [sp, #0]
 800b89e:	689b      	ldr	r3, [r3, #8]
 800b8a0:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 800b8a4:	9b03      	ldr	r3, [sp, #12]
 800b8a6:	605a      	str	r2, [r3, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800b8a8:	9b00      	ldr	r3, [sp, #0]
 800b8aa:	68db      	ldr	r3, [r3, #12]
 800b8ac:	f043 0201 	orr.w	r2, r3, #1
 800b8b0:	9b03      	ldr	r3, [sp, #12]
 800b8b2:	609a      	str	r2, [r3, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800b8b4:	9b00      	ldr	r3, [sp, #0]
 800b8b6:	685b      	ldr	r3, [r3, #4]
                         USART_CR1_RXNEIE | USART_CR1_TE |
 800b8b8:	f443 7396 	orr.w	r3, r3, #300	; 0x12c
 800b8bc:	f043 0301 	orr.w	r3, r3, #1
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800b8c0:	9a03      	ldr	r2, [sp, #12]
 800b8c2:	6013      	str	r3, [r2, #0]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 800b8c4:	9b03      	ldr	r3, [sp, #12]
 800b8c6:	f04f 32ff 	mov.w	r2, #4294967295
 800b8ca:	621a      	str	r2, [r3, #32]
}
 800b8cc:	b004      	add	sp, #16
 800b8ce:	4770      	bx	lr

0800b8d0 <usart_deinit>:
 * @brief   USART de-initialization.
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] u         pointer to an USART I/O block
 */
static void usart_deinit(USART_TypeDef *u) {
 800b8d0:	b082      	sub	sp, #8
 800b8d2:	9001      	str	r0, [sp, #4]

  u->CR1 = 0;
 800b8d4:	9b01      	ldr	r3, [sp, #4]
 800b8d6:	2200      	movs	r2, #0
 800b8d8:	601a      	str	r2, [r3, #0]
  u->CR2 = 0;
 800b8da:	9b01      	ldr	r3, [sp, #4]
 800b8dc:	2200      	movs	r2, #0
 800b8de:	605a      	str	r2, [r3, #4]
  u->CR3 = 0;
 800b8e0:	9b01      	ldr	r3, [sp, #4]
 800b8e2:	2200      	movs	r2, #0
 800b8e4:	609a      	str	r2, [r3, #8]
}
 800b8e6:	b002      	add	sp, #8
 800b8e8:	4770      	bx	lr
 800b8ea:	bf00      	nop
 800b8ec:	f3af 8000 	nop.w

0800b8f0 <set_error>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
 800b8f0:	b500      	push	{lr}
 800b8f2:	b085      	sub	sp, #20
 800b8f4:	9001      	str	r0, [sp, #4]
 800b8f6:	9100      	str	r1, [sp, #0]
  eventflags_t sts = 0;
 800b8f8:	2300      	movs	r3, #0
 800b8fa:	9303      	str	r3, [sp, #12]

  if (isr & USART_ISR_ORE)
 800b8fc:	9b00      	ldr	r3, [sp, #0]
 800b8fe:	f003 0308 	and.w	r3, r3, #8
 800b902:	2b00      	cmp	r3, #0
 800b904:	d003      	beq.n	800b90e <set_error+0x1e>
    sts |= SD_OVERRUN_ERROR;
 800b906:	9b03      	ldr	r3, [sp, #12]
 800b908:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b90c:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_PE)
 800b90e:	9b00      	ldr	r3, [sp, #0]
 800b910:	f003 0301 	and.w	r3, r3, #1
 800b914:	2b00      	cmp	r3, #0
 800b916:	d003      	beq.n	800b920 <set_error+0x30>
    sts |= SD_PARITY_ERROR;
 800b918:	9b03      	ldr	r3, [sp, #12]
 800b91a:	f043 0320 	orr.w	r3, r3, #32
 800b91e:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_FE)
 800b920:	9b00      	ldr	r3, [sp, #0]
 800b922:	f003 0302 	and.w	r3, r3, #2
 800b926:	2b00      	cmp	r3, #0
 800b928:	d003      	beq.n	800b932 <set_error+0x42>
    sts |= SD_FRAMING_ERROR;
 800b92a:	9b03      	ldr	r3, [sp, #12]
 800b92c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800b930:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_NE)
 800b932:	9b00      	ldr	r3, [sp, #0]
 800b934:	f003 0304 	and.w	r3, r3, #4
 800b938:	2b00      	cmp	r3, #0
 800b93a:	d003      	beq.n	800b944 <set_error+0x54>
    sts |= SD_NOISE_ERROR;
 800b93c:	9b03      	ldr	r3, [sp, #12]
 800b93e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800b942:	9303      	str	r3, [sp, #12]
  osalSysLockFromISR();
 800b944:	f7ff ff7c 	bl	800b840 <osalSysLockFromISR>
  chnAddFlagsI(sdp, sts);
 800b948:	9b01      	ldr	r3, [sp, #4]
 800b94a:	3304      	adds	r3, #4
 800b94c:	4618      	mov	r0, r3
 800b94e:	9903      	ldr	r1, [sp, #12]
 800b950:	f7ff ff86 	bl	800b860 <osalEventBroadcastFlagsI>
  osalSysUnlockFromISR();
 800b954:	f7ff ff7c 	bl	800b850 <osalSysUnlockFromISR>
}
 800b958:	b005      	add	sp, #20
 800b95a:	f85d fb04 	ldr.w	pc, [sp], #4
 800b95e:	bf00      	nop

0800b960 <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 800b960:	b500      	push	{lr}
 800b962:	b087      	sub	sp, #28
 800b964:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
 800b966:	9b01      	ldr	r3, [sp, #4]
 800b968:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b96a:	9305      	str	r3, [sp, #20]
  uint32_t cr1 = u->CR1;
 800b96c:	9b05      	ldr	r3, [sp, #20]
 800b96e:	681b      	ldr	r3, [r3, #0]
 800b970:	9304      	str	r3, [sp, #16]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 800b972:	9b05      	ldr	r3, [sp, #20]
 800b974:	69db      	ldr	r3, [r3, #28]
 800b976:	9303      	str	r3, [sp, #12]
  u->ICR = isr;
 800b978:	9b05      	ldr	r3, [sp, #20]
 800b97a:	9a03      	ldr	r2, [sp, #12]
 800b97c:	621a      	str	r2, [r3, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 800b97e:	9b03      	ldr	r3, [sp, #12]
 800b980:	f003 030f 	and.w	r3, r3, #15
 800b984:	2b00      	cmp	r3, #0
 800b986:	d003      	beq.n	800b990 <serve_interrupt+0x30>
    set_error(sdp, isr);
 800b988:	9801      	ldr	r0, [sp, #4]
 800b98a:	9903      	ldr	r1, [sp, #12]
 800b98c:	f7ff ffb0 	bl	800b8f0 <set_error>

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 800b990:	9b03      	ldr	r3, [sp, #12]
 800b992:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800b996:	2b00      	cmp	r3, #0
 800b998:	d00a      	beq.n	800b9b0 <serve_interrupt+0x50>
    osalSysLockFromISR();
 800b99a:	f7ff ff51 	bl	800b840 <osalSysLockFromISR>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 800b99e:	9b01      	ldr	r3, [sp, #4]
 800b9a0:	3304      	adds	r3, #4
 800b9a2:	4618      	mov	r0, r3
 800b9a4:	f44f 7100 	mov.w	r1, #512	; 0x200
 800b9a8:	f7ff ff5a 	bl	800b860 <osalEventBroadcastFlagsI>
    osalSysUnlockFromISR();
 800b9ac:	f7ff ff50 	bl	800b850 <osalSysUnlockFromISR>
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 800b9b0:	9b03      	ldr	r3, [sp, #12]
 800b9b2:	f003 0320 	and.w	r3, r3, #32
 800b9b6:	2b00      	cmp	r3, #0
 800b9b8:	d00b      	beq.n	800b9d2 <serve_interrupt+0x72>
    osalSysLockFromISR();
 800b9ba:	f7ff ff41 	bl	800b840 <osalSysLockFromISR>
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
 800b9be:	9b05      	ldr	r3, [sp, #20]
 800b9c0:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 800b9c2:	b29b      	uxth	r3, r3
 800b9c4:	b2db      	uxtb	r3, r3
 800b9c6:	9801      	ldr	r0, [sp, #4]
 800b9c8:	4619      	mov	r1, r3
 800b9ca:	f7fa fc59 	bl	8006280 <sdIncomingDataI>
    osalSysUnlockFromISR();
 800b9ce:	f7ff ff3f 	bl	800b850 <osalSysUnlockFromISR>
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 800b9d2:	9b04      	ldr	r3, [sp, #16]
 800b9d4:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800b9d8:	2b00      	cmp	r3, #0
 800b9da:	d023      	beq.n	800ba24 <serve_interrupt+0xc4>
 800b9dc:	9b03      	ldr	r3, [sp, #12]
 800b9de:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800b9e2:	2b00      	cmp	r3, #0
 800b9e4:	d01e      	beq.n	800ba24 <serve_interrupt+0xc4>
    msg_t b;
    osalSysLockFromISR();
 800b9e6:	f7ff ff2b 	bl	800b840 <osalSysLockFromISR>
    b = oqGetI(&sdp->oqueue);
 800b9ea:	9b01      	ldr	r3, [sp, #4]
 800b9ec:	3330      	adds	r3, #48	; 0x30
 800b9ee:	4618      	mov	r0, r3
 800b9f0:	f7f7 fd76 	bl	80034e0 <chOQGetI>
 800b9f4:	9002      	str	r0, [sp, #8]
    if (b < Q_OK) {
 800b9f6:	9b02      	ldr	r3, [sp, #8]
 800b9f8:	2b00      	cmp	r3, #0
 800b9fa:	da0d      	bge.n	800ba18 <serve_interrupt+0xb8>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 800b9fc:	9b01      	ldr	r3, [sp, #4]
 800b9fe:	3304      	adds	r3, #4
 800ba00:	4618      	mov	r0, r3
 800ba02:	2108      	movs	r1, #8
 800ba04:	f7ff ff2c 	bl	800b860 <osalEventBroadcastFlagsI>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 800ba08:	9b04      	ldr	r3, [sp, #16]
 800ba0a:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 800ba0e:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 800ba12:	9b05      	ldr	r3, [sp, #20]
 800ba14:	601a      	str	r2, [r3, #0]
 800ba16:	e003      	b.n	800ba20 <serve_interrupt+0xc0>
    }
    else
      u->TDR = b;
 800ba18:	9b02      	ldr	r3, [sp, #8]
 800ba1a:	b29a      	uxth	r2, r3
 800ba1c:	9b05      	ldr	r3, [sp, #20]
 800ba1e:	851a      	strh	r2, [r3, #40]	; 0x28
    osalSysUnlockFromISR();
 800ba20:	f7ff ff16 	bl	800b850 <osalSysUnlockFromISR>
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 800ba24:	9b03      	ldr	r3, [sp, #12]
 800ba26:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800ba2a:	2b00      	cmp	r3, #0
 800ba2c:	d016      	beq.n	800ba5c <serve_interrupt+0xfc>
    osalSysLockFromISR();
 800ba2e:	f7ff ff07 	bl	800b840 <osalSysLockFromISR>
    if (oqIsEmptyI(&sdp->oqueue))
 800ba32:	9b01      	ldr	r3, [sp, #4]
 800ba34:	3330      	adds	r3, #48	; 0x30
 800ba36:	4618      	mov	r0, r3
 800ba38:	f7ff feea 	bl	800b810 <chOQIsEmptyI>
 800ba3c:	4603      	mov	r3, r0
 800ba3e:	2b00      	cmp	r3, #0
 800ba40:	d005      	beq.n	800ba4e <serve_interrupt+0xee>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 800ba42:	9b01      	ldr	r3, [sp, #4]
 800ba44:	3304      	adds	r3, #4
 800ba46:	4618      	mov	r0, r3
 800ba48:	2110      	movs	r1, #16
 800ba4a:	f7ff ff09 	bl	800b860 <osalEventBroadcastFlagsI>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 800ba4e:	9b04      	ldr	r3, [sp, #16]
 800ba50:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 800ba54:	9b05      	ldr	r3, [sp, #20]
 800ba56:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 800ba58:	f7ff fefa 	bl	800b850 <osalSysUnlockFromISR>
  }
}
 800ba5c:	b007      	add	sp, #28
 800ba5e:	f85d fb04 	ldr.w	pc, [sp], #4
 800ba62:	bf00      	nop
 800ba64:	f3af 8000 	nop.w
 800ba68:	f3af 8000 	nop.w
 800ba6c:	f3af 8000 	nop.w

0800ba70 <notify5>:
  UART4->CR1 |= USART_CR1_TXEIE;
}
#endif

#if STM32_SERIAL_USE_UART5 || defined(__DOXYGEN__)
static void notify5(io_queue_t *qp) {
 800ba70:	b082      	sub	sp, #8
 800ba72:	9001      	str	r0, [sp, #4]

  (void)qp;
  UART5->CR1 |= USART_CR1_TXEIE;
 800ba74:	4b03      	ldr	r3, [pc, #12]	; (800ba84 <notify5+0x14>)
 800ba76:	4a03      	ldr	r2, [pc, #12]	; (800ba84 <notify5+0x14>)
 800ba78:	6812      	ldr	r2, [r2, #0]
 800ba7a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800ba7e:	601a      	str	r2, [r3, #0]
}
 800ba80:	b002      	add	sp, #8
 800ba82:	4770      	bx	lr
 800ba84:	40005000 	.word	0x40005000
 800ba88:	f3af 8000 	nop.w
 800ba8c:	f3af 8000 	nop.w

0800ba90 <Vector114>:
/**
 * @brief   UART5 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_UART5_HANDLER) {
 800ba90:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD5);
 800ba92:	4803      	ldr	r0, [pc, #12]	; (800baa0 <Vector114+0x10>)
 800ba94:	f7ff ff64 	bl	800b960 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 800ba98:	f7f8 f85a 	bl	8003b50 <_port_irq_epilogue>
}
 800ba9c:	bd08      	pop	{r3, pc}
 800ba9e:	bf00      	nop
 800baa0:	20001b20 	.word	0x20001b20
 800baa4:	f3af 8000 	nop.w
 800baa8:	f3af 8000 	nop.w
 800baac:	f3af 8000 	nop.w

0800bab0 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 800bab0:	b508      	push	{r3, lr}
  nvicEnableVector(STM32_UART4_NUMBER, STM32_SERIAL_UART4_PRIORITY);
#endif
#endif

#if STM32_SERIAL_USE_UART5
  sdObjectInit(&SD5, NULL, notify5);
 800bab2:	4808      	ldr	r0, [pc, #32]	; (800bad4 <sd_lld_init+0x24>)
 800bab4:	2100      	movs	r1, #0
 800bab6:	4a08      	ldr	r2, [pc, #32]	; (800bad8 <sd_lld_init+0x28>)
 800bab8:	f7fa fb7a 	bl	80061b0 <sdObjectInit>
  SD5.usart = UART5;
 800babc:	4b05      	ldr	r3, [pc, #20]	; (800bad4 <sd_lld_init+0x24>)
 800babe:	4a07      	ldr	r2, [pc, #28]	; (800badc <sd_lld_init+0x2c>)
 800bac0:	675a      	str	r2, [r3, #116]	; 0x74
  SD5.clock = STM32_UART5CLK;
 800bac2:	4b04      	ldr	r3, [pc, #16]	; (800bad4 <sd_lld_init+0x24>)
 800bac4:	4a06      	ldr	r2, [pc, #24]	; (800bae0 <sd_lld_init+0x30>)
 800bac6:	679a      	str	r2, [r3, #120]	; 0x78
#if defined(STM32_UART5_NUMBER)
  nvicEnableVector(STM32_UART5_NUMBER, STM32_SERIAL_UART5_PRIORITY);
 800bac8:	2035      	movs	r0, #53	; 0x35
 800baca:	210c      	movs	r1, #12
 800bacc:	f7fb fc30 	bl	8007330 <nvicEnableVector>
    STM32_SERIAL_USE_UART7  ||  STM32_SERIAL_USE_UART8 || defined(__DOXYGEN__)
#if defined(STM32_USART3_8_HANDLER)
  nvicEnableVector(STM32_USART3_8_NUMBER, STM32_SERIAL_USART3_8_PRIORITY);
#endif
#endif
}
 800bad0:	bd08      	pop	{r3, pc}
 800bad2:	bf00      	nop
 800bad4:	20001b20 	.word	0x20001b20
 800bad8:	0800ba71 	.word	0x0800ba71
 800badc:	40005000 	.word	0x40005000
 800bae0:	04c4b400 	.word	0x04c4b400
 800bae4:	f3af 8000 	nop.w
 800bae8:	f3af 8000 	nop.w
 800baec:	f3af 8000 	nop.w

0800baf0 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 800baf0:	b500      	push	{lr}
 800baf2:	b083      	sub	sp, #12
 800baf4:	9001      	str	r0, [sp, #4]
 800baf6:	9100      	str	r1, [sp, #0]

  if (config == NULL)
 800baf8:	9b00      	ldr	r3, [sp, #0]
 800bafa:	2b00      	cmp	r3, #0
 800bafc:	d101      	bne.n	800bb02 <sd_lld_start+0x12>
    config = &default_config;
 800bafe:	4b0b      	ldr	r3, [pc, #44]	; (800bb2c <sd_lld_start+0x3c>)
 800bb00:	9300      	str	r3, [sp, #0]

  if (sdp->state == SD_STOP) {
 800bb02:	9b01      	ldr	r3, [sp, #4]
 800bb04:	7a1b      	ldrb	r3, [r3, #8]
 800bb06:	2b01      	cmp	r3, #1
 800bb08:	d109      	bne.n	800bb1e <sd_lld_start+0x2e>
    if (&SD4 == sdp) {
      rccEnableUART4(FALSE);
    }
#endif
#if STM32_SERIAL_USE_UART5
    if (&SD5 == sdp) {
 800bb0a:	9a01      	ldr	r2, [sp, #4]
 800bb0c:	4b08      	ldr	r3, [pc, #32]	; (800bb30 <sd_lld_start+0x40>)
 800bb0e:	429a      	cmp	r2, r3
 800bb10:	d105      	bne.n	800bb1e <sd_lld_start+0x2e>
      rccEnableUART5(FALSE);
 800bb12:	4b08      	ldr	r3, [pc, #32]	; (800bb34 <sd_lld_start+0x44>)
 800bb14:	4a07      	ldr	r2, [pc, #28]	; (800bb34 <sd_lld_start+0x44>)
 800bb16:	6d92      	ldr	r2, [r2, #88]	; 0x58
 800bb18:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 800bb1c:	659a      	str	r2, [r3, #88]	; 0x58
    if (&LPSD1 == sdp) {
      rccEnableLPUART1(FALSE);
    }
#endif
  }
  usart_init(sdp, config);
 800bb1e:	9801      	ldr	r0, [sp, #4]
 800bb20:	9900      	ldr	r1, [sp, #0]
 800bb22:	f7ff fead 	bl	800b880 <usart_init>
}
 800bb26:	b003      	add	sp, #12
 800bb28:	f85d fb04 	ldr.w	pc, [sp], #4
 800bb2c:	080179f0 	.word	0x080179f0
 800bb30:	20001b20 	.word	0x20001b20
 800bb34:	40021000 	.word	0x40021000
 800bb38:	f3af 8000 	nop.w
 800bb3c:	f3af 8000 	nop.w

0800bb40 <sd_lld_stop>:
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 *
 * @notapi
 */
void sd_lld_stop(SerialDriver *sdp) {
 800bb40:	b500      	push	{lr}
 800bb42:	b083      	sub	sp, #12
 800bb44:	9001      	str	r0, [sp, #4]

  if (sdp->state == SD_READY) {
 800bb46:	9b01      	ldr	r3, [sp, #4]
 800bb48:	7a1b      	ldrb	r3, [r3, #8]
 800bb4a:	2b02      	cmp	r3, #2
 800bb4c:	d10f      	bne.n	800bb6e <sd_lld_stop+0x2e>
    /* UART is de-initialized then clocks are disabled.*/
    usart_deinit(sdp->usart);
 800bb4e:	9b01      	ldr	r3, [sp, #4]
 800bb50:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800bb52:	4618      	mov	r0, r3
 800bb54:	f7ff febc 	bl	800b8d0 <usart_deinit>
      rccDisableUART4(FALSE);
      return;
    }
#endif
#if STM32_SERIAL_USE_UART5
    if (&SD5 == sdp) {
 800bb58:	9a01      	ldr	r2, [sp, #4]
 800bb5a:	4b06      	ldr	r3, [pc, #24]	; (800bb74 <sd_lld_stop+0x34>)
 800bb5c:	429a      	cmp	r2, r3
 800bb5e:	d106      	bne.n	800bb6e <sd_lld_stop+0x2e>
      rccDisableUART5(FALSE);
 800bb60:	4b05      	ldr	r3, [pc, #20]	; (800bb78 <sd_lld_stop+0x38>)
 800bb62:	4a05      	ldr	r2, [pc, #20]	; (800bb78 <sd_lld_stop+0x38>)
 800bb64:	6d92      	ldr	r2, [r2, #88]	; 0x58
 800bb66:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 800bb6a:	659a      	str	r2, [r3, #88]	; 0x58
      return;
 800bb6c:	bf00      	nop
      rccDisableLPUART1(FALSE);
      return;
    }
#endif
  }
}
 800bb6e:	b003      	add	sp, #12
 800bb70:	f85d fb04 	ldr.w	pc, [sp], #4
 800bb74:	20001b20 	.word	0x20001b20
 800bb78:	40021000 	.word	0x40021000
 800bb7c:	f3af 8000 	nop.w

0800bb80 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 800bb80:	b508      	push	{r3, lr}

  stm32_clock_init();
 800bb82:	f7fb fce5 	bl	8007550 <stm32_clock_init>
}
 800bb86:	bd08      	pop	{r3, pc}
 800bb88:	f3af 8000 	nop.w
 800bb8c:	f3af 8000 	nop.w

0800bb90 <sdc_lld_is_card_inserted>:

#if HAL_USE_SDC || defined(__DOXYGEN__)
/**
 * @brief   SDC card detection.
 */
bool sdc_lld_is_card_inserted(SDCDriver *sdcp) {
 800bb90:	b082      	sub	sp, #8
 800bb92:	9001      	str	r0, [sp, #4]

  (void)sdcp;
  /* TODO: Fill the implementation.*/
  return true;
 800bb94:	2301      	movs	r3, #1
}
 800bb96:	4618      	mov	r0, r3
 800bb98:	b002      	add	sp, #8
 800bb9a:	4770      	bx	lr
 800bb9c:	f3af 8000 	nop.w

0800bba0 <sdc_lld_is_write_protected>:

/**
 * @brief   SDC card write protection detection.
 */
bool sdc_lld_is_write_protected(SDCDriver *sdcp) {
 800bba0:	b082      	sub	sp, #8
 800bba2:	9001      	str	r0, [sp, #4]

  (void)sdcp;
  /* TODO: Fill the implementation.*/
  return false;
 800bba4:	2300      	movs	r3, #0
}
 800bba6:	4618      	mov	r0, r3
 800bba8:	b002      	add	sp, #8
 800bbaa:	4770      	bx	lr
 800bbac:	f3af 8000 	nop.w

0800bbb0 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
 800bbb0:	4770      	bx	lr
 800bbb2:	bf00      	nop
 800bbb4:	f3af 8000 	nop.w
 800bbb8:	f3af 8000 	nop.w
 800bbbc:	f3af 8000 	nop.w

0800bbc0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800bbc0:	b082      	sub	sp, #8
 800bbc2:	2320      	movs	r3, #32
 800bbc4:	9301      	str	r3, [sp, #4]
 800bbc6:	9b01      	ldr	r3, [sp, #4]
 800bbc8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800bbcc:	b002      	add	sp, #8
 800bbce:	4770      	bx	lr

0800bbd0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800bbd0:	b082      	sub	sp, #8
 800bbd2:	2300      	movs	r3, #0
 800bbd4:	9301      	str	r3, [sp, #4]
 800bbd6:	9b01      	ldr	r3, [sp, #4]
 800bbd8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800bbdc:	b002      	add	sp, #8
 800bbde:	4770      	bx	lr

0800bbe0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800bbe0:	b508      	push	{r3, lr}

  port_lock();
 800bbe2:	f7ff ffed 	bl	800bbc0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800bbe6:	bd08      	pop	{r3, pc}
 800bbe8:	f3af 8000 	nop.w
 800bbec:	f3af 8000 	nop.w

0800bbf0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800bbf0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800bbf2:	f7ff ffed 	bl	800bbd0 <port_unlock>
}
 800bbf6:	bd08      	pop	{r3, pc}
 800bbf8:	f3af 8000 	nop.w
 800bbfc:	f3af 8000 	nop.w

0800bc00 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 800bc00:	4b01      	ldr	r3, [pc, #4]	; (800bc08 <chVTGetSystemTimeX+0x8>)
 800bc02:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800bc04:	4618      	mov	r0, r3
 800bc06:	4770      	bx	lr
 800bc08:	200016e0 	.word	0x200016e0
 800bc0c:	f3af 8000 	nop.w

0800bc10 <chVTGetSystemTime>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 800bc10:	b500      	push	{lr}
 800bc12:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 800bc14:	f7ff ffe4 	bl	800bbe0 <chSysLock>
  systime = chVTGetSystemTimeX();
 800bc18:	f7ff fff2 	bl	800bc00 <chVTGetSystemTimeX>
 800bc1c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 800bc1e:	f7ff ffe7 	bl	800bbf0 <chSysUnlock>

  return systime;
 800bc22:	9b01      	ldr	r3, [sp, #4]
}
 800bc24:	4618      	mov	r0, r3
 800bc26:	b003      	add	sp, #12
 800bc28:	f85d fb04 	ldr.w	pc, [sp], #4
 800bc2c:	f3af 8000 	nop.w

0800bc30 <chVTIsTimeWithinX>:
 *
 * @xclass
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {
 800bc30:	b084      	sub	sp, #16
 800bc32:	9003      	str	r0, [sp, #12]
 800bc34:	9102      	str	r1, [sp, #8]
 800bc36:	9201      	str	r2, [sp, #4]

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 800bc38:	9a03      	ldr	r2, [sp, #12]
 800bc3a:	9b02      	ldr	r3, [sp, #8]
 800bc3c:	1ad2      	subs	r2, r2, r3
 800bc3e:	9901      	ldr	r1, [sp, #4]
 800bc40:	9b02      	ldr	r3, [sp, #8]
 800bc42:	1acb      	subs	r3, r1, r3
 800bc44:	429a      	cmp	r2, r3
 800bc46:	bf2c      	ite	cs
 800bc48:	2300      	movcs	r3, #0
 800bc4a:	2301      	movcc	r3, #1
 800bc4c:	b2db      	uxtb	r3, r3
}
 800bc4e:	4618      	mov	r0, r3
 800bc50:	b004      	add	sp, #16
 800bc52:	4770      	bx	lr
 800bc54:	f3af 8000 	nop.w
 800bc58:	f3af 8000 	nop.w
 800bc5c:	f3af 8000 	nop.w

0800bc60 <chVTIsSystemTimeWithin>:
 * @retval true         current time within the specified time window.
 * @retval false        current time not within the specified time window.
 *
 * @api
 */
static inline bool chVTIsSystemTimeWithin(systime_t start, systime_t end) {
 800bc60:	b500      	push	{lr}
 800bc62:	b083      	sub	sp, #12
 800bc64:	9001      	str	r0, [sp, #4]
 800bc66:	9100      	str	r1, [sp, #0]

  return chVTIsTimeWithinX(chVTGetSystemTime(), start, end);
 800bc68:	f7ff ffd2 	bl	800bc10 <chVTGetSystemTime>
 800bc6c:	4603      	mov	r3, r0
 800bc6e:	4618      	mov	r0, r3
 800bc70:	9901      	ldr	r1, [sp, #4]
 800bc72:	9a00      	ldr	r2, [sp, #0]
 800bc74:	f7ff ffdc 	bl	800bc30 <chVTIsTimeWithinX>
 800bc78:	4603      	mov	r3, r0
}
 800bc7a:	4618      	mov	r0, r3
 800bc7c:	b003      	add	sp, #12
 800bc7e:	f85d fb04 	ldr.w	pc, [sp], #4
 800bc82:	bf00      	nop
 800bc84:	f3af 8000 	nop.w
 800bc88:	f3af 8000 	nop.w
 800bc8c:	f3af 8000 	nop.w

0800bc90 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 800bc90:	b082      	sub	sp, #8
 800bc92:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->vt_func != NULL);
 800bc94:	9b01      	ldr	r3, [sp, #4]
 800bc96:	68db      	ldr	r3, [r3, #12]
 800bc98:	2b00      	cmp	r3, #0
 800bc9a:	bf0c      	ite	eq
 800bc9c:	2300      	moveq	r3, #0
 800bc9e:	2301      	movne	r3, #1
 800bca0:	b2db      	uxtb	r3, r3
}
 800bca2:	4618      	mov	r0, r3
 800bca4:	b002      	add	sp, #8
 800bca6:	4770      	bx	lr
 800bca8:	f3af 8000 	nop.w
 800bcac:	f3af 8000 	nop.w

0800bcb0 <chVTResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {
 800bcb0:	b500      	push	{lr}
 800bcb2:	b083      	sub	sp, #12
 800bcb4:	9001      	str	r0, [sp, #4]

  if (chVTIsArmedI(vtp)) {
 800bcb6:	9801      	ldr	r0, [sp, #4]
 800bcb8:	f7ff ffea 	bl	800bc90 <chVTIsArmedI>
 800bcbc:	4603      	mov	r3, r0
 800bcbe:	2b00      	cmp	r3, #0
 800bcc0:	d002      	beq.n	800bcc8 <chVTResetI+0x18>
    chVTDoResetI(vtp);
 800bcc2:	9801      	ldr	r0, [sp, #4]
 800bcc4:	f7f4 fea4 	bl	8000a10 <chVTDoResetI>
  }
}
 800bcc8:	b003      	add	sp, #12
 800bcca:	f85d fb04 	ldr.w	pc, [sp], #4
 800bcce:	bf00      	nop

0800bcd0 <chVTSetI>:
 *                      function
 *
 * @iclass
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {
 800bcd0:	b500      	push	{lr}
 800bcd2:	b085      	sub	sp, #20
 800bcd4:	9003      	str	r0, [sp, #12]
 800bcd6:	9102      	str	r1, [sp, #8]
 800bcd8:	9201      	str	r2, [sp, #4]
 800bcda:	9300      	str	r3, [sp, #0]

  chVTResetI(vtp);
 800bcdc:	9803      	ldr	r0, [sp, #12]
 800bcde:	f7ff ffe7 	bl	800bcb0 <chVTResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
 800bce2:	9803      	ldr	r0, [sp, #12]
 800bce4:	9902      	ldr	r1, [sp, #8]
 800bce6:	9a01      	ldr	r2, [sp, #4]
 800bce8:	9b00      	ldr	r3, [sp, #0]
 800bcea:	f7f4 fe51 	bl	8000990 <chVTDoSetI>
}
 800bcee:	b005      	add	sp, #20
 800bcf0:	f85d fb04 	ldr.w	pc, [sp], #4
 800bcf4:	f3af 8000 	nop.w
 800bcf8:	f3af 8000 	nop.w
 800bcfc:	f3af 8000 	nop.w

0800bd00 <chVTSet>:
 *                      function
 *
 * @api
 */
static inline void chVTSet(virtual_timer_t *vtp, systime_t delay,
                           vtfunc_t vtfunc, void *par) {
 800bd00:	b500      	push	{lr}
 800bd02:	b085      	sub	sp, #20
 800bd04:	9003      	str	r0, [sp, #12]
 800bd06:	9102      	str	r1, [sp, #8]
 800bd08:	9201      	str	r2, [sp, #4]
 800bd0a:	9300      	str	r3, [sp, #0]

  chSysLock();
 800bd0c:	f7ff ff68 	bl	800bbe0 <chSysLock>
  chVTSetI(vtp, delay, vtfunc, par);
 800bd10:	9803      	ldr	r0, [sp, #12]
 800bd12:	9902      	ldr	r1, [sp, #8]
 800bd14:	9a01      	ldr	r2, [sp, #4]
 800bd16:	9b00      	ldr	r3, [sp, #0]
 800bd18:	f7ff ffda 	bl	800bcd0 <chVTSetI>
  chSysUnlock();
 800bd1c:	f7ff ff68 	bl	800bbf0 <chSysUnlock>
}
 800bd20:	b005      	add	sp, #20
 800bd22:	f85d fb04 	ldr.w	pc, [sp], #4
 800bd26:	bf00      	nop
 800bd28:	f3af 8000 	nop.w
 800bd2c:	f3af 8000 	nop.w

0800bd30 <test_printn>:
/**
 * @brief   Prints a decimal unsigned number.
 *
 * @param[in] n         the number to be printed
 */
void test_printn(uint32_t n) {
 800bd30:	b500      	push	{lr}
 800bd32:	b089      	sub	sp, #36	; 0x24
 800bd34:	9001      	str	r0, [sp, #4]
  char buf[16], *p;

  if (!n)
 800bd36:	9b01      	ldr	r3, [sp, #4]
 800bd38:	2b00      	cmp	r3, #0
 800bd3a:	d109      	bne.n	800bd50 <test_printn+0x20>
    chSequentialStreamPut(chp, '0');
 800bd3c:	4b1e      	ldr	r3, [pc, #120]	; (800bdb8 <test_printn+0x88>)
 800bd3e:	681b      	ldr	r3, [r3, #0]
 800bd40:	681b      	ldr	r3, [r3, #0]
 800bd42:	689b      	ldr	r3, [r3, #8]
 800bd44:	4a1c      	ldr	r2, [pc, #112]	; (800bdb8 <test_printn+0x88>)
 800bd46:	6812      	ldr	r2, [r2, #0]
 800bd48:	4610      	mov	r0, r2
 800bd4a:	2130      	movs	r1, #48	; 0x30
 800bd4c:	4798      	blx	r3
 800bd4e:	e02f      	b.n	800bdb0 <test_printn+0x80>
  else {
    p = buf;
 800bd50:	ab03      	add	r3, sp, #12
 800bd52:	9307      	str	r3, [sp, #28]
    while (n)
 800bd54:	e016      	b.n	800bd84 <test_printn+0x54>
      *p++ = (n % 10) + '0', n /= 10;
 800bd56:	9907      	ldr	r1, [sp, #28]
 800bd58:	1c4b      	adds	r3, r1, #1
 800bd5a:	9307      	str	r3, [sp, #28]
 800bd5c:	9801      	ldr	r0, [sp, #4]
 800bd5e:	4b17      	ldr	r3, [pc, #92]	; (800bdbc <test_printn+0x8c>)
 800bd60:	fba3 2300 	umull	r2, r3, r3, r0
 800bd64:	08da      	lsrs	r2, r3, #3
 800bd66:	4613      	mov	r3, r2
 800bd68:	009b      	lsls	r3, r3, #2
 800bd6a:	4413      	add	r3, r2
 800bd6c:	005b      	lsls	r3, r3, #1
 800bd6e:	1ac2      	subs	r2, r0, r3
 800bd70:	b2d3      	uxtb	r3, r2
 800bd72:	3330      	adds	r3, #48	; 0x30
 800bd74:	b2db      	uxtb	r3, r3
 800bd76:	700b      	strb	r3, [r1, #0]
 800bd78:	9a01      	ldr	r2, [sp, #4]
 800bd7a:	4b10      	ldr	r3, [pc, #64]	; (800bdbc <test_printn+0x8c>)
 800bd7c:	fba3 1302 	umull	r1, r3, r3, r2
 800bd80:	08db      	lsrs	r3, r3, #3
 800bd82:	9301      	str	r3, [sp, #4]

  if (!n)
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
 800bd84:	9b01      	ldr	r3, [sp, #4]
 800bd86:	2b00      	cmp	r3, #0
 800bd88:	d1e5      	bne.n	800bd56 <test_printn+0x26>
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 800bd8a:	e00d      	b.n	800bda8 <test_printn+0x78>
      chSequentialStreamPut(chp, *--p);
 800bd8c:	4b0a      	ldr	r3, [pc, #40]	; (800bdb8 <test_printn+0x88>)
 800bd8e:	681b      	ldr	r3, [r3, #0]
 800bd90:	681b      	ldr	r3, [r3, #0]
 800bd92:	689b      	ldr	r3, [r3, #8]
 800bd94:	4a08      	ldr	r2, [pc, #32]	; (800bdb8 <test_printn+0x88>)
 800bd96:	6811      	ldr	r1, [r2, #0]
 800bd98:	9a07      	ldr	r2, [sp, #28]
 800bd9a:	3a01      	subs	r2, #1
 800bd9c:	9207      	str	r2, [sp, #28]
 800bd9e:	9a07      	ldr	r2, [sp, #28]
 800bda0:	7812      	ldrb	r2, [r2, #0]
 800bda2:	4608      	mov	r0, r1
 800bda4:	4611      	mov	r1, r2
 800bda6:	4798      	blx	r3
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 800bda8:	ab03      	add	r3, sp, #12
 800bdaa:	9a07      	ldr	r2, [sp, #28]
 800bdac:	429a      	cmp	r2, r3
 800bdae:	d8ed      	bhi.n	800bd8c <test_printn+0x5c>
      chSequentialStreamPut(chp, *--p);
  }
}
 800bdb0:	b009      	add	sp, #36	; 0x24
 800bdb2:	f85d fb04 	ldr.w	pc, [sp], #4
 800bdb6:	bf00      	nop
 800bdb8:	20000fac 	.word	0x20000fac
 800bdbc:	cccccccd 	.word	0xcccccccd

0800bdc0 <test_print>:
/**
 * @brief   Prints a line without final end-of-line.
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {
 800bdc0:	b500      	push	{lr}
 800bdc2:	b083      	sub	sp, #12
 800bdc4:	9001      	str	r0, [sp, #4]

  while (*msgp)
 800bdc6:	e00c      	b.n	800bde2 <test_print+0x22>
    chSequentialStreamPut(chp, *msgp++);
 800bdc8:	4b09      	ldr	r3, [pc, #36]	; (800bdf0 <test_print+0x30>)
 800bdca:	681b      	ldr	r3, [r3, #0]
 800bdcc:	681b      	ldr	r3, [r3, #0]
 800bdce:	689a      	ldr	r2, [r3, #8]
 800bdd0:	4b07      	ldr	r3, [pc, #28]	; (800bdf0 <test_print+0x30>)
 800bdd2:	6819      	ldr	r1, [r3, #0]
 800bdd4:	9b01      	ldr	r3, [sp, #4]
 800bdd6:	1c58      	adds	r0, r3, #1
 800bdd8:	9001      	str	r0, [sp, #4]
 800bdda:	781b      	ldrb	r3, [r3, #0]
 800bddc:	4608      	mov	r0, r1
 800bdde:	4619      	mov	r1, r3
 800bde0:	4790      	blx	r2
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 800bde2:	9b01      	ldr	r3, [sp, #4]
 800bde4:	781b      	ldrb	r3, [r3, #0]
 800bde6:	2b00      	cmp	r3, #0
 800bde8:	d1ee      	bne.n	800bdc8 <test_print+0x8>
    chSequentialStreamPut(chp, *msgp++);
}
 800bdea:	b003      	add	sp, #12
 800bdec:	f85d fb04 	ldr.w	pc, [sp], #4
 800bdf0:	20000fac 	.word	0x20000fac
 800bdf4:	f3af 8000 	nop.w
 800bdf8:	f3af 8000 	nop.w
 800bdfc:	f3af 8000 	nop.w

0800be00 <test_println>:
/**
 * @brief   Prints a line.
 *
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {
 800be00:	b500      	push	{lr}
 800be02:	b083      	sub	sp, #12
 800be04:	9001      	str	r0, [sp, #4]

  test_print(msgp);
 800be06:	9801      	ldr	r0, [sp, #4]
 800be08:	f7ff ffda 	bl	800bdc0 <test_print>
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 800be0c:	4b06      	ldr	r3, [pc, #24]	; (800be28 <test_println+0x28>)
 800be0e:	681b      	ldr	r3, [r3, #0]
 800be10:	681b      	ldr	r3, [r3, #0]
 800be12:	681b      	ldr	r3, [r3, #0]
 800be14:	4a04      	ldr	r2, [pc, #16]	; (800be28 <test_println+0x28>)
 800be16:	6812      	ldr	r2, [r2, #0]
 800be18:	4610      	mov	r0, r2
 800be1a:	4904      	ldr	r1, [pc, #16]	; (800be2c <test_println+0x2c>)
 800be1c:	2202      	movs	r2, #2
 800be1e:	4798      	blx	r3
}
 800be20:	b003      	add	sp, #12
 800be22:	f85d fb04 	ldr.w	pc, [sp], #4
 800be26:	bf00      	nop
 800be28:	20000fac 	.word	0x20000fac
 800be2c:	08017b34 	.word	0x08017b34

0800be30 <clear_tokens>:
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 800be30:	4b01      	ldr	r3, [pc, #4]	; (800be38 <clear_tokens+0x8>)
 800be32:	4a02      	ldr	r2, [pc, #8]	; (800be3c <clear_tokens+0xc>)
 800be34:	601a      	str	r2, [r3, #0]
}
 800be36:	4770      	bx	lr
 800be38:	20000fa8 	.word	0x20000fa8
 800be3c:	20000f98 	.word	0x20000f98

0800be40 <print_tokens>:

static void print_tokens(void) {
 800be40:	b500      	push	{lr}
 800be42:	b083      	sub	sp, #12
  char *cp = tokens_buffer;
 800be44:	4b0b      	ldr	r3, [pc, #44]	; (800be74 <print_tokens+0x34>)
 800be46:	9301      	str	r3, [sp, #4]

  while (cp < tokp)
 800be48:	e00c      	b.n	800be64 <print_tokens+0x24>
    chSequentialStreamPut(chp, *cp++);
 800be4a:	4b0b      	ldr	r3, [pc, #44]	; (800be78 <print_tokens+0x38>)
 800be4c:	681b      	ldr	r3, [r3, #0]
 800be4e:	681b      	ldr	r3, [r3, #0]
 800be50:	689a      	ldr	r2, [r3, #8]
 800be52:	4b09      	ldr	r3, [pc, #36]	; (800be78 <print_tokens+0x38>)
 800be54:	6819      	ldr	r1, [r3, #0]
 800be56:	9b01      	ldr	r3, [sp, #4]
 800be58:	1c58      	adds	r0, r3, #1
 800be5a:	9001      	str	r0, [sp, #4]
 800be5c:	781b      	ldrb	r3, [r3, #0]
 800be5e:	4608      	mov	r0, r1
 800be60:	4619      	mov	r1, r3
 800be62:	4790      	blx	r2
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 800be64:	4b05      	ldr	r3, [pc, #20]	; (800be7c <print_tokens+0x3c>)
 800be66:	681b      	ldr	r3, [r3, #0]
 800be68:	9a01      	ldr	r2, [sp, #4]
 800be6a:	429a      	cmp	r2, r3
 800be6c:	d3ed      	bcc.n	800be4a <print_tokens+0xa>
    chSequentialStreamPut(chp, *cp++);
}
 800be6e:	b003      	add	sp, #12
 800be70:	f85d fb04 	ldr.w	pc, [sp], #4
 800be74:	20000f98 	.word	0x20000f98
 800be78:	20000fac 	.word	0x20000fac
 800be7c:	20000fa8 	.word	0x20000fa8

0800be80 <test_emit_token>:
/**
 * @brief   Emits a token into the tokens buffer.
 *
 * @param[in] token     the token as a char
 */
void test_emit_token(char token) {
 800be80:	b500      	push	{lr}
 800be82:	b083      	sub	sp, #12
 800be84:	4603      	mov	r3, r0
 800be86:	f88d 3007 	strb.w	r3, [sp, #7]

  chSysLock();
 800be8a:	f7ff fea9 	bl	800bbe0 <chSysLock>
  *tokp++ = token;
 800be8e:	4b06      	ldr	r3, [pc, #24]	; (800bea8 <test_emit_token+0x28>)
 800be90:	681b      	ldr	r3, [r3, #0]
 800be92:	1c59      	adds	r1, r3, #1
 800be94:	4a04      	ldr	r2, [pc, #16]	; (800bea8 <test_emit_token+0x28>)
 800be96:	6011      	str	r1, [r2, #0]
 800be98:	f89d 2007 	ldrb.w	r2, [sp, #7]
 800be9c:	701a      	strb	r2, [r3, #0]
  chSysUnlock();
 800be9e:	f7ff fea7 	bl	800bbf0 <chSysUnlock>
}
 800bea2:	b003      	add	sp, #12
 800bea4:	f85d fb04 	ldr.w	pc, [sp], #4
 800bea8:	20000fa8 	.word	0x20000fa8
 800beac:	f3af 8000 	nop.w

0800beb0 <_test_fail>:

/*
 * Assertions.
 */
bool _test_fail(unsigned point) {
 800beb0:	b082      	sub	sp, #8
 800beb2:	9001      	str	r0, [sp, #4]

  test_global_fail = TRUE;
 800beb4:	4b06      	ldr	r3, [pc, #24]	; (800bed0 <_test_fail+0x20>)
 800beb6:	2201      	movs	r2, #1
 800beb8:	701a      	strb	r2, [r3, #0]
  local_fail = TRUE;
 800beba:	4b06      	ldr	r3, [pc, #24]	; (800bed4 <_test_fail+0x24>)
 800bebc:	2201      	movs	r2, #1
 800bebe:	701a      	strb	r2, [r3, #0]
  failpoint = point;
 800bec0:	4b05      	ldr	r3, [pc, #20]	; (800bed8 <_test_fail+0x28>)
 800bec2:	9a01      	ldr	r2, [sp, #4]
 800bec4:	601a      	str	r2, [r3, #0]
  return TRUE;
 800bec6:	2301      	movs	r3, #1
}
 800bec8:	4618      	mov	r0, r3
 800beca:	b002      	add	sp, #8
 800becc:	4770      	bx	lr
 800bece:	bf00      	nop
 800bed0:	20001ba0 	.word	0x20001ba0
 800bed4:	20000f90 	.word	0x20000f90
 800bed8:	20000f94 	.word	0x20000f94
 800bedc:	f3af 8000 	nop.w

0800bee0 <_test_assert>:

bool _test_assert(unsigned point, bool condition) {
 800bee0:	b500      	push	{lr}
 800bee2:	b083      	sub	sp, #12
 800bee4:	9001      	str	r0, [sp, #4]
 800bee6:	460b      	mov	r3, r1
 800bee8:	f88d 3003 	strb.w	r3, [sp, #3]

  if (!condition)
 800beec:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800bef0:	f083 0301 	eor.w	r3, r3, #1
 800bef4:	b2db      	uxtb	r3, r3
 800bef6:	2b00      	cmp	r3, #0
 800bef8:	d004      	beq.n	800bf04 <_test_assert+0x24>
    return _test_fail(point);
 800befa:	9801      	ldr	r0, [sp, #4]
 800befc:	f7ff ffd8 	bl	800beb0 <_test_fail>
 800bf00:	4603      	mov	r3, r0
 800bf02:	e000      	b.n	800bf06 <_test_assert+0x26>
  return FALSE;
 800bf04:	2300      	movs	r3, #0
}
 800bf06:	4618      	mov	r0, r3
 800bf08:	b003      	add	sp, #12
 800bf0a:	f85d fb04 	ldr.w	pc, [sp], #4
 800bf0e:	bf00      	nop

0800bf10 <_test_assert_sequence>:

bool _test_assert_sequence(unsigned point, char *expected) {
 800bf10:	b500      	push	{lr}
 800bf12:	b085      	sub	sp, #20
 800bf14:	9001      	str	r0, [sp, #4]
 800bf16:	9100      	str	r1, [sp, #0]
  char *cp = tokens_buffer;
 800bf18:	4b13      	ldr	r3, [pc, #76]	; (800bf68 <_test_assert_sequence+0x58>)
 800bf1a:	9303      	str	r3, [sp, #12]
  while (cp < tokp) {
 800bf1c:	e00e      	b.n	800bf3c <_test_assert_sequence+0x2c>
    if (*cp++ != *expected++)
 800bf1e:	9b03      	ldr	r3, [sp, #12]
 800bf20:	1c5a      	adds	r2, r3, #1
 800bf22:	9203      	str	r2, [sp, #12]
 800bf24:	781a      	ldrb	r2, [r3, #0]
 800bf26:	9b00      	ldr	r3, [sp, #0]
 800bf28:	1c59      	adds	r1, r3, #1
 800bf2a:	9100      	str	r1, [sp, #0]
 800bf2c:	781b      	ldrb	r3, [r3, #0]
 800bf2e:	429a      	cmp	r2, r3
 800bf30:	d004      	beq.n	800bf3c <_test_assert_sequence+0x2c>
     return _test_fail(point);
 800bf32:	9801      	ldr	r0, [sp, #4]
 800bf34:	f7ff ffbc 	bl	800beb0 <_test_fail>
 800bf38:	4603      	mov	r3, r0
 800bf3a:	e010      	b.n	800bf5e <_test_assert_sequence+0x4e>
  return FALSE;
}

bool _test_assert_sequence(unsigned point, char *expected) {
  char *cp = tokens_buffer;
  while (cp < tokp) {
 800bf3c:	4b0b      	ldr	r3, [pc, #44]	; (800bf6c <_test_assert_sequence+0x5c>)
 800bf3e:	681b      	ldr	r3, [r3, #0]
 800bf40:	9a03      	ldr	r2, [sp, #12]
 800bf42:	429a      	cmp	r2, r3
 800bf44:	d3eb      	bcc.n	800bf1e <_test_assert_sequence+0xe>
    if (*cp++ != *expected++)
     return _test_fail(point);
  }
  if (*expected)
 800bf46:	9b00      	ldr	r3, [sp, #0]
 800bf48:	781b      	ldrb	r3, [r3, #0]
 800bf4a:	2b00      	cmp	r3, #0
 800bf4c:	d004      	beq.n	800bf58 <_test_assert_sequence+0x48>
    return _test_fail(point);
 800bf4e:	9801      	ldr	r0, [sp, #4]
 800bf50:	f7ff ffae 	bl	800beb0 <_test_fail>
 800bf54:	4603      	mov	r3, r0
 800bf56:	e002      	b.n	800bf5e <_test_assert_sequence+0x4e>
  clear_tokens();
 800bf58:	f7ff ff6a 	bl	800be30 <clear_tokens>
  return FALSE;
 800bf5c:	2300      	movs	r3, #0
}
 800bf5e:	4618      	mov	r0, r3
 800bf60:	b005      	add	sp, #20
 800bf62:	f85d fb04 	ldr.w	pc, [sp], #4
 800bf66:	bf00      	nop
 800bf68:	20000f98 	.word	0x20000f98
 800bf6c:	20000fa8 	.word	0x20000fa8

0800bf70 <_test_assert_time_window>:

bool _test_assert_time_window(unsigned point, systime_t start, systime_t end) {
 800bf70:	b500      	push	{lr}
 800bf72:	b085      	sub	sp, #20
 800bf74:	9003      	str	r0, [sp, #12]
 800bf76:	9102      	str	r1, [sp, #8]
 800bf78:	9201      	str	r2, [sp, #4]

  return _test_assert(point, chVTIsSystemTimeWithin(start, end));
 800bf7a:	9802      	ldr	r0, [sp, #8]
 800bf7c:	9901      	ldr	r1, [sp, #4]
 800bf7e:	f7ff fe6f 	bl	800bc60 <chVTIsSystemTimeWithin>
 800bf82:	4603      	mov	r3, r0
 800bf84:	9803      	ldr	r0, [sp, #12]
 800bf86:	4619      	mov	r1, r3
 800bf88:	f7ff ffaa 	bl	800bee0 <_test_assert>
 800bf8c:	4603      	mov	r3, r0
}
 800bf8e:	4618      	mov	r0, r3
 800bf90:	b005      	add	sp, #20
 800bf92:	f85d fb04 	ldr.w	pc, [sp], #4
 800bf96:	bf00      	nop
 800bf98:	f3af 8000 	nop.w
 800bf9c:	f3af 8000 	nop.w

0800bfa0 <test_terminate_threads>:
 */

/**
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
 800bfa0:	b500      	push	{lr}
 800bfa2:	b083      	sub	sp, #12
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 800bfa4:	2300      	movs	r3, #0
 800bfa6:	9301      	str	r3, [sp, #4]
 800bfa8:	e00f      	b.n	800bfca <test_terminate_threads+0x2a>
    if (threads[i])
 800bfaa:	4b0b      	ldr	r3, [pc, #44]	; (800bfd8 <test_terminate_threads+0x38>)
 800bfac:	9a01      	ldr	r2, [sp, #4]
 800bfae:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800bfb2:	2b00      	cmp	r3, #0
 800bfb4:	d006      	beq.n	800bfc4 <test_terminate_threads+0x24>
      chThdTerminate(threads[i]);
 800bfb6:	4b08      	ldr	r3, [pc, #32]	; (800bfd8 <test_terminate_threads+0x38>)
 800bfb8:	9a01      	ldr	r2, [sp, #4]
 800bfba:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800bfbe:	4618      	mov	r0, r3
 800bfc0:	f7f5 f96e 	bl	80012a0 <chThdTerminate>
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 800bfc4:	9b01      	ldr	r3, [sp, #4]
 800bfc6:	3301      	adds	r3, #1
 800bfc8:	9301      	str	r3, [sp, #4]
 800bfca:	9b01      	ldr	r3, [sp, #4]
 800bfcc:	2b04      	cmp	r3, #4
 800bfce:	ddec      	ble.n	800bfaa <test_terminate_threads+0xa>
    if (threads[i])
      chThdTerminate(threads[i]);
}
 800bfd0:	b003      	add	sp, #12
 800bfd2:	f85d fb04 	ldr.w	pc, [sp], #4
 800bfd6:	bf00      	nop
 800bfd8:	20001ba4 	.word	0x20001ba4
 800bfdc:	f3af 8000 	nop.w

0800bfe0 <test_wait_threads>:

/**
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
 800bfe0:	b500      	push	{lr}
 800bfe2:	b083      	sub	sp, #12
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 800bfe4:	2300      	movs	r3, #0
 800bfe6:	9301      	str	r3, [sp, #4]
 800bfe8:	e014      	b.n	800c014 <test_wait_threads+0x34>
    if (threads[i] != NULL) {
 800bfea:	4b0d      	ldr	r3, [pc, #52]	; (800c020 <test_wait_threads+0x40>)
 800bfec:	9a01      	ldr	r2, [sp, #4]
 800bfee:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800bff2:	2b00      	cmp	r3, #0
 800bff4:	d00b      	beq.n	800c00e <test_wait_threads+0x2e>
      chThdWait(threads[i]);
 800bff6:	4b0a      	ldr	r3, [pc, #40]	; (800c020 <test_wait_threads+0x40>)
 800bff8:	9a01      	ldr	r2, [sp, #4]
 800bffa:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800bffe:	4618      	mov	r0, r3
 800c000:	f7f5 f9fe 	bl	8001400 <chThdWait>
      threads[i] = NULL;
 800c004:	4b06      	ldr	r3, [pc, #24]	; (800c020 <test_wait_threads+0x40>)
 800c006:	9a01      	ldr	r2, [sp, #4]
 800c008:	2100      	movs	r1, #0
 800c00a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 800c00e:	9b01      	ldr	r3, [sp, #4]
 800c010:	3301      	adds	r3, #1
 800c012:	9301      	str	r3, [sp, #4]
 800c014:	9b01      	ldr	r3, [sp, #4]
 800c016:	2b04      	cmp	r3, #4
 800c018:	dde7      	ble.n	800bfea <test_wait_threads+0xa>
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
    }
}
 800c01a:	b003      	add	sp, #12
 800c01c:	f85d fb04 	ldr.w	pc, [sp], #4
 800c020:	20001ba4 	.word	0x20001ba4
 800c024:	f3af 8000 	nop.w
 800c028:	f3af 8000 	nop.w
 800c02c:	f3af 8000 	nop.w

0800c030 <test_wait_tick>:
/**
 * @brief   Delays execution until next system time tick.
 *
 * @return              The system time.
 */
systime_t test_wait_tick(void) {
 800c030:	b508      	push	{r3, lr}

  chThdSleep(1);
 800c032:	2001      	movs	r0, #1
 800c034:	f7f5 f94c 	bl	80012d0 <chThdSleep>
  return chVTGetSystemTime();
 800c038:	f7ff fdea 	bl	800bc10 <chVTGetSystemTime>
 800c03c:	4603      	mov	r3, r0
}
 800c03e:	4618      	mov	r0, r3
 800c040:	bd08      	pop	{r3, pc}
 800c042:	bf00      	nop
 800c044:	f3af 8000 	nop.w
 800c048:	f3af 8000 	nop.w
 800c04c:	f3af 8000 	nop.w

0800c050 <tmr>:
 * @brief   Set to @p TRUE when the test timer reaches its deadline.
 */
bool test_timer_done;

static virtual_timer_t vt;
static void tmr(void *p) {
 800c050:	b082      	sub	sp, #8
 800c052:	9001      	str	r0, [sp, #4]
  (void)p;

  test_timer_done = TRUE;
 800c054:	4b02      	ldr	r3, [pc, #8]	; (800c060 <tmr+0x10>)
 800c056:	2201      	movs	r2, #1
 800c058:	701a      	strb	r2, [r3, #0]
}
 800c05a:	b002      	add	sp, #8
 800c05c:	4770      	bx	lr
 800c05e:	bf00      	nop
 800c060:	20001ba1 	.word	0x20001ba1
 800c064:	f3af 8000 	nop.w
 800c068:	f3af 8000 	nop.w
 800c06c:	f3af 8000 	nop.w

0800c070 <test_start_timer>:
/**
 * @brief   Starts the test timer.
 *
 * @param[in] ms        time in milliseconds
 */
void test_start_timer(unsigned ms) {
 800c070:	b500      	push	{lr}
 800c072:	b085      	sub	sp, #20
 800c074:	9001      	str	r0, [sp, #4]

  systime_t duration = MS2ST(ms);
 800c076:	9b01      	ldr	r3, [sp, #4]
 800c078:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800c07c:	fb02 f303 	mul.w	r3, r2, r3
 800c080:	f203 32e7 	addw	r2, r3, #999	; 0x3e7
 800c084:	4b08      	ldr	r3, [pc, #32]	; (800c0a8 <test_start_timer+0x38>)
 800c086:	fba3 1302 	umull	r1, r3, r3, r2
 800c08a:	099b      	lsrs	r3, r3, #6
 800c08c:	9303      	str	r3, [sp, #12]
  test_timer_done = FALSE;
 800c08e:	4b07      	ldr	r3, [pc, #28]	; (800c0ac <test_start_timer+0x3c>)
 800c090:	2200      	movs	r2, #0
 800c092:	701a      	strb	r2, [r3, #0]
  chVTSet(&vt, duration, tmr, NULL);
 800c094:	4806      	ldr	r0, [pc, #24]	; (800c0b0 <test_start_timer+0x40>)
 800c096:	9903      	ldr	r1, [sp, #12]
 800c098:	4a06      	ldr	r2, [pc, #24]	; (800c0b4 <test_start_timer+0x44>)
 800c09a:	2300      	movs	r3, #0
 800c09c:	f7ff fe30 	bl	800bd00 <chVTSet>
}
 800c0a0:	b005      	add	sp, #20
 800c0a2:	f85d fb04 	ldr.w	pc, [sp], #4
 800c0a6:	bf00      	nop
 800c0a8:	10624dd3 	.word	0x10624dd3
 800c0ac:	20001ba1 	.word	0x20001ba1
 800c0b0:	20000fb0 	.word	0x20000fb0
 800c0b4:	0800c051 	.word	0x0800c051
 800c0b8:	f3af 8000 	nop.w
 800c0bc:	f3af 8000 	nop.w

0800c0c0 <execute_test>:

/*
 * Test suite execution.
 */
static void execute_test(const struct testcase *tcp) {
 800c0c0:	b500      	push	{lr}
 800c0c2:	b085      	sub	sp, #20
 800c0c4:	9001      	str	r0, [sp, #4]
  int i;

  /* Initialization */
  clear_tokens();
 800c0c6:	f7ff feb3 	bl	800be30 <clear_tokens>
  local_fail = FALSE;
 800c0ca:	4b13      	ldr	r3, [pc, #76]	; (800c118 <execute_test+0x58>)
 800c0cc:	2200      	movs	r2, #0
 800c0ce:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < MAX_THREADS; i++)
 800c0d0:	2300      	movs	r3, #0
 800c0d2:	9303      	str	r3, [sp, #12]
 800c0d4:	e007      	b.n	800c0e6 <execute_test+0x26>
    threads[i] = NULL;
 800c0d6:	4b11      	ldr	r3, [pc, #68]	; (800c11c <execute_test+0x5c>)
 800c0d8:	9a03      	ldr	r2, [sp, #12]
 800c0da:	2100      	movs	r1, #0
 800c0dc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  int i;

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
  for (i = 0; i < MAX_THREADS; i++)
 800c0e0:	9b03      	ldr	r3, [sp, #12]
 800c0e2:	3301      	adds	r3, #1
 800c0e4:	9303      	str	r3, [sp, #12]
 800c0e6:	9b03      	ldr	r3, [sp, #12]
 800c0e8:	2b04      	cmp	r3, #4
 800c0ea:	ddf4      	ble.n	800c0d6 <execute_test+0x16>
    threads[i] = NULL;

  if (tcp->setup != NULL)
 800c0ec:	9b01      	ldr	r3, [sp, #4]
 800c0ee:	685b      	ldr	r3, [r3, #4]
 800c0f0:	2b00      	cmp	r3, #0
 800c0f2:	d002      	beq.n	800c0fa <execute_test+0x3a>
    tcp->setup();
 800c0f4:	9b01      	ldr	r3, [sp, #4]
 800c0f6:	685b      	ldr	r3, [r3, #4]
 800c0f8:	4798      	blx	r3
  tcp->execute();
 800c0fa:	9b01      	ldr	r3, [sp, #4]
 800c0fc:	68db      	ldr	r3, [r3, #12]
 800c0fe:	4798      	blx	r3
  if (tcp->teardown != NULL)
 800c100:	9b01      	ldr	r3, [sp, #4]
 800c102:	689b      	ldr	r3, [r3, #8]
 800c104:	2b00      	cmp	r3, #0
 800c106:	d002      	beq.n	800c10e <execute_test+0x4e>
    tcp->teardown();
 800c108:	9b01      	ldr	r3, [sp, #4]
 800c10a:	689b      	ldr	r3, [r3, #8]
 800c10c:	4798      	blx	r3

  test_wait_threads();
 800c10e:	f7ff ff67 	bl	800bfe0 <test_wait_threads>
}
 800c112:	b005      	add	sp, #20
 800c114:	f85d fb04 	ldr.w	pc, [sp], #4
 800c118:	20000f90 	.word	0x20000f90
 800c11c:	20001ba4 	.word	0x20001ba4

0800c120 <print_line>:

static void print_line(void) {
 800c120:	b500      	push	{lr}
 800c122:	b083      	sub	sp, #12
  unsigned i;

  for (i = 0; i < 76; i++)
 800c124:	2300      	movs	r3, #0
 800c126:	9301      	str	r3, [sp, #4]
 800c128:	e00b      	b.n	800c142 <print_line+0x22>
    chSequentialStreamPut(chp, '-');
 800c12a:	4b0e      	ldr	r3, [pc, #56]	; (800c164 <print_line+0x44>)
 800c12c:	681b      	ldr	r3, [r3, #0]
 800c12e:	681b      	ldr	r3, [r3, #0]
 800c130:	689b      	ldr	r3, [r3, #8]
 800c132:	4a0c      	ldr	r2, [pc, #48]	; (800c164 <print_line+0x44>)
 800c134:	6812      	ldr	r2, [r2, #0]
 800c136:	4610      	mov	r0, r2
 800c138:	212d      	movs	r1, #45	; 0x2d
 800c13a:	4798      	blx	r3
}

static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
 800c13c:	9b01      	ldr	r3, [sp, #4]
 800c13e:	3301      	adds	r3, #1
 800c140:	9301      	str	r3, [sp, #4]
 800c142:	9b01      	ldr	r3, [sp, #4]
 800c144:	2b4b      	cmp	r3, #75	; 0x4b
 800c146:	d9f0      	bls.n	800c12a <print_line+0xa>
    chSequentialStreamPut(chp, '-');
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 800c148:	4b06      	ldr	r3, [pc, #24]	; (800c164 <print_line+0x44>)
 800c14a:	681b      	ldr	r3, [r3, #0]
 800c14c:	681b      	ldr	r3, [r3, #0]
 800c14e:	681b      	ldr	r3, [r3, #0]
 800c150:	4a04      	ldr	r2, [pc, #16]	; (800c164 <print_line+0x44>)
 800c152:	6812      	ldr	r2, [r2, #0]
 800c154:	4610      	mov	r0, r2
 800c156:	4904      	ldr	r1, [pc, #16]	; (800c168 <print_line+0x48>)
 800c158:	2202      	movs	r2, #2
 800c15a:	4798      	blx	r3
}
 800c15c:	b003      	add	sp, #12
 800c15e:	f85d fb04 	ldr.w	pc, [sp], #4
 800c162:	bf00      	nop
 800c164:	20000fac 	.word	0x20000fac
 800c168:	08017b34 	.word	0x08017b34
 800c16c:	f3af 8000 	nop.w

0800c170 <TestThread>:
/**
 * @brief   Test execution thread function.
 *
 * @param[in] p         pointer to a @p BaseChannel object for test output
 */
void TestThread(void *p) {
 800c170:	b500      	push	{lr}
 800c172:	b085      	sub	sp, #20
 800c174:	9001      	str	r0, [sp, #4]
  int i, j;

  chp = p;
 800c176:	4b5f      	ldr	r3, [pc, #380]	; (800c2f4 <TestThread+0x184>)
 800c178:	9a01      	ldr	r2, [sp, #4]
 800c17a:	601a      	str	r2, [r3, #0]
  test_println("");
 800c17c:	485e      	ldr	r0, [pc, #376]	; (800c2f8 <TestThread+0x188>)
 800c17e:	f7ff fe3f 	bl	800be00 <test_println>
  test_println("*** ChibiOS/RT test suite");
 800c182:	485e      	ldr	r0, [pc, #376]	; (800c2fc <TestThread+0x18c>)
 800c184:	f7ff fe3c 	bl	800be00 <test_println>
  test_println("***");
 800c188:	485d      	ldr	r0, [pc, #372]	; (800c300 <TestThread+0x190>)
 800c18a:	f7ff fe39 	bl	800be00 <test_println>
  test_print("*** Kernel:       ");
 800c18e:	485d      	ldr	r0, [pc, #372]	; (800c304 <TestThread+0x194>)
 800c190:	f7ff fe16 	bl	800bdc0 <test_print>
  test_println(CH_KERNEL_VERSION);
 800c194:	485c      	ldr	r0, [pc, #368]	; (800c308 <TestThread+0x198>)
 800c196:	f7ff fe33 	bl	800be00 <test_println>
  test_print("*** Compiled:     ");
 800c19a:	485c      	ldr	r0, [pc, #368]	; (800c30c <TestThread+0x19c>)
 800c19c:	f7ff fe10 	bl	800bdc0 <test_print>
  test_println(__DATE__ " - " __TIME__);
 800c1a0:	485b      	ldr	r0, [pc, #364]	; (800c310 <TestThread+0x1a0>)
 800c1a2:	f7ff fe2d 	bl	800be00 <test_println>
#ifdef PORT_COMPILER_NAME
  test_print("*** Compiler:     ");
 800c1a6:	485b      	ldr	r0, [pc, #364]	; (800c314 <TestThread+0x1a4>)
 800c1a8:	f7ff fe0a 	bl	800bdc0 <test_print>
  test_println(PORT_COMPILER_NAME);
 800c1ac:	485a      	ldr	r0, [pc, #360]	; (800c318 <TestThread+0x1a8>)
 800c1ae:	f7ff fe27 	bl	800be00 <test_println>
#endif
  test_print("*** Architecture: ");
 800c1b2:	485a      	ldr	r0, [pc, #360]	; (800c31c <TestThread+0x1ac>)
 800c1b4:	f7ff fe04 	bl	800bdc0 <test_print>
  test_println(PORT_ARCHITECTURE_NAME);
 800c1b8:	4859      	ldr	r0, [pc, #356]	; (800c320 <TestThread+0x1b0>)
 800c1ba:	f7ff fe21 	bl	800be00 <test_println>
#ifdef PORT_CORE_VARIANT_NAME
  test_print("*** Core Variant: ");
 800c1be:	4859      	ldr	r0, [pc, #356]	; (800c324 <TestThread+0x1b4>)
 800c1c0:	f7ff fdfe 	bl	800bdc0 <test_print>
  test_println(PORT_CORE_VARIANT_NAME);
 800c1c4:	4858      	ldr	r0, [pc, #352]	; (800c328 <TestThread+0x1b8>)
 800c1c6:	f7ff fe1b 	bl	800be00 <test_println>
#endif
#ifdef PORT_INFO
  test_print("*** Port Info:    ");
 800c1ca:	4858      	ldr	r0, [pc, #352]	; (800c32c <TestThread+0x1bc>)
 800c1cc:	f7ff fdf8 	bl	800bdc0 <test_print>
  test_println(PORT_INFO);
 800c1d0:	4857      	ldr	r0, [pc, #348]	; (800c330 <TestThread+0x1c0>)
 800c1d2:	f7ff fe15 	bl	800be00 <test_println>
#endif
#ifdef PLATFORM_NAME
  test_print("*** Platform:     ");
 800c1d6:	4857      	ldr	r0, [pc, #348]	; (800c334 <TestThread+0x1c4>)
 800c1d8:	f7ff fdf2 	bl	800bdc0 <test_print>
  test_println(PLATFORM_NAME);
 800c1dc:	4856      	ldr	r0, [pc, #344]	; (800c338 <TestThread+0x1c8>)
 800c1de:	f7ff fe0f 	bl	800be00 <test_println>
#endif
#ifdef BOARD_NAME
  test_print("*** Test Board:   ");
 800c1e2:	4856      	ldr	r0, [pc, #344]	; (800c33c <TestThread+0x1cc>)
 800c1e4:	f7ff fdec 	bl	800bdc0 <test_print>
  test_println(BOARD_NAME);
 800c1e8:	4855      	ldr	r0, [pc, #340]	; (800c340 <TestThread+0x1d0>)
 800c1ea:	f7ff fe09 	bl	800be00 <test_println>
#endif
  test_println("");
 800c1ee:	4842      	ldr	r0, [pc, #264]	; (800c2f8 <TestThread+0x188>)
 800c1f0:	f7ff fe06 	bl	800be00 <test_println>

  test_global_fail = FALSE;
 800c1f4:	4b53      	ldr	r3, [pc, #332]	; (800c344 <TestThread+0x1d4>)
 800c1f6:	2200      	movs	r2, #0
 800c1f8:	701a      	strb	r2, [r3, #0]
  i = 0;
 800c1fa:	2300      	movs	r3, #0
 800c1fc:	9303      	str	r3, [sp, #12]
  while (patterns[i]) {
 800c1fe:	e05c      	b.n	800c2ba <TestThread+0x14a>
    j = 0;
 800c200:	2300      	movs	r3, #0
 800c202:	9302      	str	r3, [sp, #8]
    while (patterns[i][j]) {
 800c204:	e04c      	b.n	800c2a0 <TestThread+0x130>
      print_line();
 800c206:	f7ff ff8b 	bl	800c120 <print_line>
      test_print("--- Test Case ");
 800c20a:	484f      	ldr	r0, [pc, #316]	; (800c348 <TestThread+0x1d8>)
 800c20c:	f7ff fdd8 	bl	800bdc0 <test_print>
      test_printn(i + 1);
 800c210:	9b03      	ldr	r3, [sp, #12]
 800c212:	3301      	adds	r3, #1
 800c214:	4618      	mov	r0, r3
 800c216:	f7ff fd8b 	bl	800bd30 <test_printn>
      test_print(".");
 800c21a:	484c      	ldr	r0, [pc, #304]	; (800c34c <TestThread+0x1dc>)
 800c21c:	f7ff fdd0 	bl	800bdc0 <test_print>
      test_printn(j + 1);
 800c220:	9b02      	ldr	r3, [sp, #8]
 800c222:	3301      	adds	r3, #1
 800c224:	4618      	mov	r0, r3
 800c226:	f7ff fd83 	bl	800bd30 <test_printn>
      test_print(" (");
 800c22a:	4849      	ldr	r0, [pc, #292]	; (800c350 <TestThread+0x1e0>)
 800c22c:	f7ff fdc8 	bl	800bdc0 <test_print>
      test_print(patterns[i][j]->name);
 800c230:	4b48      	ldr	r3, [pc, #288]	; (800c354 <TestThread+0x1e4>)
 800c232:	9a03      	ldr	r2, [sp, #12]
 800c234:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800c238:	9b02      	ldr	r3, [sp, #8]
 800c23a:	009b      	lsls	r3, r3, #2
 800c23c:	4413      	add	r3, r2
 800c23e:	681b      	ldr	r3, [r3, #0]
 800c240:	681b      	ldr	r3, [r3, #0]
 800c242:	4618      	mov	r0, r3
 800c244:	f7ff fdbc 	bl	800bdc0 <test_print>
      test_println(")");
 800c248:	4843      	ldr	r0, [pc, #268]	; (800c358 <TestThread+0x1e8>)
 800c24a:	f7ff fdd9 	bl	800be00 <test_println>
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
 800c24e:	20c8      	movs	r0, #200	; 0xc8
 800c250:	f7f5 f83e 	bl	80012d0 <chThdSleep>
#endif
      execute_test(patterns[i][j]);
 800c254:	4b3f      	ldr	r3, [pc, #252]	; (800c354 <TestThread+0x1e4>)
 800c256:	9a03      	ldr	r2, [sp, #12]
 800c258:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800c25c:	9b02      	ldr	r3, [sp, #8]
 800c25e:	009b      	lsls	r3, r3, #2
 800c260:	4413      	add	r3, r2
 800c262:	681b      	ldr	r3, [r3, #0]
 800c264:	4618      	mov	r0, r3
 800c266:	f7ff ff2b 	bl	800c0c0 <execute_test>
      if (local_fail) {
 800c26a:	4b3c      	ldr	r3, [pc, #240]	; (800c35c <TestThread+0x1ec>)
 800c26c:	781b      	ldrb	r3, [r3, #0]
 800c26e:	2b00      	cmp	r3, #0
 800c270:	d010      	beq.n	800c294 <TestThread+0x124>
        test_print("--- Result: FAILURE (#");
 800c272:	483b      	ldr	r0, [pc, #236]	; (800c360 <TestThread+0x1f0>)
 800c274:	f7ff fda4 	bl	800bdc0 <test_print>
        test_printn(failpoint);
 800c278:	4b3a      	ldr	r3, [pc, #232]	; (800c364 <TestThread+0x1f4>)
 800c27a:	681b      	ldr	r3, [r3, #0]
 800c27c:	4618      	mov	r0, r3
 800c27e:	f7ff fd57 	bl	800bd30 <test_printn>
        test_print(" [");
 800c282:	4839      	ldr	r0, [pc, #228]	; (800c368 <TestThread+0x1f8>)
 800c284:	f7ff fd9c 	bl	800bdc0 <test_print>
        print_tokens();
 800c288:	f7ff fdda 	bl	800be40 <print_tokens>
        test_println("])");
 800c28c:	4837      	ldr	r0, [pc, #220]	; (800c36c <TestThread+0x1fc>)
 800c28e:	f7ff fdb7 	bl	800be00 <test_println>
 800c292:	e002      	b.n	800c29a <TestThread+0x12a>
      }
      else
        test_println("--- Result: SUCCESS");
 800c294:	4836      	ldr	r0, [pc, #216]	; (800c370 <TestThread+0x200>)
 800c296:	f7ff fdb3 	bl	800be00 <test_println>
      j++;
 800c29a:	9b02      	ldr	r3, [sp, #8]
 800c29c:	3301      	adds	r3, #1
 800c29e:	9302      	str	r3, [sp, #8]

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
 800c2a0:	4b2c      	ldr	r3, [pc, #176]	; (800c354 <TestThread+0x1e4>)
 800c2a2:	9a03      	ldr	r2, [sp, #12]
 800c2a4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800c2a8:	9b02      	ldr	r3, [sp, #8]
 800c2aa:	009b      	lsls	r3, r3, #2
 800c2ac:	4413      	add	r3, r2
 800c2ae:	681b      	ldr	r3, [r3, #0]
 800c2b0:	2b00      	cmp	r3, #0
 800c2b2:	d1a8      	bne.n	800c206 <TestThread+0x96>
      }
      else
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
 800c2b4:	9b03      	ldr	r3, [sp, #12]
 800c2b6:	3301      	adds	r3, #1
 800c2b8:	9303      	str	r3, [sp, #12]
#endif
  test_println("");

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
 800c2ba:	4b26      	ldr	r3, [pc, #152]	; (800c354 <TestThread+0x1e4>)
 800c2bc:	9a03      	ldr	r2, [sp, #12]
 800c2be:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800c2c2:	2b00      	cmp	r3, #0
 800c2c4:	d19c      	bne.n	800c200 <TestThread+0x90>
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
  }
  print_line();
 800c2c6:	f7ff ff2b 	bl	800c120 <print_line>
  test_println("");
 800c2ca:	480b      	ldr	r0, [pc, #44]	; (800c2f8 <TestThread+0x188>)
 800c2cc:	f7ff fd98 	bl	800be00 <test_println>
  test_print("Final result: ");
 800c2d0:	4828      	ldr	r0, [pc, #160]	; (800c374 <TestThread+0x204>)
 800c2d2:	f7ff fd75 	bl	800bdc0 <test_print>
  if (test_global_fail)
 800c2d6:	4b1b      	ldr	r3, [pc, #108]	; (800c344 <TestThread+0x1d4>)
 800c2d8:	781b      	ldrb	r3, [r3, #0]
 800c2da:	2b00      	cmp	r3, #0
 800c2dc:	d003      	beq.n	800c2e6 <TestThread+0x176>
    test_println("FAILURE");
 800c2de:	4826      	ldr	r0, [pc, #152]	; (800c378 <TestThread+0x208>)
 800c2e0:	f7ff fd8e 	bl	800be00 <test_println>
 800c2e4:	e002      	b.n	800c2ec <TestThread+0x17c>
  else
    test_println("SUCCESS");
 800c2e6:	4825      	ldr	r0, [pc, #148]	; (800c37c <TestThread+0x20c>)
 800c2e8:	f7ff fd8a 	bl	800be00 <test_println>
}
 800c2ec:	b005      	add	sp, #20
 800c2ee:	f85d fb04 	ldr.w	pc, [sp], #4
 800c2f2:	bf00      	nop
 800c2f4:	20000fac 	.word	0x20000fac
 800c2f8:	08017b38 	.word	0x08017b38
 800c2fc:	08017b3c 	.word	0x08017b3c
 800c300:	08017b58 	.word	0x08017b58
 800c304:	08017b5c 	.word	0x08017b5c
 800c308:	08017b70 	.word	0x08017b70
 800c30c:	08017b78 	.word	0x08017b78
 800c310:	08017b8c 	.word	0x08017b8c
 800c314:	08017ba4 	.word	0x08017ba4
 800c318:	08017bb8 	.word	0x08017bb8
 800c31c:	08017c00 	.word	0x08017c00
 800c320:	08017c14 	.word	0x08017c14
 800c324:	08017c20 	.word	0x08017c20
 800c328:	08017c34 	.word	0x08017c34
 800c32c:	08017c40 	.word	0x08017c40
 800c330:	08017c54 	.word	0x08017c54
 800c334:	08017c6c 	.word	0x08017c6c
 800c338:	08017c80 	.word	0x08017c80
 800c33c:	08017c9c 	.word	0x08017c9c
 800c340:	08017cb0 	.word	0x08017cb0
 800c344:	20001ba0 	.word	0x20001ba0
 800c348:	08017cc0 	.word	0x08017cc0
 800c34c:	08017cd0 	.word	0x08017cd0
 800c350:	08017cd4 	.word	0x08017cd4
 800c354:	20000804 	.word	0x20000804
 800c358:	08017cd8 	.word	0x08017cd8
 800c35c:	20000f90 	.word	0x20000f90
 800c360:	08017cdc 	.word	0x08017cdc
 800c364:	20000f94 	.word	0x20000f94
 800c368:	08017cf4 	.word	0x08017cf4
 800c36c:	08017cf8 	.word	0x08017cf8
 800c370:	08017cfc 	.word	0x08017cfc
 800c374:	08017d10 	.word	0x08017d10
 800c378:	08017d20 	.word	0x08017d20
 800c37c:	08017d28 	.word	0x08017d28

0800c380 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800c380:	b082      	sub	sp, #8
 800c382:	2320      	movs	r3, #32
 800c384:	9301      	str	r3, [sp, #4]
 800c386:	9b01      	ldr	r3, [sp, #4]
 800c388:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800c38c:	b002      	add	sp, #8
 800c38e:	4770      	bx	lr

0800c390 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800c390:	b082      	sub	sp, #8
 800c392:	2300      	movs	r3, #0
 800c394:	9301      	str	r3, [sp, #4]
 800c396:	9b01      	ldr	r3, [sp, #4]
 800c398:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800c39c:	b002      	add	sp, #8
 800c39e:	4770      	bx	lr

0800c3a0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800c3a0:	b508      	push	{r3, lr}

  port_lock();
 800c3a2:	f7ff ffed 	bl	800c380 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800c3a6:	bd08      	pop	{r3, pc}
 800c3a8:	f3af 8000 	nop.w
 800c3ac:	f3af 8000 	nop.w

0800c3b0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800c3b0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800c3b2:	f7ff ffed 	bl	800c390 <port_unlock>
}
 800c3b6:	bd08      	pop	{r3, pc}
 800c3b8:	f3af 8000 	nop.w
 800c3bc:	f3af 8000 	nop.w

0800c3c0 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 800c3c0:	4b01      	ldr	r3, [pc, #4]	; (800c3c8 <chVTGetSystemTimeX+0x8>)
 800c3c2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800c3c4:	4618      	mov	r0, r3
 800c3c6:	4770      	bx	lr
 800c3c8:	200016e0 	.word	0x200016e0
 800c3cc:	f3af 8000 	nop.w

0800c3d0 <chVTGetSystemTime>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 800c3d0:	b500      	push	{lr}
 800c3d2:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 800c3d4:	f7ff ffe4 	bl	800c3a0 <chSysLock>
  systime = chVTGetSystemTimeX();
 800c3d8:	f7ff fff2 	bl	800c3c0 <chVTGetSystemTimeX>
 800c3dc:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 800c3de:	f7ff ffe7 	bl	800c3b0 <chSysUnlock>

  return systime;
 800c3e2:	9b01      	ldr	r3, [sp, #4]
}
 800c3e4:	4618      	mov	r0, r3
 800c3e6:	b003      	add	sp, #12
 800c3e8:	f85d fb04 	ldr.w	pc, [sp], #4
 800c3ec:	f3af 8000 	nop.w

0800c3f0 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800c3f0:	4b01      	ldr	r3, [pc, #4]	; (800c3f8 <chThdGetSelfX+0x8>)
 800c3f2:	699b      	ldr	r3, [r3, #24]
}
 800c3f4:	4618      	mov	r0, r3
 800c3f6:	4770      	bx	lr
 800c3f8:	200016e0 	.word	0x200016e0
 800c3fc:	f3af 8000 	nop.w

0800c400 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800c400:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800c402:	f7ff fff5 	bl	800c3f0 <chThdGetSelfX>
 800c406:	4603      	mov	r3, r0
 800c408:	689b      	ldr	r3, [r3, #8]
}
 800c40a:	4618      	mov	r0, r3
 800c40c:	bd08      	pop	{r3, pc}
 800c40e:	bf00      	nop

0800c410 <thread>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static THD_FUNCTION(thread, p) {
 800c410:	b500      	push	{lr}
 800c412:	b083      	sub	sp, #12
 800c414:	9001      	str	r0, [sp, #4]

  test_emit_token(*(char *)p);
 800c416:	9b01      	ldr	r3, [sp, #4]
 800c418:	781b      	ldrb	r3, [r3, #0]
 800c41a:	4618      	mov	r0, r3
 800c41c:	f7ff fd30 	bl	800be80 <test_emit_token>
}
 800c420:	b003      	add	sp, #12
 800c422:	f85d fb04 	ldr.w	pc, [sp], #4
 800c426:	bf00      	nop
 800c428:	f3af 8000 	nop.w
 800c42c:	f3af 8000 	nop.w

0800c430 <thd1_execute>:

static void thd1_execute(void) {
 800c430:	b510      	push	{r4, lr}
 800c432:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 800c434:	4b32      	ldr	r3, [pc, #200]	; (800c500 <thd1_execute+0xd0>)
 800c436:	681c      	ldr	r4, [r3, #0]
 800c438:	f7ff ffe2 	bl	800c400 <chThdGetPriorityX>
 800c43c:	4603      	mov	r3, r0
 800c43e:	3b05      	subs	r3, #5
 800c440:	4a30      	ldr	r2, [pc, #192]	; (800c504 <thd1_execute+0xd4>)
 800c442:	9200      	str	r2, [sp, #0]
 800c444:	4620      	mov	r0, r4
 800c446:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c44a:	461a      	mov	r2, r3
 800c44c:	4b2e      	ldr	r3, [pc, #184]	; (800c508 <thd1_execute+0xd8>)
 800c44e:	f7f4 fec7 	bl	80011e0 <chThdCreateStatic>
 800c452:	4602      	mov	r2, r0
 800c454:	4b2d      	ldr	r3, [pc, #180]	; (800c50c <thd1_execute+0xdc>)
 800c456:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 800c458:	4b29      	ldr	r3, [pc, #164]	; (800c500 <thd1_execute+0xd0>)
 800c45a:	685c      	ldr	r4, [r3, #4]
 800c45c:	f7ff ffd0 	bl	800c400 <chThdGetPriorityX>
 800c460:	4603      	mov	r3, r0
 800c462:	3b04      	subs	r3, #4
 800c464:	4a2a      	ldr	r2, [pc, #168]	; (800c510 <thd1_execute+0xe0>)
 800c466:	9200      	str	r2, [sp, #0]
 800c468:	4620      	mov	r0, r4
 800c46a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c46e:	461a      	mov	r2, r3
 800c470:	4b25      	ldr	r3, [pc, #148]	; (800c508 <thd1_execute+0xd8>)
 800c472:	f7f4 feb5 	bl	80011e0 <chThdCreateStatic>
 800c476:	4602      	mov	r2, r0
 800c478:	4b24      	ldr	r3, [pc, #144]	; (800c50c <thd1_execute+0xdc>)
 800c47a:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 800c47c:	4b20      	ldr	r3, [pc, #128]	; (800c500 <thd1_execute+0xd0>)
 800c47e:	689c      	ldr	r4, [r3, #8]
 800c480:	f7ff ffbe 	bl	800c400 <chThdGetPriorityX>
 800c484:	4603      	mov	r3, r0
 800c486:	3b03      	subs	r3, #3
 800c488:	4a22      	ldr	r2, [pc, #136]	; (800c514 <thd1_execute+0xe4>)
 800c48a:	9200      	str	r2, [sp, #0]
 800c48c:	4620      	mov	r0, r4
 800c48e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c492:	461a      	mov	r2, r3
 800c494:	4b1c      	ldr	r3, [pc, #112]	; (800c508 <thd1_execute+0xd8>)
 800c496:	f7f4 fea3 	bl	80011e0 <chThdCreateStatic>
 800c49a:	4602      	mov	r2, r0
 800c49c:	4b1b      	ldr	r3, [pc, #108]	; (800c50c <thd1_execute+0xdc>)
 800c49e:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800c4a0:	4b17      	ldr	r3, [pc, #92]	; (800c500 <thd1_execute+0xd0>)
 800c4a2:	68dc      	ldr	r4, [r3, #12]
 800c4a4:	f7ff ffac 	bl	800c400 <chThdGetPriorityX>
 800c4a8:	4603      	mov	r3, r0
 800c4aa:	3b02      	subs	r3, #2
 800c4ac:	4a1a      	ldr	r2, [pc, #104]	; (800c518 <thd1_execute+0xe8>)
 800c4ae:	9200      	str	r2, [sp, #0]
 800c4b0:	4620      	mov	r0, r4
 800c4b2:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c4b6:	461a      	mov	r2, r3
 800c4b8:	4b13      	ldr	r3, [pc, #76]	; (800c508 <thd1_execute+0xd8>)
 800c4ba:	f7f4 fe91 	bl	80011e0 <chThdCreateStatic>
 800c4be:	4602      	mov	r2, r0
 800c4c0:	4b12      	ldr	r3, [pc, #72]	; (800c50c <thd1_execute+0xdc>)
 800c4c2:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800c4c4:	4b0e      	ldr	r3, [pc, #56]	; (800c500 <thd1_execute+0xd0>)
 800c4c6:	691c      	ldr	r4, [r3, #16]
 800c4c8:	f7ff ff9a 	bl	800c400 <chThdGetPriorityX>
 800c4cc:	4603      	mov	r3, r0
 800c4ce:	3b01      	subs	r3, #1
 800c4d0:	4a12      	ldr	r2, [pc, #72]	; (800c51c <thd1_execute+0xec>)
 800c4d2:	9200      	str	r2, [sp, #0]
 800c4d4:	4620      	mov	r0, r4
 800c4d6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c4da:	461a      	mov	r2, r3
 800c4dc:	4b0a      	ldr	r3, [pc, #40]	; (800c508 <thd1_execute+0xd8>)
 800c4de:	f7f4 fe7f 	bl	80011e0 <chThdCreateStatic>
 800c4e2:	4602      	mov	r2, r0
 800c4e4:	4b09      	ldr	r3, [pc, #36]	; (800c50c <thd1_execute+0xdc>)
 800c4e6:	611a      	str	r2, [r3, #16]
  test_wait_threads();
 800c4e8:	f7ff fd7a 	bl	800bfe0 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 800c4ec:	2001      	movs	r0, #1
 800c4ee:	490c      	ldr	r1, [pc, #48]	; (800c520 <thd1_execute+0xf0>)
 800c4f0:	f7ff fd0e 	bl	800bf10 <_test_assert_sequence>
 800c4f4:	4603      	mov	r3, r0
 800c4f6:	2b00      	cmp	r3, #0
 800c4f8:	d000      	beq.n	800c4fc <thd1_execute+0xcc>
 800c4fa:	bf00      	nop
}
 800c4fc:	b002      	add	sp, #8
 800c4fe:	bd10      	pop	{r4, pc}
 800c500:	08017b20 	.word	0x08017b20
 800c504:	08017d30 	.word	0x08017d30
 800c508:	0800c411 	.word	0x0800c411
 800c50c:	20001ba4 	.word	0x20001ba4
 800c510:	08017d34 	.word	0x08017d34
 800c514:	08017d38 	.word	0x08017d38
 800c518:	08017d3c 	.word	0x08017d3c
 800c51c:	08017d40 	.word	0x08017d40
 800c520:	08017d44 	.word	0x08017d44
 800c524:	f3af 8000 	nop.w
 800c528:	f3af 8000 	nop.w
 800c52c:	f3af 8000 	nop.w

0800c530 <thd2_execute>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {
 800c530:	b510      	push	{r4, lr}
 800c532:	b082      	sub	sp, #8

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 800c534:	4b37      	ldr	r3, [pc, #220]	; (800c614 <thd2_execute+0xe4>)
 800c536:	685c      	ldr	r4, [r3, #4]
 800c538:	f7ff ff62 	bl	800c400 <chThdGetPriorityX>
 800c53c:	4603      	mov	r3, r0
 800c53e:	3b04      	subs	r3, #4
 800c540:	4a35      	ldr	r2, [pc, #212]	; (800c618 <thd2_execute+0xe8>)
 800c542:	9200      	str	r2, [sp, #0]
 800c544:	4620      	mov	r0, r4
 800c546:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c54a:	461a      	mov	r2, r3
 800c54c:	4b33      	ldr	r3, [pc, #204]	; (800c61c <thd2_execute+0xec>)
 800c54e:	f7f4 fe47 	bl	80011e0 <chThdCreateStatic>
 800c552:	4602      	mov	r2, r0
 800c554:	4b32      	ldr	r3, [pc, #200]	; (800c620 <thd2_execute+0xf0>)
 800c556:	605a      	str	r2, [r3, #4]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 800c558:	4b2e      	ldr	r3, [pc, #184]	; (800c614 <thd2_execute+0xe4>)
 800c55a:	681c      	ldr	r4, [r3, #0]
 800c55c:	f7ff ff50 	bl	800c400 <chThdGetPriorityX>
 800c560:	4603      	mov	r3, r0
 800c562:	3b05      	subs	r3, #5
 800c564:	4a2f      	ldr	r2, [pc, #188]	; (800c624 <thd2_execute+0xf4>)
 800c566:	9200      	str	r2, [sp, #0]
 800c568:	4620      	mov	r0, r4
 800c56a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c56e:	461a      	mov	r2, r3
 800c570:	4b2a      	ldr	r3, [pc, #168]	; (800c61c <thd2_execute+0xec>)
 800c572:	f7f4 fe35 	bl	80011e0 <chThdCreateStatic>
 800c576:	4602      	mov	r2, r0
 800c578:	4b29      	ldr	r3, [pc, #164]	; (800c620 <thd2_execute+0xf0>)
 800c57a:	601a      	str	r2, [r3, #0]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800c57c:	4b25      	ldr	r3, [pc, #148]	; (800c614 <thd2_execute+0xe4>)
 800c57e:	691c      	ldr	r4, [r3, #16]
 800c580:	f7ff ff3e 	bl	800c400 <chThdGetPriorityX>
 800c584:	4603      	mov	r3, r0
 800c586:	3b01      	subs	r3, #1
 800c588:	4a27      	ldr	r2, [pc, #156]	; (800c628 <thd2_execute+0xf8>)
 800c58a:	9200      	str	r2, [sp, #0]
 800c58c:	4620      	mov	r0, r4
 800c58e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c592:	461a      	mov	r2, r3
 800c594:	4b21      	ldr	r3, [pc, #132]	; (800c61c <thd2_execute+0xec>)
 800c596:	f7f4 fe23 	bl	80011e0 <chThdCreateStatic>
 800c59a:	4602      	mov	r2, r0
 800c59c:	4b20      	ldr	r3, [pc, #128]	; (800c620 <thd2_execute+0xf0>)
 800c59e:	611a      	str	r2, [r3, #16]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800c5a0:	4b1c      	ldr	r3, [pc, #112]	; (800c614 <thd2_execute+0xe4>)
 800c5a2:	68dc      	ldr	r4, [r3, #12]
 800c5a4:	f7ff ff2c 	bl	800c400 <chThdGetPriorityX>
 800c5a8:	4603      	mov	r3, r0
 800c5aa:	3b02      	subs	r3, #2
 800c5ac:	4a1f      	ldr	r2, [pc, #124]	; (800c62c <thd2_execute+0xfc>)
 800c5ae:	9200      	str	r2, [sp, #0]
 800c5b0:	4620      	mov	r0, r4
 800c5b2:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c5b6:	461a      	mov	r2, r3
 800c5b8:	4b18      	ldr	r3, [pc, #96]	; (800c61c <thd2_execute+0xec>)
 800c5ba:	f7f4 fe11 	bl	80011e0 <chThdCreateStatic>
 800c5be:	4602      	mov	r2, r0
 800c5c0:	4b17      	ldr	r3, [pc, #92]	; (800c620 <thd2_execute+0xf0>)
 800c5c2:	60da      	str	r2, [r3, #12]
  /* Done this way for coverage of chThdCreateI() and chThdStart().*/
  chSysLock();
 800c5c4:	f7ff feec 	bl	800c3a0 <chSysLock>
  threads[2] = chThdCreateI(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 800c5c8:	4b12      	ldr	r3, [pc, #72]	; (800c614 <thd2_execute+0xe4>)
 800c5ca:	689c      	ldr	r4, [r3, #8]
 800c5cc:	f7ff ff18 	bl	800c400 <chThdGetPriorityX>
 800c5d0:	4603      	mov	r3, r0
 800c5d2:	3b03      	subs	r3, #3
 800c5d4:	4a16      	ldr	r2, [pc, #88]	; (800c630 <thd2_execute+0x100>)
 800c5d6:	9200      	str	r2, [sp, #0]
 800c5d8:	4620      	mov	r0, r4
 800c5da:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c5de:	461a      	mov	r2, r3
 800c5e0:	4b0e      	ldr	r3, [pc, #56]	; (800c61c <thd2_execute+0xec>)
 800c5e2:	f7f4 fdd5 	bl	8001190 <chThdCreateI>
 800c5e6:	4602      	mov	r2, r0
 800c5e8:	4b0d      	ldr	r3, [pc, #52]	; (800c620 <thd2_execute+0xf0>)
 800c5ea:	609a      	str	r2, [r3, #8]
  chSysUnlock();
 800c5ec:	f7ff fee0 	bl	800c3b0 <chSysUnlock>
  chThdStart(threads[2]);
 800c5f0:	4b0b      	ldr	r3, [pc, #44]	; (800c620 <thd2_execute+0xf0>)
 800c5f2:	689b      	ldr	r3, [r3, #8]
 800c5f4:	4618      	mov	r0, r3
 800c5f6:	f7f4 fe13 	bl	8001220 <chThdStart>
  test_wait_threads();
 800c5fa:	f7ff fcf1 	bl	800bfe0 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 800c5fe:	2001      	movs	r0, #1
 800c600:	490c      	ldr	r1, [pc, #48]	; (800c634 <thd2_execute+0x104>)
 800c602:	f7ff fc85 	bl	800bf10 <_test_assert_sequence>
 800c606:	4603      	mov	r3, r0
 800c608:	2b00      	cmp	r3, #0
 800c60a:	d000      	beq.n	800c60e <thd2_execute+0xde>
 800c60c:	bf00      	nop
}
 800c60e:	b002      	add	sp, #8
 800c610:	bd10      	pop	{r4, pc}
 800c612:	bf00      	nop
 800c614:	08017b20 	.word	0x08017b20
 800c618:	08017d34 	.word	0x08017d34
 800c61c:	0800c411 	.word	0x0800c411
 800c620:	20001ba4 	.word	0x20001ba4
 800c624:	08017d30 	.word	0x08017d30
 800c628:	08017d40 	.word	0x08017d40
 800c62c:	08017d3c 	.word	0x08017d3c
 800c630:	08017d38 	.word	0x08017d38
 800c634:	08017d44 	.word	0x08017d44
 800c638:	f3af 8000 	nop.w
 800c63c:	f3af 8000 	nop.w

0800c640 <thd3_execute>:
 * to verify that the priority change happens as expected.<br>
 * If the @p CH_CFG_USE_MUTEXES option is enabled then the priority changes are
 * also tested under priority inheritance boosted priority state.
 */

static void thd3_execute(void) {
 800c640:	b500      	push	{lr}
 800c642:	b083      	sub	sp, #12
  tprio_t prio, p1;

  prio = chThdGetPriorityX();
 800c644:	f7ff fedc 	bl	800c400 <chThdGetPriorityX>
 800c648:	9001      	str	r0, [sp, #4]
  p1 = chThdSetPriority(prio + 1);
 800c64a:	9b01      	ldr	r3, [sp, #4]
 800c64c:	3301      	adds	r3, #1
 800c64e:	4618      	mov	r0, r3
 800c650:	f7f4 fdf6 	bl	8001240 <chThdSetPriority>
 800c654:	9000      	str	r0, [sp, #0]
  test_assert(1, p1 == prio,
 800c656:	9a00      	ldr	r2, [sp, #0]
 800c658:	9b01      	ldr	r3, [sp, #4]
 800c65a:	429a      	cmp	r2, r3
 800c65c:	bf14      	ite	ne
 800c65e:	2300      	movne	r3, #0
 800c660:	2301      	moveq	r3, #1
 800c662:	b2db      	uxtb	r3, r3
 800c664:	2001      	movs	r0, #1
 800c666:	4619      	mov	r1, r3
 800c668:	f7ff fc3a 	bl	800bee0 <_test_assert>
 800c66c:	4603      	mov	r3, r0
 800c66e:	2b00      	cmp	r3, #0
 800c670:	d000      	beq.n	800c674 <thd3_execute+0x34>
 800c672:	e0d7      	b.n	800c824 <thd3_execute+0x1e4>
              "unexpected returned priority level");
  test_assert(2, chThdGetPriorityX() == prio + 1,
 800c674:	f7ff fec4 	bl	800c400 <chThdGetPriorityX>
 800c678:	4602      	mov	r2, r0
 800c67a:	9b01      	ldr	r3, [sp, #4]
 800c67c:	3301      	adds	r3, #1
 800c67e:	429a      	cmp	r2, r3
 800c680:	bf14      	ite	ne
 800c682:	2300      	movne	r3, #0
 800c684:	2301      	moveq	r3, #1
 800c686:	b2db      	uxtb	r3, r3
 800c688:	2002      	movs	r0, #2
 800c68a:	4619      	mov	r1, r3
 800c68c:	f7ff fc28 	bl	800bee0 <_test_assert>
 800c690:	4603      	mov	r3, r0
 800c692:	2b00      	cmp	r3, #0
 800c694:	d000      	beq.n	800c698 <thd3_execute+0x58>
 800c696:	e0c5      	b.n	800c824 <thd3_execute+0x1e4>
              "unexpected priority level");
  p1 = chThdSetPriority(p1);
 800c698:	9800      	ldr	r0, [sp, #0]
 800c69a:	f7f4 fdd1 	bl	8001240 <chThdSetPriority>
 800c69e:	9000      	str	r0, [sp, #0]
  test_assert(3, p1 == prio + 1,
 800c6a0:	9b01      	ldr	r3, [sp, #4]
 800c6a2:	1c5a      	adds	r2, r3, #1
 800c6a4:	9b00      	ldr	r3, [sp, #0]
 800c6a6:	429a      	cmp	r2, r3
 800c6a8:	bf14      	ite	ne
 800c6aa:	2300      	movne	r3, #0
 800c6ac:	2301      	moveq	r3, #1
 800c6ae:	b2db      	uxtb	r3, r3
 800c6b0:	2003      	movs	r0, #3
 800c6b2:	4619      	mov	r1, r3
 800c6b4:	f7ff fc14 	bl	800bee0 <_test_assert>
 800c6b8:	4603      	mov	r3, r0
 800c6ba:	2b00      	cmp	r3, #0
 800c6bc:	d000      	beq.n	800c6c0 <thd3_execute+0x80>
 800c6be:	e0b1      	b.n	800c824 <thd3_execute+0x1e4>
              "unexpected returned priority level");
  test_assert(4, chThdGetPriorityX() == prio,
 800c6c0:	f7ff fe9e 	bl	800c400 <chThdGetPriorityX>
 800c6c4:	4602      	mov	r2, r0
 800c6c6:	9b01      	ldr	r3, [sp, #4]
 800c6c8:	429a      	cmp	r2, r3
 800c6ca:	bf14      	ite	ne
 800c6cc:	2300      	movne	r3, #0
 800c6ce:	2301      	moveq	r3, #1
 800c6d0:	b2db      	uxtb	r3, r3
 800c6d2:	2004      	movs	r0, #4
 800c6d4:	4619      	mov	r1, r3
 800c6d6:	f7ff fc03 	bl	800bee0 <_test_assert>
 800c6da:	4603      	mov	r3, r0
 800c6dc:	2b00      	cmp	r3, #0
 800c6de:	d000      	beq.n	800c6e2 <thd3_execute+0xa2>
 800c6e0:	e0a0      	b.n	800c824 <thd3_execute+0x1e4>
              "unexpected priority level");

#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  /* Simulates a priority boost situation (p_prio > p_realprio).*/
  chSysLock();
 800c6e2:	f7ff fe5d 	bl	800c3a0 <chSysLock>
  chThdGetSelfX()->p_prio += 2;
 800c6e6:	f7ff fe83 	bl	800c3f0 <chThdGetSelfX>
 800c6ea:	4603      	mov	r3, r0
 800c6ec:	689a      	ldr	r2, [r3, #8]
 800c6ee:	3202      	adds	r2, #2
 800c6f0:	609a      	str	r2, [r3, #8]
  chSysUnlock();
 800c6f2:	f7ff fe5d 	bl	800c3b0 <chSysUnlock>
  test_assert(5, chThdGetPriorityX() == prio + 2,
 800c6f6:	f7ff fe83 	bl	800c400 <chThdGetPriorityX>
 800c6fa:	4602      	mov	r2, r0
 800c6fc:	9b01      	ldr	r3, [sp, #4]
 800c6fe:	3302      	adds	r3, #2
 800c700:	429a      	cmp	r2, r3
 800c702:	bf14      	ite	ne
 800c704:	2300      	movne	r3, #0
 800c706:	2301      	moveq	r3, #1
 800c708:	b2db      	uxtb	r3, r3
 800c70a:	2005      	movs	r0, #5
 800c70c:	4619      	mov	r1, r3
 800c70e:	f7ff fbe7 	bl	800bee0 <_test_assert>
 800c712:	4603      	mov	r3, r0
 800c714:	2b00      	cmp	r3, #0
 800c716:	d000      	beq.n	800c71a <thd3_execute+0xda>
 800c718:	e084      	b.n	800c824 <thd3_execute+0x1e4>
              "unexpected priority level");

  /* Tries to raise but below the boost level. */
  p1 = chThdSetPriority(prio + 1);
 800c71a:	9b01      	ldr	r3, [sp, #4]
 800c71c:	3301      	adds	r3, #1
 800c71e:	4618      	mov	r0, r3
 800c720:	f7f4 fd8e 	bl	8001240 <chThdSetPriority>
 800c724:	9000      	str	r0, [sp, #0]
  test_assert(6, p1 == prio,
 800c726:	9a00      	ldr	r2, [sp, #0]
 800c728:	9b01      	ldr	r3, [sp, #4]
 800c72a:	429a      	cmp	r2, r3
 800c72c:	bf14      	ite	ne
 800c72e:	2300      	movne	r3, #0
 800c730:	2301      	moveq	r3, #1
 800c732:	b2db      	uxtb	r3, r3
 800c734:	2006      	movs	r0, #6
 800c736:	4619      	mov	r1, r3
 800c738:	f7ff fbd2 	bl	800bee0 <_test_assert>
 800c73c:	4603      	mov	r3, r0
 800c73e:	2b00      	cmp	r3, #0
 800c740:	d000      	beq.n	800c744 <thd3_execute+0x104>
 800c742:	e06f      	b.n	800c824 <thd3_execute+0x1e4>
              "unexpected returned priority level");
  test_assert(7, chThdGetSelfX()->p_prio == prio + 2,
 800c744:	f7ff fe54 	bl	800c3f0 <chThdGetSelfX>
 800c748:	4603      	mov	r3, r0
 800c74a:	689a      	ldr	r2, [r3, #8]
 800c74c:	9b01      	ldr	r3, [sp, #4]
 800c74e:	3302      	adds	r3, #2
 800c750:	429a      	cmp	r2, r3
 800c752:	bf14      	ite	ne
 800c754:	2300      	movne	r3, #0
 800c756:	2301      	moveq	r3, #1
 800c758:	b2db      	uxtb	r3, r3
 800c75a:	2007      	movs	r0, #7
 800c75c:	4619      	mov	r1, r3
 800c75e:	f7ff fbbf 	bl	800bee0 <_test_assert>
 800c762:	4603      	mov	r3, r0
 800c764:	2b00      	cmp	r3, #0
 800c766:	d000      	beq.n	800c76a <thd3_execute+0x12a>
 800c768:	e05c      	b.n	800c824 <thd3_execute+0x1e4>
              "unexpected priority level");
  test_assert(8, chThdGetSelfX()->p_realprio == prio + 1,
 800c76a:	f7ff fe41 	bl	800c3f0 <chThdGetSelfX>
 800c76e:	4603      	mov	r3, r0
 800c770:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800c772:	9b01      	ldr	r3, [sp, #4]
 800c774:	3301      	adds	r3, #1
 800c776:	429a      	cmp	r2, r3
 800c778:	bf14      	ite	ne
 800c77a:	2300      	movne	r3, #0
 800c77c:	2301      	moveq	r3, #1
 800c77e:	b2db      	uxtb	r3, r3
 800c780:	2008      	movs	r0, #8
 800c782:	4619      	mov	r1, r3
 800c784:	f7ff fbac 	bl	800bee0 <_test_assert>
 800c788:	4603      	mov	r3, r0
 800c78a:	2b00      	cmp	r3, #0
 800c78c:	d000      	beq.n	800c790 <thd3_execute+0x150>
 800c78e:	e049      	b.n	800c824 <thd3_execute+0x1e4>
              "unexpected returned real priority level");

  /* Tries to raise above the boost level. */
  p1 = chThdSetPriority(prio + 3);
 800c790:	9b01      	ldr	r3, [sp, #4]
 800c792:	3303      	adds	r3, #3
 800c794:	4618      	mov	r0, r3
 800c796:	f7f4 fd53 	bl	8001240 <chThdSetPriority>
 800c79a:	9000      	str	r0, [sp, #0]
  test_assert(9, p1 == prio + 1,
 800c79c:	9b01      	ldr	r3, [sp, #4]
 800c79e:	1c5a      	adds	r2, r3, #1
 800c7a0:	9b00      	ldr	r3, [sp, #0]
 800c7a2:	429a      	cmp	r2, r3
 800c7a4:	bf14      	ite	ne
 800c7a6:	2300      	movne	r3, #0
 800c7a8:	2301      	moveq	r3, #1
 800c7aa:	b2db      	uxtb	r3, r3
 800c7ac:	2009      	movs	r0, #9
 800c7ae:	4619      	mov	r1, r3
 800c7b0:	f7ff fb96 	bl	800bee0 <_test_assert>
 800c7b4:	4603      	mov	r3, r0
 800c7b6:	2b00      	cmp	r3, #0
 800c7b8:	d000      	beq.n	800c7bc <thd3_execute+0x17c>
 800c7ba:	e033      	b.n	800c824 <thd3_execute+0x1e4>
              "unexpected returned priority level");
  test_assert(10, chThdGetSelfX()->p_prio == prio + 3,
 800c7bc:	f7ff fe18 	bl	800c3f0 <chThdGetSelfX>
 800c7c0:	4603      	mov	r3, r0
 800c7c2:	689a      	ldr	r2, [r3, #8]
 800c7c4:	9b01      	ldr	r3, [sp, #4]
 800c7c6:	3303      	adds	r3, #3
 800c7c8:	429a      	cmp	r2, r3
 800c7ca:	bf14      	ite	ne
 800c7cc:	2300      	movne	r3, #0
 800c7ce:	2301      	moveq	r3, #1
 800c7d0:	b2db      	uxtb	r3, r3
 800c7d2:	200a      	movs	r0, #10
 800c7d4:	4619      	mov	r1, r3
 800c7d6:	f7ff fb83 	bl	800bee0 <_test_assert>
 800c7da:	4603      	mov	r3, r0
 800c7dc:	2b00      	cmp	r3, #0
 800c7de:	d000      	beq.n	800c7e2 <thd3_execute+0x1a2>
 800c7e0:	e020      	b.n	800c824 <thd3_execute+0x1e4>
              "unexpected priority level");
  test_assert(11, chThdGetSelfX()->p_realprio == prio + 3,
 800c7e2:	f7ff fe05 	bl	800c3f0 <chThdGetSelfX>
 800c7e6:	4603      	mov	r3, r0
 800c7e8:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800c7ea:	9b01      	ldr	r3, [sp, #4]
 800c7ec:	3303      	adds	r3, #3
 800c7ee:	429a      	cmp	r2, r3
 800c7f0:	bf14      	ite	ne
 800c7f2:	2300      	movne	r3, #0
 800c7f4:	2301      	moveq	r3, #1
 800c7f6:	b2db      	uxtb	r3, r3
 800c7f8:	200b      	movs	r0, #11
 800c7fa:	4619      	mov	r1, r3
 800c7fc:	f7ff fb70 	bl	800bee0 <_test_assert>
 800c800:	4603      	mov	r3, r0
 800c802:	2b00      	cmp	r3, #0
 800c804:	d000      	beq.n	800c808 <thd3_execute+0x1c8>
 800c806:	e00d      	b.n	800c824 <thd3_execute+0x1e4>
              "unexpected real priority level");

  chSysLock();
 800c808:	f7ff fdca 	bl	800c3a0 <chSysLock>
  chThdGetSelfX()->p_prio = prio;
 800c80c:	f7ff fdf0 	bl	800c3f0 <chThdGetSelfX>
 800c810:	4603      	mov	r3, r0
 800c812:	9a01      	ldr	r2, [sp, #4]
 800c814:	609a      	str	r2, [r3, #8]
  chThdGetSelfX()->p_realprio = prio;
 800c816:	f7ff fdeb 	bl	800c3f0 <chThdGetSelfX>
 800c81a:	4603      	mov	r3, r0
 800c81c:	9a01      	ldr	r2, [sp, #4]
 800c81e:	63da      	str	r2, [r3, #60]	; 0x3c
  chSysUnlock();
 800c820:	f7ff fdc6 	bl	800c3b0 <chSysUnlock>
#endif
}
 800c824:	b003      	add	sp, #12
 800c826:	f85d fb04 	ldr.w	pc, [sp], #4
 800c82a:	bf00      	nop
 800c82c:	f3af 8000 	nop.w

0800c830 <thd4_execute>:
 * <h2>Description</h2>
 * Delay APIs and associated macros are tested, the invoking thread is verified
 * to wake up at the exact expected time.
 */

static void thd4_execute(void) {
 800c830:	b500      	push	{lr}
 800c832:	b083      	sub	sp, #12
  systime_t time;

  test_wait_tick();
 800c834:	f7ff fbfc 	bl	800c030 <test_wait_tick>

  /* Timeouts in microseconds.*/
  time = chVTGetSystemTime();
 800c838:	f7ff fdca 	bl	800c3d0 <chVTGetSystemTime>
 800c83c:	9001      	str	r0, [sp, #4]
  chThdSleepMicroseconds(100000);
 800c83e:	2064      	movs	r0, #100	; 0x64
 800c840:	f7f4 fd46 	bl	80012d0 <chThdSleep>
  test_assert_time_window(1,
 800c844:	9b01      	ldr	r3, [sp, #4]
 800c846:	f103 0264 	add.w	r2, r3, #100	; 0x64
 800c84a:	9b01      	ldr	r3, [sp, #4]
 800c84c:	3365      	adds	r3, #101	; 0x65
 800c84e:	2001      	movs	r0, #1
 800c850:	4611      	mov	r1, r2
 800c852:	461a      	mov	r2, r3
 800c854:	f7ff fb8c 	bl	800bf70 <_test_assert_time_window>
 800c858:	4603      	mov	r3, r0
 800c85a:	2b00      	cmp	r3, #0
 800c85c:	d000      	beq.n	800c860 <thd4_execute+0x30>
 800c85e:	e03c      	b.n	800c8da <thd4_execute+0xaa>
                          time + US2ST(100000),
                          time + US2ST(100000) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in milliseconds.*/
  time = chVTGetSystemTime();
 800c860:	f7ff fdb6 	bl	800c3d0 <chVTGetSystemTime>
 800c864:	9001      	str	r0, [sp, #4]
  chThdSleepMilliseconds(100);
 800c866:	2064      	movs	r0, #100	; 0x64
 800c868:	f7f4 fd32 	bl	80012d0 <chThdSleep>
  test_assert_time_window(2,
 800c86c:	9b01      	ldr	r3, [sp, #4]
 800c86e:	f103 0264 	add.w	r2, r3, #100	; 0x64
 800c872:	9b01      	ldr	r3, [sp, #4]
 800c874:	3365      	adds	r3, #101	; 0x65
 800c876:	2002      	movs	r0, #2
 800c878:	4611      	mov	r1, r2
 800c87a:	461a      	mov	r2, r3
 800c87c:	f7ff fb78 	bl	800bf70 <_test_assert_time_window>
 800c880:	4603      	mov	r3, r0
 800c882:	2b00      	cmp	r3, #0
 800c884:	d000      	beq.n	800c888 <thd4_execute+0x58>
 800c886:	e028      	b.n	800c8da <thd4_execute+0xaa>
                          time + MS2ST(100),
                          time + MS2ST(100) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in seconds.*/
  time = chVTGetSystemTime();
 800c888:	f7ff fda2 	bl	800c3d0 <chVTGetSystemTime>
 800c88c:	9001      	str	r0, [sp, #4]
  chThdSleepSeconds(1);
 800c88e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800c892:	f7f4 fd1d 	bl	80012d0 <chThdSleep>
  test_assert_time_window(3,
 800c896:	9b01      	ldr	r3, [sp, #4]
 800c898:	f503 727a 	add.w	r2, r3, #1000	; 0x3e8
 800c89c:	9b01      	ldr	r3, [sp, #4]
 800c89e:	f203 33e9 	addw	r3, r3, #1001	; 0x3e9
 800c8a2:	2003      	movs	r0, #3
 800c8a4:	4611      	mov	r1, r2
 800c8a6:	461a      	mov	r2, r3
 800c8a8:	f7ff fb62 	bl	800bf70 <_test_assert_time_window>
 800c8ac:	4603      	mov	r3, r0
 800c8ae:	2b00      	cmp	r3, #0
 800c8b0:	d000      	beq.n	800c8b4 <thd4_execute+0x84>
 800c8b2:	e012      	b.n	800c8da <thd4_execute+0xaa>
                          time + S2ST(1),
                          time + S2ST(1) + CH_CFG_ST_TIMEDELTA + 1);

  /* Absolute timelines.*/
  time = chVTGetSystemTime() + MS2ST(100);
 800c8b4:	f7ff fd8c 	bl	800c3d0 <chVTGetSystemTime>
 800c8b8:	4603      	mov	r3, r0
 800c8ba:	3364      	adds	r3, #100	; 0x64
 800c8bc:	9301      	str	r3, [sp, #4]
  chThdSleepUntil(time);
 800c8be:	9801      	ldr	r0, [sp, #4]
 800c8c0:	f7f4 fd16 	bl	80012f0 <chThdSleepUntil>
  test_assert_time_window(4,
 800c8c4:	9b01      	ldr	r3, [sp, #4]
 800c8c6:	3301      	adds	r3, #1
 800c8c8:	2004      	movs	r0, #4
 800c8ca:	9901      	ldr	r1, [sp, #4]
 800c8cc:	461a      	mov	r2, r3
 800c8ce:	f7ff fb4f 	bl	800bf70 <_test_assert_time_window>
 800c8d2:	4603      	mov	r3, r0
 800c8d4:	2b00      	cmp	r3, #0
 800c8d6:	d000      	beq.n	800c8da <thd4_execute+0xaa>
 800c8d8:	bf00      	nop
                          time,
                          time + CH_CFG_ST_TIMEDELTA + 1);
}
 800c8da:	b003      	add	sp, #12
 800c8dc:	f85d fb04 	ldr.w	pc, [sp], #4

0800c8e0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800c8e0:	b082      	sub	sp, #8
 800c8e2:	2320      	movs	r3, #32
 800c8e4:	9301      	str	r3, [sp, #4]
 800c8e6:	9b01      	ldr	r3, [sp, #4]
 800c8e8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800c8ec:	b002      	add	sp, #8
 800c8ee:	4770      	bx	lr

0800c8f0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800c8f0:	b082      	sub	sp, #8
 800c8f2:	2300      	movs	r3, #0
 800c8f4:	9301      	str	r3, [sp, #4]
 800c8f6:	9b01      	ldr	r3, [sp, #4]
 800c8f8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800c8fc:	b002      	add	sp, #8
 800c8fe:	4770      	bx	lr

0800c900 <queue_isempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {
 800c900:	b082      	sub	sp, #8
 800c902:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next == (const thread_t *)tqp);
 800c904:	9b01      	ldr	r3, [sp, #4]
 800c906:	681a      	ldr	r2, [r3, #0]
 800c908:	9b01      	ldr	r3, [sp, #4]
 800c90a:	429a      	cmp	r2, r3
 800c90c:	bf14      	ite	ne
 800c90e:	2300      	movne	r3, #0
 800c910:	2301      	moveq	r3, #1
 800c912:	b2db      	uxtb	r3, r3
}
 800c914:	4618      	mov	r0, r3
 800c916:	b002      	add	sp, #8
 800c918:	4770      	bx	lr
 800c91a:	bf00      	nop
 800c91c:	f3af 8000 	nop.w

0800c920 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800c920:	b508      	push	{r3, lr}

  port_lock();
 800c922:	f7ff ffdd 	bl	800c8e0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800c926:	bd08      	pop	{r3, pc}
 800c928:	f3af 8000 	nop.w
 800c92c:	f3af 8000 	nop.w

0800c930 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800c930:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800c932:	f7ff ffdd 	bl	800c8f0 <port_unlock>
}
 800c936:	bd08      	pop	{r3, pc}
 800c938:	f3af 8000 	nop.w
 800c93c:	f3af 8000 	nop.w

0800c940 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 800c940:	4b01      	ldr	r3, [pc, #4]	; (800c948 <chVTGetSystemTimeX+0x8>)
 800c942:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800c944:	4618      	mov	r0, r3
 800c946:	4770      	bx	lr
 800c948:	200016e0 	.word	0x200016e0
 800c94c:	f3af 8000 	nop.w

0800c950 <chVTGetSystemTime>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 800c950:	b500      	push	{lr}
 800c952:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 800c954:	f7ff ffe4 	bl	800c920 <chSysLock>
  systime = chVTGetSystemTimeX();
 800c958:	f7ff fff2 	bl	800c940 <chVTGetSystemTimeX>
 800c95c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 800c95e:	f7ff ffe7 	bl	800c930 <chSysUnlock>

  return systime;
 800c962:	9b01      	ldr	r3, [sp, #4]
}
 800c964:	4618      	mov	r0, r3
 800c966:	b003      	add	sp, #12
 800c968:	f85d fb04 	ldr.w	pc, [sp], #4
 800c96c:	f3af 8000 	nop.w

0800c970 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800c970:	4b01      	ldr	r3, [pc, #4]	; (800c978 <chThdGetSelfX+0x8>)
 800c972:	699b      	ldr	r3, [r3, #24]
}
 800c974:	4618      	mov	r0, r3
 800c976:	4770      	bx	lr
 800c978:	200016e0 	.word	0x200016e0
 800c97c:	f3af 8000 	nop.w

0800c980 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800c980:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800c982:	f7ff fff5 	bl	800c970 <chThdGetSelfX>
 800c986:	4603      	mov	r3, r0
 800c988:	689b      	ldr	r3, [r3, #8]
}
 800c98a:	4618      	mov	r0, r3
 800c98c:	bd08      	pop	{r3, pc}
 800c98e:	bf00      	nop

0800c990 <chSemGetCounterI>:
 * @param[in] sp        pointer to a @p semaphore_t structure
 * @return              The semaphore counter value.
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {
 800c990:	b082      	sub	sp, #8
 800c992:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return sp->s_cnt;
 800c994:	9b01      	ldr	r3, [sp, #4]
 800c996:	689b      	ldr	r3, [r3, #8]
}
 800c998:	4618      	mov	r0, r3
 800c99a:	b002      	add	sp, #8
 800c99c:	4770      	bx	lr
 800c99e:	bf00      	nop

0800c9a0 <chBSemObjectInit>:
 *                      - @a true, the initial state is taken.
 *                      .
 *
 * @init
 */
static inline void chBSemObjectInit(binary_semaphore_t *bsp, bool taken) {
 800c9a0:	b500      	push	{lr}
 800c9a2:	b083      	sub	sp, #12
 800c9a4:	9001      	str	r0, [sp, #4]
 800c9a6:	460b      	mov	r3, r1
 800c9a8:	f88d 3003 	strb.w	r3, [sp, #3]

  chSemObjectInit(&bsp->bs_sem, taken ? (cnt_t)0 : (cnt_t)1);
 800c9ac:	9a01      	ldr	r2, [sp, #4]
 800c9ae:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800c9b2:	2b00      	cmp	r3, #0
 800c9b4:	d001      	beq.n	800c9ba <chBSemObjectInit+0x1a>
 800c9b6:	2300      	movs	r3, #0
 800c9b8:	e000      	b.n	800c9bc <chBSemObjectInit+0x1c>
 800c9ba:	2301      	movs	r3, #1
 800c9bc:	4610      	mov	r0, r2
 800c9be:	4619      	mov	r1, r3
 800c9c0:	f7f5 f87e 	bl	8001ac0 <chSemObjectInit>
}
 800c9c4:	b003      	add	sp, #12
 800c9c6:	f85d fb04 	ldr.w	pc, [sp], #4
 800c9ca:	bf00      	nop
 800c9cc:	f3af 8000 	nop.w

0800c9d0 <chBSemWait>:
 * @retval MSG_RESET    if the binary semaphore has been reset using
 *                      @p bsemReset().
 *
 * @api
 */
static inline msg_t chBSemWait(binary_semaphore_t *bsp) {
 800c9d0:	b500      	push	{lr}
 800c9d2:	b083      	sub	sp, #12
 800c9d4:	9001      	str	r0, [sp, #4]

  return chSemWait(&bsp->bs_sem);
 800c9d6:	9b01      	ldr	r3, [sp, #4]
 800c9d8:	4618      	mov	r0, r3
 800c9da:	f7f5 f8b9 	bl	8001b50 <chSemWait>
 800c9de:	4603      	mov	r3, r0
}
 800c9e0:	4618      	mov	r0, r3
 800c9e2:	b003      	add	sp, #12
 800c9e4:	f85d fb04 	ldr.w	pc, [sp], #4
 800c9e8:	f3af 8000 	nop.w
 800c9ec:	f3af 8000 	nop.w

0800c9f0 <chBSemReset>:
 *                      - @a true, the new state is taken.
 *                      .
 *
 * @api
 */
static inline void chBSemReset(binary_semaphore_t *bsp, bool taken) {
 800c9f0:	b500      	push	{lr}
 800c9f2:	b083      	sub	sp, #12
 800c9f4:	9001      	str	r0, [sp, #4]
 800c9f6:	460b      	mov	r3, r1
 800c9f8:	f88d 3003 	strb.w	r3, [sp, #3]

  chSemReset(&bsp->bs_sem, taken ? (cnt_t)0 : (cnt_t)1);
 800c9fc:	9a01      	ldr	r2, [sp, #4]
 800c9fe:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800ca02:	2b00      	cmp	r3, #0
 800ca04:	d001      	beq.n	800ca0a <chBSemReset+0x1a>
 800ca06:	2300      	movs	r3, #0
 800ca08:	e000      	b.n	800ca0c <chBSemReset+0x1c>
 800ca0a:	2301      	movs	r3, #1
 800ca0c:	4610      	mov	r0, r2
 800ca0e:	4619      	mov	r1, r3
 800ca10:	f7f5 f866 	bl	8001ae0 <chSemReset>
}
 800ca14:	b003      	add	sp, #12
 800ca16:	f85d fb04 	ldr.w	pc, [sp], #4
 800ca1a:	bf00      	nop
 800ca1c:	f3af 8000 	nop.w

0800ca20 <chBSemSignalI>:
 *
 * @param[in] bsp       pointer to a @p binary_semaphore_t structure
 *
 * @iclass
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {
 800ca20:	b500      	push	{lr}
 800ca22:	b083      	sub	sp, #12
 800ca24:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 800ca26:	9b01      	ldr	r3, [sp, #4]
 800ca28:	689b      	ldr	r3, [r3, #8]
 800ca2a:	2b00      	cmp	r3, #0
 800ca2c:	dc03      	bgt.n	800ca36 <chBSemSignalI+0x16>
    chSemSignalI(&bsp->bs_sem);
 800ca2e:	9b01      	ldr	r3, [sp, #4]
 800ca30:	4618      	mov	r0, r3
 800ca32:	f7f5 f92d 	bl	8001c90 <chSemSignalI>
  }
}
 800ca36:	b003      	add	sp, #12
 800ca38:	f85d fb04 	ldr.w	pc, [sp], #4
 800ca3c:	f3af 8000 	nop.w

0800ca40 <chBSemSignal>:
 *
 * @param[in] bsp       pointer to a @p binary_semaphore_t structure
 *
 * @api
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {
 800ca40:	b500      	push	{lr}
 800ca42:	b083      	sub	sp, #12
 800ca44:	9001      	str	r0, [sp, #4]

  chSysLock();
 800ca46:	f7ff ff6b 	bl	800c920 <chSysLock>
  chBSemSignalI(bsp);
 800ca4a:	9801      	ldr	r0, [sp, #4]
 800ca4c:	f7ff ffe8 	bl	800ca20 <chBSemSignalI>
  chSchRescheduleS();
 800ca50:	f7f4 f996 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 800ca54:	f7ff ff6c 	bl	800c930 <chSysUnlock>
}
 800ca58:	b003      	add	sp, #12
 800ca5a:	f85d fb04 	ldr.w	pc, [sp], #4
 800ca5e:	bf00      	nop

0800ca60 <chBSemGetStateI>:
 * @retval false        if the binary semaphore is not taken.
 * @retval true         if the binary semaphore is taken.
 *
 * @iclass
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {
 800ca60:	b082      	sub	sp, #8
 800ca62:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bsp->bs_sem.s_cnt > (cnt_t)0) ? false : true;
 800ca64:	9b01      	ldr	r3, [sp, #4]
 800ca66:	689b      	ldr	r3, [r3, #8]
 800ca68:	2b00      	cmp	r3, #0
 800ca6a:	bfcc      	ite	gt
 800ca6c:	2300      	movgt	r3, #0
 800ca6e:	2301      	movle	r3, #1
 800ca70:	b2db      	uxtb	r3, r3
}
 800ca72:	4618      	mov	r0, r3
 800ca74:	b002      	add	sp, #8
 800ca76:	4770      	bx	lr
 800ca78:	f3af 8000 	nop.w
 800ca7c:	f3af 8000 	nop.w

0800ca80 <sem1_setup>:
 * The test expects that the threads reach their goal in FIFO order or
 * priority order depending on the CH_CFG_USE_SEMAPHORES_PRIORITY configuration
 * setting.
 */

static void sem1_setup(void) {
 800ca80:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 0);
 800ca82:	4802      	ldr	r0, [pc, #8]	; (800ca8c <sem1_setup+0xc>)
 800ca84:	2100      	movs	r1, #0
 800ca86:	f7f5 f81b 	bl	8001ac0 <chSemObjectInit>
}
 800ca8a:	bd08      	pop	{r3, pc}
 800ca8c:	20000838 	.word	0x20000838

0800ca90 <thread1>:

static THD_FUNCTION(thread1, p) {
 800ca90:	b500      	push	{lr}
 800ca92:	b083      	sub	sp, #12
 800ca94:	9001      	str	r0, [sp, #4]

  chSemWait(&sem1);
 800ca96:	4805      	ldr	r0, [pc, #20]	; (800caac <thread1+0x1c>)
 800ca98:	f7f5 f85a 	bl	8001b50 <chSemWait>
  test_emit_token(*(char *)p);
 800ca9c:	9b01      	ldr	r3, [sp, #4]
 800ca9e:	781b      	ldrb	r3, [r3, #0]
 800caa0:	4618      	mov	r0, r3
 800caa2:	f7ff f9ed 	bl	800be80 <test_emit_token>
}
 800caa6:	b003      	add	sp, #12
 800caa8:	f85d fb04 	ldr.w	pc, [sp], #4
 800caac:	20000838 	.word	0x20000838

0800cab0 <sem1_execute>:

static void sem1_execute(void) {
 800cab0:	b510      	push	{r4, lr}
 800cab2:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 800cab4:	4b54      	ldr	r3, [pc, #336]	; (800cc08 <sem1_execute+0x158>)
 800cab6:	681c      	ldr	r4, [r3, #0]
 800cab8:	f7ff ff62 	bl	800c980 <chThdGetPriorityX>
 800cabc:	4603      	mov	r3, r0
 800cabe:	3305      	adds	r3, #5
 800cac0:	4a52      	ldr	r2, [pc, #328]	; (800cc0c <sem1_execute+0x15c>)
 800cac2:	9200      	str	r2, [sp, #0]
 800cac4:	4620      	mov	r0, r4
 800cac6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800caca:	461a      	mov	r2, r3
 800cacc:	4b50      	ldr	r3, [pc, #320]	; (800cc10 <sem1_execute+0x160>)
 800cace:	f7f4 fb87 	bl	80011e0 <chThdCreateStatic>
 800cad2:	4602      	mov	r2, r0
 800cad4:	4b4f      	ldr	r3, [pc, #316]	; (800cc14 <sem1_execute+0x164>)
 800cad6:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 800cad8:	4b4b      	ldr	r3, [pc, #300]	; (800cc08 <sem1_execute+0x158>)
 800cada:	685c      	ldr	r4, [r3, #4]
 800cadc:	f7ff ff50 	bl	800c980 <chThdGetPriorityX>
 800cae0:	4603      	mov	r3, r0
 800cae2:	3301      	adds	r3, #1
 800cae4:	4a4c      	ldr	r2, [pc, #304]	; (800cc18 <sem1_execute+0x168>)
 800cae6:	9200      	str	r2, [sp, #0]
 800cae8:	4620      	mov	r0, r4
 800caea:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800caee:	461a      	mov	r2, r3
 800caf0:	4b47      	ldr	r3, [pc, #284]	; (800cc10 <sem1_execute+0x160>)
 800caf2:	f7f4 fb75 	bl	80011e0 <chThdCreateStatic>
 800caf6:	4602      	mov	r2, r0
 800caf8:	4b46      	ldr	r3, [pc, #280]	; (800cc14 <sem1_execute+0x164>)
 800cafa:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 800cafc:	4b42      	ldr	r3, [pc, #264]	; (800cc08 <sem1_execute+0x158>)
 800cafe:	689c      	ldr	r4, [r3, #8]
 800cb00:	f7ff ff3e 	bl	800c980 <chThdGetPriorityX>
 800cb04:	4603      	mov	r3, r0
 800cb06:	3303      	adds	r3, #3
 800cb08:	4a44      	ldr	r2, [pc, #272]	; (800cc1c <sem1_execute+0x16c>)
 800cb0a:	9200      	str	r2, [sp, #0]
 800cb0c:	4620      	mov	r0, r4
 800cb0e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cb12:	461a      	mov	r2, r3
 800cb14:	4b3e      	ldr	r3, [pc, #248]	; (800cc10 <sem1_execute+0x160>)
 800cb16:	f7f4 fb63 	bl	80011e0 <chThdCreateStatic>
 800cb1a:	4602      	mov	r2, r0
 800cb1c:	4b3d      	ldr	r3, [pc, #244]	; (800cc14 <sem1_execute+0x164>)
 800cb1e:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 800cb20:	4b39      	ldr	r3, [pc, #228]	; (800cc08 <sem1_execute+0x158>)
 800cb22:	68dc      	ldr	r4, [r3, #12]
 800cb24:	f7ff ff2c 	bl	800c980 <chThdGetPriorityX>
 800cb28:	4603      	mov	r3, r0
 800cb2a:	3304      	adds	r3, #4
 800cb2c:	4a3c      	ldr	r2, [pc, #240]	; (800cc20 <sem1_execute+0x170>)
 800cb2e:	9200      	str	r2, [sp, #0]
 800cb30:	4620      	mov	r0, r4
 800cb32:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cb36:	461a      	mov	r2, r3
 800cb38:	4b35      	ldr	r3, [pc, #212]	; (800cc10 <sem1_execute+0x160>)
 800cb3a:	f7f4 fb51 	bl	80011e0 <chThdCreateStatic>
 800cb3e:	4602      	mov	r2, r0
 800cb40:	4b34      	ldr	r3, [pc, #208]	; (800cc14 <sem1_execute+0x164>)
 800cb42:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 800cb44:	4b30      	ldr	r3, [pc, #192]	; (800cc08 <sem1_execute+0x158>)
 800cb46:	691c      	ldr	r4, [r3, #16]
 800cb48:	f7ff ff1a 	bl	800c980 <chThdGetPriorityX>
 800cb4c:	4603      	mov	r3, r0
 800cb4e:	3302      	adds	r3, #2
 800cb50:	4a34      	ldr	r2, [pc, #208]	; (800cc24 <sem1_execute+0x174>)
 800cb52:	9200      	str	r2, [sp, #0]
 800cb54:	4620      	mov	r0, r4
 800cb56:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cb5a:	461a      	mov	r2, r3
 800cb5c:	4b2c      	ldr	r3, [pc, #176]	; (800cc10 <sem1_execute+0x160>)
 800cb5e:	f7f4 fb3f 	bl	80011e0 <chThdCreateStatic>
 800cb62:	4602      	mov	r2, r0
 800cb64:	4b2b      	ldr	r3, [pc, #172]	; (800cc14 <sem1_execute+0x164>)
 800cb66:	611a      	str	r2, [r3, #16]
  chSemSignal(&sem1);
 800cb68:	482f      	ldr	r0, [pc, #188]	; (800cc28 <sem1_execute+0x178>)
 800cb6a:	f7f5 f871 	bl	8001c50 <chSemSignal>
  chSemSignal(&sem1);
 800cb6e:	482e      	ldr	r0, [pc, #184]	; (800cc28 <sem1_execute+0x178>)
 800cb70:	f7f5 f86e 	bl	8001c50 <chSemSignal>
  chSemSignal(&sem1);
 800cb74:	482c      	ldr	r0, [pc, #176]	; (800cc28 <sem1_execute+0x178>)
 800cb76:	f7f5 f86b 	bl	8001c50 <chSemSignal>
  chSemSignal(&sem1);
 800cb7a:	482b      	ldr	r0, [pc, #172]	; (800cc28 <sem1_execute+0x178>)
 800cb7c:	f7f5 f868 	bl	8001c50 <chSemSignal>
  chSemSignal(&sem1);
 800cb80:	4829      	ldr	r0, [pc, #164]	; (800cc28 <sem1_execute+0x178>)
 800cb82:	f7f5 f865 	bl	8001c50 <chSemSignal>
  test_wait_threads();
 800cb86:	f7ff fa2b 	bl	800bfe0 <test_wait_threads>
#if CH_CFG_USE_SEMAPHORES_PRIORITY
  test_assert_sequence(1, "ADCEB");
#else
  test_assert_sequence(1, "ABCDE");
 800cb8a:	2001      	movs	r0, #1
 800cb8c:	4927      	ldr	r1, [pc, #156]	; (800cc2c <sem1_execute+0x17c>)
 800cb8e:	f7ff f9bf 	bl	800bf10 <_test_assert_sequence>
 800cb92:	4603      	mov	r3, r0
 800cb94:	2b00      	cmp	r3, #0
 800cb96:	d000      	beq.n	800cb9a <sem1_execute+0xea>
 800cb98:	e034      	b.n	800cc04 <sem1_execute+0x154>
#endif
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 800cb9a:	4b1b      	ldr	r3, [pc, #108]	; (800cc08 <sem1_execute+0x158>)
 800cb9c:	681c      	ldr	r4, [r3, #0]
 800cb9e:	f7ff feef 	bl	800c980 <chThdGetPriorityX>
 800cba2:	4603      	mov	r3, r0
 800cba4:	3305      	adds	r3, #5
 800cba6:	4a19      	ldr	r2, [pc, #100]	; (800cc0c <sem1_execute+0x15c>)
 800cba8:	9200      	str	r2, [sp, #0]
 800cbaa:	4620      	mov	r0, r4
 800cbac:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cbb0:	461a      	mov	r2, r3
 800cbb2:	4b17      	ldr	r3, [pc, #92]	; (800cc10 <sem1_execute+0x160>)
 800cbb4:	f7f4 fb14 	bl	80011e0 <chThdCreateStatic>
 800cbb8:	4602      	mov	r2, r0
 800cbba:	4b16      	ldr	r3, [pc, #88]	; (800cc14 <sem1_execute+0x164>)
 800cbbc:	601a      	str	r2, [r3, #0]
  chSysLock();
 800cbbe:	f7ff feaf 	bl	800c920 <chSysLock>
  chSemAddCounterI(&sem1, 2);
 800cbc2:	4819      	ldr	r0, [pc, #100]	; (800cc28 <sem1_execute+0x178>)
 800cbc4:	2102      	movs	r1, #2
 800cbc6:	f7f5 f883 	bl	8001cd0 <chSemAddCounterI>
  chSchRescheduleS();
 800cbca:	f7f4 f8d9 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 800cbce:	f7ff feaf 	bl	800c930 <chSysUnlock>
  test_wait_threads();
 800cbd2:	f7ff fa05 	bl	800bfe0 <test_wait_threads>
  test_assert_lock(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
 800cbd6:	f7ff fea3 	bl	800c920 <chSysLock>
 800cbda:	4813      	ldr	r0, [pc, #76]	; (800cc28 <sem1_execute+0x178>)
 800cbdc:	f7ff fed8 	bl	800c990 <chSemGetCounterI>
 800cbe0:	4603      	mov	r3, r0
 800cbe2:	2b01      	cmp	r3, #1
 800cbe4:	bf14      	ite	ne
 800cbe6:	2300      	movne	r3, #0
 800cbe8:	2301      	moveq	r3, #1
 800cbea:	b2db      	uxtb	r3, r3
 800cbec:	2002      	movs	r0, #2
 800cbee:	4619      	mov	r1, r3
 800cbf0:	f7ff f976 	bl	800bee0 <_test_assert>
 800cbf4:	4603      	mov	r3, r0
 800cbf6:	2b00      	cmp	r3, #0
 800cbf8:	d002      	beq.n	800cc00 <sem1_execute+0x150>
 800cbfa:	f7ff fe99 	bl	800c930 <chSysUnlock>
 800cbfe:	e001      	b.n	800cc04 <sem1_execute+0x154>
 800cc00:	f7ff fe96 	bl	800c930 <chSysUnlock>
}
 800cc04:	b002      	add	sp, #8
 800cc06:	bd10      	pop	{r4, pc}
 800cc08:	08017b20 	.word	0x08017b20
 800cc0c:	08017e10 	.word	0x08017e10
 800cc10:	0800ca91 	.word	0x0800ca91
 800cc14:	20001ba4 	.word	0x20001ba4
 800cc18:	08017e14 	.word	0x08017e14
 800cc1c:	08017e18 	.word	0x08017e18
 800cc20:	08017e1c 	.word	0x08017e1c
 800cc24:	08017e20 	.word	0x08017e20
 800cc28:	20000838 	.word	0x20000838
 800cc2c:	08017e24 	.word	0x08017e24

0800cc30 <sem2_setup>:
 * The test expects that the semaphore wait function returns the correct value
 * in each of the above scenario and that the semaphore structure status is
 * correct after each operation.
 */

static void sem2_setup(void) {
 800cc30:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 0);
 800cc32:	4802      	ldr	r0, [pc, #8]	; (800cc3c <sem2_setup+0xc>)
 800cc34:	2100      	movs	r1, #0
 800cc36:	f7f4 ff43 	bl	8001ac0 <chSemObjectInit>
}
 800cc3a:	bd08      	pop	{r3, pc}
 800cc3c:	20000838 	.word	0x20000838

0800cc40 <thread2>:

static THD_FUNCTION(thread2, p) {
 800cc40:	b500      	push	{lr}
 800cc42:	b083      	sub	sp, #12
 800cc44:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(50);
 800cc46:	2032      	movs	r0, #50	; 0x32
 800cc48:	f7f4 fb42 	bl	80012d0 <chThdSleep>
  chSysLock();
 800cc4c:	f7ff fe68 	bl	800c920 <chSysLock>
  chSemSignalI(&sem1); /* For coverage reasons */
 800cc50:	4804      	ldr	r0, [pc, #16]	; (800cc64 <thread2+0x24>)
 800cc52:	f7f5 f81d 	bl	8001c90 <chSemSignalI>
  chSchRescheduleS();
 800cc56:	f7f4 f893 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 800cc5a:	f7ff fe69 	bl	800c930 <chSysUnlock>
}
 800cc5e:	b003      	add	sp, #12
 800cc60:	f85d fb04 	ldr.w	pc, [sp], #4
 800cc64:	20000838 	.word	0x20000838
 800cc68:	f3af 8000 	nop.w
 800cc6c:	f3af 8000 	nop.w

0800cc70 <sem2_execute>:

static void sem2_execute(void) {
 800cc70:	b510      	push	{r4, lr}
 800cc72:	b086      	sub	sp, #24
  msg_t msg;

  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
 800cc74:	4866      	ldr	r0, [pc, #408]	; (800ce10 <sem2_execute+0x1a0>)
 800cc76:	2100      	movs	r1, #0
 800cc78:	f7f4 ffa2 	bl	8001bc0 <chSemWaitTimeout>
 800cc7c:	9004      	str	r0, [sp, #16]
  test_assert(1, msg == MSG_TIMEOUT, "wrong wake-up message");
 800cc7e:	9b04      	ldr	r3, [sp, #16]
 800cc80:	f1b3 3fff 	cmp.w	r3, #4294967295
 800cc84:	bf14      	ite	ne
 800cc86:	2300      	movne	r3, #0
 800cc88:	2301      	moveq	r3, #1
 800cc8a:	b2db      	uxtb	r3, r3
 800cc8c:	2001      	movs	r0, #1
 800cc8e:	4619      	mov	r1, r3
 800cc90:	f7ff f926 	bl	800bee0 <_test_assert>
 800cc94:	4603      	mov	r3, r0
 800cc96:	2b00      	cmp	r3, #0
 800cc98:	d000      	beq.n	800cc9c <sem2_execute+0x2c>
 800cc9a:	e0b6      	b.n	800ce0a <sem2_execute+0x19a>
  test_assert(2, queue_isempty(&sem1.s_queue), "queue not empty");
 800cc9c:	485c      	ldr	r0, [pc, #368]	; (800ce10 <sem2_execute+0x1a0>)
 800cc9e:	f7ff fe2f 	bl	800c900 <queue_isempty>
 800cca2:	4603      	mov	r3, r0
 800cca4:	2002      	movs	r0, #2
 800cca6:	4619      	mov	r1, r3
 800cca8:	f7ff f91a 	bl	800bee0 <_test_assert>
 800ccac:	4603      	mov	r3, r0
 800ccae:	2b00      	cmp	r3, #0
 800ccb0:	d000      	beq.n	800ccb4 <sem2_execute+0x44>
 800ccb2:	e0aa      	b.n	800ce0a <sem2_execute+0x19a>
  test_assert(3, sem1.s_cnt == 0, "counter not zero");
 800ccb4:	4b56      	ldr	r3, [pc, #344]	; (800ce10 <sem2_execute+0x1a0>)
 800ccb6:	689b      	ldr	r3, [r3, #8]
 800ccb8:	2b00      	cmp	r3, #0
 800ccba:	bf14      	ite	ne
 800ccbc:	2300      	movne	r3, #0
 800ccbe:	2301      	moveq	r3, #1
 800ccc0:	b2db      	uxtb	r3, r3
 800ccc2:	2003      	movs	r0, #3
 800ccc4:	4619      	mov	r1, r3
 800ccc6:	f7ff f90b 	bl	800bee0 <_test_assert>
 800ccca:	4603      	mov	r3, r0
 800cccc:	2b00      	cmp	r3, #0
 800ccce:	d000      	beq.n	800ccd2 <sem2_execute+0x62>
 800ccd0:	e09b      	b.n	800ce0a <sem2_execute+0x19a>

  /*
   * Testing not timeout condition.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800ccd2:	4b50      	ldr	r3, [pc, #320]	; (800ce14 <sem2_execute+0x1a4>)
 800ccd4:	681c      	ldr	r4, [r3, #0]
 800ccd6:	f7ff fe53 	bl	800c980 <chThdGetPriorityX>
 800ccda:	4603      	mov	r3, r0
 800ccdc:	3b01      	subs	r3, #1
 800ccde:	2200      	movs	r2, #0
 800cce0:	9200      	str	r2, [sp, #0]
 800cce2:	4620      	mov	r0, r4
 800cce4:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cce8:	461a      	mov	r2, r3
 800ccea:	4b4b      	ldr	r3, [pc, #300]	; (800ce18 <sem2_execute+0x1a8>)
 800ccec:	f7f4 fa78 	bl	80011e0 <chThdCreateStatic>
 800ccf0:	4602      	mov	r2, r0
 800ccf2:	4b4a      	ldr	r3, [pc, #296]	; (800ce1c <sem2_execute+0x1ac>)
 800ccf4:	601a      	str	r2, [r3, #0]
                                 thread2, 0);
  msg = chSemWaitTimeout(&sem1, MS2ST(500));
 800ccf6:	4846      	ldr	r0, [pc, #280]	; (800ce10 <sem2_execute+0x1a0>)
 800ccf8:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 800ccfc:	f7f4 ff60 	bl	8001bc0 <chSemWaitTimeout>
 800cd00:	9004      	str	r0, [sp, #16]
  test_wait_threads();
 800cd02:	f7ff f96d 	bl	800bfe0 <test_wait_threads>
  test_assert(4, msg == MSG_OK, "wrong wake-up message");
 800cd06:	9b04      	ldr	r3, [sp, #16]
 800cd08:	2b00      	cmp	r3, #0
 800cd0a:	bf14      	ite	ne
 800cd0c:	2300      	movne	r3, #0
 800cd0e:	2301      	moveq	r3, #1
 800cd10:	b2db      	uxtb	r3, r3
 800cd12:	2004      	movs	r0, #4
 800cd14:	4619      	mov	r1, r3
 800cd16:	f7ff f8e3 	bl	800bee0 <_test_assert>
 800cd1a:	4603      	mov	r3, r0
 800cd1c:	2b00      	cmp	r3, #0
 800cd1e:	d000      	beq.n	800cd22 <sem2_execute+0xb2>
 800cd20:	e073      	b.n	800ce0a <sem2_execute+0x19a>
  test_assert(5, queue_isempty(&sem1.s_queue), "queue not empty");
 800cd22:	483b      	ldr	r0, [pc, #236]	; (800ce10 <sem2_execute+0x1a0>)
 800cd24:	f7ff fdec 	bl	800c900 <queue_isempty>
 800cd28:	4603      	mov	r3, r0
 800cd2a:	2005      	movs	r0, #5
 800cd2c:	4619      	mov	r1, r3
 800cd2e:	f7ff f8d7 	bl	800bee0 <_test_assert>
 800cd32:	4603      	mov	r3, r0
 800cd34:	2b00      	cmp	r3, #0
 800cd36:	d000      	beq.n	800cd3a <sem2_execute+0xca>
 800cd38:	e067      	b.n	800ce0a <sem2_execute+0x19a>
  test_assert(6, sem1.s_cnt == 0, "counter not zero");
 800cd3a:	4b35      	ldr	r3, [pc, #212]	; (800ce10 <sem2_execute+0x1a0>)
 800cd3c:	689b      	ldr	r3, [r3, #8]
 800cd3e:	2b00      	cmp	r3, #0
 800cd40:	bf14      	ite	ne
 800cd42:	2300      	movne	r3, #0
 800cd44:	2301      	moveq	r3, #1
 800cd46:	b2db      	uxtb	r3, r3
 800cd48:	2006      	movs	r0, #6
 800cd4a:	4619      	mov	r1, r3
 800cd4c:	f7ff f8c8 	bl	800bee0 <_test_assert>
 800cd50:	4603      	mov	r3, r0
 800cd52:	2b00      	cmp	r3, #0
 800cd54:	d000      	beq.n	800cd58 <sem2_execute+0xe8>
 800cd56:	e058      	b.n	800ce0a <sem2_execute+0x19a>

  /*
   * Testing timeout condition.
   */
  test_wait_tick();
 800cd58:	f7ff f96a 	bl	800c030 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
 800cd5c:	f7ff fdf8 	bl	800c950 <chVTGetSystemTime>
 800cd60:	4603      	mov	r3, r0
 800cd62:	33fa      	adds	r3, #250	; 0xfa
 800cd64:	9303      	str	r3, [sp, #12]
  for (i = 0; i < 5; i++) {
 800cd66:	2300      	movs	r3, #0
 800cd68:	9305      	str	r3, [sp, #20]
 800cd6a:	e038      	b.n	800cdde <sem2_execute+0x16e>
    test_emit_token('A' + i);
 800cd6c:	9b05      	ldr	r3, [sp, #20]
 800cd6e:	b2db      	uxtb	r3, r3
 800cd70:	3341      	adds	r3, #65	; 0x41
 800cd72:	b2db      	uxtb	r3, r3
 800cd74:	4618      	mov	r0, r3
 800cd76:	f7ff f883 	bl	800be80 <test_emit_token>
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
 800cd7a:	4825      	ldr	r0, [pc, #148]	; (800ce10 <sem2_execute+0x1a0>)
 800cd7c:	2132      	movs	r1, #50	; 0x32
 800cd7e:	f7f4 ff1f 	bl	8001bc0 <chSemWaitTimeout>
 800cd82:	9004      	str	r0, [sp, #16]
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
 800cd84:	9b04      	ldr	r3, [sp, #16]
 800cd86:	f1b3 3fff 	cmp.w	r3, #4294967295
 800cd8a:	bf14      	ite	ne
 800cd8c:	2300      	movne	r3, #0
 800cd8e:	2301      	moveq	r3, #1
 800cd90:	b2db      	uxtb	r3, r3
 800cd92:	2007      	movs	r0, #7
 800cd94:	4619      	mov	r1, r3
 800cd96:	f7ff f8a3 	bl	800bee0 <_test_assert>
 800cd9a:	4603      	mov	r3, r0
 800cd9c:	2b00      	cmp	r3, #0
 800cd9e:	d000      	beq.n	800cda2 <sem2_execute+0x132>
 800cda0:	e033      	b.n	800ce0a <sem2_execute+0x19a>
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
 800cda2:	481b      	ldr	r0, [pc, #108]	; (800ce10 <sem2_execute+0x1a0>)
 800cda4:	f7ff fdac 	bl	800c900 <queue_isempty>
 800cda8:	4603      	mov	r3, r0
 800cdaa:	2008      	movs	r0, #8
 800cdac:	4619      	mov	r1, r3
 800cdae:	f7ff f897 	bl	800bee0 <_test_assert>
 800cdb2:	4603      	mov	r3, r0
 800cdb4:	2b00      	cmp	r3, #0
 800cdb6:	d000      	beq.n	800cdba <sem2_execute+0x14a>
 800cdb8:	e027      	b.n	800ce0a <sem2_execute+0x19a>
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
 800cdba:	4b15      	ldr	r3, [pc, #84]	; (800ce10 <sem2_execute+0x1a0>)
 800cdbc:	689b      	ldr	r3, [r3, #8]
 800cdbe:	2b00      	cmp	r3, #0
 800cdc0:	bf14      	ite	ne
 800cdc2:	2300      	movne	r3, #0
 800cdc4:	2301      	moveq	r3, #1
 800cdc6:	b2db      	uxtb	r3, r3
 800cdc8:	2009      	movs	r0, #9
 800cdca:	4619      	mov	r1, r3
 800cdcc:	f7ff f888 	bl	800bee0 <_test_assert>
 800cdd0:	4603      	mov	r3, r0
 800cdd2:	2b00      	cmp	r3, #0
 800cdd4:	d000      	beq.n	800cdd8 <sem2_execute+0x168>
 800cdd6:	e018      	b.n	800ce0a <sem2_execute+0x19a>
  /*
   * Testing timeout condition.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
  for (i = 0; i < 5; i++) {
 800cdd8:	9b05      	ldr	r3, [sp, #20]
 800cdda:	3301      	adds	r3, #1
 800cddc:	9305      	str	r3, [sp, #20]
 800cdde:	9b05      	ldr	r3, [sp, #20]
 800cde0:	2b04      	cmp	r3, #4
 800cde2:	ddc3      	ble.n	800cd6c <sem2_execute+0xfc>
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
 800cde4:	200a      	movs	r0, #10
 800cde6:	490e      	ldr	r1, [pc, #56]	; (800ce20 <sem2_execute+0x1b0>)
 800cde8:	f7ff f892 	bl	800bf10 <_test_assert_sequence>
 800cdec:	4603      	mov	r3, r0
 800cdee:	2b00      	cmp	r3, #0
 800cdf0:	d000      	beq.n	800cdf4 <sem2_execute+0x184>
 800cdf2:	e00a      	b.n	800ce0a <sem2_execute+0x19a>
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
 800cdf4:	9b03      	ldr	r3, [sp, #12]
 800cdf6:	3302      	adds	r3, #2
 800cdf8:	200b      	movs	r0, #11
 800cdfa:	9903      	ldr	r1, [sp, #12]
 800cdfc:	461a      	mov	r2, r3
 800cdfe:	f7ff f8b7 	bl	800bf70 <_test_assert_time_window>
 800ce02:	4603      	mov	r3, r0
 800ce04:	2b00      	cmp	r3, #0
 800ce06:	d000      	beq.n	800ce0a <sem2_execute+0x19a>
 800ce08:	bf00      	nop
}
 800ce0a:	b006      	add	sp, #24
 800ce0c:	bd10      	pop	{r4, pc}
 800ce0e:	bf00      	nop
 800ce10:	20000838 	.word	0x20000838
 800ce14:	08017b20 	.word	0x08017b20
 800ce18:	0800cc41 	.word	0x0800cc41
 800ce1c:	20001ba4 	.word	0x20001ba4
 800ce20:	08017e24 	.word	0x08017e24
 800ce24:	f3af 8000 	nop.w
 800ce28:	f3af 8000 	nop.w
 800ce2c:	f3af 8000 	nop.w

0800ce30 <sem3_setup>:
 * The test expects that the semaphore wait function returns the correct value
 * in each of the above scenario and that the semaphore structure status is
 * correct after each operation.
 */

static void sem3_setup(void) {
 800ce30:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 0);
 800ce32:	4802      	ldr	r0, [pc, #8]	; (800ce3c <sem3_setup+0xc>)
 800ce34:	2100      	movs	r1, #0
 800ce36:	f7f4 fe43 	bl	8001ac0 <chSemObjectInit>
}
 800ce3a:	bd08      	pop	{r3, pc}
 800ce3c:	20000838 	.word	0x20000838

0800ce40 <thread3>:

static THD_FUNCTION(thread3, p) {
 800ce40:	b500      	push	{lr}
 800ce42:	b083      	sub	sp, #12
 800ce44:	9001      	str	r0, [sp, #4]

  (void)p;
  chSemWait(&sem1);
 800ce46:	4804      	ldr	r0, [pc, #16]	; (800ce58 <thread3+0x18>)
 800ce48:	f7f4 fe82 	bl	8001b50 <chSemWait>
  chSemSignal(&sem1);
 800ce4c:	4802      	ldr	r0, [pc, #8]	; (800ce58 <thread3+0x18>)
 800ce4e:	f7f4 feff 	bl	8001c50 <chSemSignal>
}
 800ce52:	b003      	add	sp, #12
 800ce54:	f85d fb04 	ldr.w	pc, [sp], #4
 800ce58:	20000838 	.word	0x20000838
 800ce5c:	f3af 8000 	nop.w

0800ce60 <sem3_execute>:

static void sem3_execute(void) {
 800ce60:	b510      	push	{r4, lr}
 800ce62:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 800ce64:	4b28      	ldr	r3, [pc, #160]	; (800cf08 <sem3_execute+0xa8>)
 800ce66:	681c      	ldr	r4, [r3, #0]
 800ce68:	f7ff fd8a 	bl	800c980 <chThdGetPriorityX>
 800ce6c:	4603      	mov	r3, r0
 800ce6e:	3301      	adds	r3, #1
 800ce70:	2200      	movs	r2, #0
 800ce72:	9200      	str	r2, [sp, #0]
 800ce74:	4620      	mov	r0, r4
 800ce76:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800ce7a:	461a      	mov	r2, r3
 800ce7c:	4b23      	ldr	r3, [pc, #140]	; (800cf0c <sem3_execute+0xac>)
 800ce7e:	f7f4 f9af 	bl	80011e0 <chThdCreateStatic>
 800ce82:	4602      	mov	r2, r0
 800ce84:	4b22      	ldr	r3, [pc, #136]	; (800cf10 <sem3_execute+0xb0>)
 800ce86:	601a      	str	r2, [r3, #0]
  chSemSignalWait(&sem1, &sem1);
 800ce88:	4822      	ldr	r0, [pc, #136]	; (800cf14 <sem3_execute+0xb4>)
 800ce8a:	4922      	ldr	r1, [pc, #136]	; (800cf14 <sem3_execute+0xb4>)
 800ce8c:	f7f4 ff48 	bl	8001d20 <chSemSignalWait>
  test_assert(1, queue_isempty(&sem1.s_queue), "queue not empty");
 800ce90:	4820      	ldr	r0, [pc, #128]	; (800cf14 <sem3_execute+0xb4>)
 800ce92:	f7ff fd35 	bl	800c900 <queue_isempty>
 800ce96:	4603      	mov	r3, r0
 800ce98:	2001      	movs	r0, #1
 800ce9a:	4619      	mov	r1, r3
 800ce9c:	f7ff f820 	bl	800bee0 <_test_assert>
 800cea0:	4603      	mov	r3, r0
 800cea2:	2b00      	cmp	r3, #0
 800cea4:	d000      	beq.n	800cea8 <sem3_execute+0x48>
 800cea6:	e02d      	b.n	800cf04 <sem3_execute+0xa4>
  test_assert(2, sem1.s_cnt == 0, "counter not zero");
 800cea8:	4b1a      	ldr	r3, [pc, #104]	; (800cf14 <sem3_execute+0xb4>)
 800ceaa:	689b      	ldr	r3, [r3, #8]
 800ceac:	2b00      	cmp	r3, #0
 800ceae:	bf14      	ite	ne
 800ceb0:	2300      	movne	r3, #0
 800ceb2:	2301      	moveq	r3, #1
 800ceb4:	b2db      	uxtb	r3, r3
 800ceb6:	2002      	movs	r0, #2
 800ceb8:	4619      	mov	r1, r3
 800ceba:	f7ff f811 	bl	800bee0 <_test_assert>
 800cebe:	4603      	mov	r3, r0
 800cec0:	2b00      	cmp	r3, #0
 800cec2:	d000      	beq.n	800cec6 <sem3_execute+0x66>
 800cec4:	e01e      	b.n	800cf04 <sem3_execute+0xa4>

  chSemSignalWait(&sem1, &sem1);
 800cec6:	4813      	ldr	r0, [pc, #76]	; (800cf14 <sem3_execute+0xb4>)
 800cec8:	4912      	ldr	r1, [pc, #72]	; (800cf14 <sem3_execute+0xb4>)
 800ceca:	f7f4 ff29 	bl	8001d20 <chSemSignalWait>
  test_assert(3, queue_isempty(&sem1.s_queue), "queue not empty");
 800cece:	4811      	ldr	r0, [pc, #68]	; (800cf14 <sem3_execute+0xb4>)
 800ced0:	f7ff fd16 	bl	800c900 <queue_isempty>
 800ced4:	4603      	mov	r3, r0
 800ced6:	2003      	movs	r0, #3
 800ced8:	4619      	mov	r1, r3
 800ceda:	f7ff f801 	bl	800bee0 <_test_assert>
 800cede:	4603      	mov	r3, r0
 800cee0:	2b00      	cmp	r3, #0
 800cee2:	d000      	beq.n	800cee6 <sem3_execute+0x86>
 800cee4:	e00e      	b.n	800cf04 <sem3_execute+0xa4>
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
 800cee6:	4b0b      	ldr	r3, [pc, #44]	; (800cf14 <sem3_execute+0xb4>)
 800cee8:	689b      	ldr	r3, [r3, #8]
 800ceea:	2b00      	cmp	r3, #0
 800ceec:	bf14      	ite	ne
 800ceee:	2300      	movne	r3, #0
 800cef0:	2301      	moveq	r3, #1
 800cef2:	b2db      	uxtb	r3, r3
 800cef4:	2004      	movs	r0, #4
 800cef6:	4619      	mov	r1, r3
 800cef8:	f7fe fff2 	bl	800bee0 <_test_assert>
 800cefc:	4603      	mov	r3, r0
 800cefe:	2b00      	cmp	r3, #0
 800cf00:	d000      	beq.n	800cf04 <sem3_execute+0xa4>
 800cf02:	bf00      	nop
}
 800cf04:	b002      	add	sp, #8
 800cf06:	bd10      	pop	{r4, pc}
 800cf08:	08017b20 	.word	0x08017b20
 800cf0c:	0800ce41 	.word	0x0800ce41
 800cf10:	20001ba4 	.word	0x20001ba4
 800cf14:	20000838 	.word	0x20000838
 800cf18:	f3af 8000 	nop.w
 800cf1c:	f3af 8000 	nop.w

0800cf20 <thread4>:
 * <h2>Description</h2>
 * This test case tests the binary semaphores functionality. The test both
 * checks the binary semaphore status and the expected status of the underlying
 * counting semaphore.
 */
static THD_FUNCTION(thread4, p) {
 800cf20:	b500      	push	{lr}
 800cf22:	b083      	sub	sp, #12
 800cf24:	9001      	str	r0, [sp, #4]

  chBSemSignal((binary_semaphore_t *)p);
 800cf26:	9801      	ldr	r0, [sp, #4]
 800cf28:	f7ff fd8a 	bl	800ca40 <chBSemSignal>
}
 800cf2c:	b003      	add	sp, #12
 800cf2e:	f85d fb04 	ldr.w	pc, [sp], #4
 800cf32:	bf00      	nop
 800cf34:	f3af 8000 	nop.w
 800cf38:	f3af 8000 	nop.w
 800cf3c:	f3af 8000 	nop.w

0800cf40 <sem4_execute>:

static void sem4_execute(void) {
 800cf40:	b510      	push	{r4, lr}
 800cf42:	b086      	sub	sp, #24
  binary_semaphore_t bsem;
  
  /* Creates a taken binary semaphore.*/
  chBSemObjectInit(&bsem, TRUE);
 800cf44:	ab03      	add	r3, sp, #12
 800cf46:	4618      	mov	r0, r3
 800cf48:	2101      	movs	r1, #1
 800cf4a:	f7ff fd29 	bl	800c9a0 <chBSemObjectInit>
  chBSemReset(&bsem, TRUE);
 800cf4e:	ab03      	add	r3, sp, #12
 800cf50:	4618      	mov	r0, r3
 800cf52:	2101      	movs	r1, #1
 800cf54:	f7ff fd4c 	bl	800c9f0 <chBSemReset>
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");
 800cf58:	f7ff fce2 	bl	800c920 <chSysLock>
 800cf5c:	ab03      	add	r3, sp, #12
 800cf5e:	4618      	mov	r0, r3
 800cf60:	f7ff fd7e 	bl	800ca60 <chBSemGetStateI>
 800cf64:	4603      	mov	r3, r0
 800cf66:	2b00      	cmp	r3, #0
 800cf68:	bf0c      	ite	eq
 800cf6a:	2300      	moveq	r3, #0
 800cf6c:	2301      	movne	r3, #1
 800cf6e:	b2db      	uxtb	r3, r3
 800cf70:	2001      	movs	r0, #1
 800cf72:	4619      	mov	r1, r3
 800cf74:	f7fe ffb4 	bl	800bee0 <_test_assert>
 800cf78:	4603      	mov	r3, r0
 800cf7a:	2b00      	cmp	r3, #0
 800cf7c:	d002      	beq.n	800cf84 <sem4_execute+0x44>
 800cf7e:	f7ff fcd7 	bl	800c930 <chSysUnlock>
 800cf82:	e0a3      	b.n	800d0cc <sem4_execute+0x18c>
 800cf84:	f7ff fcd4 	bl	800c930 <chSysUnlock>

  /* Starts a signaler thread at a lower priority.*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 800cf88:	4b51      	ldr	r3, [pc, #324]	; (800d0d0 <sem4_execute+0x190>)
 800cf8a:	681c      	ldr	r4, [r3, #0]
                                 chThdGetPriorityX()-1, thread4, &bsem);
 800cf8c:	f7ff fcf8 	bl	800c980 <chThdGetPriorityX>
 800cf90:	4603      	mov	r3, r0
  chBSemObjectInit(&bsem, TRUE);
  chBSemReset(&bsem, TRUE);
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");

  /* Starts a signaler thread at a lower priority.*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 800cf92:	3b01      	subs	r3, #1
 800cf94:	aa03      	add	r2, sp, #12
 800cf96:	9200      	str	r2, [sp, #0]
 800cf98:	4620      	mov	r0, r4
 800cf9a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cf9e:	461a      	mov	r2, r3
 800cfa0:	4b4c      	ldr	r3, [pc, #304]	; (800d0d4 <sem4_execute+0x194>)
 800cfa2:	f7f4 f91d 	bl	80011e0 <chThdCreateStatic>
 800cfa6:	4602      	mov	r2, r0
 800cfa8:	4b4b      	ldr	r3, [pc, #300]	; (800d0d8 <sem4_execute+0x198>)
 800cfaa:	601a      	str	r2, [r3, #0]
                                 chThdGetPriorityX()-1, thread4, &bsem);
                                 
  /* Waits to be signaled.*/
  chBSemWait(&bsem);
 800cfac:	ab03      	add	r3, sp, #12
 800cfae:	4618      	mov	r0, r3
 800cfb0:	f7ff fd0e 	bl	800c9d0 <chBSemWait>
  
  /* The binary semaphore is expected to be taken.*/
  test_assert_lock(2, chBSemGetStateI(&bsem) == TRUE, "not taken");
 800cfb4:	f7ff fcb4 	bl	800c920 <chSysLock>
 800cfb8:	ab03      	add	r3, sp, #12
 800cfba:	4618      	mov	r0, r3
 800cfbc:	f7ff fd50 	bl	800ca60 <chBSemGetStateI>
 800cfc0:	4603      	mov	r3, r0
 800cfc2:	2b00      	cmp	r3, #0
 800cfc4:	bf0c      	ite	eq
 800cfc6:	2300      	moveq	r3, #0
 800cfc8:	2301      	movne	r3, #1
 800cfca:	b2db      	uxtb	r3, r3
 800cfcc:	2002      	movs	r0, #2
 800cfce:	4619      	mov	r1, r3
 800cfd0:	f7fe ff86 	bl	800bee0 <_test_assert>
 800cfd4:	4603      	mov	r3, r0
 800cfd6:	2b00      	cmp	r3, #0
 800cfd8:	d002      	beq.n	800cfe0 <sem4_execute+0xa0>
 800cfda:	f7ff fca9 	bl	800c930 <chSysUnlock>
 800cfde:	e075      	b.n	800d0cc <sem4_execute+0x18c>
 800cfe0:	f7ff fca6 	bl	800c930 <chSysUnlock>

  /* Releasing it, check both the binary semaphore state and the underlying
     counter semaphore state..*/
  chBSemSignal(&bsem);
 800cfe4:	ab03      	add	r3, sp, #12
 800cfe6:	4618      	mov	r0, r3
 800cfe8:	f7ff fd2a 	bl	800ca40 <chBSemSignal>
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "still taken");
 800cfec:	f7ff fc98 	bl	800c920 <chSysLock>
 800cff0:	ab03      	add	r3, sp, #12
 800cff2:	4618      	mov	r0, r3
 800cff4:	f7ff fd34 	bl	800ca60 <chBSemGetStateI>
 800cff8:	4603      	mov	r3, r0
 800cffa:	2b00      	cmp	r3, #0
 800cffc:	bf0c      	ite	eq
 800cffe:	2300      	moveq	r3, #0
 800d000:	2301      	movne	r3, #1
 800d002:	b2db      	uxtb	r3, r3
 800d004:	f083 0301 	eor.w	r3, r3, #1
 800d008:	b2db      	uxtb	r3, r3
 800d00a:	f003 0301 	and.w	r3, r3, #1
 800d00e:	b2db      	uxtb	r3, r3
 800d010:	2003      	movs	r0, #3
 800d012:	4619      	mov	r1, r3
 800d014:	f7fe ff64 	bl	800bee0 <_test_assert>
 800d018:	4603      	mov	r3, r0
 800d01a:	2b00      	cmp	r3, #0
 800d01c:	d002      	beq.n	800d024 <sem4_execute+0xe4>
 800d01e:	f7ff fc87 	bl	800c930 <chSysUnlock>
 800d022:	e053      	b.n	800d0cc <sem4_execute+0x18c>
 800d024:	f7ff fc84 	bl	800c930 <chSysUnlock>
  test_assert_lock(4, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 800d028:	f7ff fc7a 	bl	800c920 <chSysLock>
 800d02c:	ab03      	add	r3, sp, #12
 800d02e:	4618      	mov	r0, r3
 800d030:	f7ff fcae 	bl	800c990 <chSemGetCounterI>
 800d034:	4603      	mov	r3, r0
 800d036:	2b01      	cmp	r3, #1
 800d038:	bf14      	ite	ne
 800d03a:	2300      	movne	r3, #0
 800d03c:	2301      	moveq	r3, #1
 800d03e:	b2db      	uxtb	r3, r3
 800d040:	2004      	movs	r0, #4
 800d042:	4619      	mov	r1, r3
 800d044:	f7fe ff4c 	bl	800bee0 <_test_assert>
 800d048:	4603      	mov	r3, r0
 800d04a:	2b00      	cmp	r3, #0
 800d04c:	d002      	beq.n	800d054 <sem4_execute+0x114>
 800d04e:	f7ff fc6f 	bl	800c930 <chSysUnlock>
 800d052:	e03b      	b.n	800d0cc <sem4_execute+0x18c>
 800d054:	f7ff fc6c 	bl	800c930 <chSysUnlock>

  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
 800d058:	ab03      	add	r3, sp, #12
 800d05a:	4618      	mov	r0, r3
 800d05c:	f7ff fcf0 	bl	800ca40 <chBSemSignal>
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
 800d060:	f7ff fc5e 	bl	800c920 <chSysLock>
 800d064:	ab03      	add	r3, sp, #12
 800d066:	4618      	mov	r0, r3
 800d068:	f7ff fcfa 	bl	800ca60 <chBSemGetStateI>
 800d06c:	4603      	mov	r3, r0
 800d06e:	2b00      	cmp	r3, #0
 800d070:	bf0c      	ite	eq
 800d072:	2300      	moveq	r3, #0
 800d074:	2301      	movne	r3, #1
 800d076:	b2db      	uxtb	r3, r3
 800d078:	f083 0301 	eor.w	r3, r3, #1
 800d07c:	b2db      	uxtb	r3, r3
 800d07e:	f003 0301 	and.w	r3, r3, #1
 800d082:	b2db      	uxtb	r3, r3
 800d084:	2003      	movs	r0, #3
 800d086:	4619      	mov	r1, r3
 800d088:	f7fe ff2a 	bl	800bee0 <_test_assert>
 800d08c:	4603      	mov	r3, r0
 800d08e:	2b00      	cmp	r3, #0
 800d090:	d002      	beq.n	800d098 <sem4_execute+0x158>
 800d092:	f7ff fc4d 	bl	800c930 <chSysUnlock>
 800d096:	e019      	b.n	800d0cc <sem4_execute+0x18c>
 800d098:	f7ff fc4a 	bl	800c930 <chSysUnlock>
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 800d09c:	f7ff fc40 	bl	800c920 <chSysLock>
 800d0a0:	ab03      	add	r3, sp, #12
 800d0a2:	4618      	mov	r0, r3
 800d0a4:	f7ff fc74 	bl	800c990 <chSemGetCounterI>
 800d0a8:	4603      	mov	r3, r0
 800d0aa:	2b01      	cmp	r3, #1
 800d0ac:	bf14      	ite	ne
 800d0ae:	2300      	movne	r3, #0
 800d0b0:	2301      	moveq	r3, #1
 800d0b2:	b2db      	uxtb	r3, r3
 800d0b4:	2005      	movs	r0, #5
 800d0b6:	4619      	mov	r1, r3
 800d0b8:	f7fe ff12 	bl	800bee0 <_test_assert>
 800d0bc:	4603      	mov	r3, r0
 800d0be:	2b00      	cmp	r3, #0
 800d0c0:	d002      	beq.n	800d0c8 <sem4_execute+0x188>
 800d0c2:	f7ff fc35 	bl	800c930 <chSysUnlock>
 800d0c6:	e001      	b.n	800d0cc <sem4_execute+0x18c>
 800d0c8:	f7ff fc32 	bl	800c930 <chSysUnlock>
}
 800d0cc:	b006      	add	sp, #24
 800d0ce:	bd10      	pop	{r4, pc}
 800d0d0:	08017b20 	.word	0x08017b20
 800d0d4:	0800cf21 	.word	0x0800cf21
 800d0d8:	20001ba4 	.word	0x20001ba4
 800d0dc:	f3af 8000 	nop.w

0800d0e0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800d0e0:	b082      	sub	sp, #8
 800d0e2:	2320      	movs	r3, #32
 800d0e4:	9301      	str	r3, [sp, #4]
 800d0e6:	9b01      	ldr	r3, [sp, #4]
 800d0e8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800d0ec:	b002      	add	sp, #8
 800d0ee:	4770      	bx	lr

0800d0f0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800d0f0:	b082      	sub	sp, #8
 800d0f2:	2300      	movs	r3, #0
 800d0f4:	9301      	str	r3, [sp, #4]
 800d0f6:	9b01      	ldr	r3, [sp, #4]
 800d0f8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800d0fc:	b002      	add	sp, #8
 800d0fe:	4770      	bx	lr

0800d100 <queue_isempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {
 800d100:	b082      	sub	sp, #8
 800d102:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next == (const thread_t *)tqp);
 800d104:	9b01      	ldr	r3, [sp, #4]
 800d106:	681a      	ldr	r2, [r3, #0]
 800d108:	9b01      	ldr	r3, [sp, #4]
 800d10a:	429a      	cmp	r2, r3
 800d10c:	bf14      	ite	ne
 800d10e:	2300      	movne	r3, #0
 800d110:	2301      	moveq	r3, #1
 800d112:	b2db      	uxtb	r3, r3
}
 800d114:	4618      	mov	r0, r3
 800d116:	b002      	add	sp, #8
 800d118:	4770      	bx	lr
 800d11a:	bf00      	nop
 800d11c:	f3af 8000 	nop.w

0800d120 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800d120:	b508      	push	{r3, lr}

  port_lock();
 800d122:	f7ff ffdd 	bl	800d0e0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800d126:	bd08      	pop	{r3, pc}
 800d128:	f3af 8000 	nop.w
 800d12c:	f3af 8000 	nop.w

0800d130 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800d130:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800d132:	f7ff ffdd 	bl	800d0f0 <port_unlock>
}
 800d136:	bd08      	pop	{r3, pc}
 800d138:	f3af 8000 	nop.w
 800d13c:	f3af 8000 	nop.w

0800d140 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800d140:	4b01      	ldr	r3, [pc, #4]	; (800d148 <chThdGetSelfX+0x8>)
 800d142:	699b      	ldr	r3, [r3, #24]
}
 800d144:	4618      	mov	r0, r3
 800d146:	4770      	bx	lr
 800d148:	200016e0 	.word	0x200016e0
 800d14c:	f3af 8000 	nop.w

0800d150 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800d150:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800d152:	f7ff fff5 	bl	800d140 <chThdGetSelfX>
 800d156:	4603      	mov	r3, r0
 800d158:	689b      	ldr	r3, [r3, #8]
}
 800d15a:	4618      	mov	r0, r3
 800d15c:	bd08      	pop	{r3, pc}
 800d15e:	bf00      	nop

0800d160 <mtx1_setup>:
 * the mutex is unlocked.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void mtx1_setup(void) {
 800d160:	b508      	push	{r3, lr}

  chMtxObjectInit(&m1);
 800d162:	4802      	ldr	r0, [pc, #8]	; (800d16c <mtx1_setup+0xc>)
 800d164:	f7f4 fec4 	bl	8001ef0 <chMtxObjectInit>
}
 800d168:	bd08      	pop	{r3, pc}
 800d16a:	bf00      	nop
 800d16c:	20000844 	.word	0x20000844

0800d170 <thread1>:

static THD_FUNCTION(thread1, p) {
 800d170:	b500      	push	{lr}
 800d172:	b083      	sub	sp, #12
 800d174:	9001      	str	r0, [sp, #4]

  chMtxLock(&m1);
 800d176:	4807      	ldr	r0, [pc, #28]	; (800d194 <thread1+0x24>)
 800d178:	f7f4 feca 	bl	8001f10 <chMtxLock>
  test_emit_token(*(char *)p);
 800d17c:	9b01      	ldr	r3, [sp, #4]
 800d17e:	781b      	ldrb	r3, [r3, #0]
 800d180:	4618      	mov	r0, r3
 800d182:	f7fe fe7d 	bl	800be80 <test_emit_token>
  chMtxUnlock(&m1);
 800d186:	4803      	ldr	r0, [pc, #12]	; (800d194 <thread1+0x24>)
 800d188:	f7f4 ff6a 	bl	8002060 <chMtxUnlock>
}
 800d18c:	b003      	add	sp, #12
 800d18e:	f85d fb04 	ldr.w	pc, [sp], #4
 800d192:	bf00      	nop
 800d194:	20000844 	.word	0x20000844
 800d198:	f3af 8000 	nop.w
 800d19c:	f3af 8000 	nop.w

0800d1a0 <mtx1_execute>:

static void mtx1_execute(void) {
 800d1a0:	b500      	push	{lr}
 800d1a2:	b085      	sub	sp, #20

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
 800d1a4:	f7ff ffd4 	bl	800d150 <chThdGetPriorityX>
 800d1a8:	9003      	str	r0, [sp, #12]
  chMtxLock(&m1);
 800d1aa:	483a      	ldr	r0, [pc, #232]	; (800d294 <mtx1_execute+0xf4>)
 800d1ac:	f7f4 feb0 	bl	8001f10 <chMtxLock>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 800d1b0:	4b39      	ldr	r3, [pc, #228]	; (800d298 <mtx1_execute+0xf8>)
 800d1b2:	681a      	ldr	r2, [r3, #0]
 800d1b4:	9b03      	ldr	r3, [sp, #12]
 800d1b6:	3301      	adds	r3, #1
 800d1b8:	4938      	ldr	r1, [pc, #224]	; (800d29c <mtx1_execute+0xfc>)
 800d1ba:	9100      	str	r1, [sp, #0]
 800d1bc:	4610      	mov	r0, r2
 800d1be:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d1c2:	461a      	mov	r2, r3
 800d1c4:	4b36      	ldr	r3, [pc, #216]	; (800d2a0 <mtx1_execute+0x100>)
 800d1c6:	f7f4 f80b 	bl	80011e0 <chThdCreateStatic>
 800d1ca:	4602      	mov	r2, r0
 800d1cc:	4b35      	ldr	r3, [pc, #212]	; (800d2a4 <mtx1_execute+0x104>)
 800d1ce:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 800d1d0:	4b31      	ldr	r3, [pc, #196]	; (800d298 <mtx1_execute+0xf8>)
 800d1d2:	685a      	ldr	r2, [r3, #4]
 800d1d4:	9b03      	ldr	r3, [sp, #12]
 800d1d6:	3302      	adds	r3, #2
 800d1d8:	4933      	ldr	r1, [pc, #204]	; (800d2a8 <mtx1_execute+0x108>)
 800d1da:	9100      	str	r1, [sp, #0]
 800d1dc:	4610      	mov	r0, r2
 800d1de:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d1e2:	461a      	mov	r2, r3
 800d1e4:	4b2e      	ldr	r3, [pc, #184]	; (800d2a0 <mtx1_execute+0x100>)
 800d1e6:	f7f3 fffb 	bl	80011e0 <chThdCreateStatic>
 800d1ea:	4602      	mov	r2, r0
 800d1ec:	4b2d      	ldr	r3, [pc, #180]	; (800d2a4 <mtx1_execute+0x104>)
 800d1ee:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 800d1f0:	4b29      	ldr	r3, [pc, #164]	; (800d298 <mtx1_execute+0xf8>)
 800d1f2:	689a      	ldr	r2, [r3, #8]
 800d1f4:	9b03      	ldr	r3, [sp, #12]
 800d1f6:	3303      	adds	r3, #3
 800d1f8:	492c      	ldr	r1, [pc, #176]	; (800d2ac <mtx1_execute+0x10c>)
 800d1fa:	9100      	str	r1, [sp, #0]
 800d1fc:	4610      	mov	r0, r2
 800d1fe:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d202:	461a      	mov	r2, r3
 800d204:	4b26      	ldr	r3, [pc, #152]	; (800d2a0 <mtx1_execute+0x100>)
 800d206:	f7f3 ffeb 	bl	80011e0 <chThdCreateStatic>
 800d20a:	4602      	mov	r2, r0
 800d20c:	4b25      	ldr	r3, [pc, #148]	; (800d2a4 <mtx1_execute+0x104>)
 800d20e:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 800d210:	4b21      	ldr	r3, [pc, #132]	; (800d298 <mtx1_execute+0xf8>)
 800d212:	68da      	ldr	r2, [r3, #12]
 800d214:	9b03      	ldr	r3, [sp, #12]
 800d216:	3304      	adds	r3, #4
 800d218:	4925      	ldr	r1, [pc, #148]	; (800d2b0 <mtx1_execute+0x110>)
 800d21a:	9100      	str	r1, [sp, #0]
 800d21c:	4610      	mov	r0, r2
 800d21e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d222:	461a      	mov	r2, r3
 800d224:	4b1e      	ldr	r3, [pc, #120]	; (800d2a0 <mtx1_execute+0x100>)
 800d226:	f7f3 ffdb 	bl	80011e0 <chThdCreateStatic>
 800d22a:	4602      	mov	r2, r0
 800d22c:	4b1d      	ldr	r3, [pc, #116]	; (800d2a4 <mtx1_execute+0x104>)
 800d22e:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 800d230:	4b19      	ldr	r3, [pc, #100]	; (800d298 <mtx1_execute+0xf8>)
 800d232:	691a      	ldr	r2, [r3, #16]
 800d234:	9b03      	ldr	r3, [sp, #12]
 800d236:	3305      	adds	r3, #5
 800d238:	491e      	ldr	r1, [pc, #120]	; (800d2b4 <mtx1_execute+0x114>)
 800d23a:	9100      	str	r1, [sp, #0]
 800d23c:	4610      	mov	r0, r2
 800d23e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d242:	461a      	mov	r2, r3
 800d244:	4b16      	ldr	r3, [pc, #88]	; (800d2a0 <mtx1_execute+0x100>)
 800d246:	f7f3 ffcb 	bl	80011e0 <chThdCreateStatic>
 800d24a:	4602      	mov	r2, r0
 800d24c:	4b15      	ldr	r3, [pc, #84]	; (800d2a4 <mtx1_execute+0x104>)
 800d24e:	611a      	str	r2, [r3, #16]
  chMtxUnlock(&m1);
 800d250:	4810      	ldr	r0, [pc, #64]	; (800d294 <mtx1_execute+0xf4>)
 800d252:	f7f4 ff05 	bl	8002060 <chMtxUnlock>
  test_wait_threads();
 800d256:	f7fe fec3 	bl	800bfe0 <test_wait_threads>
  test_assert(1, prio == chThdGetPriorityX(), "wrong priority level");
 800d25a:	f7ff ff79 	bl	800d150 <chThdGetPriorityX>
 800d25e:	4602      	mov	r2, r0
 800d260:	9b03      	ldr	r3, [sp, #12]
 800d262:	429a      	cmp	r2, r3
 800d264:	bf14      	ite	ne
 800d266:	2300      	movne	r3, #0
 800d268:	2301      	moveq	r3, #1
 800d26a:	b2db      	uxtb	r3, r3
 800d26c:	2001      	movs	r0, #1
 800d26e:	4619      	mov	r1, r3
 800d270:	f7fe fe36 	bl	800bee0 <_test_assert>
 800d274:	4603      	mov	r3, r0
 800d276:	2b00      	cmp	r3, #0
 800d278:	d000      	beq.n	800d27c <mtx1_execute+0xdc>
 800d27a:	e007      	b.n	800d28c <mtx1_execute+0xec>
  test_assert_sequence(2, "ABCDE");
 800d27c:	2002      	movs	r0, #2
 800d27e:	490e      	ldr	r1, [pc, #56]	; (800d2b8 <mtx1_execute+0x118>)
 800d280:	f7fe fe46 	bl	800bf10 <_test_assert_sequence>
 800d284:	4603      	mov	r3, r0
 800d286:	2b00      	cmp	r3, #0
 800d288:	d000      	beq.n	800d28c <mtx1_execute+0xec>
 800d28a:	bf00      	nop
}
 800d28c:	b005      	add	sp, #20
 800d28e:	f85d fb04 	ldr.w	pc, [sp], #4
 800d292:	bf00      	nop
 800d294:	20000844 	.word	0x20000844
 800d298:	08017b20 	.word	0x08017b20
 800d29c:	08017ef0 	.word	0x08017ef0
 800d2a0:	0800d171 	.word	0x0800d171
 800d2a4:	20001ba4 	.word	0x20001ba4
 800d2a8:	08017ef4 	.word	0x08017ef4
 800d2ac:	08017ef8 	.word	0x08017ef8
 800d2b0:	08017efc 	.word	0x08017efc
 800d2b4:	08017f00 	.word	0x08017f00
 800d2b8:	08017f04 	.word	0x08017f04
 800d2bc:	f3af 8000 	nop.w

0800d2c0 <mtx4_setup>:
 * thread with precise timing.<br>
 * The test expects that the priority changes caused by the priority
 * inheritance algorithm happen at the right moment and with the right values.
 */

static void mtx4_setup(void) {
 800d2c0:	b508      	push	{r3, lr}

  chMtxObjectInit(&m1);
 800d2c2:	4803      	ldr	r0, [pc, #12]	; (800d2d0 <mtx4_setup+0x10>)
 800d2c4:	f7f4 fe14 	bl	8001ef0 <chMtxObjectInit>
  chMtxObjectInit(&m2);
 800d2c8:	4802      	ldr	r0, [pc, #8]	; (800d2d4 <mtx4_setup+0x14>)
 800d2ca:	f7f4 fe11 	bl	8001ef0 <chMtxObjectInit>
}
 800d2ce:	bd08      	pop	{r3, pc}
 800d2d0:	20000844 	.word	0x20000844
 800d2d4:	20000854 	.word	0x20000854
 800d2d8:	f3af 8000 	nop.w
 800d2dc:	f3af 8000 	nop.w

0800d2e0 <thread4a>:

static THD_FUNCTION(thread4a, p) {
 800d2e0:	b500      	push	{lr}
 800d2e2:	b083      	sub	sp, #12
 800d2e4:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(50);
 800d2e6:	2032      	movs	r0, #50	; 0x32
 800d2e8:	f7f3 fff2 	bl	80012d0 <chThdSleep>
  chMtxLock(&m2);
 800d2ec:	4804      	ldr	r0, [pc, #16]	; (800d300 <thread4a+0x20>)
 800d2ee:	f7f4 fe0f 	bl	8001f10 <chMtxLock>
  chMtxUnlock(&m2);
 800d2f2:	4803      	ldr	r0, [pc, #12]	; (800d300 <thread4a+0x20>)
 800d2f4:	f7f4 feb4 	bl	8002060 <chMtxUnlock>
}
 800d2f8:	b003      	add	sp, #12
 800d2fa:	f85d fb04 	ldr.w	pc, [sp], #4
 800d2fe:	bf00      	nop
 800d300:	20000854 	.word	0x20000854
 800d304:	f3af 8000 	nop.w
 800d308:	f3af 8000 	nop.w
 800d30c:	f3af 8000 	nop.w

0800d310 <thread4b>:

static THD_FUNCTION(thread4b, p) {
 800d310:	b500      	push	{lr}
 800d312:	b083      	sub	sp, #12
 800d314:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(150);
 800d316:	2096      	movs	r0, #150	; 0x96
 800d318:	f7f3 ffda 	bl	80012d0 <chThdSleep>
  chMtxLock(&m1);
 800d31c:	4804      	ldr	r0, [pc, #16]	; (800d330 <thread4b+0x20>)
 800d31e:	f7f4 fdf7 	bl	8001f10 <chMtxLock>
  chMtxUnlock(&m1);
 800d322:	4803      	ldr	r0, [pc, #12]	; (800d330 <thread4b+0x20>)
 800d324:	f7f4 fe9c 	bl	8002060 <chMtxUnlock>
}
 800d328:	b003      	add	sp, #12
 800d32a:	f85d fb04 	ldr.w	pc, [sp], #4
 800d32e:	bf00      	nop
 800d330:	20000844 	.word	0x20000844
 800d334:	f3af 8000 	nop.w
 800d338:	f3af 8000 	nop.w
 800d33c:	f3af 8000 	nop.w

0800d340 <mtx4_execute>:

static void mtx4_execute(void) {
 800d340:	b500      	push	{lr}
 800d342:	b087      	sub	sp, #28
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
 800d344:	f7ff ff04 	bl	800d150 <chThdGetPriorityX>
 800d348:	9005      	str	r0, [sp, #20]
  p1 = p + 1;
 800d34a:	9b05      	ldr	r3, [sp, #20]
 800d34c:	3301      	adds	r3, #1
 800d34e:	9304      	str	r3, [sp, #16]
  p2 = p + 2;
 800d350:	9b05      	ldr	r3, [sp, #20]
 800d352:	3302      	adds	r3, #2
 800d354:	9303      	str	r3, [sp, #12]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 800d356:	4ba1      	ldr	r3, [pc, #644]	; (800d5dc <mtx4_execute+0x29c>)
 800d358:	681b      	ldr	r3, [r3, #0]
 800d35a:	4aa1      	ldr	r2, [pc, #644]	; (800d5e0 <mtx4_execute+0x2a0>)
 800d35c:	9200      	str	r2, [sp, #0]
 800d35e:	4618      	mov	r0, r3
 800d360:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d364:	9a04      	ldr	r2, [sp, #16]
 800d366:	4b9f      	ldr	r3, [pc, #636]	; (800d5e4 <mtx4_execute+0x2a4>)
 800d368:	f7f3 ff3a 	bl	80011e0 <chThdCreateStatic>
 800d36c:	4602      	mov	r2, r0
 800d36e:	4b9e      	ldr	r3, [pc, #632]	; (800d5e8 <mtx4_execute+0x2a8>)
 800d370:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
 800d372:	4b9a      	ldr	r3, [pc, #616]	; (800d5dc <mtx4_execute+0x29c>)
 800d374:	685b      	ldr	r3, [r3, #4]
 800d376:	4a9d      	ldr	r2, [pc, #628]	; (800d5ec <mtx4_execute+0x2ac>)
 800d378:	9200      	str	r2, [sp, #0]
 800d37a:	4618      	mov	r0, r3
 800d37c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d380:	9a03      	ldr	r2, [sp, #12]
 800d382:	4b9b      	ldr	r3, [pc, #620]	; (800d5f0 <mtx4_execute+0x2b0>)
 800d384:	f7f3 ff2c 	bl	80011e0 <chThdCreateStatic>
 800d388:	4602      	mov	r2, r0
 800d38a:	4b97      	ldr	r3, [pc, #604]	; (800d5e8 <mtx4_execute+0x2a8>)
 800d38c:	605a      	str	r2, [r3, #4]
  chMtxLock(&m2);
 800d38e:	4899      	ldr	r0, [pc, #612]	; (800d5f4 <mtx4_execute+0x2b4>)
 800d390:	f7f4 fdbe 	bl	8001f10 <chMtxLock>
  test_assert(1, chThdGetPriorityX() == p, "wrong priority level");
 800d394:	f7ff fedc 	bl	800d150 <chThdGetPriorityX>
 800d398:	4602      	mov	r2, r0
 800d39a:	9b05      	ldr	r3, [sp, #20]
 800d39c:	429a      	cmp	r2, r3
 800d39e:	bf14      	ite	ne
 800d3a0:	2300      	movne	r3, #0
 800d3a2:	2301      	moveq	r3, #1
 800d3a4:	b2db      	uxtb	r3, r3
 800d3a6:	2001      	movs	r0, #1
 800d3a8:	4619      	mov	r1, r3
 800d3aa:	f7fe fd99 	bl	800bee0 <_test_assert>
 800d3ae:	4603      	mov	r3, r0
 800d3b0:	2b00      	cmp	r3, #0
 800d3b2:	d000      	beq.n	800d3b6 <mtx4_execute+0x76>
 800d3b4:	e13b      	b.n	800d62e <mtx4_execute+0x2ee>
  chThdSleepMilliseconds(100);
 800d3b6:	2064      	movs	r0, #100	; 0x64
 800d3b8:	f7f3 ff8a 	bl	80012d0 <chThdSleep>
  test_assert(2, chThdGetPriorityX() == p1, "wrong priority level");
 800d3bc:	f7ff fec8 	bl	800d150 <chThdGetPriorityX>
 800d3c0:	4602      	mov	r2, r0
 800d3c2:	9b04      	ldr	r3, [sp, #16]
 800d3c4:	429a      	cmp	r2, r3
 800d3c6:	bf14      	ite	ne
 800d3c8:	2300      	movne	r3, #0
 800d3ca:	2301      	moveq	r3, #1
 800d3cc:	b2db      	uxtb	r3, r3
 800d3ce:	2002      	movs	r0, #2
 800d3d0:	4619      	mov	r1, r3
 800d3d2:	f7fe fd85 	bl	800bee0 <_test_assert>
 800d3d6:	4603      	mov	r3, r0
 800d3d8:	2b00      	cmp	r3, #0
 800d3da:	d000      	beq.n	800d3de <mtx4_execute+0x9e>
 800d3dc:	e127      	b.n	800d62e <mtx4_execute+0x2ee>
  chMtxLock(&m1);
 800d3de:	4886      	ldr	r0, [pc, #536]	; (800d5f8 <mtx4_execute+0x2b8>)
 800d3e0:	f7f4 fd96 	bl	8001f10 <chMtxLock>
  test_assert(3, chThdGetPriorityX() == p1, "wrong priority level");
 800d3e4:	f7ff feb4 	bl	800d150 <chThdGetPriorityX>
 800d3e8:	4602      	mov	r2, r0
 800d3ea:	9b04      	ldr	r3, [sp, #16]
 800d3ec:	429a      	cmp	r2, r3
 800d3ee:	bf14      	ite	ne
 800d3f0:	2300      	movne	r3, #0
 800d3f2:	2301      	moveq	r3, #1
 800d3f4:	b2db      	uxtb	r3, r3
 800d3f6:	2003      	movs	r0, #3
 800d3f8:	4619      	mov	r1, r3
 800d3fa:	f7fe fd71 	bl	800bee0 <_test_assert>
 800d3fe:	4603      	mov	r3, r0
 800d400:	2b00      	cmp	r3, #0
 800d402:	d000      	beq.n	800d406 <mtx4_execute+0xc6>
 800d404:	e113      	b.n	800d62e <mtx4_execute+0x2ee>
  chThdSleepMilliseconds(100);
 800d406:	2064      	movs	r0, #100	; 0x64
 800d408:	f7f3 ff62 	bl	80012d0 <chThdSleep>
  test_assert(4, chThdGetPriorityX() == p2, "wrong priority level");
 800d40c:	f7ff fea0 	bl	800d150 <chThdGetPriorityX>
 800d410:	4602      	mov	r2, r0
 800d412:	9b03      	ldr	r3, [sp, #12]
 800d414:	429a      	cmp	r2, r3
 800d416:	bf14      	ite	ne
 800d418:	2300      	movne	r3, #0
 800d41a:	2301      	moveq	r3, #1
 800d41c:	b2db      	uxtb	r3, r3
 800d41e:	2004      	movs	r0, #4
 800d420:	4619      	mov	r1, r3
 800d422:	f7fe fd5d 	bl	800bee0 <_test_assert>
 800d426:	4603      	mov	r3, r0
 800d428:	2b00      	cmp	r3, #0
 800d42a:	d000      	beq.n	800d42e <mtx4_execute+0xee>
 800d42c:	e0ff      	b.n	800d62e <mtx4_execute+0x2ee>
  chMtxUnlock(&m1);
 800d42e:	4872      	ldr	r0, [pc, #456]	; (800d5f8 <mtx4_execute+0x2b8>)
 800d430:	f7f4 fe16 	bl	8002060 <chMtxUnlock>
  test_assert(5, chThdGetPriorityX() == p1, "wrong priority level");
 800d434:	f7ff fe8c 	bl	800d150 <chThdGetPriorityX>
 800d438:	4602      	mov	r2, r0
 800d43a:	9b04      	ldr	r3, [sp, #16]
 800d43c:	429a      	cmp	r2, r3
 800d43e:	bf14      	ite	ne
 800d440:	2300      	movne	r3, #0
 800d442:	2301      	moveq	r3, #1
 800d444:	b2db      	uxtb	r3, r3
 800d446:	2005      	movs	r0, #5
 800d448:	4619      	mov	r1, r3
 800d44a:	f7fe fd49 	bl	800bee0 <_test_assert>
 800d44e:	4603      	mov	r3, r0
 800d450:	2b00      	cmp	r3, #0
 800d452:	d000      	beq.n	800d456 <mtx4_execute+0x116>
 800d454:	e0eb      	b.n	800d62e <mtx4_execute+0x2ee>
  chThdSleepMilliseconds(100);
 800d456:	2064      	movs	r0, #100	; 0x64
 800d458:	f7f3 ff3a 	bl	80012d0 <chThdSleep>
  test_assert(6, chThdGetPriorityX() == p1, "wrong priority level");
 800d45c:	f7ff fe78 	bl	800d150 <chThdGetPriorityX>
 800d460:	4602      	mov	r2, r0
 800d462:	9b04      	ldr	r3, [sp, #16]
 800d464:	429a      	cmp	r2, r3
 800d466:	bf14      	ite	ne
 800d468:	2300      	movne	r3, #0
 800d46a:	2301      	moveq	r3, #1
 800d46c:	b2db      	uxtb	r3, r3
 800d46e:	2006      	movs	r0, #6
 800d470:	4619      	mov	r1, r3
 800d472:	f7fe fd35 	bl	800bee0 <_test_assert>
 800d476:	4603      	mov	r3, r0
 800d478:	2b00      	cmp	r3, #0
 800d47a:	d000      	beq.n	800d47e <mtx4_execute+0x13e>
 800d47c:	e0d7      	b.n	800d62e <mtx4_execute+0x2ee>
  chMtxUnlockAll();
 800d47e:	f7f4 fe97 	bl	80021b0 <chMtxUnlockAll>
  test_assert(7, chThdGetPriorityX() == p, "wrong priority level");
 800d482:	f7ff fe65 	bl	800d150 <chThdGetPriorityX>
 800d486:	4602      	mov	r2, r0
 800d488:	9b05      	ldr	r3, [sp, #20]
 800d48a:	429a      	cmp	r2, r3
 800d48c:	bf14      	ite	ne
 800d48e:	2300      	movne	r3, #0
 800d490:	2301      	moveq	r3, #1
 800d492:	b2db      	uxtb	r3, r3
 800d494:	2007      	movs	r0, #7
 800d496:	4619      	mov	r1, r3
 800d498:	f7fe fd22 	bl	800bee0 <_test_assert>
 800d49c:	4603      	mov	r3, r0
 800d49e:	2b00      	cmp	r3, #0
 800d4a0:	d000      	beq.n	800d4a4 <mtx4_execute+0x164>
 800d4a2:	e0c4      	b.n	800d62e <mtx4_execute+0x2ee>
  test_wait_threads();
 800d4a4:	f7fe fd9c 	bl	800bfe0 <test_wait_threads>

  /* Test repeated in order to cover chMtxUnlockS().*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "D");
 800d4a8:	4b4c      	ldr	r3, [pc, #304]	; (800d5dc <mtx4_execute+0x29c>)
 800d4aa:	681b      	ldr	r3, [r3, #0]
 800d4ac:	4a53      	ldr	r2, [pc, #332]	; (800d5fc <mtx4_execute+0x2bc>)
 800d4ae:	9200      	str	r2, [sp, #0]
 800d4b0:	4618      	mov	r0, r3
 800d4b2:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d4b6:	9a04      	ldr	r2, [sp, #16]
 800d4b8:	4b4a      	ldr	r3, [pc, #296]	; (800d5e4 <mtx4_execute+0x2a4>)
 800d4ba:	f7f3 fe91 	bl	80011e0 <chThdCreateStatic>
 800d4be:	4602      	mov	r2, r0
 800d4c0:	4b49      	ldr	r3, [pc, #292]	; (800d5e8 <mtx4_execute+0x2a8>)
 800d4c2:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "C");
 800d4c4:	4b45      	ldr	r3, [pc, #276]	; (800d5dc <mtx4_execute+0x29c>)
 800d4c6:	685b      	ldr	r3, [r3, #4]
 800d4c8:	4a4d      	ldr	r2, [pc, #308]	; (800d600 <mtx4_execute+0x2c0>)
 800d4ca:	9200      	str	r2, [sp, #0]
 800d4cc:	4618      	mov	r0, r3
 800d4ce:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d4d2:	9a03      	ldr	r2, [sp, #12]
 800d4d4:	4b46      	ldr	r3, [pc, #280]	; (800d5f0 <mtx4_execute+0x2b0>)
 800d4d6:	f7f3 fe83 	bl	80011e0 <chThdCreateStatic>
 800d4da:	4602      	mov	r2, r0
 800d4dc:	4b42      	ldr	r3, [pc, #264]	; (800d5e8 <mtx4_execute+0x2a8>)
 800d4de:	605a      	str	r2, [r3, #4]
  chMtxLock(&m2);
 800d4e0:	4844      	ldr	r0, [pc, #272]	; (800d5f4 <mtx4_execute+0x2b4>)
 800d4e2:	f7f4 fd15 	bl	8001f10 <chMtxLock>
  test_assert(8, chThdGetPriorityX() == p, "wrong priority level");
 800d4e6:	f7ff fe33 	bl	800d150 <chThdGetPriorityX>
 800d4ea:	4602      	mov	r2, r0
 800d4ec:	9b05      	ldr	r3, [sp, #20]
 800d4ee:	429a      	cmp	r2, r3
 800d4f0:	bf14      	ite	ne
 800d4f2:	2300      	movne	r3, #0
 800d4f4:	2301      	moveq	r3, #1
 800d4f6:	b2db      	uxtb	r3, r3
 800d4f8:	2008      	movs	r0, #8
 800d4fa:	4619      	mov	r1, r3
 800d4fc:	f7fe fcf0 	bl	800bee0 <_test_assert>
 800d500:	4603      	mov	r3, r0
 800d502:	2b00      	cmp	r3, #0
 800d504:	d000      	beq.n	800d508 <mtx4_execute+0x1c8>
 800d506:	e092      	b.n	800d62e <mtx4_execute+0x2ee>
  chThdSleepMilliseconds(100);
 800d508:	2064      	movs	r0, #100	; 0x64
 800d50a:	f7f3 fee1 	bl	80012d0 <chThdSleep>
  test_assert(9, chThdGetPriorityX() == p1, "wrong priority level");
 800d50e:	f7ff fe1f 	bl	800d150 <chThdGetPriorityX>
 800d512:	4602      	mov	r2, r0
 800d514:	9b04      	ldr	r3, [sp, #16]
 800d516:	429a      	cmp	r2, r3
 800d518:	bf14      	ite	ne
 800d51a:	2300      	movne	r3, #0
 800d51c:	2301      	moveq	r3, #1
 800d51e:	b2db      	uxtb	r3, r3
 800d520:	2009      	movs	r0, #9
 800d522:	4619      	mov	r1, r3
 800d524:	f7fe fcdc 	bl	800bee0 <_test_assert>
 800d528:	4603      	mov	r3, r0
 800d52a:	2b00      	cmp	r3, #0
 800d52c:	d000      	beq.n	800d530 <mtx4_execute+0x1f0>
 800d52e:	e07e      	b.n	800d62e <mtx4_execute+0x2ee>
  chMtxLock(&m1);
 800d530:	4831      	ldr	r0, [pc, #196]	; (800d5f8 <mtx4_execute+0x2b8>)
 800d532:	f7f4 fced 	bl	8001f10 <chMtxLock>
  test_assert(10, chThdGetPriorityX() == p1, "wrong priority level");
 800d536:	f7ff fe0b 	bl	800d150 <chThdGetPriorityX>
 800d53a:	4602      	mov	r2, r0
 800d53c:	9b04      	ldr	r3, [sp, #16]
 800d53e:	429a      	cmp	r2, r3
 800d540:	bf14      	ite	ne
 800d542:	2300      	movne	r3, #0
 800d544:	2301      	moveq	r3, #1
 800d546:	b2db      	uxtb	r3, r3
 800d548:	200a      	movs	r0, #10
 800d54a:	4619      	mov	r1, r3
 800d54c:	f7fe fcc8 	bl	800bee0 <_test_assert>
 800d550:	4603      	mov	r3, r0
 800d552:	2b00      	cmp	r3, #0
 800d554:	d000      	beq.n	800d558 <mtx4_execute+0x218>
 800d556:	e06a      	b.n	800d62e <mtx4_execute+0x2ee>
  chThdSleepMilliseconds(100);
 800d558:	2064      	movs	r0, #100	; 0x64
 800d55a:	f7f3 feb9 	bl	80012d0 <chThdSleep>
  test_assert(11, chThdGetPriorityX() == p2, "wrong priority level");
 800d55e:	f7ff fdf7 	bl	800d150 <chThdGetPriorityX>
 800d562:	4602      	mov	r2, r0
 800d564:	9b03      	ldr	r3, [sp, #12]
 800d566:	429a      	cmp	r2, r3
 800d568:	bf14      	ite	ne
 800d56a:	2300      	movne	r3, #0
 800d56c:	2301      	moveq	r3, #1
 800d56e:	b2db      	uxtb	r3, r3
 800d570:	200b      	movs	r0, #11
 800d572:	4619      	mov	r1, r3
 800d574:	f7fe fcb4 	bl	800bee0 <_test_assert>
 800d578:	4603      	mov	r3, r0
 800d57a:	2b00      	cmp	r3, #0
 800d57c:	d000      	beq.n	800d580 <mtx4_execute+0x240>
 800d57e:	e056      	b.n	800d62e <mtx4_execute+0x2ee>
  chSysLock();
 800d580:	f7ff fdce 	bl	800d120 <chSysLock>
  chMtxUnlockS(&m1);
 800d584:	481c      	ldr	r0, [pc, #112]	; (800d5f8 <mtx4_execute+0x2b8>)
 800d586:	f7f4 fdc3 	bl	8002110 <chMtxUnlockS>
  chSchRescheduleS();
 800d58a:	f7f3 fbf9 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 800d58e:	f7ff fdcf 	bl	800d130 <chSysUnlock>
  test_assert(12, chThdGetPriorityX() == p1, "wrong priority level");
 800d592:	f7ff fddd 	bl	800d150 <chThdGetPriorityX>
 800d596:	4602      	mov	r2, r0
 800d598:	9b04      	ldr	r3, [sp, #16]
 800d59a:	429a      	cmp	r2, r3
 800d59c:	bf14      	ite	ne
 800d59e:	2300      	movne	r3, #0
 800d5a0:	2301      	moveq	r3, #1
 800d5a2:	b2db      	uxtb	r3, r3
 800d5a4:	200c      	movs	r0, #12
 800d5a6:	4619      	mov	r1, r3
 800d5a8:	f7fe fc9a 	bl	800bee0 <_test_assert>
 800d5ac:	4603      	mov	r3, r0
 800d5ae:	2b00      	cmp	r3, #0
 800d5b0:	d000      	beq.n	800d5b4 <mtx4_execute+0x274>
 800d5b2:	e03c      	b.n	800d62e <mtx4_execute+0x2ee>
  chThdSleepMilliseconds(100);
 800d5b4:	2064      	movs	r0, #100	; 0x64
 800d5b6:	f7f3 fe8b 	bl	80012d0 <chThdSleep>
  test_assert(13, chThdGetPriorityX() == p1, "wrong priority level");
 800d5ba:	f7ff fdc9 	bl	800d150 <chThdGetPriorityX>
 800d5be:	4602      	mov	r2, r0
 800d5c0:	9b04      	ldr	r3, [sp, #16]
 800d5c2:	429a      	cmp	r2, r3
 800d5c4:	bf14      	ite	ne
 800d5c6:	2300      	movne	r3, #0
 800d5c8:	2301      	moveq	r3, #1
 800d5ca:	b2db      	uxtb	r3, r3
 800d5cc:	200d      	movs	r0, #13
 800d5ce:	4619      	mov	r1, r3
 800d5d0:	f7fe fc86 	bl	800bee0 <_test_assert>
 800d5d4:	4603      	mov	r3, r0
 800d5d6:	2b00      	cmp	r3, #0
 800d5d8:	d014      	beq.n	800d604 <mtx4_execute+0x2c4>
 800d5da:	e028      	b.n	800d62e <mtx4_execute+0x2ee>
 800d5dc:	08017b20 	.word	0x08017b20
 800d5e0:	08017efc 	.word	0x08017efc
 800d5e4:	0800d2e1 	.word	0x0800d2e1
 800d5e8:	20001ba4 	.word	0x20001ba4
 800d5ec:	08017f00 	.word	0x08017f00
 800d5f0:	0800d311 	.word	0x0800d311
 800d5f4:	20000854 	.word	0x20000854
 800d5f8:	20000844 	.word	0x20000844
 800d5fc:	08017ef4 	.word	0x08017ef4
 800d600:	08017ef8 	.word	0x08017ef8
  chMtxUnlockAll();
 800d604:	f7f4 fdd4 	bl	80021b0 <chMtxUnlockAll>
  test_assert(14, chThdGetPriorityX() == p, "wrong priority level");
 800d608:	f7ff fda2 	bl	800d150 <chThdGetPriorityX>
 800d60c:	4602      	mov	r2, r0
 800d60e:	9b05      	ldr	r3, [sp, #20]
 800d610:	429a      	cmp	r2, r3
 800d612:	bf14      	ite	ne
 800d614:	2300      	movne	r3, #0
 800d616:	2301      	moveq	r3, #1
 800d618:	b2db      	uxtb	r3, r3
 800d61a:	200e      	movs	r0, #14
 800d61c:	4619      	mov	r1, r3
 800d61e:	f7fe fc5f 	bl	800bee0 <_test_assert>
 800d622:	4603      	mov	r3, r0
 800d624:	2b00      	cmp	r3, #0
 800d626:	d000      	beq.n	800d62a <mtx4_execute+0x2ea>
 800d628:	e001      	b.n	800d62e <mtx4_execute+0x2ee>
  test_wait_threads();
 800d62a:	f7fe fcd9 	bl	800bfe0 <test_wait_threads>
}
 800d62e:	b007      	add	sp, #28
 800d630:	f85d fb04 	ldr.w	pc, [sp], #4
 800d634:	f3af 8000 	nop.w
 800d638:	f3af 8000 	nop.w
 800d63c:	f3af 8000 	nop.w

0800d640 <mtx5_setup>:
 * unlock operations.<br>
 * The test expects that the internal mutex status is consistent after each
 * operation.
 */

static void mtx5_setup(void) {
 800d640:	b508      	push	{r3, lr}

  chMtxObjectInit(&m1);
 800d642:	4802      	ldr	r0, [pc, #8]	; (800d64c <mtx5_setup+0xc>)
 800d644:	f7f4 fc54 	bl	8001ef0 <chMtxObjectInit>
}
 800d648:	bd08      	pop	{r3, pc}
 800d64a:	bf00      	nop
 800d64c:	20000844 	.word	0x20000844

0800d650 <mtx5_execute>:

static void mtx5_execute(void) {
 800d650:	b500      	push	{lr}
 800d652:	b083      	sub	sp, #12

#if !CH_CFG_USE_MUTEXES_RECURSIVE
  bool b;
  tprio_t prio = chThdGetPriorityX();
 800d654:	f7ff fd7c 	bl	800d150 <chThdGetPriorityX>
 800d658:	9001      	str	r0, [sp, #4]

  b = chMtxTryLock(&m1);
 800d65a:	4840      	ldr	r0, [pc, #256]	; (800d75c <mtx5_execute+0x10c>)
 800d65c:	f7f4 fcc8 	bl	8001ff0 <chMtxTryLock>
 800d660:	4603      	mov	r3, r0
 800d662:	f88d 3003 	strb.w	r3, [sp, #3]
  test_assert(1, b, "already locked");
 800d666:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d66a:	2001      	movs	r0, #1
 800d66c:	4619      	mov	r1, r3
 800d66e:	f7fe fc37 	bl	800bee0 <_test_assert>
 800d672:	4603      	mov	r3, r0
 800d674:	2b00      	cmp	r3, #0
 800d676:	d000      	beq.n	800d67a <mtx5_execute+0x2a>
 800d678:	e06d      	b.n	800d756 <mtx5_execute+0x106>

  b = chMtxTryLock(&m1);
 800d67a:	4838      	ldr	r0, [pc, #224]	; (800d75c <mtx5_execute+0x10c>)
 800d67c:	f7f4 fcb8 	bl	8001ff0 <chMtxTryLock>
 800d680:	4603      	mov	r3, r0
 800d682:	f88d 3003 	strb.w	r3, [sp, #3]
  test_assert(2, !b, "not locked");
 800d686:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d68a:	2b00      	cmp	r3, #0
 800d68c:	bf0c      	ite	eq
 800d68e:	2300      	moveq	r3, #0
 800d690:	2301      	movne	r3, #1
 800d692:	b2db      	uxtb	r3, r3
 800d694:	f083 0301 	eor.w	r3, r3, #1
 800d698:	b2db      	uxtb	r3, r3
 800d69a:	f003 0301 	and.w	r3, r3, #1
 800d69e:	b2db      	uxtb	r3, r3
 800d6a0:	2002      	movs	r0, #2
 800d6a2:	4619      	mov	r1, r3
 800d6a4:	f7fe fc1c 	bl	800bee0 <_test_assert>
 800d6a8:	4603      	mov	r3, r0
 800d6aa:	2b00      	cmp	r3, #0
 800d6ac:	d000      	beq.n	800d6b0 <mtx5_execute+0x60>
 800d6ae:	e052      	b.n	800d756 <mtx5_execute+0x106>

  chSysLock();
 800d6b0:	f7ff fd36 	bl	800d120 <chSysLock>
  chMtxUnlockS(&m1);
 800d6b4:	4829      	ldr	r0, [pc, #164]	; (800d75c <mtx5_execute+0x10c>)
 800d6b6:	f7f4 fd2b 	bl	8002110 <chMtxUnlockS>
  chSysUnlock();
 800d6ba:	f7ff fd39 	bl	800d130 <chSysUnlock>

  test_assert(3, queue_isempty(&m1.m_queue), "queue not empty");
 800d6be:	4827      	ldr	r0, [pc, #156]	; (800d75c <mtx5_execute+0x10c>)
 800d6c0:	f7ff fd1e 	bl	800d100 <queue_isempty>
 800d6c4:	4603      	mov	r3, r0
 800d6c6:	2003      	movs	r0, #3
 800d6c8:	4619      	mov	r1, r3
 800d6ca:	f7fe fc09 	bl	800bee0 <_test_assert>
 800d6ce:	4603      	mov	r3, r0
 800d6d0:	2b00      	cmp	r3, #0
 800d6d2:	d000      	beq.n	800d6d6 <mtx5_execute+0x86>
 800d6d4:	e03f      	b.n	800d756 <mtx5_execute+0x106>
  test_assert(4, m1.m_owner == NULL, "still owned");
 800d6d6:	4b21      	ldr	r3, [pc, #132]	; (800d75c <mtx5_execute+0x10c>)
 800d6d8:	689b      	ldr	r3, [r3, #8]
 800d6da:	2b00      	cmp	r3, #0
 800d6dc:	bf14      	ite	ne
 800d6de:	2300      	movne	r3, #0
 800d6e0:	2301      	moveq	r3, #1
 800d6e2:	b2db      	uxtb	r3, r3
 800d6e4:	2004      	movs	r0, #4
 800d6e6:	4619      	mov	r1, r3
 800d6e8:	f7fe fbfa 	bl	800bee0 <_test_assert>
 800d6ec:	4603      	mov	r3, r0
 800d6ee:	2b00      	cmp	r3, #0
 800d6f0:	d000      	beq.n	800d6f4 <mtx5_execute+0xa4>
 800d6f2:	e030      	b.n	800d756 <mtx5_execute+0x106>
  test_assert(5, chThdGetPriorityX() == prio, "wrong priority level");
 800d6f4:	f7ff fd2c 	bl	800d150 <chThdGetPriorityX>
 800d6f8:	4602      	mov	r2, r0
 800d6fa:	9b01      	ldr	r3, [sp, #4]
 800d6fc:	429a      	cmp	r2, r3
 800d6fe:	bf14      	ite	ne
 800d700:	2300      	movne	r3, #0
 800d702:	2301      	moveq	r3, #1
 800d704:	b2db      	uxtb	r3, r3
 800d706:	2005      	movs	r0, #5
 800d708:	4619      	mov	r1, r3
 800d70a:	f7fe fbe9 	bl	800bee0 <_test_assert>
 800d70e:	4603      	mov	r3, r0
 800d710:	2b00      	cmp	r3, #0
 800d712:	d000      	beq.n	800d716 <mtx5_execute+0xc6>
 800d714:	e01f      	b.n	800d756 <mtx5_execute+0x106>
#endif /* !CH_CFG_USE_MUTEXES_RECURSIVE */
  
  chMtxLock(&m1);
 800d716:	4811      	ldr	r0, [pc, #68]	; (800d75c <mtx5_execute+0x10c>)
 800d718:	f7f4 fbfa 	bl	8001f10 <chMtxLock>
  chMtxUnlockAll();
 800d71c:	f7f4 fd48 	bl	80021b0 <chMtxUnlockAll>
  test_assert(6, queue_isempty(&m1.m_queue), "queue not empty");
 800d720:	480e      	ldr	r0, [pc, #56]	; (800d75c <mtx5_execute+0x10c>)
 800d722:	f7ff fced 	bl	800d100 <queue_isempty>
 800d726:	4603      	mov	r3, r0
 800d728:	2006      	movs	r0, #6
 800d72a:	4619      	mov	r1, r3
 800d72c:	f7fe fbd8 	bl	800bee0 <_test_assert>
 800d730:	4603      	mov	r3, r0
 800d732:	2b00      	cmp	r3, #0
 800d734:	d000      	beq.n	800d738 <mtx5_execute+0xe8>
 800d736:	e00e      	b.n	800d756 <mtx5_execute+0x106>
  test_assert(7, m1.m_owner == NULL, "still owned");
 800d738:	4b08      	ldr	r3, [pc, #32]	; (800d75c <mtx5_execute+0x10c>)
 800d73a:	689b      	ldr	r3, [r3, #8]
 800d73c:	2b00      	cmp	r3, #0
 800d73e:	bf14      	ite	ne
 800d740:	2300      	movne	r3, #0
 800d742:	2301      	moveq	r3, #1
 800d744:	b2db      	uxtb	r3, r3
 800d746:	2007      	movs	r0, #7
 800d748:	4619      	mov	r1, r3
 800d74a:	f7fe fbc9 	bl	800bee0 <_test_assert>
 800d74e:	4603      	mov	r3, r0
 800d750:	2b00      	cmp	r3, #0
 800d752:	d000      	beq.n	800d756 <mtx5_execute+0x106>
 800d754:	bf00      	nop
}
 800d756:	b003      	add	sp, #12
 800d758:	f85d fb04 	ldr.w	pc, [sp], #4
 800d75c:	20000844 	.word	0x20000844

0800d760 <mtx6_setup>:
 * atomically.<br>
 * The test expects the threads to reach their goal in increasing priority
 * order regardless of the initial order.
 */

static void mtx6_setup(void) {
 800d760:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 800d762:	4803      	ldr	r0, [pc, #12]	; (800d770 <mtx6_setup+0x10>)
 800d764:	f7f4 fdf4 	bl	8002350 <chCondObjectInit>
  chMtxObjectInit(&m1);
 800d768:	4802      	ldr	r0, [pc, #8]	; (800d774 <mtx6_setup+0x14>)
 800d76a:	f7f4 fbc1 	bl	8001ef0 <chMtxObjectInit>
}
 800d76e:	bd08      	pop	{r3, pc}
 800d770:	20000864 	.word	0x20000864
 800d774:	20000844 	.word	0x20000844
 800d778:	f3af 8000 	nop.w
 800d77c:	f3af 8000 	nop.w

0800d780 <thread10>:

static THD_FUNCTION(thread10, p) {
 800d780:	b500      	push	{lr}
 800d782:	b083      	sub	sp, #12
 800d784:	9001      	str	r0, [sp, #4]

  chMtxLock(&m1);
 800d786:	4808      	ldr	r0, [pc, #32]	; (800d7a8 <thread10+0x28>)
 800d788:	f7f4 fbc2 	bl	8001f10 <chMtxLock>
  chCondWait(&c1);
 800d78c:	4807      	ldr	r0, [pc, #28]	; (800d7ac <thread10+0x2c>)
 800d78e:	f7f4 fe57 	bl	8002440 <chCondWait>
  test_emit_token(*(char *)p);
 800d792:	9b01      	ldr	r3, [sp, #4]
 800d794:	781b      	ldrb	r3, [r3, #0]
 800d796:	4618      	mov	r0, r3
 800d798:	f7fe fb72 	bl	800be80 <test_emit_token>
  chMtxUnlock(&m1);
 800d79c:	4802      	ldr	r0, [pc, #8]	; (800d7a8 <thread10+0x28>)
 800d79e:	f7f4 fc5f 	bl	8002060 <chMtxUnlock>
}
 800d7a2:	b003      	add	sp, #12
 800d7a4:	f85d fb04 	ldr.w	pc, [sp], #4
 800d7a8:	20000844 	.word	0x20000844
 800d7ac:	20000864 	.word	0x20000864

0800d7b0 <mtx6_execute>:

static void mtx6_execute(void) {
 800d7b0:	b500      	push	{lr}
 800d7b2:	b085      	sub	sp, #20

  tprio_t prio = chThdGetPriorityX();
 800d7b4:	f7ff fccc 	bl	800d150 <chThdGetPriorityX>
 800d7b8:	9003      	str	r0, [sp, #12]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 800d7ba:	4b39      	ldr	r3, [pc, #228]	; (800d8a0 <mtx6_execute+0xf0>)
 800d7bc:	681a      	ldr	r2, [r3, #0]
 800d7be:	9b03      	ldr	r3, [sp, #12]
 800d7c0:	3301      	adds	r3, #1
 800d7c2:	4938      	ldr	r1, [pc, #224]	; (800d8a4 <mtx6_execute+0xf4>)
 800d7c4:	9100      	str	r1, [sp, #0]
 800d7c6:	4610      	mov	r0, r2
 800d7c8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d7cc:	461a      	mov	r2, r3
 800d7ce:	4b36      	ldr	r3, [pc, #216]	; (800d8a8 <mtx6_execute+0xf8>)
 800d7d0:	f7f3 fd06 	bl	80011e0 <chThdCreateStatic>
 800d7d4:	4602      	mov	r2, r0
 800d7d6:	4b35      	ldr	r3, [pc, #212]	; (800d8ac <mtx6_execute+0xfc>)
 800d7d8:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 800d7da:	4b31      	ldr	r3, [pc, #196]	; (800d8a0 <mtx6_execute+0xf0>)
 800d7dc:	685a      	ldr	r2, [r3, #4]
 800d7de:	9b03      	ldr	r3, [sp, #12]
 800d7e0:	3302      	adds	r3, #2
 800d7e2:	4933      	ldr	r1, [pc, #204]	; (800d8b0 <mtx6_execute+0x100>)
 800d7e4:	9100      	str	r1, [sp, #0]
 800d7e6:	4610      	mov	r0, r2
 800d7e8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d7ec:	461a      	mov	r2, r3
 800d7ee:	4b2e      	ldr	r3, [pc, #184]	; (800d8a8 <mtx6_execute+0xf8>)
 800d7f0:	f7f3 fcf6 	bl	80011e0 <chThdCreateStatic>
 800d7f4:	4602      	mov	r2, r0
 800d7f6:	4b2d      	ldr	r3, [pc, #180]	; (800d8ac <mtx6_execute+0xfc>)
 800d7f8:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 800d7fa:	4b29      	ldr	r3, [pc, #164]	; (800d8a0 <mtx6_execute+0xf0>)
 800d7fc:	689a      	ldr	r2, [r3, #8]
 800d7fe:	9b03      	ldr	r3, [sp, #12]
 800d800:	3303      	adds	r3, #3
 800d802:	492c      	ldr	r1, [pc, #176]	; (800d8b4 <mtx6_execute+0x104>)
 800d804:	9100      	str	r1, [sp, #0]
 800d806:	4610      	mov	r0, r2
 800d808:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d80c:	461a      	mov	r2, r3
 800d80e:	4b26      	ldr	r3, [pc, #152]	; (800d8a8 <mtx6_execute+0xf8>)
 800d810:	f7f3 fce6 	bl	80011e0 <chThdCreateStatic>
 800d814:	4602      	mov	r2, r0
 800d816:	4b25      	ldr	r3, [pc, #148]	; (800d8ac <mtx6_execute+0xfc>)
 800d818:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 800d81a:	4b21      	ldr	r3, [pc, #132]	; (800d8a0 <mtx6_execute+0xf0>)
 800d81c:	68da      	ldr	r2, [r3, #12]
 800d81e:	9b03      	ldr	r3, [sp, #12]
 800d820:	3304      	adds	r3, #4
 800d822:	4925      	ldr	r1, [pc, #148]	; (800d8b8 <mtx6_execute+0x108>)
 800d824:	9100      	str	r1, [sp, #0]
 800d826:	4610      	mov	r0, r2
 800d828:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d82c:	461a      	mov	r2, r3
 800d82e:	4b1e      	ldr	r3, [pc, #120]	; (800d8a8 <mtx6_execute+0xf8>)
 800d830:	f7f3 fcd6 	bl	80011e0 <chThdCreateStatic>
 800d834:	4602      	mov	r2, r0
 800d836:	4b1d      	ldr	r3, [pc, #116]	; (800d8ac <mtx6_execute+0xfc>)
 800d838:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 800d83a:	4b19      	ldr	r3, [pc, #100]	; (800d8a0 <mtx6_execute+0xf0>)
 800d83c:	691a      	ldr	r2, [r3, #16]
 800d83e:	9b03      	ldr	r3, [sp, #12]
 800d840:	3305      	adds	r3, #5
 800d842:	491e      	ldr	r1, [pc, #120]	; (800d8bc <mtx6_execute+0x10c>)
 800d844:	9100      	str	r1, [sp, #0]
 800d846:	4610      	mov	r0, r2
 800d848:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d84c:	461a      	mov	r2, r3
 800d84e:	4b16      	ldr	r3, [pc, #88]	; (800d8a8 <mtx6_execute+0xf8>)
 800d850:	f7f3 fcc6 	bl	80011e0 <chThdCreateStatic>
 800d854:	4602      	mov	r2, r0
 800d856:	4b15      	ldr	r3, [pc, #84]	; (800d8ac <mtx6_execute+0xfc>)
 800d858:	611a      	str	r2, [r3, #16]
  chSysLock();
 800d85a:	f7ff fc61 	bl	800d120 <chSysLock>
  chCondSignalI(&c1);
 800d85e:	4818      	ldr	r0, [pc, #96]	; (800d8c0 <mtx6_execute+0x110>)
 800d860:	f7f4 fda6 	bl	80023b0 <chCondSignalI>
  chCondSignalI(&c1);
 800d864:	4816      	ldr	r0, [pc, #88]	; (800d8c0 <mtx6_execute+0x110>)
 800d866:	f7f4 fda3 	bl	80023b0 <chCondSignalI>
  chCondSignalI(&c1);
 800d86a:	4815      	ldr	r0, [pc, #84]	; (800d8c0 <mtx6_execute+0x110>)
 800d86c:	f7f4 fda0 	bl	80023b0 <chCondSignalI>
  chCondSignalI(&c1);
 800d870:	4813      	ldr	r0, [pc, #76]	; (800d8c0 <mtx6_execute+0x110>)
 800d872:	f7f4 fd9d 	bl	80023b0 <chCondSignalI>
  chCondSignalI(&c1);
 800d876:	4812      	ldr	r0, [pc, #72]	; (800d8c0 <mtx6_execute+0x110>)
 800d878:	f7f4 fd9a 	bl	80023b0 <chCondSignalI>
  chSchRescheduleS();
 800d87c:	f7f3 fa80 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 800d880:	f7ff fc56 	bl	800d130 <chSysUnlock>
  test_wait_threads();
 800d884:	f7fe fbac 	bl	800bfe0 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 800d888:	2001      	movs	r0, #1
 800d88a:	490e      	ldr	r1, [pc, #56]	; (800d8c4 <mtx6_execute+0x114>)
 800d88c:	f7fe fb40 	bl	800bf10 <_test_assert_sequence>
 800d890:	4603      	mov	r3, r0
 800d892:	2b00      	cmp	r3, #0
 800d894:	d000      	beq.n	800d898 <mtx6_execute+0xe8>
 800d896:	bf00      	nop
}
 800d898:	b005      	add	sp, #20
 800d89a:	f85d fb04 	ldr.w	pc, [sp], #4
 800d89e:	bf00      	nop
 800d8a0:	08017b20 	.word	0x08017b20
 800d8a4:	08017ef0 	.word	0x08017ef0
 800d8a8:	0800d781 	.word	0x0800d781
 800d8ac:	20001ba4 	.word	0x20001ba4
 800d8b0:	08017ef4 	.word	0x08017ef4
 800d8b4:	08017ef8 	.word	0x08017ef8
 800d8b8:	08017efc 	.word	0x08017efc
 800d8bc:	08017f00 	.word	0x08017f00
 800d8c0:	20000864 	.word	0x20000864
 800d8c4:	08017f04 	.word	0x08017f04
 800d8c8:	f3af 8000 	nop.w
 800d8cc:	f3af 8000 	nop.w

0800d8d0 <mtx7_setup>:
 * tester thread then proceeds to broadcast the conditional variable.<br>
 * The test expects the threads to reach their goal in increasing priority
 * order regardless of the initial order.
 */

static void mtx7_setup(void) {
 800d8d0:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 800d8d2:	4803      	ldr	r0, [pc, #12]	; (800d8e0 <mtx7_setup+0x10>)
 800d8d4:	f7f4 fd3c 	bl	8002350 <chCondObjectInit>
  chMtxObjectInit(&m1);
 800d8d8:	4802      	ldr	r0, [pc, #8]	; (800d8e4 <mtx7_setup+0x14>)
 800d8da:	f7f4 fb09 	bl	8001ef0 <chMtxObjectInit>
}
 800d8de:	bd08      	pop	{r3, pc}
 800d8e0:	20000864 	.word	0x20000864
 800d8e4:	20000844 	.word	0x20000844
 800d8e8:	f3af 8000 	nop.w
 800d8ec:	f3af 8000 	nop.w

0800d8f0 <mtx7_execute>:

static void mtx7_execute(void) {
 800d8f0:	b500      	push	{lr}
 800d8f2:	b085      	sub	sp, #20

  tprio_t prio = chThdGetPriorityX();
 800d8f4:	f7ff fc2c 	bl	800d150 <chThdGetPriorityX>
 800d8f8:	9003      	str	r0, [sp, #12]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 800d8fa:	4b30      	ldr	r3, [pc, #192]	; (800d9bc <mtx7_execute+0xcc>)
 800d8fc:	681a      	ldr	r2, [r3, #0]
 800d8fe:	9b03      	ldr	r3, [sp, #12]
 800d900:	3301      	adds	r3, #1
 800d902:	492f      	ldr	r1, [pc, #188]	; (800d9c0 <mtx7_execute+0xd0>)
 800d904:	9100      	str	r1, [sp, #0]
 800d906:	4610      	mov	r0, r2
 800d908:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d90c:	461a      	mov	r2, r3
 800d90e:	4b2d      	ldr	r3, [pc, #180]	; (800d9c4 <mtx7_execute+0xd4>)
 800d910:	f7f3 fc66 	bl	80011e0 <chThdCreateStatic>
 800d914:	4602      	mov	r2, r0
 800d916:	4b2c      	ldr	r3, [pc, #176]	; (800d9c8 <mtx7_execute+0xd8>)
 800d918:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 800d91a:	4b28      	ldr	r3, [pc, #160]	; (800d9bc <mtx7_execute+0xcc>)
 800d91c:	685a      	ldr	r2, [r3, #4]
 800d91e:	9b03      	ldr	r3, [sp, #12]
 800d920:	3302      	adds	r3, #2
 800d922:	492a      	ldr	r1, [pc, #168]	; (800d9cc <mtx7_execute+0xdc>)
 800d924:	9100      	str	r1, [sp, #0]
 800d926:	4610      	mov	r0, r2
 800d928:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d92c:	461a      	mov	r2, r3
 800d92e:	4b25      	ldr	r3, [pc, #148]	; (800d9c4 <mtx7_execute+0xd4>)
 800d930:	f7f3 fc56 	bl	80011e0 <chThdCreateStatic>
 800d934:	4602      	mov	r2, r0
 800d936:	4b24      	ldr	r3, [pc, #144]	; (800d9c8 <mtx7_execute+0xd8>)
 800d938:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 800d93a:	4b20      	ldr	r3, [pc, #128]	; (800d9bc <mtx7_execute+0xcc>)
 800d93c:	689a      	ldr	r2, [r3, #8]
 800d93e:	9b03      	ldr	r3, [sp, #12]
 800d940:	3303      	adds	r3, #3
 800d942:	4923      	ldr	r1, [pc, #140]	; (800d9d0 <mtx7_execute+0xe0>)
 800d944:	9100      	str	r1, [sp, #0]
 800d946:	4610      	mov	r0, r2
 800d948:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d94c:	461a      	mov	r2, r3
 800d94e:	4b1d      	ldr	r3, [pc, #116]	; (800d9c4 <mtx7_execute+0xd4>)
 800d950:	f7f3 fc46 	bl	80011e0 <chThdCreateStatic>
 800d954:	4602      	mov	r2, r0
 800d956:	4b1c      	ldr	r3, [pc, #112]	; (800d9c8 <mtx7_execute+0xd8>)
 800d958:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 800d95a:	4b18      	ldr	r3, [pc, #96]	; (800d9bc <mtx7_execute+0xcc>)
 800d95c:	68da      	ldr	r2, [r3, #12]
 800d95e:	9b03      	ldr	r3, [sp, #12]
 800d960:	3304      	adds	r3, #4
 800d962:	491c      	ldr	r1, [pc, #112]	; (800d9d4 <mtx7_execute+0xe4>)
 800d964:	9100      	str	r1, [sp, #0]
 800d966:	4610      	mov	r0, r2
 800d968:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d96c:	461a      	mov	r2, r3
 800d96e:	4b15      	ldr	r3, [pc, #84]	; (800d9c4 <mtx7_execute+0xd4>)
 800d970:	f7f3 fc36 	bl	80011e0 <chThdCreateStatic>
 800d974:	4602      	mov	r2, r0
 800d976:	4b14      	ldr	r3, [pc, #80]	; (800d9c8 <mtx7_execute+0xd8>)
 800d978:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 800d97a:	4b10      	ldr	r3, [pc, #64]	; (800d9bc <mtx7_execute+0xcc>)
 800d97c:	691a      	ldr	r2, [r3, #16]
 800d97e:	9b03      	ldr	r3, [sp, #12]
 800d980:	3305      	adds	r3, #5
 800d982:	4915      	ldr	r1, [pc, #84]	; (800d9d8 <mtx7_execute+0xe8>)
 800d984:	9100      	str	r1, [sp, #0]
 800d986:	4610      	mov	r0, r2
 800d988:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d98c:	461a      	mov	r2, r3
 800d98e:	4b0d      	ldr	r3, [pc, #52]	; (800d9c4 <mtx7_execute+0xd4>)
 800d990:	f7f3 fc26 	bl	80011e0 <chThdCreateStatic>
 800d994:	4602      	mov	r2, r0
 800d996:	4b0c      	ldr	r3, [pc, #48]	; (800d9c8 <mtx7_execute+0xd8>)
 800d998:	611a      	str	r2, [r3, #16]
  chCondBroadcast(&c1);
 800d99a:	4810      	ldr	r0, [pc, #64]	; (800d9dc <mtx7_execute+0xec>)
 800d99c:	f7f4 fd20 	bl	80023e0 <chCondBroadcast>
  test_wait_threads();
 800d9a0:	f7fe fb1e 	bl	800bfe0 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 800d9a4:	2001      	movs	r0, #1
 800d9a6:	490e      	ldr	r1, [pc, #56]	; (800d9e0 <mtx7_execute+0xf0>)
 800d9a8:	f7fe fab2 	bl	800bf10 <_test_assert_sequence>
 800d9ac:	4603      	mov	r3, r0
 800d9ae:	2b00      	cmp	r3, #0
 800d9b0:	d000      	beq.n	800d9b4 <mtx7_execute+0xc4>
 800d9b2:	bf00      	nop
}
 800d9b4:	b005      	add	sp, #20
 800d9b6:	f85d fb04 	ldr.w	pc, [sp], #4
 800d9ba:	bf00      	nop
 800d9bc:	08017b20 	.word	0x08017b20
 800d9c0:	08017ef0 	.word	0x08017ef0
 800d9c4:	0800d781 	.word	0x0800d781
 800d9c8:	20001ba4 	.word	0x20001ba4
 800d9cc:	08017ef4 	.word	0x08017ef4
 800d9d0:	08017ef8 	.word	0x08017ef8
 800d9d4:	08017efc 	.word	0x08017efc
 800d9d8:	08017f00 	.word	0x08017f00
 800d9dc:	20000864 	.word	0x20000864
 800d9e0:	08017f04 	.word	0x08017f04
 800d9e4:	f3af 8000 	nop.w
 800d9e8:	f3af 8000 	nop.w
 800d9ec:	f3af 8000 	nop.w

0800d9f0 <mtx8_setup>:
 * This test case verifies the priority boost of a thread waiting on a
 * conditional variable queue. It tests this very specific situation in order
 * to complete the code coverage.
 */

static void mtx8_setup(void) {
 800d9f0:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 800d9f2:	4805      	ldr	r0, [pc, #20]	; (800da08 <mtx8_setup+0x18>)
 800d9f4:	f7f4 fcac 	bl	8002350 <chCondObjectInit>
  chMtxObjectInit(&m1);
 800d9f8:	4804      	ldr	r0, [pc, #16]	; (800da0c <mtx8_setup+0x1c>)
 800d9fa:	f7f4 fa79 	bl	8001ef0 <chMtxObjectInit>
  chMtxObjectInit(&m2);
 800d9fe:	4804      	ldr	r0, [pc, #16]	; (800da10 <mtx8_setup+0x20>)
 800da00:	f7f4 fa76 	bl	8001ef0 <chMtxObjectInit>
}
 800da04:	bd08      	pop	{r3, pc}
 800da06:	bf00      	nop
 800da08:	20000864 	.word	0x20000864
 800da0c:	20000844 	.word	0x20000844
 800da10:	20000854 	.word	0x20000854
 800da14:	f3af 8000 	nop.w
 800da18:	f3af 8000 	nop.w
 800da1c:	f3af 8000 	nop.w

0800da20 <thread11>:

static THD_FUNCTION(thread11, p) {
 800da20:	b500      	push	{lr}
 800da22:	b083      	sub	sp, #12
 800da24:	9001      	str	r0, [sp, #4]

  chMtxLock(&m2);
 800da26:	480c      	ldr	r0, [pc, #48]	; (800da58 <thread11+0x38>)
 800da28:	f7f4 fa72 	bl	8001f10 <chMtxLock>
  chMtxLock(&m1);
 800da2c:	480b      	ldr	r0, [pc, #44]	; (800da5c <thread11+0x3c>)
 800da2e:	f7f4 fa6f 	bl	8001f10 <chMtxLock>
#if CH_CFG_USE_CONDVARS_TIMEOUT || defined(__DOXYGEN__)
  chCondWaitTimeout(&c1, TIME_INFINITE);
 800da32:	480b      	ldr	r0, [pc, #44]	; (800da60 <thread11+0x40>)
 800da34:	f04f 31ff 	mov.w	r1, #4294967295
 800da38:	f7f4 fd3a 	bl	80024b0 <chCondWaitTimeout>
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
 800da3c:	9b01      	ldr	r3, [sp, #4]
 800da3e:	781b      	ldrb	r3, [r3, #0]
 800da40:	4618      	mov	r0, r3
 800da42:	f7fe fa1d 	bl	800be80 <test_emit_token>
  chMtxUnlock(&m1);
 800da46:	4805      	ldr	r0, [pc, #20]	; (800da5c <thread11+0x3c>)
 800da48:	f7f4 fb0a 	bl	8002060 <chMtxUnlock>
  chMtxUnlock(&m2);
 800da4c:	4802      	ldr	r0, [pc, #8]	; (800da58 <thread11+0x38>)
 800da4e:	f7f4 fb07 	bl	8002060 <chMtxUnlock>
}
 800da52:	b003      	add	sp, #12
 800da54:	f85d fb04 	ldr.w	pc, [sp], #4
 800da58:	20000854 	.word	0x20000854
 800da5c:	20000844 	.word	0x20000844
 800da60:	20000864 	.word	0x20000864
 800da64:	f3af 8000 	nop.w
 800da68:	f3af 8000 	nop.w
 800da6c:	f3af 8000 	nop.w

0800da70 <thread12>:

static THD_FUNCTION(thread12, p) {
 800da70:	b500      	push	{lr}
 800da72:	b083      	sub	sp, #12
 800da74:	9001      	str	r0, [sp, #4]

  chMtxLock(&m2);
 800da76:	4807      	ldr	r0, [pc, #28]	; (800da94 <thread12+0x24>)
 800da78:	f7f4 fa4a 	bl	8001f10 <chMtxLock>
  test_emit_token(*(char *)p);
 800da7c:	9b01      	ldr	r3, [sp, #4]
 800da7e:	781b      	ldrb	r3, [r3, #0]
 800da80:	4618      	mov	r0, r3
 800da82:	f7fe f9fd 	bl	800be80 <test_emit_token>
  chMtxUnlock(&m2);
 800da86:	4803      	ldr	r0, [pc, #12]	; (800da94 <thread12+0x24>)
 800da88:	f7f4 faea 	bl	8002060 <chMtxUnlock>
}
 800da8c:	b003      	add	sp, #12
 800da8e:	f85d fb04 	ldr.w	pc, [sp], #4
 800da92:	bf00      	nop
 800da94:	20000854 	.word	0x20000854
 800da98:	f3af 8000 	nop.w
 800da9c:	f3af 8000 	nop.w

0800daa0 <mtx8_execute>:

static void mtx8_execute(void) {
 800daa0:	b500      	push	{lr}
 800daa2:	b085      	sub	sp, #20

  tprio_t prio = chThdGetPriorityX();
 800daa4:	f7ff fb54 	bl	800d150 <chThdGetPriorityX>
 800daa8:	9003      	str	r0, [sp, #12]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 800daaa:	4b21      	ldr	r3, [pc, #132]	; (800db30 <mtx8_execute+0x90>)
 800daac:	681a      	ldr	r2, [r3, #0]
 800daae:	9b03      	ldr	r3, [sp, #12]
 800dab0:	3301      	adds	r3, #1
 800dab2:	4920      	ldr	r1, [pc, #128]	; (800db34 <mtx8_execute+0x94>)
 800dab4:	9100      	str	r1, [sp, #0]
 800dab6:	4610      	mov	r0, r2
 800dab8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800dabc:	461a      	mov	r2, r3
 800dabe:	4b1e      	ldr	r3, [pc, #120]	; (800db38 <mtx8_execute+0x98>)
 800dac0:	f7f3 fb8e 	bl	80011e0 <chThdCreateStatic>
 800dac4:	4602      	mov	r2, r0
 800dac6:	4b1d      	ldr	r3, [pc, #116]	; (800db3c <mtx8_execute+0x9c>)
 800dac8:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 800daca:	4b19      	ldr	r3, [pc, #100]	; (800db30 <mtx8_execute+0x90>)
 800dacc:	685a      	ldr	r2, [r3, #4]
 800dace:	9b03      	ldr	r3, [sp, #12]
 800dad0:	3302      	adds	r3, #2
 800dad2:	491b      	ldr	r1, [pc, #108]	; (800db40 <mtx8_execute+0xa0>)
 800dad4:	9100      	str	r1, [sp, #0]
 800dad6:	4610      	mov	r0, r2
 800dad8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800dadc:	461a      	mov	r2, r3
 800dade:	4b19      	ldr	r3, [pc, #100]	; (800db44 <mtx8_execute+0xa4>)
 800dae0:	f7f3 fb7e 	bl	80011e0 <chThdCreateStatic>
 800dae4:	4602      	mov	r2, r0
 800dae6:	4b15      	ldr	r3, [pc, #84]	; (800db3c <mtx8_execute+0x9c>)
 800dae8:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
 800daea:	4b11      	ldr	r3, [pc, #68]	; (800db30 <mtx8_execute+0x90>)
 800daec:	689a      	ldr	r2, [r3, #8]
 800daee:	9b03      	ldr	r3, [sp, #12]
 800daf0:	3303      	adds	r3, #3
 800daf2:	4915      	ldr	r1, [pc, #84]	; (800db48 <mtx8_execute+0xa8>)
 800daf4:	9100      	str	r1, [sp, #0]
 800daf6:	4610      	mov	r0, r2
 800daf8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800dafc:	461a      	mov	r2, r3
 800dafe:	4b13      	ldr	r3, [pc, #76]	; (800db4c <mtx8_execute+0xac>)
 800db00:	f7f3 fb6e 	bl	80011e0 <chThdCreateStatic>
 800db04:	4602      	mov	r2, r0
 800db06:	4b0d      	ldr	r3, [pc, #52]	; (800db3c <mtx8_execute+0x9c>)
 800db08:	609a      	str	r2, [r3, #8]
  chCondSignal(&c1);
 800db0a:	4811      	ldr	r0, [pc, #68]	; (800db50 <mtx8_execute+0xb0>)
 800db0c:	f7f4 fc30 	bl	8002370 <chCondSignal>
  chCondSignal(&c1);
 800db10:	480f      	ldr	r0, [pc, #60]	; (800db50 <mtx8_execute+0xb0>)
 800db12:	f7f4 fc2d 	bl	8002370 <chCondSignal>
  test_wait_threads();
 800db16:	f7fe fa63 	bl	800bfe0 <test_wait_threads>
  test_assert_sequence(1, "ABC");
 800db1a:	2001      	movs	r0, #1
 800db1c:	490d      	ldr	r1, [pc, #52]	; (800db54 <mtx8_execute+0xb4>)
 800db1e:	f7fe f9f7 	bl	800bf10 <_test_assert_sequence>
 800db22:	4603      	mov	r3, r0
 800db24:	2b00      	cmp	r3, #0
 800db26:	d000      	beq.n	800db2a <mtx8_execute+0x8a>
 800db28:	bf00      	nop
}
 800db2a:	b005      	add	sp, #20
 800db2c:	f85d fb04 	ldr.w	pc, [sp], #4
 800db30:	08017b20 	.word	0x08017b20
 800db34:	08017f00 	.word	0x08017f00
 800db38:	0800da21 	.word	0x0800da21
 800db3c:	20001ba4 	.word	0x20001ba4
 800db40:	08017ef8 	.word	0x08017ef8
 800db44:	0800d781 	.word	0x0800d781
 800db48:	08017efc 	.word	0x08017efc
 800db4c:	0800da71 	.word	0x0800da71
 800db50:	20000864 	.word	0x20000864
 800db54:	08017fdc 	.word	0x08017fdc
 800db58:	f3af 8000 	nop.w
 800db5c:	f3af 8000 	nop.w

0800db60 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800db60:	4b01      	ldr	r3, [pc, #4]	; (800db68 <chThdGetSelfX+0x8>)
 800db62:	699b      	ldr	r3, [r3, #24]
}
 800db64:	4618      	mov	r0, r3
 800db66:	4770      	bx	lr
 800db68:	200016e0 	.word	0x200016e0
 800db6c:	f3af 8000 	nop.w

0800db70 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800db70:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800db72:	f7ff fff5 	bl	800db60 <chThdGetSelfX>
 800db76:	4603      	mov	r3, r0
 800db78:	689b      	ldr	r3, [r3, #8]
}
 800db7a:	4618      	mov	r0, r3
 800db7c:	bd08      	pop	{r3, pc}
 800db7e:	bf00      	nop

0800db80 <chMsgGet>:
 * @param[in] tp        pointer to the thread
 * @return              The message carried by the sender.
 *
 * @api
 */
static inline msg_t chMsgGet(thread_t *tp) {
 800db80:	b082      	sub	sp, #8
 800db82:	9001      	str	r0, [sp, #4]

  return tp->p_msg;
 800db84:	9b01      	ldr	r3, [sp, #4]
 800db86:	6b1b      	ldr	r3, [r3, #48]	; 0x30
}
 800db88:	4618      	mov	r0, r3
 800db8a:	b002      	add	sp, #8
 800db8c:	4770      	bx	lr
 800db8e:	bf00      	nop

0800db90 <thread>:
 * A thread is spawned that sends four messages back to the tester thread.<br>
 * The test expect to receive the messages in the correct sequence and to
 * not find a fifth message waiting.
 */

static THD_FUNCTION(thread, p) {
 800db90:	b500      	push	{lr}
 800db92:	b083      	sub	sp, #12
 800db94:	9001      	str	r0, [sp, #4]

  chMsgSend(p, 'A');
 800db96:	9801      	ldr	r0, [sp, #4]
 800db98:	2141      	movs	r1, #65	; 0x41
 800db9a:	f7f5 f801 	bl	8002ba0 <chMsgSend>
  chMsgSend(p, 'B');
 800db9e:	9801      	ldr	r0, [sp, #4]
 800dba0:	2142      	movs	r1, #66	; 0x42
 800dba2:	f7f4 fffd 	bl	8002ba0 <chMsgSend>
  chMsgSend(p, 'C');
 800dba6:	9801      	ldr	r0, [sp, #4]
 800dba8:	2143      	movs	r1, #67	; 0x43
 800dbaa:	f7f4 fff9 	bl	8002ba0 <chMsgSend>
}
 800dbae:	b003      	add	sp, #12
 800dbb0:	f85d fb04 	ldr.w	pc, [sp], #4
 800dbb4:	f3af 8000 	nop.w
 800dbb8:	f3af 8000 	nop.w
 800dbbc:	f3af 8000 	nop.w

0800dbc0 <msg1_execute>:

static void msg1_execute(void) {
 800dbc0:	b530      	push	{r4, r5, lr}
 800dbc2:	b085      	sub	sp, #20
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 800dbc4:	4b26      	ldr	r3, [pc, #152]	; (800dc60 <msg1_execute+0xa0>)
 800dbc6:	681d      	ldr	r5, [r3, #0]
 800dbc8:	f7ff ffd2 	bl	800db70 <chThdGetPriorityX>
 800dbcc:	4603      	mov	r3, r0
 800dbce:	1c5c      	adds	r4, r3, #1
                                 thread, chThdGetSelfX());
 800dbd0:	f7ff ffc6 	bl	800db60 <chThdGetSelfX>
 800dbd4:	4603      	mov	r3, r0
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 800dbd6:	9300      	str	r3, [sp, #0]
 800dbd8:	4628      	mov	r0, r5
 800dbda:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800dbde:	4622      	mov	r2, r4
 800dbe0:	4b20      	ldr	r3, [pc, #128]	; (800dc64 <msg1_execute+0xa4>)
 800dbe2:	f7f3 fafd 	bl	80011e0 <chThdCreateStatic>
 800dbe6:	4602      	mov	r2, r0
 800dbe8:	4b1f      	ldr	r3, [pc, #124]	; (800dc68 <msg1_execute+0xa8>)
 800dbea:	601a      	str	r2, [r3, #0]
                                 thread, chThdGetSelfX());
  tp = chMsgWait();
 800dbec:	f7f5 f808 	bl	8002c00 <chMsgWait>
 800dbf0:	9003      	str	r0, [sp, #12]
  msg = chMsgGet(tp);
 800dbf2:	9803      	ldr	r0, [sp, #12]
 800dbf4:	f7ff ffc4 	bl	800db80 <chMsgGet>
 800dbf8:	9002      	str	r0, [sp, #8]
  chMsgRelease(tp, msg);
 800dbfa:	9803      	ldr	r0, [sp, #12]
 800dbfc:	9902      	ldr	r1, [sp, #8]
 800dbfe:	f7f5 f827 	bl	8002c50 <chMsgRelease>
  test_emit_token(msg);
 800dc02:	9b02      	ldr	r3, [sp, #8]
 800dc04:	b2db      	uxtb	r3, r3
 800dc06:	4618      	mov	r0, r3
 800dc08:	f7fe f93a 	bl	800be80 <test_emit_token>
  tp = chMsgWait();
 800dc0c:	f7f4 fff8 	bl	8002c00 <chMsgWait>
 800dc10:	9003      	str	r0, [sp, #12]
  msg = chMsgGet(tp);
 800dc12:	9803      	ldr	r0, [sp, #12]
 800dc14:	f7ff ffb4 	bl	800db80 <chMsgGet>
 800dc18:	9002      	str	r0, [sp, #8]
  chMsgRelease(tp, msg);
 800dc1a:	9803      	ldr	r0, [sp, #12]
 800dc1c:	9902      	ldr	r1, [sp, #8]
 800dc1e:	f7f5 f817 	bl	8002c50 <chMsgRelease>
  test_emit_token(msg);
 800dc22:	9b02      	ldr	r3, [sp, #8]
 800dc24:	b2db      	uxtb	r3, r3
 800dc26:	4618      	mov	r0, r3
 800dc28:	f7fe f92a 	bl	800be80 <test_emit_token>
  tp = chMsgWait();
 800dc2c:	f7f4 ffe8 	bl	8002c00 <chMsgWait>
 800dc30:	9003      	str	r0, [sp, #12]
  msg = chMsgGet(tp);
 800dc32:	9803      	ldr	r0, [sp, #12]
 800dc34:	f7ff ffa4 	bl	800db80 <chMsgGet>
 800dc38:	9002      	str	r0, [sp, #8]
  chMsgRelease(tp, msg);
 800dc3a:	9803      	ldr	r0, [sp, #12]
 800dc3c:	9902      	ldr	r1, [sp, #8]
 800dc3e:	f7f5 f807 	bl	8002c50 <chMsgRelease>
  test_emit_token(msg);
 800dc42:	9b02      	ldr	r3, [sp, #8]
 800dc44:	b2db      	uxtb	r3, r3
 800dc46:	4618      	mov	r0, r3
 800dc48:	f7fe f91a 	bl	800be80 <test_emit_token>
  test_assert_sequence(1, "ABC");
 800dc4c:	2001      	movs	r0, #1
 800dc4e:	4907      	ldr	r1, [pc, #28]	; (800dc6c <msg1_execute+0xac>)
 800dc50:	f7fe f95e 	bl	800bf10 <_test_assert_sequence>
 800dc54:	4603      	mov	r3, r0
 800dc56:	2b00      	cmp	r3, #0
 800dc58:	d000      	beq.n	800dc5c <msg1_execute+0x9c>
 800dc5a:	bf00      	nop
}
 800dc5c:	b005      	add	sp, #20
 800dc5e:	bd30      	pop	{r4, r5, pc}
 800dc60:	08017b20 	.word	0x08017b20
 800dc64:	0800db91 	.word	0x0800db91
 800dc68:	20001ba4 	.word	0x20001ba4
 800dc6c:	08018020 	.word	0x08018020

0800dc70 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800dc70:	b082      	sub	sp, #8
 800dc72:	2320      	movs	r3, #32
 800dc74:	9301      	str	r3, [sp, #4]
 800dc76:	9b01      	ldr	r3, [sp, #4]
 800dc78:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800dc7c:	b002      	add	sp, #8
 800dc7e:	4770      	bx	lr

0800dc80 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800dc80:	b082      	sub	sp, #8
 800dc82:	2300      	movs	r3, #0
 800dc84:	9301      	str	r3, [sp, #4]
 800dc86:	9b01      	ldr	r3, [sp, #4]
 800dc88:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800dc8c:	b002      	add	sp, #8
 800dc8e:	4770      	bx	lr

0800dc90 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800dc90:	b508      	push	{r3, lr}

  port_lock();
 800dc92:	f7ff ffed 	bl	800dc70 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800dc96:	bd08      	pop	{r3, pc}
 800dc98:	f3af 8000 	nop.w
 800dc9c:	f3af 8000 	nop.w

0800dca0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800dca0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800dca2:	f7ff ffed 	bl	800dc80 <port_unlock>
}
 800dca6:	bd08      	pop	{r3, pc}
 800dca8:	f3af 8000 	nop.w
 800dcac:	f3af 8000 	nop.w

0800dcb0 <chSemGetCounterI>:
 * @param[in] sp        pointer to a @p semaphore_t structure
 * @return              The semaphore counter value.
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {
 800dcb0:	b082      	sub	sp, #8
 800dcb2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return sp->s_cnt;
 800dcb4:	9b01      	ldr	r3, [sp, #4]
 800dcb6:	689b      	ldr	r3, [r3, #8]
}
 800dcb8:	4618      	mov	r0, r3
 800dcba:	b002      	add	sp, #8
 800dcbc:	4770      	bx	lr
 800dcbe:	bf00      	nop

0800dcc0 <chMBGetFreeCountI>:
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of empty message slots.
 *
 * @iclass
 */
static inline cnt_t chMBGetFreeCountI(mailbox_t *mbp) {
 800dcc0:	b500      	push	{lr}
 800dcc2:	b083      	sub	sp, #12
 800dcc4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return chSemGetCounterI(&mbp->mb_emptysem);
 800dcc6:	9b01      	ldr	r3, [sp, #4]
 800dcc8:	331c      	adds	r3, #28
 800dcca:	4618      	mov	r0, r3
 800dccc:	f7ff fff0 	bl	800dcb0 <chSemGetCounterI>
 800dcd0:	4603      	mov	r3, r0
}
 800dcd2:	4618      	mov	r0, r3
 800dcd4:	b003      	add	sp, #12
 800dcd6:	f85d fb04 	ldr.w	pc, [sp], #4
 800dcda:	bf00      	nop
 800dcdc:	f3af 8000 	nop.w

0800dce0 <chMBGetUsedCountI>:
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of queued messages.
 *
 * @iclass
 */
static inline cnt_t chMBGetUsedCountI(mailbox_t *mbp) {
 800dce0:	b500      	push	{lr}
 800dce2:	b083      	sub	sp, #12
 800dce4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return chSemGetCounterI(&mbp->mb_fullsem);
 800dce6:	9b01      	ldr	r3, [sp, #4]
 800dce8:	3310      	adds	r3, #16
 800dcea:	4618      	mov	r0, r3
 800dcec:	f7ff ffe0 	bl	800dcb0 <chSemGetCounterI>
 800dcf0:	4603      	mov	r3, r0
}
 800dcf2:	4618      	mov	r0, r3
 800dcf4:	b003      	add	sp, #12
 800dcf6:	f85d fb04 	ldr.w	pc, [sp], #4
 800dcfa:	bf00      	nop
 800dcfc:	f3af 8000 	nop.w

0800dd00 <mbox1_setup>:
 * Messages are posted/fetched from a mailbox in carefully designed sequences
 * in order to stimulate all the possible code paths inside the mailbox.<br>
 * The test expects to find a consistent mailbox status after each operation.
 */

static void mbox1_setup(void) {
 800dd00:	b508      	push	{r3, lr}

  chMBObjectInit(&mb1, (msg_t *)test.wa.T0, MB_SIZE);
 800dd02:	4803      	ldr	r0, [pc, #12]	; (800dd10 <mbox1_setup+0x10>)
 800dd04:	4903      	ldr	r1, [pc, #12]	; (800dd14 <mbox1_setup+0x14>)
 800dd06:	2205      	movs	r2, #5
 800dd08:	f7f4 ffea 	bl	8002ce0 <chMBObjectInit>
}
 800dd0c:	bd08      	pop	{r3, pc}
 800dd0e:	bf00      	nop
 800dd10:	2000086c 	.word	0x2000086c
 800dd14:	20001bb8 	.word	0x20001bb8
 800dd18:	f3af 8000 	nop.w
 800dd1c:	f3af 8000 	nop.w

0800dd20 <mbox1_execute>:

static void mbox1_execute(void) {
 800dd20:	b500      	push	{lr}
 800dd22:	b085      	sub	sp, #20
  unsigned i;

  /*
   * Testing initial space.
   */
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 800dd24:	f7ff ffb4 	bl	800dc90 <chSysLock>
 800dd28:	48a9      	ldr	r0, [pc, #676]	; (800dfd0 <mbox1_execute+0x2b0>)
 800dd2a:	f7ff ffc9 	bl	800dcc0 <chMBGetFreeCountI>
 800dd2e:	4603      	mov	r3, r0
 800dd30:	2b05      	cmp	r3, #5
 800dd32:	bf14      	ite	ne
 800dd34:	2300      	movne	r3, #0
 800dd36:	2301      	moveq	r3, #1
 800dd38:	b2db      	uxtb	r3, r3
 800dd3a:	2001      	movs	r0, #1
 800dd3c:	4619      	mov	r1, r3
 800dd3e:	f7fe f8cf 	bl	800bee0 <_test_assert>
 800dd42:	4603      	mov	r3, r0
 800dd44:	2b00      	cmp	r3, #0
 800dd46:	d002      	beq.n	800dd4e <mbox1_execute+0x2e>
 800dd48:	f7ff ffaa 	bl	800dca0 <chSysUnlock>
 800dd4c:	e3ef      	b.n	800e52e <mbox1_execute+0x80e>
 800dd4e:	f7ff ffa7 	bl	800dca0 <chSysUnlock>

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
 800dd52:	2300      	movs	r3, #0
 800dd54:	9303      	str	r3, [sp, #12]
 800dd56:	e019      	b.n	800dd8c <mbox1_execute+0x6c>
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 800dd58:	9b03      	ldr	r3, [sp, #12]
 800dd5a:	3342      	adds	r3, #66	; 0x42
 800dd5c:	489c      	ldr	r0, [pc, #624]	; (800dfd0 <mbox1_execute+0x2b0>)
 800dd5e:	4619      	mov	r1, r3
 800dd60:	f04f 32ff 	mov.w	r2, #4294967295
 800dd64:	f7f5 f81c 	bl	8002da0 <chMBPost>
 800dd68:	9002      	str	r0, [sp, #8]
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
 800dd6a:	9b02      	ldr	r3, [sp, #8]
 800dd6c:	2b00      	cmp	r3, #0
 800dd6e:	bf14      	ite	ne
 800dd70:	2300      	movne	r3, #0
 800dd72:	2301      	moveq	r3, #1
 800dd74:	b2db      	uxtb	r3, r3
 800dd76:	2002      	movs	r0, #2
 800dd78:	4619      	mov	r1, r3
 800dd7a:	f7fe f8b1 	bl	800bee0 <_test_assert>
 800dd7e:	4603      	mov	r3, r0
 800dd80:	2b00      	cmp	r3, #0
 800dd82:	d000      	beq.n	800dd86 <mbox1_execute+0x66>
 800dd84:	e3d3      	b.n	800e52e <mbox1_execute+0x80e>
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
 800dd86:	9b03      	ldr	r3, [sp, #12]
 800dd88:	3301      	adds	r3, #1
 800dd8a:	9303      	str	r3, [sp, #12]
 800dd8c:	9b03      	ldr	r3, [sp, #12]
 800dd8e:	2b03      	cmp	r3, #3
 800dd90:	d9e2      	bls.n	800dd58 <mbox1_execute+0x38>
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
  }
  msg1 = chMBPostAhead(&mb1, 'A', TIME_INFINITE);
 800dd92:	488f      	ldr	r0, [pc, #572]	; (800dfd0 <mbox1_execute+0x2b0>)
 800dd94:	2141      	movs	r1, #65	; 0x41
 800dd96:	f04f 32ff 	mov.w	r2, #4294967295
 800dd9a:	f7f5 f879 	bl	8002e90 <chMBPostAhead>
 800dd9e:	9002      	str	r0, [sp, #8]
  test_assert(3, msg1 == MSG_OK, "wrong wake-up message");
 800dda0:	9b02      	ldr	r3, [sp, #8]
 800dda2:	2b00      	cmp	r3, #0
 800dda4:	bf14      	ite	ne
 800dda6:	2300      	movne	r3, #0
 800dda8:	2301      	moveq	r3, #1
 800ddaa:	b2db      	uxtb	r3, r3
 800ddac:	2003      	movs	r0, #3
 800ddae:	4619      	mov	r1, r3
 800ddb0:	f7fe f896 	bl	800bee0 <_test_assert>
 800ddb4:	4603      	mov	r3, r0
 800ddb6:	2b00      	cmp	r3, #0
 800ddb8:	d000      	beq.n	800ddbc <mbox1_execute+0x9c>
 800ddba:	e3b8      	b.n	800e52e <mbox1_execute+0x80e>

  /*
   * Testing post timeout.
   */
  msg1 = chMBPost(&mb1, 'X', 1);
 800ddbc:	4884      	ldr	r0, [pc, #528]	; (800dfd0 <mbox1_execute+0x2b0>)
 800ddbe:	2158      	movs	r1, #88	; 0x58
 800ddc0:	2201      	movs	r2, #1
 800ddc2:	f7f4 ffed 	bl	8002da0 <chMBPost>
 800ddc6:	9002      	str	r0, [sp, #8]
  test_assert(4, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800ddc8:	9b02      	ldr	r3, [sp, #8]
 800ddca:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ddce:	bf14      	ite	ne
 800ddd0:	2300      	movne	r3, #0
 800ddd2:	2301      	moveq	r3, #1
 800ddd4:	b2db      	uxtb	r3, r3
 800ddd6:	2004      	movs	r0, #4
 800ddd8:	4619      	mov	r1, r3
 800ddda:	f7fe f881 	bl	800bee0 <_test_assert>
 800ddde:	4603      	mov	r3, r0
 800dde0:	2b00      	cmp	r3, #0
 800dde2:	d000      	beq.n	800dde6 <mbox1_execute+0xc6>
 800dde4:	e3a3      	b.n	800e52e <mbox1_execute+0x80e>
  chSysLock();
 800dde6:	f7ff ff53 	bl	800dc90 <chSysLock>
  msg1 = chMBPostI(&mb1, 'X');
 800ddea:	4879      	ldr	r0, [pc, #484]	; (800dfd0 <mbox1_execute+0x2b0>)
 800ddec:	2158      	movs	r1, #88	; 0x58
 800ddee:	f7f5 f81f 	bl	8002e30 <chMBPostI>
 800ddf2:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 800ddf4:	f7ff ff54 	bl	800dca0 <chSysUnlock>
  test_assert(5, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800ddf8:	9b02      	ldr	r3, [sp, #8]
 800ddfa:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ddfe:	bf14      	ite	ne
 800de00:	2300      	movne	r3, #0
 800de02:	2301      	moveq	r3, #1
 800de04:	b2db      	uxtb	r3, r3
 800de06:	2005      	movs	r0, #5
 800de08:	4619      	mov	r1, r3
 800de0a:	f7fe f869 	bl	800bee0 <_test_assert>
 800de0e:	4603      	mov	r3, r0
 800de10:	2b00      	cmp	r3, #0
 800de12:	d000      	beq.n	800de16 <mbox1_execute+0xf6>
 800de14:	e38b      	b.n	800e52e <mbox1_execute+0x80e>
  msg1 = chMBPostAhead(&mb1, 'X', 1);
 800de16:	486e      	ldr	r0, [pc, #440]	; (800dfd0 <mbox1_execute+0x2b0>)
 800de18:	2158      	movs	r1, #88	; 0x58
 800de1a:	2201      	movs	r2, #1
 800de1c:	f7f5 f838 	bl	8002e90 <chMBPostAhead>
 800de20:	9002      	str	r0, [sp, #8]
  test_assert(6, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800de22:	9b02      	ldr	r3, [sp, #8]
 800de24:	f1b3 3fff 	cmp.w	r3, #4294967295
 800de28:	bf14      	ite	ne
 800de2a:	2300      	movne	r3, #0
 800de2c:	2301      	moveq	r3, #1
 800de2e:	b2db      	uxtb	r3, r3
 800de30:	2006      	movs	r0, #6
 800de32:	4619      	mov	r1, r3
 800de34:	f7fe f854 	bl	800bee0 <_test_assert>
 800de38:	4603      	mov	r3, r0
 800de3a:	2b00      	cmp	r3, #0
 800de3c:	d000      	beq.n	800de40 <mbox1_execute+0x120>
 800de3e:	e376      	b.n	800e52e <mbox1_execute+0x80e>
  chSysLock();
 800de40:	f7ff ff26 	bl	800dc90 <chSysLock>
  msg1 = chMBPostAheadI(&mb1, 'X');
 800de44:	4862      	ldr	r0, [pc, #392]	; (800dfd0 <mbox1_execute+0x2b0>)
 800de46:	2158      	movs	r1, #88	; 0x58
 800de48:	f7f5 f86a 	bl	8002f20 <chMBPostAheadI>
 800de4c:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 800de4e:	f7ff ff27 	bl	800dca0 <chSysUnlock>
  test_assert(7, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800de52:	9b02      	ldr	r3, [sp, #8]
 800de54:	f1b3 3fff 	cmp.w	r3, #4294967295
 800de58:	bf14      	ite	ne
 800de5a:	2300      	movne	r3, #0
 800de5c:	2301      	moveq	r3, #1
 800de5e:	b2db      	uxtb	r3, r3
 800de60:	2007      	movs	r0, #7
 800de62:	4619      	mov	r1, r3
 800de64:	f7fe f83c 	bl	800bee0 <_test_assert>
 800de68:	4603      	mov	r3, r0
 800de6a:	2b00      	cmp	r3, #0
 800de6c:	d000      	beq.n	800de70 <mbox1_execute+0x150>
 800de6e:	e35e      	b.n	800e52e <mbox1_execute+0x80e>

  /*
   * Testing final conditions.
   */
  test_assert_lock(8, chMBGetFreeCountI(&mb1) == 0, "still empty");
 800de70:	f7ff ff0e 	bl	800dc90 <chSysLock>
 800de74:	4856      	ldr	r0, [pc, #344]	; (800dfd0 <mbox1_execute+0x2b0>)
 800de76:	f7ff ff23 	bl	800dcc0 <chMBGetFreeCountI>
 800de7a:	4603      	mov	r3, r0
 800de7c:	2b00      	cmp	r3, #0
 800de7e:	bf14      	ite	ne
 800de80:	2300      	movne	r3, #0
 800de82:	2301      	moveq	r3, #1
 800de84:	b2db      	uxtb	r3, r3
 800de86:	2008      	movs	r0, #8
 800de88:	4619      	mov	r1, r3
 800de8a:	f7fe f829 	bl	800bee0 <_test_assert>
 800de8e:	4603      	mov	r3, r0
 800de90:	2b00      	cmp	r3, #0
 800de92:	d002      	beq.n	800de9a <mbox1_execute+0x17a>
 800de94:	f7ff ff04 	bl	800dca0 <chSysUnlock>
 800de98:	e349      	b.n	800e52e <mbox1_execute+0x80e>
 800de9a:	f7ff ff01 	bl	800dca0 <chSysUnlock>
  test_assert_lock(9, chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 800de9e:	f7ff fef7 	bl	800dc90 <chSysLock>
 800dea2:	484b      	ldr	r0, [pc, #300]	; (800dfd0 <mbox1_execute+0x2b0>)
 800dea4:	f7ff ff1c 	bl	800dce0 <chMBGetUsedCountI>
 800dea8:	4603      	mov	r3, r0
 800deaa:	2b05      	cmp	r3, #5
 800deac:	bf14      	ite	ne
 800deae:	2300      	movne	r3, #0
 800deb0:	2301      	moveq	r3, #1
 800deb2:	b2db      	uxtb	r3, r3
 800deb4:	2009      	movs	r0, #9
 800deb6:	4619      	mov	r1, r3
 800deb8:	f7fe f812 	bl	800bee0 <_test_assert>
 800debc:	4603      	mov	r3, r0
 800debe:	2b00      	cmp	r3, #0
 800dec0:	d002      	beq.n	800dec8 <mbox1_execute+0x1a8>
 800dec2:	f7ff feed 	bl	800dca0 <chSysUnlock>
 800dec6:	e332      	b.n	800e52e <mbox1_execute+0x80e>
 800dec8:	f7ff feea 	bl	800dca0 <chSysUnlock>
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800decc:	f7ff fee0 	bl	800dc90 <chSysLock>
 800ded0:	4b3f      	ldr	r3, [pc, #252]	; (800dfd0 <mbox1_execute+0x2b0>)
 800ded2:	68da      	ldr	r2, [r3, #12]
 800ded4:	4b3e      	ldr	r3, [pc, #248]	; (800dfd0 <mbox1_execute+0x2b0>)
 800ded6:	689b      	ldr	r3, [r3, #8]
 800ded8:	429a      	cmp	r2, r3
 800deda:	bf14      	ite	ne
 800dedc:	2300      	movne	r3, #0
 800dede:	2301      	moveq	r3, #1
 800dee0:	b2db      	uxtb	r3, r3
 800dee2:	200a      	movs	r0, #10
 800dee4:	4619      	mov	r1, r3
 800dee6:	f7fd fffb 	bl	800bee0 <_test_assert>
 800deea:	4603      	mov	r3, r0
 800deec:	2b00      	cmp	r3, #0
 800deee:	d002      	beq.n	800def6 <mbox1_execute+0x1d6>
 800def0:	f7ff fed6 	bl	800dca0 <chSysUnlock>
 800def4:	e31b      	b.n	800e52e <mbox1_execute+0x80e>
 800def6:	f7ff fed3 	bl	800dca0 <chSysUnlock>

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
 800defa:	2300      	movs	r3, #0
 800defc:	9303      	str	r3, [sp, #12]
 800defe:	e01d      	b.n	800df3c <mbox1_execute+0x21c>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 800df00:	ab01      	add	r3, sp, #4
 800df02:	4833      	ldr	r0, [pc, #204]	; (800dfd0 <mbox1_execute+0x2b0>)
 800df04:	4619      	mov	r1, r3
 800df06:	f04f 32ff 	mov.w	r2, #4294967295
 800df0a:	f7f5 f841 	bl	8002f90 <chMBFetch>
 800df0e:	9002      	str	r0, [sp, #8]
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
 800df10:	9b02      	ldr	r3, [sp, #8]
 800df12:	2b00      	cmp	r3, #0
 800df14:	bf14      	ite	ne
 800df16:	2300      	movne	r3, #0
 800df18:	2301      	moveq	r3, #1
 800df1a:	b2db      	uxtb	r3, r3
 800df1c:	200b      	movs	r0, #11
 800df1e:	4619      	mov	r1, r3
 800df20:	f7fd ffde 	bl	800bee0 <_test_assert>
 800df24:	4603      	mov	r3, r0
 800df26:	2b00      	cmp	r3, #0
 800df28:	d000      	beq.n	800df2c <mbox1_execute+0x20c>
 800df2a:	e300      	b.n	800e52e <mbox1_execute+0x80e>
    test_emit_token(msg2);
 800df2c:	9b01      	ldr	r3, [sp, #4]
 800df2e:	b2db      	uxtb	r3, r3
 800df30:	4618      	mov	r0, r3
 800df32:	f7fd ffa5 	bl	800be80 <test_emit_token>
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
 800df36:	9b03      	ldr	r3, [sp, #12]
 800df38:	3301      	adds	r3, #1
 800df3a:	9303      	str	r3, [sp, #12]
 800df3c:	9b03      	ldr	r3, [sp, #12]
 800df3e:	2b04      	cmp	r3, #4
 800df40:	d9de      	bls.n	800df00 <mbox1_execute+0x1e0>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(12, "ABCDE");
 800df42:	200c      	movs	r0, #12
 800df44:	4923      	ldr	r1, [pc, #140]	; (800dfd4 <mbox1_execute+0x2b4>)
 800df46:	f7fd ffe3 	bl	800bf10 <_test_assert_sequence>
 800df4a:	4603      	mov	r3, r0
 800df4c:	2b00      	cmp	r3, #0
 800df4e:	d000      	beq.n	800df52 <mbox1_execute+0x232>
 800df50:	e2ed      	b.n	800e52e <mbox1_execute+0x80e>

  /*
   * Testing buffer circularity.
   */
  msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 800df52:	9b03      	ldr	r3, [sp, #12]
 800df54:	3342      	adds	r3, #66	; 0x42
 800df56:	481e      	ldr	r0, [pc, #120]	; (800dfd0 <mbox1_execute+0x2b0>)
 800df58:	4619      	mov	r1, r3
 800df5a:	f04f 32ff 	mov.w	r2, #4294967295
 800df5e:	f7f4 ff1f 	bl	8002da0 <chMBPost>
 800df62:	9002      	str	r0, [sp, #8]
  test_assert(13, msg1 == MSG_OK, "wrong wake-up message");
 800df64:	9b02      	ldr	r3, [sp, #8]
 800df66:	2b00      	cmp	r3, #0
 800df68:	bf14      	ite	ne
 800df6a:	2300      	movne	r3, #0
 800df6c:	2301      	moveq	r3, #1
 800df6e:	b2db      	uxtb	r3, r3
 800df70:	200d      	movs	r0, #13
 800df72:	4619      	mov	r1, r3
 800df74:	f7fd ffb4 	bl	800bee0 <_test_assert>
 800df78:	4603      	mov	r3, r0
 800df7a:	2b00      	cmp	r3, #0
 800df7c:	d000      	beq.n	800df80 <mbox1_execute+0x260>
 800df7e:	e2d6      	b.n	800e52e <mbox1_execute+0x80e>
  msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 800df80:	ab01      	add	r3, sp, #4
 800df82:	4813      	ldr	r0, [pc, #76]	; (800dfd0 <mbox1_execute+0x2b0>)
 800df84:	4619      	mov	r1, r3
 800df86:	f04f 32ff 	mov.w	r2, #4294967295
 800df8a:	f7f5 f801 	bl	8002f90 <chMBFetch>
 800df8e:	9002      	str	r0, [sp, #8]
  test_assert(14, msg1 == MSG_OK, "wrong wake-up message");
 800df90:	9b02      	ldr	r3, [sp, #8]
 800df92:	2b00      	cmp	r3, #0
 800df94:	bf14      	ite	ne
 800df96:	2300      	movne	r3, #0
 800df98:	2301      	moveq	r3, #1
 800df9a:	b2db      	uxtb	r3, r3
 800df9c:	200e      	movs	r0, #14
 800df9e:	4619      	mov	r1, r3
 800dfa0:	f7fd ff9e 	bl	800bee0 <_test_assert>
 800dfa4:	4603      	mov	r3, r0
 800dfa6:	2b00      	cmp	r3, #0
 800dfa8:	d000      	beq.n	800dfac <mbox1_execute+0x28c>
 800dfaa:	e2c0      	b.n	800e52e <mbox1_execute+0x80e>
  test_assert(15, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 800dfac:	4b08      	ldr	r3, [pc, #32]	; (800dfd0 <mbox1_execute+0x2b0>)
 800dfae:	681a      	ldr	r2, [r3, #0]
 800dfb0:	4b07      	ldr	r3, [pc, #28]	; (800dfd0 <mbox1_execute+0x2b0>)
 800dfb2:	689b      	ldr	r3, [r3, #8]
 800dfb4:	429a      	cmp	r2, r3
 800dfb6:	bf14      	ite	ne
 800dfb8:	2300      	movne	r3, #0
 800dfba:	2301      	moveq	r3, #1
 800dfbc:	b2db      	uxtb	r3, r3
 800dfbe:	200f      	movs	r0, #15
 800dfc0:	4619      	mov	r1, r3
 800dfc2:	f7fd ff8d 	bl	800bee0 <_test_assert>
 800dfc6:	4603      	mov	r3, r0
 800dfc8:	2b00      	cmp	r3, #0
 800dfca:	d005      	beq.n	800dfd8 <mbox1_execute+0x2b8>
 800dfcc:	e2af      	b.n	800e52e <mbox1_execute+0x80e>
 800dfce:	bf00      	nop
 800dfd0:	2000086c 	.word	0x2000086c
 800dfd4:	08018050 	.word	0x08018050
  test_assert(16, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 800dfd8:	4ba9      	ldr	r3, [pc, #676]	; (800e280 <mbox1_execute+0x560>)
 800dfda:	681a      	ldr	r2, [r3, #0]
 800dfdc:	4ba8      	ldr	r3, [pc, #672]	; (800e280 <mbox1_execute+0x560>)
 800dfde:	68db      	ldr	r3, [r3, #12]
 800dfe0:	429a      	cmp	r2, r3
 800dfe2:	bf14      	ite	ne
 800dfe4:	2300      	movne	r3, #0
 800dfe6:	2301      	moveq	r3, #1
 800dfe8:	b2db      	uxtb	r3, r3
 800dfea:	2010      	movs	r0, #16
 800dfec:	4619      	mov	r1, r3
 800dfee:	f7fd ff77 	bl	800bee0 <_test_assert>
 800dff2:	4603      	mov	r3, r0
 800dff4:	2b00      	cmp	r3, #0
 800dff6:	d000      	beq.n	800dffa <mbox1_execute+0x2da>
 800dff8:	e299      	b.n	800e52e <mbox1_execute+0x80e>

  /*
   * Testing fetch timeout.
   */
  msg1 = chMBFetch(&mb1, &msg2, 1);
 800dffa:	ab01      	add	r3, sp, #4
 800dffc:	48a0      	ldr	r0, [pc, #640]	; (800e280 <mbox1_execute+0x560>)
 800dffe:	4619      	mov	r1, r3
 800e000:	2201      	movs	r2, #1
 800e002:	f7f4 ffc5 	bl	8002f90 <chMBFetch>
 800e006:	9002      	str	r0, [sp, #8]
  test_assert(17, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800e008:	9b02      	ldr	r3, [sp, #8]
 800e00a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800e00e:	bf14      	ite	ne
 800e010:	2300      	movne	r3, #0
 800e012:	2301      	moveq	r3, #1
 800e014:	b2db      	uxtb	r3, r3
 800e016:	2011      	movs	r0, #17
 800e018:	4619      	mov	r1, r3
 800e01a:	f7fd ff61 	bl	800bee0 <_test_assert>
 800e01e:	4603      	mov	r3, r0
 800e020:	2b00      	cmp	r3, #0
 800e022:	d000      	beq.n	800e026 <mbox1_execute+0x306>
 800e024:	e283      	b.n	800e52e <mbox1_execute+0x80e>
  chSysLock();
 800e026:	f7ff fe33 	bl	800dc90 <chSysLock>
  msg1 = chMBFetchI(&mb1, &msg2);
 800e02a:	ab01      	add	r3, sp, #4
 800e02c:	4894      	ldr	r0, [pc, #592]	; (800e280 <mbox1_execute+0x560>)
 800e02e:	4619      	mov	r1, r3
 800e030:	f7f4 fff6 	bl	8003020 <chMBFetchI>
 800e034:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 800e036:	f7ff fe33 	bl	800dca0 <chSysUnlock>
  test_assert(18, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800e03a:	9b02      	ldr	r3, [sp, #8]
 800e03c:	f1b3 3fff 	cmp.w	r3, #4294967295
 800e040:	bf14      	ite	ne
 800e042:	2300      	movne	r3, #0
 800e044:	2301      	moveq	r3, #1
 800e046:	b2db      	uxtb	r3, r3
 800e048:	2012      	movs	r0, #18
 800e04a:	4619      	mov	r1, r3
 800e04c:	f7fd ff48 	bl	800bee0 <_test_assert>
 800e050:	4603      	mov	r3, r0
 800e052:	2b00      	cmp	r3, #0
 800e054:	d000      	beq.n	800e058 <mbox1_execute+0x338>
 800e056:	e26a      	b.n	800e52e <mbox1_execute+0x80e>

  /*
   * Testing final conditions.
   */
  test_assert_lock(19, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800e058:	f7ff fe1a 	bl	800dc90 <chSysLock>
 800e05c:	4888      	ldr	r0, [pc, #544]	; (800e280 <mbox1_execute+0x560>)
 800e05e:	f7ff fe2f 	bl	800dcc0 <chMBGetFreeCountI>
 800e062:	4603      	mov	r3, r0
 800e064:	2b05      	cmp	r3, #5
 800e066:	bf14      	ite	ne
 800e068:	2300      	movne	r3, #0
 800e06a:	2301      	moveq	r3, #1
 800e06c:	b2db      	uxtb	r3, r3
 800e06e:	2013      	movs	r0, #19
 800e070:	4619      	mov	r1, r3
 800e072:	f7fd ff35 	bl	800bee0 <_test_assert>
 800e076:	4603      	mov	r3, r0
 800e078:	2b00      	cmp	r3, #0
 800e07a:	d002      	beq.n	800e082 <mbox1_execute+0x362>
 800e07c:	f7ff fe10 	bl	800dca0 <chSysUnlock>
 800e080:	e255      	b.n	800e52e <mbox1_execute+0x80e>
 800e082:	f7ff fe0d 	bl	800dca0 <chSysUnlock>
  test_assert_lock(20, chMBGetUsedCountI(&mb1) == 0, "still full");
 800e086:	f7ff fe03 	bl	800dc90 <chSysLock>
 800e08a:	487d      	ldr	r0, [pc, #500]	; (800e280 <mbox1_execute+0x560>)
 800e08c:	f7ff fe28 	bl	800dce0 <chMBGetUsedCountI>
 800e090:	4603      	mov	r3, r0
 800e092:	2b00      	cmp	r3, #0
 800e094:	bf14      	ite	ne
 800e096:	2300      	movne	r3, #0
 800e098:	2301      	moveq	r3, #1
 800e09a:	b2db      	uxtb	r3, r3
 800e09c:	2014      	movs	r0, #20
 800e09e:	4619      	mov	r1, r3
 800e0a0:	f7fd ff1e 	bl	800bee0 <_test_assert>
 800e0a4:	4603      	mov	r3, r0
 800e0a6:	2b00      	cmp	r3, #0
 800e0a8:	d002      	beq.n	800e0b0 <mbox1_execute+0x390>
 800e0aa:	f7ff fdf9 	bl	800dca0 <chSysUnlock>
 800e0ae:	e23e      	b.n	800e52e <mbox1_execute+0x80e>
 800e0b0:	f7ff fdf6 	bl	800dca0 <chSysUnlock>
  test_assert_lock(21, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800e0b4:	f7ff fdec 	bl	800dc90 <chSysLock>
 800e0b8:	4b71      	ldr	r3, [pc, #452]	; (800e280 <mbox1_execute+0x560>)
 800e0ba:	68da      	ldr	r2, [r3, #12]
 800e0bc:	4b70      	ldr	r3, [pc, #448]	; (800e280 <mbox1_execute+0x560>)
 800e0be:	689b      	ldr	r3, [r3, #8]
 800e0c0:	429a      	cmp	r2, r3
 800e0c2:	bf14      	ite	ne
 800e0c4:	2300      	movne	r3, #0
 800e0c6:	2301      	moveq	r3, #1
 800e0c8:	b2db      	uxtb	r3, r3
 800e0ca:	2015      	movs	r0, #21
 800e0cc:	4619      	mov	r1, r3
 800e0ce:	f7fd ff07 	bl	800bee0 <_test_assert>
 800e0d2:	4603      	mov	r3, r0
 800e0d4:	2b00      	cmp	r3, #0
 800e0d6:	d002      	beq.n	800e0de <mbox1_execute+0x3be>
 800e0d8:	f7ff fde2 	bl	800dca0 <chSysUnlock>
 800e0dc:	e227      	b.n	800e52e <mbox1_execute+0x80e>
 800e0de:	f7ff fddf 	bl	800dca0 <chSysUnlock>

  /*
   * Testing I-Class.
   */
  chSysLock();
 800e0e2:	f7ff fdd5 	bl	800dc90 <chSysLock>
  msg1 = chMBPostI(&mb1, 'A');
 800e0e6:	4866      	ldr	r0, [pc, #408]	; (800e280 <mbox1_execute+0x560>)
 800e0e8:	2141      	movs	r1, #65	; 0x41
 800e0ea:	f7f4 fea1 	bl	8002e30 <chMBPostI>
 800e0ee:	9002      	str	r0, [sp, #8]
  test_assert(22, msg1 == MSG_OK, "wrong wake-up message");
 800e0f0:	9b02      	ldr	r3, [sp, #8]
 800e0f2:	2b00      	cmp	r3, #0
 800e0f4:	bf14      	ite	ne
 800e0f6:	2300      	movne	r3, #0
 800e0f8:	2301      	moveq	r3, #1
 800e0fa:	b2db      	uxtb	r3, r3
 800e0fc:	2016      	movs	r0, #22
 800e0fe:	4619      	mov	r1, r3
 800e100:	f7fd feee 	bl	800bee0 <_test_assert>
 800e104:	4603      	mov	r3, r0
 800e106:	2b00      	cmp	r3, #0
 800e108:	d000      	beq.n	800e10c <mbox1_execute+0x3ec>
 800e10a:	e210      	b.n	800e52e <mbox1_execute+0x80e>
  msg1 = chMBPostI(&mb1, 'B');
 800e10c:	485c      	ldr	r0, [pc, #368]	; (800e280 <mbox1_execute+0x560>)
 800e10e:	2142      	movs	r1, #66	; 0x42
 800e110:	f7f4 fe8e 	bl	8002e30 <chMBPostI>
 800e114:	9002      	str	r0, [sp, #8]
  test_assert(23, msg1 == MSG_OK, "wrong wake-up message");
 800e116:	9b02      	ldr	r3, [sp, #8]
 800e118:	2b00      	cmp	r3, #0
 800e11a:	bf14      	ite	ne
 800e11c:	2300      	movne	r3, #0
 800e11e:	2301      	moveq	r3, #1
 800e120:	b2db      	uxtb	r3, r3
 800e122:	2017      	movs	r0, #23
 800e124:	4619      	mov	r1, r3
 800e126:	f7fd fedb 	bl	800bee0 <_test_assert>
 800e12a:	4603      	mov	r3, r0
 800e12c:	2b00      	cmp	r3, #0
 800e12e:	d000      	beq.n	800e132 <mbox1_execute+0x412>
 800e130:	e1fd      	b.n	800e52e <mbox1_execute+0x80e>
  msg1 = chMBPostI(&mb1, 'C');
 800e132:	4853      	ldr	r0, [pc, #332]	; (800e280 <mbox1_execute+0x560>)
 800e134:	2143      	movs	r1, #67	; 0x43
 800e136:	f7f4 fe7b 	bl	8002e30 <chMBPostI>
 800e13a:	9002      	str	r0, [sp, #8]
  test_assert(24, msg1 == MSG_OK, "wrong wake-up message");
 800e13c:	9b02      	ldr	r3, [sp, #8]
 800e13e:	2b00      	cmp	r3, #0
 800e140:	bf14      	ite	ne
 800e142:	2300      	movne	r3, #0
 800e144:	2301      	moveq	r3, #1
 800e146:	b2db      	uxtb	r3, r3
 800e148:	2018      	movs	r0, #24
 800e14a:	4619      	mov	r1, r3
 800e14c:	f7fd fec8 	bl	800bee0 <_test_assert>
 800e150:	4603      	mov	r3, r0
 800e152:	2b00      	cmp	r3, #0
 800e154:	d000      	beq.n	800e158 <mbox1_execute+0x438>
 800e156:	e1ea      	b.n	800e52e <mbox1_execute+0x80e>
  msg1 = chMBPostI(&mb1, 'D');
 800e158:	4849      	ldr	r0, [pc, #292]	; (800e280 <mbox1_execute+0x560>)
 800e15a:	2144      	movs	r1, #68	; 0x44
 800e15c:	f7f4 fe68 	bl	8002e30 <chMBPostI>
 800e160:	9002      	str	r0, [sp, #8]
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
 800e162:	9b02      	ldr	r3, [sp, #8]
 800e164:	2b00      	cmp	r3, #0
 800e166:	bf14      	ite	ne
 800e168:	2300      	movne	r3, #0
 800e16a:	2301      	moveq	r3, #1
 800e16c:	b2db      	uxtb	r3, r3
 800e16e:	2019      	movs	r0, #25
 800e170:	4619      	mov	r1, r3
 800e172:	f7fd feb5 	bl	800bee0 <_test_assert>
 800e176:	4603      	mov	r3, r0
 800e178:	2b00      	cmp	r3, #0
 800e17a:	d000      	beq.n	800e17e <mbox1_execute+0x45e>
 800e17c:	e1d7      	b.n	800e52e <mbox1_execute+0x80e>
  msg1 = chMBPostI(&mb1, 'E');
 800e17e:	4840      	ldr	r0, [pc, #256]	; (800e280 <mbox1_execute+0x560>)
 800e180:	2145      	movs	r1, #69	; 0x45
 800e182:	f7f4 fe55 	bl	8002e30 <chMBPostI>
 800e186:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 800e188:	f7ff fd8a 	bl	800dca0 <chSysUnlock>
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
 800e18c:	9b02      	ldr	r3, [sp, #8]
 800e18e:	2b00      	cmp	r3, #0
 800e190:	bf14      	ite	ne
 800e192:	2300      	movne	r3, #0
 800e194:	2301      	moveq	r3, #1
 800e196:	b2db      	uxtb	r3, r3
 800e198:	201a      	movs	r0, #26
 800e19a:	4619      	mov	r1, r3
 800e19c:	f7fd fea0 	bl	800bee0 <_test_assert>
 800e1a0:	4603      	mov	r3, r0
 800e1a2:	2b00      	cmp	r3, #0
 800e1a4:	d000      	beq.n	800e1a8 <mbox1_execute+0x488>
 800e1a6:	e1c2      	b.n	800e52e <mbox1_execute+0x80e>
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800e1a8:	4b35      	ldr	r3, [pc, #212]	; (800e280 <mbox1_execute+0x560>)
 800e1aa:	68da      	ldr	r2, [r3, #12]
 800e1ac:	4b34      	ldr	r3, [pc, #208]	; (800e280 <mbox1_execute+0x560>)
 800e1ae:	689b      	ldr	r3, [r3, #8]
 800e1b0:	429a      	cmp	r2, r3
 800e1b2:	bf14      	ite	ne
 800e1b4:	2300      	movne	r3, #0
 800e1b6:	2301      	moveq	r3, #1
 800e1b8:	b2db      	uxtb	r3, r3
 800e1ba:	201b      	movs	r0, #27
 800e1bc:	4619      	mov	r1, r3
 800e1be:	f7fd fe8f 	bl	800bee0 <_test_assert>
 800e1c2:	4603      	mov	r3, r0
 800e1c4:	2b00      	cmp	r3, #0
 800e1c6:	d000      	beq.n	800e1ca <mbox1_execute+0x4aa>
 800e1c8:	e1b1      	b.n	800e52e <mbox1_execute+0x80e>
  for (i = 0; i < MB_SIZE; i++) {
 800e1ca:	2300      	movs	r3, #0
 800e1cc:	9303      	str	r3, [sp, #12]
 800e1ce:	e01f      	b.n	800e210 <mbox1_execute+0x4f0>
    chSysLock();
 800e1d0:	f7ff fd5e 	bl	800dc90 <chSysLock>
    msg1 = chMBFetchI(&mb1, &msg2);
 800e1d4:	ab01      	add	r3, sp, #4
 800e1d6:	482a      	ldr	r0, [pc, #168]	; (800e280 <mbox1_execute+0x560>)
 800e1d8:	4619      	mov	r1, r3
 800e1da:	f7f4 ff21 	bl	8003020 <chMBFetchI>
 800e1de:	9002      	str	r0, [sp, #8]
    chSysUnlock();
 800e1e0:	f7ff fd5e 	bl	800dca0 <chSysUnlock>
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
 800e1e4:	9b02      	ldr	r3, [sp, #8]
 800e1e6:	2b00      	cmp	r3, #0
 800e1e8:	bf14      	ite	ne
 800e1ea:	2300      	movne	r3, #0
 800e1ec:	2301      	moveq	r3, #1
 800e1ee:	b2db      	uxtb	r3, r3
 800e1f0:	201c      	movs	r0, #28
 800e1f2:	4619      	mov	r1, r3
 800e1f4:	f7fd fe74 	bl	800bee0 <_test_assert>
 800e1f8:	4603      	mov	r3, r0
 800e1fa:	2b00      	cmp	r3, #0
 800e1fc:	d000      	beq.n	800e200 <mbox1_execute+0x4e0>
 800e1fe:	e196      	b.n	800e52e <mbox1_execute+0x80e>
    test_emit_token(msg2);
 800e200:	9b01      	ldr	r3, [sp, #4]
 800e202:	b2db      	uxtb	r3, r3
 800e204:	4618      	mov	r0, r3
 800e206:	f7fd fe3b 	bl	800be80 <test_emit_token>
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
  msg1 = chMBPostI(&mb1, 'E');
  chSysUnlock();
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
 800e20a:	9b03      	ldr	r3, [sp, #12]
 800e20c:	3301      	adds	r3, #1
 800e20e:	9303      	str	r3, [sp, #12]
 800e210:	9b03      	ldr	r3, [sp, #12]
 800e212:	2b04      	cmp	r3, #4
 800e214:	d9dc      	bls.n	800e1d0 <mbox1_execute+0x4b0>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(29, "ABCDE");
 800e216:	201d      	movs	r0, #29
 800e218:	491a      	ldr	r1, [pc, #104]	; (800e284 <mbox1_execute+0x564>)
 800e21a:	f7fd fe79 	bl	800bf10 <_test_assert_sequence>
 800e21e:	4603      	mov	r3, r0
 800e220:	2b00      	cmp	r3, #0
 800e222:	d000      	beq.n	800e226 <mbox1_execute+0x506>
 800e224:	e183      	b.n	800e52e <mbox1_execute+0x80e>
  test_assert_lock(30, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800e226:	f7ff fd33 	bl	800dc90 <chSysLock>
 800e22a:	4815      	ldr	r0, [pc, #84]	; (800e280 <mbox1_execute+0x560>)
 800e22c:	f7ff fd48 	bl	800dcc0 <chMBGetFreeCountI>
 800e230:	4603      	mov	r3, r0
 800e232:	2b05      	cmp	r3, #5
 800e234:	bf14      	ite	ne
 800e236:	2300      	movne	r3, #0
 800e238:	2301      	moveq	r3, #1
 800e23a:	b2db      	uxtb	r3, r3
 800e23c:	201e      	movs	r0, #30
 800e23e:	4619      	mov	r1, r3
 800e240:	f7fd fe4e 	bl	800bee0 <_test_assert>
 800e244:	4603      	mov	r3, r0
 800e246:	2b00      	cmp	r3, #0
 800e248:	d002      	beq.n	800e250 <mbox1_execute+0x530>
 800e24a:	f7ff fd29 	bl	800dca0 <chSysUnlock>
 800e24e:	e16e      	b.n	800e52e <mbox1_execute+0x80e>
 800e250:	f7ff fd26 	bl	800dca0 <chSysUnlock>
  test_assert_lock(31, chMBGetUsedCountI(&mb1) == 0, "still full");
 800e254:	f7ff fd1c 	bl	800dc90 <chSysLock>
 800e258:	4809      	ldr	r0, [pc, #36]	; (800e280 <mbox1_execute+0x560>)
 800e25a:	f7ff fd41 	bl	800dce0 <chMBGetUsedCountI>
 800e25e:	4603      	mov	r3, r0
 800e260:	2b00      	cmp	r3, #0
 800e262:	bf14      	ite	ne
 800e264:	2300      	movne	r3, #0
 800e266:	2301      	moveq	r3, #1
 800e268:	b2db      	uxtb	r3, r3
 800e26a:	201f      	movs	r0, #31
 800e26c:	4619      	mov	r1, r3
 800e26e:	f7fd fe37 	bl	800bee0 <_test_assert>
 800e272:	4603      	mov	r3, r0
 800e274:	2b00      	cmp	r3, #0
 800e276:	d007      	beq.n	800e288 <mbox1_execute+0x568>
 800e278:	f7ff fd12 	bl	800dca0 <chSysUnlock>
 800e27c:	e157      	b.n	800e52e <mbox1_execute+0x80e>
 800e27e:	bf00      	nop
 800e280:	2000086c 	.word	0x2000086c
 800e284:	08018050 	.word	0x08018050
 800e288:	f7ff fd0a 	bl	800dca0 <chSysUnlock>
  test_assert(32, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800e28c:	4ba9      	ldr	r3, [pc, #676]	; (800e534 <mbox1_execute+0x814>)
 800e28e:	68da      	ldr	r2, [r3, #12]
 800e290:	4ba8      	ldr	r3, [pc, #672]	; (800e534 <mbox1_execute+0x814>)
 800e292:	689b      	ldr	r3, [r3, #8]
 800e294:	429a      	cmp	r2, r3
 800e296:	bf14      	ite	ne
 800e298:	2300      	movne	r3, #0
 800e29a:	2301      	moveq	r3, #1
 800e29c:	b2db      	uxtb	r3, r3
 800e29e:	2020      	movs	r0, #32
 800e2a0:	4619      	mov	r1, r3
 800e2a2:	f7fd fe1d 	bl	800bee0 <_test_assert>
 800e2a6:	4603      	mov	r3, r0
 800e2a8:	2b00      	cmp	r3, #0
 800e2aa:	d000      	beq.n	800e2ae <mbox1_execute+0x58e>
 800e2ac:	e13f      	b.n	800e52e <mbox1_execute+0x80e>

  chSysLock();
 800e2ae:	f7ff fcef 	bl	800dc90 <chSysLock>
  msg1 = chMBPostAheadI(&mb1, 'E');
 800e2b2:	48a0      	ldr	r0, [pc, #640]	; (800e534 <mbox1_execute+0x814>)
 800e2b4:	2145      	movs	r1, #69	; 0x45
 800e2b6:	f7f4 fe33 	bl	8002f20 <chMBPostAheadI>
 800e2ba:	9002      	str	r0, [sp, #8]
  test_assert(33, msg1 == MSG_OK, "wrong wake-up message");
 800e2bc:	9b02      	ldr	r3, [sp, #8]
 800e2be:	2b00      	cmp	r3, #0
 800e2c0:	bf14      	ite	ne
 800e2c2:	2300      	movne	r3, #0
 800e2c4:	2301      	moveq	r3, #1
 800e2c6:	b2db      	uxtb	r3, r3
 800e2c8:	2021      	movs	r0, #33	; 0x21
 800e2ca:	4619      	mov	r1, r3
 800e2cc:	f7fd fe08 	bl	800bee0 <_test_assert>
 800e2d0:	4603      	mov	r3, r0
 800e2d2:	2b00      	cmp	r3, #0
 800e2d4:	d000      	beq.n	800e2d8 <mbox1_execute+0x5b8>
 800e2d6:	e12a      	b.n	800e52e <mbox1_execute+0x80e>
  msg1 = chMBPostAheadI(&mb1, 'D');
 800e2d8:	4896      	ldr	r0, [pc, #600]	; (800e534 <mbox1_execute+0x814>)
 800e2da:	2144      	movs	r1, #68	; 0x44
 800e2dc:	f7f4 fe20 	bl	8002f20 <chMBPostAheadI>
 800e2e0:	9002      	str	r0, [sp, #8]
  test_assert(34, msg1 == MSG_OK, "wrong wake-up message");
 800e2e2:	9b02      	ldr	r3, [sp, #8]
 800e2e4:	2b00      	cmp	r3, #0
 800e2e6:	bf14      	ite	ne
 800e2e8:	2300      	movne	r3, #0
 800e2ea:	2301      	moveq	r3, #1
 800e2ec:	b2db      	uxtb	r3, r3
 800e2ee:	2022      	movs	r0, #34	; 0x22
 800e2f0:	4619      	mov	r1, r3
 800e2f2:	f7fd fdf5 	bl	800bee0 <_test_assert>
 800e2f6:	4603      	mov	r3, r0
 800e2f8:	2b00      	cmp	r3, #0
 800e2fa:	d000      	beq.n	800e2fe <mbox1_execute+0x5de>
 800e2fc:	e117      	b.n	800e52e <mbox1_execute+0x80e>
  msg1 = chMBPostAheadI(&mb1, 'C');
 800e2fe:	488d      	ldr	r0, [pc, #564]	; (800e534 <mbox1_execute+0x814>)
 800e300:	2143      	movs	r1, #67	; 0x43
 800e302:	f7f4 fe0d 	bl	8002f20 <chMBPostAheadI>
 800e306:	9002      	str	r0, [sp, #8]
  test_assert(35, msg1 == MSG_OK, "wrong wake-up message");
 800e308:	9b02      	ldr	r3, [sp, #8]
 800e30a:	2b00      	cmp	r3, #0
 800e30c:	bf14      	ite	ne
 800e30e:	2300      	movne	r3, #0
 800e310:	2301      	moveq	r3, #1
 800e312:	b2db      	uxtb	r3, r3
 800e314:	2023      	movs	r0, #35	; 0x23
 800e316:	4619      	mov	r1, r3
 800e318:	f7fd fde2 	bl	800bee0 <_test_assert>
 800e31c:	4603      	mov	r3, r0
 800e31e:	2b00      	cmp	r3, #0
 800e320:	d000      	beq.n	800e324 <mbox1_execute+0x604>
 800e322:	e104      	b.n	800e52e <mbox1_execute+0x80e>
  msg1 = chMBPostAheadI(&mb1, 'B');
 800e324:	4883      	ldr	r0, [pc, #524]	; (800e534 <mbox1_execute+0x814>)
 800e326:	2142      	movs	r1, #66	; 0x42
 800e328:	f7f4 fdfa 	bl	8002f20 <chMBPostAheadI>
 800e32c:	9002      	str	r0, [sp, #8]
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
 800e32e:	9b02      	ldr	r3, [sp, #8]
 800e330:	2b00      	cmp	r3, #0
 800e332:	bf14      	ite	ne
 800e334:	2300      	movne	r3, #0
 800e336:	2301      	moveq	r3, #1
 800e338:	b2db      	uxtb	r3, r3
 800e33a:	2024      	movs	r0, #36	; 0x24
 800e33c:	4619      	mov	r1, r3
 800e33e:	f7fd fdcf 	bl	800bee0 <_test_assert>
 800e342:	4603      	mov	r3, r0
 800e344:	2b00      	cmp	r3, #0
 800e346:	d000      	beq.n	800e34a <mbox1_execute+0x62a>
 800e348:	e0f1      	b.n	800e52e <mbox1_execute+0x80e>
  msg1 = chMBPostAheadI(&mb1, 'A');
 800e34a:	487a      	ldr	r0, [pc, #488]	; (800e534 <mbox1_execute+0x814>)
 800e34c:	2141      	movs	r1, #65	; 0x41
 800e34e:	f7f4 fde7 	bl	8002f20 <chMBPostAheadI>
 800e352:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 800e354:	f7ff fca4 	bl	800dca0 <chSysUnlock>
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
 800e358:	9b02      	ldr	r3, [sp, #8]
 800e35a:	2b00      	cmp	r3, #0
 800e35c:	bf14      	ite	ne
 800e35e:	2300      	movne	r3, #0
 800e360:	2301      	moveq	r3, #1
 800e362:	b2db      	uxtb	r3, r3
 800e364:	2025      	movs	r0, #37	; 0x25
 800e366:	4619      	mov	r1, r3
 800e368:	f7fd fdba 	bl	800bee0 <_test_assert>
 800e36c:	4603      	mov	r3, r0
 800e36e:	2b00      	cmp	r3, #0
 800e370:	d000      	beq.n	800e374 <mbox1_execute+0x654>
 800e372:	e0dc      	b.n	800e52e <mbox1_execute+0x80e>
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800e374:	4b6f      	ldr	r3, [pc, #444]	; (800e534 <mbox1_execute+0x814>)
 800e376:	68da      	ldr	r2, [r3, #12]
 800e378:	4b6e      	ldr	r3, [pc, #440]	; (800e534 <mbox1_execute+0x814>)
 800e37a:	689b      	ldr	r3, [r3, #8]
 800e37c:	429a      	cmp	r2, r3
 800e37e:	bf14      	ite	ne
 800e380:	2300      	movne	r3, #0
 800e382:	2301      	moveq	r3, #1
 800e384:	b2db      	uxtb	r3, r3
 800e386:	2026      	movs	r0, #38	; 0x26
 800e388:	4619      	mov	r1, r3
 800e38a:	f7fd fda9 	bl	800bee0 <_test_assert>
 800e38e:	4603      	mov	r3, r0
 800e390:	2b00      	cmp	r3, #0
 800e392:	d000      	beq.n	800e396 <mbox1_execute+0x676>
 800e394:	e0cb      	b.n	800e52e <mbox1_execute+0x80e>
  for (i = 0; i < MB_SIZE; i++) {
 800e396:	2300      	movs	r3, #0
 800e398:	9303      	str	r3, [sp, #12]
 800e39a:	e01f      	b.n	800e3dc <mbox1_execute+0x6bc>
    chSysLock();
 800e39c:	f7ff fc78 	bl	800dc90 <chSysLock>
    msg1 = chMBFetchI(&mb1, &msg2);
 800e3a0:	ab01      	add	r3, sp, #4
 800e3a2:	4864      	ldr	r0, [pc, #400]	; (800e534 <mbox1_execute+0x814>)
 800e3a4:	4619      	mov	r1, r3
 800e3a6:	f7f4 fe3b 	bl	8003020 <chMBFetchI>
 800e3aa:	9002      	str	r0, [sp, #8]
    chSysUnlock();
 800e3ac:	f7ff fc78 	bl	800dca0 <chSysUnlock>
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
 800e3b0:	9b02      	ldr	r3, [sp, #8]
 800e3b2:	2b00      	cmp	r3, #0
 800e3b4:	bf14      	ite	ne
 800e3b6:	2300      	movne	r3, #0
 800e3b8:	2301      	moveq	r3, #1
 800e3ba:	b2db      	uxtb	r3, r3
 800e3bc:	2027      	movs	r0, #39	; 0x27
 800e3be:	4619      	mov	r1, r3
 800e3c0:	f7fd fd8e 	bl	800bee0 <_test_assert>
 800e3c4:	4603      	mov	r3, r0
 800e3c6:	2b00      	cmp	r3, #0
 800e3c8:	d000      	beq.n	800e3cc <mbox1_execute+0x6ac>
 800e3ca:	e0b0      	b.n	800e52e <mbox1_execute+0x80e>
    test_emit_token(msg2);
 800e3cc:	9b01      	ldr	r3, [sp, #4]
 800e3ce:	b2db      	uxtb	r3, r3
 800e3d0:	4618      	mov	r0, r3
 800e3d2:	f7fd fd55 	bl	800be80 <test_emit_token>
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
  msg1 = chMBPostAheadI(&mb1, 'A');
  chSysUnlock();
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
 800e3d6:	9b03      	ldr	r3, [sp, #12]
 800e3d8:	3301      	adds	r3, #1
 800e3da:	9303      	str	r3, [sp, #12]
 800e3dc:	9b03      	ldr	r3, [sp, #12]
 800e3de:	2b04      	cmp	r3, #4
 800e3e0:	d9dc      	bls.n	800e39c <mbox1_execute+0x67c>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(40, "ABCDE");
 800e3e2:	2028      	movs	r0, #40	; 0x28
 800e3e4:	4954      	ldr	r1, [pc, #336]	; (800e538 <mbox1_execute+0x818>)
 800e3e6:	f7fd fd93 	bl	800bf10 <_test_assert_sequence>
 800e3ea:	4603      	mov	r3, r0
 800e3ec:	2b00      	cmp	r3, #0
 800e3ee:	d000      	beq.n	800e3f2 <mbox1_execute+0x6d2>
 800e3f0:	e09d      	b.n	800e52e <mbox1_execute+0x80e>
  test_assert_lock(41, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800e3f2:	f7ff fc4d 	bl	800dc90 <chSysLock>
 800e3f6:	484f      	ldr	r0, [pc, #316]	; (800e534 <mbox1_execute+0x814>)
 800e3f8:	f7ff fc62 	bl	800dcc0 <chMBGetFreeCountI>
 800e3fc:	4603      	mov	r3, r0
 800e3fe:	2b05      	cmp	r3, #5
 800e400:	bf14      	ite	ne
 800e402:	2300      	movne	r3, #0
 800e404:	2301      	moveq	r3, #1
 800e406:	b2db      	uxtb	r3, r3
 800e408:	2029      	movs	r0, #41	; 0x29
 800e40a:	4619      	mov	r1, r3
 800e40c:	f7fd fd68 	bl	800bee0 <_test_assert>
 800e410:	4603      	mov	r3, r0
 800e412:	2b00      	cmp	r3, #0
 800e414:	d002      	beq.n	800e41c <mbox1_execute+0x6fc>
 800e416:	f7ff fc43 	bl	800dca0 <chSysUnlock>
 800e41a:	e088      	b.n	800e52e <mbox1_execute+0x80e>
 800e41c:	f7ff fc40 	bl	800dca0 <chSysUnlock>
  test_assert_lock(42, chMBGetUsedCountI(&mb1) == 0, "still full");
 800e420:	f7ff fc36 	bl	800dc90 <chSysLock>
 800e424:	4843      	ldr	r0, [pc, #268]	; (800e534 <mbox1_execute+0x814>)
 800e426:	f7ff fc5b 	bl	800dce0 <chMBGetUsedCountI>
 800e42a:	4603      	mov	r3, r0
 800e42c:	2b00      	cmp	r3, #0
 800e42e:	bf14      	ite	ne
 800e430:	2300      	movne	r3, #0
 800e432:	2301      	moveq	r3, #1
 800e434:	b2db      	uxtb	r3, r3
 800e436:	202a      	movs	r0, #42	; 0x2a
 800e438:	4619      	mov	r1, r3
 800e43a:	f7fd fd51 	bl	800bee0 <_test_assert>
 800e43e:	4603      	mov	r3, r0
 800e440:	2b00      	cmp	r3, #0
 800e442:	d002      	beq.n	800e44a <mbox1_execute+0x72a>
 800e444:	f7ff fc2c 	bl	800dca0 <chSysUnlock>
 800e448:	e071      	b.n	800e52e <mbox1_execute+0x80e>
 800e44a:	f7ff fc29 	bl	800dca0 <chSysUnlock>
  test_assert(43, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800e44e:	4b39      	ldr	r3, [pc, #228]	; (800e534 <mbox1_execute+0x814>)
 800e450:	68da      	ldr	r2, [r3, #12]
 800e452:	4b38      	ldr	r3, [pc, #224]	; (800e534 <mbox1_execute+0x814>)
 800e454:	689b      	ldr	r3, [r3, #8]
 800e456:	429a      	cmp	r2, r3
 800e458:	bf14      	ite	ne
 800e45a:	2300      	movne	r3, #0
 800e45c:	2301      	moveq	r3, #1
 800e45e:	b2db      	uxtb	r3, r3
 800e460:	202b      	movs	r0, #43	; 0x2b
 800e462:	4619      	mov	r1, r3
 800e464:	f7fd fd3c 	bl	800bee0 <_test_assert>
 800e468:	4603      	mov	r3, r0
 800e46a:	2b00      	cmp	r3, #0
 800e46c:	d000      	beq.n	800e470 <mbox1_execute+0x750>
 800e46e:	e05e      	b.n	800e52e <mbox1_execute+0x80e>

  /*
   * Testing reset.
   */
  chMBReset(&mb1);
 800e470:	4830      	ldr	r0, [pc, #192]	; (800e534 <mbox1_execute+0x814>)
 800e472:	f7f4 fc5d 	bl	8002d30 <chMBReset>

  /*
   * Re-testing final conditions.
   */
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800e476:	f7ff fc0b 	bl	800dc90 <chSysLock>
 800e47a:	482e      	ldr	r0, [pc, #184]	; (800e534 <mbox1_execute+0x814>)
 800e47c:	f7ff fc20 	bl	800dcc0 <chMBGetFreeCountI>
 800e480:	4603      	mov	r3, r0
 800e482:	2b05      	cmp	r3, #5
 800e484:	bf14      	ite	ne
 800e486:	2300      	movne	r3, #0
 800e488:	2301      	moveq	r3, #1
 800e48a:	b2db      	uxtb	r3, r3
 800e48c:	202c      	movs	r0, #44	; 0x2c
 800e48e:	4619      	mov	r1, r3
 800e490:	f7fd fd26 	bl	800bee0 <_test_assert>
 800e494:	4603      	mov	r3, r0
 800e496:	2b00      	cmp	r3, #0
 800e498:	d002      	beq.n	800e4a0 <mbox1_execute+0x780>
 800e49a:	f7ff fc01 	bl	800dca0 <chSysUnlock>
 800e49e:	e046      	b.n	800e52e <mbox1_execute+0x80e>
 800e4a0:	f7ff fbfe 	bl	800dca0 <chSysUnlock>
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
 800e4a4:	f7ff fbf4 	bl	800dc90 <chSysLock>
 800e4a8:	4822      	ldr	r0, [pc, #136]	; (800e534 <mbox1_execute+0x814>)
 800e4aa:	f7ff fc19 	bl	800dce0 <chMBGetUsedCountI>
 800e4ae:	4603      	mov	r3, r0
 800e4b0:	2b00      	cmp	r3, #0
 800e4b2:	bf14      	ite	ne
 800e4b4:	2300      	movne	r3, #0
 800e4b6:	2301      	moveq	r3, #1
 800e4b8:	b2db      	uxtb	r3, r3
 800e4ba:	202d      	movs	r0, #45	; 0x2d
 800e4bc:	4619      	mov	r1, r3
 800e4be:	f7fd fd0f 	bl	800bee0 <_test_assert>
 800e4c2:	4603      	mov	r3, r0
 800e4c4:	2b00      	cmp	r3, #0
 800e4c6:	d002      	beq.n	800e4ce <mbox1_execute+0x7ae>
 800e4c8:	f7ff fbea 	bl	800dca0 <chSysUnlock>
 800e4cc:	e02f      	b.n	800e52e <mbox1_execute+0x80e>
 800e4ce:	f7ff fbe7 	bl	800dca0 <chSysUnlock>
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 800e4d2:	f7ff fbdd 	bl	800dc90 <chSysLock>
 800e4d6:	4b17      	ldr	r3, [pc, #92]	; (800e534 <mbox1_execute+0x814>)
 800e4d8:	681a      	ldr	r2, [r3, #0]
 800e4da:	4b16      	ldr	r3, [pc, #88]	; (800e534 <mbox1_execute+0x814>)
 800e4dc:	689b      	ldr	r3, [r3, #8]
 800e4de:	429a      	cmp	r2, r3
 800e4e0:	bf14      	ite	ne
 800e4e2:	2300      	movne	r3, #0
 800e4e4:	2301      	moveq	r3, #1
 800e4e6:	b2db      	uxtb	r3, r3
 800e4e8:	202e      	movs	r0, #46	; 0x2e
 800e4ea:	4619      	mov	r1, r3
 800e4ec:	f7fd fcf8 	bl	800bee0 <_test_assert>
 800e4f0:	4603      	mov	r3, r0
 800e4f2:	2b00      	cmp	r3, #0
 800e4f4:	d002      	beq.n	800e4fc <mbox1_execute+0x7dc>
 800e4f6:	f7ff fbd3 	bl	800dca0 <chSysUnlock>
 800e4fa:	e018      	b.n	800e52e <mbox1_execute+0x80e>
 800e4fc:	f7ff fbd0 	bl	800dca0 <chSysUnlock>
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 800e500:	f7ff fbc6 	bl	800dc90 <chSysLock>
 800e504:	4b0b      	ldr	r3, [pc, #44]	; (800e534 <mbox1_execute+0x814>)
 800e506:	681a      	ldr	r2, [r3, #0]
 800e508:	4b0a      	ldr	r3, [pc, #40]	; (800e534 <mbox1_execute+0x814>)
 800e50a:	68db      	ldr	r3, [r3, #12]
 800e50c:	429a      	cmp	r2, r3
 800e50e:	bf14      	ite	ne
 800e510:	2300      	movne	r3, #0
 800e512:	2301      	moveq	r3, #1
 800e514:	b2db      	uxtb	r3, r3
 800e516:	202f      	movs	r0, #47	; 0x2f
 800e518:	4619      	mov	r1, r3
 800e51a:	f7fd fce1 	bl	800bee0 <_test_assert>
 800e51e:	4603      	mov	r3, r0
 800e520:	2b00      	cmp	r3, #0
 800e522:	d002      	beq.n	800e52a <mbox1_execute+0x80a>
 800e524:	f7ff fbbc 	bl	800dca0 <chSysUnlock>
 800e528:	e001      	b.n	800e52e <mbox1_execute+0x80e>
 800e52a:	f7ff fbb9 	bl	800dca0 <chSysUnlock>
}
 800e52e:	b005      	add	sp, #20
 800e530:	f85d fb04 	ldr.w	pc, [sp], #4
 800e534:	2000086c 	.word	0x2000086c
 800e538:	08018050 	.word	0x08018050
 800e53c:	f3af 8000 	nop.w

0800e540 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800e540:	b082      	sub	sp, #8
 800e542:	2320      	movs	r3, #32
 800e544:	9301      	str	r3, [sp, #4]
 800e546:	9b01      	ldr	r3, [sp, #4]
 800e548:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800e54c:	b002      	add	sp, #8
 800e54e:	4770      	bx	lr

0800e550 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800e550:	b082      	sub	sp, #8
 800e552:	2300      	movs	r3, #0
 800e554:	9301      	str	r3, [sp, #4]
 800e556:	9b01      	ldr	r3, [sp, #4]
 800e558:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800e55c:	b002      	add	sp, #8
 800e55e:	4770      	bx	lr

0800e560 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800e560:	b508      	push	{r3, lr}

  port_lock();
 800e562:	f7ff ffed 	bl	800e540 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800e566:	bd08      	pop	{r3, pc}
 800e568:	f3af 8000 	nop.w
 800e56c:	f3af 8000 	nop.w

0800e570 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800e570:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800e572:	f7ff ffed 	bl	800e550 <port_unlock>
}
 800e576:	bd08      	pop	{r3, pc}
 800e578:	f3af 8000 	nop.w
 800e57c:	f3af 8000 	nop.w

0800e580 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 800e580:	4b01      	ldr	r3, [pc, #4]	; (800e588 <chVTGetSystemTimeX+0x8>)
 800e582:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800e584:	4618      	mov	r0, r3
 800e586:	4770      	bx	lr
 800e588:	200016e0 	.word	0x200016e0
 800e58c:	f3af 8000 	nop.w

0800e590 <chVTGetSystemTime>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 800e590:	b500      	push	{lr}
 800e592:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 800e594:	f7ff ffe4 	bl	800e560 <chSysLock>
  systime = chVTGetSystemTimeX();
 800e598:	f7ff fff2 	bl	800e580 <chVTGetSystemTimeX>
 800e59c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 800e59e:	f7ff ffe7 	bl	800e570 <chSysUnlock>

  return systime;
 800e5a2:	9b01      	ldr	r3, [sp, #4]
}
 800e5a4:	4618      	mov	r0, r3
 800e5a6:	b003      	add	sp, #12
 800e5a8:	f85d fb04 	ldr.w	pc, [sp], #4
 800e5ac:	f3af 8000 	nop.w

0800e5b0 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800e5b0:	4b01      	ldr	r3, [pc, #4]	; (800e5b8 <chThdGetSelfX+0x8>)
 800e5b2:	699b      	ldr	r3, [r3, #24]
}
 800e5b4:	4618      	mov	r0, r3
 800e5b6:	4770      	bx	lr
 800e5b8:	200016e0 	.word	0x200016e0
 800e5bc:	f3af 8000 	nop.w

0800e5c0 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800e5c0:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800e5c2:	f7ff fff5 	bl	800e5b0 <chThdGetSelfX>
 800e5c6:	4603      	mov	r3, r0
 800e5c8:	689b      	ldr	r3, [r3, #8]
}
 800e5ca:	4618      	mov	r0, r3
 800e5cc:	bd08      	pop	{r3, pc}
 800e5ce:	bf00      	nop

0800e5d0 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 800e5d0:	b082      	sub	sp, #8
 800e5d2:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 800e5d4:	9b01      	ldr	r3, [sp, #4]
 800e5d6:	9a01      	ldr	r2, [sp, #4]
 800e5d8:	601a      	str	r2, [r3, #0]
}
 800e5da:	b002      	add	sp, #8
 800e5dc:	4770      	bx	lr
 800e5de:	bf00      	nop

0800e5e0 <chEvtRegisterMask>:
 *
 * @api
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventmask_t events) {
 800e5e0:	b500      	push	{lr}
 800e5e2:	b085      	sub	sp, #20
 800e5e4:	9003      	str	r0, [sp, #12]
 800e5e6:	9102      	str	r1, [sp, #8]
 800e5e8:	9201      	str	r2, [sp, #4]

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 800e5ea:	9803      	ldr	r0, [sp, #12]
 800e5ec:	9902      	ldr	r1, [sp, #8]
 800e5ee:	9a01      	ldr	r2, [sp, #4]
 800e5f0:	f04f 33ff 	mov.w	r3, #4294967295
 800e5f4:	f7f3 ffbc 	bl	8002570 <chEvtRegisterMaskWithFlags>
}
 800e5f8:	b005      	add	sp, #20
 800e5fa:	f85d fb04 	ldr.w	pc, [sp], #4
 800e5fe:	bf00      	nop

0800e600 <chEvtIsListeningI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @return              The event source status.
 *
 * @iclass
 */
static inline bool chEvtIsListeningI(event_source_t *esp) {
 800e600:	b082      	sub	sp, #8
 800e602:	9001      	str	r0, [sp, #4]

  return (bool)(esp != (event_source_t *)esp->es_next);
 800e604:	9b01      	ldr	r3, [sp, #4]
 800e606:	681a      	ldr	r2, [r3, #0]
 800e608:	9b01      	ldr	r3, [sp, #4]
 800e60a:	429a      	cmp	r2, r3
 800e60c:	bf0c      	ite	eq
 800e60e:	2300      	moveq	r3, #0
 800e610:	2301      	movne	r3, #1
 800e612:	b2db      	uxtb	r3, r3
}
 800e614:	4618      	mov	r0, r3
 800e616:	b002      	add	sp, #8
 800e618:	4770      	bx	lr
 800e61a:	bf00      	nop
 800e61c:	f3af 8000 	nop.w

0800e620 <chEvtBroadcast>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @api
 */
static inline void chEvtBroadcast(event_source_t *esp) {
 800e620:	b500      	push	{lr}
 800e622:	b083      	sub	sp, #12
 800e624:	9001      	str	r0, [sp, #4]

  chEvtBroadcastFlags(esp, (eventflags_t)0);
 800e626:	9801      	ldr	r0, [sp, #4]
 800e628:	2100      	movs	r1, #0
 800e62a:	f7f4 f8b9 	bl	80027a0 <chEvtBroadcastFlags>
}
 800e62e:	b003      	add	sp, #12
 800e630:	f85d fb04 	ldr.w	pc, [sp], #4
 800e634:	f3af 8000 	nop.w
 800e638:	f3af 8000 	nop.w
 800e63c:	f3af 8000 	nop.w

0800e640 <evt1_setup>:
 * the test expects no more listeners.<br>
 * In the second part the test dispatches three event flags and verifies that
 * the associated event handlers are invoked in LSb-first order.
 */

static void evt1_setup(void) {
 800e640:	b508      	push	{r3, lr}

  chEvtGetAndClearEvents(ALL_EVENTS);
 800e642:	f04f 30ff 	mov.w	r0, #4294967295
 800e646:	f7f3 ffdb 	bl	8002600 <chEvtGetAndClearEvents>
}
 800e64a:	bd08      	pop	{r3, pc}
 800e64c:	f3af 8000 	nop.w

0800e650 <h1>:

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
 800e650:	b500      	push	{lr}
 800e652:	b083      	sub	sp, #12
 800e654:	9001      	str	r0, [sp, #4]
 800e656:	2041      	movs	r0, #65	; 0x41
 800e658:	f7fd fc12 	bl	800be80 <test_emit_token>
 800e65c:	b003      	add	sp, #12
 800e65e:	f85d fb04 	ldr.w	pc, [sp], #4
 800e662:	bf00      	nop
 800e664:	f3af 8000 	nop.w
 800e668:	f3af 8000 	nop.w
 800e66c:	f3af 8000 	nop.w

0800e670 <h2>:
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
 800e670:	b500      	push	{lr}
 800e672:	b083      	sub	sp, #12
 800e674:	9001      	str	r0, [sp, #4]
 800e676:	2042      	movs	r0, #66	; 0x42
 800e678:	f7fd fc02 	bl	800be80 <test_emit_token>
 800e67c:	b003      	add	sp, #12
 800e67e:	f85d fb04 	ldr.w	pc, [sp], #4
 800e682:	bf00      	nop
 800e684:	f3af 8000 	nop.w
 800e688:	f3af 8000 	nop.w
 800e68c:	f3af 8000 	nop.w

0800e690 <h3>:
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
 800e690:	b500      	push	{lr}
 800e692:	b083      	sub	sp, #12
 800e694:	9001      	str	r0, [sp, #4]
 800e696:	2043      	movs	r0, #67	; 0x43
 800e698:	f7fd fbf2 	bl	800be80 <test_emit_token>
 800e69c:	b003      	add	sp, #12
 800e69e:	f85d fb04 	ldr.w	pc, [sp], #4
 800e6a2:	bf00      	nop
 800e6a4:	f3af 8000 	nop.w
 800e6a8:	f3af 8000 	nop.w
 800e6ac:	f3af 8000 	nop.w

0800e6b0 <evt1_execute>:
static ROMCONST evhandler_t evhndl[] = {h1, h2, h3};

static void evt1_execute(void) {
 800e6b0:	b500      	push	{lr}
 800e6b2:	b08b      	sub	sp, #44	; 0x2c
  event_listener_t el1, el2;

  /*
   * Testing chEvtRegisterMask() and chEvtUnregister().
   */
  chEvtObjectInit(&es1);
 800e6b4:	482b      	ldr	r0, [pc, #172]	; (800e764 <evt1_execute+0xb4>)
 800e6b6:	f7ff ff8b 	bl	800e5d0 <chEvtObjectInit>
  chEvtRegisterMask(&es1, &el1, 1);
 800e6ba:	ab05      	add	r3, sp, #20
 800e6bc:	4829      	ldr	r0, [pc, #164]	; (800e764 <evt1_execute+0xb4>)
 800e6be:	4619      	mov	r1, r3
 800e6c0:	2201      	movs	r2, #1
 800e6c2:	f7ff ff8d 	bl	800e5e0 <chEvtRegisterMask>
  chEvtRegisterMask(&es1, &el2, 2);
 800e6c6:	466b      	mov	r3, sp
 800e6c8:	4826      	ldr	r0, [pc, #152]	; (800e764 <evt1_execute+0xb4>)
 800e6ca:	4619      	mov	r1, r3
 800e6cc:	2202      	movs	r2, #2
 800e6ce:	f7ff ff87 	bl	800e5e0 <chEvtRegisterMask>
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
 800e6d2:	4824      	ldr	r0, [pc, #144]	; (800e764 <evt1_execute+0xb4>)
 800e6d4:	f7ff ff94 	bl	800e600 <chEvtIsListeningI>
 800e6d8:	4603      	mov	r3, r0
 800e6da:	2001      	movs	r0, #1
 800e6dc:	4619      	mov	r1, r3
 800e6de:	f7fd fbff 	bl	800bee0 <_test_assert>
 800e6e2:	4603      	mov	r3, r0
 800e6e4:	2b00      	cmp	r3, #0
 800e6e6:	d000      	beq.n	800e6ea <evt1_execute+0x3a>
 800e6e8:	e038      	b.n	800e75c <evt1_execute+0xac>
  chEvtUnregister(&es1, &el1);
 800e6ea:	ab05      	add	r3, sp, #20
 800e6ec:	481d      	ldr	r0, [pc, #116]	; (800e764 <evt1_execute+0xb4>)
 800e6ee:	4619      	mov	r1, r3
 800e6f0:	f7f3 ff66 	bl	80025c0 <chEvtUnregister>
  test_assert(2, chEvtIsListeningI(&es1), "no listener");
 800e6f4:	481b      	ldr	r0, [pc, #108]	; (800e764 <evt1_execute+0xb4>)
 800e6f6:	f7ff ff83 	bl	800e600 <chEvtIsListeningI>
 800e6fa:	4603      	mov	r3, r0
 800e6fc:	2002      	movs	r0, #2
 800e6fe:	4619      	mov	r1, r3
 800e700:	f7fd fbee 	bl	800bee0 <_test_assert>
 800e704:	4603      	mov	r3, r0
 800e706:	2b00      	cmp	r3, #0
 800e708:	d000      	beq.n	800e70c <evt1_execute+0x5c>
 800e70a:	e027      	b.n	800e75c <evt1_execute+0xac>
  chEvtUnregister(&es1, &el2);
 800e70c:	466b      	mov	r3, sp
 800e70e:	4815      	ldr	r0, [pc, #84]	; (800e764 <evt1_execute+0xb4>)
 800e710:	4619      	mov	r1, r3
 800e712:	f7f3 ff55 	bl	80025c0 <chEvtUnregister>
  test_assert(3, !chEvtIsListeningI(&es1), "stuck listener");
 800e716:	4813      	ldr	r0, [pc, #76]	; (800e764 <evt1_execute+0xb4>)
 800e718:	f7ff ff72 	bl	800e600 <chEvtIsListeningI>
 800e71c:	4603      	mov	r3, r0
 800e71e:	2b00      	cmp	r3, #0
 800e720:	bf0c      	ite	eq
 800e722:	2300      	moveq	r3, #0
 800e724:	2301      	movne	r3, #1
 800e726:	b2db      	uxtb	r3, r3
 800e728:	f083 0301 	eor.w	r3, r3, #1
 800e72c:	b2db      	uxtb	r3, r3
 800e72e:	f003 0301 	and.w	r3, r3, #1
 800e732:	b2db      	uxtb	r3, r3
 800e734:	2003      	movs	r0, #3
 800e736:	4619      	mov	r1, r3
 800e738:	f7fd fbd2 	bl	800bee0 <_test_assert>
 800e73c:	4603      	mov	r3, r0
 800e73e:	2b00      	cmp	r3, #0
 800e740:	d000      	beq.n	800e744 <evt1_execute+0x94>
 800e742:	e00b      	b.n	800e75c <evt1_execute+0xac>

  /*
   * Testing chEvtDispatch().
   */
  chEvtDispatch(evhndl, 7);
 800e744:	4808      	ldr	r0, [pc, #32]	; (800e768 <evt1_execute+0xb8>)
 800e746:	2107      	movs	r1, #7
 800e748:	f7f4 f852 	bl	80027f0 <chEvtDispatch>
  test_assert_sequence(4, "ABC");
 800e74c:	2004      	movs	r0, #4
 800e74e:	4907      	ldr	r1, [pc, #28]	; (800e76c <evt1_execute+0xbc>)
 800e750:	f7fd fbde 	bl	800bf10 <_test_assert_sequence>
 800e754:	4603      	mov	r3, r0
 800e756:	2b00      	cmp	r3, #0
 800e758:	d000      	beq.n	800e75c <evt1_execute+0xac>
 800e75a:	bf00      	nop
}
 800e75c:	b00b      	add	sp, #44	; 0x2c
 800e75e:	f85d fb04 	ldr.w	pc, [sp], #4
 800e762:	bf00      	nop
 800e764:	20000894 	.word	0x20000894
 800e768:	08018090 	.word	0x08018090
 800e76c:	0801809c 	.word	0x0801809c

0800e770 <evt2_setup>:
 * .
 * After each test phase the test verifies that the events have been served at
 * the expected time and that there are no stuck event flags.
 */

static void evt2_setup(void) {
 800e770:	b508      	push	{r3, lr}

  chEvtGetAndClearEvents(ALL_EVENTS);
 800e772:	f04f 30ff 	mov.w	r0, #4294967295
 800e776:	f7f3 ff43 	bl	8002600 <chEvtGetAndClearEvents>
}
 800e77a:	bd08      	pop	{r3, pc}
 800e77c:	f3af 8000 	nop.w

0800e780 <thread1>:

static THD_FUNCTION(thread1, p) {
 800e780:	b500      	push	{lr}
 800e782:	b083      	sub	sp, #12
 800e784:	9001      	str	r0, [sp, #4]

  chThdSleepMilliseconds(50);
 800e786:	2032      	movs	r0, #50	; 0x32
 800e788:	f7f2 fda2 	bl	80012d0 <chThdSleep>
  chEvtSignal((thread_t *)p, 1);
 800e78c:	9801      	ldr	r0, [sp, #4]
 800e78e:	2101      	movs	r1, #1
 800e790:	f7f3 ffbe 	bl	8002710 <chEvtSignal>
}
 800e794:	b003      	add	sp, #12
 800e796:	f85d fb04 	ldr.w	pc, [sp], #4
 800e79a:	bf00      	nop
 800e79c:	f3af 8000 	nop.w

0800e7a0 <thread2>:

static THD_FUNCTION(thread2, p) {
 800e7a0:	b500      	push	{lr}
 800e7a2:	b083      	sub	sp, #12
 800e7a4:	9001      	str	r0, [sp, #4]

  (void)p;
  chEvtBroadcast(&es1);
 800e7a6:	4806      	ldr	r0, [pc, #24]	; (800e7c0 <thread2+0x20>)
 800e7a8:	f7ff ff3a 	bl	800e620 <chEvtBroadcast>
  chThdSleepMilliseconds(50);
 800e7ac:	2032      	movs	r0, #50	; 0x32
 800e7ae:	f7f2 fd8f 	bl	80012d0 <chThdSleep>
  chEvtBroadcast(&es2);
 800e7b2:	4804      	ldr	r0, [pc, #16]	; (800e7c4 <thread2+0x24>)
 800e7b4:	f7ff ff34 	bl	800e620 <chEvtBroadcast>
}
 800e7b8:	b003      	add	sp, #12
 800e7ba:	f85d fb04 	ldr.w	pc, [sp], #4
 800e7be:	bf00      	nop
 800e7c0:	20000894 	.word	0x20000894
 800e7c4:	20000898 	.word	0x20000898
 800e7c8:	f3af 8000 	nop.w
 800e7cc:	f3af 8000 	nop.w

0800e7d0 <evt2_execute>:

static void evt2_execute(void) {
 800e7d0:	b530      	push	{r4, r5, lr}
 800e7d2:	b08f      	sub	sp, #60	; 0x3c
  systime_t target_time;

  /*
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(7);
 800e7d4:	2007      	movs	r0, #7
 800e7d6:	f7f3 ff33 	bl	8002640 <chEvtAddEvents>
  m = chEvtWaitOne(ALL_EVENTS);
 800e7da:	f04f 30ff 	mov.w	r0, #4294967295
 800e7de:	f7f4 f82f 	bl	8002840 <chEvtWaitOne>
 800e7e2:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(1, m == 1, "single event error");
 800e7e4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e7e6:	2b01      	cmp	r3, #1
 800e7e8:	bf14      	ite	ne
 800e7ea:	2300      	movne	r3, #0
 800e7ec:	2301      	moveq	r3, #1
 800e7ee:	b2db      	uxtb	r3, r3
 800e7f0:	2001      	movs	r0, #1
 800e7f2:	4619      	mov	r1, r3
 800e7f4:	f7fd fb74 	bl	800bee0 <_test_assert>
 800e7f8:	4603      	mov	r3, r0
 800e7fa:	2b00      	cmp	r3, #0
 800e7fc:	d000      	beq.n	800e800 <evt2_execute+0x30>
 800e7fe:	e184      	b.n	800eb0a <evt2_execute+0x33a>
  m = chEvtWaitOne(ALL_EVENTS);
 800e800:	f04f 30ff 	mov.w	r0, #4294967295
 800e804:	f7f4 f81c 	bl	8002840 <chEvtWaitOne>
 800e808:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(2, m == 2, "single event error");
 800e80a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e80c:	2b02      	cmp	r3, #2
 800e80e:	bf14      	ite	ne
 800e810:	2300      	movne	r3, #0
 800e812:	2301      	moveq	r3, #1
 800e814:	b2db      	uxtb	r3, r3
 800e816:	2002      	movs	r0, #2
 800e818:	4619      	mov	r1, r3
 800e81a:	f7fd fb61 	bl	800bee0 <_test_assert>
 800e81e:	4603      	mov	r3, r0
 800e820:	2b00      	cmp	r3, #0
 800e822:	d000      	beq.n	800e826 <evt2_execute+0x56>
 800e824:	e171      	b.n	800eb0a <evt2_execute+0x33a>
  m = chEvtWaitOne(ALL_EVENTS);
 800e826:	f04f 30ff 	mov.w	r0, #4294967295
 800e82a:	f7f4 f809 	bl	8002840 <chEvtWaitOne>
 800e82e:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(3, m == 4, "single event error");
 800e830:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e832:	2b04      	cmp	r3, #4
 800e834:	bf14      	ite	ne
 800e836:	2300      	movne	r3, #0
 800e838:	2301      	moveq	r3, #1
 800e83a:	b2db      	uxtb	r3, r3
 800e83c:	2003      	movs	r0, #3
 800e83e:	4619      	mov	r1, r3
 800e840:	f7fd fb4e 	bl	800bee0 <_test_assert>
 800e844:	4603      	mov	r3, r0
 800e846:	2b00      	cmp	r3, #0
 800e848:	d000      	beq.n	800e84c <evt2_execute+0x7c>
 800e84a:	e15e      	b.n	800eb0a <evt2_execute+0x33a>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800e84c:	f04f 30ff 	mov.w	r0, #4294967295
 800e850:	f7f3 fed6 	bl	8002600 <chEvtGetAndClearEvents>
 800e854:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(4, m == 0, "stuck event");
 800e856:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e858:	2b00      	cmp	r3, #0
 800e85a:	bf14      	ite	ne
 800e85c:	2300      	movne	r3, #0
 800e85e:	2301      	moveq	r3, #1
 800e860:	b2db      	uxtb	r3, r3
 800e862:	2004      	movs	r0, #4
 800e864:	4619      	mov	r1, r3
 800e866:	f7fd fb3b 	bl	800bee0 <_test_assert>
 800e86a:	4603      	mov	r3, r0
 800e86c:	2b00      	cmp	r3, #0
 800e86e:	d000      	beq.n	800e872 <evt2_execute+0xa2>
 800e870:	e14b      	b.n	800eb0a <evt2_execute+0x33a>

  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
 800e872:	f7fd fbdd 	bl	800c030 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(50);
 800e876:	f7ff fe8b 	bl	800e590 <chVTGetSystemTime>
 800e87a:	4603      	mov	r3, r0
 800e87c:	3332      	adds	r3, #50	; 0x32
 800e87e:	930c      	str	r3, [sp, #48]	; 0x30
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800e880:	4ba3      	ldr	r3, [pc, #652]	; (800eb10 <evt2_execute+0x340>)
 800e882:	681d      	ldr	r5, [r3, #0]
 800e884:	f7ff fe9c 	bl	800e5c0 <chThdGetPriorityX>
 800e888:	4603      	mov	r3, r0
 800e88a:	1e5c      	subs	r4, r3, #1
                                 thread1, chThdGetSelfX());
 800e88c:	f7ff fe90 	bl	800e5b0 <chThdGetSelfX>
 800e890:	4603      	mov	r3, r0
  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800e892:	9300      	str	r3, [sp, #0]
 800e894:	4628      	mov	r0, r5
 800e896:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800e89a:	4622      	mov	r2, r4
 800e89c:	4b9d      	ldr	r3, [pc, #628]	; (800eb14 <evt2_execute+0x344>)
 800e89e:	f7f2 fc9f 	bl	80011e0 <chThdCreateStatic>
 800e8a2:	4602      	mov	r2, r0
 800e8a4:	4b9c      	ldr	r3, [pc, #624]	; (800eb18 <evt2_execute+0x348>)
 800e8a6:	601a      	str	r2, [r3, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitOne(ALL_EVENTS);
 800e8a8:	f04f 30ff 	mov.w	r0, #4294967295
 800e8ac:	f7f3 ffc8 	bl	8002840 <chEvtWaitOne>
 800e8b0:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert_time_window(5, target_time, target_time + ALLOWED_DELAY);
 800e8b2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e8b4:	3305      	adds	r3, #5
 800e8b6:	2005      	movs	r0, #5
 800e8b8:	990c      	ldr	r1, [sp, #48]	; 0x30
 800e8ba:	461a      	mov	r2, r3
 800e8bc:	f7fd fb58 	bl	800bf70 <_test_assert_time_window>
 800e8c0:	4603      	mov	r3, r0
 800e8c2:	2b00      	cmp	r3, #0
 800e8c4:	d000      	beq.n	800e8c8 <evt2_execute+0xf8>
 800e8c6:	e120      	b.n	800eb0a <evt2_execute+0x33a>
  test_assert(6, m == 1, "single event error");
 800e8c8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e8ca:	2b01      	cmp	r3, #1
 800e8cc:	bf14      	ite	ne
 800e8ce:	2300      	movne	r3, #0
 800e8d0:	2301      	moveq	r3, #1
 800e8d2:	b2db      	uxtb	r3, r3
 800e8d4:	2006      	movs	r0, #6
 800e8d6:	4619      	mov	r1, r3
 800e8d8:	f7fd fb02 	bl	800bee0 <_test_assert>
 800e8dc:	4603      	mov	r3, r0
 800e8de:	2b00      	cmp	r3, #0
 800e8e0:	d000      	beq.n	800e8e4 <evt2_execute+0x114>
 800e8e2:	e112      	b.n	800eb0a <evt2_execute+0x33a>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800e8e4:	f04f 30ff 	mov.w	r0, #4294967295
 800e8e8:	f7f3 fe8a 	bl	8002600 <chEvtGetAndClearEvents>
 800e8ec:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(7, m == 0, "stuck event");
 800e8ee:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e8f0:	2b00      	cmp	r3, #0
 800e8f2:	bf14      	ite	ne
 800e8f4:	2300      	movne	r3, #0
 800e8f6:	2301      	moveq	r3, #1
 800e8f8:	b2db      	uxtb	r3, r3
 800e8fa:	2007      	movs	r0, #7
 800e8fc:	4619      	mov	r1, r3
 800e8fe:	f7fd faef 	bl	800bee0 <_test_assert>
 800e902:	4603      	mov	r3, r0
 800e904:	2b00      	cmp	r3, #0
 800e906:	d000      	beq.n	800e90a <evt2_execute+0x13a>
 800e908:	e0ff      	b.n	800eb0a <evt2_execute+0x33a>
  test_wait_threads();
 800e90a:	f7fd fb69 	bl	800bfe0 <test_wait_threads>

  /*
   * Test on chEvtWaitAny() without wait.
   */
  chEvtAddEvents(5);
 800e90e:	2005      	movs	r0, #5
 800e910:	f7f3 fe96 	bl	8002640 <chEvtAddEvents>
  m = chEvtWaitAny(ALL_EVENTS);
 800e914:	f04f 30ff 	mov.w	r0, #4294967295
 800e918:	f7f3 ffc2 	bl	80028a0 <chEvtWaitAny>
 800e91c:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(8, m == 5, "unexpected pending bit");
 800e91e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e920:	2b05      	cmp	r3, #5
 800e922:	bf14      	ite	ne
 800e924:	2300      	movne	r3, #0
 800e926:	2301      	moveq	r3, #1
 800e928:	b2db      	uxtb	r3, r3
 800e92a:	2008      	movs	r0, #8
 800e92c:	4619      	mov	r1, r3
 800e92e:	f7fd fad7 	bl	800bee0 <_test_assert>
 800e932:	4603      	mov	r3, r0
 800e934:	2b00      	cmp	r3, #0
 800e936:	d000      	beq.n	800e93a <evt2_execute+0x16a>
 800e938:	e0e7      	b.n	800eb0a <evt2_execute+0x33a>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800e93a:	f04f 30ff 	mov.w	r0, #4294967295
 800e93e:	f7f3 fe5f 	bl	8002600 <chEvtGetAndClearEvents>
 800e942:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(9, m == 0, "stuck event");
 800e944:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e946:	2b00      	cmp	r3, #0
 800e948:	bf14      	ite	ne
 800e94a:	2300      	movne	r3, #0
 800e94c:	2301      	moveq	r3, #1
 800e94e:	b2db      	uxtb	r3, r3
 800e950:	2009      	movs	r0, #9
 800e952:	4619      	mov	r1, r3
 800e954:	f7fd fac4 	bl	800bee0 <_test_assert>
 800e958:	4603      	mov	r3, r0
 800e95a:	2b00      	cmp	r3, #0
 800e95c:	d000      	beq.n	800e960 <evt2_execute+0x190>
 800e95e:	e0d4      	b.n	800eb0a <evt2_execute+0x33a>

  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
 800e960:	f7fd fb66 	bl	800c030 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(50);
 800e964:	f7ff fe14 	bl	800e590 <chVTGetSystemTime>
 800e968:	4603      	mov	r3, r0
 800e96a:	3332      	adds	r3, #50	; 0x32
 800e96c:	930c      	str	r3, [sp, #48]	; 0x30
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800e96e:	4b68      	ldr	r3, [pc, #416]	; (800eb10 <evt2_execute+0x340>)
 800e970:	681d      	ldr	r5, [r3, #0]
 800e972:	f7ff fe25 	bl	800e5c0 <chThdGetPriorityX>
 800e976:	4603      	mov	r3, r0
 800e978:	1e5c      	subs	r4, r3, #1
                                 thread1, chThdGetSelfX());
 800e97a:	f7ff fe19 	bl	800e5b0 <chThdGetSelfX>
 800e97e:	4603      	mov	r3, r0
  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800e980:	9300      	str	r3, [sp, #0]
 800e982:	4628      	mov	r0, r5
 800e984:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800e988:	4622      	mov	r2, r4
 800e98a:	4b62      	ldr	r3, [pc, #392]	; (800eb14 <evt2_execute+0x344>)
 800e98c:	f7f2 fc28 	bl	80011e0 <chThdCreateStatic>
 800e990:	4602      	mov	r2, r0
 800e992:	4b61      	ldr	r3, [pc, #388]	; (800eb18 <evt2_execute+0x348>)
 800e994:	601a      	str	r2, [r3, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitAny(ALL_EVENTS);
 800e996:	f04f 30ff 	mov.w	r0, #4294967295
 800e99a:	f7f3 ff81 	bl	80028a0 <chEvtWaitAny>
 800e99e:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert_time_window(10, target_time, target_time + ALLOWED_DELAY);
 800e9a0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e9a2:	3305      	adds	r3, #5
 800e9a4:	200a      	movs	r0, #10
 800e9a6:	990c      	ldr	r1, [sp, #48]	; 0x30
 800e9a8:	461a      	mov	r2, r3
 800e9aa:	f7fd fae1 	bl	800bf70 <_test_assert_time_window>
 800e9ae:	4603      	mov	r3, r0
 800e9b0:	2b00      	cmp	r3, #0
 800e9b2:	d000      	beq.n	800e9b6 <evt2_execute+0x1e6>
 800e9b4:	e0a9      	b.n	800eb0a <evt2_execute+0x33a>
  test_assert(11, m == 1, "single event error");
 800e9b6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e9b8:	2b01      	cmp	r3, #1
 800e9ba:	bf14      	ite	ne
 800e9bc:	2300      	movne	r3, #0
 800e9be:	2301      	moveq	r3, #1
 800e9c0:	b2db      	uxtb	r3, r3
 800e9c2:	200b      	movs	r0, #11
 800e9c4:	4619      	mov	r1, r3
 800e9c6:	f7fd fa8b 	bl	800bee0 <_test_assert>
 800e9ca:	4603      	mov	r3, r0
 800e9cc:	2b00      	cmp	r3, #0
 800e9ce:	d000      	beq.n	800e9d2 <evt2_execute+0x202>
 800e9d0:	e09b      	b.n	800eb0a <evt2_execute+0x33a>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800e9d2:	f04f 30ff 	mov.w	r0, #4294967295
 800e9d6:	f7f3 fe13 	bl	8002600 <chEvtGetAndClearEvents>
 800e9da:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(12, m == 0, "stuck event");
 800e9dc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e9de:	2b00      	cmp	r3, #0
 800e9e0:	bf14      	ite	ne
 800e9e2:	2300      	movne	r3, #0
 800e9e4:	2301      	moveq	r3, #1
 800e9e6:	b2db      	uxtb	r3, r3
 800e9e8:	200c      	movs	r0, #12
 800e9ea:	4619      	mov	r1, r3
 800e9ec:	f7fd fa78 	bl	800bee0 <_test_assert>
 800e9f0:	4603      	mov	r3, r0
 800e9f2:	2b00      	cmp	r3, #0
 800e9f4:	d000      	beq.n	800e9f8 <evt2_execute+0x228>
 800e9f6:	e088      	b.n	800eb0a <evt2_execute+0x33a>
  test_wait_threads();
 800e9f8:	f7fd faf2 	bl	800bfe0 <test_wait_threads>

  /*
   * Test on chEvtWaitAll().
   */
  chEvtObjectInit(&es1);
 800e9fc:	4847      	ldr	r0, [pc, #284]	; (800eb1c <evt2_execute+0x34c>)
 800e9fe:	f7ff fde7 	bl	800e5d0 <chEvtObjectInit>
  chEvtObjectInit(&es2);
 800ea02:	4847      	ldr	r0, [pc, #284]	; (800eb20 <evt2_execute+0x350>)
 800ea04:	f7ff fde4 	bl	800e5d0 <chEvtObjectInit>
  chEvtRegisterMask(&es1, &el1, 1);
 800ea08:	ab07      	add	r3, sp, #28
 800ea0a:	4844      	ldr	r0, [pc, #272]	; (800eb1c <evt2_execute+0x34c>)
 800ea0c:	4619      	mov	r1, r3
 800ea0e:	2201      	movs	r2, #1
 800ea10:	f7ff fde6 	bl	800e5e0 <chEvtRegisterMask>
  chEvtRegisterMask(&es2, &el2, 4);
 800ea14:	ab02      	add	r3, sp, #8
 800ea16:	4842      	ldr	r0, [pc, #264]	; (800eb20 <evt2_execute+0x350>)
 800ea18:	4619      	mov	r1, r3
 800ea1a:	2204      	movs	r2, #4
 800ea1c:	f7ff fde0 	bl	800e5e0 <chEvtRegisterMask>
  test_wait_tick();
 800ea20:	f7fd fb06 	bl	800c030 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(50);
 800ea24:	f7ff fdb4 	bl	800e590 <chVTGetSystemTime>
 800ea28:	4603      	mov	r3, r0
 800ea2a:	3332      	adds	r3, #50	; 0x32
 800ea2c:	930c      	str	r3, [sp, #48]	; 0x30
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800ea2e:	4b38      	ldr	r3, [pc, #224]	; (800eb10 <evt2_execute+0x340>)
 800ea30:	681c      	ldr	r4, [r3, #0]
 800ea32:	f7ff fdc5 	bl	800e5c0 <chThdGetPriorityX>
 800ea36:	4603      	mov	r3, r0
 800ea38:	3b01      	subs	r3, #1
 800ea3a:	4a3a      	ldr	r2, [pc, #232]	; (800eb24 <evt2_execute+0x354>)
 800ea3c:	9200      	str	r2, [sp, #0]
 800ea3e:	4620      	mov	r0, r4
 800ea40:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800ea44:	461a      	mov	r2, r3
 800ea46:	4b38      	ldr	r3, [pc, #224]	; (800eb28 <evt2_execute+0x358>)
 800ea48:	f7f2 fbca 	bl	80011e0 <chThdCreateStatic>
 800ea4c:	4602      	mov	r2, r0
 800ea4e:	4b32      	ldr	r3, [pc, #200]	; (800eb18 <evt2_execute+0x348>)
 800ea50:	601a      	str	r2, [r3, #0]
                                 thread2, "A");
  m = chEvtWaitAll(5);
 800ea52:	2005      	movs	r0, #5
 800ea54:	f7f3 ff54 	bl	8002900 <chEvtWaitAll>
 800ea58:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert_time_window(13, target_time, target_time + ALLOWED_DELAY);
 800ea5a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800ea5c:	3305      	adds	r3, #5
 800ea5e:	200d      	movs	r0, #13
 800ea60:	990c      	ldr	r1, [sp, #48]	; 0x30
 800ea62:	461a      	mov	r2, r3
 800ea64:	f7fd fa84 	bl	800bf70 <_test_assert_time_window>
 800ea68:	4603      	mov	r3, r0
 800ea6a:	2b00      	cmp	r3, #0
 800ea6c:	d000      	beq.n	800ea70 <evt2_execute+0x2a0>
 800ea6e:	e04c      	b.n	800eb0a <evt2_execute+0x33a>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800ea70:	f04f 30ff 	mov.w	r0, #4294967295
 800ea74:	f7f3 fdc4 	bl	8002600 <chEvtGetAndClearEvents>
 800ea78:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(14, m == 0, "stuck event");
 800ea7a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800ea7c:	2b00      	cmp	r3, #0
 800ea7e:	bf14      	ite	ne
 800ea80:	2300      	movne	r3, #0
 800ea82:	2301      	moveq	r3, #1
 800ea84:	b2db      	uxtb	r3, r3
 800ea86:	200e      	movs	r0, #14
 800ea88:	4619      	mov	r1, r3
 800ea8a:	f7fd fa29 	bl	800bee0 <_test_assert>
 800ea8e:	4603      	mov	r3, r0
 800ea90:	2b00      	cmp	r3, #0
 800ea92:	d000      	beq.n	800ea96 <evt2_execute+0x2c6>
 800ea94:	e039      	b.n	800eb0a <evt2_execute+0x33a>
  test_wait_threads();
 800ea96:	f7fd faa3 	bl	800bfe0 <test_wait_threads>
  chEvtUnregister(&es1, &el1);
 800ea9a:	ab07      	add	r3, sp, #28
 800ea9c:	481f      	ldr	r0, [pc, #124]	; (800eb1c <evt2_execute+0x34c>)
 800ea9e:	4619      	mov	r1, r3
 800eaa0:	f7f3 fd8e 	bl	80025c0 <chEvtUnregister>
  chEvtUnregister(&es2, &el2);
 800eaa4:	ab02      	add	r3, sp, #8
 800eaa6:	481e      	ldr	r0, [pc, #120]	; (800eb20 <evt2_execute+0x350>)
 800eaa8:	4619      	mov	r1, r3
 800eaaa:	f7f3 fd89 	bl	80025c0 <chEvtUnregister>
  test_assert(15, !chEvtIsListeningI(&es1), "stuck listener");
 800eaae:	481b      	ldr	r0, [pc, #108]	; (800eb1c <evt2_execute+0x34c>)
 800eab0:	f7ff fda6 	bl	800e600 <chEvtIsListeningI>
 800eab4:	4603      	mov	r3, r0
 800eab6:	2b00      	cmp	r3, #0
 800eab8:	bf0c      	ite	eq
 800eaba:	2300      	moveq	r3, #0
 800eabc:	2301      	movne	r3, #1
 800eabe:	b2db      	uxtb	r3, r3
 800eac0:	f083 0301 	eor.w	r3, r3, #1
 800eac4:	b2db      	uxtb	r3, r3
 800eac6:	f003 0301 	and.w	r3, r3, #1
 800eaca:	b2db      	uxtb	r3, r3
 800eacc:	200f      	movs	r0, #15
 800eace:	4619      	mov	r1, r3
 800ead0:	f7fd fa06 	bl	800bee0 <_test_assert>
 800ead4:	4603      	mov	r3, r0
 800ead6:	2b00      	cmp	r3, #0
 800ead8:	d000      	beq.n	800eadc <evt2_execute+0x30c>
 800eada:	e016      	b.n	800eb0a <evt2_execute+0x33a>
  test_assert(16, !chEvtIsListeningI(&es2), "stuck listener");
 800eadc:	4810      	ldr	r0, [pc, #64]	; (800eb20 <evt2_execute+0x350>)
 800eade:	f7ff fd8f 	bl	800e600 <chEvtIsListeningI>
 800eae2:	4603      	mov	r3, r0
 800eae4:	2b00      	cmp	r3, #0
 800eae6:	bf0c      	ite	eq
 800eae8:	2300      	moveq	r3, #0
 800eaea:	2301      	movne	r3, #1
 800eaec:	b2db      	uxtb	r3, r3
 800eaee:	f083 0301 	eor.w	r3, r3, #1
 800eaf2:	b2db      	uxtb	r3, r3
 800eaf4:	f003 0301 	and.w	r3, r3, #1
 800eaf8:	b2db      	uxtb	r3, r3
 800eafa:	2010      	movs	r0, #16
 800eafc:	4619      	mov	r1, r3
 800eafe:	f7fd f9ef 	bl	800bee0 <_test_assert>
 800eb02:	4603      	mov	r3, r0
 800eb04:	2b00      	cmp	r3, #0
 800eb06:	d000      	beq.n	800eb0a <evt2_execute+0x33a>
 800eb08:	bf00      	nop
}
 800eb0a:	b00f      	add	sp, #60	; 0x3c
 800eb0c:	bd30      	pop	{r4, r5, pc}
 800eb0e:	bf00      	nop
 800eb10:	08017b20 	.word	0x08017b20
 800eb14:	0800e781 	.word	0x0800e781
 800eb18:	20001ba4 	.word	0x20001ba4
 800eb1c:	20000894 	.word	0x20000894
 800eb20:	20000898 	.word	0x20000898
 800eb24:	080180d4 	.word	0x080180d4
 800eb28:	0800e7a1 	.word	0x0800e7a1
 800eb2c:	f3af 8000 	nop.w

0800eb30 <evt3_setup>:
 * - @p chEvtWaitAllTimeout()
 * .
 * After each test phase the test verifies that there are no stuck event flags.
 */

static void evt3_setup(void) {
 800eb30:	b508      	push	{r3, lr}

  chEvtGetAndClearEvents(ALL_EVENTS);
 800eb32:	f04f 30ff 	mov.w	r0, #4294967295
 800eb36:	f7f3 fd63 	bl	8002600 <chEvtGetAndClearEvents>
}
 800eb3a:	bd08      	pop	{r3, pc}
 800eb3c:	f3af 8000 	nop.w

0800eb40 <evt3_execute>:

static void evt3_execute(void) {
 800eb40:	b500      	push	{lr}
 800eb42:	b083      	sub	sp, #12
  eventmask_t m;

  /*
   * Tests various timeout situations.
   */
  m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 800eb44:	f04f 30ff 	mov.w	r0, #4294967295
 800eb48:	2100      	movs	r1, #0
 800eb4a:	f7f3 ff01 	bl	8002950 <chEvtWaitOneTimeout>
 800eb4e:	9001      	str	r0, [sp, #4]
  test_assert(1, m == 0, "spurious event");
 800eb50:	9b01      	ldr	r3, [sp, #4]
 800eb52:	2b00      	cmp	r3, #0
 800eb54:	bf14      	ite	ne
 800eb56:	2300      	movne	r3, #0
 800eb58:	2301      	moveq	r3, #1
 800eb5a:	b2db      	uxtb	r3, r3
 800eb5c:	2001      	movs	r0, #1
 800eb5e:	4619      	mov	r1, r3
 800eb60:	f7fd f9be 	bl	800bee0 <_test_assert>
 800eb64:	4603      	mov	r3, r0
 800eb66:	2b00      	cmp	r3, #0
 800eb68:	d000      	beq.n	800eb6c <evt3_execute+0x2c>
 800eb6a:	e063      	b.n	800ec34 <evt3_execute+0xf4>
  m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 800eb6c:	f04f 30ff 	mov.w	r0, #4294967295
 800eb70:	2100      	movs	r1, #0
 800eb72:	f7f3 ff2d 	bl	80029d0 <chEvtWaitAnyTimeout>
 800eb76:	9001      	str	r0, [sp, #4]
  test_assert(2, m == 0, "spurious event");
 800eb78:	9b01      	ldr	r3, [sp, #4]
 800eb7a:	2b00      	cmp	r3, #0
 800eb7c:	bf14      	ite	ne
 800eb7e:	2300      	movne	r3, #0
 800eb80:	2301      	moveq	r3, #1
 800eb82:	b2db      	uxtb	r3, r3
 800eb84:	2002      	movs	r0, #2
 800eb86:	4619      	mov	r1, r3
 800eb88:	f7fd f9aa 	bl	800bee0 <_test_assert>
 800eb8c:	4603      	mov	r3, r0
 800eb8e:	2b00      	cmp	r3, #0
 800eb90:	d000      	beq.n	800eb94 <evt3_execute+0x54>
 800eb92:	e04f      	b.n	800ec34 <evt3_execute+0xf4>
  m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 800eb94:	f04f 30ff 	mov.w	r0, #4294967295
 800eb98:	2100      	movs	r1, #0
 800eb9a:	f7f3 ff59 	bl	8002a50 <chEvtWaitAllTimeout>
 800eb9e:	9001      	str	r0, [sp, #4]
  test_assert(3, m == 0, "spurious event");
 800eba0:	9b01      	ldr	r3, [sp, #4]
 800eba2:	2b00      	cmp	r3, #0
 800eba4:	bf14      	ite	ne
 800eba6:	2300      	movne	r3, #0
 800eba8:	2301      	moveq	r3, #1
 800ebaa:	b2db      	uxtb	r3, r3
 800ebac:	2003      	movs	r0, #3
 800ebae:	4619      	mov	r1, r3
 800ebb0:	f7fd f996 	bl	800bee0 <_test_assert>
 800ebb4:	4603      	mov	r3, r0
 800ebb6:	2b00      	cmp	r3, #0
 800ebb8:	d000      	beq.n	800ebbc <evt3_execute+0x7c>
 800ebba:	e03b      	b.n	800ec34 <evt3_execute+0xf4>
  m = chEvtWaitOneTimeout(ALL_EVENTS, 10);
 800ebbc:	f04f 30ff 	mov.w	r0, #4294967295
 800ebc0:	210a      	movs	r1, #10
 800ebc2:	f7f3 fec5 	bl	8002950 <chEvtWaitOneTimeout>
 800ebc6:	9001      	str	r0, [sp, #4]
  test_assert(4, m == 0, "spurious event");
 800ebc8:	9b01      	ldr	r3, [sp, #4]
 800ebca:	2b00      	cmp	r3, #0
 800ebcc:	bf14      	ite	ne
 800ebce:	2300      	movne	r3, #0
 800ebd0:	2301      	moveq	r3, #1
 800ebd2:	b2db      	uxtb	r3, r3
 800ebd4:	2004      	movs	r0, #4
 800ebd6:	4619      	mov	r1, r3
 800ebd8:	f7fd f982 	bl	800bee0 <_test_assert>
 800ebdc:	4603      	mov	r3, r0
 800ebde:	2b00      	cmp	r3, #0
 800ebe0:	d000      	beq.n	800ebe4 <evt3_execute+0xa4>
 800ebe2:	e027      	b.n	800ec34 <evt3_execute+0xf4>
  m = chEvtWaitAnyTimeout(ALL_EVENTS, 10);
 800ebe4:	f04f 30ff 	mov.w	r0, #4294967295
 800ebe8:	210a      	movs	r1, #10
 800ebea:	f7f3 fef1 	bl	80029d0 <chEvtWaitAnyTimeout>
 800ebee:	9001      	str	r0, [sp, #4]
  test_assert(5, m == 0, "spurious event");
 800ebf0:	9b01      	ldr	r3, [sp, #4]
 800ebf2:	2b00      	cmp	r3, #0
 800ebf4:	bf14      	ite	ne
 800ebf6:	2300      	movne	r3, #0
 800ebf8:	2301      	moveq	r3, #1
 800ebfa:	b2db      	uxtb	r3, r3
 800ebfc:	2005      	movs	r0, #5
 800ebfe:	4619      	mov	r1, r3
 800ec00:	f7fd f96e 	bl	800bee0 <_test_assert>
 800ec04:	4603      	mov	r3, r0
 800ec06:	2b00      	cmp	r3, #0
 800ec08:	d000      	beq.n	800ec0c <evt3_execute+0xcc>
 800ec0a:	e013      	b.n	800ec34 <evt3_execute+0xf4>
  m = chEvtWaitAllTimeout(ALL_EVENTS, 10);
 800ec0c:	f04f 30ff 	mov.w	r0, #4294967295
 800ec10:	210a      	movs	r1, #10
 800ec12:	f7f3 ff1d 	bl	8002a50 <chEvtWaitAllTimeout>
 800ec16:	9001      	str	r0, [sp, #4]
  test_assert(6, m == 0, "spurious event");
 800ec18:	9b01      	ldr	r3, [sp, #4]
 800ec1a:	2b00      	cmp	r3, #0
 800ec1c:	bf14      	ite	ne
 800ec1e:	2300      	movne	r3, #0
 800ec20:	2301      	moveq	r3, #1
 800ec22:	b2db      	uxtb	r3, r3
 800ec24:	2006      	movs	r0, #6
 800ec26:	4619      	mov	r1, r3
 800ec28:	f7fd f95a 	bl	800bee0 <_test_assert>
 800ec2c:	4603      	mov	r3, r0
 800ec2e:	2b00      	cmp	r3, #0
 800ec30:	d000      	beq.n	800ec34 <evt3_execute+0xf4>
 800ec32:	bf00      	nop
}
 800ec34:	b003      	add	sp, #12
 800ec36:	f85d fb04 	ldr.w	pc, [sp], #4
 800ec3a:	bf00      	nop
 800ec3c:	f3af 8000 	nop.w

0800ec40 <heap1_setup>:
 * allocator.<br>
 * The test expects to find the heap back to the initial status after each
 * sequence.
 */

static void heap1_setup(void) {
 800ec40:	b508      	push	{r3, lr}

  chHeapObjectInit(&test_heap, test.buffer, sizeof(union test_buffers));
 800ec42:	4803      	ldr	r0, [pc, #12]	; (800ec50 <heap1_setup+0x10>)
 800ec44:	4903      	ldr	r1, [pc, #12]	; (800ec54 <heap1_setup+0x14>)
 800ec46:	f44f 62cd 	mov.w	r2, #1640	; 0x668
 800ec4a:	f7f4 fd69 	bl	8003720 <chHeapObjectInit>
}
 800ec4e:	bd08      	pop	{r3, pc}
 800ec50:	20000fc8 	.word	0x20000fc8
 800ec54:	20001bb8 	.word	0x20001bb8
 800ec58:	f3af 8000 	nop.w
 800ec5c:	f3af 8000 	nop.w

0800ec60 <heap1_execute>:

static void heap1_execute(void) {
 800ec60:	b500      	push	{lr}
 800ec62:	b087      	sub	sp, #28
  void *p1, *p2, *p3;
  size_t n, sz;

  /* Unrelated, for coverage only.*/
  (void)chCoreGetStatusX();
 800ec64:	f7f4 fd34 	bl	80036d0 <chCoreGetStatusX>

  /*
   * Test on the default heap in order to cover the core allocator at
   * least one time.
   */
  (void)chHeapStatus(NULL, &sz);
 800ec68:	ab01      	add	r3, sp, #4
 800ec6a:	2000      	movs	r0, #0
 800ec6c:	4619      	mov	r1, r3
 800ec6e:	f7f4 fe57 	bl	8003920 <chHeapStatus>
  p1 = chHeapAlloc(NULL, SIZE);
 800ec72:	2000      	movs	r0, #0
 800ec74:	2110      	movs	r1, #16
 800ec76:	f7f4 fd73 	bl	8003760 <chHeapAlloc>
 800ec7a:	9005      	str	r0, [sp, #20]
  test_assert(1, p1 != NULL, "allocation failed");
 800ec7c:	9b05      	ldr	r3, [sp, #20]
 800ec7e:	2b00      	cmp	r3, #0
 800ec80:	bf0c      	ite	eq
 800ec82:	2300      	moveq	r3, #0
 800ec84:	2301      	movne	r3, #1
 800ec86:	b2db      	uxtb	r3, r3
 800ec88:	2001      	movs	r0, #1
 800ec8a:	4619      	mov	r1, r3
 800ec8c:	f7fd f928 	bl	800bee0 <_test_assert>
 800ec90:	4603      	mov	r3, r0
 800ec92:	2b00      	cmp	r3, #0
 800ec94:	d000      	beq.n	800ec98 <heap1_execute+0x38>
 800ec96:	e14e      	b.n	800ef36 <heap1_execute+0x2d6>
  chHeapFree(p1);
 800ec98:	9805      	ldr	r0, [sp, #20]
 800ec9a:	f7f4 fdd9 	bl	8003850 <chHeapFree>
  p1 = chHeapAlloc(NULL, (size_t)-256);
 800ec9e:	2000      	movs	r0, #0
 800eca0:	f06f 01ff 	mvn.w	r1, #255	; 0xff
 800eca4:	f7f4 fd5c 	bl	8003760 <chHeapAlloc>
 800eca8:	9005      	str	r0, [sp, #20]
  test_assert(2, p1 == NULL, "allocation not failed");
 800ecaa:	9b05      	ldr	r3, [sp, #20]
 800ecac:	2b00      	cmp	r3, #0
 800ecae:	bf14      	ite	ne
 800ecb0:	2300      	movne	r3, #0
 800ecb2:	2301      	moveq	r3, #1
 800ecb4:	b2db      	uxtb	r3, r3
 800ecb6:	2002      	movs	r0, #2
 800ecb8:	4619      	mov	r1, r3
 800ecba:	f7fd f911 	bl	800bee0 <_test_assert>
 800ecbe:	4603      	mov	r3, r0
 800ecc0:	2b00      	cmp	r3, #0
 800ecc2:	d000      	beq.n	800ecc6 <heap1_execute+0x66>
 800ecc4:	e137      	b.n	800ef36 <heap1_execute+0x2d6>

  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);
 800ecc6:	ab01      	add	r3, sp, #4
 800ecc8:	489c      	ldr	r0, [pc, #624]	; (800ef3c <heap1_execute+0x2dc>)
 800ecca:	4619      	mov	r1, r3
 800eccc:	f7f4 fe28 	bl	8003920 <chHeapStatus>

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 800ecd0:	489a      	ldr	r0, [pc, #616]	; (800ef3c <heap1_execute+0x2dc>)
 800ecd2:	2110      	movs	r1, #16
 800ecd4:	f7f4 fd44 	bl	8003760 <chHeapAlloc>
 800ecd8:	9005      	str	r0, [sp, #20]
  p2 = chHeapAlloc(&test_heap, SIZE);
 800ecda:	4898      	ldr	r0, [pc, #608]	; (800ef3c <heap1_execute+0x2dc>)
 800ecdc:	2110      	movs	r1, #16
 800ecde:	f7f4 fd3f 	bl	8003760 <chHeapAlloc>
 800ece2:	9004      	str	r0, [sp, #16]
  p3 = chHeapAlloc(&test_heap, SIZE);
 800ece4:	4895      	ldr	r0, [pc, #596]	; (800ef3c <heap1_execute+0x2dc>)
 800ece6:	2110      	movs	r1, #16
 800ece8:	f7f4 fd3a 	bl	8003760 <chHeapAlloc>
 800ecec:	9003      	str	r0, [sp, #12]
  chHeapFree(p1);                               /* Does not merge.*/
 800ecee:	9805      	ldr	r0, [sp, #20]
 800ecf0:	f7f4 fdae 	bl	8003850 <chHeapFree>
  chHeapFree(p2);                               /* Merges backward.*/
 800ecf4:	9804      	ldr	r0, [sp, #16]
 800ecf6:	f7f4 fdab 	bl	8003850 <chHeapFree>
  chHeapFree(p3);                               /* Merges both sides.*/
 800ecfa:	9803      	ldr	r0, [sp, #12]
 800ecfc:	f7f4 fda8 	bl	8003850 <chHeapFree>
  test_assert(3, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 800ed00:	ab02      	add	r3, sp, #8
 800ed02:	488e      	ldr	r0, [pc, #568]	; (800ef3c <heap1_execute+0x2dc>)
 800ed04:	4619      	mov	r1, r3
 800ed06:	f7f4 fe0b 	bl	8003920 <chHeapStatus>
 800ed0a:	4603      	mov	r3, r0
 800ed0c:	2b01      	cmp	r3, #1
 800ed0e:	bf14      	ite	ne
 800ed10:	2300      	movne	r3, #0
 800ed12:	2301      	moveq	r3, #1
 800ed14:	b2db      	uxtb	r3, r3
 800ed16:	2003      	movs	r0, #3
 800ed18:	4619      	mov	r1, r3
 800ed1a:	f7fd f8e1 	bl	800bee0 <_test_assert>
 800ed1e:	4603      	mov	r3, r0
 800ed20:	2b00      	cmp	r3, #0
 800ed22:	d000      	beq.n	800ed26 <heap1_execute+0xc6>
 800ed24:	e107      	b.n	800ef36 <heap1_execute+0x2d6>

  /* Reverse order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 800ed26:	4885      	ldr	r0, [pc, #532]	; (800ef3c <heap1_execute+0x2dc>)
 800ed28:	2110      	movs	r1, #16
 800ed2a:	f7f4 fd19 	bl	8003760 <chHeapAlloc>
 800ed2e:	9005      	str	r0, [sp, #20]
  p2 = chHeapAlloc(&test_heap, SIZE);
 800ed30:	4882      	ldr	r0, [pc, #520]	; (800ef3c <heap1_execute+0x2dc>)
 800ed32:	2110      	movs	r1, #16
 800ed34:	f7f4 fd14 	bl	8003760 <chHeapAlloc>
 800ed38:	9004      	str	r0, [sp, #16]
  p3 = chHeapAlloc(&test_heap, SIZE);
 800ed3a:	4880      	ldr	r0, [pc, #512]	; (800ef3c <heap1_execute+0x2dc>)
 800ed3c:	2110      	movs	r1, #16
 800ed3e:	f7f4 fd0f 	bl	8003760 <chHeapAlloc>
 800ed42:	9003      	str	r0, [sp, #12]
  chHeapFree(p3);                               /* Merges forward.*/
 800ed44:	9803      	ldr	r0, [sp, #12]
 800ed46:	f7f4 fd83 	bl	8003850 <chHeapFree>
  chHeapFree(p2);                               /* Merges forward.*/
 800ed4a:	9804      	ldr	r0, [sp, #16]
 800ed4c:	f7f4 fd80 	bl	8003850 <chHeapFree>
  chHeapFree(p1);                               /* Merges forward.*/
 800ed50:	9805      	ldr	r0, [sp, #20]
 800ed52:	f7f4 fd7d 	bl	8003850 <chHeapFree>
  test_assert(4, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 800ed56:	ab02      	add	r3, sp, #8
 800ed58:	4878      	ldr	r0, [pc, #480]	; (800ef3c <heap1_execute+0x2dc>)
 800ed5a:	4619      	mov	r1, r3
 800ed5c:	f7f4 fde0 	bl	8003920 <chHeapStatus>
 800ed60:	4603      	mov	r3, r0
 800ed62:	2b01      	cmp	r3, #1
 800ed64:	bf14      	ite	ne
 800ed66:	2300      	movne	r3, #0
 800ed68:	2301      	moveq	r3, #1
 800ed6a:	b2db      	uxtb	r3, r3
 800ed6c:	2004      	movs	r0, #4
 800ed6e:	4619      	mov	r1, r3
 800ed70:	f7fd f8b6 	bl	800bee0 <_test_assert>
 800ed74:	4603      	mov	r3, r0
 800ed76:	2b00      	cmp	r3, #0
 800ed78:	d000      	beq.n	800ed7c <heap1_execute+0x11c>
 800ed7a:	e0dc      	b.n	800ef36 <heap1_execute+0x2d6>

  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
 800ed7c:	486f      	ldr	r0, [pc, #444]	; (800ef3c <heap1_execute+0x2dc>)
 800ed7e:	2111      	movs	r1, #17
 800ed80:	f7f4 fcee 	bl	8003760 <chHeapAlloc>
 800ed84:	9005      	str	r0, [sp, #20]
  p2 = chHeapAlloc(&test_heap, SIZE);
 800ed86:	486d      	ldr	r0, [pc, #436]	; (800ef3c <heap1_execute+0x2dc>)
 800ed88:	2110      	movs	r1, #16
 800ed8a:	f7f4 fce9 	bl	8003760 <chHeapAlloc>
 800ed8e:	9004      	str	r0, [sp, #16]
  chHeapFree(p1);
 800ed90:	9805      	ldr	r0, [sp, #20]
 800ed92:	f7f4 fd5d 	bl	8003850 <chHeapFree>
  test_assert(5, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 800ed96:	ab02      	add	r3, sp, #8
 800ed98:	4868      	ldr	r0, [pc, #416]	; (800ef3c <heap1_execute+0x2dc>)
 800ed9a:	4619      	mov	r1, r3
 800ed9c:	f7f4 fdc0 	bl	8003920 <chHeapStatus>
 800eda0:	4603      	mov	r3, r0
 800eda2:	2b02      	cmp	r3, #2
 800eda4:	bf14      	ite	ne
 800eda6:	2300      	movne	r3, #0
 800eda8:	2301      	moveq	r3, #1
 800edaa:	b2db      	uxtb	r3, r3
 800edac:	2005      	movs	r0, #5
 800edae:	4619      	mov	r1, r3
 800edb0:	f7fd f896 	bl	800bee0 <_test_assert>
 800edb4:	4603      	mov	r3, r0
 800edb6:	2b00      	cmp	r3, #0
 800edb8:	d000      	beq.n	800edbc <heap1_execute+0x15c>
 800edba:	e0bc      	b.n	800ef36 <heap1_execute+0x2d6>
  p1 = chHeapAlloc(&test_heap, SIZE);
 800edbc:	485f      	ldr	r0, [pc, #380]	; (800ef3c <heap1_execute+0x2dc>)
 800edbe:	2110      	movs	r1, #16
 800edc0:	f7f4 fcce 	bl	8003760 <chHeapAlloc>
 800edc4:	9005      	str	r0, [sp, #20]
  /* Note, the first situation happens when the alignment size is smaller
     than the header size, the second in the other cases.*/
  test_assert(6, (chHeapStatus(&test_heap, &n) == 1) ||
 800edc6:	ab02      	add	r3, sp, #8
 800edc8:	485c      	ldr	r0, [pc, #368]	; (800ef3c <heap1_execute+0x2dc>)
 800edca:	4619      	mov	r1, r3
 800edcc:	f7f4 fda8 	bl	8003920 <chHeapStatus>
 800edd0:	4603      	mov	r3, r0
 800edd2:	2b01      	cmp	r3, #1
 800edd4:	d007      	beq.n	800ede6 <heap1_execute+0x186>
 800edd6:	ab02      	add	r3, sp, #8
 800edd8:	4858      	ldr	r0, [pc, #352]	; (800ef3c <heap1_execute+0x2dc>)
 800edda:	4619      	mov	r1, r3
 800eddc:	f7f4 fda0 	bl	8003920 <chHeapStatus>
 800ede0:	4603      	mov	r3, r0
 800ede2:	2b02      	cmp	r3, #2
 800ede4:	d101      	bne.n	800edea <heap1_execute+0x18a>
 800ede6:	2301      	movs	r3, #1
 800ede8:	e000      	b.n	800edec <heap1_execute+0x18c>
 800edea:	2300      	movs	r3, #0
 800edec:	f003 0301 	and.w	r3, r3, #1
 800edf0:	b2db      	uxtb	r3, r3
 800edf2:	2006      	movs	r0, #6
 800edf4:	4619      	mov	r1, r3
 800edf6:	f7fd f873 	bl	800bee0 <_test_assert>
 800edfa:	4603      	mov	r3, r0
 800edfc:	2b00      	cmp	r3, #0
 800edfe:	d000      	beq.n	800ee02 <heap1_execute+0x1a2>
 800ee00:	e099      	b.n	800ef36 <heap1_execute+0x2d6>
                 (chHeapStatus(&test_heap, &n) == 2), "heap fragmented");
  chHeapFree(p2);
 800ee02:	9804      	ldr	r0, [sp, #16]
 800ee04:	f7f4 fd24 	bl	8003850 <chHeapFree>
  chHeapFree(p1);
 800ee08:	9805      	ldr	r0, [sp, #20]
 800ee0a:	f7f4 fd21 	bl	8003850 <chHeapFree>
  test_assert(7, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 800ee0e:	ab02      	add	r3, sp, #8
 800ee10:	484a      	ldr	r0, [pc, #296]	; (800ef3c <heap1_execute+0x2dc>)
 800ee12:	4619      	mov	r1, r3
 800ee14:	f7f4 fd84 	bl	8003920 <chHeapStatus>
 800ee18:	4603      	mov	r3, r0
 800ee1a:	2b01      	cmp	r3, #1
 800ee1c:	bf14      	ite	ne
 800ee1e:	2300      	movne	r3, #0
 800ee20:	2301      	moveq	r3, #1
 800ee22:	b2db      	uxtb	r3, r3
 800ee24:	2007      	movs	r0, #7
 800ee26:	4619      	mov	r1, r3
 800ee28:	f7fd f85a 	bl	800bee0 <_test_assert>
 800ee2c:	4603      	mov	r3, r0
 800ee2e:	2b00      	cmp	r3, #0
 800ee30:	d000      	beq.n	800ee34 <heap1_execute+0x1d4>
 800ee32:	e080      	b.n	800ef36 <heap1_execute+0x2d6>

  /* Skip fragment handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 800ee34:	4841      	ldr	r0, [pc, #260]	; (800ef3c <heap1_execute+0x2dc>)
 800ee36:	2110      	movs	r1, #16
 800ee38:	f7f4 fc92 	bl	8003760 <chHeapAlloc>
 800ee3c:	9005      	str	r0, [sp, #20]
  p2 = chHeapAlloc(&test_heap, SIZE);
 800ee3e:	483f      	ldr	r0, [pc, #252]	; (800ef3c <heap1_execute+0x2dc>)
 800ee40:	2110      	movs	r1, #16
 800ee42:	f7f4 fc8d 	bl	8003760 <chHeapAlloc>
 800ee46:	9004      	str	r0, [sp, #16]
  chHeapFree(p1);
 800ee48:	9805      	ldr	r0, [sp, #20]
 800ee4a:	f7f4 fd01 	bl	8003850 <chHeapFree>
  test_assert(8, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 800ee4e:	ab02      	add	r3, sp, #8
 800ee50:	483a      	ldr	r0, [pc, #232]	; (800ef3c <heap1_execute+0x2dc>)
 800ee52:	4619      	mov	r1, r3
 800ee54:	f7f4 fd64 	bl	8003920 <chHeapStatus>
 800ee58:	4603      	mov	r3, r0
 800ee5a:	2b02      	cmp	r3, #2
 800ee5c:	bf14      	ite	ne
 800ee5e:	2300      	movne	r3, #0
 800ee60:	2301      	moveq	r3, #1
 800ee62:	b2db      	uxtb	r3, r3
 800ee64:	2008      	movs	r0, #8
 800ee66:	4619      	mov	r1, r3
 800ee68:	f7fd f83a 	bl	800bee0 <_test_assert>
 800ee6c:	4603      	mov	r3, r0
 800ee6e:	2b00      	cmp	r3, #0
 800ee70:	d000      	beq.n	800ee74 <heap1_execute+0x214>
 800ee72:	e060      	b.n	800ef36 <heap1_execute+0x2d6>
  p1 = chHeapAlloc(&test_heap, SIZE * 2);       /* Skips first fragment.*/
 800ee74:	4831      	ldr	r0, [pc, #196]	; (800ef3c <heap1_execute+0x2dc>)
 800ee76:	2120      	movs	r1, #32
 800ee78:	f7f4 fc72 	bl	8003760 <chHeapAlloc>
 800ee7c:	9005      	str	r0, [sp, #20]
  chHeapFree(p1);
 800ee7e:	9805      	ldr	r0, [sp, #20]
 800ee80:	f7f4 fce6 	bl	8003850 <chHeapFree>
  chHeapFree(p2);
 800ee84:	9804      	ldr	r0, [sp, #16]
 800ee86:	f7f4 fce3 	bl	8003850 <chHeapFree>
  test_assert(9, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 800ee8a:	ab02      	add	r3, sp, #8
 800ee8c:	482b      	ldr	r0, [pc, #172]	; (800ef3c <heap1_execute+0x2dc>)
 800ee8e:	4619      	mov	r1, r3
 800ee90:	f7f4 fd46 	bl	8003920 <chHeapStatus>
 800ee94:	4603      	mov	r3, r0
 800ee96:	2b01      	cmp	r3, #1
 800ee98:	bf14      	ite	ne
 800ee9a:	2300      	movne	r3, #0
 800ee9c:	2301      	moveq	r3, #1
 800ee9e:	b2db      	uxtb	r3, r3
 800eea0:	2009      	movs	r0, #9
 800eea2:	4619      	mov	r1, r3
 800eea4:	f7fd f81c 	bl	800bee0 <_test_assert>
 800eea8:	4603      	mov	r3, r0
 800eeaa:	2b00      	cmp	r3, #0
 800eeac:	d000      	beq.n	800eeb0 <heap1_execute+0x250>
 800eeae:	e042      	b.n	800ef36 <heap1_execute+0x2d6>

  /* Allocate all handling.*/
  (void)chHeapStatus(&test_heap, &n);
 800eeb0:	ab02      	add	r3, sp, #8
 800eeb2:	4822      	ldr	r0, [pc, #136]	; (800ef3c <heap1_execute+0x2dc>)
 800eeb4:	4619      	mov	r1, r3
 800eeb6:	f7f4 fd33 	bl	8003920 <chHeapStatus>
  p1 = chHeapAlloc(&test_heap, n);
 800eeba:	9b02      	ldr	r3, [sp, #8]
 800eebc:	481f      	ldr	r0, [pc, #124]	; (800ef3c <heap1_execute+0x2dc>)
 800eebe:	4619      	mov	r1, r3
 800eec0:	f7f4 fc4e 	bl	8003760 <chHeapAlloc>
 800eec4:	9005      	str	r0, [sp, #20]
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
 800eec6:	ab02      	add	r3, sp, #8
 800eec8:	481c      	ldr	r0, [pc, #112]	; (800ef3c <heap1_execute+0x2dc>)
 800eeca:	4619      	mov	r1, r3
 800eecc:	f7f4 fd28 	bl	8003920 <chHeapStatus>
 800eed0:	4603      	mov	r3, r0
 800eed2:	2b00      	cmp	r3, #0
 800eed4:	bf14      	ite	ne
 800eed6:	2300      	movne	r3, #0
 800eed8:	2301      	moveq	r3, #1
 800eeda:	b2db      	uxtb	r3, r3
 800eedc:	200a      	movs	r0, #10
 800eede:	4619      	mov	r1, r3
 800eee0:	f7fc fffe 	bl	800bee0 <_test_assert>
 800eee4:	4603      	mov	r3, r0
 800eee6:	2b00      	cmp	r3, #0
 800eee8:	d000      	beq.n	800eeec <heap1_execute+0x28c>
 800eeea:	e024      	b.n	800ef36 <heap1_execute+0x2d6>
  chHeapFree(p1);
 800eeec:	9805      	ldr	r0, [sp, #20]
 800eeee:	f7f4 fcaf 	bl	8003850 <chHeapFree>

  test_assert(11, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 800eef2:	ab02      	add	r3, sp, #8
 800eef4:	4811      	ldr	r0, [pc, #68]	; (800ef3c <heap1_execute+0x2dc>)
 800eef6:	4619      	mov	r1, r3
 800eef8:	f7f4 fd12 	bl	8003920 <chHeapStatus>
 800eefc:	4603      	mov	r3, r0
 800eefe:	2b01      	cmp	r3, #1
 800ef00:	bf14      	ite	ne
 800ef02:	2300      	movne	r3, #0
 800ef04:	2301      	moveq	r3, #1
 800ef06:	b2db      	uxtb	r3, r3
 800ef08:	200b      	movs	r0, #11
 800ef0a:	4619      	mov	r1, r3
 800ef0c:	f7fc ffe8 	bl	800bee0 <_test_assert>
 800ef10:	4603      	mov	r3, r0
 800ef12:	2b00      	cmp	r3, #0
 800ef14:	d000      	beq.n	800ef18 <heap1_execute+0x2b8>
 800ef16:	e00e      	b.n	800ef36 <heap1_execute+0x2d6>
  test_assert(12, n == sz, "size changed");
 800ef18:	9a02      	ldr	r2, [sp, #8]
 800ef1a:	9b01      	ldr	r3, [sp, #4]
 800ef1c:	429a      	cmp	r2, r3
 800ef1e:	bf14      	ite	ne
 800ef20:	2300      	movne	r3, #0
 800ef22:	2301      	moveq	r3, #1
 800ef24:	b2db      	uxtb	r3, r3
 800ef26:	200c      	movs	r0, #12
 800ef28:	4619      	mov	r1, r3
 800ef2a:	f7fc ffd9 	bl	800bee0 <_test_assert>
 800ef2e:	4603      	mov	r3, r0
 800ef30:	2b00      	cmp	r3, #0
 800ef32:	d000      	beq.n	800ef36 <heap1_execute+0x2d6>
 800ef34:	bf00      	nop
}
 800ef36:	b007      	add	sp, #28
 800ef38:	f85d fb04 	ldr.w	pc, [sp], #4
 800ef3c:	20000fc8 	.word	0x20000fc8

0800ef40 <null_provider>:
 * Five memory blocks are added to a memory pool then removed.<br>
 * The test expects to find the pool queue in the proper status after each
 * operation.
 */

static void *null_provider(size_t size) {
 800ef40:	b082      	sub	sp, #8
 800ef42:	9001      	str	r0, [sp, #4]

  (void)size;
  return NULL;
 800ef44:	2300      	movs	r3, #0
}
 800ef46:	4618      	mov	r0, r3
 800ef48:	b002      	add	sp, #8
 800ef4a:	4770      	bx	lr
 800ef4c:	f3af 8000 	nop.w

0800ef50 <pools1_setup>:

static void pools1_setup(void) {
 800ef50:	b508      	push	{r3, lr}

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
 800ef52:	4803      	ldr	r0, [pc, #12]	; (800ef60 <pools1_setup+0x10>)
 800ef54:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800ef58:	2200      	movs	r2, #0
 800ef5a:	f7f4 fd49 	bl	80039f0 <chPoolObjectInit>
}
 800ef5e:	bd08      	pop	{r3, pc}
 800ef60:	2000089c 	.word	0x2000089c
 800ef64:	f3af 8000 	nop.w
 800ef68:	f3af 8000 	nop.w
 800ef6c:	f3af 8000 	nop.w

0800ef70 <pools1_execute>:

static void pools1_execute(void) {
 800ef70:	b500      	push	{lr}
 800ef72:	b083      	sub	sp, #12
  int i;

  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);
 800ef74:	4b43      	ldr	r3, [pc, #268]	; (800f084 <pools1_execute+0x114>)
 800ef76:	681b      	ldr	r3, [r3, #0]
 800ef78:	4843      	ldr	r0, [pc, #268]	; (800f088 <pools1_execute+0x118>)
 800ef7a:	4619      	mov	r1, r3
 800ef7c:	2205      	movs	r2, #5
 800ef7e:	f7f4 fd47 	bl	8003a10 <chPoolLoadArray>

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
 800ef82:	2300      	movs	r3, #0
 800ef84:	9301      	str	r3, [sp, #4]
 800ef86:	e013      	b.n	800efb0 <pools1_execute+0x40>
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");
 800ef88:	483f      	ldr	r0, [pc, #252]	; (800f088 <pools1_execute+0x118>)
 800ef8a:	f7f4 fd79 	bl	8003a80 <chPoolAlloc>
 800ef8e:	4603      	mov	r3, r0
 800ef90:	2b00      	cmp	r3, #0
 800ef92:	bf0c      	ite	eq
 800ef94:	2300      	moveq	r3, #0
 800ef96:	2301      	movne	r3, #1
 800ef98:	b2db      	uxtb	r3, r3
 800ef9a:	2001      	movs	r0, #1
 800ef9c:	4619      	mov	r1, r3
 800ef9e:	f7fc ff9f 	bl	800bee0 <_test_assert>
 800efa2:	4603      	mov	r3, r0
 800efa4:	2b00      	cmp	r3, #0
 800efa6:	d000      	beq.n	800efaa <pools1_execute+0x3a>
 800efa8:	e068      	b.n	800f07c <pools1_execute+0x10c>

  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
 800efaa:	9b01      	ldr	r3, [sp, #4]
 800efac:	3301      	adds	r3, #1
 800efae:	9301      	str	r3, [sp, #4]
 800efb0:	9b01      	ldr	r3, [sp, #4]
 800efb2:	2b04      	cmp	r3, #4
 800efb4:	dde8      	ble.n	800ef88 <pools1_execute+0x18>
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");
 800efb6:	4834      	ldr	r0, [pc, #208]	; (800f088 <pools1_execute+0x118>)
 800efb8:	f7f4 fd62 	bl	8003a80 <chPoolAlloc>
 800efbc:	4603      	mov	r3, r0
 800efbe:	2b00      	cmp	r3, #0
 800efc0:	bf14      	ite	ne
 800efc2:	2300      	movne	r3, #0
 800efc4:	2301      	moveq	r3, #1
 800efc6:	b2db      	uxtb	r3, r3
 800efc8:	2002      	movs	r0, #2
 800efca:	4619      	mov	r1, r3
 800efcc:	f7fc ff88 	bl	800bee0 <_test_assert>
 800efd0:	4603      	mov	r3, r0
 800efd2:	2b00      	cmp	r3, #0
 800efd4:	d000      	beq.n	800efd8 <pools1_execute+0x68>
 800efd6:	e051      	b.n	800f07c <pools1_execute+0x10c>

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
 800efd8:	2300      	movs	r3, #0
 800efda:	9301      	str	r3, [sp, #4]
 800efdc:	e00a      	b.n	800eff4 <pools1_execute+0x84>
    chPoolFree(&mp1, wa[i]);
 800efde:	4b29      	ldr	r3, [pc, #164]	; (800f084 <pools1_execute+0x114>)
 800efe0:	9a01      	ldr	r2, [sp, #4]
 800efe2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800efe6:	4828      	ldr	r0, [pc, #160]	; (800f088 <pools1_execute+0x118>)
 800efe8:	4619      	mov	r1, r3
 800efea:	f7f4 fd69 	bl	8003ac0 <chPoolFree>

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
 800efee:	9b01      	ldr	r3, [sp, #4]
 800eff0:	3301      	adds	r3, #1
 800eff2:	9301      	str	r3, [sp, #4]
 800eff4:	9b01      	ldr	r3, [sp, #4]
 800eff6:	2b04      	cmp	r3, #4
 800eff8:	ddf1      	ble.n	800efde <pools1_execute+0x6e>
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
 800effa:	2300      	movs	r3, #0
 800effc:	9301      	str	r3, [sp, #4]
 800effe:	e013      	b.n	800f028 <pools1_execute+0xb8>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");
 800f000:	4821      	ldr	r0, [pc, #132]	; (800f088 <pools1_execute+0x118>)
 800f002:	f7f4 fd3d 	bl	8003a80 <chPoolAlloc>
 800f006:	4603      	mov	r3, r0
 800f008:	2b00      	cmp	r3, #0
 800f00a:	bf0c      	ite	eq
 800f00c:	2300      	moveq	r3, #0
 800f00e:	2301      	movne	r3, #1
 800f010:	b2db      	uxtb	r3, r3
 800f012:	2003      	movs	r0, #3
 800f014:	4619      	mov	r1, r3
 800f016:	f7fc ff63 	bl	800bee0 <_test_assert>
 800f01a:	4603      	mov	r3, r0
 800f01c:	2b00      	cmp	r3, #0
 800f01e:	d000      	beq.n	800f022 <pools1_execute+0xb2>
 800f020:	e02c      	b.n	800f07c <pools1_execute+0x10c>
  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
 800f022:	9b01      	ldr	r3, [sp, #4]
 800f024:	3301      	adds	r3, #1
 800f026:	9301      	str	r3, [sp, #4]
 800f028:	9b01      	ldr	r3, [sp, #4]
 800f02a:	2b04      	cmp	r3, #4
 800f02c:	dde8      	ble.n	800f000 <pools1_execute+0x90>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty again.*/
  test_assert(4, chPoolAlloc(&mp1) == NULL, "list not empty");
 800f02e:	4816      	ldr	r0, [pc, #88]	; (800f088 <pools1_execute+0x118>)
 800f030:	f7f4 fd26 	bl	8003a80 <chPoolAlloc>
 800f034:	4603      	mov	r3, r0
 800f036:	2b00      	cmp	r3, #0
 800f038:	bf14      	ite	ne
 800f03a:	2300      	movne	r3, #0
 800f03c:	2301      	moveq	r3, #1
 800f03e:	b2db      	uxtb	r3, r3
 800f040:	2004      	movs	r0, #4
 800f042:	4619      	mov	r1, r3
 800f044:	f7fc ff4c 	bl	800bee0 <_test_assert>
 800f048:	4603      	mov	r3, r0
 800f04a:	2b00      	cmp	r3, #0
 800f04c:	d000      	beq.n	800f050 <pools1_execute+0xe0>
 800f04e:	e015      	b.n	800f07c <pools1_execute+0x10c>

  /* Covering the case where a provider is unable to return more memory.*/
  chPoolObjectInit(&mp1, 16, null_provider);
 800f050:	480d      	ldr	r0, [pc, #52]	; (800f088 <pools1_execute+0x118>)
 800f052:	2110      	movs	r1, #16
 800f054:	4a0d      	ldr	r2, [pc, #52]	; (800f08c <pools1_execute+0x11c>)
 800f056:	f7f4 fccb 	bl	80039f0 <chPoolObjectInit>
  test_assert(5, chPoolAlloc(&mp1) == NULL, "provider returned memory");
 800f05a:	480b      	ldr	r0, [pc, #44]	; (800f088 <pools1_execute+0x118>)
 800f05c:	f7f4 fd10 	bl	8003a80 <chPoolAlloc>
 800f060:	4603      	mov	r3, r0
 800f062:	2b00      	cmp	r3, #0
 800f064:	bf14      	ite	ne
 800f066:	2300      	movne	r3, #0
 800f068:	2301      	moveq	r3, #1
 800f06a:	b2db      	uxtb	r3, r3
 800f06c:	2005      	movs	r0, #5
 800f06e:	4619      	mov	r1, r3
 800f070:	f7fc ff36 	bl	800bee0 <_test_assert>
 800f074:	4603      	mov	r3, r0
 800f076:	2b00      	cmp	r3, #0
 800f078:	d000      	beq.n	800f07c <pools1_execute+0x10c>
 800f07a:	bf00      	nop
}
 800f07c:	b003      	add	sp, #12
 800f07e:	f85d fb04 	ldr.w	pc, [sp], #4
 800f082:	bf00      	nop
 800f084:	08017b20 	.word	0x08017b20
 800f088:	2000089c 	.word	0x2000089c
 800f08c:	0800ef41 	.word	0x0800ef41

0800f090 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800f090:	4b01      	ldr	r3, [pc, #4]	; (800f098 <chThdGetSelfX+0x8>)
 800f092:	699b      	ldr	r3, [r3, #24]
}
 800f094:	4618      	mov	r0, r3
 800f096:	4770      	bx	lr
 800f098:	200016e0 	.word	0x200016e0
 800f09c:	f3af 8000 	nop.w

0800f0a0 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800f0a0:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800f0a2:	f7ff fff5 	bl	800f090 <chThdGetSelfX>
 800f0a6:	4603      	mov	r3, r0
 800f0a8:	689b      	ldr	r3, [r3, #8]
}
 800f0aa:	4618      	mov	r0, r3
 800f0ac:	bd08      	pop	{r3, pc}
 800f0ae:	bf00      	nop

0800f0b0 <thread>:
 * is attempted.<br>
 * The test expects the first two threads to successfully start and the last
 * one to fail.
 */

static THD_FUNCTION(thread, p) {
 800f0b0:	b500      	push	{lr}
 800f0b2:	b083      	sub	sp, #12
 800f0b4:	9001      	str	r0, [sp, #4]

  test_emit_token(*(char *)p);
 800f0b6:	9b01      	ldr	r3, [sp, #4]
 800f0b8:	781b      	ldrb	r3, [r3, #0]
 800f0ba:	4618      	mov	r0, r3
 800f0bc:	f7fc fee0 	bl	800be80 <test_emit_token>
}
 800f0c0:	b003      	add	sp, #12
 800f0c2:	f85d fb04 	ldr.w	pc, [sp], #4
 800f0c6:	bf00      	nop
 800f0c8:	f3af 8000 	nop.w
 800f0cc:	f3af 8000 	nop.w

0800f0d0 <dyn1_setup>:

#if CH_CFG_USE_HEAP || defined(__DOXYGEN__)
static void dyn1_setup(void) {
 800f0d0:	b508      	push	{r3, lr}

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
 800f0d2:	4803      	ldr	r0, [pc, #12]	; (800f0e0 <dyn1_setup+0x10>)
 800f0d4:	4903      	ldr	r1, [pc, #12]	; (800f0e4 <dyn1_setup+0x14>)
 800f0d6:	f44f 62cd 	mov.w	r2, #1640	; 0x668
 800f0da:	f7f4 fb21 	bl	8003720 <chHeapObjectInit>
}
 800f0de:	bd08      	pop	{r3, pc}
 800f0e0:	20000fe8 	.word	0x20000fe8
 800f0e4:	20001bb8 	.word	0x20001bb8
 800f0e8:	f3af 8000 	nop.w
 800f0ec:	f3af 8000 	nop.w

0800f0f0 <dyn1_execute>:

static void dyn1_execute(void) {
 800f0f0:	b500      	push	{lr}
 800f0f2:	b087      	sub	sp, #28
  size_t n, sz;
  void *p1;
  tprio_t prio = chThdGetPriorityX();
 800f0f4:	f7ff ffd4 	bl	800f0a0 <chThdGetPriorityX>
 800f0f8:	9005      	str	r0, [sp, #20]

  (void)chHeapStatus(&heap1, &sz);
 800f0fa:	ab02      	add	r3, sp, #8
 800f0fc:	4846      	ldr	r0, [pc, #280]	; (800f218 <dyn1_execute+0x128>)
 800f0fe:	4619      	mov	r1, r3
 800f100:	f7f4 fc0e 	bl	8003920 <chHeapStatus>
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
 800f104:	9b05      	ldr	r3, [sp, #20]
 800f106:	3b01      	subs	r3, #1
 800f108:	4a44      	ldr	r2, [pc, #272]	; (800f21c <dyn1_execute+0x12c>)
 800f10a:	9200      	str	r2, [sp, #0]
 800f10c:	4842      	ldr	r0, [pc, #264]	; (800f218 <dyn1_execute+0x128>)
 800f10e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f112:	461a      	mov	r2, r3
 800f114:	4b42      	ldr	r3, [pc, #264]	; (800f220 <dyn1_execute+0x130>)
 800f116:	f7f2 fb9b 	bl	8001850 <chThdCreateFromHeap>
 800f11a:	4602      	mov	r2, r0
 800f11c:	4b41      	ldr	r3, [pc, #260]	; (800f224 <dyn1_execute+0x134>)
 800f11e:	601a      	str	r2, [r3, #0]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 800f120:	9b05      	ldr	r3, [sp, #20]
 800f122:	3b02      	subs	r3, #2
 800f124:	4a40      	ldr	r2, [pc, #256]	; (800f228 <dyn1_execute+0x138>)
 800f126:	9200      	str	r2, [sp, #0]
 800f128:	483b      	ldr	r0, [pc, #236]	; (800f218 <dyn1_execute+0x128>)
 800f12a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f12e:	461a      	mov	r2, r3
 800f130:	4b3b      	ldr	r3, [pc, #236]	; (800f220 <dyn1_execute+0x130>)
 800f132:	f7f2 fb8d 	bl	8001850 <chThdCreateFromHeap>
 800f136:	4602      	mov	r2, r0
 800f138:	4b3a      	ldr	r3, [pc, #232]	; (800f224 <dyn1_execute+0x134>)
 800f13a:	605a      	str	r2, [r3, #4]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
 800f13c:	ab03      	add	r3, sp, #12
 800f13e:	4836      	ldr	r0, [pc, #216]	; (800f218 <dyn1_execute+0x128>)
 800f140:	4619      	mov	r1, r3
 800f142:	f7f4 fbed 	bl	8003920 <chHeapStatus>
  p1 = chHeapAlloc(&heap1, n);
 800f146:	9b03      	ldr	r3, [sp, #12]
 800f148:	4833      	ldr	r0, [pc, #204]	; (800f218 <dyn1_execute+0x128>)
 800f14a:	4619      	mov	r1, r3
 800f14c:	f7f4 fb08 	bl	8003760 <chHeapAlloc>
 800f150:	9004      	str	r0, [sp, #16]
  threads[2] = chThdCreateFromHeap(&heap1,
 800f152:	9b05      	ldr	r3, [sp, #20]
 800f154:	3b03      	subs	r3, #3
 800f156:	4a35      	ldr	r2, [pc, #212]	; (800f22c <dyn1_execute+0x13c>)
 800f158:	9200      	str	r2, [sp, #0]
 800f15a:	482f      	ldr	r0, [pc, #188]	; (800f218 <dyn1_execute+0x128>)
 800f15c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f160:	461a      	mov	r2, r3
 800f162:	4b2f      	ldr	r3, [pc, #188]	; (800f220 <dyn1_execute+0x130>)
 800f164:	f7f2 fb74 	bl	8001850 <chThdCreateFromHeap>
 800f168:	4602      	mov	r2, r0
 800f16a:	4b2e      	ldr	r3, [pc, #184]	; (800f224 <dyn1_execute+0x134>)
 800f16c:	609a      	str	r2, [r3, #8]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-3, thread, "C");
  chHeapFree(p1);
 800f16e:	9804      	ldr	r0, [sp, #16]
 800f170:	f7f4 fb6e 	bl	8003850 <chHeapFree>

  test_assert(1, (threads[0] != NULL) &&
 800f174:	4b2b      	ldr	r3, [pc, #172]	; (800f224 <dyn1_execute+0x134>)
 800f176:	681b      	ldr	r3, [r3, #0]
 800f178:	2b00      	cmp	r3, #0
 800f17a:	d011      	beq.n	800f1a0 <dyn1_execute+0xb0>
 800f17c:	4b29      	ldr	r3, [pc, #164]	; (800f224 <dyn1_execute+0x134>)
 800f17e:	685b      	ldr	r3, [r3, #4]
 800f180:	2b00      	cmp	r3, #0
 800f182:	d00d      	beq.n	800f1a0 <dyn1_execute+0xb0>
 800f184:	4b27      	ldr	r3, [pc, #156]	; (800f224 <dyn1_execute+0x134>)
 800f186:	689b      	ldr	r3, [r3, #8]
 800f188:	2b00      	cmp	r3, #0
 800f18a:	d109      	bne.n	800f1a0 <dyn1_execute+0xb0>
 800f18c:	4b25      	ldr	r3, [pc, #148]	; (800f224 <dyn1_execute+0x134>)
 800f18e:	68db      	ldr	r3, [r3, #12]
 800f190:	2b00      	cmp	r3, #0
 800f192:	d105      	bne.n	800f1a0 <dyn1_execute+0xb0>
 800f194:	4b23      	ldr	r3, [pc, #140]	; (800f224 <dyn1_execute+0x134>)
 800f196:	691b      	ldr	r3, [r3, #16]
 800f198:	2b00      	cmp	r3, #0
 800f19a:	d101      	bne.n	800f1a0 <dyn1_execute+0xb0>
 800f19c:	2301      	movs	r3, #1
 800f19e:	e000      	b.n	800f1a2 <dyn1_execute+0xb2>
 800f1a0:	2300      	movs	r3, #0
 800f1a2:	f003 0301 	and.w	r3, r3, #1
 800f1a6:	b2db      	uxtb	r3, r3
 800f1a8:	2001      	movs	r0, #1
 800f1aa:	4619      	mov	r1, r3
 800f1ac:	f7fc fe98 	bl	800bee0 <_test_assert>
 800f1b0:	4603      	mov	r3, r0
 800f1b2:	2b00      	cmp	r3, #0
 800f1b4:	d000      	beq.n	800f1b8 <dyn1_execute+0xc8>
 800f1b6:	e02b      	b.n	800f210 <dyn1_execute+0x120>
                 (threads[3] == NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 800f1b8:	f7fc ff12 	bl	800bfe0 <test_wait_threads>
  test_assert_sequence(2, "AB");
 800f1bc:	2002      	movs	r0, #2
 800f1be:	491c      	ldr	r1, [pc, #112]	; (800f230 <dyn1_execute+0x140>)
 800f1c0:	f7fc fea6 	bl	800bf10 <_test_assert_sequence>
 800f1c4:	4603      	mov	r3, r0
 800f1c6:	2b00      	cmp	r3, #0
 800f1c8:	d000      	beq.n	800f1cc <dyn1_execute+0xdc>
 800f1ca:	e021      	b.n	800f210 <dyn1_execute+0x120>

  /* Heap status checked again.*/
  test_assert(3, chHeapStatus(&heap1, &n) == 1, "heap fragmented");
 800f1cc:	ab03      	add	r3, sp, #12
 800f1ce:	4812      	ldr	r0, [pc, #72]	; (800f218 <dyn1_execute+0x128>)
 800f1d0:	4619      	mov	r1, r3
 800f1d2:	f7f4 fba5 	bl	8003920 <chHeapStatus>
 800f1d6:	4603      	mov	r3, r0
 800f1d8:	2b01      	cmp	r3, #1
 800f1da:	bf14      	ite	ne
 800f1dc:	2300      	movne	r3, #0
 800f1de:	2301      	moveq	r3, #1
 800f1e0:	b2db      	uxtb	r3, r3
 800f1e2:	2003      	movs	r0, #3
 800f1e4:	4619      	mov	r1, r3
 800f1e6:	f7fc fe7b 	bl	800bee0 <_test_assert>
 800f1ea:	4603      	mov	r3, r0
 800f1ec:	2b00      	cmp	r3, #0
 800f1ee:	d000      	beq.n	800f1f2 <dyn1_execute+0x102>
 800f1f0:	e00e      	b.n	800f210 <dyn1_execute+0x120>
  test_assert(4, n == sz, "heap size changed");
 800f1f2:	9a03      	ldr	r2, [sp, #12]
 800f1f4:	9b02      	ldr	r3, [sp, #8]
 800f1f6:	429a      	cmp	r2, r3
 800f1f8:	bf14      	ite	ne
 800f1fa:	2300      	movne	r3, #0
 800f1fc:	2301      	moveq	r3, #1
 800f1fe:	b2db      	uxtb	r3, r3
 800f200:	2004      	movs	r0, #4
 800f202:	4619      	mov	r1, r3
 800f204:	f7fc fe6c 	bl	800bee0 <_test_assert>
 800f208:	4603      	mov	r3, r0
 800f20a:	2b00      	cmp	r3, #0
 800f20c:	d000      	beq.n	800f210 <dyn1_execute+0x120>
 800f20e:	bf00      	nop
}
 800f210:	b007      	add	sp, #28
 800f212:	f85d fb04 	ldr.w	pc, [sp], #4
 800f216:	bf00      	nop
 800f218:	20000fe8 	.word	0x20000fe8
 800f21c:	080181c0 	.word	0x080181c0
 800f220:	0800f0b1 	.word	0x0800f0b1
 800f224:	20001ba4 	.word	0x20001ba4
 800f228:	080181c4 	.word	0x080181c4
 800f22c:	080181c8 	.word	0x080181c8
 800f230:	080181cc 	.word	0x080181cc
 800f234:	f3af 8000 	nop.w
 800f238:	f3af 8000 	nop.w
 800f23c:	f3af 8000 	nop.w

0800f240 <dyn2_setup>:
 * elements.<br>
 * The test expects the first four threads to successfully start and the last
 * one to fail.
 */

static void dyn2_setup(void) {
 800f240:	b508      	push	{r3, lr}

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
 800f242:	4803      	ldr	r0, [pc, #12]	; (800f250 <dyn2_setup+0x10>)
 800f244:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f248:	2200      	movs	r2, #0
 800f24a:	f7f4 fbd1 	bl	80039f0 <chPoolObjectInit>
}
 800f24e:	bd08      	pop	{r3, pc}
 800f250:	20001008 	.word	0x20001008
 800f254:	f3af 8000 	nop.w
 800f258:	f3af 8000 	nop.w
 800f25c:	f3af 8000 	nop.w

0800f260 <dyn2_execute>:

static void dyn2_execute(void) {
 800f260:	b500      	push	{lr}
 800f262:	b083      	sub	sp, #12
  int i;
  tprio_t prio = chThdGetPriorityX();
 800f264:	f7ff ff1c 	bl	800f0a0 <chThdGetPriorityX>
 800f268:	9000      	str	r0, [sp, #0]

  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
 800f26a:	2300      	movs	r3, #0
 800f26c:	9301      	str	r3, [sp, #4]
 800f26e:	e00a      	b.n	800f286 <dyn2_execute+0x26>
    chPoolFree(&mp1, wa[i]);
 800f270:	4b4f      	ldr	r3, [pc, #316]	; (800f3b0 <dyn2_execute+0x150>)
 800f272:	9a01      	ldr	r2, [sp, #4]
 800f274:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800f278:	484e      	ldr	r0, [pc, #312]	; (800f3b4 <dyn2_execute+0x154>)
 800f27a:	4619      	mov	r1, r3
 800f27c:	f7f4 fc20 	bl	8003ac0 <chPoolFree>
static void dyn2_execute(void) {
  int i;
  tprio_t prio = chThdGetPriorityX();

  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
 800f280:	9b01      	ldr	r3, [sp, #4]
 800f282:	3301      	adds	r3, #1
 800f284:	9301      	str	r3, [sp, #4]
 800f286:	9b01      	ldr	r3, [sp, #4]
 800f288:	2b03      	cmp	r3, #3
 800f28a:	ddf1      	ble.n	800f270 <dyn2_execute+0x10>
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
 800f28c:	9b00      	ldr	r3, [sp, #0]
 800f28e:	3b01      	subs	r3, #1
 800f290:	4848      	ldr	r0, [pc, #288]	; (800f3b4 <dyn2_execute+0x154>)
 800f292:	4619      	mov	r1, r3
 800f294:	4a48      	ldr	r2, [pc, #288]	; (800f3b8 <dyn2_execute+0x158>)
 800f296:	4b49      	ldr	r3, [pc, #292]	; (800f3bc <dyn2_execute+0x15c>)
 800f298:	f7f2 fb0a 	bl	80018b0 <chThdCreateFromMemoryPool>
 800f29c:	4602      	mov	r2, r0
 800f29e:	4b48      	ldr	r3, [pc, #288]	; (800f3c0 <dyn2_execute+0x160>)
 800f2a0:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 800f2a2:	9b00      	ldr	r3, [sp, #0]
 800f2a4:	3b02      	subs	r3, #2
 800f2a6:	4843      	ldr	r0, [pc, #268]	; (800f3b4 <dyn2_execute+0x154>)
 800f2a8:	4619      	mov	r1, r3
 800f2aa:	4a43      	ldr	r2, [pc, #268]	; (800f3b8 <dyn2_execute+0x158>)
 800f2ac:	4b45      	ldr	r3, [pc, #276]	; (800f3c4 <dyn2_execute+0x164>)
 800f2ae:	f7f2 faff 	bl	80018b0 <chThdCreateFromMemoryPool>
 800f2b2:	4602      	mov	r2, r0
 800f2b4:	4b42      	ldr	r3, [pc, #264]	; (800f3c0 <dyn2_execute+0x160>)
 800f2b6:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 800f2b8:	9b00      	ldr	r3, [sp, #0]
 800f2ba:	3b03      	subs	r3, #3
 800f2bc:	483d      	ldr	r0, [pc, #244]	; (800f3b4 <dyn2_execute+0x154>)
 800f2be:	4619      	mov	r1, r3
 800f2c0:	4a3d      	ldr	r2, [pc, #244]	; (800f3b8 <dyn2_execute+0x158>)
 800f2c2:	4b41      	ldr	r3, [pc, #260]	; (800f3c8 <dyn2_execute+0x168>)
 800f2c4:	f7f2 faf4 	bl	80018b0 <chThdCreateFromMemoryPool>
 800f2c8:	4602      	mov	r2, r0
 800f2ca:	4b3d      	ldr	r3, [pc, #244]	; (800f3c0 <dyn2_execute+0x160>)
 800f2cc:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 800f2ce:	9b00      	ldr	r3, [sp, #0]
 800f2d0:	3b04      	subs	r3, #4
 800f2d2:	4838      	ldr	r0, [pc, #224]	; (800f3b4 <dyn2_execute+0x154>)
 800f2d4:	4619      	mov	r1, r3
 800f2d6:	4a38      	ldr	r2, [pc, #224]	; (800f3b8 <dyn2_execute+0x158>)
 800f2d8:	4b3c      	ldr	r3, [pc, #240]	; (800f3cc <dyn2_execute+0x16c>)
 800f2da:	f7f2 fae9 	bl	80018b0 <chThdCreateFromMemoryPool>
 800f2de:	4602      	mov	r2, r0
 800f2e0:	4b37      	ldr	r3, [pc, #220]	; (800f3c0 <dyn2_execute+0x160>)
 800f2e2:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 800f2e4:	9b00      	ldr	r3, [sp, #0]
 800f2e6:	3b05      	subs	r3, #5
 800f2e8:	4832      	ldr	r0, [pc, #200]	; (800f3b4 <dyn2_execute+0x154>)
 800f2ea:	4619      	mov	r1, r3
 800f2ec:	4a32      	ldr	r2, [pc, #200]	; (800f3b8 <dyn2_execute+0x158>)
 800f2ee:	4b38      	ldr	r3, [pc, #224]	; (800f3d0 <dyn2_execute+0x170>)
 800f2f0:	f7f2 fade 	bl	80018b0 <chThdCreateFromMemoryPool>
 800f2f4:	4602      	mov	r2, r0
 800f2f6:	4b32      	ldr	r3, [pc, #200]	; (800f3c0 <dyn2_execute+0x160>)
 800f2f8:	611a      	str	r2, [r3, #16]

  test_assert(1, (threads[0] != NULL) &&
 800f2fa:	4b31      	ldr	r3, [pc, #196]	; (800f3c0 <dyn2_execute+0x160>)
 800f2fc:	681b      	ldr	r3, [r3, #0]
 800f2fe:	2b00      	cmp	r3, #0
 800f300:	d011      	beq.n	800f326 <dyn2_execute+0xc6>
 800f302:	4b2f      	ldr	r3, [pc, #188]	; (800f3c0 <dyn2_execute+0x160>)
 800f304:	685b      	ldr	r3, [r3, #4]
 800f306:	2b00      	cmp	r3, #0
 800f308:	d00d      	beq.n	800f326 <dyn2_execute+0xc6>
 800f30a:	4b2d      	ldr	r3, [pc, #180]	; (800f3c0 <dyn2_execute+0x160>)
 800f30c:	689b      	ldr	r3, [r3, #8]
 800f30e:	2b00      	cmp	r3, #0
 800f310:	d009      	beq.n	800f326 <dyn2_execute+0xc6>
 800f312:	4b2b      	ldr	r3, [pc, #172]	; (800f3c0 <dyn2_execute+0x160>)
 800f314:	68db      	ldr	r3, [r3, #12]
 800f316:	2b00      	cmp	r3, #0
 800f318:	d005      	beq.n	800f326 <dyn2_execute+0xc6>
 800f31a:	4b29      	ldr	r3, [pc, #164]	; (800f3c0 <dyn2_execute+0x160>)
 800f31c:	691b      	ldr	r3, [r3, #16]
 800f31e:	2b00      	cmp	r3, #0
 800f320:	d101      	bne.n	800f326 <dyn2_execute+0xc6>
 800f322:	2301      	movs	r3, #1
 800f324:	e000      	b.n	800f328 <dyn2_execute+0xc8>
 800f326:	2300      	movs	r3, #0
 800f328:	f003 0301 	and.w	r3, r3, #1
 800f32c:	b2db      	uxtb	r3, r3
 800f32e:	2001      	movs	r0, #1
 800f330:	4619      	mov	r1, r3
 800f332:	f7fc fdd5 	bl	800bee0 <_test_assert>
 800f336:	4603      	mov	r3, r0
 800f338:	2b00      	cmp	r3, #0
 800f33a:	d000      	beq.n	800f33e <dyn2_execute+0xde>
 800f33c:	e034      	b.n	800f3a8 <dyn2_execute+0x148>
                 (threads[3] != NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 800f33e:	f7fc fe4f 	bl	800bfe0 <test_wait_threads>
  test_assert_sequence(2, "ABCD");
 800f342:	2002      	movs	r0, #2
 800f344:	4923      	ldr	r1, [pc, #140]	; (800f3d4 <dyn2_execute+0x174>)
 800f346:	f7fc fde3 	bl	800bf10 <_test_assert_sequence>
 800f34a:	4603      	mov	r3, r0
 800f34c:	2b00      	cmp	r3, #0
 800f34e:	d000      	beq.n	800f352 <dyn2_execute+0xf2>
 800f350:	e02a      	b.n	800f3a8 <dyn2_execute+0x148>

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
 800f352:	2300      	movs	r3, #0
 800f354:	9301      	str	r3, [sp, #4]
 800f356:	e013      	b.n	800f380 <dyn2_execute+0x120>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
 800f358:	4816      	ldr	r0, [pc, #88]	; (800f3b4 <dyn2_execute+0x154>)
 800f35a:	f7f4 fb91 	bl	8003a80 <chPoolAlloc>
 800f35e:	4603      	mov	r3, r0
 800f360:	2b00      	cmp	r3, #0
 800f362:	bf0c      	ite	eq
 800f364:	2300      	moveq	r3, #0
 800f366:	2301      	movne	r3, #1
 800f368:	b2db      	uxtb	r3, r3
 800f36a:	2003      	movs	r0, #3
 800f36c:	4619      	mov	r1, r3
 800f36e:	f7fc fdb7 	bl	800bee0 <_test_assert>
 800f372:	4603      	mov	r3, r0
 800f374:	2b00      	cmp	r3, #0
 800f376:	d000      	beq.n	800f37a <dyn2_execute+0x11a>
 800f378:	e016      	b.n	800f3a8 <dyn2_execute+0x148>
  /* Claiming the memory from terminated threads. */
  test_wait_threads();
  test_assert_sequence(2, "ABCD");

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
 800f37a:	9b01      	ldr	r3, [sp, #4]
 800f37c:	3301      	adds	r3, #1
 800f37e:	9301      	str	r3, [sp, #4]
 800f380:	9b01      	ldr	r3, [sp, #4]
 800f382:	2b03      	cmp	r3, #3
 800f384:	dde8      	ble.n	800f358 <dyn2_execute+0xf8>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
  test_assert(4, chPoolAlloc(&mp1) == NULL, "pool list not empty");
 800f386:	480b      	ldr	r0, [pc, #44]	; (800f3b4 <dyn2_execute+0x154>)
 800f388:	f7f4 fb7a 	bl	8003a80 <chPoolAlloc>
 800f38c:	4603      	mov	r3, r0
 800f38e:	2b00      	cmp	r3, #0
 800f390:	bf14      	ite	ne
 800f392:	2300      	movne	r3, #0
 800f394:	2301      	moveq	r3, #1
 800f396:	b2db      	uxtb	r3, r3
 800f398:	2004      	movs	r0, #4
 800f39a:	4619      	mov	r1, r3
 800f39c:	f7fc fda0 	bl	800bee0 <_test_assert>
 800f3a0:	4603      	mov	r3, r0
 800f3a2:	2b00      	cmp	r3, #0
 800f3a4:	d000      	beq.n	800f3a8 <dyn2_execute+0x148>
 800f3a6:	bf00      	nop
}
 800f3a8:	b003      	add	sp, #12
 800f3aa:	f85d fb04 	ldr.w	pc, [sp], #4
 800f3ae:	bf00      	nop
 800f3b0:	08017b20 	.word	0x08017b20
 800f3b4:	20001008 	.word	0x20001008
 800f3b8:	0800f0b1 	.word	0x0800f0b1
 800f3bc:	080181c0 	.word	0x080181c0
 800f3c0:	20001ba4 	.word	0x20001ba4
 800f3c4:	080181c4 	.word	0x080181c4
 800f3c8:	080181c8 	.word	0x080181c8
 800f3cc:	0801820c 	.word	0x0801820c
 800f3d0:	08018210 	.word	0x08018210
 800f3d4:	08018214 	.word	0x08018214
 800f3d8:	f3af 8000 	nop.w
 800f3dc:	f3af 8000 	nop.w

0800f3e0 <regfind>:
 * <h2>Description</h2>
 * Registry and Thread References APIs are tested for functionality and
 * coverage.
 */

static bool regfind(thread_t *tp) {
 800f3e0:	b500      	push	{lr}
 800f3e2:	b085      	sub	sp, #20
 800f3e4:	9001      	str	r0, [sp, #4]
  thread_t *ftp;
  bool found = false;
 800f3e6:	2300      	movs	r3, #0
 800f3e8:	f88d 300b 	strb.w	r3, [sp, #11]

  ftp = chRegFirstThread();
 800f3ec:	f7f2 fab0 	bl	8001950 <chRegFirstThread>
 800f3f0:	9003      	str	r0, [sp, #12]
  do {
    found |= ftp == tp;
 800f3f2:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800f3f6:	9903      	ldr	r1, [sp, #12]
 800f3f8:	9b01      	ldr	r3, [sp, #4]
 800f3fa:	4299      	cmp	r1, r3
 800f3fc:	bf14      	ite	ne
 800f3fe:	2300      	movne	r3, #0
 800f400:	2301      	moveq	r3, #1
 800f402:	b2db      	uxtb	r3, r3
 800f404:	4313      	orrs	r3, r2
 800f406:	2b00      	cmp	r3, #0
 800f408:	bf0c      	ite	eq
 800f40a:	2300      	moveq	r3, #0
 800f40c:	2301      	movne	r3, #1
 800f40e:	f88d 300b 	strb.w	r3, [sp, #11]
    ftp = chRegNextThread(ftp);
 800f412:	9803      	ldr	r0, [sp, #12]
 800f414:	f7f2 fab4 	bl	8001980 <chRegNextThread>
 800f418:	9003      	str	r0, [sp, #12]
  } while (ftp != NULL);
 800f41a:	9b03      	ldr	r3, [sp, #12]
 800f41c:	2b00      	cmp	r3, #0
 800f41e:	d1e8      	bne.n	800f3f2 <regfind+0x12>
  return found;
 800f420:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 800f424:	4618      	mov	r0, r3
 800f426:	b005      	add	sp, #20
 800f428:	f85d fb04 	ldr.w	pc, [sp], #4
 800f42c:	f3af 8000 	nop.w

0800f430 <dyn3_setup>:

static void dyn3_setup(void) {
 800f430:	b508      	push	{r3, lr}

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
 800f432:	4803      	ldr	r0, [pc, #12]	; (800f440 <dyn3_setup+0x10>)
 800f434:	4903      	ldr	r1, [pc, #12]	; (800f444 <dyn3_setup+0x14>)
 800f436:	f44f 62cd 	mov.w	r2, #1640	; 0x668
 800f43a:	f7f4 f971 	bl	8003720 <chHeapObjectInit>
}
 800f43e:	bd08      	pop	{r3, pc}
 800f440:	20000fe8 	.word	0x20000fe8
 800f444:	20001bb8 	.word	0x20001bb8
 800f448:	f3af 8000 	nop.w
 800f44c:	f3af 8000 	nop.w

0800f450 <dyn3_execute>:

static void dyn3_execute(void) {
 800f450:	b500      	push	{lr}
 800f452:	b085      	sub	sp, #20
  thread_t *tp;
  tprio_t prio = chThdGetPriorityX();
 800f454:	f7ff fe24 	bl	800f0a0 <chThdGetPriorityX>
 800f458:	9003      	str	r0, [sp, #12]

  /* Testing references increase/decrease and final detach.*/
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
 800f45a:	9b03      	ldr	r3, [sp, #12]
 800f45c:	3b01      	subs	r3, #1
 800f45e:	4a63      	ldr	r2, [pc, #396]	; (800f5ec <dyn3_execute+0x19c>)
 800f460:	9200      	str	r2, [sp, #0]
 800f462:	4863      	ldr	r0, [pc, #396]	; (800f5f0 <dyn3_execute+0x1a0>)
 800f464:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f468:	461a      	mov	r2, r3
 800f46a:	4b62      	ldr	r3, [pc, #392]	; (800f5f4 <dyn3_execute+0x1a4>)
 800f46c:	f7f2 f9f0 	bl	8001850 <chThdCreateFromHeap>
 800f470:	9002      	str	r0, [sp, #8]
  test_assert(1, tp->p_refs == 1, "wrong initial reference counter");
 800f472:	9b02      	ldr	r3, [sp, #8]
 800f474:	7f9b      	ldrb	r3, [r3, #30]
 800f476:	2b01      	cmp	r3, #1
 800f478:	bf14      	ite	ne
 800f47a:	2300      	movne	r3, #0
 800f47c:	2301      	moveq	r3, #1
 800f47e:	b2db      	uxtb	r3, r3
 800f480:	2001      	movs	r0, #1
 800f482:	4619      	mov	r1, r3
 800f484:	f7fc fd2c 	bl	800bee0 <_test_assert>
 800f488:	4603      	mov	r3, r0
 800f48a:	2b00      	cmp	r3, #0
 800f48c:	d000      	beq.n	800f490 <dyn3_execute+0x40>
 800f48e:	e0a9      	b.n	800f5e4 <dyn3_execute+0x194>
  chThdAddRef(tp);
 800f490:	9802      	ldr	r0, [sp, #8]
 800f492:	f7f2 f97d 	bl	8001790 <chThdAddRef>
  test_assert(2, tp->p_refs == 2, "references increase failure");
 800f496:	9b02      	ldr	r3, [sp, #8]
 800f498:	7f9b      	ldrb	r3, [r3, #30]
 800f49a:	2b02      	cmp	r3, #2
 800f49c:	bf14      	ite	ne
 800f49e:	2300      	movne	r3, #0
 800f4a0:	2301      	moveq	r3, #1
 800f4a2:	b2db      	uxtb	r3, r3
 800f4a4:	2002      	movs	r0, #2
 800f4a6:	4619      	mov	r1, r3
 800f4a8:	f7fc fd1a 	bl	800bee0 <_test_assert>
 800f4ac:	4603      	mov	r3, r0
 800f4ae:	2b00      	cmp	r3, #0
 800f4b0:	d000      	beq.n	800f4b4 <dyn3_execute+0x64>
 800f4b2:	e097      	b.n	800f5e4 <dyn3_execute+0x194>
  chThdRelease(tp);
 800f4b4:	9802      	ldr	r0, [sp, #8]
 800f4b6:	f7f2 f983 	bl	80017c0 <chThdRelease>
  test_assert(3, tp->p_refs == 1, "references decrease failure");
 800f4ba:	9b02      	ldr	r3, [sp, #8]
 800f4bc:	7f9b      	ldrb	r3, [r3, #30]
 800f4be:	2b01      	cmp	r3, #1
 800f4c0:	bf14      	ite	ne
 800f4c2:	2300      	movne	r3, #0
 800f4c4:	2301      	moveq	r3, #1
 800f4c6:	b2db      	uxtb	r3, r3
 800f4c8:	2003      	movs	r0, #3
 800f4ca:	4619      	mov	r1, r3
 800f4cc:	f7fc fd08 	bl	800bee0 <_test_assert>
 800f4d0:	4603      	mov	r3, r0
 800f4d2:	2b00      	cmp	r3, #0
 800f4d4:	d000      	beq.n	800f4d8 <dyn3_execute+0x88>
 800f4d6:	e085      	b.n	800f5e4 <dyn3_execute+0x194>

  /* Verify the new threads count.*/
  test_assert(4, regfind(tp), "thread missing from registry");
 800f4d8:	9802      	ldr	r0, [sp, #8]
 800f4da:	f7ff ff81 	bl	800f3e0 <regfind>
 800f4de:	4603      	mov	r3, r0
 800f4e0:	2004      	movs	r0, #4
 800f4e2:	4619      	mov	r1, r3
 800f4e4:	f7fc fcfc 	bl	800bee0 <_test_assert>
 800f4e8:	4603      	mov	r3, r0
 800f4ea:	2b00      	cmp	r3, #0
 800f4ec:	d000      	beq.n	800f4f0 <dyn3_execute+0xa0>
 800f4ee:	e079      	b.n	800f5e4 <dyn3_execute+0x194>
  test_assert(5, regfind(tp), "thread disappeared");
 800f4f0:	9802      	ldr	r0, [sp, #8]
 800f4f2:	f7ff ff75 	bl	800f3e0 <regfind>
 800f4f6:	4603      	mov	r3, r0
 800f4f8:	2005      	movs	r0, #5
 800f4fa:	4619      	mov	r1, r3
 800f4fc:	f7fc fcf0 	bl	800bee0 <_test_assert>
 800f500:	4603      	mov	r3, r0
 800f502:	2b00      	cmp	r3, #0
 800f504:	d000      	beq.n	800f508 <dyn3_execute+0xb8>
 800f506:	e06d      	b.n	800f5e4 <dyn3_execute+0x194>

  /* Detach and let the thread execute and terminate.*/
  chThdRelease(tp);
 800f508:	9802      	ldr	r0, [sp, #8]
 800f50a:	f7f2 f959 	bl	80017c0 <chThdRelease>
  test_assert(6, tp->p_refs == 0, "detach failure");
 800f50e:	9b02      	ldr	r3, [sp, #8]
 800f510:	7f9b      	ldrb	r3, [r3, #30]
 800f512:	2b00      	cmp	r3, #0
 800f514:	bf14      	ite	ne
 800f516:	2300      	movne	r3, #0
 800f518:	2301      	moveq	r3, #1
 800f51a:	b2db      	uxtb	r3, r3
 800f51c:	2006      	movs	r0, #6
 800f51e:	4619      	mov	r1, r3
 800f520:	f7fc fcde 	bl	800bee0 <_test_assert>
 800f524:	4603      	mov	r3, r0
 800f526:	2b00      	cmp	r3, #0
 800f528:	d000      	beq.n	800f52c <dyn3_execute+0xdc>
 800f52a:	e05b      	b.n	800f5e4 <dyn3_execute+0x194>
  test_assert(7, tp->p_state == CH_STATE_READY, "invalid state");
 800f52c:	9b02      	ldr	r3, [sp, #8]
 800f52e:	7f1b      	ldrb	r3, [r3, #28]
 800f530:	2b00      	cmp	r3, #0
 800f532:	bf14      	ite	ne
 800f534:	2300      	movne	r3, #0
 800f536:	2301      	moveq	r3, #1
 800f538:	b2db      	uxtb	r3, r3
 800f53a:	2007      	movs	r0, #7
 800f53c:	4619      	mov	r1, r3
 800f53e:	f7fc fccf 	bl	800bee0 <_test_assert>
 800f542:	4603      	mov	r3, r0
 800f544:	2b00      	cmp	r3, #0
 800f546:	d000      	beq.n	800f54a <dyn3_execute+0xfa>
 800f548:	e04c      	b.n	800f5e4 <dyn3_execute+0x194>
  test_assert(8, regfind(tp), "thread disappeared");
 800f54a:	9802      	ldr	r0, [sp, #8]
 800f54c:	f7ff ff48 	bl	800f3e0 <regfind>
 800f550:	4603      	mov	r3, r0
 800f552:	2008      	movs	r0, #8
 800f554:	4619      	mov	r1, r3
 800f556:	f7fc fcc3 	bl	800bee0 <_test_assert>
 800f55a:	4603      	mov	r3, r0
 800f55c:	2b00      	cmp	r3, #0
 800f55e:	d000      	beq.n	800f562 <dyn3_execute+0x112>
 800f560:	e040      	b.n	800f5e4 <dyn3_execute+0x194>
  test_assert(9, regfind(tp), "thread disappeared");
 800f562:	9802      	ldr	r0, [sp, #8]
 800f564:	f7ff ff3c 	bl	800f3e0 <regfind>
 800f568:	4603      	mov	r3, r0
 800f56a:	2009      	movs	r0, #9
 800f56c:	4619      	mov	r1, r3
 800f56e:	f7fc fcb7 	bl	800bee0 <_test_assert>
 800f572:	4603      	mov	r3, r0
 800f574:	2b00      	cmp	r3, #0
 800f576:	d000      	beq.n	800f57a <dyn3_execute+0x12a>
 800f578:	e034      	b.n	800f5e4 <dyn3_execute+0x194>
  chThdSleepMilliseconds(50);           /* The thread just terminates.      */
 800f57a:	2032      	movs	r0, #50	; 0x32
 800f57c:	f7f1 fea8 	bl	80012d0 <chThdSleep>
  test_assert(10, tp->p_state == CH_STATE_FINAL, "invalid state");
 800f580:	9b02      	ldr	r3, [sp, #8]
 800f582:	7f1b      	ldrb	r3, [r3, #28]
 800f584:	2b0f      	cmp	r3, #15
 800f586:	bf14      	ite	ne
 800f588:	2300      	movne	r3, #0
 800f58a:	2301      	moveq	r3, #1
 800f58c:	b2db      	uxtb	r3, r3
 800f58e:	200a      	movs	r0, #10
 800f590:	4619      	mov	r1, r3
 800f592:	f7fc fca5 	bl	800bee0 <_test_assert>
 800f596:	4603      	mov	r3, r0
 800f598:	2b00      	cmp	r3, #0
 800f59a:	d000      	beq.n	800f59e <dyn3_execute+0x14e>
 800f59c:	e022      	b.n	800f5e4 <dyn3_execute+0x194>

  /* Clearing the zombie by scanning the registry.*/
  test_assert(11, regfind(tp), "thread disappeared");
 800f59e:	9802      	ldr	r0, [sp, #8]
 800f5a0:	f7ff ff1e 	bl	800f3e0 <regfind>
 800f5a4:	4603      	mov	r3, r0
 800f5a6:	200b      	movs	r0, #11
 800f5a8:	4619      	mov	r1, r3
 800f5aa:	f7fc fc99 	bl	800bee0 <_test_assert>
 800f5ae:	4603      	mov	r3, r0
 800f5b0:	2b00      	cmp	r3, #0
 800f5b2:	d000      	beq.n	800f5b6 <dyn3_execute+0x166>
 800f5b4:	e016      	b.n	800f5e4 <dyn3_execute+0x194>
  test_assert(12, !regfind(tp), "thread still in registry");
 800f5b6:	9802      	ldr	r0, [sp, #8]
 800f5b8:	f7ff ff12 	bl	800f3e0 <regfind>
 800f5bc:	4603      	mov	r3, r0
 800f5be:	2b00      	cmp	r3, #0
 800f5c0:	bf0c      	ite	eq
 800f5c2:	2300      	moveq	r3, #0
 800f5c4:	2301      	movne	r3, #1
 800f5c6:	b2db      	uxtb	r3, r3
 800f5c8:	f083 0301 	eor.w	r3, r3, #1
 800f5cc:	b2db      	uxtb	r3, r3
 800f5ce:	f003 0301 	and.w	r3, r3, #1
 800f5d2:	b2db      	uxtb	r3, r3
 800f5d4:	200c      	movs	r0, #12
 800f5d6:	4619      	mov	r1, r3
 800f5d8:	f7fc fc82 	bl	800bee0 <_test_assert>
 800f5dc:	4603      	mov	r3, r0
 800f5de:	2b00      	cmp	r3, #0
 800f5e0:	d000      	beq.n	800f5e4 <dyn3_execute+0x194>
 800f5e2:	bf00      	nop
}
 800f5e4:	b005      	add	sp, #20
 800f5e6:	f85d fb04 	ldr.w	pc, [sp], #4
 800f5ea:	bf00      	nop
 800f5ec:	080181c0 	.word	0x080181c0
 800f5f0:	20000fe8 	.word	0x20000fe8
 800f5f4:	0800f0b1 	.word	0x0800f0b1
 800f5f8:	f3af 8000 	nop.w
 800f5fc:	f3af 8000 	nop.w

0800f600 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800f600:	b082      	sub	sp, #8
 800f602:	2320      	movs	r3, #32
 800f604:	9301      	str	r3, [sp, #4]
 800f606:	9b01      	ldr	r3, [sp, #4]
 800f608:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800f60c:	b002      	add	sp, #8
 800f60e:	4770      	bx	lr

0800f610 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800f610:	b082      	sub	sp, #8
 800f612:	2300      	movs	r3, #0
 800f614:	9301      	str	r3, [sp, #4]
 800f616:	9b01      	ldr	r3, [sp, #4]
 800f618:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800f61c:	b002      	add	sp, #8
 800f61e:	4770      	bx	lr

0800f620 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800f620:	b508      	push	{r3, lr}

  port_lock();
 800f622:	f7ff ffed 	bl	800f600 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800f626:	bd08      	pop	{r3, pc}
 800f628:	f3af 8000 	nop.w
 800f62c:	f3af 8000 	nop.w

0800f630 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800f630:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800f632:	f7ff ffed 	bl	800f610 <port_unlock>
}
 800f636:	bd08      	pop	{r3, pc}
 800f638:	f3af 8000 	nop.w
 800f63c:	f3af 8000 	nop.w

0800f640 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800f640:	4b01      	ldr	r3, [pc, #4]	; (800f648 <chThdGetSelfX+0x8>)
 800f642:	699b      	ldr	r3, [r3, #24]
}
 800f644:	4618      	mov	r0, r3
 800f646:	4770      	bx	lr
 800f648:	200016e0 	.word	0x200016e0
 800f64c:	f3af 8000 	nop.w

0800f650 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800f650:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800f652:	f7ff fff5 	bl	800f640 <chThdGetSelfX>
 800f656:	4603      	mov	r3, r0
 800f658:	689b      	ldr	r3, [r3, #8]
}
 800f65a:	4618      	mov	r0, r3
 800f65c:	bd08      	pop	{r3, pc}
 800f65e:	bf00      	nop

0800f660 <chIQGetFullI>:
 * @return              The number of full bytes in the queue.
 * @retval 0            if the queue is empty.
 *
 * @iclass
 */
static inline size_t chIQGetFullI(input_queue_t *iqp) {
 800f660:	b082      	sub	sp, #8
 800f662:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (size_t)chQSpaceI(iqp);
 800f664:	9b01      	ldr	r3, [sp, #4]
 800f666:	689b      	ldr	r3, [r3, #8]
}
 800f668:	4618      	mov	r0, r3
 800f66a:	b002      	add	sp, #8
 800f66c:	4770      	bx	lr
 800f66e:	bf00      	nop

0800f670 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 800f670:	b082      	sub	sp, #8
 800f672:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 800f674:	9b01      	ldr	r3, [sp, #4]
 800f676:	689b      	ldr	r3, [r3, #8]
 800f678:	2b00      	cmp	r3, #0
 800f67a:	bf14      	ite	ne
 800f67c:	2300      	movne	r3, #0
 800f67e:	2301      	moveq	r3, #1
 800f680:	b2db      	uxtb	r3, r3
}
 800f682:	4618      	mov	r0, r3
 800f684:	b002      	add	sp, #8
 800f686:	4770      	bx	lr
 800f688:	f3af 8000 	nop.w
 800f68c:	f3af 8000 	nop.w

0800f690 <chIQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {
 800f690:	b082      	sub	sp, #8
 800f692:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 800f694:	9b01      	ldr	r3, [sp, #4]
 800f696:	695a      	ldr	r2, [r3, #20]
 800f698:	9b01      	ldr	r3, [sp, #4]
 800f69a:	699b      	ldr	r3, [r3, #24]
 800f69c:	429a      	cmp	r2, r3
 800f69e:	d105      	bne.n	800f6ac <chIQIsFullI+0x1c>
 800f6a0:	9b01      	ldr	r3, [sp, #4]
 800f6a2:	689b      	ldr	r3, [r3, #8]
 800f6a4:	2b00      	cmp	r3, #0
 800f6a6:	d001      	beq.n	800f6ac <chIQIsFullI+0x1c>
 800f6a8:	2301      	movs	r3, #1
 800f6aa:	e000      	b.n	800f6ae <chIQIsFullI+0x1e>
 800f6ac:	2300      	movs	r3, #0
 800f6ae:	f003 0301 	and.w	r3, r3, #1
 800f6b2:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 800f6b4:	4618      	mov	r0, r3
 800f6b6:	b002      	add	sp, #8
 800f6b8:	4770      	bx	lr
 800f6ba:	bf00      	nop
 800f6bc:	f3af 8000 	nop.w

0800f6c0 <chIQGet>:
 * @return              A byte value from the queue.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {
 800f6c0:	b500      	push	{lr}
 800f6c2:	b083      	sub	sp, #12
 800f6c4:	9001      	str	r0, [sp, #4]

  return chIQGetTimeout(iqp, TIME_INFINITE);
 800f6c6:	9801      	ldr	r0, [sp, #4]
 800f6c8:	f04f 31ff 	mov.w	r1, #4294967295
 800f6cc:	f7f3 fdd8 	bl	8003280 <chIQGetTimeout>
 800f6d0:	4603      	mov	r3, r0
}
 800f6d2:	4618      	mov	r0, r3
 800f6d4:	b003      	add	sp, #12
 800f6d6:	f85d fb04 	ldr.w	pc, [sp], #4
 800f6da:	bf00      	nop
 800f6dc:	f3af 8000 	nop.w

0800f6e0 <chOQGetFullI>:
 * @return              The number of full bytes in the queue.
 * @retval 0            if the queue is empty.
 *
 * @iclass
 */
static inline size_t chOQGetFullI(output_queue_t *oqp) {
 800f6e0:	b082      	sub	sp, #8
 800f6e2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (size_t)(chQSizeX(oqp) - chQSpaceI(oqp));
 800f6e4:	9b01      	ldr	r3, [sp, #4]
 800f6e6:	691b      	ldr	r3, [r3, #16]
 800f6e8:	461a      	mov	r2, r3
 800f6ea:	9b01      	ldr	r3, [sp, #4]
 800f6ec:	68db      	ldr	r3, [r3, #12]
 800f6ee:	1ad3      	subs	r3, r2, r3
 800f6f0:	461a      	mov	r2, r3
 800f6f2:	9b01      	ldr	r3, [sp, #4]
 800f6f4:	689b      	ldr	r3, [r3, #8]
 800f6f6:	1ad3      	subs	r3, r2, r3
}
 800f6f8:	4618      	mov	r0, r3
 800f6fa:	b002      	add	sp, #8
 800f6fc:	4770      	bx	lr
 800f6fe:	bf00      	nop

0800f700 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 800f700:	b082      	sub	sp, #8
 800f702:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 800f704:	9b01      	ldr	r3, [sp, #4]
 800f706:	695a      	ldr	r2, [r3, #20]
 800f708:	9b01      	ldr	r3, [sp, #4]
 800f70a:	699b      	ldr	r3, [r3, #24]
 800f70c:	429a      	cmp	r2, r3
 800f70e:	d105      	bne.n	800f71c <chOQIsEmptyI+0x1c>
 800f710:	9b01      	ldr	r3, [sp, #4]
 800f712:	689b      	ldr	r3, [r3, #8]
 800f714:	2b00      	cmp	r3, #0
 800f716:	d001      	beq.n	800f71c <chOQIsEmptyI+0x1c>
 800f718:	2301      	movs	r3, #1
 800f71a:	e000      	b.n	800f71e <chOQIsEmptyI+0x1e>
 800f71c:	2300      	movs	r3, #0
 800f71e:	f003 0301 	and.w	r3, r3, #1
 800f722:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 800f724:	4618      	mov	r0, r3
 800f726:	b002      	add	sp, #8
 800f728:	4770      	bx	lr
 800f72a:	bf00      	nop
 800f72c:	f3af 8000 	nop.w

0800f730 <chOQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
 800f730:	b082      	sub	sp, #8
 800f732:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 800f734:	9b01      	ldr	r3, [sp, #4]
 800f736:	689b      	ldr	r3, [r3, #8]
 800f738:	2b00      	cmp	r3, #0
 800f73a:	bf14      	ite	ne
 800f73c:	2300      	movne	r3, #0
 800f73e:	2301      	moveq	r3, #1
 800f740:	b2db      	uxtb	r3, r3
}
 800f742:	4618      	mov	r0, r3
 800f744:	b002      	add	sp, #8
 800f746:	4770      	bx	lr
 800f748:	f3af 8000 	nop.w
 800f74c:	f3af 8000 	nop.w

0800f750 <chOQPut>:
 * @retval Q_OK         if the operation succeeded.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
static inline msg_t chOQPut(output_queue_t *oqp, uint8_t b) {
 800f750:	b500      	push	{lr}
 800f752:	b083      	sub	sp, #12
 800f754:	9001      	str	r0, [sp, #4]
 800f756:	460b      	mov	r3, r1
 800f758:	f88d 3003 	strb.w	r3, [sp, #3]

  return chOQPutTimeout(oqp, b, TIME_INFINITE);
 800f75c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800f760:	9801      	ldr	r0, [sp, #4]
 800f762:	4619      	mov	r1, r3
 800f764:	f04f 32ff 	mov.w	r2, #4294967295
 800f768:	f7f3 fe72 	bl	8003450 <chOQPutTimeout>
 800f76c:	4603      	mov	r3, r0
}
 800f76e:	4618      	mov	r0, r3
 800f770:	b003      	add	sp, #12
 800f772:	f85d fb04 	ldr.w	pc, [sp], #4
 800f776:	bf00      	nop
 800f778:	f3af 8000 	nop.w
 800f77c:	f3af 8000 	nop.w

0800f780 <notify>:

#if CH_CFG_USE_QUEUES || defined(__DOXYGEN__)

#define TEST_QUEUES_SIZE 4

static void notify(io_queue_t *qp) {
 800f780:	b082      	sub	sp, #8
 800f782:	9001      	str	r0, [sp, #4]
  (void)qp;
}
 800f784:	b002      	add	sp, #8
 800f786:	4770      	bx	lr
 800f788:	f3af 8000 	nop.w
 800f78c:	f3af 8000 	nop.w

0800f790 <queues1_setup>:
 * This test case tests synchronous and asynchronous operations on an
 * @p InputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues1_setup(void) {
 800f790:	b500      	push	{lr}
 800f792:	b083      	sub	sp, #12

  chIQObjectInit(&iq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
 800f794:	4b06      	ldr	r3, [pc, #24]	; (800f7b0 <queues1_setup+0x20>)
 800f796:	681b      	ldr	r3, [r3, #0]
 800f798:	2200      	movs	r2, #0
 800f79a:	9200      	str	r2, [sp, #0]
 800f79c:	4805      	ldr	r0, [pc, #20]	; (800f7b4 <queues1_setup+0x24>)
 800f79e:	4619      	mov	r1, r3
 800f7a0:	2204      	movs	r2, #4
 800f7a2:	4b05      	ldr	r3, [pc, #20]	; (800f7b8 <queues1_setup+0x28>)
 800f7a4:	f7f3 fcfc 	bl	80031a0 <chIQObjectInit>
}
 800f7a8:	b003      	add	sp, #12
 800f7aa:	f85d fb04 	ldr.w	pc, [sp], #4
 800f7ae:	bf00      	nop
 800f7b0:	08017b20 	.word	0x08017b20
 800f7b4:	200008a8 	.word	0x200008a8
 800f7b8:	0800f781 	.word	0x0800f781
 800f7bc:	f3af 8000 	nop.w

0800f7c0 <thread1>:

static THD_FUNCTION(thread1, p) {
 800f7c0:	b500      	push	{lr}
 800f7c2:	b083      	sub	sp, #12
 800f7c4:	9001      	str	r0, [sp, #4]

  (void)p;
  chIQGetTimeout(&iq, MS2ST(200));
 800f7c6:	4803      	ldr	r0, [pc, #12]	; (800f7d4 <thread1+0x14>)
 800f7c8:	21c8      	movs	r1, #200	; 0xc8
 800f7ca:	f7f3 fd59 	bl	8003280 <chIQGetTimeout>
}
 800f7ce:	b003      	add	sp, #12
 800f7d0:	f85d fb04 	ldr.w	pc, [sp], #4
 800f7d4:	200008a8 	.word	0x200008a8
 800f7d8:	f3af 8000 	nop.w
 800f7dc:	f3af 8000 	nop.w

0800f7e0 <queues1_execute>:

static void queues1_execute(void) {
 800f7e0:	b510      	push	{r4, lr}
 800f7e2:	b084      	sub	sp, #16
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");
 800f7e4:	f7ff ff1c 	bl	800f620 <chSysLock>
 800f7e8:	48ab      	ldr	r0, [pc, #684]	; (800fa98 <queues1_execute+0x2b8>)
 800f7ea:	f7ff ff41 	bl	800f670 <chIQIsEmptyI>
 800f7ee:	4603      	mov	r3, r0
 800f7f0:	2001      	movs	r0, #1
 800f7f2:	4619      	mov	r1, r3
 800f7f4:	f7fc fb74 	bl	800bee0 <_test_assert>
 800f7f8:	4603      	mov	r3, r0
 800f7fa:	2b00      	cmp	r3, #0
 800f7fc:	d002      	beq.n	800f804 <queues1_execute+0x24>
 800f7fe:	f7ff ff17 	bl	800f630 <chSysUnlock>
 800f802:	e16a      	b.n	800fada <queues1_execute+0x2fa>
 800f804:	f7ff ff14 	bl	800f630 <chSysUnlock>

  /* Queue filling */
  chSysLock();
 800f808:	f7ff ff0a 	bl	800f620 <chSysLock>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800f80c:	2300      	movs	r3, #0
 800f80e:	9303      	str	r3, [sp, #12]
 800f810:	e00a      	b.n	800f828 <queues1_execute+0x48>
    chIQPutI(&iq, 'A' + i);
 800f812:	9b03      	ldr	r3, [sp, #12]
 800f814:	b2db      	uxtb	r3, r3
 800f816:	3341      	adds	r3, #65	; 0x41
 800f818:	b2db      	uxtb	r3, r3
 800f81a:	489f      	ldr	r0, [pc, #636]	; (800fa98 <queues1_execute+0x2b8>)
 800f81c:	4619      	mov	r1, r3
 800f81e:	f7f3 fcff 	bl	8003220 <chIQPutI>
  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");

  /* Queue filling */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800f822:	9b03      	ldr	r3, [sp, #12]
 800f824:	3301      	adds	r3, #1
 800f826:	9303      	str	r3, [sp, #12]
 800f828:	9b03      	ldr	r3, [sp, #12]
 800f82a:	2b03      	cmp	r3, #3
 800f82c:	d9f1      	bls.n	800f812 <queues1_execute+0x32>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
 800f82e:	f7ff feff 	bl	800f630 <chSysUnlock>
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
 800f832:	f7ff fef5 	bl	800f620 <chSysLock>
 800f836:	4898      	ldr	r0, [pc, #608]	; (800fa98 <queues1_execute+0x2b8>)
 800f838:	f7ff ff2a 	bl	800f690 <chIQIsFullI>
 800f83c:	4603      	mov	r3, r0
 800f83e:	2002      	movs	r0, #2
 800f840:	4619      	mov	r1, r3
 800f842:	f7fc fb4d 	bl	800bee0 <_test_assert>
 800f846:	4603      	mov	r3, r0
 800f848:	2b00      	cmp	r3, #0
 800f84a:	d002      	beq.n	800f852 <queues1_execute+0x72>
 800f84c:	f7ff fef0 	bl	800f630 <chSysUnlock>
 800f850:	e143      	b.n	800fada <queues1_execute+0x2fa>
 800f852:	f7ff feed 	bl	800f630 <chSysUnlock>
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");
 800f856:	f7ff fee3 	bl	800f620 <chSysLock>
 800f85a:	488f      	ldr	r0, [pc, #572]	; (800fa98 <queues1_execute+0x2b8>)
 800f85c:	2100      	movs	r1, #0
 800f85e:	f7f3 fcdf 	bl	8003220 <chIQPutI>
 800f862:	4603      	mov	r3, r0
 800f864:	f113 0f04 	cmn.w	r3, #4
 800f868:	bf14      	ite	ne
 800f86a:	2300      	movne	r3, #0
 800f86c:	2301      	moveq	r3, #1
 800f86e:	b2db      	uxtb	r3, r3
 800f870:	2003      	movs	r0, #3
 800f872:	4619      	mov	r1, r3
 800f874:	f7fc fb34 	bl	800bee0 <_test_assert>
 800f878:	4603      	mov	r3, r0
 800f87a:	2b00      	cmp	r3, #0
 800f87c:	d002      	beq.n	800f884 <queues1_execute+0xa4>
 800f87e:	f7ff fed7 	bl	800f630 <chSysUnlock>
 800f882:	e12a      	b.n	800fada <queues1_execute+0x2fa>
 800f884:	f7ff fed4 	bl	800f630 <chSysUnlock>

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800f888:	2300      	movs	r3, #0
 800f88a:	9303      	str	r3, [sp, #12]
 800f88c:	e00a      	b.n	800f8a4 <queues1_execute+0xc4>
    test_emit_token(chIQGet(&iq));
 800f88e:	4882      	ldr	r0, [pc, #520]	; (800fa98 <queues1_execute+0x2b8>)
 800f890:	f7ff ff16 	bl	800f6c0 <chIQGet>
 800f894:	4603      	mov	r3, r0
 800f896:	b2db      	uxtb	r3, r3
 800f898:	4618      	mov	r0, r3
 800f89a:	f7fc faf1 	bl	800be80 <test_emit_token>
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800f89e:	9b03      	ldr	r3, [sp, #12]
 800f8a0:	3301      	adds	r3, #1
 800f8a2:	9303      	str	r3, [sp, #12]
 800f8a4:	9b03      	ldr	r3, [sp, #12]
 800f8a6:	2b03      	cmp	r3, #3
 800f8a8:	d9f1      	bls.n	800f88e <queues1_execute+0xae>
    test_emit_token(chIQGet(&iq));
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
 800f8aa:	f7ff feb9 	bl	800f620 <chSysLock>
 800f8ae:	487a      	ldr	r0, [pc, #488]	; (800fa98 <queues1_execute+0x2b8>)
 800f8b0:	f7ff fede 	bl	800f670 <chIQIsEmptyI>
 800f8b4:	4603      	mov	r3, r0
 800f8b6:	2004      	movs	r0, #4
 800f8b8:	4619      	mov	r1, r3
 800f8ba:	f7fc fb11 	bl	800bee0 <_test_assert>
 800f8be:	4603      	mov	r3, r0
 800f8c0:	2b00      	cmp	r3, #0
 800f8c2:	d002      	beq.n	800f8ca <queues1_execute+0xea>
 800f8c4:	f7ff feb4 	bl	800f630 <chSysUnlock>
 800f8c8:	e107      	b.n	800fada <queues1_execute+0x2fa>
 800f8ca:	f7ff feb1 	bl	800f630 <chSysUnlock>
  test_assert_sequence(5, "ABCD");
 800f8ce:	2005      	movs	r0, #5
 800f8d0:	4972      	ldr	r1, [pc, #456]	; (800fa9c <queues1_execute+0x2bc>)
 800f8d2:	f7fc fb1d 	bl	800bf10 <_test_assert_sequence>
 800f8d6:	4603      	mov	r3, r0
 800f8d8:	2b00      	cmp	r3, #0
 800f8da:	d000      	beq.n	800f8de <queues1_execute+0xfe>
 800f8dc:	e0fd      	b.n	800fada <queues1_execute+0x2fa>

  /* Queue filling again */
  chSysLock();
 800f8de:	f7ff fe9f 	bl	800f620 <chSysLock>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800f8e2:	2300      	movs	r3, #0
 800f8e4:	9303      	str	r3, [sp, #12]
 800f8e6:	e00a      	b.n	800f8fe <queues1_execute+0x11e>
    chIQPutI(&iq, 'A' + i);
 800f8e8:	9b03      	ldr	r3, [sp, #12]
 800f8ea:	b2db      	uxtb	r3, r3
 800f8ec:	3341      	adds	r3, #65	; 0x41
 800f8ee:	b2db      	uxtb	r3, r3
 800f8f0:	4869      	ldr	r0, [pc, #420]	; (800fa98 <queues1_execute+0x2b8>)
 800f8f2:	4619      	mov	r1, r3
 800f8f4:	f7f3 fc94 	bl	8003220 <chIQPutI>
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
  test_assert_sequence(5, "ABCD");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800f8f8:	9b03      	ldr	r3, [sp, #12]
 800f8fa:	3301      	adds	r3, #1
 800f8fc:	9303      	str	r3, [sp, #12]
 800f8fe:	9b03      	ldr	r3, [sp, #12]
 800f900:	2b03      	cmp	r3, #3
 800f902:	d9f1      	bls.n	800f8e8 <queues1_execute+0x108>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
 800f904:	f7ff fe94 	bl	800f630 <chSysUnlock>

  /* Reading the whole thing */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 800f908:	4b65      	ldr	r3, [pc, #404]	; (800faa0 <queues1_execute+0x2c0>)
 800f90a:	685b      	ldr	r3, [r3, #4]
 800f90c:	4862      	ldr	r0, [pc, #392]	; (800fa98 <queues1_execute+0x2b8>)
 800f90e:	4619      	mov	r1, r3
 800f910:	2208      	movs	r2, #8
 800f912:	2300      	movs	r3, #0
 800f914:	f7f3 fcfc 	bl	8003310 <chIQReadTimeout>
 800f918:	9002      	str	r0, [sp, #8]
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 800f91a:	9b02      	ldr	r3, [sp, #8]
 800f91c:	2b04      	cmp	r3, #4
 800f91e:	bf14      	ite	ne
 800f920:	2300      	movne	r3, #0
 800f922:	2301      	moveq	r3, #1
 800f924:	b2db      	uxtb	r3, r3
 800f926:	2006      	movs	r0, #6
 800f928:	4619      	mov	r1, r3
 800f92a:	f7fc fad9 	bl	800bee0 <_test_assert>
 800f92e:	4603      	mov	r3, r0
 800f930:	2b00      	cmp	r3, #0
 800f932:	d000      	beq.n	800f936 <queues1_execute+0x156>
 800f934:	e0d1      	b.n	800fada <queues1_execute+0x2fa>
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");
 800f936:	f7ff fe73 	bl	800f620 <chSysLock>
 800f93a:	4857      	ldr	r0, [pc, #348]	; (800fa98 <queues1_execute+0x2b8>)
 800f93c:	f7ff fe98 	bl	800f670 <chIQIsEmptyI>
 800f940:	4603      	mov	r3, r0
 800f942:	2007      	movs	r0, #7
 800f944:	4619      	mov	r1, r3
 800f946:	f7fc facb 	bl	800bee0 <_test_assert>
 800f94a:	4603      	mov	r3, r0
 800f94c:	2b00      	cmp	r3, #0
 800f94e:	d002      	beq.n	800f956 <queues1_execute+0x176>
 800f950:	f7ff fe6e 	bl	800f630 <chSysUnlock>
 800f954:	e0c1      	b.n	800fada <queues1_execute+0x2fa>
 800f956:	f7ff fe6b 	bl	800f630 <chSysUnlock>

  /* Queue filling again */
  chSysLock();
 800f95a:	f7ff fe61 	bl	800f620 <chSysLock>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800f95e:	2300      	movs	r3, #0
 800f960:	9303      	str	r3, [sp, #12]
 800f962:	e00a      	b.n	800f97a <queues1_execute+0x19a>
    chIQPutI(&iq, 'A' + i);
 800f964:	9b03      	ldr	r3, [sp, #12]
 800f966:	b2db      	uxtb	r3, r3
 800f968:	3341      	adds	r3, #65	; 0x41
 800f96a:	b2db      	uxtb	r3, r3
 800f96c:	484a      	ldr	r0, [pc, #296]	; (800fa98 <queues1_execute+0x2b8>)
 800f96e:	4619      	mov	r1, r3
 800f970:	f7f3 fc56 	bl	8003220 <chIQPutI>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800f974:	9b03      	ldr	r3, [sp, #12]
 800f976:	3301      	adds	r3, #1
 800f978:	9303      	str	r3, [sp, #12]
 800f97a:	9b03      	ldr	r3, [sp, #12]
 800f97c:	2b03      	cmp	r3, #3
 800f97e:	d9f1      	bls.n	800f964 <queues1_execute+0x184>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
 800f980:	f7ff fe56 	bl	800f630 <chSysUnlock>

  /* Partial reads */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 800f984:	4b46      	ldr	r3, [pc, #280]	; (800faa0 <queues1_execute+0x2c0>)
 800f986:	685b      	ldr	r3, [r3, #4]
 800f988:	4843      	ldr	r0, [pc, #268]	; (800fa98 <queues1_execute+0x2b8>)
 800f98a:	4619      	mov	r1, r3
 800f98c:	2202      	movs	r2, #2
 800f98e:	2300      	movs	r3, #0
 800f990:	f7f3 fcbe 	bl	8003310 <chIQReadTimeout>
 800f994:	9002      	str	r0, [sp, #8]
  test_assert(8, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800f996:	9b02      	ldr	r3, [sp, #8]
 800f998:	2b02      	cmp	r3, #2
 800f99a:	bf14      	ite	ne
 800f99c:	2300      	movne	r3, #0
 800f99e:	2301      	moveq	r3, #1
 800f9a0:	b2db      	uxtb	r3, r3
 800f9a2:	2008      	movs	r0, #8
 800f9a4:	4619      	mov	r1, r3
 800f9a6:	f7fc fa9b 	bl	800bee0 <_test_assert>
 800f9aa:	4603      	mov	r3, r0
 800f9ac:	2b00      	cmp	r3, #0
 800f9ae:	d000      	beq.n	800f9b2 <queues1_execute+0x1d2>
 800f9b0:	e093      	b.n	800fada <queues1_execute+0x2fa>
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 800f9b2:	4b3b      	ldr	r3, [pc, #236]	; (800faa0 <queues1_execute+0x2c0>)
 800f9b4:	685b      	ldr	r3, [r3, #4]
 800f9b6:	4838      	ldr	r0, [pc, #224]	; (800fa98 <queues1_execute+0x2b8>)
 800f9b8:	4619      	mov	r1, r3
 800f9ba:	2202      	movs	r2, #2
 800f9bc:	2300      	movs	r3, #0
 800f9be:	f7f3 fca7 	bl	8003310 <chIQReadTimeout>
 800f9c2:	9002      	str	r0, [sp, #8]
  test_assert(9, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800f9c4:	9b02      	ldr	r3, [sp, #8]
 800f9c6:	2b02      	cmp	r3, #2
 800f9c8:	bf14      	ite	ne
 800f9ca:	2300      	movne	r3, #0
 800f9cc:	2301      	moveq	r3, #1
 800f9ce:	b2db      	uxtb	r3, r3
 800f9d0:	2009      	movs	r0, #9
 800f9d2:	4619      	mov	r1, r3
 800f9d4:	f7fc fa84 	bl	800bee0 <_test_assert>
 800f9d8:	4603      	mov	r3, r0
 800f9da:	2b00      	cmp	r3, #0
 800f9dc:	d000      	beq.n	800f9e0 <queues1_execute+0x200>
 800f9de:	e07c      	b.n	800fada <queues1_execute+0x2fa>
  test_assert_lock(10, chIQIsEmptyI(&iq), "still full");
 800f9e0:	f7ff fe1e 	bl	800f620 <chSysLock>
 800f9e4:	482c      	ldr	r0, [pc, #176]	; (800fa98 <queues1_execute+0x2b8>)
 800f9e6:	f7ff fe43 	bl	800f670 <chIQIsEmptyI>
 800f9ea:	4603      	mov	r3, r0
 800f9ec:	200a      	movs	r0, #10
 800f9ee:	4619      	mov	r1, r3
 800f9f0:	f7fc fa76 	bl	800bee0 <_test_assert>
 800f9f4:	4603      	mov	r3, r0
 800f9f6:	2b00      	cmp	r3, #0
 800f9f8:	d002      	beq.n	800fa00 <queues1_execute+0x220>
 800f9fa:	f7ff fe19 	bl	800f630 <chSysUnlock>
 800f9fe:	e06c      	b.n	800fada <queues1_execute+0x2fa>
 800fa00:	f7ff fe16 	bl	800f630 <chSysUnlock>

  /* Testing reset */
  chSysLock();
 800fa04:	f7ff fe0c 	bl	800f620 <chSysLock>
  chIQPutI(&iq, 0);
 800fa08:	4823      	ldr	r0, [pc, #140]	; (800fa98 <queues1_execute+0x2b8>)
 800fa0a:	2100      	movs	r1, #0
 800fa0c:	f7f3 fc08 	bl	8003220 <chIQPutI>
  chIQResetI(&iq);
 800fa10:	4821      	ldr	r0, [pc, #132]	; (800fa98 <queues1_execute+0x2b8>)
 800fa12:	f7f3 fbed 	bl	80031f0 <chIQResetI>
  chSysUnlock();
 800fa16:	f7ff fe0b 	bl	800f630 <chSysUnlock>
  test_assert_lock(11, chIQGetFullI(&iq) == 0, "still full");
 800fa1a:	f7ff fe01 	bl	800f620 <chSysLock>
 800fa1e:	481e      	ldr	r0, [pc, #120]	; (800fa98 <queues1_execute+0x2b8>)
 800fa20:	f7ff fe1e 	bl	800f660 <chIQGetFullI>
 800fa24:	4603      	mov	r3, r0
 800fa26:	2b00      	cmp	r3, #0
 800fa28:	bf14      	ite	ne
 800fa2a:	2300      	movne	r3, #0
 800fa2c:	2301      	moveq	r3, #1
 800fa2e:	b2db      	uxtb	r3, r3
 800fa30:	200b      	movs	r0, #11
 800fa32:	4619      	mov	r1, r3
 800fa34:	f7fc fa54 	bl	800bee0 <_test_assert>
 800fa38:	4603      	mov	r3, r0
 800fa3a:	2b00      	cmp	r3, #0
 800fa3c:	d002      	beq.n	800fa44 <queues1_execute+0x264>
 800fa3e:	f7ff fdf7 	bl	800f630 <chSysUnlock>
 800fa42:	e04a      	b.n	800fada <queues1_execute+0x2fa>
 800fa44:	f7ff fdf4 	bl	800f630 <chSysUnlock>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, NULL);
 800fa48:	4b15      	ldr	r3, [pc, #84]	; (800faa0 <queues1_execute+0x2c0>)
 800fa4a:	681c      	ldr	r4, [r3, #0]
 800fa4c:	f7ff fe00 	bl	800f650 <chThdGetPriorityX>
 800fa50:	4603      	mov	r3, r0
 800fa52:	3301      	adds	r3, #1
 800fa54:	2200      	movs	r2, #0
 800fa56:	9200      	str	r2, [sp, #0]
 800fa58:	4620      	mov	r0, r4
 800fa5a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800fa5e:	461a      	mov	r2, r3
 800fa60:	4b10      	ldr	r3, [pc, #64]	; (800faa4 <queues1_execute+0x2c4>)
 800fa62:	f7f1 fbbd 	bl	80011e0 <chThdCreateStatic>
 800fa66:	4602      	mov	r2, r0
 800fa68:	4b0f      	ldr	r3, [pc, #60]	; (800faa8 <queues1_execute+0x2c8>)
 800fa6a:	601a      	str	r2, [r3, #0]
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
 800fa6c:	f7ff fdd8 	bl	800f620 <chSysLock>
 800fa70:	4809      	ldr	r0, [pc, #36]	; (800fa98 <queues1_execute+0x2b8>)
 800fa72:	f7ff fdf5 	bl	800f660 <chIQGetFullI>
 800fa76:	4603      	mov	r3, r0
 800fa78:	2b00      	cmp	r3, #0
 800fa7a:	bf14      	ite	ne
 800fa7c:	2300      	movne	r3, #0
 800fa7e:	2301      	moveq	r3, #1
 800fa80:	b2db      	uxtb	r3, r3
 800fa82:	200c      	movs	r0, #12
 800fa84:	4619      	mov	r1, r3
 800fa86:	f7fc fa2b 	bl	800bee0 <_test_assert>
 800fa8a:	4603      	mov	r3, r0
 800fa8c:	2b00      	cmp	r3, #0
 800fa8e:	d00d      	beq.n	800faac <queues1_execute+0x2cc>
 800fa90:	f7ff fdce 	bl	800f630 <chSysUnlock>
 800fa94:	e021      	b.n	800fada <queues1_execute+0x2fa>
 800fa96:	bf00      	nop
 800fa98:	200008a8 	.word	0x200008a8
 800fa9c:	080182b0 	.word	0x080182b0
 800faa0:	08017b20 	.word	0x08017b20
 800faa4:	0800f7c1 	.word	0x0800f7c1
 800faa8:	20001ba4 	.word	0x20001ba4
 800faac:	f7ff fdc0 	bl	800f630 <chSysUnlock>
  test_wait_threads();
 800fab0:	f7fc fa96 	bl	800bfe0 <test_wait_threads>

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
 800fab4:	480a      	ldr	r0, [pc, #40]	; (800fae0 <queues1_execute+0x300>)
 800fab6:	210a      	movs	r1, #10
 800fab8:	f7f3 fbe2 	bl	8003280 <chIQGetTimeout>
 800fabc:	4603      	mov	r3, r0
 800fabe:	f1b3 3fff 	cmp.w	r3, #4294967295
 800fac2:	bf14      	ite	ne
 800fac4:	2300      	movne	r3, #0
 800fac6:	2301      	moveq	r3, #1
 800fac8:	b2db      	uxtb	r3, r3
 800faca:	200d      	movs	r0, #13
 800facc:	4619      	mov	r1, r3
 800face:	f7fc fa07 	bl	800bee0 <_test_assert>
 800fad2:	4603      	mov	r3, r0
 800fad4:	2b00      	cmp	r3, #0
 800fad6:	d000      	beq.n	800fada <queues1_execute+0x2fa>
 800fad8:	bf00      	nop
}
 800fada:	b004      	add	sp, #16
 800fadc:	bd10      	pop	{r4, pc}
 800fade:	bf00      	nop
 800fae0:	200008a8 	.word	0x200008a8
 800fae4:	f3af 8000 	nop.w
 800fae8:	f3af 8000 	nop.w
 800faec:	f3af 8000 	nop.w

0800faf0 <queues2_setup>:
 * This test case tests synchronous and asynchronous operations on an
 * @p OutputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues2_setup(void) {
 800faf0:	b500      	push	{lr}
 800faf2:	b083      	sub	sp, #12

  chOQObjectInit(&oq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
 800faf4:	4b06      	ldr	r3, [pc, #24]	; (800fb10 <queues2_setup+0x20>)
 800faf6:	681b      	ldr	r3, [r3, #0]
 800faf8:	2200      	movs	r2, #0
 800fafa:	9200      	str	r2, [sp, #0]
 800fafc:	4805      	ldr	r0, [pc, #20]	; (800fb14 <queues2_setup+0x24>)
 800fafe:	4619      	mov	r1, r3
 800fb00:	2204      	movs	r2, #4
 800fb02:	4b05      	ldr	r3, [pc, #20]	; (800fb18 <queues2_setup+0x28>)
 800fb04:	f7f3 fc5c 	bl	80033c0 <chOQObjectInit>
}
 800fb08:	b003      	add	sp, #12
 800fb0a:	f85d fb04 	ldr.w	pc, [sp], #4
 800fb0e:	bf00      	nop
 800fb10:	08017b20 	.word	0x08017b20
 800fb14:	200008cc 	.word	0x200008cc
 800fb18:	0800f781 	.word	0x0800f781
 800fb1c:	f3af 8000 	nop.w

0800fb20 <thread2>:

static THD_FUNCTION(thread2, p) {
 800fb20:	b500      	push	{lr}
 800fb22:	b083      	sub	sp, #12
 800fb24:	9001      	str	r0, [sp, #4]

  (void)p;
  chOQPutTimeout(&oq, 0, MS2ST(200));
 800fb26:	4804      	ldr	r0, [pc, #16]	; (800fb38 <thread2+0x18>)
 800fb28:	2100      	movs	r1, #0
 800fb2a:	22c8      	movs	r2, #200	; 0xc8
 800fb2c:	f7f3 fc90 	bl	8003450 <chOQPutTimeout>
}
 800fb30:	b003      	add	sp, #12
 800fb32:	f85d fb04 	ldr.w	pc, [sp], #4
 800fb36:	bf00      	nop
 800fb38:	200008cc 	.word	0x200008cc
 800fb3c:	f3af 8000 	nop.w

0800fb40 <queues2_execute>:

static void queues2_execute(void) {
 800fb40:	b510      	push	{r4, lr}
 800fb42:	b086      	sub	sp, #24
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");
 800fb44:	f7ff fd6c 	bl	800f620 <chSysLock>
 800fb48:	48a2      	ldr	r0, [pc, #648]	; (800fdd4 <queues2_execute+0x294>)
 800fb4a:	f7ff fdd9 	bl	800f700 <chOQIsEmptyI>
 800fb4e:	4603      	mov	r3, r0
 800fb50:	2001      	movs	r0, #1
 800fb52:	4619      	mov	r1, r3
 800fb54:	f7fc f9c4 	bl	800bee0 <_test_assert>
 800fb58:	4603      	mov	r3, r0
 800fb5a:	2b00      	cmp	r3, #0
 800fb5c:	d002      	beq.n	800fb64 <queues2_execute+0x24>
 800fb5e:	f7ff fd67 	bl	800f630 <chSysUnlock>
 800fb62:	e134      	b.n	800fdce <queues2_execute+0x28e>
 800fb64:	f7ff fd64 	bl	800f630 <chSysUnlock>

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800fb68:	2300      	movs	r3, #0
 800fb6a:	9305      	str	r3, [sp, #20]
 800fb6c:	e00a      	b.n	800fb84 <queues2_execute+0x44>
    chOQPut(&oq, 'A' + i);
 800fb6e:	9b05      	ldr	r3, [sp, #20]
 800fb70:	b2db      	uxtb	r3, r3
 800fb72:	3341      	adds	r3, #65	; 0x41
 800fb74:	b2db      	uxtb	r3, r3
 800fb76:	4897      	ldr	r0, [pc, #604]	; (800fdd4 <queues2_execute+0x294>)
 800fb78:	4619      	mov	r1, r3
 800fb7a:	f7ff fde9 	bl	800f750 <chOQPut>

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800fb7e:	9b05      	ldr	r3, [sp, #20]
 800fb80:	3301      	adds	r3, #1
 800fb82:	9305      	str	r3, [sp, #20]
 800fb84:	9b05      	ldr	r3, [sp, #20]
 800fb86:	2b03      	cmp	r3, #3
 800fb88:	d9f1      	bls.n	800fb6e <queues2_execute+0x2e>
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");
 800fb8a:	f7ff fd49 	bl	800f620 <chSysLock>
 800fb8e:	4891      	ldr	r0, [pc, #580]	; (800fdd4 <queues2_execute+0x294>)
 800fb90:	f7ff fdce 	bl	800f730 <chOQIsFullI>
 800fb94:	4603      	mov	r3, r0
 800fb96:	2002      	movs	r0, #2
 800fb98:	4619      	mov	r1, r3
 800fb9a:	f7fc f9a1 	bl	800bee0 <_test_assert>
 800fb9e:	4603      	mov	r3, r0
 800fba0:	2b00      	cmp	r3, #0
 800fba2:	d002      	beq.n	800fbaa <queues2_execute+0x6a>
 800fba4:	f7ff fd44 	bl	800f630 <chSysUnlock>
 800fba8:	e111      	b.n	800fdce <queues2_execute+0x28e>
 800fbaa:	f7ff fd41 	bl	800f630 <chSysUnlock>

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
 800fbae:	2300      	movs	r3, #0
 800fbb0:	9305      	str	r3, [sp, #20]
 800fbb2:	e011      	b.n	800fbd8 <queues2_execute+0x98>
    char c;

    chSysLock();
 800fbb4:	f7ff fd34 	bl	800f620 <chSysLock>
    c = chOQGetI(&oq);
 800fbb8:	4886      	ldr	r0, [pc, #536]	; (800fdd4 <queues2_execute+0x294>)
 800fbba:	f7f3 fc91 	bl	80034e0 <chOQGetI>
 800fbbe:	4603      	mov	r3, r0
 800fbc0:	f88d 3013 	strb.w	r3, [sp, #19]
    chSysUnlock();
 800fbc4:	f7ff fd34 	bl	800f630 <chSysUnlock>
    test_emit_token(c);
 800fbc8:	f89d 3013 	ldrb.w	r3, [sp, #19]
 800fbcc:	4618      	mov	r0, r3
 800fbce:	f7fc f957 	bl	800be80 <test_emit_token>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
 800fbd2:	9b05      	ldr	r3, [sp, #20]
 800fbd4:	3301      	adds	r3, #1
 800fbd6:	9305      	str	r3, [sp, #20]
 800fbd8:	9b05      	ldr	r3, [sp, #20]
 800fbda:	2b03      	cmp	r3, #3
 800fbdc:	d9ea      	bls.n	800fbb4 <queues2_execute+0x74>
    chSysLock();
    c = chOQGetI(&oq);
    chSysUnlock();
    test_emit_token(c);
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
 800fbde:	f7ff fd1f 	bl	800f620 <chSysLock>
 800fbe2:	487c      	ldr	r0, [pc, #496]	; (800fdd4 <queues2_execute+0x294>)
 800fbe4:	f7ff fd8c 	bl	800f700 <chOQIsEmptyI>
 800fbe8:	4603      	mov	r3, r0
 800fbea:	2003      	movs	r0, #3
 800fbec:	4619      	mov	r1, r3
 800fbee:	f7fc f977 	bl	800bee0 <_test_assert>
 800fbf2:	4603      	mov	r3, r0
 800fbf4:	2b00      	cmp	r3, #0
 800fbf6:	d002      	beq.n	800fbfe <queues2_execute+0xbe>
 800fbf8:	f7ff fd1a 	bl	800f630 <chSysUnlock>
 800fbfc:	e0e7      	b.n	800fdce <queues2_execute+0x28e>
 800fbfe:	f7ff fd17 	bl	800f630 <chSysUnlock>
  test_assert_sequence(4, "ABCD");
 800fc02:	2004      	movs	r0, #4
 800fc04:	4974      	ldr	r1, [pc, #464]	; (800fdd8 <queues2_execute+0x298>)
 800fc06:	f7fc f983 	bl	800bf10 <_test_assert_sequence>
 800fc0a:	4603      	mov	r3, r0
 800fc0c:	2b00      	cmp	r3, #0
 800fc0e:	d000      	beq.n	800fc12 <queues2_execute+0xd2>
 800fc10:	e0dd      	b.n	800fdce <queues2_execute+0x28e>
  test_assert_lock(5, chOQGetI(&oq) == Q_EMPTY, "failed to report Q_EMPTY");
 800fc12:	f7ff fd05 	bl	800f620 <chSysLock>
 800fc16:	486f      	ldr	r0, [pc, #444]	; (800fdd4 <queues2_execute+0x294>)
 800fc18:	f7f3 fc62 	bl	80034e0 <chOQGetI>
 800fc1c:	4603      	mov	r3, r0
 800fc1e:	f113 0f03 	cmn.w	r3, #3
 800fc22:	bf14      	ite	ne
 800fc24:	2300      	movne	r3, #0
 800fc26:	2301      	moveq	r3, #1
 800fc28:	b2db      	uxtb	r3, r3
 800fc2a:	2005      	movs	r0, #5
 800fc2c:	4619      	mov	r1, r3
 800fc2e:	f7fc f957 	bl	800bee0 <_test_assert>
 800fc32:	4603      	mov	r3, r0
 800fc34:	2b00      	cmp	r3, #0
 800fc36:	d002      	beq.n	800fc3e <queues2_execute+0xfe>
 800fc38:	f7ff fcfa 	bl	800f630 <chSysUnlock>
 800fc3c:	e0c7      	b.n	800fdce <queues2_execute+0x28e>
 800fc3e:	f7ff fcf7 	bl	800f630 <chSysUnlock>

  /* Writing the whole thing */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 800fc42:	4b66      	ldr	r3, [pc, #408]	; (800fddc <queues2_execute+0x29c>)
 800fc44:	685b      	ldr	r3, [r3, #4]
 800fc46:	4863      	ldr	r0, [pc, #396]	; (800fdd4 <queues2_execute+0x294>)
 800fc48:	4619      	mov	r1, r3
 800fc4a:	2208      	movs	r2, #8
 800fc4c:	2300      	movs	r3, #0
 800fc4e:	f7f3 fc77 	bl	8003540 <chOQWriteTimeout>
 800fc52:	9003      	str	r0, [sp, #12]
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 800fc54:	9b03      	ldr	r3, [sp, #12]
 800fc56:	2b04      	cmp	r3, #4
 800fc58:	bf14      	ite	ne
 800fc5a:	2300      	movne	r3, #0
 800fc5c:	2301      	moveq	r3, #1
 800fc5e:	b2db      	uxtb	r3, r3
 800fc60:	2006      	movs	r0, #6
 800fc62:	4619      	mov	r1, r3
 800fc64:	f7fc f93c 	bl	800bee0 <_test_assert>
 800fc68:	4603      	mov	r3, r0
 800fc6a:	2b00      	cmp	r3, #0
 800fc6c:	d000      	beq.n	800fc70 <queues2_execute+0x130>
 800fc6e:	e0ae      	b.n	800fdce <queues2_execute+0x28e>
  test_assert_lock(7, chOQIsFullI(&oq), "not full");
 800fc70:	f7ff fcd6 	bl	800f620 <chSysLock>
 800fc74:	4857      	ldr	r0, [pc, #348]	; (800fdd4 <queues2_execute+0x294>)
 800fc76:	f7ff fd5b 	bl	800f730 <chOQIsFullI>
 800fc7a:	4603      	mov	r3, r0
 800fc7c:	2007      	movs	r0, #7
 800fc7e:	4619      	mov	r1, r3
 800fc80:	f7fc f92e 	bl	800bee0 <_test_assert>
 800fc84:	4603      	mov	r3, r0
 800fc86:	2b00      	cmp	r3, #0
 800fc88:	d002      	beq.n	800fc90 <queues2_execute+0x150>
 800fc8a:	f7ff fcd1 	bl	800f630 <chSysUnlock>
 800fc8e:	e09e      	b.n	800fdce <queues2_execute+0x28e>
 800fc90:	f7ff fcce 	bl	800f630 <chSysUnlock>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 800fc94:	4b51      	ldr	r3, [pc, #324]	; (800fddc <queues2_execute+0x29c>)
 800fc96:	681c      	ldr	r4, [r3, #0]
 800fc98:	f7ff fcda 	bl	800f650 <chThdGetPriorityX>
 800fc9c:	4603      	mov	r3, r0
 800fc9e:	3301      	adds	r3, #1
 800fca0:	2200      	movs	r2, #0
 800fca2:	9200      	str	r2, [sp, #0]
 800fca4:	4620      	mov	r0, r4
 800fca6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800fcaa:	461a      	mov	r2, r3
 800fcac:	4b4c      	ldr	r3, [pc, #304]	; (800fde0 <queues2_execute+0x2a0>)
 800fcae:	f7f1 fa97 	bl	80011e0 <chThdCreateStatic>
 800fcb2:	4602      	mov	r2, r0
 800fcb4:	4b4b      	ldr	r3, [pc, #300]	; (800fde4 <queues2_execute+0x2a4>)
 800fcb6:	601a      	str	r2, [r3, #0]
  test_assert_lock(8, chOQGetFullI(&oq) == TEST_QUEUES_SIZE, "not empty");
 800fcb8:	f7ff fcb2 	bl	800f620 <chSysLock>
 800fcbc:	4845      	ldr	r0, [pc, #276]	; (800fdd4 <queues2_execute+0x294>)
 800fcbe:	f7ff fd0f 	bl	800f6e0 <chOQGetFullI>
 800fcc2:	4603      	mov	r3, r0
 800fcc4:	2b04      	cmp	r3, #4
 800fcc6:	bf14      	ite	ne
 800fcc8:	2300      	movne	r3, #0
 800fcca:	2301      	moveq	r3, #1
 800fccc:	b2db      	uxtb	r3, r3
 800fcce:	2008      	movs	r0, #8
 800fcd0:	4619      	mov	r1, r3
 800fcd2:	f7fc f905 	bl	800bee0 <_test_assert>
 800fcd6:	4603      	mov	r3, r0
 800fcd8:	2b00      	cmp	r3, #0
 800fcda:	d002      	beq.n	800fce2 <queues2_execute+0x1a2>
 800fcdc:	f7ff fca8 	bl	800f630 <chSysUnlock>
 800fce0:	e075      	b.n	800fdce <queues2_execute+0x28e>
 800fce2:	f7ff fca5 	bl	800f630 <chSysUnlock>
  test_wait_threads();
 800fce6:	f7fc f97b 	bl	800bfe0 <test_wait_threads>

  /* Testing reset */
  chSysLock();
 800fcea:	f7ff fc99 	bl	800f620 <chSysLock>
  chOQResetI(&oq);
 800fcee:	4839      	ldr	r0, [pc, #228]	; (800fdd4 <queues2_execute+0x294>)
 800fcf0:	f7f3 fb8e 	bl	8003410 <chOQResetI>
  chSysUnlock();
 800fcf4:	f7ff fc9c 	bl	800f630 <chSysUnlock>
  test_assert_lock(9, chOQGetFullI(&oq) == 0, "still full");
 800fcf8:	f7ff fc92 	bl	800f620 <chSysLock>
 800fcfc:	4835      	ldr	r0, [pc, #212]	; (800fdd4 <queues2_execute+0x294>)
 800fcfe:	f7ff fcef 	bl	800f6e0 <chOQGetFullI>
 800fd02:	4603      	mov	r3, r0
 800fd04:	2b00      	cmp	r3, #0
 800fd06:	bf14      	ite	ne
 800fd08:	2300      	movne	r3, #0
 800fd0a:	2301      	moveq	r3, #1
 800fd0c:	b2db      	uxtb	r3, r3
 800fd0e:	2009      	movs	r0, #9
 800fd10:	4619      	mov	r1, r3
 800fd12:	f7fc f8e5 	bl	800bee0 <_test_assert>
 800fd16:	4603      	mov	r3, r0
 800fd18:	2b00      	cmp	r3, #0
 800fd1a:	d002      	beq.n	800fd22 <queues2_execute+0x1e2>
 800fd1c:	f7ff fc88 	bl	800f630 <chSysUnlock>
 800fd20:	e055      	b.n	800fdce <queues2_execute+0x28e>
 800fd22:	f7ff fc85 	bl	800f630 <chSysUnlock>

  /* Partial writes */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 800fd26:	4b2d      	ldr	r3, [pc, #180]	; (800fddc <queues2_execute+0x29c>)
 800fd28:	685b      	ldr	r3, [r3, #4]
 800fd2a:	482a      	ldr	r0, [pc, #168]	; (800fdd4 <queues2_execute+0x294>)
 800fd2c:	4619      	mov	r1, r3
 800fd2e:	2202      	movs	r2, #2
 800fd30:	2300      	movs	r3, #0
 800fd32:	f7f3 fc05 	bl	8003540 <chOQWriteTimeout>
 800fd36:	9003      	str	r0, [sp, #12]
  test_assert(10, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800fd38:	9b03      	ldr	r3, [sp, #12]
 800fd3a:	2b02      	cmp	r3, #2
 800fd3c:	bf14      	ite	ne
 800fd3e:	2300      	movne	r3, #0
 800fd40:	2301      	moveq	r3, #1
 800fd42:	b2db      	uxtb	r3, r3
 800fd44:	200a      	movs	r0, #10
 800fd46:	4619      	mov	r1, r3
 800fd48:	f7fc f8ca 	bl	800bee0 <_test_assert>
 800fd4c:	4603      	mov	r3, r0
 800fd4e:	2b00      	cmp	r3, #0
 800fd50:	d000      	beq.n	800fd54 <queues2_execute+0x214>
 800fd52:	e03c      	b.n	800fdce <queues2_execute+0x28e>
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 800fd54:	4b21      	ldr	r3, [pc, #132]	; (800fddc <queues2_execute+0x29c>)
 800fd56:	685b      	ldr	r3, [r3, #4]
 800fd58:	481e      	ldr	r0, [pc, #120]	; (800fdd4 <queues2_execute+0x294>)
 800fd5a:	4619      	mov	r1, r3
 800fd5c:	2202      	movs	r2, #2
 800fd5e:	2300      	movs	r3, #0
 800fd60:	f7f3 fbee 	bl	8003540 <chOQWriteTimeout>
 800fd64:	9003      	str	r0, [sp, #12]
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800fd66:	9b03      	ldr	r3, [sp, #12]
 800fd68:	2b02      	cmp	r3, #2
 800fd6a:	bf14      	ite	ne
 800fd6c:	2300      	movne	r3, #0
 800fd6e:	2301      	moveq	r3, #1
 800fd70:	b2db      	uxtb	r3, r3
 800fd72:	200b      	movs	r0, #11
 800fd74:	4619      	mov	r1, r3
 800fd76:	f7fc f8b3 	bl	800bee0 <_test_assert>
 800fd7a:	4603      	mov	r3, r0
 800fd7c:	2b00      	cmp	r3, #0
 800fd7e:	d000      	beq.n	800fd82 <queues2_execute+0x242>
 800fd80:	e025      	b.n	800fdce <queues2_execute+0x28e>
  test_assert_lock(12, chOQIsFullI(&oq), "not full");
 800fd82:	f7ff fc4d 	bl	800f620 <chSysLock>
 800fd86:	4813      	ldr	r0, [pc, #76]	; (800fdd4 <queues2_execute+0x294>)
 800fd88:	f7ff fcd2 	bl	800f730 <chOQIsFullI>
 800fd8c:	4603      	mov	r3, r0
 800fd8e:	200c      	movs	r0, #12
 800fd90:	4619      	mov	r1, r3
 800fd92:	f7fc f8a5 	bl	800bee0 <_test_assert>
 800fd96:	4603      	mov	r3, r0
 800fd98:	2b00      	cmp	r3, #0
 800fd9a:	d002      	beq.n	800fda2 <queues2_execute+0x262>
 800fd9c:	f7ff fc48 	bl	800f630 <chSysUnlock>
 800fda0:	e015      	b.n	800fdce <queues2_execute+0x28e>
 800fda2:	f7ff fc45 	bl	800f630 <chSysUnlock>

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
 800fda6:	480b      	ldr	r0, [pc, #44]	; (800fdd4 <queues2_execute+0x294>)
 800fda8:	2100      	movs	r1, #0
 800fdaa:	220a      	movs	r2, #10
 800fdac:	f7f3 fb50 	bl	8003450 <chOQPutTimeout>
 800fdb0:	4603      	mov	r3, r0
 800fdb2:	f1b3 3fff 	cmp.w	r3, #4294967295
 800fdb6:	bf14      	ite	ne
 800fdb8:	2300      	movne	r3, #0
 800fdba:	2301      	moveq	r3, #1
 800fdbc:	b2db      	uxtb	r3, r3
 800fdbe:	200d      	movs	r0, #13
 800fdc0:	4619      	mov	r1, r3
 800fdc2:	f7fc f88d 	bl	800bee0 <_test_assert>
 800fdc6:	4603      	mov	r3, r0
 800fdc8:	2b00      	cmp	r3, #0
 800fdca:	d000      	beq.n	800fdce <queues2_execute+0x28e>
 800fdcc:	bf00      	nop
}
 800fdce:	b006      	add	sp, #24
 800fdd0:	bd10      	pop	{r4, pc}
 800fdd2:	bf00      	nop
 800fdd4:	200008cc 	.word	0x200008cc
 800fdd8:	080182b0 	.word	0x080182b0
 800fddc:	08017b20 	.word	0x08017b20
 800fde0:	0800fb21 	.word	0x0800fb21
 800fde4:	20001ba4 	.word	0x20001ba4
 800fde8:	f3af 8000 	nop.w
 800fdec:	f3af 8000 	nop.w

0800fdf0 <port_get_irq_status>:
/**
 * @brief   Returns a word encoding the current interrupts status.
 *
 * @return              The interrupts status.
 */
static inline syssts_t port_get_irq_status(void) {
 800fdf0:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800fdf2:	f3ef 8311 	mrs	r3, BASEPRI
 800fdf6:	9300      	str	r3, [sp, #0]
  return(result);
 800fdf8:	9b00      	ldr	r3, [sp, #0]
  syssts_t sts;

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  sts = (syssts_t)__get_BASEPRI();
 800fdfa:	9301      	str	r3, [sp, #4]
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  sts = (syssts_t)__get_PRIMASK();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
  return sts;
 800fdfc:	9b01      	ldr	r3, [sp, #4]
}
 800fdfe:	4618      	mov	r0, r3
 800fe00:	b002      	add	sp, #8
 800fe02:	4770      	bx	lr
 800fe04:	f3af 8000 	nop.w
 800fe08:	f3af 8000 	nop.w
 800fe0c:	f3af 8000 	nop.w

0800fe10 <port_irq_enabled>:
 *
 * @return              The interrupt status.
 * @retvel false        the word specified a disabled interrupts status.
 * @retvel true         the word specified an enabled interrupts status.
 */
static inline bool port_irq_enabled(syssts_t sts) {
 800fe10:	b082      	sub	sp, #8
 800fe12:	9001      	str	r0, [sp, #4]

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  return sts == (syssts_t)CORTEX_BASEPRI_DISABLED;
 800fe14:	9b01      	ldr	r3, [sp, #4]
 800fe16:	2b00      	cmp	r3, #0
 800fe18:	bf14      	ite	ne
 800fe1a:	2300      	movne	r3, #0
 800fe1c:	2301      	moveq	r3, #1
 800fe1e:	b2db      	uxtb	r3, r3
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  return (sts & (syssts_t)1) == (syssts_t)0;
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800fe20:	4618      	mov	r0, r3
 800fe22:	b002      	add	sp, #8
 800fe24:	4770      	bx	lr
 800fe26:	bf00      	nop
 800fe28:	f3af 8000 	nop.w
 800fe2c:	f3af 8000 	nop.w

0800fe30 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800fe30:	b082      	sub	sp, #8
 800fe32:	2320      	movs	r3, #32
 800fe34:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800fe36:	9b01      	ldr	r3, [sp, #4]
 800fe38:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800fe3c:	b002      	add	sp, #8
 800fe3e:	4770      	bx	lr

0800fe40 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800fe40:	b082      	sub	sp, #8
 800fe42:	2300      	movs	r3, #0
 800fe44:	9301      	str	r3, [sp, #4]
 800fe46:	9b01      	ldr	r3, [sp, #4]
 800fe48:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800fe4c:	b002      	add	sp, #8
 800fe4e:	4770      	bx	lr

0800fe50 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800fe50:	b508      	push	{r3, lr}

  port_lock();
 800fe52:	f7ff ffed 	bl	800fe30 <port_lock>
}
 800fe56:	bd08      	pop	{r3, pc}
 800fe58:	f3af 8000 	nop.w
 800fe5c:	f3af 8000 	nop.w

0800fe60 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800fe60:	b508      	push	{r3, lr}

  port_unlock();
 800fe62:	f7ff ffed 	bl	800fe40 <port_unlock>
}
 800fe66:	bd08      	pop	{r3, pc}
 800fe68:	f3af 8000 	nop.w
 800fe6c:	f3af 8000 	nop.w

0800fe70 <port_disable>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800fe70:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 800fe72:	4770      	bx	lr
 800fe74:	f3af 8000 	nop.w
 800fe78:	f3af 8000 	nop.w
 800fe7c:	f3af 8000 	nop.w

0800fe80 <port_suspend>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 * @note    Interrupt sources above kernel level remains enabled.
 * @note    In this port it raises/lowers the base priority to kernel level.
 */
static inline void port_suspend(void) {
 800fe80:	b082      	sub	sp, #8
 800fe82:	2320      	movs	r3, #32
 800fe84:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800fe86:	9b01      	ldr	r3, [sp, #4]
 800fe88:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800fe8c:	b662      	cpsie	i
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
  __enable_irq();
#else
  __disable_irq();
#endif
}
 800fe8e:	b002      	add	sp, #8
 800fe90:	4770      	bx	lr
 800fe92:	bf00      	nop
 800fe94:	f3af 8000 	nop.w
 800fe98:	f3af 8000 	nop.w
 800fe9c:	f3af 8000 	nop.w

0800fea0 <port_enable>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
 800fea0:	b082      	sub	sp, #8
 800fea2:	2300      	movs	r3, #0
 800fea4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800fea6:	9b01      	ldr	r3, [sp, #4]
 800fea8:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800feac:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
 800feae:	b002      	add	sp, #8
 800feb0:	4770      	bx	lr
 800feb2:	bf00      	nop
 800feb4:	f3af 8000 	nop.w
 800feb8:	f3af 8000 	nop.w
 800febc:	f3af 8000 	nop.w

0800fec0 <chSysDisable>:
 *          hardware priority.
 * @note    Do not invoke this API from within a kernel lock.
 *
 * @special
 */
static inline void chSysDisable(void) {
 800fec0:	b508      	push	{r3, lr}

  port_disable();
 800fec2:	f7ff ffd5 	bl	800fe70 <port_disable>
  _dbg_check_disable();
}
 800fec6:	bd08      	pop	{r3, pc}
 800fec8:	f3af 8000 	nop.w
 800fecc:	f3af 8000 	nop.w

0800fed0 <chSysSuspend>:
 * @note    This API is no replacement for @p chSysLock(), the @p chSysLock()
 *          could do more than just disable the interrupts.
 *
 * @special
 */
static inline void chSysSuspend(void) {
 800fed0:	b508      	push	{r3, lr}

  port_suspend();
 800fed2:	f7ff ffd5 	bl	800fe80 <port_suspend>
  _dbg_check_suspend();
}
 800fed6:	bd08      	pop	{r3, pc}
 800fed8:	f3af 8000 	nop.w
 800fedc:	f3af 8000 	nop.w

0800fee0 <chSysEnable>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 800fee0:	b508      	push	{r3, lr}

  _dbg_check_enable();
  port_enable();
 800fee2:	f7ff ffdd 	bl	800fea0 <port_enable>
}
 800fee6:	bd08      	pop	{r3, pc}
 800fee8:	f3af 8000 	nop.w
 800feec:	f3af 8000 	nop.w

0800fef0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800fef0:	b508      	push	{r3, lr}

  port_lock();
 800fef2:	f7ff ff9d 	bl	800fe30 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800fef6:	bd08      	pop	{r3, pc}
 800fef8:	f3af 8000 	nop.w
 800fefc:	f3af 8000 	nop.w

0800ff00 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800ff00:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800ff02:	f7ff ff9d 	bl	800fe40 <port_unlock>
}
 800ff06:	bd08      	pop	{r3, pc}
 800ff08:	f3af 8000 	nop.w
 800ff0c:	f3af 8000 	nop.w

0800ff10 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 800ff10:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800ff12:	f7ff ff9d 	bl	800fe50 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 800ff16:	bd08      	pop	{r3, pc}
 800ff18:	f3af 8000 	nop.w
 800ff1c:	f3af 8000 	nop.w

0800ff20 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 800ff20:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 800ff22:	f7ff ff9d 	bl	800fe60 <port_unlock_from_isr>
}
 800ff26:	bd08      	pop	{r3, pc}
 800ff28:	f3af 8000 	nop.w
 800ff2c:	f3af 8000 	nop.w

0800ff30 <chSysUnconditionalLock>:
 * @note    Can be called without previous knowledge of the current lock state.
 *          The final state is "s-locked".
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {
 800ff30:	b508      	push	{r3, lr}

  if (port_irq_enabled(port_get_irq_status())) {
 800ff32:	f7ff ff5d 	bl	800fdf0 <port_get_irq_status>
 800ff36:	4603      	mov	r3, r0
 800ff38:	4618      	mov	r0, r3
 800ff3a:	f7ff ff69 	bl	800fe10 <port_irq_enabled>
 800ff3e:	4603      	mov	r3, r0
 800ff40:	2b00      	cmp	r3, #0
 800ff42:	d001      	beq.n	800ff48 <chSysUnconditionalLock+0x18>
    chSysLock();
 800ff44:	f7ff ffd4 	bl	800fef0 <chSysLock>
  }
}
 800ff48:	bd08      	pop	{r3, pc}
 800ff4a:	bf00      	nop
 800ff4c:	f3af 8000 	nop.w

0800ff50 <chSysUnconditionalUnlock>:
 * @note    Can be called without previous knowledge of the current lock state.
 *          The final state is "normal".
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {
 800ff50:	b508      	push	{r3, lr}

  if (!port_irq_enabled(port_get_irq_status())) {
 800ff52:	f7ff ff4d 	bl	800fdf0 <port_get_irq_status>
 800ff56:	4603      	mov	r3, r0
 800ff58:	4618      	mov	r0, r3
 800ff5a:	f7ff ff59 	bl	800fe10 <port_irq_enabled>
 800ff5e:	4603      	mov	r3, r0
 800ff60:	f083 0301 	eor.w	r3, r3, #1
 800ff64:	b2db      	uxtb	r3, r3
 800ff66:	2b00      	cmp	r3, #0
 800ff68:	d001      	beq.n	800ff6e <chSysUnconditionalUnlock+0x1e>
    chSysUnlock();
 800ff6a:	f7ff ffc9 	bl	800ff00 <chSysUnlock>
  }
}
 800ff6e:	bd08      	pop	{r3, pc}

0800ff70 <chVTObjectInit>:
 *
 * @param[out] vtp      the @p virtual_timer_t structure pointer
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {
 800ff70:	b082      	sub	sp, #8
 800ff72:	9001      	str	r0, [sp, #4]

  vtp->vt_func = NULL;
 800ff74:	9b01      	ldr	r3, [sp, #4]
 800ff76:	2200      	movs	r2, #0
 800ff78:	60da      	str	r2, [r3, #12]
}
 800ff7a:	b002      	add	sp, #8
 800ff7c:	4770      	bx	lr
 800ff7e:	bf00      	nop

0800ff80 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 800ff80:	b082      	sub	sp, #8
 800ff82:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->vt_func != NULL);
 800ff84:	9b01      	ldr	r3, [sp, #4]
 800ff86:	68db      	ldr	r3, [r3, #12]
 800ff88:	2b00      	cmp	r3, #0
 800ff8a:	bf0c      	ite	eq
 800ff8c:	2300      	moveq	r3, #0
 800ff8e:	2301      	movne	r3, #1
 800ff90:	b2db      	uxtb	r3, r3
}
 800ff92:	4618      	mov	r0, r3
 800ff94:	b002      	add	sp, #8
 800ff96:	4770      	bx	lr
 800ff98:	f3af 8000 	nop.w
 800ff9c:	f3af 8000 	nop.w

0800ffa0 <chVTIsArmed>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @api
 */
static inline bool chVTIsArmed(virtual_timer_t *vtp) {
 800ffa0:	b500      	push	{lr}
 800ffa2:	b085      	sub	sp, #20
 800ffa4:	9001      	str	r0, [sp, #4]
  bool b;

  chSysLock();
 800ffa6:	f7ff ffa3 	bl	800fef0 <chSysLock>
  b = chVTIsArmedI(vtp);
 800ffaa:	9801      	ldr	r0, [sp, #4]
 800ffac:	f7ff ffe8 	bl	800ff80 <chVTIsArmedI>
 800ffb0:	4603      	mov	r3, r0
 800ffb2:	f88d 300f 	strb.w	r3, [sp, #15]
  chSysUnlock();
 800ffb6:	f7ff ffa3 	bl	800ff00 <chSysUnlock>

  return b;
 800ffba:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 800ffbe:	4618      	mov	r0, r3
 800ffc0:	b005      	add	sp, #20
 800ffc2:	f85d fb04 	ldr.w	pc, [sp], #4
 800ffc6:	bf00      	nop
 800ffc8:	f3af 8000 	nop.w
 800ffcc:	f3af 8000 	nop.w

0800ffd0 <chVTResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {
 800ffd0:	b500      	push	{lr}
 800ffd2:	b083      	sub	sp, #12
 800ffd4:	9001      	str	r0, [sp, #4]

  if (chVTIsArmedI(vtp)) {
 800ffd6:	9801      	ldr	r0, [sp, #4]
 800ffd8:	f7ff ffd2 	bl	800ff80 <chVTIsArmedI>
 800ffdc:	4603      	mov	r3, r0
 800ffde:	2b00      	cmp	r3, #0
 800ffe0:	d002      	beq.n	800ffe8 <chVTResetI+0x18>
    chVTDoResetI(vtp);
 800ffe2:	9801      	ldr	r0, [sp, #4]
 800ffe4:	f7f0 fd14 	bl	8000a10 <chVTDoResetI>
  }
}
 800ffe8:	b003      	add	sp, #12
 800ffea:	f85d fb04 	ldr.w	pc, [sp], #4
 800ffee:	bf00      	nop

0800fff0 <chVTSetI>:
 *                      function
 *
 * @iclass
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {
 800fff0:	b500      	push	{lr}
 800fff2:	b085      	sub	sp, #20
 800fff4:	9003      	str	r0, [sp, #12]
 800fff6:	9102      	str	r1, [sp, #8]
 800fff8:	9201      	str	r2, [sp, #4]
 800fffa:	9300      	str	r3, [sp, #0]

  chVTResetI(vtp);
 800fffc:	9803      	ldr	r0, [sp, #12]
 800fffe:	f7ff ffe7 	bl	800ffd0 <chVTResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
 8010002:	9803      	ldr	r0, [sp, #12]
 8010004:	9902      	ldr	r1, [sp, #8]
 8010006:	9a01      	ldr	r2, [sp, #4]
 8010008:	9b00      	ldr	r3, [sp, #0]
 801000a:	f7f0 fcc1 	bl	8000990 <chVTDoSetI>
}
 801000e:	b005      	add	sp, #20
 8010010:	f85d fb04 	ldr.w	pc, [sp], #4
 8010014:	f3af 8000 	nop.w
 8010018:	f3af 8000 	nop.w
 801001c:	f3af 8000 	nop.w

08010020 <chVTSet>:
 *                      function
 *
 * @api
 */
static inline void chVTSet(virtual_timer_t *vtp, systime_t delay,
                           vtfunc_t vtfunc, void *par) {
 8010020:	b500      	push	{lr}
 8010022:	b085      	sub	sp, #20
 8010024:	9003      	str	r0, [sp, #12]
 8010026:	9102      	str	r1, [sp, #8]
 8010028:	9201      	str	r2, [sp, #4]
 801002a:	9300      	str	r3, [sp, #0]

  chSysLock();
 801002c:	f7ff ff60 	bl	800fef0 <chSysLock>
  chVTSetI(vtp, delay, vtfunc, par);
 8010030:	9803      	ldr	r0, [sp, #12]
 8010032:	9902      	ldr	r1, [sp, #8]
 8010034:	9a01      	ldr	r2, [sp, #4]
 8010036:	9b00      	ldr	r3, [sp, #0]
 8010038:	f7ff ffda 	bl	800fff0 <chVTSetI>
  chSysUnlock();
 801003c:	f7ff ff60 	bl	800ff00 <chSysUnlock>
}
 8010040:	b005      	add	sp, #20
 8010042:	f85d fb04 	ldr.w	pc, [sp], #4
 8010046:	bf00      	nop
 8010048:	f3af 8000 	nop.w
 801004c:	f3af 8000 	nop.w

08010050 <vtcb>:
 *
 * <h2>Description</h2>
 * The critical zones API is invoked for coverage.
 */

static void vtcb(void *p) {
 8010050:	b500      	push	{lr}
 8010052:	b085      	sub	sp, #20
 8010054:	9001      	str	r0, [sp, #4]
  syssts_t sts;

  (void)p;

  /* Testing normal case.*/
  chSysLockFromISR();
 8010056:	f7ff ff5b 	bl	800ff10 <chSysLockFromISR>
  chSysUnlockFromISR();
 801005a:	f7ff ff61 	bl	800ff20 <chSysUnlockFromISR>

  /* Reentrant case.*/
  chSysLockFromISR();
 801005e:	f7ff ff57 	bl	800ff10 <chSysLockFromISR>
  sts = chSysGetStatusAndLockX();
 8010062:	f7f0 fc0d 	bl	8000880 <chSysGetStatusAndLockX>
 8010066:	9003      	str	r0, [sp, #12]
  chSysRestoreStatusX(sts);
 8010068:	9803      	ldr	r0, [sp, #12]
 801006a:	f7f0 fc29 	bl	80008c0 <chSysRestoreStatusX>
  chSysUnlockFromISR();
 801006e:	f7ff ff57 	bl	800ff20 <chSysUnlockFromISR>
}
 8010072:	b005      	add	sp, #20
 8010074:	f85d fb04 	ldr.w	pc, [sp], #4
 8010078:	f3af 8000 	nop.w
 801007c:	f3af 8000 	nop.w

08010080 <sys1_execute>:

static void sys1_execute(void) {
 8010080:	b500      	push	{lr}
 8010082:	b087      	sub	sp, #28
  syssts_t sts;
  virtual_timer_t vt;

  /* Testing normal case.*/
  sts = chSysGetStatusAndLockX();
 8010084:	f7f0 fbfc 	bl	8000880 <chSysGetStatusAndLockX>
 8010088:	9005      	str	r0, [sp, #20]
  chSysRestoreStatusX(sts);
 801008a:	9805      	ldr	r0, [sp, #20]
 801008c:	f7f0 fc18 	bl	80008c0 <chSysRestoreStatusX>

  /* Reentrant case.*/
  chSysLock();
 8010090:	f7ff ff2e 	bl	800fef0 <chSysLock>
  sts = chSysGetStatusAndLockX();
 8010094:	f7f0 fbf4 	bl	8000880 <chSysGetStatusAndLockX>
 8010098:	9005      	str	r0, [sp, #20]
  chSysRestoreStatusX(sts);
 801009a:	9805      	ldr	r0, [sp, #20]
 801009c:	f7f0 fc10 	bl	80008c0 <chSysRestoreStatusX>
  chSysUnlock();
 80100a0:	f7ff ff2e 	bl	800ff00 <chSysUnlock>

  /* Unconditional lock.*/
  chSysUnconditionalLock();
 80100a4:	f7ff ff44 	bl	800ff30 <chSysUnconditionalLock>
  chSysUnconditionalLock();
 80100a8:	f7ff ff42 	bl	800ff30 <chSysUnconditionalLock>
  chSysUnlock();
 80100ac:	f7ff ff28 	bl	800ff00 <chSysUnlock>

  /* Unconditional unlock.*/
  chSysLock();
 80100b0:	f7ff ff1e 	bl	800fef0 <chSysLock>
  chSysUnconditionalUnlock();
 80100b4:	f7ff ff4c 	bl	800ff50 <chSysUnconditionalUnlock>
  chSysUnconditionalUnlock();
 80100b8:	f7ff ff4a 	bl	800ff50 <chSysUnconditionalUnlock>

  /*/Testing from ISR context using a virtual timer.*/
  chVTObjectInit(&vt);
 80100bc:	466b      	mov	r3, sp
 80100be:	4618      	mov	r0, r3
 80100c0:	f7ff ff56 	bl	800ff70 <chVTObjectInit>
  chVTSet(&vt, 1, vtcb, NULL);
 80100c4:	466b      	mov	r3, sp
 80100c6:	4618      	mov	r0, r3
 80100c8:	2101      	movs	r1, #1
 80100ca:	4a10      	ldr	r2, [pc, #64]	; (801010c <sys1_execute+0x8c>)
 80100cc:	2300      	movs	r3, #0
 80100ce:	f7ff ffa7 	bl	8010020 <chVTSet>
  chThdSleep(10);
 80100d2:	200a      	movs	r0, #10
 80100d4:	f7f1 f8fc 	bl	80012d0 <chThdSleep>

  test_assert(1, chVTIsArmed(&vt) == false, "timer still armed");
 80100d8:	466b      	mov	r3, sp
 80100da:	4618      	mov	r0, r3
 80100dc:	f7ff ff60 	bl	800ffa0 <chVTIsArmed>
 80100e0:	4603      	mov	r3, r0
 80100e2:	2b00      	cmp	r3, #0
 80100e4:	bf0c      	ite	eq
 80100e6:	2300      	moveq	r3, #0
 80100e8:	2301      	movne	r3, #1
 80100ea:	b2db      	uxtb	r3, r3
 80100ec:	f083 0301 	eor.w	r3, r3, #1
 80100f0:	b2db      	uxtb	r3, r3
 80100f2:	f003 0301 	and.w	r3, r3, #1
 80100f6:	b2db      	uxtb	r3, r3
 80100f8:	2001      	movs	r0, #1
 80100fa:	4619      	mov	r1, r3
 80100fc:	f7fb fef0 	bl	800bee0 <_test_assert>
 8010100:	4603      	mov	r3, r0
 8010102:	2b00      	cmp	r3, #0
}
 8010104:	b007      	add	sp, #28
 8010106:	f85d fb04 	ldr.w	pc, [sp], #4
 801010a:	bf00      	nop
 801010c:	08010051 	.word	0x08010051

08010110 <sys2_execute>:
 *
 * <h2>Description</h2>
 * The interrupts handling API is invoked for coverage.
 */

static void sys2_execute(void) {
 8010110:	b508      	push	{r3, lr}

  chSysSuspend();
 8010112:	f7ff fedd 	bl	800fed0 <chSysSuspend>
  chSysDisable();
 8010116:	f7ff fed3 	bl	800fec0 <chSysDisable>
  chSysSuspend();
 801011a:	f7ff fed9 	bl	800fed0 <chSysSuspend>
  chSysEnable();
 801011e:	f7ff fedf 	bl	800fee0 <chSysEnable>
}
 8010122:	bd08      	pop	{r3, pc}
 8010124:	f3af 8000 	nop.w
 8010128:	f3af 8000 	nop.w
 801012c:	f3af 8000 	nop.w

08010130 <sys3_execute>:
 * <h2>Description</h2>
 * The chSysIntegrityCheckI() API is invoked in order to asses the state of the
 * system data structures.
 */

static void sys3_execute(void) {
 8010130:	b500      	push	{lr}
 8010132:	b083      	sub	sp, #12
  bool result;

  chSysLock();
 8010134:	f7ff fedc 	bl	800fef0 <chSysLock>
  result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
 8010138:	2001      	movs	r0, #1
 801013a:	f7f0 fb01 	bl	8000740 <chSysIntegrityCheckI>
 801013e:	4603      	mov	r3, r0
 8010140:	f88d 3007 	strb.w	r3, [sp, #7]
  chSysUnlock();
 8010144:	f7ff fedc 	bl	800ff00 <chSysUnlock>
  test_assert(1, result == false, "ready list check failed");
 8010148:	f89d 3007 	ldrb.w	r3, [sp, #7]
 801014c:	2b00      	cmp	r3, #0
 801014e:	bf0c      	ite	eq
 8010150:	2300      	moveq	r3, #0
 8010152:	2301      	movne	r3, #1
 8010154:	b2db      	uxtb	r3, r3
 8010156:	f083 0301 	eor.w	r3, r3, #1
 801015a:	b2db      	uxtb	r3, r3
 801015c:	f003 0301 	and.w	r3, r3, #1
 8010160:	b2db      	uxtb	r3, r3
 8010162:	2001      	movs	r0, #1
 8010164:	4619      	mov	r1, r3
 8010166:	f7fb febb 	bl	800bee0 <_test_assert>
 801016a:	4603      	mov	r3, r0
 801016c:	2b00      	cmp	r3, #0
 801016e:	d000      	beq.n	8010172 <sys3_execute+0x42>
 8010170:	e05c      	b.n	801022c <sys3_execute+0xfc>

  chSysLock();
 8010172:	f7ff febd 	bl	800fef0 <chSysLock>
  result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
 8010176:	2002      	movs	r0, #2
 8010178:	f7f0 fae2 	bl	8000740 <chSysIntegrityCheckI>
 801017c:	4603      	mov	r3, r0
 801017e:	f88d 3007 	strb.w	r3, [sp, #7]
  chSysUnlock();
 8010182:	f7ff febd 	bl	800ff00 <chSysUnlock>
  test_assert(2, result == false, "virtual timers list check failed");
 8010186:	f89d 3007 	ldrb.w	r3, [sp, #7]
 801018a:	2b00      	cmp	r3, #0
 801018c:	bf0c      	ite	eq
 801018e:	2300      	moveq	r3, #0
 8010190:	2301      	movne	r3, #1
 8010192:	b2db      	uxtb	r3, r3
 8010194:	f083 0301 	eor.w	r3, r3, #1
 8010198:	b2db      	uxtb	r3, r3
 801019a:	f003 0301 	and.w	r3, r3, #1
 801019e:	b2db      	uxtb	r3, r3
 80101a0:	2002      	movs	r0, #2
 80101a2:	4619      	mov	r1, r3
 80101a4:	f7fb fe9c 	bl	800bee0 <_test_assert>
 80101a8:	4603      	mov	r3, r0
 80101aa:	2b00      	cmp	r3, #0
 80101ac:	d000      	beq.n	80101b0 <sys3_execute+0x80>
 80101ae:	e03d      	b.n	801022c <sys3_execute+0xfc>

  chSysLock();
 80101b0:	f7ff fe9e 	bl	800fef0 <chSysLock>
  result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
 80101b4:	2004      	movs	r0, #4
 80101b6:	f7f0 fac3 	bl	8000740 <chSysIntegrityCheckI>
 80101ba:	4603      	mov	r3, r0
 80101bc:	f88d 3007 	strb.w	r3, [sp, #7]
  chSysUnlock();
 80101c0:	f7ff fe9e 	bl	800ff00 <chSysUnlock>
  test_assert(3, result == false, "registry list check failed");
 80101c4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80101c8:	2b00      	cmp	r3, #0
 80101ca:	bf0c      	ite	eq
 80101cc:	2300      	moveq	r3, #0
 80101ce:	2301      	movne	r3, #1
 80101d0:	b2db      	uxtb	r3, r3
 80101d2:	f083 0301 	eor.w	r3, r3, #1
 80101d6:	b2db      	uxtb	r3, r3
 80101d8:	f003 0301 	and.w	r3, r3, #1
 80101dc:	b2db      	uxtb	r3, r3
 80101de:	2003      	movs	r0, #3
 80101e0:	4619      	mov	r1, r3
 80101e2:	f7fb fe7d 	bl	800bee0 <_test_assert>
 80101e6:	4603      	mov	r3, r0
 80101e8:	2b00      	cmp	r3, #0
 80101ea:	d000      	beq.n	80101ee <sys3_execute+0xbe>
 80101ec:	e01e      	b.n	801022c <sys3_execute+0xfc>

  chSysLock();
 80101ee:	f7ff fe7f 	bl	800fef0 <chSysLock>
  result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
 80101f2:	2008      	movs	r0, #8
 80101f4:	f7f0 faa4 	bl	8000740 <chSysIntegrityCheckI>
 80101f8:	4603      	mov	r3, r0
 80101fa:	f88d 3007 	strb.w	r3, [sp, #7]
  chSysUnlock();
 80101fe:	f7ff fe7f 	bl	800ff00 <chSysUnlock>
  test_assert(4, result == false, "port layer check failed");
 8010202:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8010206:	2b00      	cmp	r3, #0
 8010208:	bf0c      	ite	eq
 801020a:	2300      	moveq	r3, #0
 801020c:	2301      	movne	r3, #1
 801020e:	b2db      	uxtb	r3, r3
 8010210:	f083 0301 	eor.w	r3, r3, #1
 8010214:	b2db      	uxtb	r3, r3
 8010216:	f003 0301 	and.w	r3, r3, #1
 801021a:	b2db      	uxtb	r3, r3
 801021c:	2004      	movs	r0, #4
 801021e:	4619      	mov	r1, r3
 8010220:	f7fb fe5e 	bl	800bee0 <_test_assert>
 8010224:	4603      	mov	r3, r0
 8010226:	2b00      	cmp	r3, #0
 8010228:	d000      	beq.n	801022c <sys3_execute+0xfc>
 801022a:	bf00      	nop
}
 801022c:	b003      	add	sp, #12
 801022e:	f85d fb04 	ldr.w	pc, [sp], #4
 8010232:	bf00      	nop
 8010234:	f3af 8000 	nop.w
 8010238:	f3af 8000 	nop.w
 801023c:	f3af 8000 	nop.w

08010240 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8010240:	b082      	sub	sp, #8
 8010242:	2320      	movs	r3, #32
 8010244:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8010246:	9b01      	ldr	r3, [sp, #4]
 8010248:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 801024c:	b002      	add	sp, #8
 801024e:	4770      	bx	lr

08010250 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8010250:	b082      	sub	sp, #8
 8010252:	2300      	movs	r3, #0
 8010254:	9301      	str	r3, [sp, #4]
 8010256:	9b01      	ldr	r3, [sp, #4]
 8010258:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 801025c:	b002      	add	sp, #8
 801025e:	4770      	bx	lr

08010260 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8010260:	b508      	push	{r3, lr}

  port_lock();
 8010262:	f7ff ffed 	bl	8010240 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8010266:	bd08      	pop	{r3, pc}
 8010268:	f3af 8000 	nop.w
 801026c:	f3af 8000 	nop.w

08010270 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8010270:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8010272:	f7ff ffed 	bl	8010250 <port_unlock>
}
 8010276:	bd08      	pop	{r3, pc}
 8010278:	f3af 8000 	nop.w
 801027c:	f3af 8000 	nop.w

08010280 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8010280:	4b01      	ldr	r3, [pc, #4]	; (8010288 <chThdGetSelfX+0x8>)
 8010282:	699b      	ldr	r3, [r3, #24]
}
 8010284:	4618      	mov	r0, r3
 8010286:	4770      	bx	lr
 8010288:	200016e0 	.word	0x200016e0
 801028c:	f3af 8000 	nop.w

08010290 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 8010290:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 8010292:	f7ff fff5 	bl	8010280 <chThdGetSelfX>
 8010296:	4603      	mov	r3, r0
 8010298:	689b      	ldr	r3, [r3, #8]
}
 801029a:	4618      	mov	r0, r3
 801029c:	bd08      	pop	{r3, pc}
 801029e:	bf00      	nop

080102a0 <chThdShouldTerminateX>:
 * @retval true         termination request pending.
 * @retval false        termination request not pending.
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {
 80102a0:	b508      	push	{r3, lr}

  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 80102a2:	f7ff ffed 	bl	8010280 <chThdGetSelfX>
 80102a6:	4603      	mov	r3, r0
 80102a8:	7f5b      	ldrb	r3, [r3, #29]
 80102aa:	f003 0304 	and.w	r3, r3, #4
 80102ae:	2b00      	cmp	r3, #0
 80102b0:	bf0c      	ite	eq
 80102b2:	2300      	moveq	r3, #0
 80102b4:	2301      	movne	r3, #1
 80102b6:	b2db      	uxtb	r3, r3
}
 80102b8:	4618      	mov	r0, r3
 80102ba:	bd08      	pop	{r3, pc}
 80102bc:	f3af 8000 	nop.w

080102c0 <chMsgGet>:
 * @param[in] tp        pointer to the thread
 * @return              The message carried by the sender.
 *
 * @api
 */
static inline msg_t chMsgGet(thread_t *tp) {
 80102c0:	b082      	sub	sp, #8
 80102c2:	9001      	str	r0, [sp, #4]

  return tp->p_msg;
 80102c4:	9b01      	ldr	r3, [sp, #4]
 80102c6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
}
 80102c8:	4618      	mov	r0, r3
 80102ca:	b002      	add	sp, #8
 80102cc:	4770      	bx	lr
 80102ce:	bf00      	nop

080102d0 <chIQGet>:
 * @return              A byte value from the queue.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {
 80102d0:	b500      	push	{lr}
 80102d2:	b083      	sub	sp, #12
 80102d4:	9001      	str	r0, [sp, #4]

  return chIQGetTimeout(iqp, TIME_INFINITE);
 80102d6:	9801      	ldr	r0, [sp, #4]
 80102d8:	f04f 31ff 	mov.w	r1, #4294967295
 80102dc:	f7f2 ffd0 	bl	8003280 <chIQGetTimeout>
 80102e0:	4603      	mov	r3, r0
}
 80102e2:	4618      	mov	r0, r3
 80102e4:	b003      	add	sp, #12
 80102e6:	f85d fb04 	ldr.w	pc, [sp], #4
 80102ea:	bf00      	nop
 80102ec:	f3af 8000 	nop.w

080102f0 <thread1>:
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
static mutex_t mtx1;
#endif

static THD_FUNCTION(thread1, p) {
 80102f0:	b500      	push	{lr}
 80102f2:	b083      	sub	sp, #12
 80102f4:	9001      	str	r0, [sp, #4]

  chThdExit((msg_t)p);
 80102f6:	9b01      	ldr	r3, [sp, #4]
 80102f8:	4618      	mov	r0, r3
 80102fa:	f7f1 f839 	bl	8001370 <chThdExit>
}
 80102fe:	b003      	add	sp, #12
 8010300:	f85d fb04 	ldr.w	pc, [sp], #4
 8010304:	f3af 8000 	nop.w
 8010308:	f3af 8000 	nop.w
 801030c:	f3af 8000 	nop.w

08010310 <thread2>:

#if CH_CFG_USE_MESSAGES || defined(__DOXYGEN__)
static THD_FUNCTION(thread2, p) {
 8010310:	b500      	push	{lr}
 8010312:	b085      	sub	sp, #20
 8010314:	9001      	str	r0, [sp, #4]
  thread_t *tp;
  msg_t msg;

  (void)p;
  do {
    tp = chMsgWait();
 8010316:	f7f2 fc73 	bl	8002c00 <chMsgWait>
 801031a:	9003      	str	r0, [sp, #12]
    msg = chMsgGet(tp);
 801031c:	9803      	ldr	r0, [sp, #12]
 801031e:	f7ff ffcf 	bl	80102c0 <chMsgGet>
 8010322:	9002      	str	r0, [sp, #8]
    chMsgRelease(tp, msg);
 8010324:	9803      	ldr	r0, [sp, #12]
 8010326:	9902      	ldr	r1, [sp, #8]
 8010328:	f7f2 fc92 	bl	8002c50 <chMsgRelease>
  } while (msg);
 801032c:	9b02      	ldr	r3, [sp, #8]
 801032e:	2b00      	cmp	r3, #0
 8010330:	d1f1      	bne.n	8010316 <thread2+0x6>
}
 8010332:	b005      	add	sp, #20
 8010334:	f85d fb04 	ldr.w	pc, [sp], #4
 8010338:	f3af 8000 	nop.w
 801033c:	f3af 8000 	nop.w

08010340 <msg_loop_test>:

#ifdef __GNUC__
__attribute__((noinline))
#endif
static unsigned int msg_loop_test(thread_t *tp) {
 8010340:	b500      	push	{lr}
 8010342:	b085      	sub	sp, #20
 8010344:	9001      	str	r0, [sp, #4]

  uint32_t n = 0;
 8010346:	2300      	movs	r3, #0
 8010348:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 801034a:	f7fb fe71 	bl	800c030 <test_wait_tick>
  test_start_timer(1000);
 801034e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8010352:	f7fb fe8d 	bl	800c070 <test_start_timer>
  do {
    (void)chMsgSend(tp, 1);
 8010356:	9801      	ldr	r0, [sp, #4]
 8010358:	2101      	movs	r1, #1
 801035a:	f7f2 fc21 	bl	8002ba0 <chMsgSend>
    n++;
 801035e:	9b03      	ldr	r3, [sp, #12]
 8010360:	3301      	adds	r3, #1
 8010362:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8010364:	4b07      	ldr	r3, [pc, #28]	; (8010384 <msg_loop_test+0x44>)
 8010366:	781b      	ldrb	r3, [r3, #0]
 8010368:	f083 0301 	eor.w	r3, r3, #1
 801036c:	b2db      	uxtb	r3, r3
 801036e:	2b00      	cmp	r3, #0
 8010370:	d1f1      	bne.n	8010356 <msg_loop_test+0x16>
  (void)chMsgSend(tp, 0);
 8010372:	9801      	ldr	r0, [sp, #4]
 8010374:	2100      	movs	r1, #0
 8010376:	f7f2 fc13 	bl	8002ba0 <chMsgSend>
  return n;
 801037a:	9b03      	ldr	r3, [sp, #12]
}
 801037c:	4618      	mov	r0, r3
 801037e:	b005      	add	sp, #20
 8010380:	f85d fb04 	ldr.w	pc, [sp], #4
 8010384:	20001ba1 	.word	0x20001ba1
 8010388:	f3af 8000 	nop.w
 801038c:	f3af 8000 	nop.w

08010390 <bmk1_execute>:
 * A message server thread is created with a lower priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk1_execute(void) {
 8010390:	b510      	push	{r4, lr}
 8010392:	b084      	sub	sp, #16
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2, NULL);
 8010394:	4b16      	ldr	r3, [pc, #88]	; (80103f0 <bmk1_execute+0x60>)
 8010396:	681c      	ldr	r4, [r3, #0]
 8010398:	f7ff ff7a 	bl	8010290 <chThdGetPriorityX>
 801039c:	4603      	mov	r3, r0
 801039e:	3b01      	subs	r3, #1
 80103a0:	2200      	movs	r2, #0
 80103a2:	9200      	str	r2, [sp, #0]
 80103a4:	4620      	mov	r0, r4
 80103a6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80103aa:	461a      	mov	r2, r3
 80103ac:	4b11      	ldr	r3, [pc, #68]	; (80103f4 <bmk1_execute+0x64>)
 80103ae:	f7f0 ff17 	bl	80011e0 <chThdCreateStatic>
 80103b2:	4602      	mov	r2, r0
 80103b4:	4b10      	ldr	r3, [pc, #64]	; (80103f8 <bmk1_execute+0x68>)
 80103b6:	601a      	str	r2, [r3, #0]
  n = msg_loop_test(threads[0]);
 80103b8:	4b0f      	ldr	r3, [pc, #60]	; (80103f8 <bmk1_execute+0x68>)
 80103ba:	681b      	ldr	r3, [r3, #0]
 80103bc:	4618      	mov	r0, r3
 80103be:	f7ff ffbf 	bl	8010340 <msg_loop_test>
 80103c2:	9003      	str	r0, [sp, #12]
  test_wait_threads();
 80103c4:	f7fb fe0c 	bl	800bfe0 <test_wait_threads>
  test_print("--- Score : ");
 80103c8:	480c      	ldr	r0, [pc, #48]	; (80103fc <bmk1_execute+0x6c>)
 80103ca:	f7fb fcf9 	bl	800bdc0 <test_print>
  test_printn(n);
 80103ce:	9803      	ldr	r0, [sp, #12]
 80103d0:	f7fb fcae 	bl	800bd30 <test_printn>
  test_print(" msgs/S, ");
 80103d4:	480a      	ldr	r0, [pc, #40]	; (8010400 <bmk1_execute+0x70>)
 80103d6:	f7fb fcf3 	bl	800bdc0 <test_print>
  test_printn(n << 1);
 80103da:	9b03      	ldr	r3, [sp, #12]
 80103dc:	005b      	lsls	r3, r3, #1
 80103de:	4618      	mov	r0, r3
 80103e0:	f7fb fca6 	bl	800bd30 <test_printn>
  test_println(" ctxswc/S");
 80103e4:	4807      	ldr	r0, [pc, #28]	; (8010404 <bmk1_execute+0x74>)
 80103e6:	f7fb fd0b 	bl	800be00 <test_println>
}
 80103ea:	b004      	add	sp, #16
 80103ec:	bd10      	pop	{r4, pc}
 80103ee:	bf00      	nop
 80103f0:	08017b20 	.word	0x08017b20
 80103f4:	08010311 	.word	0x08010311
 80103f8:	20001ba4 	.word	0x20001ba4
 80103fc:	080183b0 	.word	0x080183b0
 8010400:	080183c0 	.word	0x080183c0
 8010404:	080183cc 	.word	0x080183cc
 8010408:	f3af 8000 	nop.w
 801040c:	f3af 8000 	nop.w

08010410 <bmk2_execute>:
 * A message server thread is created with an higher priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk2_execute(void) {
 8010410:	b510      	push	{r4, lr}
 8010412:	b084      	sub	sp, #16
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8010414:	4b16      	ldr	r3, [pc, #88]	; (8010470 <bmk2_execute+0x60>)
 8010416:	681c      	ldr	r4, [r3, #0]
 8010418:	f7ff ff3a 	bl	8010290 <chThdGetPriorityX>
 801041c:	4603      	mov	r3, r0
 801041e:	3301      	adds	r3, #1
 8010420:	2200      	movs	r2, #0
 8010422:	9200      	str	r2, [sp, #0]
 8010424:	4620      	mov	r0, r4
 8010426:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801042a:	461a      	mov	r2, r3
 801042c:	4b11      	ldr	r3, [pc, #68]	; (8010474 <bmk2_execute+0x64>)
 801042e:	f7f0 fed7 	bl	80011e0 <chThdCreateStatic>
 8010432:	4602      	mov	r2, r0
 8010434:	4b10      	ldr	r3, [pc, #64]	; (8010478 <bmk2_execute+0x68>)
 8010436:	601a      	str	r2, [r3, #0]
  n = msg_loop_test(threads[0]);
 8010438:	4b0f      	ldr	r3, [pc, #60]	; (8010478 <bmk2_execute+0x68>)
 801043a:	681b      	ldr	r3, [r3, #0]
 801043c:	4618      	mov	r0, r3
 801043e:	f7ff ff7f 	bl	8010340 <msg_loop_test>
 8010442:	9003      	str	r0, [sp, #12]
  test_wait_threads();
 8010444:	f7fb fdcc 	bl	800bfe0 <test_wait_threads>
  test_print("--- Score : ");
 8010448:	480c      	ldr	r0, [pc, #48]	; (801047c <bmk2_execute+0x6c>)
 801044a:	f7fb fcb9 	bl	800bdc0 <test_print>
  test_printn(n);
 801044e:	9803      	ldr	r0, [sp, #12]
 8010450:	f7fb fc6e 	bl	800bd30 <test_printn>
  test_print(" msgs/S, ");
 8010454:	480a      	ldr	r0, [pc, #40]	; (8010480 <bmk2_execute+0x70>)
 8010456:	f7fb fcb3 	bl	800bdc0 <test_print>
  test_printn(n << 1);
 801045a:	9b03      	ldr	r3, [sp, #12]
 801045c:	005b      	lsls	r3, r3, #1
 801045e:	4618      	mov	r0, r3
 8010460:	f7fb fc66 	bl	800bd30 <test_printn>
  test_println(" ctxswc/S");
 8010464:	4807      	ldr	r0, [pc, #28]	; (8010484 <bmk2_execute+0x74>)
 8010466:	f7fb fccb 	bl	800be00 <test_println>
}
 801046a:	b004      	add	sp, #16
 801046c:	bd10      	pop	{r4, pc}
 801046e:	bf00      	nop
 8010470:	08017b20 	.word	0x08017b20
 8010474:	08010311 	.word	0x08010311
 8010478:	20001ba4 	.word	0x20001ba4
 801047c:	080183b0 	.word	0x080183b0
 8010480:	080183c0 	.word	0x080183c0
 8010484:	080183cc 	.word	0x080183cc
 8010488:	f3af 8000 	nop.w
 801048c:	f3af 8000 	nop.w

08010490 <bmk3_execute>:
 * thread, four lower priority threads crowd the ready list, the messages
 * throughput per second is measured while the ready list and the result
 * printed in the output log.
 */

static void bmk3_execute(void) {
 8010490:	b510      	push	{r4, lr}
 8010492:	b084      	sub	sp, #16
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8010494:	4b3a      	ldr	r3, [pc, #232]	; (8010580 <bmk3_execute+0xf0>)
 8010496:	681c      	ldr	r4, [r3, #0]
 8010498:	f7ff fefa 	bl	8010290 <chThdGetPriorityX>
 801049c:	4603      	mov	r3, r0
 801049e:	3301      	adds	r3, #1
 80104a0:	2200      	movs	r2, #0
 80104a2:	9200      	str	r2, [sp, #0]
 80104a4:	4620      	mov	r0, r4
 80104a6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80104aa:	461a      	mov	r2, r3
 80104ac:	4b35      	ldr	r3, [pc, #212]	; (8010584 <bmk3_execute+0xf4>)
 80104ae:	f7f0 fe97 	bl	80011e0 <chThdCreateStatic>
 80104b2:	4602      	mov	r2, r0
 80104b4:	4b34      	ldr	r3, [pc, #208]	; (8010588 <bmk3_execute+0xf8>)
 80104b6:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 80104b8:	4b31      	ldr	r3, [pc, #196]	; (8010580 <bmk3_execute+0xf0>)
 80104ba:	685c      	ldr	r4, [r3, #4]
 80104bc:	f7ff fee8 	bl	8010290 <chThdGetPriorityX>
 80104c0:	4603      	mov	r3, r0
 80104c2:	3b02      	subs	r3, #2
 80104c4:	2200      	movs	r2, #0
 80104c6:	9200      	str	r2, [sp, #0]
 80104c8:	4620      	mov	r0, r4
 80104ca:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80104ce:	461a      	mov	r2, r3
 80104d0:	4b2e      	ldr	r3, [pc, #184]	; (801058c <bmk3_execute+0xfc>)
 80104d2:	f7f0 fe85 	bl	80011e0 <chThdCreateStatic>
 80104d6:	4602      	mov	r2, r0
 80104d8:	4b2b      	ldr	r3, [pc, #172]	; (8010588 <bmk3_execute+0xf8>)
 80104da:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
 80104dc:	4b28      	ldr	r3, [pc, #160]	; (8010580 <bmk3_execute+0xf0>)
 80104de:	689c      	ldr	r4, [r3, #8]
 80104e0:	f7ff fed6 	bl	8010290 <chThdGetPriorityX>
 80104e4:	4603      	mov	r3, r0
 80104e6:	3b03      	subs	r3, #3
 80104e8:	2200      	movs	r2, #0
 80104ea:	9200      	str	r2, [sp, #0]
 80104ec:	4620      	mov	r0, r4
 80104ee:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80104f2:	461a      	mov	r2, r3
 80104f4:	4b25      	ldr	r3, [pc, #148]	; (801058c <bmk3_execute+0xfc>)
 80104f6:	f7f0 fe73 	bl	80011e0 <chThdCreateStatic>
 80104fa:	4602      	mov	r2, r0
 80104fc:	4b22      	ldr	r3, [pc, #136]	; (8010588 <bmk3_execute+0xf8>)
 80104fe:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
 8010500:	4b1f      	ldr	r3, [pc, #124]	; (8010580 <bmk3_execute+0xf0>)
 8010502:	68dc      	ldr	r4, [r3, #12]
 8010504:	f7ff fec4 	bl	8010290 <chThdGetPriorityX>
 8010508:	4603      	mov	r3, r0
 801050a:	3b04      	subs	r3, #4
 801050c:	2200      	movs	r2, #0
 801050e:	9200      	str	r2, [sp, #0]
 8010510:	4620      	mov	r0, r4
 8010512:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8010516:	461a      	mov	r2, r3
 8010518:	4b1c      	ldr	r3, [pc, #112]	; (801058c <bmk3_execute+0xfc>)
 801051a:	f7f0 fe61 	bl	80011e0 <chThdCreateStatic>
 801051e:	4602      	mov	r2, r0
 8010520:	4b19      	ldr	r3, [pc, #100]	; (8010588 <bmk3_execute+0xf8>)
 8010522:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, thread1, NULL);
 8010524:	4b16      	ldr	r3, [pc, #88]	; (8010580 <bmk3_execute+0xf0>)
 8010526:	691c      	ldr	r4, [r3, #16]
 8010528:	f7ff feb2 	bl	8010290 <chThdGetPriorityX>
 801052c:	4603      	mov	r3, r0
 801052e:	3b05      	subs	r3, #5
 8010530:	2200      	movs	r2, #0
 8010532:	9200      	str	r2, [sp, #0]
 8010534:	4620      	mov	r0, r4
 8010536:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801053a:	461a      	mov	r2, r3
 801053c:	4b13      	ldr	r3, [pc, #76]	; (801058c <bmk3_execute+0xfc>)
 801053e:	f7f0 fe4f 	bl	80011e0 <chThdCreateStatic>
 8010542:	4602      	mov	r2, r0
 8010544:	4b10      	ldr	r3, [pc, #64]	; (8010588 <bmk3_execute+0xf8>)
 8010546:	611a      	str	r2, [r3, #16]
  n = msg_loop_test(threads[0]);
 8010548:	4b0f      	ldr	r3, [pc, #60]	; (8010588 <bmk3_execute+0xf8>)
 801054a:	681b      	ldr	r3, [r3, #0]
 801054c:	4618      	mov	r0, r3
 801054e:	f7ff fef7 	bl	8010340 <msg_loop_test>
 8010552:	9003      	str	r0, [sp, #12]
  test_wait_threads();
 8010554:	f7fb fd44 	bl	800bfe0 <test_wait_threads>
  test_print("--- Score : ");
 8010558:	480d      	ldr	r0, [pc, #52]	; (8010590 <bmk3_execute+0x100>)
 801055a:	f7fb fc31 	bl	800bdc0 <test_print>
  test_printn(n);
 801055e:	9803      	ldr	r0, [sp, #12]
 8010560:	f7fb fbe6 	bl	800bd30 <test_printn>
  test_print(" msgs/S, ");
 8010564:	480b      	ldr	r0, [pc, #44]	; (8010594 <bmk3_execute+0x104>)
 8010566:	f7fb fc2b 	bl	800bdc0 <test_print>
  test_printn(n << 1);
 801056a:	9b03      	ldr	r3, [sp, #12]
 801056c:	005b      	lsls	r3, r3, #1
 801056e:	4618      	mov	r0, r3
 8010570:	f7fb fbde 	bl	800bd30 <test_printn>
  test_println(" ctxswc/S");
 8010574:	4808      	ldr	r0, [pc, #32]	; (8010598 <bmk3_execute+0x108>)
 8010576:	f7fb fc43 	bl	800be00 <test_println>
}
 801057a:	b004      	add	sp, #16
 801057c:	bd10      	pop	{r4, pc}
 801057e:	bf00      	nop
 8010580:	08017b20 	.word	0x08017b20
 8010584:	08010311 	.word	0x08010311
 8010588:	20001ba4 	.word	0x20001ba4
 801058c:	080102f1 	.word	0x080102f1
 8010590:	080183b0 	.word	0x080183b0
 8010594:	080183c0 	.word	0x080183c0
 8010598:	080183cc 	.word	0x080183cc
 801059c:	f3af 8000 	nop.w

080105a0 <thread4>:
 * the thread is awakened as fast is possible by the tester thread.<br>
 * The Context Switch performance is calculated by measuring the number of
 * iterations after a second of continuous operations.
 */

static THD_FUNCTION(thread4, p) {
 80105a0:	b500      	push	{lr}
 80105a2:	b085      	sub	sp, #20
 80105a4:	9001      	str	r0, [sp, #4]
  msg_t msg;
  thread_t *self = chThdGetSelfX();
 80105a6:	f7ff fe6b 	bl	8010280 <chThdGetSelfX>
 80105aa:	9003      	str	r0, [sp, #12]

  (void)p;
  chSysLock();
 80105ac:	f7ff fe58 	bl	8010260 <chSysLock>
  do {
    chSchGoSleepS(CH_STATE_SUSPENDED);
 80105b0:	2003      	movs	r0, #3
 80105b2:	f7f0 fb1d 	bl	8000bf0 <chSchGoSleepS>
    msg = self->p_u.rdymsg;
 80105b6:	9b03      	ldr	r3, [sp, #12]
 80105b8:	6a1b      	ldr	r3, [r3, #32]
 80105ba:	9302      	str	r3, [sp, #8]
  } while (msg == MSG_OK);
 80105bc:	9b02      	ldr	r3, [sp, #8]
 80105be:	2b00      	cmp	r3, #0
 80105c0:	d0f6      	beq.n	80105b0 <thread4+0x10>
  chSysUnlock();
 80105c2:	f7ff fe55 	bl	8010270 <chSysUnlock>
}
 80105c6:	b005      	add	sp, #20
 80105c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80105cc:	f3af 8000 	nop.w

080105d0 <bmk4_execute>:

static void bmk4_execute(void) {
 80105d0:	b510      	push	{r4, lr}
 80105d2:	b084      	sub	sp, #16
  thread_t *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 80105d4:	4b29      	ldr	r3, [pc, #164]	; (801067c <bmk4_execute+0xac>)
 80105d6:	681c      	ldr	r4, [r3, #0]
 80105d8:	f7ff fe5a 	bl	8010290 <chThdGetPriorityX>
 80105dc:	4603      	mov	r3, r0
 80105de:	3301      	adds	r3, #1
 80105e0:	2200      	movs	r2, #0
 80105e2:	9200      	str	r2, [sp, #0]
 80105e4:	4620      	mov	r0, r4
 80105e6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80105ea:	461a      	mov	r2, r3
 80105ec:	4b24      	ldr	r3, [pc, #144]	; (8010680 <bmk4_execute+0xb0>)
 80105ee:	f7f0 fdf7 	bl	80011e0 <chThdCreateStatic>
 80105f2:	4602      	mov	r2, r0
 80105f4:	4b23      	ldr	r3, [pc, #140]	; (8010684 <bmk4_execute+0xb4>)
 80105f6:	601a      	str	r2, [r3, #0]
 80105f8:	4b22      	ldr	r3, [pc, #136]	; (8010684 <bmk4_execute+0xb4>)
 80105fa:	681b      	ldr	r3, [r3, #0]
 80105fc:	9302      	str	r3, [sp, #8]
                                      thread4, NULL);
  n = 0;
 80105fe:	2300      	movs	r3, #0
 8010600:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 8010602:	f7fb fd15 	bl	800c030 <test_wait_tick>
  test_start_timer(1000);
 8010606:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 801060a:	f7fb fd31 	bl	800c070 <test_start_timer>
  do {
    chSysLock();
 801060e:	f7ff fe27 	bl	8010260 <chSysLock>
    chSchWakeupS(tp, MSG_OK);
 8010612:	9802      	ldr	r0, [sp, #8]
 8010614:	2100      	movs	r1, #0
 8010616:	f7f0 fb8b 	bl	8000d30 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 801061a:	9802      	ldr	r0, [sp, #8]
 801061c:	2100      	movs	r1, #0
 801061e:	f7f0 fb87 	bl	8000d30 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 8010622:	9802      	ldr	r0, [sp, #8]
 8010624:	2100      	movs	r1, #0
 8010626:	f7f0 fb83 	bl	8000d30 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 801062a:	9802      	ldr	r0, [sp, #8]
 801062c:	2100      	movs	r1, #0
 801062e:	f7f0 fb7f 	bl	8000d30 <chSchWakeupS>
    chSysUnlock();
 8010632:	f7ff fe1d 	bl	8010270 <chSysUnlock>
    n += 4;
 8010636:	9b03      	ldr	r3, [sp, #12]
 8010638:	3304      	adds	r3, #4
 801063a:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 801063c:	4b12      	ldr	r3, [pc, #72]	; (8010688 <bmk4_execute+0xb8>)
 801063e:	781b      	ldrb	r3, [r3, #0]
 8010640:	f083 0301 	eor.w	r3, r3, #1
 8010644:	b2db      	uxtb	r3, r3
 8010646:	2b00      	cmp	r3, #0
 8010648:	d1e1      	bne.n	801060e <bmk4_execute+0x3e>
  chSysLock();
 801064a:	f7ff fe09 	bl	8010260 <chSysLock>
  chSchWakeupS(tp, MSG_TIMEOUT);
 801064e:	9802      	ldr	r0, [sp, #8]
 8010650:	f04f 31ff 	mov.w	r1, #4294967295
 8010654:	f7f0 fb6c 	bl	8000d30 <chSchWakeupS>
  chSysUnlock();
 8010658:	f7ff fe0a 	bl	8010270 <chSysUnlock>

  test_wait_threads();
 801065c:	f7fb fcc0 	bl	800bfe0 <test_wait_threads>
  test_print("--- Score : ");
 8010660:	480a      	ldr	r0, [pc, #40]	; (801068c <bmk4_execute+0xbc>)
 8010662:	f7fb fbad 	bl	800bdc0 <test_print>
  test_printn(n * 2);
 8010666:	9b03      	ldr	r3, [sp, #12]
 8010668:	005b      	lsls	r3, r3, #1
 801066a:	4618      	mov	r0, r3
 801066c:	f7fb fb60 	bl	800bd30 <test_printn>
  test_println(" ctxswc/S");
 8010670:	4807      	ldr	r0, [pc, #28]	; (8010690 <bmk4_execute+0xc0>)
 8010672:	f7fb fbc5 	bl	800be00 <test_println>
}
 8010676:	b004      	add	sp, #16
 8010678:	bd10      	pop	{r4, pc}
 801067a:	bf00      	nop
 801067c:	08017b20 	.word	0x08017b20
 8010680:	080105a1 	.word	0x080105a1
 8010684:	20001ba4 	.word	0x20001ba4
 8010688:	20001ba1 	.word	0x20001ba1
 801068c:	080183b0 	.word	0x080183b0
 8010690:	080183cc 	.word	0x080183cc
 8010694:	f3af 8000 	nop.w
 8010698:	f3af 8000 	nop.w
 801069c:	f3af 8000 	nop.w

080106a0 <bmk5_execute>:
 * in each iteration.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk5_execute(void) {
 80106a0:	b500      	push	{lr}
 80106a2:	b087      	sub	sp, #28

  uint32_t n = 0;
 80106a4:	2300      	movs	r3, #0
 80106a6:	9305      	str	r3, [sp, #20]
  void *wap = wa[0];
 80106a8:	4b18      	ldr	r3, [pc, #96]	; (801070c <bmk5_execute+0x6c>)
 80106aa:	681b      	ldr	r3, [r3, #0]
 80106ac:	9304      	str	r3, [sp, #16]
  tprio_t prio = chThdGetPriorityX() - 1;
 80106ae:	f7ff fdef 	bl	8010290 <chThdGetPriorityX>
 80106b2:	4603      	mov	r3, r0
 80106b4:	3b01      	subs	r3, #1
 80106b6:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 80106b8:	f7fb fcba 	bl	800c030 <test_wait_tick>
  test_start_timer(1000);
 80106bc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80106c0:	f7fb fcd6 	bl	800c070 <test_start_timer>
  do {
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
 80106c4:	2300      	movs	r3, #0
 80106c6:	9300      	str	r3, [sp, #0]
 80106c8:	9804      	ldr	r0, [sp, #16]
 80106ca:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80106ce:	9a03      	ldr	r2, [sp, #12]
 80106d0:	4b0f      	ldr	r3, [pc, #60]	; (8010710 <bmk5_execute+0x70>)
 80106d2:	f7f0 fd85 	bl	80011e0 <chThdCreateStatic>
 80106d6:	4603      	mov	r3, r0
 80106d8:	4618      	mov	r0, r3
 80106da:	f7f0 fe91 	bl	8001400 <chThdWait>
    n++;
 80106de:	9b05      	ldr	r3, [sp, #20]
 80106e0:	3301      	adds	r3, #1
 80106e2:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80106e4:	4b0b      	ldr	r3, [pc, #44]	; (8010714 <bmk5_execute+0x74>)
 80106e6:	781b      	ldrb	r3, [r3, #0]
 80106e8:	f083 0301 	eor.w	r3, r3, #1
 80106ec:	b2db      	uxtb	r3, r3
 80106ee:	2b00      	cmp	r3, #0
 80106f0:	d1e8      	bne.n	80106c4 <bmk5_execute+0x24>
  test_print("--- Score : ");
 80106f2:	4809      	ldr	r0, [pc, #36]	; (8010718 <bmk5_execute+0x78>)
 80106f4:	f7fb fb64 	bl	800bdc0 <test_print>
  test_printn(n);
 80106f8:	9805      	ldr	r0, [sp, #20]
 80106fa:	f7fb fb19 	bl	800bd30 <test_printn>
  test_println(" threads/S");
 80106fe:	4807      	ldr	r0, [pc, #28]	; (801071c <bmk5_execute+0x7c>)
 8010700:	f7fb fb7e 	bl	800be00 <test_println>
}
 8010704:	b007      	add	sp, #28
 8010706:	f85d fb04 	ldr.w	pc, [sp], #4
 801070a:	bf00      	nop
 801070c:	08017b20 	.word	0x08017b20
 8010710:	080102f1 	.word	0x080102f1
 8010714:	20001ba1 	.word	0x20001ba1
 8010718:	080183b0 	.word	0x080183b0
 801071c:	0801847c 	.word	0x0801847c

08010720 <bmk6_execute>:
 * terminate.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk6_execute(void) {
 8010720:	b500      	push	{lr}
 8010722:	b087      	sub	sp, #28

  uint32_t n = 0;
 8010724:	2300      	movs	r3, #0
 8010726:	9305      	str	r3, [sp, #20]
  void *wap = wa[0];
 8010728:	4b16      	ldr	r3, [pc, #88]	; (8010784 <bmk6_execute+0x64>)
 801072a:	681b      	ldr	r3, [r3, #0]
 801072c:	9304      	str	r3, [sp, #16]
  tprio_t prio = chThdGetPriorityX() + 1;
 801072e:	f7ff fdaf 	bl	8010290 <chThdGetPriorityX>
 8010732:	4603      	mov	r3, r0
 8010734:	3301      	adds	r3, #1
 8010736:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 8010738:	f7fb fc7a 	bl	800c030 <test_wait_tick>
  test_start_timer(1000);
 801073c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8010740:	f7fb fc96 	bl	800c070 <test_start_timer>
  do {
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
 8010744:	2300      	movs	r3, #0
 8010746:	9300      	str	r3, [sp, #0]
 8010748:	9804      	ldr	r0, [sp, #16]
 801074a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801074e:	9a03      	ldr	r2, [sp, #12]
 8010750:	4b0d      	ldr	r3, [pc, #52]	; (8010788 <bmk6_execute+0x68>)
 8010752:	f7f0 fd45 	bl	80011e0 <chThdCreateStatic>
    n++;
 8010756:	9b05      	ldr	r3, [sp, #20]
 8010758:	3301      	adds	r3, #1
 801075a:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 801075c:	4b0b      	ldr	r3, [pc, #44]	; (801078c <bmk6_execute+0x6c>)
 801075e:	781b      	ldrb	r3, [r3, #0]
 8010760:	f083 0301 	eor.w	r3, r3, #1
 8010764:	b2db      	uxtb	r3, r3
 8010766:	2b00      	cmp	r3, #0
 8010768:	d1ec      	bne.n	8010744 <bmk6_execute+0x24>
  test_print("--- Score : ");
 801076a:	4809      	ldr	r0, [pc, #36]	; (8010790 <bmk6_execute+0x70>)
 801076c:	f7fb fb28 	bl	800bdc0 <test_print>
  test_printn(n);
 8010770:	9805      	ldr	r0, [sp, #20]
 8010772:	f7fb fadd 	bl	800bd30 <test_printn>
  test_println(" threads/S");
 8010776:	4807      	ldr	r0, [pc, #28]	; (8010794 <bmk6_execute+0x74>)
 8010778:	f7fb fb42 	bl	800be00 <test_println>
}
 801077c:	b007      	add	sp, #28
 801077e:	f85d fb04 	ldr.w	pc, [sp], #4
 8010782:	bf00      	nop
 8010784:	08017b20 	.word	0x08017b20
 8010788:	080102f1 	.word	0x080102f1
 801078c:	20001ba1 	.word	0x20001ba1
 8010790:	080183b0 	.word	0x080183b0
 8010794:	0801847c 	.word	0x0801847c
 8010798:	f3af 8000 	nop.w
 801079c:	f3af 8000 	nop.w

080107a0 <thread3>:
 * continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static THD_FUNCTION(thread3, p) {
 80107a0:	b500      	push	{lr}
 80107a2:	b083      	sub	sp, #12
 80107a4:	9001      	str	r0, [sp, #4]

  (void)p;
  while (!chThdShouldTerminateX())
 80107a6:	e002      	b.n	80107ae <thread3+0xe>
    chSemWait(&sem1);
 80107a8:	4806      	ldr	r0, [pc, #24]	; (80107c4 <thread3+0x24>)
 80107aa:	f7f1 f9d1 	bl	8001b50 <chSemWait>
 */

static THD_FUNCTION(thread3, p) {

  (void)p;
  while (!chThdShouldTerminateX())
 80107ae:	f7ff fd77 	bl	80102a0 <chThdShouldTerminateX>
 80107b2:	4603      	mov	r3, r0
 80107b4:	f083 0301 	eor.w	r3, r3, #1
 80107b8:	b2db      	uxtb	r3, r3
 80107ba:	2b00      	cmp	r3, #0
 80107bc:	d1f4      	bne.n	80107a8 <thread3+0x8>
    chSemWait(&sem1);
}
 80107be:	b003      	add	sp, #12
 80107c0:	f85d fb04 	ldr.w	pc, [sp], #4
 80107c4:	20001018 	.word	0x20001018
 80107c8:	f3af 8000 	nop.w
 80107cc:	f3af 8000 	nop.w

080107d0 <bmk7_setup>:

static void bmk7_setup(void) {
 80107d0:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 0);
 80107d2:	4802      	ldr	r0, [pc, #8]	; (80107dc <bmk7_setup+0xc>)
 80107d4:	2100      	movs	r1, #0
 80107d6:	f7f1 f973 	bl	8001ac0 <chSemObjectInit>
}
 80107da:	bd08      	pop	{r3, pc}
 80107dc:	20001018 	.word	0x20001018

080107e0 <bmk7_execute>:

static void bmk7_execute(void) {
 80107e0:	b510      	push	{r4, lr}
 80107e2:	b084      	sub	sp, #16
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 80107e4:	4b46      	ldr	r3, [pc, #280]	; (8010900 <bmk7_execute+0x120>)
 80107e6:	681c      	ldr	r4, [r3, #0]
 80107e8:	f7ff fd52 	bl	8010290 <chThdGetPriorityX>
 80107ec:	4603      	mov	r3, r0
 80107ee:	3305      	adds	r3, #5
 80107f0:	2200      	movs	r2, #0
 80107f2:	9200      	str	r2, [sp, #0]
 80107f4:	4620      	mov	r0, r4
 80107f6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80107fa:	461a      	mov	r2, r3
 80107fc:	4b41      	ldr	r3, [pc, #260]	; (8010904 <bmk7_execute+0x124>)
 80107fe:	f7f0 fcef 	bl	80011e0 <chThdCreateStatic>
 8010802:	4602      	mov	r2, r0
 8010804:	4b40      	ldr	r3, [pc, #256]	; (8010908 <bmk7_execute+0x128>)
 8010806:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
 8010808:	4b3d      	ldr	r3, [pc, #244]	; (8010900 <bmk7_execute+0x120>)
 801080a:	685c      	ldr	r4, [r3, #4]
 801080c:	f7ff fd40 	bl	8010290 <chThdGetPriorityX>
 8010810:	4603      	mov	r3, r0
 8010812:	3304      	adds	r3, #4
 8010814:	2200      	movs	r2, #0
 8010816:	9200      	str	r2, [sp, #0]
 8010818:	4620      	mov	r0, r4
 801081a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801081e:	461a      	mov	r2, r3
 8010820:	4b38      	ldr	r3, [pc, #224]	; (8010904 <bmk7_execute+0x124>)
 8010822:	f7f0 fcdd 	bl	80011e0 <chThdCreateStatic>
 8010826:	4602      	mov	r2, r0
 8010828:	4b37      	ldr	r3, [pc, #220]	; (8010908 <bmk7_execute+0x128>)
 801082a:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
 801082c:	4b34      	ldr	r3, [pc, #208]	; (8010900 <bmk7_execute+0x120>)
 801082e:	689c      	ldr	r4, [r3, #8]
 8010830:	f7ff fd2e 	bl	8010290 <chThdGetPriorityX>
 8010834:	4603      	mov	r3, r0
 8010836:	3303      	adds	r3, #3
 8010838:	2200      	movs	r2, #0
 801083a:	9200      	str	r2, [sp, #0]
 801083c:	4620      	mov	r0, r4
 801083e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8010842:	461a      	mov	r2, r3
 8010844:	4b2f      	ldr	r3, [pc, #188]	; (8010904 <bmk7_execute+0x124>)
 8010846:	f7f0 fccb 	bl	80011e0 <chThdCreateStatic>
 801084a:	4602      	mov	r2, r0
 801084c:	4b2e      	ldr	r3, [pc, #184]	; (8010908 <bmk7_execute+0x128>)
 801084e:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
 8010850:	4b2b      	ldr	r3, [pc, #172]	; (8010900 <bmk7_execute+0x120>)
 8010852:	68dc      	ldr	r4, [r3, #12]
 8010854:	f7ff fd1c 	bl	8010290 <chThdGetPriorityX>
 8010858:	4603      	mov	r3, r0
 801085a:	3302      	adds	r3, #2
 801085c:	2200      	movs	r2, #0
 801085e:	9200      	str	r2, [sp, #0]
 8010860:	4620      	mov	r0, r4
 8010862:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8010866:	461a      	mov	r2, r3
 8010868:	4b26      	ldr	r3, [pc, #152]	; (8010904 <bmk7_execute+0x124>)
 801086a:	f7f0 fcb9 	bl	80011e0 <chThdCreateStatic>
 801086e:	4602      	mov	r2, r0
 8010870:	4b25      	ldr	r3, [pc, #148]	; (8010908 <bmk7_execute+0x128>)
 8010872:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, thread3, NULL);
 8010874:	4b22      	ldr	r3, [pc, #136]	; (8010900 <bmk7_execute+0x120>)
 8010876:	691c      	ldr	r4, [r3, #16]
 8010878:	f7ff fd0a 	bl	8010290 <chThdGetPriorityX>
 801087c:	4603      	mov	r3, r0
 801087e:	3301      	adds	r3, #1
 8010880:	2200      	movs	r2, #0
 8010882:	9200      	str	r2, [sp, #0]
 8010884:	4620      	mov	r0, r4
 8010886:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801088a:	461a      	mov	r2, r3
 801088c:	4b1d      	ldr	r3, [pc, #116]	; (8010904 <bmk7_execute+0x124>)
 801088e:	f7f0 fca7 	bl	80011e0 <chThdCreateStatic>
 8010892:	4602      	mov	r2, r0
 8010894:	4b1c      	ldr	r3, [pc, #112]	; (8010908 <bmk7_execute+0x128>)
 8010896:	611a      	str	r2, [r3, #16]

  n = 0;
 8010898:	2300      	movs	r3, #0
 801089a:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 801089c:	f7fb fbc8 	bl	800c030 <test_wait_tick>
  test_start_timer(1000);
 80108a0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80108a4:	f7fb fbe4 	bl	800c070 <test_start_timer>
  do {
    chSemReset(&sem1, 0);
 80108a8:	4818      	ldr	r0, [pc, #96]	; (801090c <bmk7_execute+0x12c>)
 80108aa:	2100      	movs	r1, #0
 80108ac:	f7f1 f918 	bl	8001ae0 <chSemReset>
    n++;
 80108b0:	9b03      	ldr	r3, [sp, #12]
 80108b2:	3301      	adds	r3, #1
 80108b4:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80108b6:	4b16      	ldr	r3, [pc, #88]	; (8010910 <bmk7_execute+0x130>)
 80108b8:	781b      	ldrb	r3, [r3, #0]
 80108ba:	f083 0301 	eor.w	r3, r3, #1
 80108be:	b2db      	uxtb	r3, r3
 80108c0:	2b00      	cmp	r3, #0
 80108c2:	d1f1      	bne.n	80108a8 <bmk7_execute+0xc8>
  test_terminate_threads();
 80108c4:	f7fb fb6c 	bl	800bfa0 <test_terminate_threads>
  chSemReset(&sem1, 0);
 80108c8:	4810      	ldr	r0, [pc, #64]	; (801090c <bmk7_execute+0x12c>)
 80108ca:	2100      	movs	r1, #0
 80108cc:	f7f1 f908 	bl	8001ae0 <chSemReset>
  test_wait_threads();
 80108d0:	f7fb fb86 	bl	800bfe0 <test_wait_threads>

  test_print("--- Score : ");
 80108d4:	480f      	ldr	r0, [pc, #60]	; (8010914 <bmk7_execute+0x134>)
 80108d6:	f7fb fa73 	bl	800bdc0 <test_print>
  test_printn(n);
 80108da:	9803      	ldr	r0, [sp, #12]
 80108dc:	f7fb fa28 	bl	800bd30 <test_printn>
  test_print(" reschedules/S, ");
 80108e0:	480d      	ldr	r0, [pc, #52]	; (8010918 <bmk7_execute+0x138>)
 80108e2:	f7fb fa6d 	bl	800bdc0 <test_print>
  test_printn(n * 6);
 80108e6:	9a03      	ldr	r2, [sp, #12]
 80108e8:	4613      	mov	r3, r2
 80108ea:	005b      	lsls	r3, r3, #1
 80108ec:	4413      	add	r3, r2
 80108ee:	005b      	lsls	r3, r3, #1
 80108f0:	4618      	mov	r0, r3
 80108f2:	f7fb fa1d 	bl	800bd30 <test_printn>
  test_println(" ctxswc/S");
 80108f6:	4809      	ldr	r0, [pc, #36]	; (801091c <bmk7_execute+0x13c>)
 80108f8:	f7fb fa82 	bl	800be00 <test_println>
}
 80108fc:	b004      	add	sp, #16
 80108fe:	bd10      	pop	{r4, pc}
 8010900:	08017b20 	.word	0x08017b20
 8010904:	080107a1 	.word	0x080107a1
 8010908:	20001ba4 	.word	0x20001ba4
 801090c:	20001018 	.word	0x20001018
 8010910:	20001ba1 	.word	0x20001ba1
 8010914:	080183b0 	.word	0x080183b0
 8010918:	080184e8 	.word	0x080184e8
 801091c:	080183cc 	.word	0x080183cc

08010920 <thread8>:
 * variable and yields.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static THD_FUNCTION(thread8, p) {
 8010920:	b500      	push	{lr}
 8010922:	b083      	sub	sp, #12
 8010924:	9001      	str	r0, [sp, #4]

  do {
    chThdYield();
 8010926:	f7f0 fd1b 	bl	8001360 <chThdYield>
    chThdYield();
 801092a:	f7f0 fd19 	bl	8001360 <chThdYield>
    chThdYield();
 801092e:	f7f0 fd17 	bl	8001360 <chThdYield>
    chThdYield();
 8010932:	f7f0 fd15 	bl	8001360 <chThdYield>
    (*(uint32_t *)p) += 4;
 8010936:	9b01      	ldr	r3, [sp, #4]
 8010938:	681b      	ldr	r3, [r3, #0]
 801093a:	1d1a      	adds	r2, r3, #4
 801093c:	9b01      	ldr	r3, [sp, #4]
 801093e:	601a      	str	r2, [r3, #0]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
 8010940:	f7ff fcae 	bl	80102a0 <chThdShouldTerminateX>
 8010944:	4603      	mov	r3, r0
 8010946:	f083 0301 	eor.w	r3, r3, #1
 801094a:	b2db      	uxtb	r3, r3
 801094c:	2b00      	cmp	r3, #0
 801094e:	d1ea      	bne.n	8010926 <thread8+0x6>
}
 8010950:	b003      	add	sp, #12
 8010952:	f85d fb04 	ldr.w	pc, [sp], #4
 8010956:	bf00      	nop
 8010958:	f3af 8000 	nop.w
 801095c:	f3af 8000 	nop.w

08010960 <bmk8_execute>:

static void bmk8_execute(void) {
 8010960:	b510      	push	{r4, lr}
 8010962:	b084      	sub	sp, #16
  uint32_t n;

  n = 0;
 8010964:	2300      	movs	r3, #0
 8010966:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 8010968:	f7fb fb62 	bl	800c030 <test_wait_tick>

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 801096c:	4b36      	ldr	r3, [pc, #216]	; (8010a48 <bmk8_execute+0xe8>)
 801096e:	681c      	ldr	r4, [r3, #0]
 8010970:	f7ff fc8e 	bl	8010290 <chThdGetPriorityX>
 8010974:	4603      	mov	r3, r0
 8010976:	3b01      	subs	r3, #1
 8010978:	aa03      	add	r2, sp, #12
 801097a:	9200      	str	r2, [sp, #0]
 801097c:	4620      	mov	r0, r4
 801097e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8010982:	461a      	mov	r2, r3
 8010984:	4b31      	ldr	r3, [pc, #196]	; (8010a4c <bmk8_execute+0xec>)
 8010986:	f7f0 fc2b 	bl	80011e0 <chThdCreateStatic>
 801098a:	4602      	mov	r2, r0
 801098c:	4b30      	ldr	r3, [pc, #192]	; (8010a50 <bmk8_execute+0xf0>)
 801098e:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8010990:	4b2d      	ldr	r3, [pc, #180]	; (8010a48 <bmk8_execute+0xe8>)
 8010992:	685c      	ldr	r4, [r3, #4]
 8010994:	f7ff fc7c 	bl	8010290 <chThdGetPriorityX>
 8010998:	4603      	mov	r3, r0
 801099a:	3b01      	subs	r3, #1
 801099c:	aa03      	add	r2, sp, #12
 801099e:	9200      	str	r2, [sp, #0]
 80109a0:	4620      	mov	r0, r4
 80109a2:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80109a6:	461a      	mov	r2, r3
 80109a8:	4b28      	ldr	r3, [pc, #160]	; (8010a4c <bmk8_execute+0xec>)
 80109aa:	f7f0 fc19 	bl	80011e0 <chThdCreateStatic>
 80109ae:	4602      	mov	r2, r0
 80109b0:	4b27      	ldr	r3, [pc, #156]	; (8010a50 <bmk8_execute+0xf0>)
 80109b2:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 80109b4:	4b24      	ldr	r3, [pc, #144]	; (8010a48 <bmk8_execute+0xe8>)
 80109b6:	689c      	ldr	r4, [r3, #8]
 80109b8:	f7ff fc6a 	bl	8010290 <chThdGetPriorityX>
 80109bc:	4603      	mov	r3, r0
 80109be:	3b01      	subs	r3, #1
 80109c0:	aa03      	add	r2, sp, #12
 80109c2:	9200      	str	r2, [sp, #0]
 80109c4:	4620      	mov	r0, r4
 80109c6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80109ca:	461a      	mov	r2, r3
 80109cc:	4b1f      	ldr	r3, [pc, #124]	; (8010a4c <bmk8_execute+0xec>)
 80109ce:	f7f0 fc07 	bl	80011e0 <chThdCreateStatic>
 80109d2:	4602      	mov	r2, r0
 80109d4:	4b1e      	ldr	r3, [pc, #120]	; (8010a50 <bmk8_execute+0xf0>)
 80109d6:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 80109d8:	4b1b      	ldr	r3, [pc, #108]	; (8010a48 <bmk8_execute+0xe8>)
 80109da:	68dc      	ldr	r4, [r3, #12]
 80109dc:	f7ff fc58 	bl	8010290 <chThdGetPriorityX>
 80109e0:	4603      	mov	r3, r0
 80109e2:	3b01      	subs	r3, #1
 80109e4:	aa03      	add	r2, sp, #12
 80109e6:	9200      	str	r2, [sp, #0]
 80109e8:	4620      	mov	r0, r4
 80109ea:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80109ee:	461a      	mov	r2, r3
 80109f0:	4b16      	ldr	r3, [pc, #88]	; (8010a4c <bmk8_execute+0xec>)
 80109f2:	f7f0 fbf5 	bl	80011e0 <chThdCreateStatic>
 80109f6:	4602      	mov	r2, r0
 80109f8:	4b15      	ldr	r3, [pc, #84]	; (8010a50 <bmk8_execute+0xf0>)
 80109fa:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 80109fc:	4b12      	ldr	r3, [pc, #72]	; (8010a48 <bmk8_execute+0xe8>)
 80109fe:	691c      	ldr	r4, [r3, #16]
 8010a00:	f7ff fc46 	bl	8010290 <chThdGetPriorityX>
 8010a04:	4603      	mov	r3, r0
 8010a06:	3b01      	subs	r3, #1
 8010a08:	aa03      	add	r2, sp, #12
 8010a0a:	9200      	str	r2, [sp, #0]
 8010a0c:	4620      	mov	r0, r4
 8010a0e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8010a12:	461a      	mov	r2, r3
 8010a14:	4b0d      	ldr	r3, [pc, #52]	; (8010a4c <bmk8_execute+0xec>)
 8010a16:	f7f0 fbe3 	bl	80011e0 <chThdCreateStatic>
 8010a1a:	4602      	mov	r2, r0
 8010a1c:	4b0c      	ldr	r3, [pc, #48]	; (8010a50 <bmk8_execute+0xf0>)
 8010a1e:	611a      	str	r2, [r3, #16]

  chThdSleepSeconds(1);
 8010a20:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8010a24:	f7f0 fc54 	bl	80012d0 <chThdSleep>
  test_terminate_threads();
 8010a28:	f7fb faba 	bl	800bfa0 <test_terminate_threads>
  test_wait_threads();
 8010a2c:	f7fb fad8 	bl	800bfe0 <test_wait_threads>

  test_print("--- Score : ");
 8010a30:	4808      	ldr	r0, [pc, #32]	; (8010a54 <bmk8_execute+0xf4>)
 8010a32:	f7fb f9c5 	bl	800bdc0 <test_print>
  test_printn(n);
 8010a36:	9b03      	ldr	r3, [sp, #12]
 8010a38:	4618      	mov	r0, r3
 8010a3a:	f7fb f979 	bl	800bd30 <test_printn>
  test_println(" ctxswc/S");
 8010a3e:	4806      	ldr	r0, [pc, #24]	; (8010a58 <bmk8_execute+0xf8>)
 8010a40:	f7fb f9de 	bl	800be00 <test_println>
}
 8010a44:	b004      	add	sp, #16
 8010a46:	bd10      	pop	{r4, pc}
 8010a48:	08017b20 	.word	0x08017b20
 8010a4c:	08010921 	.word	0x08010921
 8010a50:	20001ba4 	.word	0x20001ba4
 8010a54:	080183b0 	.word	0x080183b0
 8010a58:	080183cc 	.word	0x080183cc
 8010a5c:	f3af 8000 	nop.w

08010a60 <bmk9_execute>:
 * loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk9_execute(void) {
 8010a60:	b500      	push	{lr}
 8010a62:	b085      	sub	sp, #20
  uint32_t n;
  static uint8_t ib[16];
  static input_queue_t iq;

  chIQObjectInit(&iq, ib, sizeof(ib), NULL, NULL);
 8010a64:	2300      	movs	r3, #0
 8010a66:	9300      	str	r3, [sp, #0]
 8010a68:	4822      	ldr	r0, [pc, #136]	; (8010af4 <bmk9_execute+0x94>)
 8010a6a:	4923      	ldr	r1, [pc, #140]	; (8010af8 <bmk9_execute+0x98>)
 8010a6c:	2210      	movs	r2, #16
 8010a6e:	2300      	movs	r3, #0
 8010a70:	f7f2 fb96 	bl	80031a0 <chIQObjectInit>
  n = 0;
 8010a74:	2300      	movs	r3, #0
 8010a76:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 8010a78:	f7fb fada 	bl	800c030 <test_wait_tick>
  test_start_timer(1000);
 8010a7c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8010a80:	f7fb faf6 	bl	800c070 <test_start_timer>
  do {
    chSysLock();
 8010a84:	f7ff fbec 	bl	8010260 <chSysLock>
    chIQPutI(&iq, 0);
 8010a88:	481a      	ldr	r0, [pc, #104]	; (8010af4 <bmk9_execute+0x94>)
 8010a8a:	2100      	movs	r1, #0
 8010a8c:	f7f2 fbc8 	bl	8003220 <chIQPutI>
    chIQPutI(&iq, 1);
 8010a90:	4818      	ldr	r0, [pc, #96]	; (8010af4 <bmk9_execute+0x94>)
 8010a92:	2101      	movs	r1, #1
 8010a94:	f7f2 fbc4 	bl	8003220 <chIQPutI>
    chIQPutI(&iq, 2);
 8010a98:	4816      	ldr	r0, [pc, #88]	; (8010af4 <bmk9_execute+0x94>)
 8010a9a:	2102      	movs	r1, #2
 8010a9c:	f7f2 fbc0 	bl	8003220 <chIQPutI>
    chIQPutI(&iq, 3);
 8010aa0:	4814      	ldr	r0, [pc, #80]	; (8010af4 <bmk9_execute+0x94>)
 8010aa2:	2103      	movs	r1, #3
 8010aa4:	f7f2 fbbc 	bl	8003220 <chIQPutI>
    chSysUnlock();
 8010aa8:	f7ff fbe2 	bl	8010270 <chSysUnlock>
    (void)chIQGet(&iq);
 8010aac:	4811      	ldr	r0, [pc, #68]	; (8010af4 <bmk9_execute+0x94>)
 8010aae:	f7ff fc0f 	bl	80102d0 <chIQGet>
    (void)chIQGet(&iq);
 8010ab2:	4810      	ldr	r0, [pc, #64]	; (8010af4 <bmk9_execute+0x94>)
 8010ab4:	f7ff fc0c 	bl	80102d0 <chIQGet>
    (void)chIQGet(&iq);
 8010ab8:	480e      	ldr	r0, [pc, #56]	; (8010af4 <bmk9_execute+0x94>)
 8010aba:	f7ff fc09 	bl	80102d0 <chIQGet>
    (void)chIQGet(&iq);
 8010abe:	480d      	ldr	r0, [pc, #52]	; (8010af4 <bmk9_execute+0x94>)
 8010ac0:	f7ff fc06 	bl	80102d0 <chIQGet>
    n++;
 8010ac4:	9b03      	ldr	r3, [sp, #12]
 8010ac6:	3301      	adds	r3, #1
 8010ac8:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8010aca:	4b0c      	ldr	r3, [pc, #48]	; (8010afc <bmk9_execute+0x9c>)
 8010acc:	781b      	ldrb	r3, [r3, #0]
 8010ace:	f083 0301 	eor.w	r3, r3, #1
 8010ad2:	b2db      	uxtb	r3, r3
 8010ad4:	2b00      	cmp	r3, #0
 8010ad6:	d1d5      	bne.n	8010a84 <bmk9_execute+0x24>
  test_print("--- Score : ");
 8010ad8:	4809      	ldr	r0, [pc, #36]	; (8010b00 <bmk9_execute+0xa0>)
 8010ada:	f7fb f971 	bl	800bdc0 <test_print>
  test_printn(n * 4);
 8010ade:	9b03      	ldr	r3, [sp, #12]
 8010ae0:	009b      	lsls	r3, r3, #2
 8010ae2:	4618      	mov	r0, r3
 8010ae4:	f7fb f924 	bl	800bd30 <test_printn>
  test_println(" bytes/S");
 8010ae8:	4806      	ldr	r0, [pc, #24]	; (8010b04 <bmk9_execute+0xa4>)
 8010aea:	f7fb f989 	bl	800be00 <test_println>
}
 8010aee:	b005      	add	sp, #20
 8010af0:	f85d fb04 	ldr.w	pc, [sp], #4
 8010af4:	20001034 	.word	0x20001034
 8010af8:	20001058 	.word	0x20001058
 8010afc:	20001ba1 	.word	0x20001ba1
 8010b00:	080183b0 	.word	0x080183b0
 8010b04:	08018570 	.word	0x08018570
 8010b08:	f3af 8000 	nop.w
 8010b0c:	f3af 8000 	nop.w

08010b10 <tmo>:
 * A virtual timer is set and immediately reset into a continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void tmo(void *param) {(void)param;}
 8010b10:	b082      	sub	sp, #8
 8010b12:	9001      	str	r0, [sp, #4]
 8010b14:	b002      	add	sp, #8
 8010b16:	4770      	bx	lr
 8010b18:	f3af 8000 	nop.w
 8010b1c:	f3af 8000 	nop.w

08010b20 <bmk10_execute>:

static void bmk10_execute(void) {
 8010b20:	b500      	push	{lr}
 8010b22:	b083      	sub	sp, #12
  static virtual_timer_t vt1, vt2;
  uint32_t n = 0;
 8010b24:	2300      	movs	r3, #0
 8010b26:	9301      	str	r3, [sp, #4]

  test_wait_tick();
 8010b28:	f7fb fa82 	bl	800c030 <test_wait_tick>
  test_start_timer(1000);
 8010b2c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8010b30:	f7fb fa9e 	bl	800c070 <test_start_timer>
  do {
    chSysLock();
 8010b34:	f7ff fb94 	bl	8010260 <chSysLock>
    chVTDoSetI(&vt1, 1, tmo, NULL);
 8010b38:	4816      	ldr	r0, [pc, #88]	; (8010b94 <bmk10_execute+0x74>)
 8010b3a:	2101      	movs	r1, #1
 8010b3c:	4a16      	ldr	r2, [pc, #88]	; (8010b98 <bmk10_execute+0x78>)
 8010b3e:	2300      	movs	r3, #0
 8010b40:	f7ef ff26 	bl	8000990 <chVTDoSetI>
    chVTDoSetI(&vt2, 10000, tmo, NULL);
 8010b44:	4815      	ldr	r0, [pc, #84]	; (8010b9c <bmk10_execute+0x7c>)
 8010b46:	f242 7110 	movw	r1, #10000	; 0x2710
 8010b4a:	4a13      	ldr	r2, [pc, #76]	; (8010b98 <bmk10_execute+0x78>)
 8010b4c:	2300      	movs	r3, #0
 8010b4e:	f7ef ff1f 	bl	8000990 <chVTDoSetI>
    chVTDoResetI(&vt1);
 8010b52:	4810      	ldr	r0, [pc, #64]	; (8010b94 <bmk10_execute+0x74>)
 8010b54:	f7ef ff5c 	bl	8000a10 <chVTDoResetI>
    chVTDoResetI(&vt2);
 8010b58:	4810      	ldr	r0, [pc, #64]	; (8010b9c <bmk10_execute+0x7c>)
 8010b5a:	f7ef ff59 	bl	8000a10 <chVTDoResetI>
    chSysUnlock();
 8010b5e:	f7ff fb87 	bl	8010270 <chSysUnlock>
    n++;
 8010b62:	9b01      	ldr	r3, [sp, #4]
 8010b64:	3301      	adds	r3, #1
 8010b66:	9301      	str	r3, [sp, #4]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8010b68:	4b0d      	ldr	r3, [pc, #52]	; (8010ba0 <bmk10_execute+0x80>)
 8010b6a:	781b      	ldrb	r3, [r3, #0]
 8010b6c:	f083 0301 	eor.w	r3, r3, #1
 8010b70:	b2db      	uxtb	r3, r3
 8010b72:	2b00      	cmp	r3, #0
 8010b74:	d1de      	bne.n	8010b34 <bmk10_execute+0x14>
  test_print("--- Score : ");
 8010b76:	480b      	ldr	r0, [pc, #44]	; (8010ba4 <bmk10_execute+0x84>)
 8010b78:	f7fb f922 	bl	800bdc0 <test_print>
  test_printn(n * 2);
 8010b7c:	9b01      	ldr	r3, [sp, #4]
 8010b7e:	005b      	lsls	r3, r3, #1
 8010b80:	4618      	mov	r0, r3
 8010b82:	f7fb f8d5 	bl	800bd30 <test_printn>
  test_println(" timers/S");
 8010b86:	4808      	ldr	r0, [pc, #32]	; (8010ba8 <bmk10_execute+0x88>)
 8010b88:	f7fb f93a 	bl	800be00 <test_println>
}
 8010b8c:	b003      	add	sp, #12
 8010b8e:	f85d fb04 	ldr.w	pc, [sp], #4
 8010b92:	bf00      	nop
 8010b94:	20001068 	.word	0x20001068
 8010b98:	08010b11 	.word	0x08010b11
 8010b9c:	2000107c 	.word	0x2000107c
 8010ba0:	20001ba1 	.word	0x20001ba1
 8010ba4:	080183b0 	.word	0x080183b0
 8010ba8:	080185b0 	.word	0x080185b0
 8010bac:	f3af 8000 	nop.w

08010bb0 <bmk11_setup>:
 * Switch happens because the counter is always non negative.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk11_setup(void) {
 8010bb0:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 1);
 8010bb2:	4802      	ldr	r0, [pc, #8]	; (8010bbc <bmk11_setup+0xc>)
 8010bb4:	2101      	movs	r1, #1
 8010bb6:	f7f0 ff83 	bl	8001ac0 <chSemObjectInit>
}
 8010bba:	bd08      	pop	{r3, pc}
 8010bbc:	20001018 	.word	0x20001018

08010bc0 <bmk11_execute>:

static void bmk11_execute(void) {
 8010bc0:	b500      	push	{lr}
 8010bc2:	b083      	sub	sp, #12
  uint32_t n = 0;
 8010bc4:	2300      	movs	r3, #0
 8010bc6:	9301      	str	r3, [sp, #4]

  test_wait_tick();
 8010bc8:	f7fb fa32 	bl	800c030 <test_wait_tick>
  test_start_timer(1000);
 8010bcc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8010bd0:	f7fb fa4e 	bl	800c070 <test_start_timer>
  do {
    chSemWait(&sem1);
 8010bd4:	4817      	ldr	r0, [pc, #92]	; (8010c34 <bmk11_execute+0x74>)
 8010bd6:	f7f0 ffbb 	bl	8001b50 <chSemWait>
    chSemSignal(&sem1);
 8010bda:	4816      	ldr	r0, [pc, #88]	; (8010c34 <bmk11_execute+0x74>)
 8010bdc:	f7f1 f838 	bl	8001c50 <chSemSignal>
    chSemWait(&sem1);
 8010be0:	4814      	ldr	r0, [pc, #80]	; (8010c34 <bmk11_execute+0x74>)
 8010be2:	f7f0 ffb5 	bl	8001b50 <chSemWait>
    chSemSignal(&sem1);
 8010be6:	4813      	ldr	r0, [pc, #76]	; (8010c34 <bmk11_execute+0x74>)
 8010be8:	f7f1 f832 	bl	8001c50 <chSemSignal>
    chSemWait(&sem1);
 8010bec:	4811      	ldr	r0, [pc, #68]	; (8010c34 <bmk11_execute+0x74>)
 8010bee:	f7f0 ffaf 	bl	8001b50 <chSemWait>
    chSemSignal(&sem1);
 8010bf2:	4810      	ldr	r0, [pc, #64]	; (8010c34 <bmk11_execute+0x74>)
 8010bf4:	f7f1 f82c 	bl	8001c50 <chSemSignal>
    chSemWait(&sem1);
 8010bf8:	480e      	ldr	r0, [pc, #56]	; (8010c34 <bmk11_execute+0x74>)
 8010bfa:	f7f0 ffa9 	bl	8001b50 <chSemWait>
    chSemSignal(&sem1);
 8010bfe:	480d      	ldr	r0, [pc, #52]	; (8010c34 <bmk11_execute+0x74>)
 8010c00:	f7f1 f826 	bl	8001c50 <chSemSignal>
    n++;
 8010c04:	9b01      	ldr	r3, [sp, #4]
 8010c06:	3301      	adds	r3, #1
 8010c08:	9301      	str	r3, [sp, #4]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8010c0a:	4b0b      	ldr	r3, [pc, #44]	; (8010c38 <bmk11_execute+0x78>)
 8010c0c:	781b      	ldrb	r3, [r3, #0]
 8010c0e:	f083 0301 	eor.w	r3, r3, #1
 8010c12:	b2db      	uxtb	r3, r3
 8010c14:	2b00      	cmp	r3, #0
 8010c16:	d1dd      	bne.n	8010bd4 <bmk11_execute+0x14>
  test_print("--- Score : ");
 8010c18:	4808      	ldr	r0, [pc, #32]	; (8010c3c <bmk11_execute+0x7c>)
 8010c1a:	f7fb f8d1 	bl	800bdc0 <test_print>
  test_printn(n * 4);
 8010c1e:	9b01      	ldr	r3, [sp, #4]
 8010c20:	009b      	lsls	r3, r3, #2
 8010c22:	4618      	mov	r0, r3
 8010c24:	f7fb f884 	bl	800bd30 <test_printn>
  test_println(" wait+signal/S");
 8010c28:	4805      	ldr	r0, [pc, #20]	; (8010c40 <bmk11_execute+0x80>)
 8010c2a:	f7fb f8e9 	bl	800be00 <test_println>
}
 8010c2e:	b003      	add	sp, #12
 8010c30:	f85d fb04 	ldr.w	pc, [sp], #4
 8010c34:	20001018 	.word	0x20001018
 8010c38:	20001ba1 	.word	0x20001ba1
 8010c3c:	080183b0 	.word	0x080183b0
 8010c40:	080185f0 	.word	0x080185f0
 8010c44:	f3af 8000 	nop.w
 8010c48:	f3af 8000 	nop.w
 8010c4c:	f3af 8000 	nop.w

08010c50 <bmk12_setup>:
 * because there are no other threads asking for the mutex.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk12_setup(void) {
 8010c50:	b508      	push	{r3, lr}

  chMtxObjectInit(&mtx1);
 8010c52:	4802      	ldr	r0, [pc, #8]	; (8010c5c <bmk12_setup+0xc>)
 8010c54:	f7f1 f94c 	bl	8001ef0 <chMtxObjectInit>
}
 8010c58:	bd08      	pop	{r3, pc}
 8010c5a:	bf00      	nop
 8010c5c:	20001024 	.word	0x20001024

08010c60 <bmk12_execute>:

static void bmk12_execute(void) {
 8010c60:	b500      	push	{lr}
 8010c62:	b083      	sub	sp, #12
  uint32_t n = 0;
 8010c64:	2300      	movs	r3, #0
 8010c66:	9301      	str	r3, [sp, #4]

  test_wait_tick();
 8010c68:	f7fb f9e2 	bl	800c030 <test_wait_tick>
  test_start_timer(1000);
 8010c6c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8010c70:	f7fb f9fe 	bl	800c070 <test_start_timer>
  do {
    chMtxLock(&mtx1);
 8010c74:	4817      	ldr	r0, [pc, #92]	; (8010cd4 <bmk12_execute+0x74>)
 8010c76:	f7f1 f94b 	bl	8001f10 <chMtxLock>
    chMtxUnlock(&mtx1);
 8010c7a:	4816      	ldr	r0, [pc, #88]	; (8010cd4 <bmk12_execute+0x74>)
 8010c7c:	f7f1 f9f0 	bl	8002060 <chMtxUnlock>
    chMtxLock(&mtx1);
 8010c80:	4814      	ldr	r0, [pc, #80]	; (8010cd4 <bmk12_execute+0x74>)
 8010c82:	f7f1 f945 	bl	8001f10 <chMtxLock>
    chMtxUnlock(&mtx1);
 8010c86:	4813      	ldr	r0, [pc, #76]	; (8010cd4 <bmk12_execute+0x74>)
 8010c88:	f7f1 f9ea 	bl	8002060 <chMtxUnlock>
    chMtxLock(&mtx1);
 8010c8c:	4811      	ldr	r0, [pc, #68]	; (8010cd4 <bmk12_execute+0x74>)
 8010c8e:	f7f1 f93f 	bl	8001f10 <chMtxLock>
    chMtxUnlock(&mtx1);
 8010c92:	4810      	ldr	r0, [pc, #64]	; (8010cd4 <bmk12_execute+0x74>)
 8010c94:	f7f1 f9e4 	bl	8002060 <chMtxUnlock>
    chMtxLock(&mtx1);
 8010c98:	480e      	ldr	r0, [pc, #56]	; (8010cd4 <bmk12_execute+0x74>)
 8010c9a:	f7f1 f939 	bl	8001f10 <chMtxLock>
    chMtxUnlock(&mtx1);
 8010c9e:	480d      	ldr	r0, [pc, #52]	; (8010cd4 <bmk12_execute+0x74>)
 8010ca0:	f7f1 f9de 	bl	8002060 <chMtxUnlock>
    n++;
 8010ca4:	9b01      	ldr	r3, [sp, #4]
 8010ca6:	3301      	adds	r3, #1
 8010ca8:	9301      	str	r3, [sp, #4]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8010caa:	4b0b      	ldr	r3, [pc, #44]	; (8010cd8 <bmk12_execute+0x78>)
 8010cac:	781b      	ldrb	r3, [r3, #0]
 8010cae:	f083 0301 	eor.w	r3, r3, #1
 8010cb2:	b2db      	uxtb	r3, r3
 8010cb4:	2b00      	cmp	r3, #0
 8010cb6:	d1dd      	bne.n	8010c74 <bmk12_execute+0x14>
  test_print("--- Score : ");
 8010cb8:	4808      	ldr	r0, [pc, #32]	; (8010cdc <bmk12_execute+0x7c>)
 8010cba:	f7fb f881 	bl	800bdc0 <test_print>
  test_printn(n * 4);
 8010cbe:	9b01      	ldr	r3, [sp, #4]
 8010cc0:	009b      	lsls	r3, r3, #2
 8010cc2:	4618      	mov	r0, r3
 8010cc4:	f7fb f834 	bl	800bd30 <test_printn>
  test_println(" lock+unlock/S");
 8010cc8:	4805      	ldr	r0, [pc, #20]	; (8010ce0 <bmk12_execute+0x80>)
 8010cca:	f7fb f899 	bl	800be00 <test_println>
}
 8010cce:	b003      	add	sp, #12
 8010cd0:	f85d fb04 	ldr.w	pc, [sp], #4
 8010cd4:	20001024 	.word	0x20001024
 8010cd8:	20001ba1 	.word	0x20001ba1
 8010cdc:	080183b0 	.word	0x080183b0
 8010ce0:	08018634 	.word	0x08018634
 8010ce4:	f3af 8000 	nop.w
 8010ce8:	f3af 8000 	nop.w
 8010cec:	f3af 8000 	nop.w

08010cf0 <bmk13_execute>:
 *
 * <h2>Description</h2>
 * The memory size of the various kernel objects is printed.
 */

static void bmk13_execute(void) {
 8010cf0:	b508      	push	{r3, lr}

  test_print("--- System: ");
 8010cf2:	482e      	ldr	r0, [pc, #184]	; (8010dac <bmk13_execute+0xbc>)
 8010cf4:	f7fb f864 	bl	800bdc0 <test_print>
  test_printn(sizeof(ch_system_t));
 8010cf8:	f44f 70a8 	mov.w	r0, #336	; 0x150
 8010cfc:	f7fb f818 	bl	800bd30 <test_printn>
  test_println(" bytes");
 8010d00:	482b      	ldr	r0, [pc, #172]	; (8010db0 <bmk13_execute+0xc0>)
 8010d02:	f7fb f87d 	bl	800be00 <test_println>
  test_print("--- Thread: ");
 8010d06:	482b      	ldr	r0, [pc, #172]	; (8010db4 <bmk13_execute+0xc4>)
 8010d08:	f7fb f85a 	bl	800bdc0 <test_print>
  test_printn(sizeof(thread_t));
 8010d0c:	2044      	movs	r0, #68	; 0x44
 8010d0e:	f7fb f80f 	bl	800bd30 <test_printn>
  test_println(" bytes");
 8010d12:	4827      	ldr	r0, [pc, #156]	; (8010db0 <bmk13_execute+0xc0>)
 8010d14:	f7fb f874 	bl	800be00 <test_println>
  test_print("--- Timer : ");
 8010d18:	4827      	ldr	r0, [pc, #156]	; (8010db8 <bmk13_execute+0xc8>)
 8010d1a:	f7fb f851 	bl	800bdc0 <test_print>
  test_printn(sizeof(virtual_timer_t));
 8010d1e:	2014      	movs	r0, #20
 8010d20:	f7fb f806 	bl	800bd30 <test_printn>
  test_println(" bytes");
 8010d24:	4822      	ldr	r0, [pc, #136]	; (8010db0 <bmk13_execute+0xc0>)
 8010d26:	f7fb f86b 	bl	800be00 <test_println>
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
  test_print("--- Semaph: ");
 8010d2a:	4824      	ldr	r0, [pc, #144]	; (8010dbc <bmk13_execute+0xcc>)
 8010d2c:	f7fb f848 	bl	800bdc0 <test_print>
  test_printn(sizeof(semaphore_t));
 8010d30:	200c      	movs	r0, #12
 8010d32:	f7fa fffd 	bl	800bd30 <test_printn>
  test_println(" bytes");
 8010d36:	481e      	ldr	r0, [pc, #120]	; (8010db0 <bmk13_execute+0xc0>)
 8010d38:	f7fb f862 	bl	800be00 <test_println>
#endif
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
  test_print("--- EventS: ");
 8010d3c:	4820      	ldr	r0, [pc, #128]	; (8010dc0 <bmk13_execute+0xd0>)
 8010d3e:	f7fb f83f 	bl	800bdc0 <test_print>
  test_printn(sizeof(event_source_t));
 8010d42:	2004      	movs	r0, #4
 8010d44:	f7fa fff4 	bl	800bd30 <test_printn>
  test_println(" bytes");
 8010d48:	4819      	ldr	r0, [pc, #100]	; (8010db0 <bmk13_execute+0xc0>)
 8010d4a:	f7fb f859 	bl	800be00 <test_println>
  test_print("--- EventL: ");
 8010d4e:	481d      	ldr	r0, [pc, #116]	; (8010dc4 <bmk13_execute+0xd4>)
 8010d50:	f7fb f836 	bl	800bdc0 <test_print>
  test_printn(sizeof(event_listener_t));
 8010d54:	2014      	movs	r0, #20
 8010d56:	f7fa ffeb 	bl	800bd30 <test_printn>
  test_println(" bytes");
 8010d5a:	4815      	ldr	r0, [pc, #84]	; (8010db0 <bmk13_execute+0xc0>)
 8010d5c:	f7fb f850 	bl	800be00 <test_println>
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  test_print("--- Mutex : ");
 8010d60:	4819      	ldr	r0, [pc, #100]	; (8010dc8 <bmk13_execute+0xd8>)
 8010d62:	f7fb f82d 	bl	800bdc0 <test_print>
  test_printn(sizeof(mutex_t));
 8010d66:	2010      	movs	r0, #16
 8010d68:	f7fa ffe2 	bl	800bd30 <test_printn>
  test_println(" bytes");
 8010d6c:	4810      	ldr	r0, [pc, #64]	; (8010db0 <bmk13_execute+0xc0>)
 8010d6e:	f7fb f847 	bl	800be00 <test_println>
#endif
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
  test_print("--- CondV.: ");
 8010d72:	4816      	ldr	r0, [pc, #88]	; (8010dcc <bmk13_execute+0xdc>)
 8010d74:	f7fb f824 	bl	800bdc0 <test_print>
  test_printn(sizeof(condition_variable_t));
 8010d78:	2008      	movs	r0, #8
 8010d7a:	f7fa ffd9 	bl	800bd30 <test_printn>
  test_println(" bytes");
 8010d7e:	480c      	ldr	r0, [pc, #48]	; (8010db0 <bmk13_execute+0xc0>)
 8010d80:	f7fb f83e 	bl	800be00 <test_println>
#endif
#if CH_CFG_USE_QUEUES || defined(__DOXYGEN__)
  test_print("--- Queue : ");
 8010d84:	4812      	ldr	r0, [pc, #72]	; (8010dd0 <bmk13_execute+0xe0>)
 8010d86:	f7fb f81b 	bl	800bdc0 <test_print>
  test_printn(sizeof(io_queue_t));
 8010d8a:	2024      	movs	r0, #36	; 0x24
 8010d8c:	f7fa ffd0 	bl	800bd30 <test_printn>
  test_println(" bytes");
 8010d90:	4807      	ldr	r0, [pc, #28]	; (8010db0 <bmk13_execute+0xc0>)
 8010d92:	f7fb f835 	bl	800be00 <test_println>
#endif
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
  test_print("--- MailB.: ");
 8010d96:	480f      	ldr	r0, [pc, #60]	; (8010dd4 <bmk13_execute+0xe4>)
 8010d98:	f7fb f812 	bl	800bdc0 <test_print>
  test_printn(sizeof(mailbox_t));
 8010d9c:	2028      	movs	r0, #40	; 0x28
 8010d9e:	f7fa ffc7 	bl	800bd30 <test_printn>
  test_println(" bytes");
 8010da2:	4803      	ldr	r0, [pc, #12]	; (8010db0 <bmk13_execute+0xc0>)
 8010da4:	f7fb f82c 	bl	800be00 <test_println>
#endif
}
 8010da8:	bd08      	pop	{r3, pc}
 8010daa:	bf00      	nop
 8010dac:	08018674 	.word	0x08018674
 8010db0:	08018684 	.word	0x08018684
 8010db4:	0801868c 	.word	0x0801868c
 8010db8:	0801869c 	.word	0x0801869c
 8010dbc:	080186ac 	.word	0x080186ac
 8010dc0:	080186bc 	.word	0x080186bc
 8010dc4:	080186cc 	.word	0x080186cc
 8010dc8:	080186dc 	.word	0x080186dc
 8010dcc:	080186ec 	.word	0x080186ec
 8010dd0:	080186fc 	.word	0x080186fc
 8010dd4:	0801870c 	.word	0x0801870c
 8010dd8:	f3af 8000 	nop.w
 8010ddc:	f3af 8000 	nop.w

08010de0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8010de0:	b082      	sub	sp, #8
 8010de2:	2320      	movs	r3, #32
 8010de4:	9301      	str	r3, [sp, #4]
 8010de6:	9b01      	ldr	r3, [sp, #4]
 8010de8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8010dec:	b002      	add	sp, #8
 8010dee:	4770      	bx	lr

08010df0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8010df0:	b082      	sub	sp, #8
 8010df2:	2300      	movs	r3, #0
 8010df4:	9301      	str	r3, [sp, #4]
 8010df6:	9b01      	ldr	r3, [sp, #4]
 8010df8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8010dfc:	b002      	add	sp, #8
 8010dfe:	4770      	bx	lr

08010e00 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8010e00:	b508      	push	{r3, lr}

  port_lock();
 8010e02:	f7ff ffed 	bl	8010de0 <port_lock>
}
 8010e06:	bd08      	pop	{r3, pc}
 8010e08:	f3af 8000 	nop.w
 8010e0c:	f3af 8000 	nop.w

08010e10 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8010e10:	b508      	push	{r3, lr}

  port_unlock();
 8010e12:	f7ff ffed 	bl	8010df0 <port_unlock>
}
 8010e16:	bd08      	pop	{r3, pc}
 8010e18:	f3af 8000 	nop.w
 8010e1c:	f3af 8000 	nop.w

08010e20 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8010e20:	b508      	push	{r3, lr}

  port_lock();
 8010e22:	f7ff ffdd 	bl	8010de0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8010e26:	bd08      	pop	{r3, pc}
 8010e28:	f3af 8000 	nop.w
 8010e2c:	f3af 8000 	nop.w

08010e30 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8010e30:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8010e32:	f7ff ffdd 	bl	8010df0 <port_unlock>
}
 8010e36:	bd08      	pop	{r3, pc}
 8010e38:	f3af 8000 	nop.w
 8010e3c:	f3af 8000 	nop.w

08010e40 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8010e40:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8010e42:	f7ff ffdd 	bl	8010e00 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8010e46:	bd08      	pop	{r3, pc}
 8010e48:	f3af 8000 	nop.w
 8010e4c:	f3af 8000 	nop.w

08010e50 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8010e50:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8010e52:	f7ff ffdd 	bl	8010e10 <port_unlock_from_isr>
}
 8010e56:	bd08      	pop	{r3, pc}
 8010e58:	f3af 8000 	nop.w
 8010e5c:	f3af 8000 	nop.w

08010e60 <chVTObjectInit>:
 *
 * @param[out] vtp      the @p virtual_timer_t structure pointer
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {
 8010e60:	b082      	sub	sp, #8
 8010e62:	9001      	str	r0, [sp, #4]

  vtp->vt_func = NULL;
 8010e64:	9b01      	ldr	r3, [sp, #4]
 8010e66:	2200      	movs	r2, #0
 8010e68:	60da      	str	r2, [r3, #12]
}
 8010e6a:	b002      	add	sp, #8
 8010e6c:	4770      	bx	lr
 8010e6e:	bf00      	nop

08010e70 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 8010e70:	b082      	sub	sp, #8
 8010e72:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->vt_func != NULL);
 8010e74:	9b01      	ldr	r3, [sp, #4]
 8010e76:	68db      	ldr	r3, [r3, #12]
 8010e78:	2b00      	cmp	r3, #0
 8010e7a:	bf0c      	ite	eq
 8010e7c:	2300      	moveq	r3, #0
 8010e7e:	2301      	movne	r3, #1
 8010e80:	b2db      	uxtb	r3, r3
}
 8010e82:	4618      	mov	r0, r3
 8010e84:	b002      	add	sp, #8
 8010e86:	4770      	bx	lr
 8010e88:	f3af 8000 	nop.w
 8010e8c:	f3af 8000 	nop.w

08010e90 <chVTResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {
 8010e90:	b500      	push	{lr}
 8010e92:	b083      	sub	sp, #12
 8010e94:	9001      	str	r0, [sp, #4]

  if (chVTIsArmedI(vtp)) {
 8010e96:	9801      	ldr	r0, [sp, #4]
 8010e98:	f7ff ffea 	bl	8010e70 <chVTIsArmedI>
 8010e9c:	4603      	mov	r3, r0
 8010e9e:	2b00      	cmp	r3, #0
 8010ea0:	d002      	beq.n	8010ea8 <chVTResetI+0x18>
    chVTDoResetI(vtp);
 8010ea2:	9801      	ldr	r0, [sp, #4]
 8010ea4:	f7ef fdb4 	bl	8000a10 <chVTDoResetI>
  }
}
 8010ea8:	b003      	add	sp, #12
 8010eaa:	f85d fb04 	ldr.w	pc, [sp], #4
 8010eae:	bf00      	nop

08010eb0 <chVTSetI>:
 *                      function
 *
 * @iclass
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {
 8010eb0:	b500      	push	{lr}
 8010eb2:	b085      	sub	sp, #20
 8010eb4:	9003      	str	r0, [sp, #12]
 8010eb6:	9102      	str	r1, [sp, #8]
 8010eb8:	9201      	str	r2, [sp, #4]
 8010eba:	9300      	str	r3, [sp, #0]

  chVTResetI(vtp);
 8010ebc:	9803      	ldr	r0, [sp, #12]
 8010ebe:	f7ff ffe7 	bl	8010e90 <chVTResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
 8010ec2:	9803      	ldr	r0, [sp, #12]
 8010ec4:	9902      	ldr	r1, [sp, #8]
 8010ec6:	9a01      	ldr	r2, [sp, #4]
 8010ec8:	9b00      	ldr	r3, [sp, #0]
 8010eca:	f7ef fd61 	bl	8000990 <chVTDoSetI>
}
 8010ece:	b005      	add	sp, #20
 8010ed0:	f85d fb04 	ldr.w	pc, [sp], #4
 8010ed4:	f3af 8000 	nop.w
 8010ed8:	f3af 8000 	nop.w
 8010edc:	f3af 8000 	nop.w

08010ee0 <chVTSet>:
 *                      function
 *
 * @api
 */
static inline void chVTSet(virtual_timer_t *vtp, systime_t delay,
                           vtfunc_t vtfunc, void *par) {
 8010ee0:	b500      	push	{lr}
 8010ee2:	b085      	sub	sp, #20
 8010ee4:	9003      	str	r0, [sp, #12]
 8010ee6:	9102      	str	r1, [sp, #8]
 8010ee8:	9201      	str	r2, [sp, #4]
 8010eea:	9300      	str	r3, [sp, #0]

  chSysLock();
 8010eec:	f7ff ff98 	bl	8010e20 <chSysLock>
  chVTSetI(vtp, delay, vtfunc, par);
 8010ef0:	9803      	ldr	r0, [sp, #12]
 8010ef2:	9902      	ldr	r1, [sp, #8]
 8010ef4:	9a01      	ldr	r2, [sp, #4]
 8010ef6:	9b00      	ldr	r3, [sp, #0]
 8010ef8:	f7ff ffda 	bl	8010eb0 <chVTSetI>
  chSysUnlock();
 8010efc:	f7ff ff98 	bl	8010e30 <chSysUnlock>
}
 8010f00:	b005      	add	sp, #20
 8010f02:	f85d fb04 	ldr.w	pc, [sp], #4
 8010f06:	bf00      	nop
 8010f08:	f3af 8000 	nop.w
 8010f0c:	f3af 8000 	nop.w

08010f10 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 8010f10:	b082      	sub	sp, #8
 8010f12:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 8010f14:	9b01      	ldr	r3, [sp, #4]
 8010f16:	9a01      	ldr	r2, [sp, #4]
 8010f18:	601a      	str	r2, [r3, #0]
}
 8010f1a:	b002      	add	sp, #8
 8010f1c:	4770      	bx	lr
 8010f1e:	bf00      	nop

08010f20 <chEvtBroadcastI>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {
 8010f20:	b500      	push	{lr}
 8010f22:	b083      	sub	sp, #12
 8010f24:	9001      	str	r0, [sp, #4]

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
 8010f26:	9801      	ldr	r0, [sp, #4]
 8010f28:	2100      	movs	r1, #0
 8010f2a:	f7f1 fba9 	bl	8002680 <chEvtBroadcastFlagsI>
}
 8010f2e:	b003      	add	sp, #12
 8010f30:	f85d fb04 	ldr.w	pc, [sp], #4
 8010f34:	f3af 8000 	nop.w
 8010f38:	f3af 8000 	nop.w
 8010f3c:	f3af 8000 	nop.w

08010f40 <tmrcb>:

/*===========================================================================*/
/* Module local functions.                                                   */
/*===========================================================================*/

static void tmrcb(void *p) {
 8010f40:	b500      	push	{lr}
 8010f42:	b085      	sub	sp, #20
 8010f44:	9001      	str	r0, [sp, #4]
  event_timer_t *etp = p;
 8010f46:	9b01      	ldr	r3, [sp, #4]
 8010f48:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 8010f4a:	f7ff ff79 	bl	8010e40 <chSysLockFromISR>
  chEvtBroadcastI(&etp->et_es);
 8010f4e:	9b03      	ldr	r3, [sp, #12]
 8010f50:	3314      	adds	r3, #20
 8010f52:	4618      	mov	r0, r3
 8010f54:	f7ff ffe4 	bl	8010f20 <chEvtBroadcastI>
  chVTDoSetI(&etp->et_vt, etp->et_interval, tmrcb, etp);
 8010f58:	9a03      	ldr	r2, [sp, #12]
 8010f5a:	9b03      	ldr	r3, [sp, #12]
 8010f5c:	699b      	ldr	r3, [r3, #24]
 8010f5e:	4610      	mov	r0, r2
 8010f60:	4619      	mov	r1, r3
 8010f62:	4a04      	ldr	r2, [pc, #16]	; (8010f74 <tmrcb+0x34>)
 8010f64:	9b03      	ldr	r3, [sp, #12]
 8010f66:	f7ef fd13 	bl	8000990 <chVTDoSetI>
  chSysUnlockFromISR();
 8010f6a:	f7ff ff71 	bl	8010e50 <chSysUnlockFromISR>
}
 8010f6e:	b005      	add	sp, #20
 8010f70:	f85d fb04 	ldr.w	pc, [sp], #4
 8010f74:	08010f41 	.word	0x08010f41
 8010f78:	f3af 8000 	nop.w
 8010f7c:	f3af 8000 	nop.w

08010f80 <evtObjectInit>:
 * @brief Initializes an @p event_timer_t structure.
 *
 * @param[out] etp      the @p event_timer_t structure to be initialized
 * @param[in] time      the interval in system ticks
 */
void evtObjectInit(event_timer_t *etp, systime_t time) {
 8010f80:	b500      	push	{lr}
 8010f82:	b083      	sub	sp, #12
 8010f84:	9001      	str	r0, [sp, #4]
 8010f86:	9100      	str	r1, [sp, #0]

  chEvtObjectInit(&etp->et_es);
 8010f88:	9b01      	ldr	r3, [sp, #4]
 8010f8a:	3314      	adds	r3, #20
 8010f8c:	4618      	mov	r0, r3
 8010f8e:	f7ff ffbf 	bl	8010f10 <chEvtObjectInit>
  chVTObjectInit(&etp->et_vt);
 8010f92:	9b01      	ldr	r3, [sp, #4]
 8010f94:	4618      	mov	r0, r3
 8010f96:	f7ff ff63 	bl	8010e60 <chVTObjectInit>
  etp->et_interval = time;
 8010f9a:	9b01      	ldr	r3, [sp, #4]
 8010f9c:	9a00      	ldr	r2, [sp, #0]
 8010f9e:	619a      	str	r2, [r3, #24]
}
 8010fa0:	b003      	add	sp, #12
 8010fa2:	f85d fb04 	ldr.w	pc, [sp], #4
 8010fa6:	bf00      	nop
 8010fa8:	f3af 8000 	nop.w
 8010fac:	f3af 8000 	nop.w

08010fb0 <evtStart>:
 * @brief   Starts the timer
 * @details If the timer was already running then the function has no effect.
 *
 * @param[in] etp       pointer to an initialized @p event_timer_t structure.
 */
void evtStart(event_timer_t *etp) {
 8010fb0:	b500      	push	{lr}
 8010fb2:	b083      	sub	sp, #12
 8010fb4:	9001      	str	r0, [sp, #4]

  chVTSet(&etp->et_vt, etp->et_interval, tmrcb, etp);
 8010fb6:	9a01      	ldr	r2, [sp, #4]
 8010fb8:	9b01      	ldr	r3, [sp, #4]
 8010fba:	699b      	ldr	r3, [r3, #24]
 8010fbc:	4610      	mov	r0, r2
 8010fbe:	4619      	mov	r1, r3
 8010fc0:	4a03      	ldr	r2, [pc, #12]	; (8010fd0 <evtStart+0x20>)
 8010fc2:	9b01      	ldr	r3, [sp, #4]
 8010fc4:	f7ff ff8c 	bl	8010ee0 <chVTSet>
}
 8010fc8:	b003      	add	sp, #12
 8010fca:	f85d fb04 	ldr.w	pc, [sp], #4
 8010fce:	bf00      	nop
 8010fd0:	08010f41 	.word	0x08010f41
 8010fd4:	f3af 8000 	nop.w
 8010fd8:	f3af 8000 	nop.w
 8010fdc:	f3af 8000 	nop.w

08010fe0 <writes>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static size_t writes(void *ip, const uint8_t *bp, size_t n) {
 8010fe0:	b500      	push	{lr}
 8010fe2:	b087      	sub	sp, #28
 8010fe4:	9003      	str	r0, [sp, #12]
 8010fe6:	9102      	str	r1, [sp, #8]
 8010fe8:	9201      	str	r2, [sp, #4]
  MemoryStream *msp = ip;
 8010fea:	9b03      	ldr	r3, [sp, #12]
 8010fec:	9305      	str	r3, [sp, #20]

  if (msp->size - msp->eos < n)
 8010fee:	9b05      	ldr	r3, [sp, #20]
 8010ff0:	689a      	ldr	r2, [r3, #8]
 8010ff2:	9b05      	ldr	r3, [sp, #20]
 8010ff4:	68db      	ldr	r3, [r3, #12]
 8010ff6:	1ad2      	subs	r2, r2, r3
 8010ff8:	9b01      	ldr	r3, [sp, #4]
 8010ffa:	429a      	cmp	r2, r3
 8010ffc:	d205      	bcs.n	801100a <writes+0x2a>
    n = msp->size - msp->eos;
 8010ffe:	9b05      	ldr	r3, [sp, #20]
 8011000:	689a      	ldr	r2, [r3, #8]
 8011002:	9b05      	ldr	r3, [sp, #20]
 8011004:	68db      	ldr	r3, [r3, #12]
 8011006:	1ad3      	subs	r3, r2, r3
 8011008:	9301      	str	r3, [sp, #4]
  memcpy(msp->buffer + msp->eos, bp, n);
 801100a:	9b05      	ldr	r3, [sp, #20]
 801100c:	685a      	ldr	r2, [r3, #4]
 801100e:	9b05      	ldr	r3, [sp, #20]
 8011010:	68db      	ldr	r3, [r3, #12]
 8011012:	4413      	add	r3, r2
 8011014:	4618      	mov	r0, r3
 8011016:	9902      	ldr	r1, [sp, #8]
 8011018:	9a01      	ldr	r2, [sp, #4]
 801101a:	f006 f831 	bl	8017080 <memcpy>
  msp->eos += n;
 801101e:	9b05      	ldr	r3, [sp, #20]
 8011020:	68da      	ldr	r2, [r3, #12]
 8011022:	9b01      	ldr	r3, [sp, #4]
 8011024:	441a      	add	r2, r3
 8011026:	9b05      	ldr	r3, [sp, #20]
 8011028:	60da      	str	r2, [r3, #12]
  return n;
 801102a:	9b01      	ldr	r3, [sp, #4]
}
 801102c:	4618      	mov	r0, r3
 801102e:	b007      	add	sp, #28
 8011030:	f85d fb04 	ldr.w	pc, [sp], #4
 8011034:	f3af 8000 	nop.w
 8011038:	f3af 8000 	nop.w
 801103c:	f3af 8000 	nop.w

08011040 <reads>:

static size_t reads(void *ip, uint8_t *bp, size_t n) {
 8011040:	b500      	push	{lr}
 8011042:	b087      	sub	sp, #28
 8011044:	9003      	str	r0, [sp, #12]
 8011046:	9102      	str	r1, [sp, #8]
 8011048:	9201      	str	r2, [sp, #4]
  MemoryStream *msp = ip;
 801104a:	9b03      	ldr	r3, [sp, #12]
 801104c:	9305      	str	r3, [sp, #20]

  if (msp->eos - msp->offset < n)
 801104e:	9b05      	ldr	r3, [sp, #20]
 8011050:	68da      	ldr	r2, [r3, #12]
 8011052:	9b05      	ldr	r3, [sp, #20]
 8011054:	691b      	ldr	r3, [r3, #16]
 8011056:	1ad2      	subs	r2, r2, r3
 8011058:	9b01      	ldr	r3, [sp, #4]
 801105a:	429a      	cmp	r2, r3
 801105c:	d205      	bcs.n	801106a <reads+0x2a>
    n = msp->eos - msp->offset;
 801105e:	9b05      	ldr	r3, [sp, #20]
 8011060:	68da      	ldr	r2, [r3, #12]
 8011062:	9b05      	ldr	r3, [sp, #20]
 8011064:	691b      	ldr	r3, [r3, #16]
 8011066:	1ad3      	subs	r3, r2, r3
 8011068:	9301      	str	r3, [sp, #4]
  memcpy(bp, msp->buffer + msp->offset, n);
 801106a:	9b05      	ldr	r3, [sp, #20]
 801106c:	685a      	ldr	r2, [r3, #4]
 801106e:	9b05      	ldr	r3, [sp, #20]
 8011070:	691b      	ldr	r3, [r3, #16]
 8011072:	4413      	add	r3, r2
 8011074:	9802      	ldr	r0, [sp, #8]
 8011076:	4619      	mov	r1, r3
 8011078:	9a01      	ldr	r2, [sp, #4]
 801107a:	f006 f801 	bl	8017080 <memcpy>
  msp->offset += n;
 801107e:	9b05      	ldr	r3, [sp, #20]
 8011080:	691a      	ldr	r2, [r3, #16]
 8011082:	9b01      	ldr	r3, [sp, #4]
 8011084:	441a      	add	r2, r3
 8011086:	9b05      	ldr	r3, [sp, #20]
 8011088:	611a      	str	r2, [r3, #16]
  return n;
 801108a:	9b01      	ldr	r3, [sp, #4]
}
 801108c:	4618      	mov	r0, r3
 801108e:	b007      	add	sp, #28
 8011090:	f85d fb04 	ldr.w	pc, [sp], #4
 8011094:	f3af 8000 	nop.w
 8011098:	f3af 8000 	nop.w
 801109c:	f3af 8000 	nop.w

080110a0 <put>:

static msg_t put(void *ip, uint8_t b) {
 80110a0:	b084      	sub	sp, #16
 80110a2:	9001      	str	r0, [sp, #4]
 80110a4:	460b      	mov	r3, r1
 80110a6:	f88d 3003 	strb.w	r3, [sp, #3]
  MemoryStream *msp = ip;
 80110aa:	9b01      	ldr	r3, [sp, #4]
 80110ac:	9303      	str	r3, [sp, #12]

  if (msp->size - msp->eos <= 0)
 80110ae:	9b03      	ldr	r3, [sp, #12]
 80110b0:	689a      	ldr	r2, [r3, #8]
 80110b2:	9b03      	ldr	r3, [sp, #12]
 80110b4:	68db      	ldr	r3, [r3, #12]
 80110b6:	429a      	cmp	r2, r3
 80110b8:	d102      	bne.n	80110c0 <put+0x20>
    return MSG_RESET;
 80110ba:	f06f 0301 	mvn.w	r3, #1
 80110be:	e00d      	b.n	80110dc <put+0x3c>
  *(msp->buffer + msp->eos) = b;
 80110c0:	9b03      	ldr	r3, [sp, #12]
 80110c2:	685a      	ldr	r2, [r3, #4]
 80110c4:	9b03      	ldr	r3, [sp, #12]
 80110c6:	68db      	ldr	r3, [r3, #12]
 80110c8:	4413      	add	r3, r2
 80110ca:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80110ce:	701a      	strb	r2, [r3, #0]
  msp->eos += 1;
 80110d0:	9b03      	ldr	r3, [sp, #12]
 80110d2:	68db      	ldr	r3, [r3, #12]
 80110d4:	1c5a      	adds	r2, r3, #1
 80110d6:	9b03      	ldr	r3, [sp, #12]
 80110d8:	60da      	str	r2, [r3, #12]
  return MSG_OK;
 80110da:	2300      	movs	r3, #0
}
 80110dc:	4618      	mov	r0, r3
 80110de:	b004      	add	sp, #16
 80110e0:	4770      	bx	lr
 80110e2:	bf00      	nop
 80110e4:	f3af 8000 	nop.w
 80110e8:	f3af 8000 	nop.w
 80110ec:	f3af 8000 	nop.w

080110f0 <get>:

static msg_t get(void *ip) {
 80110f0:	b084      	sub	sp, #16
 80110f2:	9001      	str	r0, [sp, #4]
  uint8_t b;
  MemoryStream *msp = ip;
 80110f4:	9b01      	ldr	r3, [sp, #4]
 80110f6:	9303      	str	r3, [sp, #12]

  if (msp->eos - msp->offset <= 0)
 80110f8:	9b03      	ldr	r3, [sp, #12]
 80110fa:	68da      	ldr	r2, [r3, #12]
 80110fc:	9b03      	ldr	r3, [sp, #12]
 80110fe:	691b      	ldr	r3, [r3, #16]
 8011100:	429a      	cmp	r2, r3
 8011102:	d102      	bne.n	801110a <get+0x1a>
    return MSG_RESET;
 8011104:	f06f 0301 	mvn.w	r3, #1
 8011108:	e00e      	b.n	8011128 <get+0x38>
  b = *(msp->buffer + msp->offset);
 801110a:	9b03      	ldr	r3, [sp, #12]
 801110c:	685a      	ldr	r2, [r3, #4]
 801110e:	9b03      	ldr	r3, [sp, #12]
 8011110:	691b      	ldr	r3, [r3, #16]
 8011112:	4413      	add	r3, r2
 8011114:	781b      	ldrb	r3, [r3, #0]
 8011116:	f88d 300b 	strb.w	r3, [sp, #11]
  msp->offset += 1;
 801111a:	9b03      	ldr	r3, [sp, #12]
 801111c:	691b      	ldr	r3, [r3, #16]
 801111e:	1c5a      	adds	r2, r3, #1
 8011120:	9b03      	ldr	r3, [sp, #12]
 8011122:	611a      	str	r2, [r3, #16]
  return b;
 8011124:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 8011128:	4618      	mov	r0, r3
 801112a:	b004      	add	sp, #16
 801112c:	4770      	bx	lr
 801112e:	bf00      	nop

08011130 <msObjectInit>:
 * @param[in] eos       initial End Of Stream offset. Normally you need to
 *                      put this to zero for RAM buffers or equal to @p size
 *                      for ROM streams.
 */
void msObjectInit(MemoryStream *msp, uint8_t *buffer,
                  size_t size, size_t eos) {
 8011130:	b084      	sub	sp, #16
 8011132:	9003      	str	r0, [sp, #12]
 8011134:	9102      	str	r1, [sp, #8]
 8011136:	9201      	str	r2, [sp, #4]
 8011138:	9300      	str	r3, [sp, #0]

  msp->vmt    = &vmt;
 801113a:	9b03      	ldr	r3, [sp, #12]
 801113c:	4a07      	ldr	r2, [pc, #28]	; (801115c <msObjectInit+0x2c>)
 801113e:	601a      	str	r2, [r3, #0]
  msp->buffer = buffer;
 8011140:	9b03      	ldr	r3, [sp, #12]
 8011142:	9a02      	ldr	r2, [sp, #8]
 8011144:	605a      	str	r2, [r3, #4]
  msp->size   = size;
 8011146:	9b03      	ldr	r3, [sp, #12]
 8011148:	9a01      	ldr	r2, [sp, #4]
 801114a:	609a      	str	r2, [r3, #8]
  msp->eos    = eos;
 801114c:	9b03      	ldr	r3, [sp, #12]
 801114e:	9a00      	ldr	r2, [sp, #0]
 8011150:	60da      	str	r2, [r3, #12]
  msp->offset = 0;
 8011152:	9b03      	ldr	r3, [sp, #12]
 8011154:	2200      	movs	r2, #0
 8011156:	611a      	str	r2, [r3, #16]
}
 8011158:	b004      	add	sp, #16
 801115a:	4770      	bx	lr
 801115c:	08018780 	.word	0x08018780

08011160 <long_to_string_with_divisor>:
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
                                         long num,
                                         unsigned radix,
                                         long divisor) {
 8011160:	b088      	sub	sp, #32
 8011162:	9003      	str	r0, [sp, #12]
 8011164:	9102      	str	r1, [sp, #8]
 8011166:	9201      	str	r2, [sp, #4]
 8011168:	9300      	str	r3, [sp, #0]
  int i;
  char *q;
  long l, ll;

  l = num;
 801116a:	9b02      	ldr	r3, [sp, #8]
 801116c:	9305      	str	r3, [sp, #20]
  if (divisor == 0) {
 801116e:	9b00      	ldr	r3, [sp, #0]
 8011170:	2b00      	cmp	r3, #0
 8011172:	d102      	bne.n	801117a <long_to_string_with_divisor+0x1a>
    ll = num;
 8011174:	9b02      	ldr	r3, [sp, #8]
 8011176:	9304      	str	r3, [sp, #16]
 8011178:	e001      	b.n	801117e <long_to_string_with_divisor+0x1e>
  } else {
    ll = divisor;
 801117a:	9b00      	ldr	r3, [sp, #0]
 801117c:	9304      	str	r3, [sp, #16]
  }

  q = p + MAX_FILLER;
 801117e:	9b03      	ldr	r3, [sp, #12]
 8011180:	330b      	adds	r3, #11
 8011182:	9306      	str	r3, [sp, #24]
  do {
    i = (int)(l % radix);
 8011184:	9b05      	ldr	r3, [sp, #20]
 8011186:	9a01      	ldr	r2, [sp, #4]
 8011188:	fbb3 f2f2 	udiv	r2, r3, r2
 801118c:	9901      	ldr	r1, [sp, #4]
 801118e:	fb01 f202 	mul.w	r2, r1, r2
 8011192:	1a9b      	subs	r3, r3, r2
 8011194:	9307      	str	r3, [sp, #28]
    i += '0';
 8011196:	9b07      	ldr	r3, [sp, #28]
 8011198:	3330      	adds	r3, #48	; 0x30
 801119a:	9307      	str	r3, [sp, #28]
    if (i > '9')
 801119c:	9b07      	ldr	r3, [sp, #28]
 801119e:	2b39      	cmp	r3, #57	; 0x39
 80111a0:	dd02      	ble.n	80111a8 <long_to_string_with_divisor+0x48>
      i += 'A' - '0' - 10;
 80111a2:	9b07      	ldr	r3, [sp, #28]
 80111a4:	3307      	adds	r3, #7
 80111a6:	9307      	str	r3, [sp, #28]
    *--q = i;
 80111a8:	9b06      	ldr	r3, [sp, #24]
 80111aa:	3b01      	subs	r3, #1
 80111ac:	9306      	str	r3, [sp, #24]
 80111ae:	9b07      	ldr	r3, [sp, #28]
 80111b0:	b2da      	uxtb	r2, r3
 80111b2:	9b06      	ldr	r3, [sp, #24]
 80111b4:	701a      	strb	r2, [r3, #0]
    l /= radix;
 80111b6:	9a05      	ldr	r2, [sp, #20]
 80111b8:	9b01      	ldr	r3, [sp, #4]
 80111ba:	fbb2 f3f3 	udiv	r3, r2, r3
 80111be:	9305      	str	r3, [sp, #20]
  } while ((ll /= radix) != 0);
 80111c0:	9a04      	ldr	r2, [sp, #16]
 80111c2:	9b01      	ldr	r3, [sp, #4]
 80111c4:	fbb2 f3f3 	udiv	r3, r2, r3
 80111c8:	9304      	str	r3, [sp, #16]
 80111ca:	9b04      	ldr	r3, [sp, #16]
 80111cc:	2b00      	cmp	r3, #0
 80111ce:	d1d9      	bne.n	8011184 <long_to_string_with_divisor+0x24>

  i = (int)(p + MAX_FILLER - q);
 80111d0:	9b03      	ldr	r3, [sp, #12]
 80111d2:	330b      	adds	r3, #11
 80111d4:	461a      	mov	r2, r3
 80111d6:	9b06      	ldr	r3, [sp, #24]
 80111d8:	1ad3      	subs	r3, r2, r3
 80111da:	9307      	str	r3, [sp, #28]
  do
    *p++ = *q++;
 80111dc:	9b03      	ldr	r3, [sp, #12]
 80111de:	1c5a      	adds	r2, r3, #1
 80111e0:	9203      	str	r2, [sp, #12]
 80111e2:	9a06      	ldr	r2, [sp, #24]
 80111e4:	1c51      	adds	r1, r2, #1
 80111e6:	9106      	str	r1, [sp, #24]
 80111e8:	7812      	ldrb	r2, [r2, #0]
 80111ea:	701a      	strb	r2, [r3, #0]
  while (--i);
 80111ec:	9b07      	ldr	r3, [sp, #28]
 80111ee:	3b01      	subs	r3, #1
 80111f0:	9307      	str	r3, [sp, #28]
 80111f2:	9b07      	ldr	r3, [sp, #28]
 80111f4:	2b00      	cmp	r3, #0
 80111f6:	d1f1      	bne.n	80111dc <long_to_string_with_divisor+0x7c>

  return p;
 80111f8:	9b03      	ldr	r3, [sp, #12]
}
 80111fa:	4618      	mov	r0, r3
 80111fc:	b008      	add	sp, #32
 80111fe:	4770      	bx	lr

08011200 <ch_ltoa>:

static char *ch_ltoa(char *p, long num, unsigned radix) {
 8011200:	b500      	push	{lr}
 8011202:	b085      	sub	sp, #20
 8011204:	9003      	str	r0, [sp, #12]
 8011206:	9102      	str	r1, [sp, #8]
 8011208:	9201      	str	r2, [sp, #4]

  return long_to_string_with_divisor(p, num, radix, 0);
 801120a:	9803      	ldr	r0, [sp, #12]
 801120c:	9902      	ldr	r1, [sp, #8]
 801120e:	9a01      	ldr	r2, [sp, #4]
 8011210:	2300      	movs	r3, #0
 8011212:	f7ff ffa5 	bl	8011160 <long_to_string_with_divisor>
 8011216:	4603      	mov	r3, r0
}
 8011218:	4618      	mov	r0, r3
 801121a:	b005      	add	sp, #20
 801121c:	f85d fb04 	ldr.w	pc, [sp], #4

08011220 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8011220:	b500      	push	{lr}
 8011222:	b091      	sub	sp, #68	; 0x44
 8011224:	9003      	str	r0, [sp, #12]
 8011226:	9102      	str	r1, [sp, #8]
 8011228:	9201      	str	r2, [sp, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 801122a:	2300      	movs	r3, #0
 801122c:	9309      	str	r3, [sp, #36]	; 0x24
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 801122e:	9b02      	ldr	r3, [sp, #8]
 8011230:	1c5a      	adds	r2, r3, #1
 8011232:	9202      	str	r2, [sp, #8]
 8011234:	781b      	ldrb	r3, [r3, #0]
 8011236:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    if (c == 0)
 801123a:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801123e:	2b00      	cmp	r3, #0
 8011240:	d101      	bne.n	8011246 <chvprintf+0x26>
      return n;
 8011242:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8011244:	e210      	b.n	8011668 <chvprintf+0x448>
    if (c != '%') {
 8011246:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801124a:	2b25      	cmp	r3, #37	; 0x25
 801124c:	d00b      	beq.n	8011266 <chvprintf+0x46>
      streamPut(chp, (uint8_t)c);
 801124e:	9b03      	ldr	r3, [sp, #12]
 8011250:	681b      	ldr	r3, [r3, #0]
 8011252:	689b      	ldr	r3, [r3, #8]
 8011254:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 8011258:	9803      	ldr	r0, [sp, #12]
 801125a:	4611      	mov	r1, r2
 801125c:	4798      	blx	r3
      n++;
 801125e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8011260:	3301      	adds	r3, #1
 8011262:	9309      	str	r3, [sp, #36]	; 0x24
      continue;
 8011264:	e1ff      	b.n	8011666 <chvprintf+0x446>
    }
    p = tmpbuf;
 8011266:	ab04      	add	r3, sp, #16
 8011268:	930f      	str	r3, [sp, #60]	; 0x3c
    s = tmpbuf;
 801126a:	ab04      	add	r3, sp, #16
 801126c:	930e      	str	r3, [sp, #56]	; 0x38
    left_align = FALSE;
 801126e:	2300      	movs	r3, #0
 8011270:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    if (*fmt == '-') {
 8011274:	9b02      	ldr	r3, [sp, #8]
 8011276:	781b      	ldrb	r3, [r3, #0]
 8011278:	2b2d      	cmp	r3, #45	; 0x2d
 801127a:	d105      	bne.n	8011288 <chvprintf+0x68>
      fmt++;
 801127c:	9b02      	ldr	r3, [sp, #8]
 801127e:	3301      	adds	r3, #1
 8011280:	9302      	str	r3, [sp, #8]
      left_align = TRUE;
 8011282:	2301      	movs	r3, #1
 8011284:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    }
    filler = ' ';
 8011288:	2320      	movs	r3, #32
 801128a:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    if (*fmt == '0') {
 801128e:	9b02      	ldr	r3, [sp, #8]
 8011290:	781b      	ldrb	r3, [r3, #0]
 8011292:	2b30      	cmp	r3, #48	; 0x30
 8011294:	d105      	bne.n	80112a2 <chvprintf+0x82>
      fmt++;
 8011296:	9b02      	ldr	r3, [sp, #8]
 8011298:	3301      	adds	r3, #1
 801129a:	9302      	str	r3, [sp, #8]
      filler = '0';
 801129c:	2330      	movs	r3, #48	; 0x30
 801129e:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    }
    width = 0;
 80112a2:	2300      	movs	r3, #0
 80112a4:	930a      	str	r3, [sp, #40]	; 0x28
    while (TRUE) {
      c = *fmt++;
 80112a6:	9b02      	ldr	r3, [sp, #8]
 80112a8:	1c5a      	adds	r2, r3, #1
 80112aa:	9202      	str	r2, [sp, #8]
 80112ac:	781b      	ldrb	r3, [r3, #0]
 80112ae:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      if (c >= '0' && c <= '9')
 80112b2:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80112b6:	2b2f      	cmp	r3, #47	; 0x2f
 80112b8:	d909      	bls.n	80112ce <chvprintf+0xae>
 80112ba:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80112be:	2b39      	cmp	r3, #57	; 0x39
 80112c0:	d805      	bhi.n	80112ce <chvprintf+0xae>
        c -= '0';
 80112c2:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80112c6:	3b30      	subs	r3, #48	; 0x30
 80112c8:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 80112cc:	e012      	b.n	80112f4 <chvprintf+0xd4>
      else if (c == '*')
 80112ce:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80112d2:	2b2a      	cmp	r3, #42	; 0x2a
 80112d4:	d106      	bne.n	80112e4 <chvprintf+0xc4>
        c = va_arg(ap, int);
 80112d6:	9b01      	ldr	r3, [sp, #4]
 80112d8:	1d1a      	adds	r2, r3, #4
 80112da:	9201      	str	r2, [sp, #4]
 80112dc:	681b      	ldr	r3, [r3, #0]
 80112de:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 80112e2:	e007      	b.n	80112f4 <chvprintf+0xd4>
      else
        break;
 80112e4:	bf00      	nop
      width = width * 10 + c;
    }
    precision = 0;
 80112e6:	2300      	movs	r3, #0
 80112e8:	930b      	str	r3, [sp, #44]	; 0x2c
    if (c == '.') {
 80112ea:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80112ee:	2b2e      	cmp	r3, #46	; 0x2e
 80112f0:	d137      	bne.n	8011362 <chvprintf+0x142>
 80112f2:	e00a      	b.n	801130a <chvprintf+0xea>
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
      else
        break;
      width = width * 10 + c;
 80112f4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80112f6:	4613      	mov	r3, r2
 80112f8:	009b      	lsls	r3, r3, #2
 80112fa:	4413      	add	r3, r2
 80112fc:	005b      	lsls	r3, r3, #1
 80112fe:	461a      	mov	r2, r3
 8011300:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8011304:	4413      	add	r3, r2
 8011306:	930a      	str	r3, [sp, #40]	; 0x28
    }
 8011308:	e7cd      	b.n	80112a6 <chvprintf+0x86>
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
 801130a:	9b02      	ldr	r3, [sp, #8]
 801130c:	1c5a      	adds	r2, r3, #1
 801130e:	9202      	str	r2, [sp, #8]
 8011310:	781b      	ldrb	r3, [r3, #0]
 8011312:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
        if (c >= '0' && c <= '9')
 8011316:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801131a:	2b2f      	cmp	r3, #47	; 0x2f
 801131c:	d909      	bls.n	8011332 <chvprintf+0x112>
 801131e:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8011322:	2b39      	cmp	r3, #57	; 0x39
 8011324:	d805      	bhi.n	8011332 <chvprintf+0x112>
          c -= '0';
 8011326:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801132a:	3b30      	subs	r3, #48	; 0x30
 801132c:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 8011330:	e00b      	b.n	801134a <chvprintf+0x12a>
        else if (c == '*')
 8011332:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8011336:	2b2a      	cmp	r3, #42	; 0x2a
 8011338:	d106      	bne.n	8011348 <chvprintf+0x128>
          c = va_arg(ap, int);
 801133a:	9b01      	ldr	r3, [sp, #4]
 801133c:	1d1a      	adds	r2, r3, #4
 801133e:	9201      	str	r2, [sp, #4]
 8011340:	681b      	ldr	r3, [r3, #0]
 8011342:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 8011346:	e000      	b.n	801134a <chvprintf+0x12a>
        else
          break;
 8011348:	e00b      	b.n	8011362 <chvprintf+0x142>
        precision *= 10;
 801134a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801134c:	4613      	mov	r3, r2
 801134e:	009b      	lsls	r3, r3, #2
 8011350:	4413      	add	r3, r2
 8011352:	005b      	lsls	r3, r3, #1
 8011354:	930b      	str	r3, [sp, #44]	; 0x2c
        precision += c;
 8011356:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801135a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801135c:	4413      	add	r3, r2
 801135e:	930b      	str	r3, [sp, #44]	; 0x2c
      }
 8011360:	e7d3      	b.n	801130a <chvprintf+0xea>
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8011362:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8011366:	2b6c      	cmp	r3, #108	; 0x6c
 8011368:	d003      	beq.n	8011372 <chvprintf+0x152>
 801136a:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801136e:	2b4c      	cmp	r3, #76	; 0x4c
 8011370:	d10e      	bne.n	8011390 <chvprintf+0x170>
      is_long = TRUE;
 8011372:	2301      	movs	r3, #1
 8011374:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
      if (*fmt)
 8011378:	9b02      	ldr	r3, [sp, #8]
 801137a:	781b      	ldrb	r3, [r3, #0]
 801137c:	2b00      	cmp	r3, #0
 801137e:	d006      	beq.n	801138e <chvprintf+0x16e>
        c = *fmt++;
 8011380:	9b02      	ldr	r3, [sp, #8]
 8011382:	1c5a      	adds	r2, r3, #1
 8011384:	9202      	str	r2, [sp, #8]
 8011386:	781b      	ldrb	r3, [r3, #0]
 8011388:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
 801138c:	e013      	b.n	80113b6 <chvprintf+0x196>
 801138e:	e012      	b.n	80113b6 <chvprintf+0x196>
        c = *fmt++;
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');
 8011390:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8011394:	2b40      	cmp	r3, #64	; 0x40
 8011396:	d905      	bls.n	80113a4 <chvprintf+0x184>
 8011398:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801139c:	2b5a      	cmp	r3, #90	; 0x5a
 801139e:	d801      	bhi.n	80113a4 <chvprintf+0x184>
 80113a0:	2301      	movs	r3, #1
 80113a2:	e000      	b.n	80113a6 <chvprintf+0x186>
 80113a4:	2300      	movs	r3, #0
 80113a6:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
 80113aa:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 80113ae:	f003 0301 	and.w	r3, r3, #1
 80113b2:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23

    /* Command decoding.*/
    switch (c) {
 80113b6:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80113ba:	3b44      	subs	r3, #68	; 0x44
 80113bc:	2b34      	cmp	r3, #52	; 0x34
 80113be:	f200 80e2 	bhi.w	8011586 <chvprintf+0x366>
 80113c2:	a201      	add	r2, pc, #4	; (adr r2, 80113c8 <chvprintf+0x1a8>)
 80113c4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80113c8:	080114ff 	.word	0x080114ff
 80113cc:	08011587 	.word	0x08011587
 80113d0:	08011587 	.word	0x08011587
 80113d4:	08011587 	.word	0x08011587
 80113d8:	08011587 	.word	0x08011587
 80113dc:	080114ff 	.word	0x080114ff
 80113e0:	08011587 	.word	0x08011587
 80113e4:	08011587 	.word	0x08011587
 80113e8:	08011587 	.word	0x08011587
 80113ec:	08011587 	.word	0x08011587
 80113f0:	08011587 	.word	0x08011587
 80113f4:	08011551 	.word	0x08011551
 80113f8:	08011587 	.word	0x08011587
 80113fc:	08011587 	.word	0x08011587
 8011400:	08011587 	.word	0x08011587
 8011404:	08011587 	.word	0x08011587
 8011408:	08011587 	.word	0x08011587
 801140c:	08011549 	.word	0x08011549
 8011410:	08011587 	.word	0x08011587
 8011414:	08011587 	.word	0x08011587
 8011418:	08011541 	.word	0x08011541
 801141c:	08011587 	.word	0x08011587
 8011420:	08011587 	.word	0x08011587
 8011424:	08011587 	.word	0x08011587
 8011428:	08011587 	.word	0x08011587
 801142c:	08011587 	.word	0x08011587
 8011430:	08011587 	.word	0x08011587
 8011434:	08011587 	.word	0x08011587
 8011438:	08011587 	.word	0x08011587
 801143c:	08011587 	.word	0x08011587
 8011440:	08011587 	.word	0x08011587
 8011444:	0801149d 	.word	0x0801149d
 8011448:	080114ff 	.word	0x080114ff
 801144c:	08011587 	.word	0x08011587
 8011450:	08011587 	.word	0x08011587
 8011454:	08011587 	.word	0x08011587
 8011458:	08011587 	.word	0x08011587
 801145c:	080114ff 	.word	0x080114ff
 8011460:	08011587 	.word	0x08011587
 8011464:	08011587 	.word	0x08011587
 8011468:	08011587 	.word	0x08011587
 801146c:	08011587 	.word	0x08011587
 8011470:	08011587 	.word	0x08011587
 8011474:	08011551 	.word	0x08011551
 8011478:	08011587 	.word	0x08011587
 801147c:	08011587 	.word	0x08011587
 8011480:	08011587 	.word	0x08011587
 8011484:	080114b7 	.word	0x080114b7
 8011488:	08011587 	.word	0x08011587
 801148c:	08011549 	.word	0x08011549
 8011490:	08011587 	.word	0x08011587
 8011494:	08011587 	.word	0x08011587
 8011498:	08011541 	.word	0x08011541
    case 'c':
      filler = ' ';
 801149c:	2320      	movs	r3, #32
 801149e:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
      *p++ = va_arg(ap, int);
 80114a2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80114a4:	1c5a      	adds	r2, r3, #1
 80114a6:	920f      	str	r2, [sp, #60]	; 0x3c
 80114a8:	9a01      	ldr	r2, [sp, #4]
 80114aa:	1d11      	adds	r1, r2, #4
 80114ac:	9101      	str	r1, [sp, #4]
 80114ae:	6812      	ldr	r2, [r2, #0]
 80114b0:	b2d2      	uxtb	r2, r2
 80114b2:	701a      	strb	r2, [r3, #0]
      break;
 80114b4:	e06e      	b.n	8011594 <chvprintf+0x374>
    case 's':
      filler = ' ';
 80114b6:	2320      	movs	r3, #32
 80114b8:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
      if ((s = va_arg(ap, char *)) == 0)
 80114bc:	9b01      	ldr	r3, [sp, #4]
 80114be:	1d1a      	adds	r2, r3, #4
 80114c0:	9201      	str	r2, [sp, #4]
 80114c2:	681b      	ldr	r3, [r3, #0]
 80114c4:	930e      	str	r3, [sp, #56]	; 0x38
 80114c6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80114c8:	2b00      	cmp	r3, #0
 80114ca:	d101      	bne.n	80114d0 <chvprintf+0x2b0>
        s = "(null)";
 80114cc:	4b68      	ldr	r3, [pc, #416]	; (8011670 <chvprintf+0x450>)
 80114ce:	930e      	str	r3, [sp, #56]	; 0x38
      if (precision == 0)
 80114d0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80114d2:	2b00      	cmp	r3, #0
 80114d4:	d102      	bne.n	80114dc <chvprintf+0x2bc>
        precision = 32767;
 80114d6:	f647 73ff 	movw	r3, #32767	; 0x7fff
 80114da:	930b      	str	r3, [sp, #44]	; 0x2c
      for (p = s; *p && (--precision >= 0); p++)
 80114dc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80114de:	930f      	str	r3, [sp, #60]	; 0x3c
 80114e0:	e002      	b.n	80114e8 <chvprintf+0x2c8>
 80114e2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80114e4:	3301      	adds	r3, #1
 80114e6:	930f      	str	r3, [sp, #60]	; 0x3c
 80114e8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80114ea:	781b      	ldrb	r3, [r3, #0]
 80114ec:	2b00      	cmp	r3, #0
 80114ee:	d005      	beq.n	80114fc <chvprintf+0x2dc>
 80114f0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80114f2:	3b01      	subs	r3, #1
 80114f4:	930b      	str	r3, [sp, #44]	; 0x2c
 80114f6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80114f8:	2b00      	cmp	r3, #0
 80114fa:	daf2      	bge.n	80114e2 <chvprintf+0x2c2>
        ;
      break;
 80114fc:	e04a      	b.n	8011594 <chvprintf+0x374>
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long)
 80114fe:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 8011502:	2b00      	cmp	r3, #0
 8011504:	d005      	beq.n	8011512 <chvprintf+0x2f2>
        l = va_arg(ap, long);
 8011506:	9b01      	ldr	r3, [sp, #4]
 8011508:	1d1a      	adds	r2, r3, #4
 801150a:	9201      	str	r2, [sp, #4]
 801150c:	681b      	ldr	r3, [r3, #0]
 801150e:	9307      	str	r3, [sp, #28]
 8011510:	e004      	b.n	801151c <chvprintf+0x2fc>
      else
        l = va_arg(ap, int);
 8011512:	9b01      	ldr	r3, [sp, #4]
 8011514:	1d1a      	adds	r2, r3, #4
 8011516:	9201      	str	r2, [sp, #4]
 8011518:	681b      	ldr	r3, [r3, #0]
 801151a:	9307      	str	r3, [sp, #28]
      if (l < 0) {
 801151c:	9b07      	ldr	r3, [sp, #28]
 801151e:	2b00      	cmp	r3, #0
 8011520:	da07      	bge.n	8011532 <chvprintf+0x312>
        *p++ = '-';
 8011522:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8011524:	1c5a      	adds	r2, r3, #1
 8011526:	920f      	str	r2, [sp, #60]	; 0x3c
 8011528:	222d      	movs	r2, #45	; 0x2d
 801152a:	701a      	strb	r2, [r3, #0]
        l = -l;
 801152c:	9b07      	ldr	r3, [sp, #28]
 801152e:	425b      	negs	r3, r3
 8011530:	9307      	str	r3, [sp, #28]
      }
      p = ch_ltoa(p, l, 10);
 8011532:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8011534:	9907      	ldr	r1, [sp, #28]
 8011536:	220a      	movs	r2, #10
 8011538:	f7ff fe62 	bl	8011200 <ch_ltoa>
 801153c:	900f      	str	r0, [sp, #60]	; 0x3c
      break;
 801153e:	e029      	b.n	8011594 <chvprintf+0x374>
      p = ftoa(p, f, precision);
      break;
#endif
    case 'X':
    case 'x':
      c = 16;
 8011540:	2310      	movs	r3, #16
 8011542:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      goto unsigned_common;
 8011546:	e006      	b.n	8011556 <chvprintf+0x336>
    case 'U':
    case 'u':
      c = 10;
 8011548:	230a      	movs	r3, #10
 801154a:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      goto unsigned_common;
 801154e:	e002      	b.n	8011556 <chvprintf+0x336>
    case 'O':
    case 'o':
      c = 8;
 8011550:	2308      	movs	r3, #8
 8011552:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
unsigned_common:
      if (is_long)
 8011556:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 801155a:	2b00      	cmp	r3, #0
 801155c:	d005      	beq.n	801156a <chvprintf+0x34a>
        l = va_arg(ap, unsigned long);
 801155e:	9b01      	ldr	r3, [sp, #4]
 8011560:	1d1a      	adds	r2, r3, #4
 8011562:	9201      	str	r2, [sp, #4]
 8011564:	681b      	ldr	r3, [r3, #0]
 8011566:	9307      	str	r3, [sp, #28]
 8011568:	e004      	b.n	8011574 <chvprintf+0x354>
      else
        l = va_arg(ap, unsigned int);
 801156a:	9b01      	ldr	r3, [sp, #4]
 801156c:	1d1a      	adds	r2, r3, #4
 801156e:	9201      	str	r2, [sp, #4]
 8011570:	681b      	ldr	r3, [r3, #0]
 8011572:	9307      	str	r3, [sp, #28]
      p = ch_ltoa(p, l, c);
 8011574:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8011578:	980f      	ldr	r0, [sp, #60]	; 0x3c
 801157a:	9907      	ldr	r1, [sp, #28]
 801157c:	461a      	mov	r2, r3
 801157e:	f7ff fe3f 	bl	8011200 <ch_ltoa>
 8011582:	900f      	str	r0, [sp, #60]	; 0x3c
      break;
 8011584:	e006      	b.n	8011594 <chvprintf+0x374>
    default:
      *p++ = c;
 8011586:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8011588:	1c5a      	adds	r2, r3, #1
 801158a:	920f      	str	r2, [sp, #60]	; 0x3c
 801158c:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 8011590:	701a      	strb	r2, [r3, #0]
      break;
 8011592:	bf00      	nop
    }
    i = (int)(p - s);
 8011594:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8011596:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8011598:	1ad3      	subs	r3, r2, r3
 801159a:	930c      	str	r3, [sp, #48]	; 0x30
    if ((width -= i) < 0)
 801159c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801159e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80115a0:	1ad3      	subs	r3, r2, r3
 80115a2:	930a      	str	r3, [sp, #40]	; 0x28
 80115a4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80115a6:	2b00      	cmp	r3, #0
 80115a8:	da01      	bge.n	80115ae <chvprintf+0x38e>
      width = 0;
 80115aa:	2300      	movs	r3, #0
 80115ac:	930a      	str	r3, [sp, #40]	; 0x28
    if (left_align == FALSE)
 80115ae:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
 80115b2:	f083 0301 	eor.w	r3, r3, #1
 80115b6:	b2db      	uxtb	r3, r3
 80115b8:	2b00      	cmp	r3, #0
 80115ba:	d002      	beq.n	80115c2 <chvprintf+0x3a2>
      width = -width;
 80115bc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80115be:	425b      	negs	r3, r3
 80115c0:	930a      	str	r3, [sp, #40]	; 0x28
    if (width < 0) {
 80115c2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80115c4:	2b00      	cmp	r3, #0
 80115c6:	da28      	bge.n	801161a <chvprintf+0x3fa>
      if (*s == '-' && filler == '0') {
 80115c8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80115ca:	781b      	ldrb	r3, [r3, #0]
 80115cc:	2b2d      	cmp	r3, #45	; 0x2d
 80115ce:	d113      	bne.n	80115f8 <chvprintf+0x3d8>
 80115d0:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
 80115d4:	2b30      	cmp	r3, #48	; 0x30
 80115d6:	d10f      	bne.n	80115f8 <chvprintf+0x3d8>
        streamPut(chp, (uint8_t)*s++);
 80115d8:	9b03      	ldr	r3, [sp, #12]
 80115da:	681b      	ldr	r3, [r3, #0]
 80115dc:	689a      	ldr	r2, [r3, #8]
 80115de:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80115e0:	1c59      	adds	r1, r3, #1
 80115e2:	910e      	str	r1, [sp, #56]	; 0x38
 80115e4:	781b      	ldrb	r3, [r3, #0]
 80115e6:	9803      	ldr	r0, [sp, #12]
 80115e8:	4619      	mov	r1, r3
 80115ea:	4790      	blx	r2
        n++;
 80115ec:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80115ee:	3301      	adds	r3, #1
 80115f0:	9309      	str	r3, [sp, #36]	; 0x24
        i--;
 80115f2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80115f4:	3b01      	subs	r3, #1
 80115f6:	930c      	str	r3, [sp, #48]	; 0x30
      }
      do {
        streamPut(chp, (uint8_t)filler);
 80115f8:	9b03      	ldr	r3, [sp, #12]
 80115fa:	681b      	ldr	r3, [r3, #0]
 80115fc:	689b      	ldr	r3, [r3, #8]
 80115fe:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
 8011602:	9803      	ldr	r0, [sp, #12]
 8011604:	4611      	mov	r1, r2
 8011606:	4798      	blx	r3
        n++;
 8011608:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801160a:	3301      	adds	r3, #1
 801160c:	9309      	str	r3, [sp, #36]	; 0x24
      } while (++width != 0);
 801160e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8011610:	3301      	adds	r3, #1
 8011612:	930a      	str	r3, [sp, #40]	; 0x28
 8011614:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8011616:	2b00      	cmp	r3, #0
 8011618:	d1ee      	bne.n	80115f8 <chvprintf+0x3d8>
    }
    while (--i >= 0) {
 801161a:	e00c      	b.n	8011636 <chvprintf+0x416>
      streamPut(chp, (uint8_t)*s++);
 801161c:	9b03      	ldr	r3, [sp, #12]
 801161e:	681b      	ldr	r3, [r3, #0]
 8011620:	689a      	ldr	r2, [r3, #8]
 8011622:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8011624:	1c59      	adds	r1, r3, #1
 8011626:	910e      	str	r1, [sp, #56]	; 0x38
 8011628:	781b      	ldrb	r3, [r3, #0]
 801162a:	9803      	ldr	r0, [sp, #12]
 801162c:	4619      	mov	r1, r3
 801162e:	4790      	blx	r2
      n++;
 8011630:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8011632:	3301      	adds	r3, #1
 8011634:	9309      	str	r3, [sp, #36]	; 0x24
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8011636:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8011638:	3b01      	subs	r3, #1
 801163a:	930c      	str	r3, [sp, #48]	; 0x30
 801163c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801163e:	2b00      	cmp	r3, #0
 8011640:	daec      	bge.n	801161c <chvprintf+0x3fc>
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8011642:	e00d      	b.n	8011660 <chvprintf+0x440>
      streamPut(chp, (uint8_t)filler);
 8011644:	9b03      	ldr	r3, [sp, #12]
 8011646:	681b      	ldr	r3, [r3, #0]
 8011648:	689b      	ldr	r3, [r3, #8]
 801164a:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
 801164e:	9803      	ldr	r0, [sp, #12]
 8011650:	4611      	mov	r1, r2
 8011652:	4798      	blx	r3
      n++;
 8011654:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8011656:	3301      	adds	r3, #1
 8011658:	9309      	str	r3, [sp, #36]	; 0x24
      width--;
 801165a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801165c:	3b01      	subs	r3, #1
 801165e:	930a      	str	r3, [sp, #40]	; 0x28
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8011660:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8011662:	2b00      	cmp	r3, #0
 8011664:	d1ee      	bne.n	8011644 <chvprintf+0x424>
      streamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
 8011666:	e5e2      	b.n	801122e <chvprintf+0xe>
}
 8011668:	4618      	mov	r0, r3
 801166a:	b011      	add	sp, #68	; 0x44
 801166c:	f85d fb04 	ldr.w	pc, [sp], #4
 8011670:	08018790 	.word	0x08018790
 8011674:	f3af 8000 	nop.w
 8011678:	f3af 8000 	nop.w
 801167c:	f3af 8000 	nop.w

08011680 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8011680:	b40e      	push	{r1, r2, r3}
 8011682:	b500      	push	{lr}
 8011684:	b084      	sub	sp, #16
 8011686:	9001      	str	r0, [sp, #4]
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8011688:	ab06      	add	r3, sp, #24
 801168a:	9302      	str	r3, [sp, #8]
  formatted_bytes = chvprintf(chp, fmt, ap);
 801168c:	9801      	ldr	r0, [sp, #4]
 801168e:	9905      	ldr	r1, [sp, #20]
 8011690:	9a02      	ldr	r2, [sp, #8]
 8011692:	f7ff fdc5 	bl	8011220 <chvprintf>
 8011696:	9003      	str	r0, [sp, #12]
  va_end(ap);

  return formatted_bytes;
 8011698:	9b03      	ldr	r3, [sp, #12]
}
 801169a:	4618      	mov	r0, r3
 801169c:	b004      	add	sp, #16
 801169e:	f85d eb04 	ldr.w	lr, [sp], #4
 80116a2:	b003      	add	sp, #12
 80116a4:	4770      	bx	lr
 80116a6:	bf00      	nop
 80116a8:	f3af 8000 	nop.w
 80116ac:	f3af 8000 	nop.w

080116b0 <chsnprintf>:
 *                      terminating NUL byte) that would have been
 *                      stored in @p str if there was room.
 *
 * @api
 */
int chsnprintf(char *str, size_t size, const char *fmt, ...) {
 80116b0:	b40c      	push	{r2, r3}
 80116b2:	b500      	push	{lr}
 80116b4:	b08d      	sub	sp, #52	; 0x34
 80116b6:	9001      	str	r0, [sp, #4]
 80116b8:	9100      	str	r1, [sp, #0]
  MemoryStream ms;
  BaseSequentialStream *chp;
  size_t size_wo_nul;
  int retval;

  if (size > 0)
 80116ba:	9b00      	ldr	r3, [sp, #0]
 80116bc:	2b00      	cmp	r3, #0
 80116be:	d003      	beq.n	80116c8 <chsnprintf+0x18>
    size_wo_nul = size - 1;
 80116c0:	9b00      	ldr	r3, [sp, #0]
 80116c2:	3b01      	subs	r3, #1
 80116c4:	930b      	str	r3, [sp, #44]	; 0x2c
 80116c6:	e001      	b.n	80116cc <chsnprintf+0x1c>
  else
    size_wo_nul = 0;
 80116c8:	2300      	movs	r3, #0
 80116ca:	930b      	str	r3, [sp, #44]	; 0x2c

  /* Memory stream object to be used as a string writer, reserving one
     byte for the final zero.*/
  msObjectInit(&ms, (uint8_t *)str, size_wo_nul, 0);
 80116cc:	ab03      	add	r3, sp, #12
 80116ce:	4618      	mov	r0, r3
 80116d0:	9901      	ldr	r1, [sp, #4]
 80116d2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80116d4:	2300      	movs	r3, #0
 80116d6:	f7ff fd2b 	bl	8011130 <msObjectInit>

  /* Performing the print operation using the common code.*/
  chp = (BaseSequentialStream *)(void *)&ms;
 80116da:	ab03      	add	r3, sp, #12
 80116dc:	930a      	str	r3, [sp, #40]	; 0x28
  va_start(ap, fmt);
 80116de:	ab0f      	add	r3, sp, #60	; 0x3c
 80116e0:	9308      	str	r3, [sp, #32]
  retval = chvprintf(chp, fmt, ap);
 80116e2:	980a      	ldr	r0, [sp, #40]	; 0x28
 80116e4:	990e      	ldr	r1, [sp, #56]	; 0x38
 80116e6:	9a08      	ldr	r2, [sp, #32]
 80116e8:	f7ff fd9a 	bl	8011220 <chvprintf>
 80116ec:	9009      	str	r0, [sp, #36]	; 0x24
  va_end(ap);

  /* Terminate with a zero, unless size==0.*/
  if (ms.eos < size)
 80116ee:	9a06      	ldr	r2, [sp, #24]
 80116f0:	9b00      	ldr	r3, [sp, #0]
 80116f2:	429a      	cmp	r2, r3
 80116f4:	d204      	bcs.n	8011700 <chsnprintf+0x50>
      str[ms.eos] = 0;
 80116f6:	9b06      	ldr	r3, [sp, #24]
 80116f8:	9a01      	ldr	r2, [sp, #4]
 80116fa:	4413      	add	r3, r2
 80116fc:	2200      	movs	r2, #0
 80116fe:	701a      	strb	r2, [r3, #0]

  /* Return number of bytes that would have been written.*/
  return retval;
 8011700:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
 8011702:	4618      	mov	r0, r3
 8011704:	b00d      	add	sp, #52	; 0x34
 8011706:	f85d eb04 	ldr.w	lr, [sp], #4
 801170a:	b002      	add	sp, #8
 801170c:	4770      	bx	lr
 801170e:	bf00      	nop

08011710 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8011710:	b082      	sub	sp, #8
 8011712:	2320      	movs	r3, #32
 8011714:	9301      	str	r3, [sp, #4]
 8011716:	9b01      	ldr	r3, [sp, #4]
 8011718:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 801171c:	b002      	add	sp, #8
 801171e:	4770      	bx	lr

08011720 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8011720:	b082      	sub	sp, #8
 8011722:	2300      	movs	r3, #0
 8011724:	9301      	str	r3, [sp, #4]
 8011726:	9b01      	ldr	r3, [sp, #4]
 8011728:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 801172c:	b002      	add	sp, #8
 801172e:	4770      	bx	lr

08011730 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8011730:	b508      	push	{r3, lr}

  port_lock();
 8011732:	f7ff ffed 	bl	8011710 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8011736:	bd08      	pop	{r3, pc}
 8011738:	f3af 8000 	nop.w
 801173c:	f3af 8000 	nop.w

08011740 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8011740:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8011742:	f7ff ffed 	bl	8011720 <port_unlock>
}
 8011746:	bd08      	pop	{r3, pc}
 8011748:	f3af 8000 	nop.w
 801174c:	f3af 8000 	nop.w

08011750 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 8011750:	4b01      	ldr	r3, [pc, #4]	; (8011758 <chVTGetSystemTimeX+0x8>)
 8011752:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8011754:	4618      	mov	r0, r3
 8011756:	4770      	bx	lr
 8011758:	200016e0 	.word	0x200016e0
 801175c:	f3af 8000 	nop.w

08011760 <chVTGetSystemTime>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 8011760:	b500      	push	{lr}
 8011762:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 8011764:	f7ff ffe4 	bl	8011730 <chSysLock>
  systime = chVTGetSystemTimeX();
 8011768:	f7ff fff2 	bl	8011750 <chVTGetSystemTimeX>
 801176c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 801176e:	f7ff ffe7 	bl	8011740 <chSysUnlock>

  return systime;
 8011772:	9b01      	ldr	r3, [sp, #4]
}
 8011774:	4618      	mov	r0, r3
 8011776:	b003      	add	sp, #12
 8011778:	f85d fb04 	ldr.w	pc, [sp], #4
 801177c:	f3af 8000 	nop.w

08011780 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8011780:	b082      	sub	sp, #8
 8011782:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8011784:	4b02      	ldr	r3, [pc, #8]	; (8011790 <chRegSetThreadName+0x10>)
 8011786:	699b      	ldr	r3, [r3, #24]
 8011788:	9a01      	ldr	r2, [sp, #4]
 801178a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 801178c:	b002      	add	sp, #8
 801178e:	4770      	bx	lr
 8011790:	200016e0 	.word	0x200016e0
 8011794:	f3af 8000 	nop.w
 8011798:	f3af 8000 	nop.w
 801179c:	f3af 8000 	nop.w

080117a0 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 80117a0:	b082      	sub	sp, #8
 80117a2:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 80117a4:	9b01      	ldr	r3, [sp, #4]
 80117a6:	9a01      	ldr	r2, [sp, #4]
 80117a8:	601a      	str	r2, [r3, #0]
}
 80117aa:	b002      	add	sp, #8
 80117ac:	4770      	bx	lr
 80117ae:	bf00      	nop

080117b0 <chEvtBroadcastI>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {
 80117b0:	b500      	push	{lr}
 80117b2:	b083      	sub	sp, #12
 80117b4:	9001      	str	r0, [sp, #4]

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
 80117b6:	9801      	ldr	r0, [sp, #4]
 80117b8:	2100      	movs	r1, #0
 80117ba:	f7f0 ff61 	bl	8002680 <chEvtBroadcastFlagsI>
}
 80117be:	b003      	add	sp, #12
 80117c0:	f85d fb04 	ldr.w	pc, [sp], #4
 80117c4:	f3af 8000 	nop.w
 80117c8:	f3af 8000 	nop.w
 80117cc:	f3af 8000 	nop.w

080117d0 <_strtok>:
/**
 * @brief   Shell termination event source.
 */
event_source_t shell_terminated;

static char *_strtok(char *str, const char *delim, char **saveptr) {
 80117d0:	b500      	push	{lr}
 80117d2:	b087      	sub	sp, #28
 80117d4:	9003      	str	r0, [sp, #12]
 80117d6:	9102      	str	r1, [sp, #8]
 80117d8:	9201      	str	r2, [sp, #4]
  char *token;
  if (str)
 80117da:	9b03      	ldr	r3, [sp, #12]
 80117dc:	2b00      	cmp	r3, #0
 80117de:	d002      	beq.n	80117e6 <_strtok+0x16>
    *saveptr = str;
 80117e0:	9b01      	ldr	r3, [sp, #4]
 80117e2:	9a03      	ldr	r2, [sp, #12]
 80117e4:	601a      	str	r2, [r3, #0]
  token = *saveptr;
 80117e6:	9b01      	ldr	r3, [sp, #4]
 80117e8:	681b      	ldr	r3, [r3, #0]
 80117ea:	9305      	str	r3, [sp, #20]

  if (!token)
 80117ec:	9b05      	ldr	r3, [sp, #20]
 80117ee:	2b00      	cmp	r3, #0
 80117f0:	d101      	bne.n	80117f6 <_strtok+0x26>
    return NULL;
 80117f2:	2300      	movs	r3, #0
 80117f4:	e020      	b.n	8011838 <_strtok+0x68>

  token += strspn(token, delim);
 80117f6:	9805      	ldr	r0, [sp, #20]
 80117f8:	9902      	ldr	r1, [sp, #8]
 80117fa:	f005 fea9 	bl	8017550 <strspn>
 80117fe:	4603      	mov	r3, r0
 8011800:	9a05      	ldr	r2, [sp, #20]
 8011802:	4413      	add	r3, r2
 8011804:	9305      	str	r3, [sp, #20]
  *saveptr = strpbrk(token, delim);
 8011806:	9805      	ldr	r0, [sp, #20]
 8011808:	9902      	ldr	r1, [sp, #8]
 801180a:	f005 fe79 	bl	8017500 <strpbrk>
 801180e:	4602      	mov	r2, r0
 8011810:	9b01      	ldr	r3, [sp, #4]
 8011812:	601a      	str	r2, [r3, #0]
  if (*saveptr)
 8011814:	9b01      	ldr	r3, [sp, #4]
 8011816:	681b      	ldr	r3, [r3, #0]
 8011818:	2b00      	cmp	r3, #0
 801181a:	d006      	beq.n	801182a <_strtok+0x5a>
    *(*saveptr)++ = '\0';
 801181c:	9b01      	ldr	r3, [sp, #4]
 801181e:	681b      	ldr	r3, [r3, #0]
 8011820:	1c59      	adds	r1, r3, #1
 8011822:	9a01      	ldr	r2, [sp, #4]
 8011824:	6011      	str	r1, [r2, #0]
 8011826:	2200      	movs	r2, #0
 8011828:	701a      	strb	r2, [r3, #0]

  return *token ? token : NULL;
 801182a:	9b05      	ldr	r3, [sp, #20]
 801182c:	781b      	ldrb	r3, [r3, #0]
 801182e:	2b00      	cmp	r3, #0
 8011830:	d001      	beq.n	8011836 <_strtok+0x66>
 8011832:	9b05      	ldr	r3, [sp, #20]
 8011834:	e000      	b.n	8011838 <_strtok+0x68>
 8011836:	2300      	movs	r3, #0
}
 8011838:	4618      	mov	r0, r3
 801183a:	b007      	add	sp, #28
 801183c:	f85d fb04 	ldr.w	pc, [sp], #4

08011840 <usage>:

static void usage(BaseSequentialStream *chp, char *p) {
 8011840:	b500      	push	{lr}
 8011842:	b083      	sub	sp, #12
 8011844:	9001      	str	r0, [sp, #4]
 8011846:	9100      	str	r1, [sp, #0]

  chprintf(chp, "Usage: %s\r\n", p);
 8011848:	9801      	ldr	r0, [sp, #4]
 801184a:	4903      	ldr	r1, [pc, #12]	; (8011858 <usage+0x18>)
 801184c:	9a00      	ldr	r2, [sp, #0]
 801184e:	f7ff ff17 	bl	8011680 <chprintf>
}
 8011852:	b003      	add	sp, #12
 8011854:	f85d fb04 	ldr.w	pc, [sp], #4
 8011858:	080187a0 	.word	0x080187a0
 801185c:	f3af 8000 	nop.w

08011860 <list_commands>:

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {
 8011860:	b500      	push	{lr}
 8011862:	b083      	sub	sp, #12
 8011864:	9001      	str	r0, [sp, #4]
 8011866:	9100      	str	r1, [sp, #0]

  while (scp->sc_name != NULL) {
 8011868:	e009      	b.n	801187e <list_commands+0x1e>
    chprintf(chp, "%s ", scp->sc_name);
 801186a:	9b00      	ldr	r3, [sp, #0]
 801186c:	681b      	ldr	r3, [r3, #0]
 801186e:	9801      	ldr	r0, [sp, #4]
 8011870:	4906      	ldr	r1, [pc, #24]	; (801188c <list_commands+0x2c>)
 8011872:	461a      	mov	r2, r3
 8011874:	f7ff ff04 	bl	8011680 <chprintf>
    scp++;
 8011878:	9b00      	ldr	r3, [sp, #0]
 801187a:	3308      	adds	r3, #8
 801187c:	9300      	str	r3, [sp, #0]
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 801187e:	9b00      	ldr	r3, [sp, #0]
 8011880:	681b      	ldr	r3, [r3, #0]
 8011882:	2b00      	cmp	r3, #0
 8011884:	d1f1      	bne.n	801186a <list_commands+0xa>
    chprintf(chp, "%s ", scp->sc_name);
    scp++;
  }
}
 8011886:	b003      	add	sp, #12
 8011888:	f85d fb04 	ldr.w	pc, [sp], #4
 801188c:	080187ac 	.word	0x080187ac

08011890 <cmd_info>:

static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 8011890:	b500      	push	{lr}
 8011892:	b087      	sub	sp, #28
 8011894:	9005      	str	r0, [sp, #20]
 8011896:	9104      	str	r1, [sp, #16]
 8011898:	9203      	str	r2, [sp, #12]

  (void)argv;
  if (argc > 0) {
 801189a:	9b04      	ldr	r3, [sp, #16]
 801189c:	2b00      	cmp	r3, #0
 801189e:	dd04      	ble.n	80118aa <cmd_info+0x1a>
    usage(chp, "info");
 80118a0:	9805      	ldr	r0, [sp, #20]
 80118a2:	4919      	ldr	r1, [pc, #100]	; (8011908 <cmd_info+0x78>)
 80118a4:	f7ff ffcc 	bl	8011840 <usage>
    return;
 80118a8:	e02a      	b.n	8011900 <cmd_info+0x70>
  }

  chprintf(chp, "Kernel:       %s\r\n", CH_KERNEL_VERSION);
 80118aa:	9805      	ldr	r0, [sp, #20]
 80118ac:	4917      	ldr	r1, [pc, #92]	; (801190c <cmd_info+0x7c>)
 80118ae:	4a18      	ldr	r2, [pc, #96]	; (8011910 <cmd_info+0x80>)
 80118b0:	f7ff fee6 	bl	8011680 <chprintf>
#ifdef PORT_COMPILER_NAME
  chprintf(chp, "Compiler:     %s\r\n", PORT_COMPILER_NAME);
 80118b4:	9805      	ldr	r0, [sp, #20]
 80118b6:	4917      	ldr	r1, [pc, #92]	; (8011914 <cmd_info+0x84>)
 80118b8:	4a17      	ldr	r2, [pc, #92]	; (8011918 <cmd_info+0x88>)
 80118ba:	f7ff fee1 	bl	8011680 <chprintf>
#endif
  chprintf(chp, "Architecture: %s\r\n", PORT_ARCHITECTURE_NAME);
 80118be:	9805      	ldr	r0, [sp, #20]
 80118c0:	4916      	ldr	r1, [pc, #88]	; (801191c <cmd_info+0x8c>)
 80118c2:	4a17      	ldr	r2, [pc, #92]	; (8011920 <cmd_info+0x90>)
 80118c4:	f7ff fedc 	bl	8011680 <chprintf>
#ifdef PORT_CORE_VARIANT_NAME
  chprintf(chp, "Core Variant: %s\r\n", PORT_CORE_VARIANT_NAME);
 80118c8:	9805      	ldr	r0, [sp, #20]
 80118ca:	4916      	ldr	r1, [pc, #88]	; (8011924 <cmd_info+0x94>)
 80118cc:	4a16      	ldr	r2, [pc, #88]	; (8011928 <cmd_info+0x98>)
 80118ce:	f7ff fed7 	bl	8011680 <chprintf>
#endif
#ifdef PORT_INFO
  chprintf(chp, "Port Info:    %s\r\n", PORT_INFO);
 80118d2:	9805      	ldr	r0, [sp, #20]
 80118d4:	4915      	ldr	r1, [pc, #84]	; (801192c <cmd_info+0x9c>)
 80118d6:	4a16      	ldr	r2, [pc, #88]	; (8011930 <cmd_info+0xa0>)
 80118d8:	f7ff fed2 	bl	8011680 <chprintf>
#endif
#ifdef PLATFORM_NAME
  chprintf(chp, "Platform:     %s\r\n", PLATFORM_NAME);
 80118dc:	9805      	ldr	r0, [sp, #20]
 80118de:	4915      	ldr	r1, [pc, #84]	; (8011934 <cmd_info+0xa4>)
 80118e0:	4a15      	ldr	r2, [pc, #84]	; (8011938 <cmd_info+0xa8>)
 80118e2:	f7ff fecd 	bl	8011680 <chprintf>
#endif
#ifdef BOARD_NAME
  chprintf(chp, "Board:        %s\r\n", BOARD_NAME);
 80118e6:	9805      	ldr	r0, [sp, #20]
 80118e8:	4914      	ldr	r1, [pc, #80]	; (801193c <cmd_info+0xac>)
 80118ea:	4a15      	ldr	r2, [pc, #84]	; (8011940 <cmd_info+0xb0>)
 80118ec:	f7ff fec8 	bl	8011680 <chprintf>
#endif
#ifdef __DATE__
#ifdef __TIME__
  chprintf(chp, "Build time:   %s%s%s\r\n", __DATE__, " - ", __TIME__);
 80118f0:	4b14      	ldr	r3, [pc, #80]	; (8011944 <cmd_info+0xb4>)
 80118f2:	9300      	str	r3, [sp, #0]
 80118f4:	9805      	ldr	r0, [sp, #20]
 80118f6:	4914      	ldr	r1, [pc, #80]	; (8011948 <cmd_info+0xb8>)
 80118f8:	4a14      	ldr	r2, [pc, #80]	; (801194c <cmd_info+0xbc>)
 80118fa:	4b15      	ldr	r3, [pc, #84]	; (8011950 <cmd_info+0xc0>)
 80118fc:	f7ff fec0 	bl	8011680 <chprintf>
#endif
#endif
}
 8011900:	b007      	add	sp, #28
 8011902:	f85d fb04 	ldr.w	pc, [sp], #4
 8011906:	bf00      	nop
 8011908:	080187b0 	.word	0x080187b0
 801190c:	080187b8 	.word	0x080187b8
 8011910:	080187cc 	.word	0x080187cc
 8011914:	080187d4 	.word	0x080187d4
 8011918:	080187e8 	.word	0x080187e8
 801191c:	08018830 	.word	0x08018830
 8011920:	08018844 	.word	0x08018844
 8011924:	08018850 	.word	0x08018850
 8011928:	08018864 	.word	0x08018864
 801192c:	08018870 	.word	0x08018870
 8011930:	08018884 	.word	0x08018884
 8011934:	0801889c 	.word	0x0801889c
 8011938:	080188b0 	.word	0x080188b0
 801193c:	080188cc 	.word	0x080188cc
 8011940:	080188e0 	.word	0x080188e0
 8011944:	08018918 	.word	0x08018918
 8011948:	080188f0 	.word	0x080188f0
 801194c:	08018908 	.word	0x08018908
 8011950:	08018914 	.word	0x08018914
 8011954:	f3af 8000 	nop.w
 8011958:	f3af 8000 	nop.w
 801195c:	f3af 8000 	nop.w

08011960 <cmd_systime>:

static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {
 8011960:	b500      	push	{lr}
 8011962:	b085      	sub	sp, #20
 8011964:	9003      	str	r0, [sp, #12]
 8011966:	9102      	str	r1, [sp, #8]
 8011968:	9201      	str	r2, [sp, #4]

  (void)argv;
  if (argc > 0) {
 801196a:	9b02      	ldr	r3, [sp, #8]
 801196c:	2b00      	cmp	r3, #0
 801196e:	dd04      	ble.n	801197a <cmd_systime+0x1a>
    usage(chp, "systime");
 8011970:	9803      	ldr	r0, [sp, #12]
 8011972:	4907      	ldr	r1, [pc, #28]	; (8011990 <cmd_systime+0x30>)
 8011974:	f7ff ff64 	bl	8011840 <usage>
    return;
 8011978:	e007      	b.n	801198a <cmd_systime+0x2a>
  }
  chprintf(chp, "%lu\r\n", (unsigned long)chVTGetSystemTime());
 801197a:	f7ff fef1 	bl	8011760 <chVTGetSystemTime>
 801197e:	4603      	mov	r3, r0
 8011980:	9803      	ldr	r0, [sp, #12]
 8011982:	4904      	ldr	r1, [pc, #16]	; (8011994 <cmd_systime+0x34>)
 8011984:	461a      	mov	r2, r3
 8011986:	f7ff fe7b 	bl	8011680 <chprintf>
}
 801198a:	b005      	add	sp, #20
 801198c:	f85d fb04 	ldr.w	pc, [sp], #4
 8011990:	08018924 	.word	0x08018924
 8011994:	0801892c 	.word	0x0801892c
 8011998:	f3af 8000 	nop.w
 801199c:	f3af 8000 	nop.w

080119a0 <cmdexec>:
  {"systime", cmd_systime},
  {NULL, NULL}
};

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {
 80119a0:	b500      	push	{lr}
 80119a2:	b085      	sub	sp, #20
 80119a4:	9003      	str	r0, [sp, #12]
 80119a6:	9102      	str	r1, [sp, #8]
 80119a8:	9201      	str	r2, [sp, #4]
 80119aa:	9300      	str	r3, [sp, #0]

  while (scp->sc_name != NULL) {
 80119ac:	e013      	b.n	80119d6 <cmdexec+0x36>
    if (strcmp(scp->sc_name, name) == 0) {
 80119ae:	9b03      	ldr	r3, [sp, #12]
 80119b0:	681b      	ldr	r3, [r3, #0]
 80119b2:	4618      	mov	r0, r3
 80119b4:	9901      	ldr	r1, [sp, #4]
 80119b6:	f005 fc03 	bl	80171c0 <strcmp>
 80119ba:	4603      	mov	r3, r0
 80119bc:	2b00      	cmp	r3, #0
 80119be:	d107      	bne.n	80119d0 <cmdexec+0x30>
      scp->sc_function(chp, argc, argv);
 80119c0:	9b03      	ldr	r3, [sp, #12]
 80119c2:	685b      	ldr	r3, [r3, #4]
 80119c4:	9802      	ldr	r0, [sp, #8]
 80119c6:	9900      	ldr	r1, [sp, #0]
 80119c8:	9a06      	ldr	r2, [sp, #24]
 80119ca:	4798      	blx	r3
      return false;
 80119cc:	2300      	movs	r3, #0
 80119ce:	e007      	b.n	80119e0 <cmdexec+0x40>
    }
    scp++;
 80119d0:	9b03      	ldr	r3, [sp, #12]
 80119d2:	3308      	adds	r3, #8
 80119d4:	9303      	str	r3, [sp, #12]
};

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {

  while (scp->sc_name != NULL) {
 80119d6:	9b03      	ldr	r3, [sp, #12]
 80119d8:	681b      	ldr	r3, [r3, #0]
 80119da:	2b00      	cmp	r3, #0
 80119dc:	d1e7      	bne.n	80119ae <cmdexec+0xe>
      scp->sc_function(chp, argc, argv);
      return false;
    }
    scp++;
  }
  return true;
 80119de:	2301      	movs	r3, #1
}
 80119e0:	4618      	mov	r0, r3
 80119e2:	b005      	add	sp, #20
 80119e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80119e8:	f3af 8000 	nop.w
 80119ec:	f3af 8000 	nop.w

080119f0 <shell_thread>:
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
static THD_FUNCTION(shell_thread, p) {
 80119f0:	b500      	push	{lr}
 80119f2:	b0a1      	sub	sp, #132	; 0x84
 80119f4:	9003      	str	r0, [sp, #12]
  int n;
  BaseSequentialStream *chp = ((ShellConfig *)p)->sc_channel;
 80119f6:	9b03      	ldr	r3, [sp, #12]
 80119f8:	681b      	ldr	r3, [r3, #0]
 80119fa:	931d      	str	r3, [sp, #116]	; 0x74
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
 80119fc:	9b03      	ldr	r3, [sp, #12]
 80119fe:	685b      	ldr	r3, [r3, #4]
 8011a00:	931c      	str	r3, [sp, #112]	; 0x70
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("shell");
 8011a02:	4855      	ldr	r0, [pc, #340]	; (8011b58 <shell_thread+0x168>)
 8011a04:	f7ff febc 	bl	8011780 <chRegSetThreadName>
  chprintf(chp, "\r\nChibiOS/RT Shell\r\n");
 8011a08:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011a0a:	4954      	ldr	r1, [pc, #336]	; (8011b5c <shell_thread+0x16c>)
 8011a0c:	f7ff fe38 	bl	8011680 <chprintf>
  while (true) {
    chprintf(chp, "ch> ");
 8011a10:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011a12:	4953      	ldr	r1, [pc, #332]	; (8011b60 <shell_thread+0x170>)
 8011a14:	f7ff fe34 	bl	8011680 <chprintf>
    if (shellGetLine(chp, line, sizeof(line))) {
 8011a18:	ab0a      	add	r3, sp, #40	; 0x28
 8011a1a:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011a1c:	4619      	mov	r1, r3
 8011a1e:	2240      	movs	r2, #64	; 0x40
 8011a20:	f000 f8fe 	bl	8011c20 <shellGetLine>
 8011a24:	4603      	mov	r3, r0
 8011a26:	2b00      	cmp	r3, #0
 8011a28:	d004      	beq.n	8011a34 <shell_thread+0x44>
      chprintf(chp, "\r\nlogout");
 8011a2a:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011a2c:	494d      	ldr	r1, [pc, #308]	; (8011b64 <shell_thread+0x174>)
 8011a2e:	f7ff fe27 	bl	8011680 <chprintf>
      break;
 8011a32:	e08a      	b.n	8011b4a <shell_thread+0x15a>
    }
    lp = _strtok(line, " \t", &tokp);
 8011a34:	aa0a      	add	r2, sp, #40	; 0x28
 8011a36:	ab1a      	add	r3, sp, #104	; 0x68
 8011a38:	4610      	mov	r0, r2
 8011a3a:	494b      	ldr	r1, [pc, #300]	; (8011b68 <shell_thread+0x178>)
 8011a3c:	461a      	mov	r2, r3
 8011a3e:	f7ff fec7 	bl	80117d0 <_strtok>
 8011a42:	901b      	str	r0, [sp, #108]	; 0x6c
    cmd = lp;
 8011a44:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8011a46:	931e      	str	r3, [sp, #120]	; 0x78
    n = 0;
 8011a48:	2300      	movs	r3, #0
 8011a4a:	931f      	str	r3, [sp, #124]	; 0x7c
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 8011a4c:	e012      	b.n	8011a74 <shell_thread+0x84>
      if (n >= SHELL_MAX_ARGUMENTS) {
 8011a4e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8011a50:	2b03      	cmp	r3, #3
 8011a52:	dd06      	ble.n	8011a62 <shell_thread+0x72>
        chprintf(chp, "too many arguments\r\n");
 8011a54:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011a56:	4945      	ldr	r1, [pc, #276]	; (8011b6c <shell_thread+0x17c>)
 8011a58:	f7ff fe12 	bl	8011680 <chprintf>
        cmd = NULL;
 8011a5c:	2300      	movs	r3, #0
 8011a5e:	931e      	str	r3, [sp, #120]	; 0x78
        break;
 8011a60:	e012      	b.n	8011a88 <shell_thread+0x98>
      }
      args[n++] = lp;
 8011a62:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8011a64:	1c5a      	adds	r2, r3, #1
 8011a66:	921f      	str	r2, [sp, #124]	; 0x7c
 8011a68:	009b      	lsls	r3, r3, #2
 8011a6a:	aa20      	add	r2, sp, #128	; 0x80
 8011a6c:	4413      	add	r3, r2
 8011a6e:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 8011a70:	f843 2c6c 	str.w	r2, [r3, #-108]
      break;
    }
    lp = _strtok(line, " \t", &tokp);
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 8011a74:	ab1a      	add	r3, sp, #104	; 0x68
 8011a76:	2000      	movs	r0, #0
 8011a78:	493b      	ldr	r1, [pc, #236]	; (8011b68 <shell_thread+0x178>)
 8011a7a:	461a      	mov	r2, r3
 8011a7c:	f7ff fea8 	bl	80117d0 <_strtok>
 8011a80:	901b      	str	r0, [sp, #108]	; 0x6c
 8011a82:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8011a84:	2b00      	cmp	r3, #0
 8011a86:	d1e2      	bne.n	8011a4e <shell_thread+0x5e>
        cmd = NULL;
        break;
      }
      args[n++] = lp;
    }
    args[n] = NULL;
 8011a88:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8011a8a:	009b      	lsls	r3, r3, #2
 8011a8c:	aa20      	add	r2, sp, #128	; 0x80
 8011a8e:	4413      	add	r3, r2
 8011a90:	2200      	movs	r2, #0
 8011a92:	f843 2c6c 	str.w	r2, [r3, #-108]
    if (cmd != NULL) {
 8011a96:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8011a98:	2b00      	cmp	r3, #0
 8011a9a:	d055      	beq.n	8011b48 <shell_thread+0x158>
      if (strcmp(cmd, "exit") == 0) {
 8011a9c:	981e      	ldr	r0, [sp, #120]	; 0x78
 8011a9e:	4934      	ldr	r1, [pc, #208]	; (8011b70 <shell_thread+0x180>)
 8011aa0:	f005 fb8e 	bl	80171c0 <strcmp>
 8011aa4:	4603      	mov	r3, r0
 8011aa6:	2b00      	cmp	r3, #0
 8011aa8:	d108      	bne.n	8011abc <shell_thread+0xcc>
        if (n > 0) {
 8011aaa:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8011aac:	2b00      	cmp	r3, #0
 8011aae:	dd04      	ble.n	8011aba <shell_thread+0xca>
          usage(chp, "exit");
 8011ab0:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011ab2:	492f      	ldr	r1, [pc, #188]	; (8011b70 <shell_thread+0x180>)
 8011ab4:	f7ff fec4 	bl	8011840 <usage>
          continue;
 8011ab8:	e046      	b.n	8011b48 <shell_thread+0x158>
        }
        break;
 8011aba:	e046      	b.n	8011b4a <shell_thread+0x15a>
      }
      else if (strcmp(cmd, "help") == 0) {
 8011abc:	981e      	ldr	r0, [sp, #120]	; 0x78
 8011abe:	492d      	ldr	r1, [pc, #180]	; (8011b74 <shell_thread+0x184>)
 8011ac0:	f005 fb7e 	bl	80171c0 <strcmp>
 8011ac4:	4603      	mov	r3, r0
 8011ac6:	2b00      	cmp	r3, #0
 8011ac8:	d11b      	bne.n	8011b02 <shell_thread+0x112>
        if (n > 0) {
 8011aca:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8011acc:	2b00      	cmp	r3, #0
 8011ace:	dd04      	ble.n	8011ada <shell_thread+0xea>
          usage(chp, "help");
 8011ad0:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011ad2:	4928      	ldr	r1, [pc, #160]	; (8011b74 <shell_thread+0x184>)
 8011ad4:	f7ff feb4 	bl	8011840 <usage>
          continue;
 8011ad8:	e036      	b.n	8011b48 <shell_thread+0x158>
        }
        chprintf(chp, "Commands: help exit ");
 8011ada:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011adc:	4926      	ldr	r1, [pc, #152]	; (8011b78 <shell_thread+0x188>)
 8011ade:	f7ff fdcf 	bl	8011680 <chprintf>
        list_commands(chp, local_commands);
 8011ae2:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011ae4:	4925      	ldr	r1, [pc, #148]	; (8011b7c <shell_thread+0x18c>)
 8011ae6:	f7ff febb 	bl	8011860 <list_commands>
        if (scp != NULL)
 8011aea:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8011aec:	2b00      	cmp	r3, #0
 8011aee:	d003      	beq.n	8011af8 <shell_thread+0x108>
          list_commands(chp, scp);
 8011af0:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011af2:	991c      	ldr	r1, [sp, #112]	; 0x70
 8011af4:	f7ff feb4 	bl	8011860 <list_commands>
        chprintf(chp, "\r\n");
 8011af8:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011afa:	4921      	ldr	r1, [pc, #132]	; (8011b80 <shell_thread+0x190>)
 8011afc:	f7ff fdc0 	bl	8011680 <chprintf>
 8011b00:	e022      	b.n	8011b48 <shell_thread+0x158>
      }
      else if (cmdexec(local_commands, chp, cmd, n, args) &&
 8011b02:	ab05      	add	r3, sp, #20
 8011b04:	9300      	str	r3, [sp, #0]
 8011b06:	481d      	ldr	r0, [pc, #116]	; (8011b7c <shell_thread+0x18c>)
 8011b08:	991d      	ldr	r1, [sp, #116]	; 0x74
 8011b0a:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 8011b0c:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8011b0e:	f7ff ff47 	bl	80119a0 <cmdexec>
 8011b12:	4603      	mov	r3, r0
 8011b14:	2b00      	cmp	r3, #0
 8011b16:	d017      	beq.n	8011b48 <shell_thread+0x158>
 8011b18:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8011b1a:	2b00      	cmp	r3, #0
 8011b1c:	d00a      	beq.n	8011b34 <shell_thread+0x144>
          ((scp == NULL) || cmdexec(scp, chp, cmd, n, args))) {
 8011b1e:	ab05      	add	r3, sp, #20
 8011b20:	9300      	str	r3, [sp, #0]
 8011b22:	981c      	ldr	r0, [sp, #112]	; 0x70
 8011b24:	991d      	ldr	r1, [sp, #116]	; 0x74
 8011b26:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 8011b28:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8011b2a:	f7ff ff39 	bl	80119a0 <cmdexec>
 8011b2e:	4603      	mov	r3, r0
 8011b30:	2b00      	cmp	r3, #0
 8011b32:	d009      	beq.n	8011b48 <shell_thread+0x158>
        chprintf(chp, "%s", cmd);
 8011b34:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011b36:	4913      	ldr	r1, [pc, #76]	; (8011b84 <shell_thread+0x194>)
 8011b38:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 8011b3a:	f7ff fda1 	bl	8011680 <chprintf>
        chprintf(chp, " ?\r\n");
 8011b3e:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011b40:	4911      	ldr	r1, [pc, #68]	; (8011b88 <shell_thread+0x198>)
 8011b42:	f7ff fd9d 	bl	8011680 <chprintf>
      }
    }
  }
 8011b46:	e763      	b.n	8011a10 <shell_thread+0x20>
 8011b48:	e762      	b.n	8011a10 <shell_thread+0x20>
  shellExit(MSG_OK);
 8011b4a:	2000      	movs	r0, #0
 8011b4c:	f000 f828 	bl	8011ba0 <shellExit>
}
 8011b50:	b021      	add	sp, #132	; 0x84
 8011b52:	f85d fb04 	ldr.w	pc, [sp], #4
 8011b56:	bf00      	nop
 8011b58:	0801894c 	.word	0x0801894c
 8011b5c:	08018954 	.word	0x08018954
 8011b60:	0801896c 	.word	0x0801896c
 8011b64:	08018974 	.word	0x08018974
 8011b68:	08018980 	.word	0x08018980
 8011b6c:	08018984 	.word	0x08018984
 8011b70:	0801899c 	.word	0x0801899c
 8011b74:	080189a4 	.word	0x080189a4
 8011b78:	080189ac 	.word	0x080189ac
 8011b7c:	08018934 	.word	0x08018934
 8011b80:	080189c4 	.word	0x080189c4
 8011b84:	080189c8 	.word	0x080189c8
 8011b88:	080189cc 	.word	0x080189cc
 8011b8c:	f3af 8000 	nop.w

08011b90 <shellInit>:
/**
 * @brief   Shell manager initialization.
 *
 * @api
 */
void shellInit(void) {
 8011b90:	b508      	push	{r3, lr}

  chEvtObjectInit(&shell_terminated);
 8011b92:	4802      	ldr	r0, [pc, #8]	; (8011b9c <shellInit+0xc>)
 8011b94:	f7ff fe04 	bl	80117a0 <chEvtObjectInit>
}
 8011b98:	bd08      	pop	{r3, pc}
 8011b9a:	bf00      	nop
 8011b9c:	20002220 	.word	0x20002220

08011ba0 <shellExit>:
 *
 * @param[in] msg       shell exit code
 *
 * @api
 */
void shellExit(msg_t msg) {
 8011ba0:	b500      	push	{lr}
 8011ba2:	b083      	sub	sp, #12
 8011ba4:	9001      	str	r0, [sp, #4]

  /* Atomically broadcasting the event source and terminating the thread,
     there is not a chSysUnlock() because the thread terminates upon return.*/
  chSysLock();
 8011ba6:	f7ff fdc3 	bl	8011730 <chSysLock>
  chEvtBroadcastI(&shell_terminated);
 8011baa:	4804      	ldr	r0, [pc, #16]	; (8011bbc <shellExit+0x1c>)
 8011bac:	f7ff fe00 	bl	80117b0 <chEvtBroadcastI>
  chThdExitS(msg);
 8011bb0:	9801      	ldr	r0, [sp, #4]
 8011bb2:	f7ef fbed 	bl	8001390 <chThdExitS>
}
 8011bb6:	b003      	add	sp, #12
 8011bb8:	f85d fb04 	ldr.w	pc, [sp], #4
 8011bbc:	20002220 	.word	0x20002220

08011bc0 <shellCreate>:
 * @retval NULL         thread creation failed because memory allocation.
 *
 * @api
 */
#if CH_CFG_USE_HEAP && CH_CFG_USE_DYNAMIC
thread_t *shellCreate(const ShellConfig *scp, size_t size, tprio_t prio) {
 8011bc0:	b500      	push	{lr}
 8011bc2:	b087      	sub	sp, #28
 8011bc4:	9005      	str	r0, [sp, #20]
 8011bc6:	9104      	str	r1, [sp, #16]
 8011bc8:	9203      	str	r2, [sp, #12]

  return chThdCreateFromHeap(NULL, size, prio, shell_thread, (void *)scp);
 8011bca:	9b05      	ldr	r3, [sp, #20]
 8011bcc:	9300      	str	r3, [sp, #0]
 8011bce:	2000      	movs	r0, #0
 8011bd0:	9904      	ldr	r1, [sp, #16]
 8011bd2:	9a03      	ldr	r2, [sp, #12]
 8011bd4:	4b03      	ldr	r3, [pc, #12]	; (8011be4 <shellCreate+0x24>)
 8011bd6:	f7ef fe3b 	bl	8001850 <chThdCreateFromHeap>
 8011bda:	4603      	mov	r3, r0
}
 8011bdc:	4618      	mov	r0, r3
 8011bde:	b007      	add	sp, #28
 8011be0:	f85d fb04 	ldr.w	pc, [sp], #4
 8011be4:	080119f1 	.word	0x080119f1
 8011be8:	f3af 8000 	nop.w
 8011bec:	f3af 8000 	nop.w

08011bf0 <shellCreateStatic>:
 * @return              A pointer to the shell thread.
 *
 * @api
 */
thread_t *shellCreateStatic(const ShellConfig *scp, void *wsp,
                            size_t size, tprio_t prio) {
 8011bf0:	b500      	push	{lr}
 8011bf2:	b087      	sub	sp, #28
 8011bf4:	9005      	str	r0, [sp, #20]
 8011bf6:	9104      	str	r1, [sp, #16]
 8011bf8:	9203      	str	r2, [sp, #12]
 8011bfa:	9302      	str	r3, [sp, #8]

  return chThdCreateStatic(wsp, size, prio, shell_thread, (void *)scp);
 8011bfc:	9b05      	ldr	r3, [sp, #20]
 8011bfe:	9300      	str	r3, [sp, #0]
 8011c00:	9804      	ldr	r0, [sp, #16]
 8011c02:	9903      	ldr	r1, [sp, #12]
 8011c04:	9a02      	ldr	r2, [sp, #8]
 8011c06:	4b04      	ldr	r3, [pc, #16]	; (8011c18 <shellCreateStatic+0x28>)
 8011c08:	f7ef faea 	bl	80011e0 <chThdCreateStatic>
 8011c0c:	4603      	mov	r3, r0
}
 8011c0e:	4618      	mov	r0, r3
 8011c10:	b007      	add	sp, #28
 8011c12:	f85d fb04 	ldr.w	pc, [sp], #4
 8011c16:	bf00      	nop
 8011c18:	080119f1 	.word	0x080119f1
 8011c1c:	f3af 8000 	nop.w

08011c20 <shellGetLine>:
 * @retval true         the channel was reset or CTRL-D pressed.
 * @retval false        operation successful.
 *
 * @api
 */
bool shellGetLine(BaseSequentialStream *chp, char *line, unsigned size) {
 8011c20:	b500      	push	{lr}
 8011c22:	b087      	sub	sp, #28
 8011c24:	9003      	str	r0, [sp, #12]
 8011c26:	9102      	str	r1, [sp, #8]
 8011c28:	9201      	str	r2, [sp, #4]
  char *p = line;
 8011c2a:	9b02      	ldr	r3, [sp, #8]
 8011c2c:	9305      	str	r3, [sp, #20]

  while (true) {
    char c;

    if (chSequentialStreamRead(chp, (uint8_t *)&c, 1) == 0)
 8011c2e:	9b03      	ldr	r3, [sp, #12]
 8011c30:	681b      	ldr	r3, [r3, #0]
 8011c32:	685b      	ldr	r3, [r3, #4]
 8011c34:	f10d 0213 	add.w	r2, sp, #19
 8011c38:	9803      	ldr	r0, [sp, #12]
 8011c3a:	4611      	mov	r1, r2
 8011c3c:	2201      	movs	r2, #1
 8011c3e:	4798      	blx	r3
 8011c40:	4603      	mov	r3, r0
 8011c42:	2b00      	cmp	r3, #0
 8011c44:	d101      	bne.n	8011c4a <shellGetLine+0x2a>
      return true;
 8011c46:	2301      	movs	r3, #1
 8011c48:	e055      	b.n	8011cf6 <shellGetLine+0xd6>
    if (c == 4) {
 8011c4a:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8011c4e:	2b04      	cmp	r3, #4
 8011c50:	d105      	bne.n	8011c5e <shellGetLine+0x3e>
      chprintf(chp, "^D");
 8011c52:	9803      	ldr	r0, [sp, #12]
 8011c54:	492a      	ldr	r1, [pc, #168]	; (8011d00 <shellGetLine+0xe0>)
 8011c56:	f7ff fd13 	bl	8011680 <chprintf>
      return true;
 8011c5a:	2301      	movs	r3, #1
 8011c5c:	e04b      	b.n	8011cf6 <shellGetLine+0xd6>
    }
    if ((c == 8) || (c == 127)) {
 8011c5e:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8011c62:	2b08      	cmp	r3, #8
 8011c64:	d003      	beq.n	8011c6e <shellGetLine+0x4e>
 8011c66:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8011c6a:	2b7f      	cmp	r3, #127	; 0x7f
 8011c6c:	d11a      	bne.n	8011ca4 <shellGetLine+0x84>
      if (p != line) {
 8011c6e:	9a05      	ldr	r2, [sp, #20]
 8011c70:	9b02      	ldr	r3, [sp, #8]
 8011c72:	429a      	cmp	r2, r3
 8011c74:	d015      	beq.n	8011ca2 <shellGetLine+0x82>
        chSequentialStreamPut(chp, 0x08);
 8011c76:	9b03      	ldr	r3, [sp, #12]
 8011c78:	681b      	ldr	r3, [r3, #0]
 8011c7a:	689b      	ldr	r3, [r3, #8]
 8011c7c:	9803      	ldr	r0, [sp, #12]
 8011c7e:	2108      	movs	r1, #8
 8011c80:	4798      	blx	r3
        chSequentialStreamPut(chp, 0x20);
 8011c82:	9b03      	ldr	r3, [sp, #12]
 8011c84:	681b      	ldr	r3, [r3, #0]
 8011c86:	689b      	ldr	r3, [r3, #8]
 8011c88:	9803      	ldr	r0, [sp, #12]
 8011c8a:	2120      	movs	r1, #32
 8011c8c:	4798      	blx	r3
        chSequentialStreamPut(chp, 0x08);
 8011c8e:	9b03      	ldr	r3, [sp, #12]
 8011c90:	681b      	ldr	r3, [r3, #0]
 8011c92:	689b      	ldr	r3, [r3, #8]
 8011c94:	9803      	ldr	r0, [sp, #12]
 8011c96:	2108      	movs	r1, #8
 8011c98:	4798      	blx	r3
        p--;
 8011c9a:	9b05      	ldr	r3, [sp, #20]
 8011c9c:	3b01      	subs	r3, #1
 8011c9e:	9305      	str	r3, [sp, #20]
      }
      continue;
 8011ca0:	e028      	b.n	8011cf4 <shellGetLine+0xd4>
 8011ca2:	e027      	b.n	8011cf4 <shellGetLine+0xd4>
    }
    if (c == '\r') {
 8011ca4:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8011ca8:	2b0d      	cmp	r3, #13
 8011caa:	d108      	bne.n	8011cbe <shellGetLine+0x9e>
      chprintf(chp, "\r\n");
 8011cac:	9803      	ldr	r0, [sp, #12]
 8011cae:	4915      	ldr	r1, [pc, #84]	; (8011d04 <shellGetLine+0xe4>)
 8011cb0:	f7ff fce6 	bl	8011680 <chprintf>
      *p = 0;
 8011cb4:	9b05      	ldr	r3, [sp, #20]
 8011cb6:	2200      	movs	r2, #0
 8011cb8:	701a      	strb	r2, [r3, #0]
      return false;
 8011cba:	2300      	movs	r3, #0
 8011cbc:	e01b      	b.n	8011cf6 <shellGetLine+0xd6>
    }
    if (c < 0x20)
 8011cbe:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8011cc2:	2b1f      	cmp	r3, #31
 8011cc4:	d800      	bhi.n	8011cc8 <shellGetLine+0xa8>
      continue;
 8011cc6:	e015      	b.n	8011cf4 <shellGetLine+0xd4>
    if (p < line + size - 1) {
 8011cc8:	9b01      	ldr	r3, [sp, #4]
 8011cca:	3b01      	subs	r3, #1
 8011ccc:	9a02      	ldr	r2, [sp, #8]
 8011cce:	441a      	add	r2, r3
 8011cd0:	9b05      	ldr	r3, [sp, #20]
 8011cd2:	429a      	cmp	r2, r3
 8011cd4:	d90e      	bls.n	8011cf4 <shellGetLine+0xd4>
      chSequentialStreamPut(chp, c);
 8011cd6:	9b03      	ldr	r3, [sp, #12]
 8011cd8:	681b      	ldr	r3, [r3, #0]
 8011cda:	689b      	ldr	r3, [r3, #8]
 8011cdc:	f89d 2013 	ldrb.w	r2, [sp, #19]
 8011ce0:	9803      	ldr	r0, [sp, #12]
 8011ce2:	4611      	mov	r1, r2
 8011ce4:	4798      	blx	r3
      *p++ = (char)c;
 8011ce6:	9b05      	ldr	r3, [sp, #20]
 8011ce8:	1c5a      	adds	r2, r3, #1
 8011cea:	9205      	str	r2, [sp, #20]
 8011cec:	f89d 2013 	ldrb.w	r2, [sp, #19]
 8011cf0:	701a      	strb	r2, [r3, #0]
    }
  }
 8011cf2:	e79c      	b.n	8011c2e <shellGetLine+0xe>
 8011cf4:	e79b      	b.n	8011c2e <shellGetLine+0xe>
}
 8011cf6:	4618      	mov	r0, r3
 8011cf8:	b007      	add	sp, #28
 8011cfa:	f85d fb04 	ldr.w	pc, [sp], #4
 8011cfe:	bf00      	nop
 8011d00:	080189d4 	.word	0x080189d4
 8011d04:	080189c4 	.word	0x080189c4
 8011d08:	f3af 8000 	nop.w
 8011d0c:	f3af 8000 	nop.w

08011d10 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8011d10:	b082      	sub	sp, #8
 8011d12:	4603      	mov	r3, r0
 8011d14:	f88d 3007 	strb.w	r3, [sp, #7]
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8011d18:	4b07      	ldr	r3, [pc, #28]	; (8011d38 <NVIC_EnableIRQ+0x28>)
 8011d1a:	f99d 2007 	ldrsb.w	r2, [sp, #7]
 8011d1e:	0952      	lsrs	r2, r2, #5
 8011d20:	f89d 1007 	ldrb.w	r1, [sp, #7]
 8011d24:	f001 011f 	and.w	r1, r1, #31
 8011d28:	2001      	movs	r0, #1
 8011d2a:	fa00 f101 	lsl.w	r1, r0, r1
 8011d2e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8011d32:	b002      	add	sp, #8
 8011d34:	4770      	bx	lr
 8011d36:	bf00      	nop
 8011d38:	e000e100 	.word	0xe000e100
 8011d3c:	f3af 8000 	nop.w

08011d40 <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
 8011d40:	b082      	sub	sp, #8
 8011d42:	4603      	mov	r3, r0
 8011d44:	f88d 3007 	strb.w	r3, [sp, #7]
  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8011d48:	4b07      	ldr	r3, [pc, #28]	; (8011d68 <NVIC_DisableIRQ+0x28>)
 8011d4a:	f99d 2007 	ldrsb.w	r2, [sp, #7]
 8011d4e:	0952      	lsrs	r2, r2, #5
 8011d50:	f89d 1007 	ldrb.w	r1, [sp, #7]
 8011d54:	f001 011f 	and.w	r1, r1, #31
 8011d58:	2001      	movs	r0, #1
 8011d5a:	fa00 f101 	lsl.w	r1, r0, r1
 8011d5e:	3220      	adds	r2, #32
 8011d60:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8011d64:	b002      	add	sp, #8
 8011d66:	4770      	bx	lr
 8011d68:	e000e100 	.word	0xe000e100
 8011d6c:	f3af 8000 	nop.w

08011d70 <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
 8011d70:	b082      	sub	sp, #8
 8011d72:	4603      	mov	r3, r0
 8011d74:	f88d 3007 	strb.w	r3, [sp, #7]
  NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8011d78:	4b07      	ldr	r3, [pc, #28]	; (8011d98 <NVIC_ClearPendingIRQ+0x28>)
 8011d7a:	f99d 2007 	ldrsb.w	r2, [sp, #7]
 8011d7e:	0952      	lsrs	r2, r2, #5
 8011d80:	f89d 1007 	ldrb.w	r1, [sp, #7]
 8011d84:	f001 011f 	and.w	r1, r1, #31
 8011d88:	2001      	movs	r0, #1
 8011d8a:	fa00 f101 	lsl.w	r1, r0, r1
 8011d8e:	3260      	adds	r2, #96	; 0x60
 8011d90:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8011d94:	b002      	add	sp, #8
 8011d96:	4770      	bx	lr
 8011d98:	e000e100 	.word	0xe000e100
 8011d9c:	f3af 8000 	nop.w

08011da0 <Sensor_IO_SPI_Write>:
 * @retval 0 in case of success
 * @retval 1 in case of failure
 */

uint8_t Sensor_IO_SPI_Write(SPIConfig *handle, uint8_t WriteAddr, uint8_t *pBuffer, uint16_t nBytesToWrite )
{
 8011da0:	b500      	push	{lr}
 8011da2:	b087      	sub	sp, #28
 8011da4:	9003      	str	r0, [sp, #12]
 8011da6:	9201      	str	r2, [sp, #4]
 8011da8:	460a      	mov	r2, r1
 8011daa:	f88d 200b 	strb.w	r2, [sp, #11]
 8011dae:	f8ad 3008 	strh.w	r3, [sp, #8]

  	uint8_t i;

  	// checks which port & pin we're on 
  	// enables 3-wire SPI mode for the accelerometer (LSM303)
  	if(handle->ssport == GPIOC && handle->sspad == 4) // may not need this anymore 
 8011db2:	9b03      	ldr	r3, [sp, #12]
 8011db4:	685a      	ldr	r2, [r3, #4]
 8011db6:	4b32      	ldr	r3, [pc, #200]	; (8011e80 <Sensor_IO_SPI_Write+0xe0>)
 8011db8:	429a      	cmp	r2, r3
 8011dba:	d15b      	bne.n	8011e74 <Sensor_IO_SPI_Write+0xd4>
 8011dbc:	9b03      	ldr	r3, [sp, #12]
 8011dbe:	891b      	ldrh	r3, [r3, #8]
 8011dc0:	2b04      	cmp	r3, #4
 8011dc2:	d157      	bne.n	8011e74 <Sensor_IO_SPI_Write+0xd4>
	  {
	  	SPIDriver *spip = (SPIDriver *) &SPID2;
 8011dc4:	4b2f      	ldr	r3, [pc, #188]	; (8011e84 <Sensor_IO_SPI_Write+0xe4>)
 8011dc6:	9304      	str	r3, [sp, #16]
	  	// Select the correct device
	    //Sensor_IO_SPI_CS_Enable(handle); // -> spiSelect(SPIDriver *spip) || spiSelectI(spip) 
	    	if(nBytesToWrite > 1){
 8011dc8:	f8bd 3008 	ldrh.w	r3, [sp, #8]
 8011dcc:	2b01      	cmp	r3, #1
 8011dce:	d905      	bls.n	8011ddc <Sensor_IO_SPI_Write+0x3c>
	  		WriteAddr |= 0x40;
 8011dd0:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8011dd4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8011dd8:	f88d 300b 	strb.w	r3, [sp, #11]
	  	}
	    	//WriteAddr = WriteAddr & (~0x80);	
	    	WriteAddr &= (~0x80);
 8011ddc:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8011de0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8011de4:	f88d 300b 	strb.w	r3, [sp, #11]
	    	spiAcquireBus(spip);
 8011de8:	9804      	ldr	r0, [sp, #16]
 8011dea:	f7f4 fc71 	bl	80066d0 <spiAcquireBus>
	  
	    	spiStart(spip, handle);
 8011dee:	9804      	ldr	r0, [sp, #16]
 8011df0:	9903      	ldr	r1, [sp, #12]
 8011df2:	f7f4 fb4d 	bl	8006490 <spiStart>
	  
	    	SPI_DMA_DISABLE(spip);
 8011df6:	9b04      	ldr	r3, [sp, #16]
 8011df8:	69db      	ldr	r3, [r3, #28]
 8011dfa:	9a04      	ldr	r2, [sp, #16]
 8011dfc:	69d2      	ldr	r2, [r2, #28]
 8011dfe:	6852      	ldr	r2, [r2, #4]
 8011e00:	f022 0203 	bic.w	r2, r2, #3
 8011e04:	605a      	str	r2, [r3, #4]
	    	SPI_1LINE_ENABLE(spip);
 8011e06:	9b04      	ldr	r3, [sp, #16]
 8011e08:	69db      	ldr	r3, [r3, #28]
 8011e0a:	9a04      	ldr	r2, [sp, #16]
 8011e0c:	69d2      	ldr	r2, [r2, #28]
 8011e0e:	6812      	ldr	r2, [r2, #0]
 8011e10:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8011e14:	601a      	str	r2, [r3, #0]
	    	SPI_1LINE_TX(spip);
 8011e16:	9b04      	ldr	r3, [sp, #16]
 8011e18:	69db      	ldr	r3, [r3, #28]
 8011e1a:	9a04      	ldr	r2, [sp, #16]
 8011e1c:	69d2      	ldr	r2, [r2, #28]
 8011e1e:	6812      	ldr	r2, [r2, #0]
 8011e20:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8011e24:	601a      	str	r2, [r3, #0]
	  
	 	 	spiSelect(spip);
 8011e26:	9804      	ldr	r0, [sp, #16]
 8011e28:	f7f4 fb5a 	bl	80064e0 <spiSelect>
	  	
	  		spiPolledTx(spip,(uint16_t)WriteAddr); // size ? 
 8011e2c:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8011e30:	9804      	ldr	r0, [sp, #16]
 8011e32:	4619      	mov	r1, r3
 8011e34:	f7f9 fc4c 	bl	800b6d0 <spi_lld_polled_tx>
	  
	    	for(i=0;i<nBytesToWrite;i++)
 8011e38:	2300      	movs	r3, #0
 8011e3a:	f88d 3017 	strb.w	r3, [sp, #23]
 8011e3e:	e00c      	b.n	8011e5a <Sensor_IO_SPI_Write+0xba>
	    	{
	  		spiPolledTx(spip, (uint16_t)*pBuffer++);
 8011e40:	9b01      	ldr	r3, [sp, #4]
 8011e42:	1c5a      	adds	r2, r3, #1
 8011e44:	9201      	str	r2, [sp, #4]
 8011e46:	781b      	ldrb	r3, [r3, #0]
 8011e48:	9804      	ldr	r0, [sp, #16]
 8011e4a:	4619      	mov	r1, r3
 8011e4c:	f7f9 fc40 	bl	800b6d0 <spi_lld_polled_tx>
	  
	 	 	spiSelect(spip);
	  	
	  		spiPolledTx(spip,(uint16_t)WriteAddr); // size ? 
	  
	    	for(i=0;i<nBytesToWrite;i++)
 8011e50:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8011e54:	3301      	adds	r3, #1
 8011e56:	f88d 3017 	strb.w	r3, [sp, #23]
 8011e5a:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8011e5e:	b29b      	uxth	r3, r3
 8011e60:	f8bd 2008 	ldrh.w	r2, [sp, #8]
 8011e64:	429a      	cmp	r2, r3
 8011e66:	d8eb      	bhi.n	8011e40 <Sensor_IO_SPI_Write+0xa0>
	    	{
	  		spiPolledTx(spip, (uint16_t)*pBuffer++);
	   	}
	    
	  // Deselect the device
	  	spiUnselect(spip);
 8011e68:	9804      	ldr	r0, [sp, #16]
 8011e6a:	f7f4 fb49 	bl	8006500 <spiUnselect>
	  	spiReleaseBus(spip);
 8011e6e:	9804      	ldr	r0, [sp, #16]
 8011e70:	f7f4 fc3e 	bl	80066f0 <spiReleaseBus>
	 } 


  //Sensor_IO_SPI_CS_Disable(handle); // -> spiUnselect(SPIDRiver *spip) || spiUnselectI(spip)
  
  return 0;
 8011e74:	2300      	movs	r3, #0
  
}
 8011e76:	4618      	mov	r0, r3
 8011e78:	b007      	add	sp, #28
 8011e7a:	f85d fb04 	ldr.w	pc, [sp], #4
 8011e7e:	bf00      	nop
 8011e80:	48000800 	.word	0x48000800
 8011e84:	20001af0 	.word	0x20001af0
 8011e88:	f3af 8000 	nop.w
 8011e8c:	f3af 8000 	nop.w

08011e90 <Sensor_IO_SPI_Read>:
 * @retval 1 in case of failure
 */


uint8_t Sensor_IO_SPI_Read(SPIConfig *handle, uint8_t ReadAddr, uint8_t *pBuffer, uint16_t nBytesToRead )
{
 8011e90:	b510      	push	{r4, lr}
 8011e92:	b086      	sub	sp, #24
 8011e94:	9003      	str	r0, [sp, #12]
 8011e96:	9201      	str	r2, [sp, #4]
 8011e98:	460a      	mov	r2, r1
 8011e9a:	f88d 200b 	strb.w	r2, [sp, #11]
 8011e9e:	f8ad 3008 	strh.w	r3, [sp, #8]

	SPIDriver *spip = (SPIDriver *) &SPID2;
 8011ea2:	4b36      	ldr	r3, [pc, #216]	; (8011f7c <Sensor_IO_SPI_Read+0xec>)
 8011ea4:	9304      	str	r3, [sp, #16]

	uint8_t i;
	 
	if(nBytesToRead > 1){
 8011ea6:	f8bd 3008 	ldrh.w	r3, [sp, #8]
 8011eaa:	2b01      	cmp	r3, #1
 8011eac:	d905      	bls.n	8011eba <Sensor_IO_SPI_Read+0x2a>
		ReadAddr |=  0x40;
 8011eae:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8011eb2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8011eb6:	f88d 300b 	strb.w	r3, [sp, #11]
	}
	ReadAddr |= 0x80;
 8011eba:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8011ebe:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8011ec2:	f88d 300b 	strb.w	r3, [sp, #11]

	spiAcquireBus(spip); // acquire bus
 8011ec6:	9804      	ldr	r0, [sp, #16]
 8011ec8:	f7f4 fc02 	bl	80066d0 <spiAcquireBus>

	spiStart(spip, handle); 
 8011ecc:	9804      	ldr	r0, [sp, #16]
 8011ece:	9903      	ldr	r1, [sp, #12]
 8011ed0:	f7f4 fade 	bl	8006490 <spiStart>
 
 	SPI_DMA_DISABLE(spip);
 8011ed4:	9b04      	ldr	r3, [sp, #16]
 8011ed6:	69db      	ldr	r3, [r3, #28]
 8011ed8:	9a04      	ldr	r2, [sp, #16]
 8011eda:	69d2      	ldr	r2, [r2, #28]
 8011edc:	6852      	ldr	r2, [r2, #4]
 8011ede:	f022 0203 	bic.w	r2, r2, #3
 8011ee2:	605a      	str	r2, [r3, #4]
 	SPI_1LINE_ENABLE(spip);
 8011ee4:	9b04      	ldr	r3, [sp, #16]
 8011ee6:	69db      	ldr	r3, [r3, #28]
 8011ee8:	9a04      	ldr	r2, [sp, #16]
 8011eea:	69d2      	ldr	r2, [r2, #28]
 8011eec:	6812      	ldr	r2, [r2, #0]
 8011eee:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8011ef2:	601a      	str	r2, [r3, #0]
	spiSelect(spip);
 8011ef4:	9804      	ldr	r0, [sp, #16]
 8011ef6:	f7f4 faf3 	bl	80064e0 <spiSelect>

	spiPolledTx(spip, (uint16_t)ReadAddr);
 8011efa:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8011efe:	9804      	ldr	r0, [sp, #16]
 8011f00:	4619      	mov	r1, r3
 8011f02:	f7f9 fbe5 	bl	800b6d0 <spi_lld_polled_tx>

	SPI_1LINE_DISABLE(spip);
 8011f06:	9b04      	ldr	r3, [sp, #16]
 8011f08:	69db      	ldr	r3, [r3, #28]
 8011f0a:	9a04      	ldr	r2, [sp, #16]
 8011f0c:	69d2      	ldr	r2, [r2, #28]
 8011f0e:	6812      	ldr	r2, [r2, #0]
 8011f10:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8011f14:	601a      	str	r2, [r3, #0]
	SPI_1LINE_RX(spip);
 8011f16:	9b04      	ldr	r3, [sp, #16]
 8011f18:	69db      	ldr	r3, [r3, #28]
 8011f1a:	9a04      	ldr	r2, [sp, #16]
 8011f1c:	69d2      	ldr	r2, [r2, #28]
 8011f1e:	6812      	ldr	r2, [r2, #0]
 8011f20:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8011f24:	601a      	str	r2, [r3, #0]

	// Select the correct device
	  for(i=0;i<nBytesToRead;i++)
 8011f26:	2300      	movs	r3, #0
 8011f28:	f88d 3017 	strb.w	r3, [sp, #23]
 8011f2c:	e00d      	b.n	8011f4a <Sensor_IO_SPI_Read+0xba>
	  {
		*pBuffer++ = spiPolledRx(spip);
 8011f2e:	9c01      	ldr	r4, [sp, #4]
 8011f30:	1c63      	adds	r3, r4, #1
 8011f32:	9301      	str	r3, [sp, #4]
 8011f34:	9804      	ldr	r0, [sp, #16]
 8011f36:	f7f9 fbfb 	bl	800b730 <spi_lld_polled_rx>
 8011f3a:	4603      	mov	r3, r0
 8011f3c:	b2db      	uxtb	r3, r3
 8011f3e:	7023      	strb	r3, [r4, #0]

	SPI_1LINE_DISABLE(spip);
	SPI_1LINE_RX(spip);

	// Select the correct device
	  for(i=0;i<nBytesToRead;i++)
 8011f40:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8011f44:	3301      	adds	r3, #1
 8011f46:	f88d 3017 	strb.w	r3, [sp, #23]
 8011f4a:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8011f4e:	b29b      	uxth	r3, r3
 8011f50:	f8bd 2008 	ldrh.w	r2, [sp, #8]
 8011f54:	429a      	cmp	r2, r3
 8011f56:	d8ea      	bhi.n	8011f2e <Sensor_IO_SPI_Read+0x9e>
	  {
		*pBuffer++ = spiPolledRx(spip);
	
	  }

	  spiUnselect(spip);
 8011f58:	9804      	ldr	r0, [sp, #16]
 8011f5a:	f7f4 fad1 	bl	8006500 <spiUnselect>
	  
	  SPI_1LINE_TX(spip);
 8011f5e:	9b04      	ldr	r3, [sp, #16]
 8011f60:	69db      	ldr	r3, [r3, #28]
 8011f62:	9a04      	ldr	r2, [sp, #16]
 8011f64:	69d2      	ldr	r2, [r2, #28]
 8011f66:	6812      	ldr	r2, [r2, #0]
 8011f68:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8011f6c:	601a      	str	r2, [r3, #0]

	  spiReleaseBus(spip);
 8011f6e:	9804      	ldr	r0, [sp, #16]
 8011f70:	f7f4 fbbe 	bl	80066f0 <spiReleaseBus>

	  return 0;
 8011f74:	2300      	movs	r3, #0
}
 8011f76:	4618      	mov	r0, r3
 8011f78:	b006      	add	sp, #24
 8011f7a:	bd10      	pop	{r4, pc}
 8011f7c:	20001af0 	.word	0x20001af0

08011f80 <Sensor_IO_SPI_BlueNRG_Write>:
// How to set the IRQ low, and also set it as output?  


int32_t Sensor_IO_SPI_BlueNRG_Write(SPIConfig *handle, uint8_t* data1,
                          uint8_t* data2, uint8_t numbytes1, uint8_t numbytes2)
{  
 8011f80:	b510      	push	{r4, lr}
 8011f82:	b0cc      	sub	sp, #304	; 0x130
 8011f84:	ac03      	add	r4, sp, #12
 8011f86:	6020      	str	r0, [r4, #0]
 8011f88:	a802      	add	r0, sp, #8
 8011f8a:	6001      	str	r1, [r0, #0]
 8011f8c:	a901      	add	r1, sp, #4
 8011f8e:	600a      	str	r2, [r1, #0]
 8011f90:	461a      	mov	r2, r3
 8011f92:	f10d 0303 	add.w	r3, sp, #3
 8011f96:	701a      	strb	r2, [r3, #0]
	SPIDriver *spip = (SPIDriver *) &SPID1;
 8011f98:	4b3f      	ldr	r3, [pc, #252]	; (8012098 <Sensor_IO_SPI_BlueNRG_Write+0x118>)
 8011f9a:	934a      	str	r3, [sp, #296]	; 0x128

  	int32_t result = 0;
 8011f9c:	2300      	movs	r3, #0
 8011f9e:	934b      	str	r3, [sp, #300]	; 0x12c
  
  	int32_t spi_fix_enabled = 0;
 8011fa0:	2300      	movs	r3, #0
 8011fa2:	9349      	str	r3, [sp, #292]	; 0x124
  
#ifdef ENABLE_SPI_FIX
  spi_fix_enabled = 1;
#endif //ENABLE_SPI_FIX
  
  unsigned char header_master[HEADER_SIZE] = {0x0a, 0x00, 0x00, 0x00, 0x00};
 8011fa4:	230a      	movs	r3, #10
 8011fa6:	f88d 311c 	strb.w	r3, [sp, #284]	; 0x11c
 8011faa:	2300      	movs	r3, #0
 8011fac:	f88d 311d 	strb.w	r3, [sp, #285]	; 0x11d
 8011fb0:	2300      	movs	r3, #0
 8011fb2:	f88d 311e 	strb.w	r3, [sp, #286]	; 0x11e
 8011fb6:	2300      	movs	r3, #0
 8011fb8:	f88d 311f 	strb.w	r3, [sp, #287]	; 0x11f
 8011fbc:	2300      	movs	r3, #0
 8011fbe:	f88d 3120 	strb.w	r3, [sp, #288]	; 0x120
  unsigned char header_slave[HEADER_SIZE]  = {0xaa, 0x00, 0x00, 0x00, 0x00};
 8011fc2:	23aa      	movs	r3, #170	; 0xaa
 8011fc4:	f88d 3114 	strb.w	r3, [sp, #276]	; 0x114
 8011fc8:	2300      	movs	r3, #0
 8011fca:	f88d 3115 	strb.w	r3, [sp, #277]	; 0x115
 8011fce:	2300      	movs	r3, #0
 8011fd0:	f88d 3116 	strb.w	r3, [sp, #278]	; 0x116
 8011fd4:	2300      	movs	r3, #0
 8011fd6:	f88d 3117 	strb.w	r3, [sp, #279]	; 0x117
 8011fda:	2300      	movs	r3, #0
 8011fdc:	f88d 3118 	strb.w	r3, [sp, #280]	; 0x118
  
  unsigned char read_char_buf[MAX_BUFFER_SIZE];
  
  Disable_SPI_IRQ(); // chSysLock();
 8011fe0:	f000 f926 	bl	8012230 <Disable_SPI_IRQ>
  If the SPI_FIX is enabled the IRQ is set in Output mode, then it is pulled
  high and, after a delay of at least 112us, the CS line is asserted and the
  header transmit/receive operations are started.
  After these transmit/receive operations the IRQ is reset in input mode.
  */
  if (spi_fix_enabled) {
 8011fe4:	9b49      	ldr	r3, [sp, #292]	; 0x124
 8011fe6:	2b00      	cmp	r3, #0
 8011fe8:	d003      	beq.n	8011ff2 <Sensor_IO_SPI_BlueNRG_Write+0x72>
    set_irq_as_output();
 8011fea:	f000 f8e9 	bl	80121c0 <set_irq_as_output>
    
    /* Assert CS line after at least 112us */

    us150Delay(); // chThdSleepMilliseconds(...); ???
 8011fee:	f000 f8ff 	bl	80121f0 <us150Delay>
  }
  


  /* CS reset */
  spiAcquireBus(spip); 
 8011ff2:	984a      	ldr	r0, [sp, #296]	; 0x128
 8011ff4:	f7f4 fb6c 	bl	80066d0 <spiAcquireBus>
  spiStart(spip, handle);
 8011ff8:	ab03      	add	r3, sp, #12
 8011ffa:	984a      	ldr	r0, [sp, #296]	; 0x128
 8011ffc:	6819      	ldr	r1, [r3, #0]
 8011ffe:	f7f4 fa47 	bl	8006490 <spiStart>

  spiUnselect(spip);
 8012002:	984a      	ldr	r0, [sp, #296]	; 0x128
 8012004:	f7f4 fa7c 	bl	8006500 <spiUnselect>
  // HAL_GPIO_WritePin(BNRG_SPI_CS_PORT, BNRG_SPI_CS_PIN, GPIO_PIN_RESET);  	// spiUnselect(SpiDriver *spip);   
  
  /* Exchange header */  
  spiStartExchange(spip, HEADER_SIZE, header_master, header_slave);
 8012008:	aa47      	add	r2, sp, #284	; 0x11c
 801200a:	ab45      	add	r3, sp, #276	; 0x114
 801200c:	984a      	ldr	r0, [sp, #296]	; 0x128
 801200e:	2105      	movs	r1, #5
 8012010:	f7f4 fa9e 	bl	8006550 <spiStartExchange>

  /*__disable_irq();
  HAL_SPI_TransmitReceive(handle, header_master, header_slave, HEADER_SIZE, TIMEOUT_DURATION);		// spiStartExchange(SpiDriver ..., size, txbuf, rxbuf);
  __enable_irq();
  */
  if (spi_fix_enabled) {
 8012014:	9b49      	ldr	r3, [sp, #292]	; 0x124
 8012016:	2b00      	cmp	r3, #0
 8012018:	d001      	beq.n	801201e <Sensor_IO_SPI_BlueNRG_Write+0x9e>
    set_irq_as_input();
 801201a:	f000 f8e1 	bl	80121e0 <set_irq_as_input>
  }
  
  if (header_slave[0] == 0x02) {
 801201e:	f89d 3114 	ldrb.w	r3, [sp, #276]	; 0x114
 8012022:	2b02      	cmp	r3, #2
 8012024:	d129      	bne.n	801207a <Sensor_IO_SPI_BlueNRG_Write+0xfa>
    /* SPI is ready */
    if (header_slave[1] >= (numbytes1+numbytes2)) {
 8012026:	f89d 3115 	ldrb.w	r3, [sp, #277]	; 0x115
 801202a:	461a      	mov	r2, r3
 801202c:	f10d 0303 	add.w	r3, sp, #3
 8012030:	7819      	ldrb	r1, [r3, #0]
 8012032:	f89d 3138 	ldrb.w	r3, [sp, #312]	; 0x138
 8012036:	440b      	add	r3, r1
 8012038:	429a      	cmp	r2, r3
 801203a:	db1a      	blt.n	8012072 <Sensor_IO_SPI_BlueNRG_Write+0xf2>
      
      /*  Buffer is big enough */	
      if (numbytes1 > 0) {
 801203c:	f10d 0303 	add.w	r3, sp, #3
 8012040:	781b      	ldrb	r3, [r3, #0]
 8012042:	2b00      	cmp	r3, #0
 8012044:	d008      	beq.n	8012058 <Sensor_IO_SPI_BlueNRG_Write+0xd8>
        spiStartExchange(spip, numbytes1, data1, read_char_buf);
 8012046:	f10d 0303 	add.w	r3, sp, #3
 801204a:	7819      	ldrb	r1, [r3, #0]
 801204c:	aa02      	add	r2, sp, #8
 801204e:	ab05      	add	r3, sp, #20
 8012050:	984a      	ldr	r0, [sp, #296]	; 0x128
 8012052:	6812      	ldr	r2, [r2, #0]
 8012054:	f7f4 fa7c 	bl	8006550 <spiStartExchange>
        /*__disable_irq();
        HAL_SPI_TransmitReceive(handle, data1, read_char_buf, numbytes1, TIMEOUT_DURATION);     // spiStartExchange( ... ) again 
        __enable_irq();
        */
      }
      if (numbytes2 > 0) {
 8012058:	f89d 3138 	ldrb.w	r3, [sp, #312]	; 0x138
 801205c:	2b00      	cmp	r3, #0
 801205e:	d00f      	beq.n	8012080 <Sensor_IO_SPI_BlueNRG_Write+0x100>
        spiStartExchange(spip, numbytes2, data2, read_char_buf);
 8012060:	f89d 1138 	ldrb.w	r1, [sp, #312]	; 0x138
 8012064:	aa01      	add	r2, sp, #4
 8012066:	ab05      	add	r3, sp, #20
 8012068:	984a      	ldr	r0, [sp, #296]	; 0x128
 801206a:	6812      	ldr	r2, [r2, #0]
 801206c:	f7f4 fa70 	bl	8006550 <spiStartExchange>
 8012070:	e006      	b.n	8012080 <Sensor_IO_SPI_BlueNRG_Write+0x100>
        */
      }
      
    } else {
      /* Buffer is too small */
      result = -2;
 8012072:	f06f 0301 	mvn.w	r3, #1
 8012076:	934b      	str	r3, [sp, #300]	; 0x12c
 8012078:	e002      	b.n	8012080 <Sensor_IO_SPI_BlueNRG_Write+0x100>
    }
  } else {
    /* SPI is not ready */
    result = -1;
 801207a:	f04f 33ff 	mov.w	r3, #4294967295
 801207e:	934b      	str	r3, [sp, #300]	; 0x12c
  }
  
  /* Release CS line */
  
  spiSelect(spip);
 8012080:	984a      	ldr	r0, [sp, #296]	; 0x128
 8012082:	f7f4 fa2d 	bl	80064e0 <spiSelect>
  //HAL_GPIO_WritePin(BNRG_SPI_CS_PORT, BNRG_SPI_CS_PIN, GPIO_PIN_SET);		// spiSelect( ... ); 
  
  // chSysUnlock();  
  Enable_SPI_IRQ();
 8012086:	f000 f8cb 	bl	8012220 <Enable_SPI_IRQ>

  spiReleaseBus(spip); 
 801208a:	984a      	ldr	r0, [sp, #296]	; 0x128
 801208c:	f7f4 fb30 	bl	80066f0 <spiReleaseBus>
  return result;
 8012090:	9b4b      	ldr	r3, [sp, #300]	; 0x12c
}
 8012092:	4618      	mov	r0, r3
 8012094:	b04c      	add	sp, #304	; 0x130
 8012096:	bd10      	pop	{r4, pc}
 8012098:	20001ac0 	.word	0x20001ac0
 801209c:	f3af 8000 	nop.w

080120a0 <Sensor_IO_SPI_BlueNRG_Read>:
* @param  buff_size: Buffer size
* @retval int32_t  : Number of read bytes
*/
int32_t Sensor_IO_SPI_BlueNRG_Read(SPIConfig *handle, uint8_t *buffer,
                             uint8_t buff_size)
{
 80120a0:	b500      	push	{lr}
 80120a2:	b08b      	sub	sp, #44	; 0x2c
 80120a4:	9003      	str	r0, [sp, #12]
 80120a6:	9102      	str	r1, [sp, #8]
 80120a8:	4613      	mov	r3, r2
 80120aa:	f88d 3007 	strb.w	r3, [sp, #7]
	SPIDriver *spip = (SPIDriver *) &SPID1;
 80120ae:	4b3f      	ldr	r3, [pc, #252]	; (80121ac <Sensor_IO_SPI_BlueNRG_Read+0x10c>)
 80120b0:	9308      	str	r3, [sp, #32]

  uint16_t byte_count;
  uint8_t len = 0;
 80120b2:	2300      	movs	r3, #0
 80120b4:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
  uint8_t char_ff = 0xff;
 80120b8:	23ff      	movs	r3, #255	; 0xff
 80120ba:	f88d 301f 	strb.w	r3, [sp, #31]
  volatile uint8_t read_char;
  
  uint8_t header_master[HEADER_SIZE] = {0x0b, 0x00, 0x00, 0x00, 0x00};
 80120be:	230b      	movs	r3, #11
 80120c0:	f88d 3018 	strb.w	r3, [sp, #24]
 80120c4:	2300      	movs	r3, #0
 80120c6:	f88d 3019 	strb.w	r3, [sp, #25]
 80120ca:	2300      	movs	r3, #0
 80120cc:	f88d 301a 	strb.w	r3, [sp, #26]
 80120d0:	2300      	movs	r3, #0
 80120d2:	f88d 301b 	strb.w	r3, [sp, #27]
 80120d6:	2300      	movs	r3, #0
 80120d8:	f88d 301c 	strb.w	r3, [sp, #28]
  uint8_t header_slave[HEADER_SIZE];
  
  /* CS reset */
  spiSelect(spip); 
 80120dc:	9808      	ldr	r0, [sp, #32]
 80120de:	f7f4 f9ff 	bl	80064e0 <spiSelect>
  //HAL_GPIO_WritePin(BNRG_SPI_CS_PORT, BNRG_SPI_CS_PIN, GPIO_PIN_RESET);
  spiAcquireBus(spip);
 80120e2:	9808      	ldr	r0, [sp, #32]
 80120e4:	f7f4 faf4 	bl	80066d0 <spiAcquireBus>
  spiStart(spip, handle);
 80120e8:	9808      	ldr	r0, [sp, #32]
 80120ea:	9903      	ldr	r1, [sp, #12]
 80120ec:	f7f4 f9d0 	bl	8006490 <spiStart>
  /* Read the header */  
  spiStartExchange(spip, HEADER_SIZE, header_master, header_slave); 
 80120f0:	aa06      	add	r2, sp, #24
 80120f2:	ab04      	add	r3, sp, #16
 80120f4:	9808      	ldr	r0, [sp, #32]
 80120f6:	2105      	movs	r1, #5
 80120f8:	f7f4 fa2a 	bl	8006550 <spiStartExchange>
  //HAL_SPI_TransmitReceive(handle, header_master, header_slave, HEADER_SIZE, TIMEOUT_DURATION);
  
  if (header_slave[0] == 0x02) {
 80120fc:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8012100:	2b02      	cmp	r3, #2
 8012102:	d138      	bne.n	8012176 <Sensor_IO_SPI_BlueNRG_Read+0xd6>
    /* device is ready */
    byte_count = (header_slave[4]<<8)|header_slave[3];
 8012104:	f89d 3014 	ldrb.w	r3, [sp, #20]
 8012108:	021b      	lsls	r3, r3, #8
 801210a:	b29a      	uxth	r2, r3
 801210c:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8012110:	4313      	orrs	r3, r2
 8012112:	b29b      	uxth	r3, r3
 8012114:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
    if (byte_count > 0) {
 8012118:	f8bd 3026 	ldrh.w	r3, [sp, #38]	; 0x26
 801211c:	2b00      	cmp	r3, #0
 801211e:	d02a      	beq.n	8012176 <Sensor_IO_SPI_BlueNRG_Read+0xd6>
      
      /* avoid to read more data that size of the buffer */
      if (byte_count > buff_size){
 8012120:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8012124:	b29b      	uxth	r3, r3
 8012126:	f8bd 2026 	ldrh.w	r2, [sp, #38]	; 0x26
 801212a:	429a      	cmp	r2, r3
 801212c:	d903      	bls.n	8012136 <Sensor_IO_SPI_BlueNRG_Read+0x96>
        byte_count = buff_size;
 801212e:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8012132:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
      }
      
      for (len = 0; len < byte_count; len++){
 8012136:	2300      	movs	r3, #0
 8012138:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
 801213c:	e014      	b.n	8012168 <Sensor_IO_SPI_BlueNRG_Read+0xc8>
        spiStartExchange(spip, 1, &char_ff, (uint8_t*)&read_char);
 801213e:	f10d 021f 	add.w	r2, sp, #31
 8012142:	f10d 031e 	add.w	r3, sp, #30
 8012146:	9808      	ldr	r0, [sp, #32]
 8012148:	2101      	movs	r1, #1
 801214a:	f7f4 fa01 	bl	8006550 <spiStartExchange>
        /*__disable_irq();
        HAL_SPI_TransmitReceive(handle, &char_ff, (uint8_t*)&read_char, 1, TIMEOUT_DURATION);
        __enable_irq();
        */buffer[len] = read_char;
 801214e:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
 8012152:	9a02      	ldr	r2, [sp, #8]
 8012154:	4413      	add	r3, r2
 8012156:	f89d 201e 	ldrb.w	r2, [sp, #30]
 801215a:	b2d2      	uxtb	r2, r2
 801215c:	701a      	strb	r2, [r3, #0]
      /* avoid to read more data that size of the buffer */
      if (byte_count > buff_size){
        byte_count = buff_size;
      }
      
      for (len = 0; len < byte_count; len++){
 801215e:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
 8012162:	3301      	adds	r3, #1
 8012164:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
 8012168:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
 801216c:	b29b      	uxth	r3, r3
 801216e:	f8bd 2026 	ldrh.w	r2, [sp, #38]	; 0x26
 8012172:	429a      	cmp	r2, r3
 8012174:	d8e3      	bhi.n	801213e <Sensor_IO_SPI_BlueNRG_Read+0x9e>
        */buffer[len] = read_char;
      }
    }    
  }
  /* Release CS line */
  spiUnselect(spip);
 8012176:	9808      	ldr	r0, [sp, #32]
 8012178:	f7f4 f9c2 	bl	8006500 <spiUnselect>
  //HAL_GPIO_WritePin(BNRG_SPI_CS_PORT, BNRG_SPI_CS_PIN, GPIO_PIN_SET);
  
  spiReleaseBus(spip);
 801217c:	9808      	ldr	r0, [sp, #32]
 801217e:	f7f4 fab7 	bl	80066f0 <spiReleaseBus>

  // Add a small delay to give time to the BlueNRG to set the IRQ pin low
  // to avoid a useless SPI read at the end of the transaction
  for( i = 0; i < 2; i++)__NOP();
 8012182:	4b0b      	ldr	r3, [pc, #44]	; (80121b0 <Sensor_IO_SPI_BlueNRG_Read+0x110>)
 8012184:	2200      	movs	r2, #0
 8012186:	601a      	str	r2, [r3, #0]
 8012188:	e005      	b.n	8012196 <Sensor_IO_SPI_BlueNRG_Read+0xf6>

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 801218a:	bf00      	nop
 801218c:	4b08      	ldr	r3, [pc, #32]	; (80121b0 <Sensor_IO_SPI_BlueNRG_Read+0x110>)
 801218e:	681b      	ldr	r3, [r3, #0]
 8012190:	1c5a      	adds	r2, r3, #1
 8012192:	4b07      	ldr	r3, [pc, #28]	; (80121b0 <Sensor_IO_SPI_BlueNRG_Read+0x110>)
 8012194:	601a      	str	r2, [r3, #0]
 8012196:	4b06      	ldr	r3, [pc, #24]	; (80121b0 <Sensor_IO_SPI_BlueNRG_Read+0x110>)
 8012198:	681b      	ldr	r3, [r3, #0]
 801219a:	2b01      	cmp	r3, #1
 801219c:	ddf5      	ble.n	801218a <Sensor_IO_SPI_BlueNRG_Read+0xea>
    }
    PRINT_CSV("\n");
  }
#endif
  
  return len;   
 801219e:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
}
 80121a2:	4618      	mov	r0, r3
 80121a4:	b00b      	add	sp, #44	; 0x2c
 80121a6:	f85d fb04 	ldr.w	pc, [sp], #4
 80121aa:	bf00      	nop
 80121ac:	20001ac0 	.word	0x20001ac0
 80121b0:	20002224 	.word	0x20002224
 80121b4:	f3af 8000 	nop.w
 80121b8:	f3af 8000 	nop.w
 80121bc:	f3af 8000 	nop.w

080121c0 <set_irq_as_output>:

void set_irq_as_output(void)
{
 80121c0:	b508      	push	{r3, lr}
  	
	palSetPadMode(GPIOA, 0, PAL_MODE_OUTPUT_PUSHPULL);
 80121c2:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80121c6:	2101      	movs	r1, #1
 80121c8:	2201      	movs	r2, #1
 80121ca:	f7f5 ff81 	bl	80080d0 <_pal_lld_setgroupmode>
	palSetPad(GPIOA, 0);
 80121ce:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 80121d2:	2201      	movs	r2, #1
 80121d4:	831a      	strh	r2, [r3, #24]
  GPIO_InitStructure.Speed = BNRG_SPI_IRQ_SPEED;
  GPIO_InitStructure.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(BNRG_SPI_IRQ_PORT, &GPIO_InitStructure);
  HAL_GPIO_WritePin(BNRG_SPI_IRQ_PORT, BNRG_SPI_IRQ_PIN, GPIO_PIN_SET);
*/
}
 80121d6:	bd08      	pop	{r3, pc}
 80121d8:	f3af 8000 	nop.w
 80121dc:	f3af 8000 	nop.w

080121e0 <set_irq_as_input>:
* @brief  Set the IRQ in input mode.
* @param  None
* @retval None
*/
void set_irq_as_input(void)
{
 80121e0:	b508      	push	{r3, lr}
  
  
	// sets the mode to pulldown, and the alternate function to 0
	
  palSetPadMode(GPIOA, 0, (PAL_MODE_INPUT_PULLDOWN | PAL_MODE_ALTERNATE(0)));
 80121e2:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80121e6:	2101      	movs	r1, #1
 80121e8:	2242      	movs	r2, #66	; 0x42
 80121ea:	f7f5 ff71 	bl	80080d0 <_pal_lld_setgroupmode>
  HAL_GPIO_Init(BNRG_SPI_IRQ_PORT, &GPIO_InitStructure);
  
  GPIO_InitStructure.Pull = BNRG_SPI_IRQ_PULL;
  HAL_GPIO_Init(BNRG_SPI_IRQ_PORT, &GPIO_InitStructure);
*/
}
 80121ee:	bd08      	pop	{r3, pc}

080121f0 <us150Delay>:
#if SYSCLK_FREQ == 4000000
  for( i = 0; i < 35; i++)__NOP();
#elif SYSCLK_FREQ == 32000000
  for( i = 0; i < 420; i++)__NOP();
#elif SYSCLK_FREQ == 80000000
  for( i = 0; i < 1072; i++)__NOP();
 80121f0:	4b07      	ldr	r3, [pc, #28]	; (8012210 <us150Delay+0x20>)
 80121f2:	2200      	movs	r2, #0
 80121f4:	601a      	str	r2, [r3, #0]
 80121f6:	e005      	b.n	8012204 <us150Delay+0x14>
 80121f8:	bf00      	nop
 80121fa:	4b05      	ldr	r3, [pc, #20]	; (8012210 <us150Delay+0x20>)
 80121fc:	681b      	ldr	r3, [r3, #0]
 80121fe:	1c5a      	adds	r2, r3, #1
 8012200:	4b03      	ldr	r3, [pc, #12]	; (8012210 <us150Delay+0x20>)
 8012202:	601a      	str	r2, [r3, #0]
 8012204:	4b02      	ldr	r3, [pc, #8]	; (8012210 <us150Delay+0x20>)
 8012206:	681b      	ldr	r3, [r3, #0]
 8012208:	f5b3 6f86 	cmp.w	r3, #1072	; 0x430
 801220c:	dbf4      	blt.n	80121f8 <us150Delay+0x8>
#elif SYSCLK_FREQ == 168000000
  for( i = 0; i < 2250; i++)__NOP();
#else
#error Implement delay function.
#endif    
}
 801220e:	4770      	bx	lr
 8012210:	20002224 	.word	0x20002224
 8012214:	f3af 8000 	nop.w
 8012218:	f3af 8000 	nop.w
 801221c:	f3af 8000 	nop.w

08012220 <Enable_SPI_IRQ>:
* @brief  Enable SPI IRQ.
* @param  None
* @retval None
*/
void Enable_SPI_IRQ(void)
{
 8012220:	b508      	push	{r3, lr}
  NVIC_EnableIRQ(BNRG_SPI_EXTI_IRQn);  
 8012222:	2017      	movs	r0, #23
 8012224:	f7ff fd74 	bl	8011d10 <NVIC_EnableIRQ>
}
 8012228:	bd08      	pop	{r3, pc}
 801222a:	bf00      	nop
 801222c:	f3af 8000 	nop.w

08012230 <Disable_SPI_IRQ>:
* @brief  Disable SPI IRQ.
* @param  None
* @retval None
*/
void Disable_SPI_IRQ(void)
{ 
 8012230:	b508      	push	{r3, lr}
  NVIC_DisableIRQ(BNRG_SPI_EXTI_IRQn);
 8012232:	2017      	movs	r0, #23
 8012234:	f7ff fd84 	bl	8011d40 <NVIC_DisableIRQ>
}
 8012238:	bd08      	pop	{r3, pc}
 801223a:	bf00      	nop
 801223c:	f3af 8000 	nop.w

08012240 <Clear_SPI_IRQ>:
* @brief  Clear Pending SPI IRQ.
* @param  None
* @retval None
*/
void Clear_SPI_IRQ(void)
{
 8012240:	b508      	push	{r3, lr}
  NVIC_ClearPendingIRQ(BNRG_SPI_EXTI_IRQn);
 8012242:	2017      	movs	r0, #23
 8012244:	f7ff fd94 	bl	8011d70 <NVIC_ClearPendingIRQ>
}
 8012248:	bd08      	pop	{r3, pc}
 801224a:	bf00      	nop
 801224c:	f3af 8000 	nop.w

08012250 <Clear_SPI_EXTI_Flag>:
//#define __GPIO_EXT1_CLEAR_IT(__EXTI_LINE__) (EXTI->PR = (__EXTI_LINE__))

void Clear_SPI_EXTI_Flag(void)
{  
  // _GPIO_EXTI_CLEAR_IT(BNRG_SPI_EXTI_PIN);  
}
 8012250:	4770      	bx	lr
 8012252:	bf00      	nop
 8012254:	f3af 8000 	nop.w
 8012258:	f3af 8000 	nop.w
 801225c:	f3af 8000 	nop.w

08012260 <LSM303AGR_ACC_Init>:
/************** Generic Function  *******************/


/* Enable 3 wire SPI mode on the LSM303AGR */

status_t LSM303AGR_ACC_Init(void) {
 8012260:	b500      	push	{lr}
 8012262:	b083      	sub	sp, #12
  uint8_t value = LSM303AGR_ACC_SIM_3_WIRES;  
 8012264:	2301      	movs	r3, #1
 8012266:	f88d 3007 	strb.w	r3, [sp, #7]
  uint8_t Reg1_val = 0x27;
 801226a:	2327      	movs	r3, #39	; 0x27
 801226c:	f88d 3006 	strb.w	r3, [sp, #6]
  LSM303AGR_ACC_WriteReg(NULL,LSM303AGR_ACC_CTRL_REG1,&Reg1_val,1);
 8012270:	f10d 0306 	add.w	r3, sp, #6
 8012274:	2000      	movs	r0, #0
 8012276:	2120      	movs	r1, #32
 8012278:	461a      	mov	r2, r3
 801227a:	2301      	movs	r3, #1
 801227c:	f000 f830 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
  LSM303AGR_ACC_WriteReg(NULL,LSM303AGR_ACC_CTRL_REG4,&value,1);
 8012280:	f10d 0307 	add.w	r3, sp, #7
 8012284:	2000      	movs	r0, #0
 8012286:	2123      	movs	r1, #35	; 0x23
 8012288:	461a      	mov	r2, r3
 801228a:	2301      	movs	r3, #1
 801228c:	f000 f828 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
  return MEMS_SUCCESS;
 8012290:	2301      	movs	r3, #1
}
 8012292:	4618      	mov	r0, r3
 8012294:	b003      	add	sp, #12
 8012296:	f85d fb04 	ldr.w	pc, [sp], #4
 801229a:	bf00      	nop
 801229c:	f3af 8000 	nop.w

080122a0 <LSM303AGR_ACC_HR_Init>:
 
status_t LSM303AGR_ACC_HR_Init(void) {
 80122a0:	b500      	push	{lr}
 80122a2:	b083      	sub	sp, #12
  uint8_t value = 0x09;  
 80122a4:	2309      	movs	r3, #9
 80122a6:	f88d 3007 	strb.w	r3, [sp, #7]
  uint8_t Reg1_val = 0x27;
 80122aa:	2327      	movs	r3, #39	; 0x27
 80122ac:	f88d 3006 	strb.w	r3, [sp, #6]
  LSM303AGR_ACC_WriteReg(NULL,LSM303AGR_ACC_CTRL_REG1,&Reg1_val,1);
 80122b0:	f10d 0306 	add.w	r3, sp, #6
 80122b4:	2000      	movs	r0, #0
 80122b6:	2120      	movs	r1, #32
 80122b8:	461a      	mov	r2, r3
 80122ba:	2301      	movs	r3, #1
 80122bc:	f000 f810 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
  LSM303AGR_ACC_WriteReg(NULL,LSM303AGR_ACC_CTRL_REG4,&value,1);
 80122c0:	f10d 0307 	add.w	r3, sp, #7
 80122c4:	2000      	movs	r0, #0
 80122c6:	2123      	movs	r1, #35	; 0x23
 80122c8:	461a      	mov	r2, r3
 80122ca:	2301      	movs	r3, #1
 80122cc:	f000 f808 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
  return MEMS_SUCCESS;
 80122d0:	2301      	movs	r3, #1
}
 80122d2:	4618      	mov	r0, r3
 80122d4:	b003      	add	sp, #12
 80122d6:	f85d fb04 	ldr.w	pc, [sp], #4
 80122da:	bf00      	nop
 80122dc:	f3af 8000 	nop.w

080122e0 <LSM303AGR_ACC_WriteReg>:
* Input       : Register Address, ptr to buffer to be written,
*                                 length of buffer
* Output      : None
* Return      : None
*******************************************************************************/
status_t LSM303AGR_ACC_WriteReg(void *handle, u8_t Reg, u8_t *Bufp, u16_t len) {
 80122e0:	b500      	push	{lr}
 80122e2:	b085      	sub	sp, #20
 80122e4:	9003      	str	r0, [sp, #12]
 80122e6:	9201      	str	r2, [sp, #4]
 80122e8:	460a      	mov	r2, r1
 80122ea:	f88d 200b 	strb.w	r2, [sp, #11]
 80122ee:	f8ad 3008 	strh.w	r3, [sp, #8]
  UNUSED(handle);
  if (Sensor_IO_SPI_Write(&lsm303ad_accel_cfg, Reg, Bufp, len))
 80122f2:	f89d 200b 	ldrb.w	r2, [sp, #11]
 80122f6:	f8bd 3008 	ldrh.w	r3, [sp, #8]
 80122fa:	4807      	ldr	r0, [pc, #28]	; (8012318 <LSM303AGR_ACC_WriteReg+0x38>)
 80122fc:	4611      	mov	r1, r2
 80122fe:	9a01      	ldr	r2, [sp, #4]
 8012300:	f7ff fd4e 	bl	8011da0 <Sensor_IO_SPI_Write>
 8012304:	4603      	mov	r3, r0
 8012306:	2b00      	cmp	r3, #0
 8012308:	d001      	beq.n	801230e <LSM303AGR_ACC_WriteReg+0x2e>
  {
    return MEMS_ERROR;
 801230a:	2300      	movs	r3, #0
 801230c:	e000      	b.n	8012310 <LSM303AGR_ACC_WriteReg+0x30>
  }
  else
  {
    return MEMS_SUCCESS;
 801230e:	2301      	movs	r3, #1
  }
}
 8012310:	4618      	mov	r0, r3
 8012312:	b005      	add	sp, #20
 8012314:	f85d fb04 	ldr.w	pc, [sp], #4
 8012318:	200008f0 	.word	0x200008f0
 801231c:	f3af 8000 	nop.w

08012320 <LSM303AGR_ACC_ReadReg>:
* Input       : Register Address, ptr to buffer to be read,
*                                 length of buffer
* Output      : None
* Return      : None
*******************************************************************************/
status_t LSM303AGR_ACC_ReadReg(void *handle, u8_t Reg, u8_t *Bufp, u16_t len) {
 8012320:	b500      	push	{lr}
 8012322:	b085      	sub	sp, #20
 8012324:	9003      	str	r0, [sp, #12]
 8012326:	9201      	str	r2, [sp, #4]
 8012328:	460a      	mov	r2, r1
 801232a:	f88d 200b 	strb.w	r2, [sp, #11]
 801232e:	f8ad 3008 	strh.w	r3, [sp, #8]
  UNUSED(handle);
  if (Sensor_IO_SPI_Read(&lsm303ad_accel_cfg, Reg, Bufp, len))
 8012332:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8012336:	f8bd 3008 	ldrh.w	r3, [sp, #8]
 801233a:	4807      	ldr	r0, [pc, #28]	; (8012358 <LSM303AGR_ACC_ReadReg+0x38>)
 801233c:	4611      	mov	r1, r2
 801233e:	9a01      	ldr	r2, [sp, #4]
 8012340:	f7ff fda6 	bl	8011e90 <Sensor_IO_SPI_Read>
 8012344:	4603      	mov	r3, r0
 8012346:	2b00      	cmp	r3, #0
 8012348:	d001      	beq.n	801234e <LSM303AGR_ACC_ReadReg+0x2e>
  {
    return MEMS_ERROR;
 801234a:	2300      	movs	r3, #0
 801234c:	e000      	b.n	8012350 <LSM303AGR_ACC_ReadReg+0x30>
  }
  else
  {
    return MEMS_SUCCESS;
 801234e:	2301      	movs	r3, #1
  }
}
 8012350:	4618      	mov	r0, r3
 8012352:	b005      	add	sp, #20
 8012354:	f85d fb04 	ldr.w	pc, [sp], #4
 8012358:	200008f0 	.word	0x200008f0
 801235c:	f3af 8000 	nop.w

08012360 <LSM303AGR_ACC_R_WHO_AM_I>:
* Input          : Pointer to u8_t
* Output         : Status of WHO_AM_I
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_WHO_AM_I(void *handle, u8_t *value)
{
 8012360:	b500      	push	{lr}
 8012362:	b083      	sub	sp, #12
 8012364:	9001      	str	r0, [sp, #4]
 8012366:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_WHO_AM_I_REG, value, 1) )
 8012368:	9801      	ldr	r0, [sp, #4]
 801236a:	210f      	movs	r1, #15
 801236c:	9a00      	ldr	r2, [sp, #0]
 801236e:	2301      	movs	r3, #1
 8012370:	f7ff ffd6 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8012374:	4603      	mov	r3, r0
 8012376:	2b00      	cmp	r3, #0
 8012378:	d101      	bne.n	801237e <LSM303AGR_ACC_R_WHO_AM_I+0x1e>
    return MEMS_ERROR;
 801237a:	2300      	movs	r3, #0
 801237c:	e000      	b.n	8012380 <LSM303AGR_ACC_R_WHO_AM_I+0x20>

  /* *value &= LSM303AGR_ACC_WHO_AM_I_MASK; //coerce */
  /* *value = *value >> LSM303AGR_ACC_WHO_AM_I_POSITION; //mask */

  return MEMS_SUCCESS;
 801237e:	2301      	movs	r3, #1
}
 8012380:	4618      	mov	r0, r3
 8012382:	b003      	add	sp, #12
 8012384:	f85d fb04 	ldr.w	pc, [sp], #4
 8012388:	f3af 8000 	nop.w
 801238c:	f3af 8000 	nop.w

08012390 <LSM303AGR_ACC_W_BlockDataUpdate>:
* Input          : LSM303AGR_ACC_BDU_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_BlockDataUpdate(void *handle, LSM303AGR_ACC_BDU_t newValue)
{
 8012390:	b500      	push	{lr}
 8012392:	b085      	sub	sp, #20
 8012394:	9001      	str	r0, [sp, #4]
 8012396:	460b      	mov	r3, r1
 8012398:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 801239c:	f10d 030f 	add.w	r3, sp, #15
 80123a0:	9801      	ldr	r0, [sp, #4]
 80123a2:	2123      	movs	r1, #35	; 0x23
 80123a4:	461a      	mov	r2, r3
 80123a6:	2301      	movs	r3, #1
 80123a8:	f7ff ffba 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80123ac:	4603      	mov	r3, r0
 80123ae:	2b00      	cmp	r3, #0
 80123b0:	d101      	bne.n	80123b6 <LSM303AGR_ACC_W_BlockDataUpdate+0x26>
    return MEMS_ERROR;
 80123b2:	2300      	movs	r3, #0
 80123b4:	e01c      	b.n	80123f0 <LSM303AGR_ACC_W_BlockDataUpdate+0x60>

  value &= ~LSM303AGR_ACC_BDU_MASK;
 80123b6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80123ba:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80123be:	b2db      	uxtb	r3, r3
 80123c0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80123c4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80123c8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80123cc:	4313      	orrs	r3, r2
 80123ce:	b2db      	uxtb	r3, r3
 80123d0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 80123d4:	f10d 030f 	add.w	r3, sp, #15
 80123d8:	9801      	ldr	r0, [sp, #4]
 80123da:	2123      	movs	r1, #35	; 0x23
 80123dc:	461a      	mov	r2, r3
 80123de:	2301      	movs	r3, #1
 80123e0:	f7ff ff7e 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 80123e4:	4603      	mov	r3, r0
 80123e6:	2b00      	cmp	r3, #0
 80123e8:	d101      	bne.n	80123ee <LSM303AGR_ACC_W_BlockDataUpdate+0x5e>
    return MEMS_ERROR;
 80123ea:	2300      	movs	r3, #0
 80123ec:	e000      	b.n	80123f0 <LSM303AGR_ACC_W_BlockDataUpdate+0x60>

  return MEMS_SUCCESS;
 80123ee:	2301      	movs	r3, #1
}
 80123f0:	4618      	mov	r0, r3
 80123f2:	b005      	add	sp, #20
 80123f4:	f85d fb04 	ldr.w	pc, [sp], #4
 80123f8:	f3af 8000 	nop.w
 80123fc:	f3af 8000 	nop.w

08012400 <LSM303AGR_ACC_R_BlockDataUpdate>:
* Input          : Pointer to LSM303AGR_ACC_BDU_t
* Output         : Status of BDU see LSM303AGR_ACC_BDU_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_BlockDataUpdate(void *handle, LSM303AGR_ACC_BDU_t *value)
{
 8012400:	b500      	push	{lr}
 8012402:	b083      	sub	sp, #12
 8012404:	9001      	str	r0, [sp, #4]
 8012406:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
 8012408:	9801      	ldr	r0, [sp, #4]
 801240a:	2123      	movs	r1, #35	; 0x23
 801240c:	9a00      	ldr	r2, [sp, #0]
 801240e:	2301      	movs	r3, #1
 8012410:	f7ff ff86 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8012414:	4603      	mov	r3, r0
 8012416:	2b00      	cmp	r3, #0
 8012418:	d101      	bne.n	801241e <LSM303AGR_ACC_R_BlockDataUpdate+0x1e>
    return MEMS_ERROR;
 801241a:	2300      	movs	r3, #0
 801241c:	e007      	b.n	801242e <LSM303AGR_ACC_R_BlockDataUpdate+0x2e>

  *value &= LSM303AGR_ACC_BDU_MASK; //mask
 801241e:	9b00      	ldr	r3, [sp, #0]
 8012420:	781b      	ldrb	r3, [r3, #0]
 8012422:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8012426:	b2da      	uxtb	r2, r3
 8012428:	9b00      	ldr	r3, [sp, #0]
 801242a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801242c:	2301      	movs	r3, #1
}
 801242e:	4618      	mov	r0, r3
 8012430:	b003      	add	sp, #12
 8012432:	f85d fb04 	ldr.w	pc, [sp], #4
 8012436:	bf00      	nop
 8012438:	f3af 8000 	nop.w
 801243c:	f3af 8000 	nop.w

08012440 <LSM303AGR_ACC_W_FullScale>:
* Input          : LSM303AGR_ACC_FS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FullScale(void *handle, LSM303AGR_ACC_FS_t newValue)
{
 8012440:	b500      	push	{lr}
 8012442:	b085      	sub	sp, #20
 8012444:	9001      	str	r0, [sp, #4]
 8012446:	460b      	mov	r3, r1
 8012448:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 801244c:	f10d 030f 	add.w	r3, sp, #15
 8012450:	9801      	ldr	r0, [sp, #4]
 8012452:	2123      	movs	r1, #35	; 0x23
 8012454:	461a      	mov	r2, r3
 8012456:	2301      	movs	r3, #1
 8012458:	f7ff ff62 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 801245c:	4603      	mov	r3, r0
 801245e:	2b00      	cmp	r3, #0
 8012460:	d101      	bne.n	8012466 <LSM303AGR_ACC_W_FullScale+0x26>
    return MEMS_ERROR;
 8012462:	2300      	movs	r3, #0
 8012464:	e01c      	b.n	80124a0 <LSM303AGR_ACC_W_FullScale+0x60>

  value &= ~LSM303AGR_ACC_FS_MASK;
 8012466:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801246a:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 801246e:	b2db      	uxtb	r3, r3
 8012470:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012474:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012478:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801247c:	4313      	orrs	r3, r2
 801247e:	b2db      	uxtb	r3, r3
 8012480:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 8012484:	f10d 030f 	add.w	r3, sp, #15
 8012488:	9801      	ldr	r0, [sp, #4]
 801248a:	2123      	movs	r1, #35	; 0x23
 801248c:	461a      	mov	r2, r3
 801248e:	2301      	movs	r3, #1
 8012490:	f7ff ff26 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8012494:	4603      	mov	r3, r0
 8012496:	2b00      	cmp	r3, #0
 8012498:	d101      	bne.n	801249e <LSM303AGR_ACC_W_FullScale+0x5e>
    return MEMS_ERROR;
 801249a:	2300      	movs	r3, #0
 801249c:	e000      	b.n	80124a0 <LSM303AGR_ACC_W_FullScale+0x60>

  return MEMS_SUCCESS;
 801249e:	2301      	movs	r3, #1
}
 80124a0:	4618      	mov	r0, r3
 80124a2:	b005      	add	sp, #20
 80124a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80124a8:	f3af 8000 	nop.w
 80124ac:	f3af 8000 	nop.w

080124b0 <LSM303AGR_ACC_R_FullScale>:
* Input          : Pointer to LSM303AGR_ACC_FS_t
* Output         : Status of FS see LSM303AGR_ACC_FS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FullScale(void *handle, LSM303AGR_ACC_FS_t *value)
{
 80124b0:	b500      	push	{lr}
 80124b2:	b083      	sub	sp, #12
 80124b4:	9001      	str	r0, [sp, #4]
 80124b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
 80124b8:	9801      	ldr	r0, [sp, #4]
 80124ba:	2123      	movs	r1, #35	; 0x23
 80124bc:	9a00      	ldr	r2, [sp, #0]
 80124be:	2301      	movs	r3, #1
 80124c0:	f7ff ff2e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80124c4:	4603      	mov	r3, r0
 80124c6:	2b00      	cmp	r3, #0
 80124c8:	d101      	bne.n	80124ce <LSM303AGR_ACC_R_FullScale+0x1e>
    return MEMS_ERROR;
 80124ca:	2300      	movs	r3, #0
 80124cc:	e007      	b.n	80124de <LSM303AGR_ACC_R_FullScale+0x2e>

  *value &= LSM303AGR_ACC_FS_MASK; //mask
 80124ce:	9b00      	ldr	r3, [sp, #0]
 80124d0:	781b      	ldrb	r3, [r3, #0]
 80124d2:	f003 0330 	and.w	r3, r3, #48	; 0x30
 80124d6:	b2da      	uxtb	r2, r3
 80124d8:	9b00      	ldr	r3, [sp, #0]
 80124da:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80124dc:	2301      	movs	r3, #1
}
 80124de:	4618      	mov	r0, r3
 80124e0:	b003      	add	sp, #12
 80124e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80124e6:	bf00      	nop
 80124e8:	f3af 8000 	nop.w
 80124ec:	f3af 8000 	nop.w

080124f0 <LSM303AGR_ACC_Get_Raw_Acceleration>:
* Input          : pointer to [u8_t]
* Output         : Acceleration buffer u8_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_Get_Raw_Acceleration(void *handle, u8_t *buff)
{
 80124f0:	b500      	push	{lr}
 80124f2:	b083      	sub	sp, #12
 80124f4:	9001      	str	r0, [sp, #4]
 80124f6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_OUT_X_L, buff, 6 ) )
 80124f8:	9801      	ldr	r0, [sp, #4]
 80124fa:	2128      	movs	r1, #40	; 0x28
 80124fc:	9a00      	ldr	r2, [sp, #0]
 80124fe:	2306      	movs	r3, #6
 8012500:	f7ff ff0e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8012504:	4603      	mov	r3, r0
 8012506:	2b00      	cmp	r3, #0
 8012508:	d101      	bne.n	801250e <LSM303AGR_ACC_Get_Raw_Acceleration+0x1e>
    return MEMS_ERROR;
 801250a:	2300      	movs	r3, #0
 801250c:	e000      	b.n	8012510 <LSM303AGR_ACC_Get_Raw_Acceleration+0x20>

  return MEMS_SUCCESS;
 801250e:	2301      	movs	r3, #1
}
 8012510:	4618      	mov	r0, r3
 8012512:	b003      	add	sp, #12
 8012514:	f85d fb04 	ldr.w	pc, [sp], #4
 8012518:	f3af 8000 	nop.w
 801251c:	f3af 8000 	nop.w

08012520 <LSM303AGR_ACC_Get_Acceleration>:
    62520,  /* FS @8g */
    187580, /* FS @16g */
  },
};
status_t LSM303AGR_ACC_Get_Acceleration(void *handle, int *buff)
{
 8012520:	b570      	push	{r4, r5, r6, lr}
 8012522:	b086      	sub	sp, #24
 8012524:	9001      	str	r0, [sp, #4]
 8012526:	9100      	str	r1, [sp, #0]
  Type3Axis16bit_U raw_data_tmp;
  u8_t op_mode = 0, fs_mode = 0, shift = 0;
 8012528:	2300      	movs	r3, #0
 801252a:	f88d 3017 	strb.w	r3, [sp, #23]
 801252e:	2300      	movs	r3, #0
 8012530:	f88d 3016 	strb.w	r3, [sp, #22]
 8012534:	2300      	movs	r3, #0
 8012536:	f88d 3015 	strb.w	r3, [sp, #21]
  LSM303AGR_ACC_LPEN_t lp;
  LSM303AGR_ACC_HR_t hr;
  LSM303AGR_ACC_FS_t fs;

  /* Determine which operational mode the acc is set */
  LSM303AGR_ACC_R_HiRes(handle, &hr);
 801253a:	f10d 030a 	add.w	r3, sp, #10
 801253e:	9801      	ldr	r0, [sp, #4]
 8012540:	4619      	mov	r1, r3
 8012542:	f001 f9dd 	bl	8013900 <LSM303AGR_ACC_R_HiRes>
  LSM303AGR_ACC_R_LOWPWR_EN(handle, &lp);
 8012546:	f10d 030b 	add.w	r3, sp, #11
 801254a:	9801      	ldr	r0, [sp, #4]
 801254c:	4619      	mov	r1, r3
 801254e:	f000 fc57 	bl	8012e00 <LSM303AGR_ACC_R_LOWPWR_EN>

  if (lp == LSM303AGR_ACC_LPEN_ENABLED && hr == LSM303AGR_ACC_HR_DISABLED)
 8012552:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8012556:	2b08      	cmp	r3, #8
 8012558:	d10a      	bne.n	8012570 <LSM303AGR_ACC_Get_Acceleration+0x50>
 801255a:	f89d 300a 	ldrb.w	r3, [sp, #10]
 801255e:	2b00      	cmp	r3, #0
 8012560:	d106      	bne.n	8012570 <LSM303AGR_ACC_Get_Acceleration+0x50>
  {
    /* op mode is LP 8-bit */
    op_mode = 2;
 8012562:	2302      	movs	r3, #2
 8012564:	f88d 3017 	strb.w	r3, [sp, #23]
    shift = 8;
 8012568:	2308      	movs	r3, #8
 801256a:	f88d 3015 	strb.w	r3, [sp, #21]
 801256e:	e01f      	b.n	80125b0 <LSM303AGR_ACC_Get_Acceleration+0x90>
  }
  else if (lp == LSM303AGR_ACC_LPEN_DISABLED && hr == LSM303AGR_ACC_HR_DISABLED)
 8012570:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8012574:	2b00      	cmp	r3, #0
 8012576:	d10a      	bne.n	801258e <LSM303AGR_ACC_Get_Acceleration+0x6e>
 8012578:	f89d 300a 	ldrb.w	r3, [sp, #10]
 801257c:	2b00      	cmp	r3, #0
 801257e:	d106      	bne.n	801258e <LSM303AGR_ACC_Get_Acceleration+0x6e>
  {
    /* op mode is Normal 10-bit */
    op_mode = 1;
 8012580:	2301      	movs	r3, #1
 8012582:	f88d 3017 	strb.w	r3, [sp, #23]
    shift = 6;
 8012586:	2306      	movs	r3, #6
 8012588:	f88d 3015 	strb.w	r3, [sp, #21]
 801258c:	e010      	b.n	80125b0 <LSM303AGR_ACC_Get_Acceleration+0x90>
  }
  else if (lp == LSM303AGR_ACC_LPEN_DISABLED && hr == LSM303AGR_ACC_HR_ENABLED)
 801258e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8012592:	2b00      	cmp	r3, #0
 8012594:	d10a      	bne.n	80125ac <LSM303AGR_ACC_Get_Acceleration+0x8c>
 8012596:	f89d 300a 	ldrb.w	r3, [sp, #10]
 801259a:	2b08      	cmp	r3, #8
 801259c:	d106      	bne.n	80125ac <LSM303AGR_ACC_Get_Acceleration+0x8c>
  {
    /* op mode is HR 12-bit */
    op_mode = 0;
 801259e:	2300      	movs	r3, #0
 80125a0:	f88d 3017 	strb.w	r3, [sp, #23]
    shift = 4;
 80125a4:	2304      	movs	r3, #4
 80125a6:	f88d 3015 	strb.w	r3, [sp, #21]
 80125aa:	e001      	b.n	80125b0 <LSM303AGR_ACC_Get_Acceleration+0x90>
  }
  else
    return MEMS_ERROR;
 80125ac:	2300      	movs	r3, #0
 80125ae:	e0b8      	b.n	8012722 <LSM303AGR_ACC_Get_Acceleration+0x202>

  /* Determine the Full Scale the acc is set */
  LSM303AGR_ACC_R_FullScale(handle, &fs);
 80125b0:	f10d 0309 	add.w	r3, sp, #9
 80125b4:	9801      	ldr	r0, [sp, #4]
 80125b6:	4619      	mov	r1, r3
 80125b8:	f7ff ff7a 	bl	80124b0 <LSM303AGR_ACC_R_FullScale>
  switch (fs)
 80125bc:	f89d 3009 	ldrb.w	r3, [sp, #9]
 80125c0:	2b10      	cmp	r3, #16
 80125c2:	d00d      	beq.n	80125e0 <LSM303AGR_ACC_Get_Acceleration+0xc0>
 80125c4:	2b10      	cmp	r3, #16
 80125c6:	dc02      	bgt.n	80125ce <LSM303AGR_ACC_Get_Acceleration+0xae>
 80125c8:	2b00      	cmp	r3, #0
 80125ca:	d005      	beq.n	80125d8 <LSM303AGR_ACC_Get_Acceleration+0xb8>
 80125cc:	e014      	b.n	80125f8 <LSM303AGR_ACC_Get_Acceleration+0xd8>
 80125ce:	2b20      	cmp	r3, #32
 80125d0:	d00a      	beq.n	80125e8 <LSM303AGR_ACC_Get_Acceleration+0xc8>
 80125d2:	2b30      	cmp	r3, #48	; 0x30
 80125d4:	d00c      	beq.n	80125f0 <LSM303AGR_ACC_Get_Acceleration+0xd0>
 80125d6:	e00f      	b.n	80125f8 <LSM303AGR_ACC_Get_Acceleration+0xd8>
  {
    case LSM303AGR_ACC_FS_2G:
      fs_mode = 0;
 80125d8:	2300      	movs	r3, #0
 80125da:	f88d 3016 	strb.w	r3, [sp, #22]
      break;
 80125de:	e00b      	b.n	80125f8 <LSM303AGR_ACC_Get_Acceleration+0xd8>

    case LSM303AGR_ACC_FS_4G:
      fs_mode = 1;
 80125e0:	2301      	movs	r3, #1
 80125e2:	f88d 3016 	strb.w	r3, [sp, #22]
      break;
 80125e6:	e007      	b.n	80125f8 <LSM303AGR_ACC_Get_Acceleration+0xd8>

    case LSM303AGR_ACC_FS_8G:
      fs_mode = 2;
 80125e8:	2302      	movs	r3, #2
 80125ea:	f88d 3016 	strb.w	r3, [sp, #22]
      break;
 80125ee:	e003      	b.n	80125f8 <LSM303AGR_ACC_Get_Acceleration+0xd8>

    case LSM303AGR_ACC_FS_16G:
      fs_mode = 3;
 80125f0:	2303      	movs	r3, #3
 80125f2:	f88d 3016 	strb.w	r3, [sp, #22]
      break;
 80125f6:	bf00      	nop
  }

  /* Read out raw accelerometer samples */
  LSM303AGR_ACC_Get_Raw_Acceleration(handle, raw_data_tmp.u8bit);
 80125f8:	ab03      	add	r3, sp, #12
 80125fa:	9801      	ldr	r0, [sp, #4]
 80125fc:	4619      	mov	r1, r3
 80125fe:	f7ff ff77 	bl	80124f0 <LSM303AGR_ACC_Get_Raw_Acceleration>

  /* Apply proper shift and sensitivity */
  buff[0] = ((raw_data_tmp.i16bit[0] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 8012602:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 8012606:	b21a      	sxth	r2, r3
 8012608:	f89d 3015 	ldrb.w	r3, [sp, #21]
 801260c:	fa42 f303 	asr.w	r3, r2, r3
 8012610:	4618      	mov	r0, r3
 8012612:	ea4f 71e0 	mov.w	r1, r0, asr #31
 8012616:	f89d 4017 	ldrb.w	r4, [sp, #23]
 801261a:	f89d 3016 	ldrb.w	r3, [sp, #22]
 801261e:	4a42      	ldr	r2, [pc, #264]	; (8012728 <LSM303AGR_ACC_Get_Acceleration+0x208>)
 8012620:	00a4      	lsls	r4, r4, #2
 8012622:	4423      	add	r3, r4
 8012624:	00db      	lsls	r3, r3, #3
 8012626:	4413      	add	r3, r2
 8012628:	e9d3 2300 	ldrd	r2, r3, [r3]
 801262c:	fb02 f501 	mul.w	r5, r2, r1
 8012630:	fb00 f403 	mul.w	r4, r0, r3
 8012634:	442c      	add	r4, r5
 8012636:	fba0 2302 	umull	r2, r3, r0, r2
 801263a:	18e1      	adds	r1, r4, r3
 801263c:	460b      	mov	r3, r1
 801263e:	f512 72fa 	adds.w	r2, r2, #500	; 0x1f4
 8012642:	f143 0300 	adc.w	r3, r3, #0
 8012646:	4610      	mov	r0, r2
 8012648:	4619      	mov	r1, r3
 801264a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 801264e:	f04f 0300 	mov.w	r3, #0
 8012652:	f004 fa25 	bl	8016aa0 <__aeabi_ldivmod>
 8012656:	4602      	mov	r2, r0
 8012658:	460b      	mov	r3, r1
 801265a:	9b00      	ldr	r3, [sp, #0]
 801265c:	601a      	str	r2, [r3, #0]
  buff[1] = ((raw_data_tmp.i16bit[1] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 801265e:	9b00      	ldr	r3, [sp, #0]
 8012660:	1d1c      	adds	r4, r3, #4
 8012662:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8012666:	b21a      	sxth	r2, r3
 8012668:	f89d 3015 	ldrb.w	r3, [sp, #21]
 801266c:	fa42 f303 	asr.w	r3, r2, r3
 8012670:	4618      	mov	r0, r3
 8012672:	ea4f 71e0 	mov.w	r1, r0, asr #31
 8012676:	f89d 5017 	ldrb.w	r5, [sp, #23]
 801267a:	f89d 3016 	ldrb.w	r3, [sp, #22]
 801267e:	4a2a      	ldr	r2, [pc, #168]	; (8012728 <LSM303AGR_ACC_Get_Acceleration+0x208>)
 8012680:	00ad      	lsls	r5, r5, #2
 8012682:	442b      	add	r3, r5
 8012684:	00db      	lsls	r3, r3, #3
 8012686:	4413      	add	r3, r2
 8012688:	e9d3 2300 	ldrd	r2, r3, [r3]
 801268c:	fb02 f601 	mul.w	r6, r2, r1
 8012690:	fb00 f503 	mul.w	r5, r0, r3
 8012694:	4435      	add	r5, r6
 8012696:	fba0 2302 	umull	r2, r3, r0, r2
 801269a:	18e9      	adds	r1, r5, r3
 801269c:	460b      	mov	r3, r1
 801269e:	f512 72fa 	adds.w	r2, r2, #500	; 0x1f4
 80126a2:	f143 0300 	adc.w	r3, r3, #0
 80126a6:	4610      	mov	r0, r2
 80126a8:	4619      	mov	r1, r3
 80126aa:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80126ae:	f04f 0300 	mov.w	r3, #0
 80126b2:	f004 f9f5 	bl	8016aa0 <__aeabi_ldivmod>
 80126b6:	4602      	mov	r2, r0
 80126b8:	460b      	mov	r3, r1
 80126ba:	4613      	mov	r3, r2
 80126bc:	6023      	str	r3, [r4, #0]
  buff[2] = ((raw_data_tmp.i16bit[2] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 80126be:	9b00      	ldr	r3, [sp, #0]
 80126c0:	f103 0408 	add.w	r4, r3, #8
 80126c4:	f8bd 3010 	ldrh.w	r3, [sp, #16]
 80126c8:	b21a      	sxth	r2, r3
 80126ca:	f89d 3015 	ldrb.w	r3, [sp, #21]
 80126ce:	fa42 f303 	asr.w	r3, r2, r3
 80126d2:	4618      	mov	r0, r3
 80126d4:	ea4f 71e0 	mov.w	r1, r0, asr #31
 80126d8:	f89d 5017 	ldrb.w	r5, [sp, #23]
 80126dc:	f89d 3016 	ldrb.w	r3, [sp, #22]
 80126e0:	4a11      	ldr	r2, [pc, #68]	; (8012728 <LSM303AGR_ACC_Get_Acceleration+0x208>)
 80126e2:	00ad      	lsls	r5, r5, #2
 80126e4:	442b      	add	r3, r5
 80126e6:	00db      	lsls	r3, r3, #3
 80126e8:	4413      	add	r3, r2
 80126ea:	e9d3 2300 	ldrd	r2, r3, [r3]
 80126ee:	fb02 f601 	mul.w	r6, r2, r1
 80126f2:	fb00 f503 	mul.w	r5, r0, r3
 80126f6:	4435      	add	r5, r6
 80126f8:	fba0 2302 	umull	r2, r3, r0, r2
 80126fc:	18e9      	adds	r1, r5, r3
 80126fe:	460b      	mov	r3, r1
 8012700:	f512 72fa 	adds.w	r2, r2, #500	; 0x1f4
 8012704:	f143 0300 	adc.w	r3, r3, #0
 8012708:	4610      	mov	r0, r2
 801270a:	4619      	mov	r1, r3
 801270c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8012710:	f04f 0300 	mov.w	r3, #0
 8012714:	f004 f9c4 	bl	8016aa0 <__aeabi_ldivmod>
 8012718:	4602      	mov	r2, r0
 801271a:	460b      	mov	r3, r1
 801271c:	4613      	mov	r3, r2
 801271e:	6023      	str	r3, [r4, #0]

  return MEMS_SUCCESS;
 8012720:	2301      	movs	r3, #1
}
 8012722:	4618      	mov	r0, r3
 8012724:	b006      	add	sp, #24
 8012726:	bd70      	pop	{r4, r5, r6, pc}
 8012728:	080189e0 	.word	0x080189e0
 801272c:	f3af 8000 	nop.w

08012730 <LSM303AGR_ACC_W_ODR>:
* Input          : LSM303AGR_ACC_ODR_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ODR(void *handle, LSM303AGR_ACC_ODR_t newValue)
{
 8012730:	b500      	push	{lr}
 8012732:	b085      	sub	sp, #20
 8012734:	9001      	str	r0, [sp, #4]
 8012736:	460b      	mov	r3, r1
 8012738:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 801273c:	f10d 030f 	add.w	r3, sp, #15
 8012740:	9801      	ldr	r0, [sp, #4]
 8012742:	2120      	movs	r1, #32
 8012744:	461a      	mov	r2, r3
 8012746:	2301      	movs	r3, #1
 8012748:	f7ff fdea 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 801274c:	4603      	mov	r3, r0
 801274e:	2b00      	cmp	r3, #0
 8012750:	d101      	bne.n	8012756 <LSM303AGR_ACC_W_ODR+0x26>
    return MEMS_ERROR;
 8012752:	2300      	movs	r3, #0
 8012754:	e01c      	b.n	8012790 <LSM303AGR_ACC_W_ODR+0x60>

  value &= ~LSM303AGR_ACC_ODR_MASK;
 8012756:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801275a:	f003 030f 	and.w	r3, r3, #15
 801275e:	b2db      	uxtb	r3, r3
 8012760:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012764:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012768:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801276c:	4313      	orrs	r3, r2
 801276e:	b2db      	uxtb	r3, r3
 8012770:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 8012774:	f10d 030f 	add.w	r3, sp, #15
 8012778:	9801      	ldr	r0, [sp, #4]
 801277a:	2120      	movs	r1, #32
 801277c:	461a      	mov	r2, r3
 801277e:	2301      	movs	r3, #1
 8012780:	f7ff fdae 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8012784:	4603      	mov	r3, r0
 8012786:	2b00      	cmp	r3, #0
 8012788:	d101      	bne.n	801278e <LSM303AGR_ACC_W_ODR+0x5e>
    return MEMS_ERROR;
 801278a:	2300      	movs	r3, #0
 801278c:	e000      	b.n	8012790 <LSM303AGR_ACC_W_ODR+0x60>

  return MEMS_SUCCESS;
 801278e:	2301      	movs	r3, #1
}
 8012790:	4618      	mov	r0, r3
 8012792:	b005      	add	sp, #20
 8012794:	f85d fb04 	ldr.w	pc, [sp], #4
 8012798:	f3af 8000 	nop.w
 801279c:	f3af 8000 	nop.w

080127a0 <LSM303AGR_ACC_R_ODR>:
* Input          : Pointer to LSM303AGR_ACC_ODR_t
* Output         : Status of ODR see LSM303AGR_ACC_ODR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ODR(void *handle, LSM303AGR_ACC_ODR_t *value)
{
 80127a0:	b500      	push	{lr}
 80127a2:	b083      	sub	sp, #12
 80127a4:	9001      	str	r0, [sp, #4]
 80127a6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, (u8_t *)value, 1) )
 80127a8:	9801      	ldr	r0, [sp, #4]
 80127aa:	2120      	movs	r1, #32
 80127ac:	9a00      	ldr	r2, [sp, #0]
 80127ae:	2301      	movs	r3, #1
 80127b0:	f7ff fdb6 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80127b4:	4603      	mov	r3, r0
 80127b6:	2b00      	cmp	r3, #0
 80127b8:	d101      	bne.n	80127be <LSM303AGR_ACC_R_ODR+0x1e>
    return MEMS_ERROR;
 80127ba:	2300      	movs	r3, #0
 80127bc:	e007      	b.n	80127ce <LSM303AGR_ACC_R_ODR+0x2e>

  *value &= LSM303AGR_ACC_ODR_MASK; //mask
 80127be:	9b00      	ldr	r3, [sp, #0]
 80127c0:	781b      	ldrb	r3, [r3, #0]
 80127c2:	f023 030f 	bic.w	r3, r3, #15
 80127c6:	b2da      	uxtb	r2, r3
 80127c8:	9b00      	ldr	r3, [sp, #0]
 80127ca:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80127cc:	2301      	movs	r3, #1
}
 80127ce:	4618      	mov	r0, r3
 80127d0:	b003      	add	sp, #12
 80127d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80127d6:	bf00      	nop
 80127d8:	f3af 8000 	nop.w
 80127dc:	f3af 8000 	nop.w

080127e0 <LSM303AGR_ACC_R_x_data_avail>:
* Input          : Pointer to LSM303AGR_ACC_1DA_t
* Output         : Status of 1DA see LSM303AGR_ACC_1DA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_x_data_avail(void *handle, LSM303AGR_ACC_1DA_t *value)
{
 80127e0:	b500      	push	{lr}
 80127e2:	b083      	sub	sp, #12
 80127e4:	9001      	str	r0, [sp, #4]
 80127e6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 80127e8:	9801      	ldr	r0, [sp, #4]
 80127ea:	2107      	movs	r1, #7
 80127ec:	9a00      	ldr	r2, [sp, #0]
 80127ee:	2301      	movs	r3, #1
 80127f0:	f7ff fd96 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80127f4:	4603      	mov	r3, r0
 80127f6:	2b00      	cmp	r3, #0
 80127f8:	d101      	bne.n	80127fe <LSM303AGR_ACC_R_x_data_avail+0x1e>
    return MEMS_ERROR;
 80127fa:	2300      	movs	r3, #0
 80127fc:	e007      	b.n	801280e <LSM303AGR_ACC_R_x_data_avail+0x2e>

  *value &= LSM303AGR_ACC_1DA_MASK; //mask
 80127fe:	9b00      	ldr	r3, [sp, #0]
 8012800:	781b      	ldrb	r3, [r3, #0]
 8012802:	f003 0301 	and.w	r3, r3, #1
 8012806:	b2da      	uxtb	r2, r3
 8012808:	9b00      	ldr	r3, [sp, #0]
 801280a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801280c:	2301      	movs	r3, #1
}
 801280e:	4618      	mov	r0, r3
 8012810:	b003      	add	sp, #12
 8012812:	f85d fb04 	ldr.w	pc, [sp], #4
 8012816:	bf00      	nop
 8012818:	f3af 8000 	nop.w
 801281c:	f3af 8000 	nop.w

08012820 <LSM303AGR_ACC_R_y_data_avail>:
* Input          : Pointer to LSM303AGR_ACC_2DA__t
* Output         : Status of 2DA_ see LSM303AGR_ACC_2DA__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_y_data_avail(void *handle, LSM303AGR_ACC_2DA__t *value)
{
 8012820:	b500      	push	{lr}
 8012822:	b083      	sub	sp, #12
 8012824:	9001      	str	r0, [sp, #4]
 8012826:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 8012828:	9801      	ldr	r0, [sp, #4]
 801282a:	2107      	movs	r1, #7
 801282c:	9a00      	ldr	r2, [sp, #0]
 801282e:	2301      	movs	r3, #1
 8012830:	f7ff fd76 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8012834:	4603      	mov	r3, r0
 8012836:	2b00      	cmp	r3, #0
 8012838:	d101      	bne.n	801283e <LSM303AGR_ACC_R_y_data_avail+0x1e>
    return MEMS_ERROR;
 801283a:	2300      	movs	r3, #0
 801283c:	e007      	b.n	801284e <LSM303AGR_ACC_R_y_data_avail+0x2e>

  *value &= LSM303AGR_ACC_2DA__MASK; //mask
 801283e:	9b00      	ldr	r3, [sp, #0]
 8012840:	781b      	ldrb	r3, [r3, #0]
 8012842:	f003 0302 	and.w	r3, r3, #2
 8012846:	b2da      	uxtb	r2, r3
 8012848:	9b00      	ldr	r3, [sp, #0]
 801284a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801284c:	2301      	movs	r3, #1
}
 801284e:	4618      	mov	r0, r3
 8012850:	b003      	add	sp, #12
 8012852:	f85d fb04 	ldr.w	pc, [sp], #4
 8012856:	bf00      	nop
 8012858:	f3af 8000 	nop.w
 801285c:	f3af 8000 	nop.w

08012860 <LSM303AGR_ACC_R_z_data_avail>:
* Input          : Pointer to LSM303AGR_ACC_3DA__t
* Output         : Status of 3DA_ see LSM303AGR_ACC_3DA__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_z_data_avail(void *handle, LSM303AGR_ACC_3DA__t *value)
{
 8012860:	b500      	push	{lr}
 8012862:	b083      	sub	sp, #12
 8012864:	9001      	str	r0, [sp, #4]
 8012866:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 8012868:	9801      	ldr	r0, [sp, #4]
 801286a:	2107      	movs	r1, #7
 801286c:	9a00      	ldr	r2, [sp, #0]
 801286e:	2301      	movs	r3, #1
 8012870:	f7ff fd56 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8012874:	4603      	mov	r3, r0
 8012876:	2b00      	cmp	r3, #0
 8012878:	d101      	bne.n	801287e <LSM303AGR_ACC_R_z_data_avail+0x1e>
    return MEMS_ERROR;
 801287a:	2300      	movs	r3, #0
 801287c:	e007      	b.n	801288e <LSM303AGR_ACC_R_z_data_avail+0x2e>

  *value &= LSM303AGR_ACC_3DA__MASK; //mask
 801287e:	9b00      	ldr	r3, [sp, #0]
 8012880:	781b      	ldrb	r3, [r3, #0]
 8012882:	f003 0304 	and.w	r3, r3, #4
 8012886:	b2da      	uxtb	r2, r3
 8012888:	9b00      	ldr	r3, [sp, #0]
 801288a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801288c:	2301      	movs	r3, #1
}
 801288e:	4618      	mov	r0, r3
 8012890:	b003      	add	sp, #12
 8012892:	f85d fb04 	ldr.w	pc, [sp], #4
 8012896:	bf00      	nop
 8012898:	f3af 8000 	nop.w
 801289c:	f3af 8000 	nop.w

080128a0 <LSM303AGR_ACC_R_xyz_data_avail>:
* Input          : Pointer to LSM303AGR_ACC_321DA__t
* Output         : Status of 321DA_ see LSM303AGR_ACC_321DA__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_xyz_data_avail(void *handle, LSM303AGR_ACC_321DA__t *value)
{
 80128a0:	b500      	push	{lr}
 80128a2:	b083      	sub	sp, #12
 80128a4:	9001      	str	r0, [sp, #4]
 80128a6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 80128a8:	9801      	ldr	r0, [sp, #4]
 80128aa:	2107      	movs	r1, #7
 80128ac:	9a00      	ldr	r2, [sp, #0]
 80128ae:	2301      	movs	r3, #1
 80128b0:	f7ff fd36 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80128b4:	4603      	mov	r3, r0
 80128b6:	2b00      	cmp	r3, #0
 80128b8:	d101      	bne.n	80128be <LSM303AGR_ACC_R_xyz_data_avail+0x1e>
    return MEMS_ERROR;
 80128ba:	2300      	movs	r3, #0
 80128bc:	e007      	b.n	80128ce <LSM303AGR_ACC_R_xyz_data_avail+0x2e>

  *value &= LSM303AGR_ACC_321DA__MASK; //mask
 80128be:	9b00      	ldr	r3, [sp, #0]
 80128c0:	781b      	ldrb	r3, [r3, #0]
 80128c2:	f003 0308 	and.w	r3, r3, #8
 80128c6:	b2da      	uxtb	r2, r3
 80128c8:	9b00      	ldr	r3, [sp, #0]
 80128ca:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80128cc:	2301      	movs	r3, #1
}
 80128ce:	4618      	mov	r0, r3
 80128d0:	b003      	add	sp, #12
 80128d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80128d6:	bf00      	nop
 80128d8:	f3af 8000 	nop.w
 80128dc:	f3af 8000 	nop.w

080128e0 <LSM303AGR_ACC_R_DataXOverrun>:
* Input          : Pointer to LSM303AGR_ACC_1OR__t
* Output         : Status of 1OR_ see LSM303AGR_ACC_1OR__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_DataXOverrun(void *handle, LSM303AGR_ACC_1OR__t *value)
{
 80128e0:	b500      	push	{lr}
 80128e2:	b083      	sub	sp, #12
 80128e4:	9001      	str	r0, [sp, #4]
 80128e6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 80128e8:	9801      	ldr	r0, [sp, #4]
 80128ea:	2107      	movs	r1, #7
 80128ec:	9a00      	ldr	r2, [sp, #0]
 80128ee:	2301      	movs	r3, #1
 80128f0:	f7ff fd16 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80128f4:	4603      	mov	r3, r0
 80128f6:	2b00      	cmp	r3, #0
 80128f8:	d101      	bne.n	80128fe <LSM303AGR_ACC_R_DataXOverrun+0x1e>
    return MEMS_ERROR;
 80128fa:	2300      	movs	r3, #0
 80128fc:	e007      	b.n	801290e <LSM303AGR_ACC_R_DataXOverrun+0x2e>

  *value &= LSM303AGR_ACC_1OR__MASK; //mask
 80128fe:	9b00      	ldr	r3, [sp, #0]
 8012900:	781b      	ldrb	r3, [r3, #0]
 8012902:	f003 0310 	and.w	r3, r3, #16
 8012906:	b2da      	uxtb	r2, r3
 8012908:	9b00      	ldr	r3, [sp, #0]
 801290a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801290c:	2301      	movs	r3, #1
}
 801290e:	4618      	mov	r0, r3
 8012910:	b003      	add	sp, #12
 8012912:	f85d fb04 	ldr.w	pc, [sp], #4
 8012916:	bf00      	nop
 8012918:	f3af 8000 	nop.w
 801291c:	f3af 8000 	nop.w

08012920 <LSM303AGR_ACC_R_DataYOverrun>:
* Input          : Pointer to LSM303AGR_ACC_2OR__t
* Output         : Status of 2OR_ see LSM303AGR_ACC_2OR__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_DataYOverrun(void *handle, LSM303AGR_ACC_2OR__t *value)
{
 8012920:	b500      	push	{lr}
 8012922:	b083      	sub	sp, #12
 8012924:	9001      	str	r0, [sp, #4]
 8012926:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 8012928:	9801      	ldr	r0, [sp, #4]
 801292a:	2107      	movs	r1, #7
 801292c:	9a00      	ldr	r2, [sp, #0]
 801292e:	2301      	movs	r3, #1
 8012930:	f7ff fcf6 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8012934:	4603      	mov	r3, r0
 8012936:	2b00      	cmp	r3, #0
 8012938:	d101      	bne.n	801293e <LSM303AGR_ACC_R_DataYOverrun+0x1e>
    return MEMS_ERROR;
 801293a:	2300      	movs	r3, #0
 801293c:	e007      	b.n	801294e <LSM303AGR_ACC_R_DataYOverrun+0x2e>

  *value &= LSM303AGR_ACC_2OR__MASK; //mask
 801293e:	9b00      	ldr	r3, [sp, #0]
 8012940:	781b      	ldrb	r3, [r3, #0]
 8012942:	f003 0320 	and.w	r3, r3, #32
 8012946:	b2da      	uxtb	r2, r3
 8012948:	9b00      	ldr	r3, [sp, #0]
 801294a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801294c:	2301      	movs	r3, #1
}
 801294e:	4618      	mov	r0, r3
 8012950:	b003      	add	sp, #12
 8012952:	f85d fb04 	ldr.w	pc, [sp], #4
 8012956:	bf00      	nop
 8012958:	f3af 8000 	nop.w
 801295c:	f3af 8000 	nop.w

08012960 <LSM303AGR_ACC_R_DataZOverrun>:
* Input          : Pointer to LSM303AGR_ACC_3OR__t
* Output         : Status of 3OR_ see LSM303AGR_ACC_3OR__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_DataZOverrun(void *handle, LSM303AGR_ACC_3OR__t *value)
{
 8012960:	b500      	push	{lr}
 8012962:	b083      	sub	sp, #12
 8012964:	9001      	str	r0, [sp, #4]
 8012966:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 8012968:	9801      	ldr	r0, [sp, #4]
 801296a:	2107      	movs	r1, #7
 801296c:	9a00      	ldr	r2, [sp, #0]
 801296e:	2301      	movs	r3, #1
 8012970:	f7ff fcd6 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8012974:	4603      	mov	r3, r0
 8012976:	2b00      	cmp	r3, #0
 8012978:	d101      	bne.n	801297e <LSM303AGR_ACC_R_DataZOverrun+0x1e>
    return MEMS_ERROR;
 801297a:	2300      	movs	r3, #0
 801297c:	e007      	b.n	801298e <LSM303AGR_ACC_R_DataZOverrun+0x2e>

  *value &= LSM303AGR_ACC_3OR__MASK; //mask
 801297e:	9b00      	ldr	r3, [sp, #0]
 8012980:	781b      	ldrb	r3, [r3, #0]
 8012982:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8012986:	b2da      	uxtb	r2, r3
 8012988:	9b00      	ldr	r3, [sp, #0]
 801298a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801298c:	2301      	movs	r3, #1
}
 801298e:	4618      	mov	r0, r3
 8012990:	b003      	add	sp, #12
 8012992:	f85d fb04 	ldr.w	pc, [sp], #4
 8012996:	bf00      	nop
 8012998:	f3af 8000 	nop.w
 801299c:	f3af 8000 	nop.w

080129a0 <LSM303AGR_ACC_R_DataXYZOverrun>:
* Input          : Pointer to LSM303AGR_ACC_321OR__t
* Output         : Status of 321OR_ see LSM303AGR_ACC_321OR__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_DataXYZOverrun(void *handle, LSM303AGR_ACC_321OR__t *value)
{
 80129a0:	b500      	push	{lr}
 80129a2:	b083      	sub	sp, #12
 80129a4:	9001      	str	r0, [sp, #4]
 80129a6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 80129a8:	9801      	ldr	r0, [sp, #4]
 80129aa:	2107      	movs	r1, #7
 80129ac:	9a00      	ldr	r2, [sp, #0]
 80129ae:	2301      	movs	r3, #1
 80129b0:	f7ff fcb6 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80129b4:	4603      	mov	r3, r0
 80129b6:	2b00      	cmp	r3, #0
 80129b8:	d101      	bne.n	80129be <LSM303AGR_ACC_R_DataXYZOverrun+0x1e>
    return MEMS_ERROR;
 80129ba:	2300      	movs	r3, #0
 80129bc:	e007      	b.n	80129ce <LSM303AGR_ACC_R_DataXYZOverrun+0x2e>

  *value &= LSM303AGR_ACC_321OR__MASK; //mask
 80129be:	9b00      	ldr	r3, [sp, #0]
 80129c0:	781b      	ldrb	r3, [r3, #0]
 80129c2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80129c6:	b2da      	uxtb	r2, r3
 80129c8:	9b00      	ldr	r3, [sp, #0]
 80129ca:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80129cc:	2301      	movs	r3, #1
}
 80129ce:	4618      	mov	r0, r3
 80129d0:	b003      	add	sp, #12
 80129d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80129d6:	bf00      	nop
 80129d8:	f3af 8000 	nop.w
 80129dc:	f3af 8000 	nop.w

080129e0 <LSM303AGR_ACC_R_int_counter>:
* Input          : Pointer to u8_t
* Output         : Status of IC
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_int_counter(void *handle, u8_t *value)
{
 80129e0:	b500      	push	{lr}
 80129e2:	b083      	sub	sp, #12
 80129e4:	9001      	str	r0, [sp, #4]
 80129e6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT_COUNTER_REG, (u8_t *)value, 1) )
 80129e8:	9801      	ldr	r0, [sp, #4]
 80129ea:	210e      	movs	r1, #14
 80129ec:	9a00      	ldr	r2, [sp, #0]
 80129ee:	2301      	movs	r3, #1
 80129f0:	f7ff fc96 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80129f4:	4603      	mov	r3, r0
 80129f6:	2b00      	cmp	r3, #0
 80129f8:	d101      	bne.n	80129fe <LSM303AGR_ACC_R_int_counter+0x1e>
    return MEMS_ERROR;
 80129fa:	2300      	movs	r3, #0
 80129fc:	e008      	b.n	8012a10 <LSM303AGR_ACC_R_int_counter+0x30>

  *value &= LSM303AGR_ACC_IC_MASK; //coerce
 80129fe:	9b00      	ldr	r3, [sp, #0]
 8012a00:	781a      	ldrb	r2, [r3, #0]
 8012a02:	9b00      	ldr	r3, [sp, #0]
 8012a04:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_IC_POSITION; //mask
 8012a06:	9b00      	ldr	r3, [sp, #0]
 8012a08:	781a      	ldrb	r2, [r3, #0]
 8012a0a:	9b00      	ldr	r3, [sp, #0]
 8012a0c:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012a0e:	2301      	movs	r3, #1
}
 8012a10:	4618      	mov	r0, r3
 8012a12:	b003      	add	sp, #12
 8012a14:	f85d fb04 	ldr.w	pc, [sp], #4
 8012a18:	f3af 8000 	nop.w
 8012a1c:	f3af 8000 	nop.w

08012a20 <LSM303AGR_ACC_W_TEMP_EN_bits>:
* Input          : LSM303AGR_ACC_TEMP_EN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_TEMP_EN_bits(void *handle, LSM303AGR_ACC_TEMP_EN_t newValue)
{
 8012a20:	b500      	push	{lr}
 8012a22:	b085      	sub	sp, #20
 8012a24:	9001      	str	r0, [sp, #4]
 8012a26:	460b      	mov	r3, r1
 8012a28:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TEMP_CFG_REG, &value, 1) )
 8012a2c:	f10d 030f 	add.w	r3, sp, #15
 8012a30:	9801      	ldr	r0, [sp, #4]
 8012a32:	211f      	movs	r1, #31
 8012a34:	461a      	mov	r2, r3
 8012a36:	2301      	movs	r3, #1
 8012a38:	f7ff fc72 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8012a3c:	4603      	mov	r3, r0
 8012a3e:	2b00      	cmp	r3, #0
 8012a40:	d101      	bne.n	8012a46 <LSM303AGR_ACC_W_TEMP_EN_bits+0x26>
    return MEMS_ERROR;
 8012a42:	2300      	movs	r3, #0
 8012a44:	e01c      	b.n	8012a80 <LSM303AGR_ACC_W_TEMP_EN_bits+0x60>

  value &= ~LSM303AGR_ACC_TEMP_EN_MASK;
 8012a46:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012a4a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8012a4e:	b2db      	uxtb	r3, r3
 8012a50:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012a54:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012a58:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012a5c:	4313      	orrs	r3, r2
 8012a5e:	b2db      	uxtb	r3, r3
 8012a60:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_TEMP_CFG_REG, &value, 1) )
 8012a64:	f10d 030f 	add.w	r3, sp, #15
 8012a68:	9801      	ldr	r0, [sp, #4]
 8012a6a:	211f      	movs	r1, #31
 8012a6c:	461a      	mov	r2, r3
 8012a6e:	2301      	movs	r3, #1
 8012a70:	f7ff fc36 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8012a74:	4603      	mov	r3, r0
 8012a76:	2b00      	cmp	r3, #0
 8012a78:	d101      	bne.n	8012a7e <LSM303AGR_ACC_W_TEMP_EN_bits+0x5e>
    return MEMS_ERROR;
 8012a7a:	2300      	movs	r3, #0
 8012a7c:	e000      	b.n	8012a80 <LSM303AGR_ACC_W_TEMP_EN_bits+0x60>

  return MEMS_SUCCESS;
 8012a7e:	2301      	movs	r3, #1
}
 8012a80:	4618      	mov	r0, r3
 8012a82:	b005      	add	sp, #20
 8012a84:	f85d fb04 	ldr.w	pc, [sp], #4
 8012a88:	f3af 8000 	nop.w
 8012a8c:	f3af 8000 	nop.w

08012a90 <LSM303AGR_ACC_R_TEMP_EN_bits>:
* Input          : Pointer to LSM303AGR_ACC_TEMP_EN_t
* Output         : Status of TEMP_EN see LSM303AGR_ACC_TEMP_EN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_TEMP_EN_bits(void *handle, LSM303AGR_ACC_TEMP_EN_t *value)
{
 8012a90:	b500      	push	{lr}
 8012a92:	b083      	sub	sp, #12
 8012a94:	9001      	str	r0, [sp, #4]
 8012a96:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TEMP_CFG_REG, (u8_t *)value, 1) )
 8012a98:	9801      	ldr	r0, [sp, #4]
 8012a9a:	211f      	movs	r1, #31
 8012a9c:	9a00      	ldr	r2, [sp, #0]
 8012a9e:	2301      	movs	r3, #1
 8012aa0:	f7ff fc3e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8012aa4:	4603      	mov	r3, r0
 8012aa6:	2b00      	cmp	r3, #0
 8012aa8:	d101      	bne.n	8012aae <LSM303AGR_ACC_R_TEMP_EN_bits+0x1e>
    return MEMS_ERROR;
 8012aaa:	2300      	movs	r3, #0
 8012aac:	e007      	b.n	8012abe <LSM303AGR_ACC_R_TEMP_EN_bits+0x2e>

  *value &= LSM303AGR_ACC_TEMP_EN_MASK; //mask
 8012aae:	9b00      	ldr	r3, [sp, #0]
 8012ab0:	781b      	ldrb	r3, [r3, #0]
 8012ab2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8012ab6:	b2da      	uxtb	r2, r3
 8012ab8:	9b00      	ldr	r3, [sp, #0]
 8012aba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012abc:	2301      	movs	r3, #1
}
 8012abe:	4618      	mov	r0, r3
 8012ac0:	b003      	add	sp, #12
 8012ac2:	f85d fb04 	ldr.w	pc, [sp], #4
 8012ac6:	bf00      	nop
 8012ac8:	f3af 8000 	nop.w
 8012acc:	f3af 8000 	nop.w

08012ad0 <LSM303AGR_ACC_W_ADC_PD>:
* Input          : LSM303AGR_ACC_ADC_PD_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ADC_PD(void *handle, LSM303AGR_ACC_ADC_PD_t newValue)
{
 8012ad0:	b500      	push	{lr}
 8012ad2:	b085      	sub	sp, #20
 8012ad4:	9001      	str	r0, [sp, #4]
 8012ad6:	460b      	mov	r3, r1
 8012ad8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TEMP_CFG_REG, &value, 1) )
 8012adc:	f10d 030f 	add.w	r3, sp, #15
 8012ae0:	9801      	ldr	r0, [sp, #4]
 8012ae2:	211f      	movs	r1, #31
 8012ae4:	461a      	mov	r2, r3
 8012ae6:	2301      	movs	r3, #1
 8012ae8:	f7ff fc1a 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8012aec:	4603      	mov	r3, r0
 8012aee:	2b00      	cmp	r3, #0
 8012af0:	d101      	bne.n	8012af6 <LSM303AGR_ACC_W_ADC_PD+0x26>
    return MEMS_ERROR;
 8012af2:	2300      	movs	r3, #0
 8012af4:	e01c      	b.n	8012b30 <LSM303AGR_ACC_W_ADC_PD+0x60>

  value &= ~LSM303AGR_ACC_ADC_PD_MASK;
 8012af6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012afa:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8012afe:	b2db      	uxtb	r3, r3
 8012b00:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012b04:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012b08:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012b0c:	4313      	orrs	r3, r2
 8012b0e:	b2db      	uxtb	r3, r3
 8012b10:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_TEMP_CFG_REG, &value, 1) )
 8012b14:	f10d 030f 	add.w	r3, sp, #15
 8012b18:	9801      	ldr	r0, [sp, #4]
 8012b1a:	211f      	movs	r1, #31
 8012b1c:	461a      	mov	r2, r3
 8012b1e:	2301      	movs	r3, #1
 8012b20:	f7ff fbde 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8012b24:	4603      	mov	r3, r0
 8012b26:	2b00      	cmp	r3, #0
 8012b28:	d101      	bne.n	8012b2e <LSM303AGR_ACC_W_ADC_PD+0x5e>
    return MEMS_ERROR;
 8012b2a:	2300      	movs	r3, #0
 8012b2c:	e000      	b.n	8012b30 <LSM303AGR_ACC_W_ADC_PD+0x60>

  return MEMS_SUCCESS;
 8012b2e:	2301      	movs	r3, #1
}
 8012b30:	4618      	mov	r0, r3
 8012b32:	b005      	add	sp, #20
 8012b34:	f85d fb04 	ldr.w	pc, [sp], #4
 8012b38:	f3af 8000 	nop.w
 8012b3c:	f3af 8000 	nop.w

08012b40 <LSM303AGR_ACC_R_ADC_PD>:
* Input          : Pointer to LSM303AGR_ACC_ADC_PD_t
* Output         : Status of ADC_PD see LSM303AGR_ACC_ADC_PD_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ADC_PD(void *handle, LSM303AGR_ACC_ADC_PD_t *value)
{
 8012b40:	b500      	push	{lr}
 8012b42:	b083      	sub	sp, #12
 8012b44:	9001      	str	r0, [sp, #4]
 8012b46:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TEMP_CFG_REG, (u8_t *)value, 1) )
 8012b48:	9801      	ldr	r0, [sp, #4]
 8012b4a:	211f      	movs	r1, #31
 8012b4c:	9a00      	ldr	r2, [sp, #0]
 8012b4e:	2301      	movs	r3, #1
 8012b50:	f7ff fbe6 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8012b54:	4603      	mov	r3, r0
 8012b56:	2b00      	cmp	r3, #0
 8012b58:	d101      	bne.n	8012b5e <LSM303AGR_ACC_R_ADC_PD+0x1e>
    return MEMS_ERROR;
 8012b5a:	2300      	movs	r3, #0
 8012b5c:	e007      	b.n	8012b6e <LSM303AGR_ACC_R_ADC_PD+0x2e>

  *value &= LSM303AGR_ACC_ADC_PD_MASK; //mask
 8012b5e:	9b00      	ldr	r3, [sp, #0]
 8012b60:	781b      	ldrb	r3, [r3, #0]
 8012b62:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8012b66:	b2da      	uxtb	r2, r3
 8012b68:	9b00      	ldr	r3, [sp, #0]
 8012b6a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012b6c:	2301      	movs	r3, #1
}
 8012b6e:	4618      	mov	r0, r3
 8012b70:	b003      	add	sp, #12
 8012b72:	f85d fb04 	ldr.w	pc, [sp], #4
 8012b76:	bf00      	nop
 8012b78:	f3af 8000 	nop.w
 8012b7c:	f3af 8000 	nop.w

08012b80 <LSM303AGR_ACC_W_XEN>:
* Input          : LSM303AGR_ACC_XEN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_XEN(void *handle, LSM303AGR_ACC_XEN_t newValue)
{
 8012b80:	b500      	push	{lr}
 8012b82:	b085      	sub	sp, #20
 8012b84:	9001      	str	r0, [sp, #4]
 8012b86:	460b      	mov	r3, r1
 8012b88:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 8012b8c:	f10d 030f 	add.w	r3, sp, #15
 8012b90:	9801      	ldr	r0, [sp, #4]
 8012b92:	2120      	movs	r1, #32
 8012b94:	461a      	mov	r2, r3
 8012b96:	2301      	movs	r3, #1
 8012b98:	f7ff fbc2 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8012b9c:	4603      	mov	r3, r0
 8012b9e:	2b00      	cmp	r3, #0
 8012ba0:	d101      	bne.n	8012ba6 <LSM303AGR_ACC_W_XEN+0x26>
    return MEMS_ERROR;
 8012ba2:	2300      	movs	r3, #0
 8012ba4:	e01c      	b.n	8012be0 <LSM303AGR_ACC_W_XEN+0x60>

  value &= ~LSM303AGR_ACC_XEN_MASK;
 8012ba6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012baa:	f023 0301 	bic.w	r3, r3, #1
 8012bae:	b2db      	uxtb	r3, r3
 8012bb0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012bb4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012bb8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012bbc:	4313      	orrs	r3, r2
 8012bbe:	b2db      	uxtb	r3, r3
 8012bc0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 8012bc4:	f10d 030f 	add.w	r3, sp, #15
 8012bc8:	9801      	ldr	r0, [sp, #4]
 8012bca:	2120      	movs	r1, #32
 8012bcc:	461a      	mov	r2, r3
 8012bce:	2301      	movs	r3, #1
 8012bd0:	f7ff fb86 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8012bd4:	4603      	mov	r3, r0
 8012bd6:	2b00      	cmp	r3, #0
 8012bd8:	d101      	bne.n	8012bde <LSM303AGR_ACC_W_XEN+0x5e>
    return MEMS_ERROR;
 8012bda:	2300      	movs	r3, #0
 8012bdc:	e000      	b.n	8012be0 <LSM303AGR_ACC_W_XEN+0x60>

  return MEMS_SUCCESS;
 8012bde:	2301      	movs	r3, #1
}
 8012be0:	4618      	mov	r0, r3
 8012be2:	b005      	add	sp, #20
 8012be4:	f85d fb04 	ldr.w	pc, [sp], #4
 8012be8:	f3af 8000 	nop.w
 8012bec:	f3af 8000 	nop.w

08012bf0 <LSM303AGR_ACC_R_XEN>:
* Input          : Pointer to LSM303AGR_ACC_XEN_t
* Output         : Status of XEN see LSM303AGR_ACC_XEN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XEN(void *handle, LSM303AGR_ACC_XEN_t *value)
{
 8012bf0:	b500      	push	{lr}
 8012bf2:	b083      	sub	sp, #12
 8012bf4:	9001      	str	r0, [sp, #4]
 8012bf6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, (u8_t *)value, 1) )
 8012bf8:	9801      	ldr	r0, [sp, #4]
 8012bfa:	2120      	movs	r1, #32
 8012bfc:	9a00      	ldr	r2, [sp, #0]
 8012bfe:	2301      	movs	r3, #1
 8012c00:	f7ff fb8e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8012c04:	4603      	mov	r3, r0
 8012c06:	2b00      	cmp	r3, #0
 8012c08:	d101      	bne.n	8012c0e <LSM303AGR_ACC_R_XEN+0x1e>
    return MEMS_ERROR;
 8012c0a:	2300      	movs	r3, #0
 8012c0c:	e007      	b.n	8012c1e <LSM303AGR_ACC_R_XEN+0x2e>

  *value &= LSM303AGR_ACC_XEN_MASK; //mask
 8012c0e:	9b00      	ldr	r3, [sp, #0]
 8012c10:	781b      	ldrb	r3, [r3, #0]
 8012c12:	f003 0301 	and.w	r3, r3, #1
 8012c16:	b2da      	uxtb	r2, r3
 8012c18:	9b00      	ldr	r3, [sp, #0]
 8012c1a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012c1c:	2301      	movs	r3, #1
}
 8012c1e:	4618      	mov	r0, r3
 8012c20:	b003      	add	sp, #12
 8012c22:	f85d fb04 	ldr.w	pc, [sp], #4
 8012c26:	bf00      	nop
 8012c28:	f3af 8000 	nop.w
 8012c2c:	f3af 8000 	nop.w

08012c30 <LSM303AGR_ACC_W_YEN>:
* Input          : LSM303AGR_ACC_YEN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_YEN(void *handle, LSM303AGR_ACC_YEN_t newValue)
{
 8012c30:	b500      	push	{lr}
 8012c32:	b085      	sub	sp, #20
 8012c34:	9001      	str	r0, [sp, #4]
 8012c36:	460b      	mov	r3, r1
 8012c38:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 8012c3c:	f10d 030f 	add.w	r3, sp, #15
 8012c40:	9801      	ldr	r0, [sp, #4]
 8012c42:	2120      	movs	r1, #32
 8012c44:	461a      	mov	r2, r3
 8012c46:	2301      	movs	r3, #1
 8012c48:	f7ff fb6a 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8012c4c:	4603      	mov	r3, r0
 8012c4e:	2b00      	cmp	r3, #0
 8012c50:	d101      	bne.n	8012c56 <LSM303AGR_ACC_W_YEN+0x26>
    return MEMS_ERROR;
 8012c52:	2300      	movs	r3, #0
 8012c54:	e01c      	b.n	8012c90 <LSM303AGR_ACC_W_YEN+0x60>

  value &= ~LSM303AGR_ACC_YEN_MASK;
 8012c56:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012c5a:	f023 0302 	bic.w	r3, r3, #2
 8012c5e:	b2db      	uxtb	r3, r3
 8012c60:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012c64:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012c68:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012c6c:	4313      	orrs	r3, r2
 8012c6e:	b2db      	uxtb	r3, r3
 8012c70:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 8012c74:	f10d 030f 	add.w	r3, sp, #15
 8012c78:	9801      	ldr	r0, [sp, #4]
 8012c7a:	2120      	movs	r1, #32
 8012c7c:	461a      	mov	r2, r3
 8012c7e:	2301      	movs	r3, #1
 8012c80:	f7ff fb2e 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8012c84:	4603      	mov	r3, r0
 8012c86:	2b00      	cmp	r3, #0
 8012c88:	d101      	bne.n	8012c8e <LSM303AGR_ACC_W_YEN+0x5e>
    return MEMS_ERROR;
 8012c8a:	2300      	movs	r3, #0
 8012c8c:	e000      	b.n	8012c90 <LSM303AGR_ACC_W_YEN+0x60>

  return MEMS_SUCCESS;
 8012c8e:	2301      	movs	r3, #1
}
 8012c90:	4618      	mov	r0, r3
 8012c92:	b005      	add	sp, #20
 8012c94:	f85d fb04 	ldr.w	pc, [sp], #4
 8012c98:	f3af 8000 	nop.w
 8012c9c:	f3af 8000 	nop.w

08012ca0 <LSM303AGR_ACC_R_YEN>:
* Input          : Pointer to LSM303AGR_ACC_YEN_t
* Output         : Status of YEN see LSM303AGR_ACC_YEN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_YEN(void *handle, LSM303AGR_ACC_YEN_t *value)
{
 8012ca0:	b500      	push	{lr}
 8012ca2:	b083      	sub	sp, #12
 8012ca4:	9001      	str	r0, [sp, #4]
 8012ca6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, (u8_t *)value, 1) )
 8012ca8:	9801      	ldr	r0, [sp, #4]
 8012caa:	2120      	movs	r1, #32
 8012cac:	9a00      	ldr	r2, [sp, #0]
 8012cae:	2301      	movs	r3, #1
 8012cb0:	f7ff fb36 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8012cb4:	4603      	mov	r3, r0
 8012cb6:	2b00      	cmp	r3, #0
 8012cb8:	d101      	bne.n	8012cbe <LSM303AGR_ACC_R_YEN+0x1e>
    return MEMS_ERROR;
 8012cba:	2300      	movs	r3, #0
 8012cbc:	e007      	b.n	8012cce <LSM303AGR_ACC_R_YEN+0x2e>

  *value &= LSM303AGR_ACC_YEN_MASK; //mask
 8012cbe:	9b00      	ldr	r3, [sp, #0]
 8012cc0:	781b      	ldrb	r3, [r3, #0]
 8012cc2:	f003 0302 	and.w	r3, r3, #2
 8012cc6:	b2da      	uxtb	r2, r3
 8012cc8:	9b00      	ldr	r3, [sp, #0]
 8012cca:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012ccc:	2301      	movs	r3, #1
}
 8012cce:	4618      	mov	r0, r3
 8012cd0:	b003      	add	sp, #12
 8012cd2:	f85d fb04 	ldr.w	pc, [sp], #4
 8012cd6:	bf00      	nop
 8012cd8:	f3af 8000 	nop.w
 8012cdc:	f3af 8000 	nop.w

08012ce0 <LSM303AGR_ACC_W_ZEN>:
* Input          : LSM303AGR_ACC_ZEN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ZEN(void *handle, LSM303AGR_ACC_ZEN_t newValue)
{
 8012ce0:	b500      	push	{lr}
 8012ce2:	b085      	sub	sp, #20
 8012ce4:	9001      	str	r0, [sp, #4]
 8012ce6:	460b      	mov	r3, r1
 8012ce8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 8012cec:	f10d 030f 	add.w	r3, sp, #15
 8012cf0:	9801      	ldr	r0, [sp, #4]
 8012cf2:	2120      	movs	r1, #32
 8012cf4:	461a      	mov	r2, r3
 8012cf6:	2301      	movs	r3, #1
 8012cf8:	f7ff fb12 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8012cfc:	4603      	mov	r3, r0
 8012cfe:	2b00      	cmp	r3, #0
 8012d00:	d101      	bne.n	8012d06 <LSM303AGR_ACC_W_ZEN+0x26>
    return MEMS_ERROR;
 8012d02:	2300      	movs	r3, #0
 8012d04:	e01c      	b.n	8012d40 <LSM303AGR_ACC_W_ZEN+0x60>

  value &= ~LSM303AGR_ACC_ZEN_MASK;
 8012d06:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012d0a:	f023 0304 	bic.w	r3, r3, #4
 8012d0e:	b2db      	uxtb	r3, r3
 8012d10:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012d14:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012d18:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012d1c:	4313      	orrs	r3, r2
 8012d1e:	b2db      	uxtb	r3, r3
 8012d20:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 8012d24:	f10d 030f 	add.w	r3, sp, #15
 8012d28:	9801      	ldr	r0, [sp, #4]
 8012d2a:	2120      	movs	r1, #32
 8012d2c:	461a      	mov	r2, r3
 8012d2e:	2301      	movs	r3, #1
 8012d30:	f7ff fad6 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8012d34:	4603      	mov	r3, r0
 8012d36:	2b00      	cmp	r3, #0
 8012d38:	d101      	bne.n	8012d3e <LSM303AGR_ACC_W_ZEN+0x5e>
    return MEMS_ERROR;
 8012d3a:	2300      	movs	r3, #0
 8012d3c:	e000      	b.n	8012d40 <LSM303AGR_ACC_W_ZEN+0x60>

  return MEMS_SUCCESS;
 8012d3e:	2301      	movs	r3, #1
}
 8012d40:	4618      	mov	r0, r3
 8012d42:	b005      	add	sp, #20
 8012d44:	f85d fb04 	ldr.w	pc, [sp], #4
 8012d48:	f3af 8000 	nop.w
 8012d4c:	f3af 8000 	nop.w

08012d50 <LSM303AGR_ACC_R_ZEN>:
* Input          : Pointer to LSM303AGR_ACC_ZEN_t
* Output         : Status of ZEN see LSM303AGR_ACC_ZEN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ZEN(void *handle, LSM303AGR_ACC_ZEN_t *value)
{
 8012d50:	b500      	push	{lr}
 8012d52:	b083      	sub	sp, #12
 8012d54:	9001      	str	r0, [sp, #4]
 8012d56:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, (u8_t *)value, 1) )
 8012d58:	9801      	ldr	r0, [sp, #4]
 8012d5a:	2120      	movs	r1, #32
 8012d5c:	9a00      	ldr	r2, [sp, #0]
 8012d5e:	2301      	movs	r3, #1
 8012d60:	f7ff fade 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8012d64:	4603      	mov	r3, r0
 8012d66:	2b00      	cmp	r3, #0
 8012d68:	d101      	bne.n	8012d6e <LSM303AGR_ACC_R_ZEN+0x1e>
    return MEMS_ERROR;
 8012d6a:	2300      	movs	r3, #0
 8012d6c:	e007      	b.n	8012d7e <LSM303AGR_ACC_R_ZEN+0x2e>

  *value &= LSM303AGR_ACC_ZEN_MASK; //mask
 8012d6e:	9b00      	ldr	r3, [sp, #0]
 8012d70:	781b      	ldrb	r3, [r3, #0]
 8012d72:	f003 0304 	and.w	r3, r3, #4
 8012d76:	b2da      	uxtb	r2, r3
 8012d78:	9b00      	ldr	r3, [sp, #0]
 8012d7a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012d7c:	2301      	movs	r3, #1
}
 8012d7e:	4618      	mov	r0, r3
 8012d80:	b003      	add	sp, #12
 8012d82:	f85d fb04 	ldr.w	pc, [sp], #4
 8012d86:	bf00      	nop
 8012d88:	f3af 8000 	nop.w
 8012d8c:	f3af 8000 	nop.w

08012d90 <LSM303AGR_ACC_W_LOWPWR_EN>:
* Input          : LSM303AGR_ACC_LPEN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_LOWPWR_EN(void *handle, LSM303AGR_ACC_LPEN_t newValue)
{
 8012d90:	b500      	push	{lr}
 8012d92:	b085      	sub	sp, #20
 8012d94:	9001      	str	r0, [sp, #4]
 8012d96:	460b      	mov	r3, r1
 8012d98:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 8012d9c:	f10d 030f 	add.w	r3, sp, #15
 8012da0:	9801      	ldr	r0, [sp, #4]
 8012da2:	2120      	movs	r1, #32
 8012da4:	461a      	mov	r2, r3
 8012da6:	2301      	movs	r3, #1
 8012da8:	f7ff faba 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8012dac:	4603      	mov	r3, r0
 8012dae:	2b00      	cmp	r3, #0
 8012db0:	d101      	bne.n	8012db6 <LSM303AGR_ACC_W_LOWPWR_EN+0x26>
    return MEMS_ERROR;
 8012db2:	2300      	movs	r3, #0
 8012db4:	e01c      	b.n	8012df0 <LSM303AGR_ACC_W_LOWPWR_EN+0x60>

  value &= ~LSM303AGR_ACC_LPEN_MASK;
 8012db6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012dba:	f023 0308 	bic.w	r3, r3, #8
 8012dbe:	b2db      	uxtb	r3, r3
 8012dc0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012dc4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012dc8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012dcc:	4313      	orrs	r3, r2
 8012dce:	b2db      	uxtb	r3, r3
 8012dd0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 8012dd4:	f10d 030f 	add.w	r3, sp, #15
 8012dd8:	9801      	ldr	r0, [sp, #4]
 8012dda:	2120      	movs	r1, #32
 8012ddc:	461a      	mov	r2, r3
 8012dde:	2301      	movs	r3, #1
 8012de0:	f7ff fa7e 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8012de4:	4603      	mov	r3, r0
 8012de6:	2b00      	cmp	r3, #0
 8012de8:	d101      	bne.n	8012dee <LSM303AGR_ACC_W_LOWPWR_EN+0x5e>
    return MEMS_ERROR;
 8012dea:	2300      	movs	r3, #0
 8012dec:	e000      	b.n	8012df0 <LSM303AGR_ACC_W_LOWPWR_EN+0x60>

  return MEMS_SUCCESS;
 8012dee:	2301      	movs	r3, #1
}
 8012df0:	4618      	mov	r0, r3
 8012df2:	b005      	add	sp, #20
 8012df4:	f85d fb04 	ldr.w	pc, [sp], #4
 8012df8:	f3af 8000 	nop.w
 8012dfc:	f3af 8000 	nop.w

08012e00 <LSM303AGR_ACC_R_LOWPWR_EN>:
* Input          : Pointer to LSM303AGR_ACC_LPEN_t
* Output         : Status of LPEN see LSM303AGR_ACC_LPEN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_LOWPWR_EN(void *handle, LSM303AGR_ACC_LPEN_t *value)
{
 8012e00:	b500      	push	{lr}
 8012e02:	b083      	sub	sp, #12
 8012e04:	9001      	str	r0, [sp, #4]
 8012e06:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, (u8_t *)value, 1) )
 8012e08:	9801      	ldr	r0, [sp, #4]
 8012e0a:	2120      	movs	r1, #32
 8012e0c:	9a00      	ldr	r2, [sp, #0]
 8012e0e:	2301      	movs	r3, #1
 8012e10:	f7ff fa86 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8012e14:	4603      	mov	r3, r0
 8012e16:	2b00      	cmp	r3, #0
 8012e18:	d101      	bne.n	8012e1e <LSM303AGR_ACC_R_LOWPWR_EN+0x1e>
    return MEMS_ERROR;
 8012e1a:	2300      	movs	r3, #0
 8012e1c:	e007      	b.n	8012e2e <LSM303AGR_ACC_R_LOWPWR_EN+0x2e>

  *value &= LSM303AGR_ACC_LPEN_MASK; //mask
 8012e1e:	9b00      	ldr	r3, [sp, #0]
 8012e20:	781b      	ldrb	r3, [r3, #0]
 8012e22:	f003 0308 	and.w	r3, r3, #8
 8012e26:	b2da      	uxtb	r2, r3
 8012e28:	9b00      	ldr	r3, [sp, #0]
 8012e2a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012e2c:	2301      	movs	r3, #1
}
 8012e2e:	4618      	mov	r0, r3
 8012e30:	b003      	add	sp, #12
 8012e32:	f85d fb04 	ldr.w	pc, [sp], #4
 8012e36:	bf00      	nop
 8012e38:	f3af 8000 	nop.w
 8012e3c:	f3af 8000 	nop.w

08012e40 <LSM303AGR_ACC_W_hpf_aoi_en_int1>:
* Input          : LSM303AGR_ACC_HPIS1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_hpf_aoi_en_int1(void *handle, LSM303AGR_ACC_HPIS1_t newValue)
{
 8012e40:	b500      	push	{lr}
 8012e42:	b085      	sub	sp, #20
 8012e44:	9001      	str	r0, [sp, #4]
 8012e46:	460b      	mov	r3, r1
 8012e48:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8012e4c:	f10d 030f 	add.w	r3, sp, #15
 8012e50:	9801      	ldr	r0, [sp, #4]
 8012e52:	2121      	movs	r1, #33	; 0x21
 8012e54:	461a      	mov	r2, r3
 8012e56:	2301      	movs	r3, #1
 8012e58:	f7ff fa62 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8012e5c:	4603      	mov	r3, r0
 8012e5e:	2b00      	cmp	r3, #0
 8012e60:	d101      	bne.n	8012e66 <LSM303AGR_ACC_W_hpf_aoi_en_int1+0x26>
    return MEMS_ERROR;
 8012e62:	2300      	movs	r3, #0
 8012e64:	e01c      	b.n	8012ea0 <LSM303AGR_ACC_W_hpf_aoi_en_int1+0x60>

  value &= ~LSM303AGR_ACC_HPIS1_MASK;
 8012e66:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012e6a:	f023 0301 	bic.w	r3, r3, #1
 8012e6e:	b2db      	uxtb	r3, r3
 8012e70:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012e74:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012e78:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012e7c:	4313      	orrs	r3, r2
 8012e7e:	b2db      	uxtb	r3, r3
 8012e80:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8012e84:	f10d 030f 	add.w	r3, sp, #15
 8012e88:	9801      	ldr	r0, [sp, #4]
 8012e8a:	2121      	movs	r1, #33	; 0x21
 8012e8c:	461a      	mov	r2, r3
 8012e8e:	2301      	movs	r3, #1
 8012e90:	f7ff fa26 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8012e94:	4603      	mov	r3, r0
 8012e96:	2b00      	cmp	r3, #0
 8012e98:	d101      	bne.n	8012e9e <LSM303AGR_ACC_W_hpf_aoi_en_int1+0x5e>
    return MEMS_ERROR;
 8012e9a:	2300      	movs	r3, #0
 8012e9c:	e000      	b.n	8012ea0 <LSM303AGR_ACC_W_hpf_aoi_en_int1+0x60>

  return MEMS_SUCCESS;
 8012e9e:	2301      	movs	r3, #1
}
 8012ea0:	4618      	mov	r0, r3
 8012ea2:	b005      	add	sp, #20
 8012ea4:	f85d fb04 	ldr.w	pc, [sp], #4
 8012ea8:	f3af 8000 	nop.w
 8012eac:	f3af 8000 	nop.w

08012eb0 <LSM303AGR_ACC_R_hpf_aoi_en_int1>:
* Input          : Pointer to LSM303AGR_ACC_HPIS1_t
* Output         : Status of HPIS1 see LSM303AGR_ACC_HPIS1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_hpf_aoi_en_int1(void *handle, LSM303AGR_ACC_HPIS1_t *value)
{
 8012eb0:	b500      	push	{lr}
 8012eb2:	b083      	sub	sp, #12
 8012eb4:	9001      	str	r0, [sp, #4]
 8012eb6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, (u8_t *)value, 1) )
 8012eb8:	9801      	ldr	r0, [sp, #4]
 8012eba:	2121      	movs	r1, #33	; 0x21
 8012ebc:	9a00      	ldr	r2, [sp, #0]
 8012ebe:	2301      	movs	r3, #1
 8012ec0:	f7ff fa2e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8012ec4:	4603      	mov	r3, r0
 8012ec6:	2b00      	cmp	r3, #0
 8012ec8:	d101      	bne.n	8012ece <LSM303AGR_ACC_R_hpf_aoi_en_int1+0x1e>
    return MEMS_ERROR;
 8012eca:	2300      	movs	r3, #0
 8012ecc:	e007      	b.n	8012ede <LSM303AGR_ACC_R_hpf_aoi_en_int1+0x2e>

  *value &= LSM303AGR_ACC_HPIS1_MASK; //mask
 8012ece:	9b00      	ldr	r3, [sp, #0]
 8012ed0:	781b      	ldrb	r3, [r3, #0]
 8012ed2:	f003 0301 	and.w	r3, r3, #1
 8012ed6:	b2da      	uxtb	r2, r3
 8012ed8:	9b00      	ldr	r3, [sp, #0]
 8012eda:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012edc:	2301      	movs	r3, #1
}
 8012ede:	4618      	mov	r0, r3
 8012ee0:	b003      	add	sp, #12
 8012ee2:	f85d fb04 	ldr.w	pc, [sp], #4
 8012ee6:	bf00      	nop
 8012ee8:	f3af 8000 	nop.w
 8012eec:	f3af 8000 	nop.w

08012ef0 <LSM303AGR_ACC_W_hpf_aoi_en_int2>:
* Input          : LSM303AGR_ACC_HPIS2_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_hpf_aoi_en_int2(void *handle, LSM303AGR_ACC_HPIS2_t newValue)
{
 8012ef0:	b500      	push	{lr}
 8012ef2:	b085      	sub	sp, #20
 8012ef4:	9001      	str	r0, [sp, #4]
 8012ef6:	460b      	mov	r3, r1
 8012ef8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8012efc:	f10d 030f 	add.w	r3, sp, #15
 8012f00:	9801      	ldr	r0, [sp, #4]
 8012f02:	2121      	movs	r1, #33	; 0x21
 8012f04:	461a      	mov	r2, r3
 8012f06:	2301      	movs	r3, #1
 8012f08:	f7ff fa0a 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8012f0c:	4603      	mov	r3, r0
 8012f0e:	2b00      	cmp	r3, #0
 8012f10:	d101      	bne.n	8012f16 <LSM303AGR_ACC_W_hpf_aoi_en_int2+0x26>
    return MEMS_ERROR;
 8012f12:	2300      	movs	r3, #0
 8012f14:	e01c      	b.n	8012f50 <LSM303AGR_ACC_W_hpf_aoi_en_int2+0x60>

  value &= ~LSM303AGR_ACC_HPIS2_MASK;
 8012f16:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012f1a:	f023 0302 	bic.w	r3, r3, #2
 8012f1e:	b2db      	uxtb	r3, r3
 8012f20:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012f24:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012f28:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012f2c:	4313      	orrs	r3, r2
 8012f2e:	b2db      	uxtb	r3, r3
 8012f30:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8012f34:	f10d 030f 	add.w	r3, sp, #15
 8012f38:	9801      	ldr	r0, [sp, #4]
 8012f3a:	2121      	movs	r1, #33	; 0x21
 8012f3c:	461a      	mov	r2, r3
 8012f3e:	2301      	movs	r3, #1
 8012f40:	f7ff f9ce 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8012f44:	4603      	mov	r3, r0
 8012f46:	2b00      	cmp	r3, #0
 8012f48:	d101      	bne.n	8012f4e <LSM303AGR_ACC_W_hpf_aoi_en_int2+0x5e>
    return MEMS_ERROR;
 8012f4a:	2300      	movs	r3, #0
 8012f4c:	e000      	b.n	8012f50 <LSM303AGR_ACC_W_hpf_aoi_en_int2+0x60>

  return MEMS_SUCCESS;
 8012f4e:	2301      	movs	r3, #1
}
 8012f50:	4618      	mov	r0, r3
 8012f52:	b005      	add	sp, #20
 8012f54:	f85d fb04 	ldr.w	pc, [sp], #4
 8012f58:	f3af 8000 	nop.w
 8012f5c:	f3af 8000 	nop.w

08012f60 <LSM303AGR_ACC_R_hpf_aoi_en_int2>:
* Input          : Pointer to LSM303AGR_ACC_HPIS2_t
* Output         : Status of HPIS2 see LSM303AGR_ACC_HPIS2_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_hpf_aoi_en_int2(void *handle, LSM303AGR_ACC_HPIS2_t *value)
{
 8012f60:	b500      	push	{lr}
 8012f62:	b083      	sub	sp, #12
 8012f64:	9001      	str	r0, [sp, #4]
 8012f66:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, (u8_t *)value, 1) )
 8012f68:	9801      	ldr	r0, [sp, #4]
 8012f6a:	2121      	movs	r1, #33	; 0x21
 8012f6c:	9a00      	ldr	r2, [sp, #0]
 8012f6e:	2301      	movs	r3, #1
 8012f70:	f7ff f9d6 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8012f74:	4603      	mov	r3, r0
 8012f76:	2b00      	cmp	r3, #0
 8012f78:	d101      	bne.n	8012f7e <LSM303AGR_ACC_R_hpf_aoi_en_int2+0x1e>
    return MEMS_ERROR;
 8012f7a:	2300      	movs	r3, #0
 8012f7c:	e007      	b.n	8012f8e <LSM303AGR_ACC_R_hpf_aoi_en_int2+0x2e>

  *value &= LSM303AGR_ACC_HPIS2_MASK; //mask
 8012f7e:	9b00      	ldr	r3, [sp, #0]
 8012f80:	781b      	ldrb	r3, [r3, #0]
 8012f82:	f003 0302 	and.w	r3, r3, #2
 8012f86:	b2da      	uxtb	r2, r3
 8012f88:	9b00      	ldr	r3, [sp, #0]
 8012f8a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012f8c:	2301      	movs	r3, #1
}
 8012f8e:	4618      	mov	r0, r3
 8012f90:	b003      	add	sp, #12
 8012f92:	f85d fb04 	ldr.w	pc, [sp], #4
 8012f96:	bf00      	nop
 8012f98:	f3af 8000 	nop.w
 8012f9c:	f3af 8000 	nop.w

08012fa0 <LSM303AGR_ACC_W_hpf_click_en>:
* Input          : LSM303AGR_ACC_HPCLICK_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_hpf_click_en(void *handle, LSM303AGR_ACC_HPCLICK_t newValue)
{
 8012fa0:	b500      	push	{lr}
 8012fa2:	b085      	sub	sp, #20
 8012fa4:	9001      	str	r0, [sp, #4]
 8012fa6:	460b      	mov	r3, r1
 8012fa8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8012fac:	f10d 030f 	add.w	r3, sp, #15
 8012fb0:	9801      	ldr	r0, [sp, #4]
 8012fb2:	2121      	movs	r1, #33	; 0x21
 8012fb4:	461a      	mov	r2, r3
 8012fb6:	2301      	movs	r3, #1
 8012fb8:	f7ff f9b2 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8012fbc:	4603      	mov	r3, r0
 8012fbe:	2b00      	cmp	r3, #0
 8012fc0:	d101      	bne.n	8012fc6 <LSM303AGR_ACC_W_hpf_click_en+0x26>
    return MEMS_ERROR;
 8012fc2:	2300      	movs	r3, #0
 8012fc4:	e01c      	b.n	8013000 <LSM303AGR_ACC_W_hpf_click_en+0x60>

  value &= ~LSM303AGR_ACC_HPCLICK_MASK;
 8012fc6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012fca:	f023 0304 	bic.w	r3, r3, #4
 8012fce:	b2db      	uxtb	r3, r3
 8012fd0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012fd4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012fd8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012fdc:	4313      	orrs	r3, r2
 8012fde:	b2db      	uxtb	r3, r3
 8012fe0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8012fe4:	f10d 030f 	add.w	r3, sp, #15
 8012fe8:	9801      	ldr	r0, [sp, #4]
 8012fea:	2121      	movs	r1, #33	; 0x21
 8012fec:	461a      	mov	r2, r3
 8012fee:	2301      	movs	r3, #1
 8012ff0:	f7ff f976 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8012ff4:	4603      	mov	r3, r0
 8012ff6:	2b00      	cmp	r3, #0
 8012ff8:	d101      	bne.n	8012ffe <LSM303AGR_ACC_W_hpf_click_en+0x5e>
    return MEMS_ERROR;
 8012ffa:	2300      	movs	r3, #0
 8012ffc:	e000      	b.n	8013000 <LSM303AGR_ACC_W_hpf_click_en+0x60>

  return MEMS_SUCCESS;
 8012ffe:	2301      	movs	r3, #1
}
 8013000:	4618      	mov	r0, r3
 8013002:	b005      	add	sp, #20
 8013004:	f85d fb04 	ldr.w	pc, [sp], #4
 8013008:	f3af 8000 	nop.w
 801300c:	f3af 8000 	nop.w

08013010 <LSM303AGR_ACC_R_hpf_click_en>:
* Input          : Pointer to LSM303AGR_ACC_HPCLICK_t
* Output         : Status of HPCLICK see LSM303AGR_ACC_HPCLICK_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_hpf_click_en(void *handle, LSM303AGR_ACC_HPCLICK_t *value)
{
 8013010:	b500      	push	{lr}
 8013012:	b083      	sub	sp, #12
 8013014:	9001      	str	r0, [sp, #4]
 8013016:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, (u8_t *)value, 1) )
 8013018:	9801      	ldr	r0, [sp, #4]
 801301a:	2121      	movs	r1, #33	; 0x21
 801301c:	9a00      	ldr	r2, [sp, #0]
 801301e:	2301      	movs	r3, #1
 8013020:	f7ff f97e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013024:	4603      	mov	r3, r0
 8013026:	2b00      	cmp	r3, #0
 8013028:	d101      	bne.n	801302e <LSM303AGR_ACC_R_hpf_click_en+0x1e>
    return MEMS_ERROR;
 801302a:	2300      	movs	r3, #0
 801302c:	e007      	b.n	801303e <LSM303AGR_ACC_R_hpf_click_en+0x2e>

  *value &= LSM303AGR_ACC_HPCLICK_MASK; //mask
 801302e:	9b00      	ldr	r3, [sp, #0]
 8013030:	781b      	ldrb	r3, [r3, #0]
 8013032:	f003 0304 	and.w	r3, r3, #4
 8013036:	b2da      	uxtb	r2, r3
 8013038:	9b00      	ldr	r3, [sp, #0]
 801303a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801303c:	2301      	movs	r3, #1
}
 801303e:	4618      	mov	r0, r3
 8013040:	b003      	add	sp, #12
 8013042:	f85d fb04 	ldr.w	pc, [sp], #4
 8013046:	bf00      	nop
 8013048:	f3af 8000 	nop.w
 801304c:	f3af 8000 	nop.w

08013050 <LSM303AGR_ACC_W_Data_Filter>:
* Input          : LSM303AGR_ACC_FDS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Data_Filter(void *handle, LSM303AGR_ACC_FDS_t newValue)
{
 8013050:	b500      	push	{lr}
 8013052:	b085      	sub	sp, #20
 8013054:	9001      	str	r0, [sp, #4]
 8013056:	460b      	mov	r3, r1
 8013058:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 801305c:	f10d 030f 	add.w	r3, sp, #15
 8013060:	9801      	ldr	r0, [sp, #4]
 8013062:	2121      	movs	r1, #33	; 0x21
 8013064:	461a      	mov	r2, r3
 8013066:	2301      	movs	r3, #1
 8013068:	f7ff f95a 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 801306c:	4603      	mov	r3, r0
 801306e:	2b00      	cmp	r3, #0
 8013070:	d101      	bne.n	8013076 <LSM303AGR_ACC_W_Data_Filter+0x26>
    return MEMS_ERROR;
 8013072:	2300      	movs	r3, #0
 8013074:	e01c      	b.n	80130b0 <LSM303AGR_ACC_W_Data_Filter+0x60>

  value &= ~LSM303AGR_ACC_FDS_MASK;
 8013076:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801307a:	f023 0308 	bic.w	r3, r3, #8
 801307e:	b2db      	uxtb	r3, r3
 8013080:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013084:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013088:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801308c:	4313      	orrs	r3, r2
 801308e:	b2db      	uxtb	r3, r3
 8013090:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8013094:	f10d 030f 	add.w	r3, sp, #15
 8013098:	9801      	ldr	r0, [sp, #4]
 801309a:	2121      	movs	r1, #33	; 0x21
 801309c:	461a      	mov	r2, r3
 801309e:	2301      	movs	r3, #1
 80130a0:	f7ff f91e 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 80130a4:	4603      	mov	r3, r0
 80130a6:	2b00      	cmp	r3, #0
 80130a8:	d101      	bne.n	80130ae <LSM303AGR_ACC_W_Data_Filter+0x5e>
    return MEMS_ERROR;
 80130aa:	2300      	movs	r3, #0
 80130ac:	e000      	b.n	80130b0 <LSM303AGR_ACC_W_Data_Filter+0x60>

  return MEMS_SUCCESS;
 80130ae:	2301      	movs	r3, #1
}
 80130b0:	4618      	mov	r0, r3
 80130b2:	b005      	add	sp, #20
 80130b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80130b8:	f3af 8000 	nop.w
 80130bc:	f3af 8000 	nop.w

080130c0 <LSM303AGR_ACC_R_Data_Filter>:
* Input          : Pointer to LSM303AGR_ACC_FDS_t
* Output         : Status of FDS see LSM303AGR_ACC_FDS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Data_Filter(void *handle, LSM303AGR_ACC_FDS_t *value)
{
 80130c0:	b500      	push	{lr}
 80130c2:	b083      	sub	sp, #12
 80130c4:	9001      	str	r0, [sp, #4]
 80130c6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, (u8_t *)value, 1) )
 80130c8:	9801      	ldr	r0, [sp, #4]
 80130ca:	2121      	movs	r1, #33	; 0x21
 80130cc:	9a00      	ldr	r2, [sp, #0]
 80130ce:	2301      	movs	r3, #1
 80130d0:	f7ff f926 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80130d4:	4603      	mov	r3, r0
 80130d6:	2b00      	cmp	r3, #0
 80130d8:	d101      	bne.n	80130de <LSM303AGR_ACC_R_Data_Filter+0x1e>
    return MEMS_ERROR;
 80130da:	2300      	movs	r3, #0
 80130dc:	e007      	b.n	80130ee <LSM303AGR_ACC_R_Data_Filter+0x2e>

  *value &= LSM303AGR_ACC_FDS_MASK; //mask
 80130de:	9b00      	ldr	r3, [sp, #0]
 80130e0:	781b      	ldrb	r3, [r3, #0]
 80130e2:	f003 0308 	and.w	r3, r3, #8
 80130e6:	b2da      	uxtb	r2, r3
 80130e8:	9b00      	ldr	r3, [sp, #0]
 80130ea:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80130ec:	2301      	movs	r3, #1
}
 80130ee:	4618      	mov	r0, r3
 80130f0:	b003      	add	sp, #12
 80130f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80130f6:	bf00      	nop
 80130f8:	f3af 8000 	nop.w
 80130fc:	f3af 8000 	nop.w

08013100 <LSM303AGR_ACC_W_hpf_cutoff_freq>:
* Input          : LSM303AGR_ACC_HPCF_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_hpf_cutoff_freq(void *handle, LSM303AGR_ACC_HPCF_t newValue)
{
 8013100:	b500      	push	{lr}
 8013102:	b085      	sub	sp, #20
 8013104:	9001      	str	r0, [sp, #4]
 8013106:	460b      	mov	r3, r1
 8013108:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 801310c:	f10d 030f 	add.w	r3, sp, #15
 8013110:	9801      	ldr	r0, [sp, #4]
 8013112:	2121      	movs	r1, #33	; 0x21
 8013114:	461a      	mov	r2, r3
 8013116:	2301      	movs	r3, #1
 8013118:	f7ff f902 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 801311c:	4603      	mov	r3, r0
 801311e:	2b00      	cmp	r3, #0
 8013120:	d101      	bne.n	8013126 <LSM303AGR_ACC_W_hpf_cutoff_freq+0x26>
    return MEMS_ERROR;
 8013122:	2300      	movs	r3, #0
 8013124:	e01c      	b.n	8013160 <LSM303AGR_ACC_W_hpf_cutoff_freq+0x60>

  value &= ~LSM303AGR_ACC_HPCF_MASK;
 8013126:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801312a:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 801312e:	b2db      	uxtb	r3, r3
 8013130:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013134:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013138:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801313c:	4313      	orrs	r3, r2
 801313e:	b2db      	uxtb	r3, r3
 8013140:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8013144:	f10d 030f 	add.w	r3, sp, #15
 8013148:	9801      	ldr	r0, [sp, #4]
 801314a:	2121      	movs	r1, #33	; 0x21
 801314c:	461a      	mov	r2, r3
 801314e:	2301      	movs	r3, #1
 8013150:	f7ff f8c6 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8013154:	4603      	mov	r3, r0
 8013156:	2b00      	cmp	r3, #0
 8013158:	d101      	bne.n	801315e <LSM303AGR_ACC_W_hpf_cutoff_freq+0x5e>
    return MEMS_ERROR;
 801315a:	2300      	movs	r3, #0
 801315c:	e000      	b.n	8013160 <LSM303AGR_ACC_W_hpf_cutoff_freq+0x60>

  return MEMS_SUCCESS;
 801315e:	2301      	movs	r3, #1
}
 8013160:	4618      	mov	r0, r3
 8013162:	b005      	add	sp, #20
 8013164:	f85d fb04 	ldr.w	pc, [sp], #4
 8013168:	f3af 8000 	nop.w
 801316c:	f3af 8000 	nop.w

08013170 <LSM303AGR_ACC_R_hpf_cutoff_freq>:
* Input          : Pointer to LSM303AGR_ACC_HPCF_t
* Output         : Status of HPCF see LSM303AGR_ACC_HPCF_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_hpf_cutoff_freq(void *handle, LSM303AGR_ACC_HPCF_t *value)
{
 8013170:	b500      	push	{lr}
 8013172:	b083      	sub	sp, #12
 8013174:	9001      	str	r0, [sp, #4]
 8013176:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, (u8_t *)value, 1) )
 8013178:	9801      	ldr	r0, [sp, #4]
 801317a:	2121      	movs	r1, #33	; 0x21
 801317c:	9a00      	ldr	r2, [sp, #0]
 801317e:	2301      	movs	r3, #1
 8013180:	f7ff f8ce 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013184:	4603      	mov	r3, r0
 8013186:	2b00      	cmp	r3, #0
 8013188:	d101      	bne.n	801318e <LSM303AGR_ACC_R_hpf_cutoff_freq+0x1e>
    return MEMS_ERROR;
 801318a:	2300      	movs	r3, #0
 801318c:	e007      	b.n	801319e <LSM303AGR_ACC_R_hpf_cutoff_freq+0x2e>

  *value &= LSM303AGR_ACC_HPCF_MASK; //mask
 801318e:	9b00      	ldr	r3, [sp, #0]
 8013190:	781b      	ldrb	r3, [r3, #0]
 8013192:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8013196:	b2da      	uxtb	r2, r3
 8013198:	9b00      	ldr	r3, [sp, #0]
 801319a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801319c:	2301      	movs	r3, #1
}
 801319e:	4618      	mov	r0, r3
 80131a0:	b003      	add	sp, #12
 80131a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80131a6:	bf00      	nop
 80131a8:	f3af 8000 	nop.w
 80131ac:	f3af 8000 	nop.w

080131b0 <LSM303AGR_ACC_W_hpf_mode>:
* Input          : LSM303AGR_ACC_HPM_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_hpf_mode(void *handle, LSM303AGR_ACC_HPM_t newValue)
{
 80131b0:	b500      	push	{lr}
 80131b2:	b085      	sub	sp, #20
 80131b4:	9001      	str	r0, [sp, #4]
 80131b6:	460b      	mov	r3, r1
 80131b8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 80131bc:	f10d 030f 	add.w	r3, sp, #15
 80131c0:	9801      	ldr	r0, [sp, #4]
 80131c2:	2121      	movs	r1, #33	; 0x21
 80131c4:	461a      	mov	r2, r3
 80131c6:	2301      	movs	r3, #1
 80131c8:	f7ff f8aa 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80131cc:	4603      	mov	r3, r0
 80131ce:	2b00      	cmp	r3, #0
 80131d0:	d101      	bne.n	80131d6 <LSM303AGR_ACC_W_hpf_mode+0x26>
    return MEMS_ERROR;
 80131d2:	2300      	movs	r3, #0
 80131d4:	e01c      	b.n	8013210 <LSM303AGR_ACC_W_hpf_mode+0x60>

  value &= ~LSM303AGR_ACC_HPM_MASK;
 80131d6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80131da:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80131de:	b2db      	uxtb	r3, r3
 80131e0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80131e4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80131e8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80131ec:	4313      	orrs	r3, r2
 80131ee:	b2db      	uxtb	r3, r3
 80131f0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 80131f4:	f10d 030f 	add.w	r3, sp, #15
 80131f8:	9801      	ldr	r0, [sp, #4]
 80131fa:	2121      	movs	r1, #33	; 0x21
 80131fc:	461a      	mov	r2, r3
 80131fe:	2301      	movs	r3, #1
 8013200:	f7ff f86e 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8013204:	4603      	mov	r3, r0
 8013206:	2b00      	cmp	r3, #0
 8013208:	d101      	bne.n	801320e <LSM303AGR_ACC_W_hpf_mode+0x5e>
    return MEMS_ERROR;
 801320a:	2300      	movs	r3, #0
 801320c:	e000      	b.n	8013210 <LSM303AGR_ACC_W_hpf_mode+0x60>

  return MEMS_SUCCESS;
 801320e:	2301      	movs	r3, #1
}
 8013210:	4618      	mov	r0, r3
 8013212:	b005      	add	sp, #20
 8013214:	f85d fb04 	ldr.w	pc, [sp], #4
 8013218:	f3af 8000 	nop.w
 801321c:	f3af 8000 	nop.w

08013220 <LSM303AGR_ACC_R_hpf_mode>:
* Input          : Pointer to LSM303AGR_ACC_HPM_t
* Output         : Status of HPM see LSM303AGR_ACC_HPM_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_hpf_mode(void *handle, LSM303AGR_ACC_HPM_t *value)
{
 8013220:	b500      	push	{lr}
 8013222:	b083      	sub	sp, #12
 8013224:	9001      	str	r0, [sp, #4]
 8013226:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, (u8_t *)value, 1) )
 8013228:	9801      	ldr	r0, [sp, #4]
 801322a:	2121      	movs	r1, #33	; 0x21
 801322c:	9a00      	ldr	r2, [sp, #0]
 801322e:	2301      	movs	r3, #1
 8013230:	f7ff f876 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013234:	4603      	mov	r3, r0
 8013236:	2b00      	cmp	r3, #0
 8013238:	d101      	bne.n	801323e <LSM303AGR_ACC_R_hpf_mode+0x1e>
    return MEMS_ERROR;
 801323a:	2300      	movs	r3, #0
 801323c:	e007      	b.n	801324e <LSM303AGR_ACC_R_hpf_mode+0x2e>

  *value &= LSM303AGR_ACC_HPM_MASK; //mask
 801323e:	9b00      	ldr	r3, [sp, #0]
 8013240:	781b      	ldrb	r3, [r3, #0]
 8013242:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8013246:	b2da      	uxtb	r2, r3
 8013248:	9b00      	ldr	r3, [sp, #0]
 801324a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801324c:	2301      	movs	r3, #1
}
 801324e:	4618      	mov	r0, r3
 8013250:	b003      	add	sp, #12
 8013252:	f85d fb04 	ldr.w	pc, [sp], #4
 8013256:	bf00      	nop
 8013258:	f3af 8000 	nop.w
 801325c:	f3af 8000 	nop.w

08013260 <LSM303AGR_ACC_W_FIFO_Overrun_on_INT1>:
* Input          : LSM303AGR_ACC_I1_OVERRUN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_Overrun_on_INT1(void *handle, LSM303AGR_ACC_I1_OVERRUN_t newValue)
{
 8013260:	b500      	push	{lr}
 8013262:	b085      	sub	sp, #20
 8013264:	9001      	str	r0, [sp, #4]
 8013266:	460b      	mov	r3, r1
 8013268:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 801326c:	f10d 030f 	add.w	r3, sp, #15
 8013270:	9801      	ldr	r0, [sp, #4]
 8013272:	2122      	movs	r1, #34	; 0x22
 8013274:	461a      	mov	r2, r3
 8013276:	2301      	movs	r3, #1
 8013278:	f7ff f852 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 801327c:	4603      	mov	r3, r0
 801327e:	2b00      	cmp	r3, #0
 8013280:	d101      	bne.n	8013286 <LSM303AGR_ACC_W_FIFO_Overrun_on_INT1+0x26>
    return MEMS_ERROR;
 8013282:	2300      	movs	r3, #0
 8013284:	e01c      	b.n	80132c0 <LSM303AGR_ACC_W_FIFO_Overrun_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_OVERRUN_MASK;
 8013286:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801328a:	f023 0302 	bic.w	r3, r3, #2
 801328e:	b2db      	uxtb	r3, r3
 8013290:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013294:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013298:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801329c:	4313      	orrs	r3, r2
 801329e:	b2db      	uxtb	r3, r3
 80132a0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 80132a4:	f10d 030f 	add.w	r3, sp, #15
 80132a8:	9801      	ldr	r0, [sp, #4]
 80132aa:	2122      	movs	r1, #34	; 0x22
 80132ac:	461a      	mov	r2, r3
 80132ae:	2301      	movs	r3, #1
 80132b0:	f7ff f816 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 80132b4:	4603      	mov	r3, r0
 80132b6:	2b00      	cmp	r3, #0
 80132b8:	d101      	bne.n	80132be <LSM303AGR_ACC_W_FIFO_Overrun_on_INT1+0x5e>
    return MEMS_ERROR;
 80132ba:	2300      	movs	r3, #0
 80132bc:	e000      	b.n	80132c0 <LSM303AGR_ACC_W_FIFO_Overrun_on_INT1+0x60>

  return MEMS_SUCCESS;
 80132be:	2301      	movs	r3, #1
}
 80132c0:	4618      	mov	r0, r3
 80132c2:	b005      	add	sp, #20
 80132c4:	f85d fb04 	ldr.w	pc, [sp], #4
 80132c8:	f3af 8000 	nop.w
 80132cc:	f3af 8000 	nop.w

080132d0 <LSM303AGR_ACC_R_FIFO_Overrun_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_OVERRUN_t
* Output         : Status of I1_OVERRUN see LSM303AGR_ACC_I1_OVERRUN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_Overrun_on_INT1(void *handle, LSM303AGR_ACC_I1_OVERRUN_t *value)
{
 80132d0:	b500      	push	{lr}
 80132d2:	b083      	sub	sp, #12
 80132d4:	9001      	str	r0, [sp, #4]
 80132d6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 80132d8:	9801      	ldr	r0, [sp, #4]
 80132da:	2122      	movs	r1, #34	; 0x22
 80132dc:	9a00      	ldr	r2, [sp, #0]
 80132de:	2301      	movs	r3, #1
 80132e0:	f7ff f81e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80132e4:	4603      	mov	r3, r0
 80132e6:	2b00      	cmp	r3, #0
 80132e8:	d101      	bne.n	80132ee <LSM303AGR_ACC_R_FIFO_Overrun_on_INT1+0x1e>
    return MEMS_ERROR;
 80132ea:	2300      	movs	r3, #0
 80132ec:	e007      	b.n	80132fe <LSM303AGR_ACC_R_FIFO_Overrun_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_OVERRUN_MASK; //mask
 80132ee:	9b00      	ldr	r3, [sp, #0]
 80132f0:	781b      	ldrb	r3, [r3, #0]
 80132f2:	f003 0302 	and.w	r3, r3, #2
 80132f6:	b2da      	uxtb	r2, r3
 80132f8:	9b00      	ldr	r3, [sp, #0]
 80132fa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80132fc:	2301      	movs	r3, #1
}
 80132fe:	4618      	mov	r0, r3
 8013300:	b003      	add	sp, #12
 8013302:	f85d fb04 	ldr.w	pc, [sp], #4
 8013306:	bf00      	nop
 8013308:	f3af 8000 	nop.w
 801330c:	f3af 8000 	nop.w

08013310 <LSM303AGR_ACC_W_FIFO_Watermark_on_INT1>:
* Input          : LSM303AGR_ACC_I1_WTM_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_Watermark_on_INT1(void *handle, LSM303AGR_ACC_I1_WTM_t newValue)
{
 8013310:	b500      	push	{lr}
 8013312:	b085      	sub	sp, #20
 8013314:	9001      	str	r0, [sp, #4]
 8013316:	460b      	mov	r3, r1
 8013318:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 801331c:	f10d 030f 	add.w	r3, sp, #15
 8013320:	9801      	ldr	r0, [sp, #4]
 8013322:	2122      	movs	r1, #34	; 0x22
 8013324:	461a      	mov	r2, r3
 8013326:	2301      	movs	r3, #1
 8013328:	f7fe fffa 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 801332c:	4603      	mov	r3, r0
 801332e:	2b00      	cmp	r3, #0
 8013330:	d101      	bne.n	8013336 <LSM303AGR_ACC_W_FIFO_Watermark_on_INT1+0x26>
    return MEMS_ERROR;
 8013332:	2300      	movs	r3, #0
 8013334:	e01c      	b.n	8013370 <LSM303AGR_ACC_W_FIFO_Watermark_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_WTM_MASK;
 8013336:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801333a:	f023 0304 	bic.w	r3, r3, #4
 801333e:	b2db      	uxtb	r3, r3
 8013340:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013344:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013348:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801334c:	4313      	orrs	r3, r2
 801334e:	b2db      	uxtb	r3, r3
 8013350:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8013354:	f10d 030f 	add.w	r3, sp, #15
 8013358:	9801      	ldr	r0, [sp, #4]
 801335a:	2122      	movs	r1, #34	; 0x22
 801335c:	461a      	mov	r2, r3
 801335e:	2301      	movs	r3, #1
 8013360:	f7fe ffbe 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8013364:	4603      	mov	r3, r0
 8013366:	2b00      	cmp	r3, #0
 8013368:	d101      	bne.n	801336e <LSM303AGR_ACC_W_FIFO_Watermark_on_INT1+0x5e>
    return MEMS_ERROR;
 801336a:	2300      	movs	r3, #0
 801336c:	e000      	b.n	8013370 <LSM303AGR_ACC_W_FIFO_Watermark_on_INT1+0x60>

  return MEMS_SUCCESS;
 801336e:	2301      	movs	r3, #1
}
 8013370:	4618      	mov	r0, r3
 8013372:	b005      	add	sp, #20
 8013374:	f85d fb04 	ldr.w	pc, [sp], #4
 8013378:	f3af 8000 	nop.w
 801337c:	f3af 8000 	nop.w

08013380 <LSM303AGR_ACC_R_FIFO_Watermark_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_WTM_t
* Output         : Status of I1_WTM see LSM303AGR_ACC_I1_WTM_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_Watermark_on_INT1(void *handle, LSM303AGR_ACC_I1_WTM_t *value)
{
 8013380:	b500      	push	{lr}
 8013382:	b083      	sub	sp, #12
 8013384:	9001      	str	r0, [sp, #4]
 8013386:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 8013388:	9801      	ldr	r0, [sp, #4]
 801338a:	2122      	movs	r1, #34	; 0x22
 801338c:	9a00      	ldr	r2, [sp, #0]
 801338e:	2301      	movs	r3, #1
 8013390:	f7fe ffc6 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013394:	4603      	mov	r3, r0
 8013396:	2b00      	cmp	r3, #0
 8013398:	d101      	bne.n	801339e <LSM303AGR_ACC_R_FIFO_Watermark_on_INT1+0x1e>
    return MEMS_ERROR;
 801339a:	2300      	movs	r3, #0
 801339c:	e007      	b.n	80133ae <LSM303AGR_ACC_R_FIFO_Watermark_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_WTM_MASK; //mask
 801339e:	9b00      	ldr	r3, [sp, #0]
 80133a0:	781b      	ldrb	r3, [r3, #0]
 80133a2:	f003 0304 	and.w	r3, r3, #4
 80133a6:	b2da      	uxtb	r2, r3
 80133a8:	9b00      	ldr	r3, [sp, #0]
 80133aa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80133ac:	2301      	movs	r3, #1
}
 80133ae:	4618      	mov	r0, r3
 80133b0:	b003      	add	sp, #12
 80133b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80133b6:	bf00      	nop
 80133b8:	f3af 8000 	nop.w
 80133bc:	f3af 8000 	nop.w

080133c0 <LSM303AGR_ACC_W_FIFO_DRDY2_on_INT1>:
* Input          : LSM303AGR_ACC_I1_DRDY2_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_DRDY2_on_INT1(void *handle, LSM303AGR_ACC_I1_DRDY2_t newValue)
{
 80133c0:	b500      	push	{lr}
 80133c2:	b085      	sub	sp, #20
 80133c4:	9001      	str	r0, [sp, #4]
 80133c6:	460b      	mov	r3, r1
 80133c8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 80133cc:	f10d 030f 	add.w	r3, sp, #15
 80133d0:	9801      	ldr	r0, [sp, #4]
 80133d2:	2122      	movs	r1, #34	; 0x22
 80133d4:	461a      	mov	r2, r3
 80133d6:	2301      	movs	r3, #1
 80133d8:	f7fe ffa2 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80133dc:	4603      	mov	r3, r0
 80133de:	2b00      	cmp	r3, #0
 80133e0:	d101      	bne.n	80133e6 <LSM303AGR_ACC_W_FIFO_DRDY2_on_INT1+0x26>
    return MEMS_ERROR;
 80133e2:	2300      	movs	r3, #0
 80133e4:	e01c      	b.n	8013420 <LSM303AGR_ACC_W_FIFO_DRDY2_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_DRDY2_MASK;
 80133e6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80133ea:	f023 0308 	bic.w	r3, r3, #8
 80133ee:	b2db      	uxtb	r3, r3
 80133f0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80133f4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80133f8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80133fc:	4313      	orrs	r3, r2
 80133fe:	b2db      	uxtb	r3, r3
 8013400:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8013404:	f10d 030f 	add.w	r3, sp, #15
 8013408:	9801      	ldr	r0, [sp, #4]
 801340a:	2122      	movs	r1, #34	; 0x22
 801340c:	461a      	mov	r2, r3
 801340e:	2301      	movs	r3, #1
 8013410:	f7fe ff66 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8013414:	4603      	mov	r3, r0
 8013416:	2b00      	cmp	r3, #0
 8013418:	d101      	bne.n	801341e <LSM303AGR_ACC_W_FIFO_DRDY2_on_INT1+0x5e>
    return MEMS_ERROR;
 801341a:	2300      	movs	r3, #0
 801341c:	e000      	b.n	8013420 <LSM303AGR_ACC_W_FIFO_DRDY2_on_INT1+0x60>

  return MEMS_SUCCESS;
 801341e:	2301      	movs	r3, #1
}
 8013420:	4618      	mov	r0, r3
 8013422:	b005      	add	sp, #20
 8013424:	f85d fb04 	ldr.w	pc, [sp], #4
 8013428:	f3af 8000 	nop.w
 801342c:	f3af 8000 	nop.w

08013430 <LSM303AGR_ACC_R_FIFO_DRDY2_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_DRDY2_t
* Output         : Status of I1_DRDY2 see LSM303AGR_ACC_I1_DRDY2_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_DRDY2_on_INT1(void *handle, LSM303AGR_ACC_I1_DRDY2_t *value)
{
 8013430:	b500      	push	{lr}
 8013432:	b083      	sub	sp, #12
 8013434:	9001      	str	r0, [sp, #4]
 8013436:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 8013438:	9801      	ldr	r0, [sp, #4]
 801343a:	2122      	movs	r1, #34	; 0x22
 801343c:	9a00      	ldr	r2, [sp, #0]
 801343e:	2301      	movs	r3, #1
 8013440:	f7fe ff6e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013444:	4603      	mov	r3, r0
 8013446:	2b00      	cmp	r3, #0
 8013448:	d101      	bne.n	801344e <LSM303AGR_ACC_R_FIFO_DRDY2_on_INT1+0x1e>
    return MEMS_ERROR;
 801344a:	2300      	movs	r3, #0
 801344c:	e007      	b.n	801345e <LSM303AGR_ACC_R_FIFO_DRDY2_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_DRDY2_MASK; //mask
 801344e:	9b00      	ldr	r3, [sp, #0]
 8013450:	781b      	ldrb	r3, [r3, #0]
 8013452:	f003 0308 	and.w	r3, r3, #8
 8013456:	b2da      	uxtb	r2, r3
 8013458:	9b00      	ldr	r3, [sp, #0]
 801345a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801345c:	2301      	movs	r3, #1
}
 801345e:	4618      	mov	r0, r3
 8013460:	b003      	add	sp, #12
 8013462:	f85d fb04 	ldr.w	pc, [sp], #4
 8013466:	bf00      	nop
 8013468:	f3af 8000 	nop.w
 801346c:	f3af 8000 	nop.w

08013470 <LSM303AGR_ACC_W_FIFO_DRDY1_on_INT1>:
* Input          : LSM303AGR_ACC_I1_DRDY1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_DRDY1_on_INT1(void *handle, LSM303AGR_ACC_I1_DRDY1_t newValue)
{
 8013470:	b500      	push	{lr}
 8013472:	b085      	sub	sp, #20
 8013474:	9001      	str	r0, [sp, #4]
 8013476:	460b      	mov	r3, r1
 8013478:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 801347c:	f10d 030f 	add.w	r3, sp, #15
 8013480:	9801      	ldr	r0, [sp, #4]
 8013482:	2122      	movs	r1, #34	; 0x22
 8013484:	461a      	mov	r2, r3
 8013486:	2301      	movs	r3, #1
 8013488:	f7fe ff4a 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 801348c:	4603      	mov	r3, r0
 801348e:	2b00      	cmp	r3, #0
 8013490:	d101      	bne.n	8013496 <LSM303AGR_ACC_W_FIFO_DRDY1_on_INT1+0x26>
    return MEMS_ERROR;
 8013492:	2300      	movs	r3, #0
 8013494:	e01c      	b.n	80134d0 <LSM303AGR_ACC_W_FIFO_DRDY1_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_DRDY1_MASK;
 8013496:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801349a:	f023 0310 	bic.w	r3, r3, #16
 801349e:	b2db      	uxtb	r3, r3
 80134a0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80134a4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80134a8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80134ac:	4313      	orrs	r3, r2
 80134ae:	b2db      	uxtb	r3, r3
 80134b0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 80134b4:	f10d 030f 	add.w	r3, sp, #15
 80134b8:	9801      	ldr	r0, [sp, #4]
 80134ba:	2122      	movs	r1, #34	; 0x22
 80134bc:	461a      	mov	r2, r3
 80134be:	2301      	movs	r3, #1
 80134c0:	f7fe ff0e 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 80134c4:	4603      	mov	r3, r0
 80134c6:	2b00      	cmp	r3, #0
 80134c8:	d101      	bne.n	80134ce <LSM303AGR_ACC_W_FIFO_DRDY1_on_INT1+0x5e>
    return MEMS_ERROR;
 80134ca:	2300      	movs	r3, #0
 80134cc:	e000      	b.n	80134d0 <LSM303AGR_ACC_W_FIFO_DRDY1_on_INT1+0x60>

  return MEMS_SUCCESS;
 80134ce:	2301      	movs	r3, #1
}
 80134d0:	4618      	mov	r0, r3
 80134d2:	b005      	add	sp, #20
 80134d4:	f85d fb04 	ldr.w	pc, [sp], #4
 80134d8:	f3af 8000 	nop.w
 80134dc:	f3af 8000 	nop.w

080134e0 <LSM303AGR_ACC_R_FIFO_DRDY1_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_DRDY1_t
* Output         : Status of I1_DRDY1 see LSM303AGR_ACC_I1_DRDY1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_DRDY1_on_INT1(void *handle, LSM303AGR_ACC_I1_DRDY1_t *value)
{
 80134e0:	b500      	push	{lr}
 80134e2:	b083      	sub	sp, #12
 80134e4:	9001      	str	r0, [sp, #4]
 80134e6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 80134e8:	9801      	ldr	r0, [sp, #4]
 80134ea:	2122      	movs	r1, #34	; 0x22
 80134ec:	9a00      	ldr	r2, [sp, #0]
 80134ee:	2301      	movs	r3, #1
 80134f0:	f7fe ff16 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80134f4:	4603      	mov	r3, r0
 80134f6:	2b00      	cmp	r3, #0
 80134f8:	d101      	bne.n	80134fe <LSM303AGR_ACC_R_FIFO_DRDY1_on_INT1+0x1e>
    return MEMS_ERROR;
 80134fa:	2300      	movs	r3, #0
 80134fc:	e007      	b.n	801350e <LSM303AGR_ACC_R_FIFO_DRDY1_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_DRDY1_MASK; //mask
 80134fe:	9b00      	ldr	r3, [sp, #0]
 8013500:	781b      	ldrb	r3, [r3, #0]
 8013502:	f003 0310 	and.w	r3, r3, #16
 8013506:	b2da      	uxtb	r2, r3
 8013508:	9b00      	ldr	r3, [sp, #0]
 801350a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801350c:	2301      	movs	r3, #1
}
 801350e:	4618      	mov	r0, r3
 8013510:	b003      	add	sp, #12
 8013512:	f85d fb04 	ldr.w	pc, [sp], #4
 8013516:	bf00      	nop
 8013518:	f3af 8000 	nop.w
 801351c:	f3af 8000 	nop.w

08013520 <LSM303AGR_ACC_W_FIFO_AOL2_on_INT1>:
* Input          : LSM303AGR_ACC_I1_AOI2_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_AOL2_on_INT1(void *handle, LSM303AGR_ACC_I1_AOI2_t newValue)
{
 8013520:	b500      	push	{lr}
 8013522:	b085      	sub	sp, #20
 8013524:	9001      	str	r0, [sp, #4]
 8013526:	460b      	mov	r3, r1
 8013528:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 801352c:	f10d 030f 	add.w	r3, sp, #15
 8013530:	9801      	ldr	r0, [sp, #4]
 8013532:	2122      	movs	r1, #34	; 0x22
 8013534:	461a      	mov	r2, r3
 8013536:	2301      	movs	r3, #1
 8013538:	f7fe fef2 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 801353c:	4603      	mov	r3, r0
 801353e:	2b00      	cmp	r3, #0
 8013540:	d101      	bne.n	8013546 <LSM303AGR_ACC_W_FIFO_AOL2_on_INT1+0x26>
    return MEMS_ERROR;
 8013542:	2300      	movs	r3, #0
 8013544:	e01c      	b.n	8013580 <LSM303AGR_ACC_W_FIFO_AOL2_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_AOI2_MASK;
 8013546:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801354a:	f023 0320 	bic.w	r3, r3, #32
 801354e:	b2db      	uxtb	r3, r3
 8013550:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013554:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013558:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801355c:	4313      	orrs	r3, r2
 801355e:	b2db      	uxtb	r3, r3
 8013560:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8013564:	f10d 030f 	add.w	r3, sp, #15
 8013568:	9801      	ldr	r0, [sp, #4]
 801356a:	2122      	movs	r1, #34	; 0x22
 801356c:	461a      	mov	r2, r3
 801356e:	2301      	movs	r3, #1
 8013570:	f7fe feb6 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8013574:	4603      	mov	r3, r0
 8013576:	2b00      	cmp	r3, #0
 8013578:	d101      	bne.n	801357e <LSM303AGR_ACC_W_FIFO_AOL2_on_INT1+0x5e>
    return MEMS_ERROR;
 801357a:	2300      	movs	r3, #0
 801357c:	e000      	b.n	8013580 <LSM303AGR_ACC_W_FIFO_AOL2_on_INT1+0x60>

  return MEMS_SUCCESS;
 801357e:	2301      	movs	r3, #1
}
 8013580:	4618      	mov	r0, r3
 8013582:	b005      	add	sp, #20
 8013584:	f85d fb04 	ldr.w	pc, [sp], #4
 8013588:	f3af 8000 	nop.w
 801358c:	f3af 8000 	nop.w

08013590 <LSM303AGR_ACC_R_FIFO_AOL2_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_AOI2_t
* Output         : Status of I1_AOI2 see LSM303AGR_ACC_I1_AOI2_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_AOL2_on_INT1(void *handle, LSM303AGR_ACC_I1_AOI2_t *value)
{
 8013590:	b500      	push	{lr}
 8013592:	b083      	sub	sp, #12
 8013594:	9001      	str	r0, [sp, #4]
 8013596:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 8013598:	9801      	ldr	r0, [sp, #4]
 801359a:	2122      	movs	r1, #34	; 0x22
 801359c:	9a00      	ldr	r2, [sp, #0]
 801359e:	2301      	movs	r3, #1
 80135a0:	f7fe febe 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80135a4:	4603      	mov	r3, r0
 80135a6:	2b00      	cmp	r3, #0
 80135a8:	d101      	bne.n	80135ae <LSM303AGR_ACC_R_FIFO_AOL2_on_INT1+0x1e>
    return MEMS_ERROR;
 80135aa:	2300      	movs	r3, #0
 80135ac:	e007      	b.n	80135be <LSM303AGR_ACC_R_FIFO_AOL2_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_AOI2_MASK; //mask
 80135ae:	9b00      	ldr	r3, [sp, #0]
 80135b0:	781b      	ldrb	r3, [r3, #0]
 80135b2:	f003 0320 	and.w	r3, r3, #32
 80135b6:	b2da      	uxtb	r2, r3
 80135b8:	9b00      	ldr	r3, [sp, #0]
 80135ba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80135bc:	2301      	movs	r3, #1
}
 80135be:	4618      	mov	r0, r3
 80135c0:	b003      	add	sp, #12
 80135c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80135c6:	bf00      	nop
 80135c8:	f3af 8000 	nop.w
 80135cc:	f3af 8000 	nop.w

080135d0 <LSM303AGR_ACC_W_FIFO_AOL1_on_INT1>:
* Input          : LSM303AGR_ACC_I1_AOI1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_AOL1_on_INT1(void *handle, LSM303AGR_ACC_I1_AOI1_t newValue)
{
 80135d0:	b500      	push	{lr}
 80135d2:	b085      	sub	sp, #20
 80135d4:	9001      	str	r0, [sp, #4]
 80135d6:	460b      	mov	r3, r1
 80135d8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 80135dc:	f10d 030f 	add.w	r3, sp, #15
 80135e0:	9801      	ldr	r0, [sp, #4]
 80135e2:	2122      	movs	r1, #34	; 0x22
 80135e4:	461a      	mov	r2, r3
 80135e6:	2301      	movs	r3, #1
 80135e8:	f7fe fe9a 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80135ec:	4603      	mov	r3, r0
 80135ee:	2b00      	cmp	r3, #0
 80135f0:	d101      	bne.n	80135f6 <LSM303AGR_ACC_W_FIFO_AOL1_on_INT1+0x26>
    return MEMS_ERROR;
 80135f2:	2300      	movs	r3, #0
 80135f4:	e01c      	b.n	8013630 <LSM303AGR_ACC_W_FIFO_AOL1_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_AOI1_MASK;
 80135f6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80135fa:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80135fe:	b2db      	uxtb	r3, r3
 8013600:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013604:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013608:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801360c:	4313      	orrs	r3, r2
 801360e:	b2db      	uxtb	r3, r3
 8013610:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8013614:	f10d 030f 	add.w	r3, sp, #15
 8013618:	9801      	ldr	r0, [sp, #4]
 801361a:	2122      	movs	r1, #34	; 0x22
 801361c:	461a      	mov	r2, r3
 801361e:	2301      	movs	r3, #1
 8013620:	f7fe fe5e 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8013624:	4603      	mov	r3, r0
 8013626:	2b00      	cmp	r3, #0
 8013628:	d101      	bne.n	801362e <LSM303AGR_ACC_W_FIFO_AOL1_on_INT1+0x5e>
    return MEMS_ERROR;
 801362a:	2300      	movs	r3, #0
 801362c:	e000      	b.n	8013630 <LSM303AGR_ACC_W_FIFO_AOL1_on_INT1+0x60>

  return MEMS_SUCCESS;
 801362e:	2301      	movs	r3, #1
}
 8013630:	4618      	mov	r0, r3
 8013632:	b005      	add	sp, #20
 8013634:	f85d fb04 	ldr.w	pc, [sp], #4
 8013638:	f3af 8000 	nop.w
 801363c:	f3af 8000 	nop.w

08013640 <LSM303AGR_ACC_R_FIFO_AOL1_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_AOI1_t
* Output         : Status of I1_AOI1 see LSM303AGR_ACC_I1_AOI1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_AOL1_on_INT1(void *handle, LSM303AGR_ACC_I1_AOI1_t *value)
{
 8013640:	b500      	push	{lr}
 8013642:	b083      	sub	sp, #12
 8013644:	9001      	str	r0, [sp, #4]
 8013646:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 8013648:	9801      	ldr	r0, [sp, #4]
 801364a:	2122      	movs	r1, #34	; 0x22
 801364c:	9a00      	ldr	r2, [sp, #0]
 801364e:	2301      	movs	r3, #1
 8013650:	f7fe fe66 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013654:	4603      	mov	r3, r0
 8013656:	2b00      	cmp	r3, #0
 8013658:	d101      	bne.n	801365e <LSM303AGR_ACC_R_FIFO_AOL1_on_INT1+0x1e>
    return MEMS_ERROR;
 801365a:	2300      	movs	r3, #0
 801365c:	e007      	b.n	801366e <LSM303AGR_ACC_R_FIFO_AOL1_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_AOI1_MASK; //mask
 801365e:	9b00      	ldr	r3, [sp, #0]
 8013660:	781b      	ldrb	r3, [r3, #0]
 8013662:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8013666:	b2da      	uxtb	r2, r3
 8013668:	9b00      	ldr	r3, [sp, #0]
 801366a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801366c:	2301      	movs	r3, #1
}
 801366e:	4618      	mov	r0, r3
 8013670:	b003      	add	sp, #12
 8013672:	f85d fb04 	ldr.w	pc, [sp], #4
 8013676:	bf00      	nop
 8013678:	f3af 8000 	nop.w
 801367c:	f3af 8000 	nop.w

08013680 <LSM303AGR_ACC_W_FIFO_Click_on_INT1>:
* Input          : LSM303AGR_ACC_I1_CLICK_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_Click_on_INT1(void *handle, LSM303AGR_ACC_I1_CLICK_t newValue)
{
 8013680:	b500      	push	{lr}
 8013682:	b085      	sub	sp, #20
 8013684:	9001      	str	r0, [sp, #4]
 8013686:	460b      	mov	r3, r1
 8013688:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 801368c:	f10d 030f 	add.w	r3, sp, #15
 8013690:	9801      	ldr	r0, [sp, #4]
 8013692:	2122      	movs	r1, #34	; 0x22
 8013694:	461a      	mov	r2, r3
 8013696:	2301      	movs	r3, #1
 8013698:	f7fe fe42 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 801369c:	4603      	mov	r3, r0
 801369e:	2b00      	cmp	r3, #0
 80136a0:	d101      	bne.n	80136a6 <LSM303AGR_ACC_W_FIFO_Click_on_INT1+0x26>
    return MEMS_ERROR;
 80136a2:	2300      	movs	r3, #0
 80136a4:	e01c      	b.n	80136e0 <LSM303AGR_ACC_W_FIFO_Click_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_CLICK_MASK;
 80136a6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80136aa:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80136ae:	b2db      	uxtb	r3, r3
 80136b0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80136b4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80136b8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80136bc:	4313      	orrs	r3, r2
 80136be:	b2db      	uxtb	r3, r3
 80136c0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 80136c4:	f10d 030f 	add.w	r3, sp, #15
 80136c8:	9801      	ldr	r0, [sp, #4]
 80136ca:	2122      	movs	r1, #34	; 0x22
 80136cc:	461a      	mov	r2, r3
 80136ce:	2301      	movs	r3, #1
 80136d0:	f7fe fe06 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 80136d4:	4603      	mov	r3, r0
 80136d6:	2b00      	cmp	r3, #0
 80136d8:	d101      	bne.n	80136de <LSM303AGR_ACC_W_FIFO_Click_on_INT1+0x5e>
    return MEMS_ERROR;
 80136da:	2300      	movs	r3, #0
 80136dc:	e000      	b.n	80136e0 <LSM303AGR_ACC_W_FIFO_Click_on_INT1+0x60>

  return MEMS_SUCCESS;
 80136de:	2301      	movs	r3, #1
}
 80136e0:	4618      	mov	r0, r3
 80136e2:	b005      	add	sp, #20
 80136e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80136e8:	f3af 8000 	nop.w
 80136ec:	f3af 8000 	nop.w

080136f0 <LSM303AGR_ACC_R_FIFO_Click_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_CLICK_t
* Output         : Status of I1_CLICK see LSM303AGR_ACC_I1_CLICK_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_Click_on_INT1(void *handle, LSM303AGR_ACC_I1_CLICK_t *value)
{
 80136f0:	b500      	push	{lr}
 80136f2:	b083      	sub	sp, #12
 80136f4:	9001      	str	r0, [sp, #4]
 80136f6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 80136f8:	9801      	ldr	r0, [sp, #4]
 80136fa:	2122      	movs	r1, #34	; 0x22
 80136fc:	9a00      	ldr	r2, [sp, #0]
 80136fe:	2301      	movs	r3, #1
 8013700:	f7fe fe0e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013704:	4603      	mov	r3, r0
 8013706:	2b00      	cmp	r3, #0
 8013708:	d101      	bne.n	801370e <LSM303AGR_ACC_R_FIFO_Click_on_INT1+0x1e>
    return MEMS_ERROR;
 801370a:	2300      	movs	r3, #0
 801370c:	e007      	b.n	801371e <LSM303AGR_ACC_R_FIFO_Click_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_CLICK_MASK; //mask
 801370e:	9b00      	ldr	r3, [sp, #0]
 8013710:	781b      	ldrb	r3, [r3, #0]
 8013712:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8013716:	b2da      	uxtb	r2, r3
 8013718:	9b00      	ldr	r3, [sp, #0]
 801371a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801371c:	2301      	movs	r3, #1
}
 801371e:	4618      	mov	r0, r3
 8013720:	b003      	add	sp, #12
 8013722:	f85d fb04 	ldr.w	pc, [sp], #4
 8013726:	bf00      	nop
 8013728:	f3af 8000 	nop.w
 801372c:	f3af 8000 	nop.w

08013730 <LSM303AGR_ACC_W_SPI_mode>:
* Input          : LSM303AGR_ACC_SIM_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_SPI_mode(void *handle, LSM303AGR_ACC_SIM_t newValue)
{
 8013730:	b500      	push	{lr}
 8013732:	b085      	sub	sp, #20
 8013734:	9001      	str	r0, [sp, #4]
 8013736:	460b      	mov	r3, r1
 8013738:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 801373c:	f10d 030f 	add.w	r3, sp, #15
 8013740:	9801      	ldr	r0, [sp, #4]
 8013742:	2123      	movs	r1, #35	; 0x23
 8013744:	461a      	mov	r2, r3
 8013746:	2301      	movs	r3, #1
 8013748:	f7fe fdea 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 801374c:	4603      	mov	r3, r0
 801374e:	2b00      	cmp	r3, #0
 8013750:	d101      	bne.n	8013756 <LSM303AGR_ACC_W_SPI_mode+0x26>
    return MEMS_ERROR;
 8013752:	2300      	movs	r3, #0
 8013754:	e01c      	b.n	8013790 <LSM303AGR_ACC_W_SPI_mode+0x60>

  value &= ~LSM303AGR_ACC_SIM_MASK;
 8013756:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801375a:	f023 0301 	bic.w	r3, r3, #1
 801375e:	b2db      	uxtb	r3, r3
 8013760:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013764:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013768:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801376c:	4313      	orrs	r3, r2
 801376e:	b2db      	uxtb	r3, r3
 8013770:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 8013774:	f10d 030f 	add.w	r3, sp, #15
 8013778:	9801      	ldr	r0, [sp, #4]
 801377a:	2123      	movs	r1, #35	; 0x23
 801377c:	461a      	mov	r2, r3
 801377e:	2301      	movs	r3, #1
 8013780:	f7fe fdae 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8013784:	4603      	mov	r3, r0
 8013786:	2b00      	cmp	r3, #0
 8013788:	d101      	bne.n	801378e <LSM303AGR_ACC_W_SPI_mode+0x5e>
    return MEMS_ERROR;
 801378a:	2300      	movs	r3, #0
 801378c:	e000      	b.n	8013790 <LSM303AGR_ACC_W_SPI_mode+0x60>

  return MEMS_SUCCESS;
 801378e:	2301      	movs	r3, #1
}
 8013790:	4618      	mov	r0, r3
 8013792:	b005      	add	sp, #20
 8013794:	f85d fb04 	ldr.w	pc, [sp], #4
 8013798:	f3af 8000 	nop.w
 801379c:	f3af 8000 	nop.w

080137a0 <LSM303AGR_ACC_R_SPI_mode>:
* Input          : Pointer to LSM303AGR_ACC_SIM_t
* Output         : Status of SIM see LSM303AGR_ACC_SIM_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_SPI_mode(void *handle, LSM303AGR_ACC_SIM_t *value)
{
 80137a0:	b500      	push	{lr}
 80137a2:	b083      	sub	sp, #12
 80137a4:	9001      	str	r0, [sp, #4]
 80137a6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
 80137a8:	9801      	ldr	r0, [sp, #4]
 80137aa:	2123      	movs	r1, #35	; 0x23
 80137ac:	9a00      	ldr	r2, [sp, #0]
 80137ae:	2301      	movs	r3, #1
 80137b0:	f7fe fdb6 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80137b4:	4603      	mov	r3, r0
 80137b6:	2b00      	cmp	r3, #0
 80137b8:	d101      	bne.n	80137be <LSM303AGR_ACC_R_SPI_mode+0x1e>
    return MEMS_ERROR;
 80137ba:	2300      	movs	r3, #0
 80137bc:	e007      	b.n	80137ce <LSM303AGR_ACC_R_SPI_mode+0x2e>

  *value &= LSM303AGR_ACC_SIM_MASK; //mask
 80137be:	9b00      	ldr	r3, [sp, #0]
 80137c0:	781b      	ldrb	r3, [r3, #0]
 80137c2:	f003 0301 	and.w	r3, r3, #1
 80137c6:	b2da      	uxtb	r2, r3
 80137c8:	9b00      	ldr	r3, [sp, #0]
 80137ca:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80137cc:	2301      	movs	r3, #1
}
 80137ce:	4618      	mov	r0, r3
 80137d0:	b003      	add	sp, #12
 80137d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80137d6:	bf00      	nop
 80137d8:	f3af 8000 	nop.w
 80137dc:	f3af 8000 	nop.w

080137e0 <LSM303AGR_ACC_W_SelfTest>:
* Input          : LSM303AGR_ACC_ST_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_SelfTest(void *handle, LSM303AGR_ACC_ST_t newValue)
{
 80137e0:	b500      	push	{lr}
 80137e2:	b085      	sub	sp, #20
 80137e4:	9001      	str	r0, [sp, #4]
 80137e6:	460b      	mov	r3, r1
 80137e8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 80137ec:	f10d 030f 	add.w	r3, sp, #15
 80137f0:	9801      	ldr	r0, [sp, #4]
 80137f2:	2123      	movs	r1, #35	; 0x23
 80137f4:	461a      	mov	r2, r3
 80137f6:	2301      	movs	r3, #1
 80137f8:	f7fe fd92 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80137fc:	4603      	mov	r3, r0
 80137fe:	2b00      	cmp	r3, #0
 8013800:	d101      	bne.n	8013806 <LSM303AGR_ACC_W_SelfTest+0x26>
    return MEMS_ERROR;
 8013802:	2300      	movs	r3, #0
 8013804:	e01c      	b.n	8013840 <LSM303AGR_ACC_W_SelfTest+0x60>

  value &= ~LSM303AGR_ACC_ST_MASK;
 8013806:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801380a:	f023 0306 	bic.w	r3, r3, #6
 801380e:	b2db      	uxtb	r3, r3
 8013810:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013814:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013818:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801381c:	4313      	orrs	r3, r2
 801381e:	b2db      	uxtb	r3, r3
 8013820:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 8013824:	f10d 030f 	add.w	r3, sp, #15
 8013828:	9801      	ldr	r0, [sp, #4]
 801382a:	2123      	movs	r1, #35	; 0x23
 801382c:	461a      	mov	r2, r3
 801382e:	2301      	movs	r3, #1
 8013830:	f7fe fd56 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8013834:	4603      	mov	r3, r0
 8013836:	2b00      	cmp	r3, #0
 8013838:	d101      	bne.n	801383e <LSM303AGR_ACC_W_SelfTest+0x5e>
    return MEMS_ERROR;
 801383a:	2300      	movs	r3, #0
 801383c:	e000      	b.n	8013840 <LSM303AGR_ACC_W_SelfTest+0x60>

  return MEMS_SUCCESS;
 801383e:	2301      	movs	r3, #1
}
 8013840:	4618      	mov	r0, r3
 8013842:	b005      	add	sp, #20
 8013844:	f85d fb04 	ldr.w	pc, [sp], #4
 8013848:	f3af 8000 	nop.w
 801384c:	f3af 8000 	nop.w

08013850 <LSM303AGR_ACC_R_SelfTest>:
* Input          : Pointer to LSM303AGR_ACC_ST_t
* Output         : Status of ST see LSM303AGR_ACC_ST_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_SelfTest(void *handle, LSM303AGR_ACC_ST_t *value)
{
 8013850:	b500      	push	{lr}
 8013852:	b083      	sub	sp, #12
 8013854:	9001      	str	r0, [sp, #4]
 8013856:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
 8013858:	9801      	ldr	r0, [sp, #4]
 801385a:	2123      	movs	r1, #35	; 0x23
 801385c:	9a00      	ldr	r2, [sp, #0]
 801385e:	2301      	movs	r3, #1
 8013860:	f7fe fd5e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013864:	4603      	mov	r3, r0
 8013866:	2b00      	cmp	r3, #0
 8013868:	d101      	bne.n	801386e <LSM303AGR_ACC_R_SelfTest+0x1e>
    return MEMS_ERROR;
 801386a:	2300      	movs	r3, #0
 801386c:	e007      	b.n	801387e <LSM303AGR_ACC_R_SelfTest+0x2e>

  *value &= LSM303AGR_ACC_ST_MASK; //mask
 801386e:	9b00      	ldr	r3, [sp, #0]
 8013870:	781b      	ldrb	r3, [r3, #0]
 8013872:	f003 0306 	and.w	r3, r3, #6
 8013876:	b2da      	uxtb	r2, r3
 8013878:	9b00      	ldr	r3, [sp, #0]
 801387a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801387c:	2301      	movs	r3, #1
}
 801387e:	4618      	mov	r0, r3
 8013880:	b003      	add	sp, #12
 8013882:	f85d fb04 	ldr.w	pc, [sp], #4
 8013886:	bf00      	nop
 8013888:	f3af 8000 	nop.w
 801388c:	f3af 8000 	nop.w

08013890 <LSM303AGR_ACC_W_HiRes>:
* Input          : LSM303AGR_ACC_HR_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_HiRes(void *handle, LSM303AGR_ACC_HR_t newValue)
{
 8013890:	b500      	push	{lr}
 8013892:	b085      	sub	sp, #20
 8013894:	9001      	str	r0, [sp, #4]
 8013896:	460b      	mov	r3, r1
 8013898:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 801389c:	f10d 030f 	add.w	r3, sp, #15
 80138a0:	9801      	ldr	r0, [sp, #4]
 80138a2:	2123      	movs	r1, #35	; 0x23
 80138a4:	461a      	mov	r2, r3
 80138a6:	2301      	movs	r3, #1
 80138a8:	f7fe fd3a 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80138ac:	4603      	mov	r3, r0
 80138ae:	2b00      	cmp	r3, #0
 80138b0:	d101      	bne.n	80138b6 <LSM303AGR_ACC_W_HiRes+0x26>
    return MEMS_ERROR;
 80138b2:	2300      	movs	r3, #0
 80138b4:	e01c      	b.n	80138f0 <LSM303AGR_ACC_W_HiRes+0x60>

  value &= ~LSM303AGR_ACC_HR_MASK;
 80138b6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80138ba:	f023 0308 	bic.w	r3, r3, #8
 80138be:	b2db      	uxtb	r3, r3
 80138c0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80138c4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80138c8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80138cc:	4313      	orrs	r3, r2
 80138ce:	b2db      	uxtb	r3, r3
 80138d0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 80138d4:	f10d 030f 	add.w	r3, sp, #15
 80138d8:	9801      	ldr	r0, [sp, #4]
 80138da:	2123      	movs	r1, #35	; 0x23
 80138dc:	461a      	mov	r2, r3
 80138de:	2301      	movs	r3, #1
 80138e0:	f7fe fcfe 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 80138e4:	4603      	mov	r3, r0
 80138e6:	2b00      	cmp	r3, #0
 80138e8:	d101      	bne.n	80138ee <LSM303AGR_ACC_W_HiRes+0x5e>
    return MEMS_ERROR;
 80138ea:	2300      	movs	r3, #0
 80138ec:	e000      	b.n	80138f0 <LSM303AGR_ACC_W_HiRes+0x60>

  return MEMS_SUCCESS;
 80138ee:	2301      	movs	r3, #1
}
 80138f0:	4618      	mov	r0, r3
 80138f2:	b005      	add	sp, #20
 80138f4:	f85d fb04 	ldr.w	pc, [sp], #4
 80138f8:	f3af 8000 	nop.w
 80138fc:	f3af 8000 	nop.w

08013900 <LSM303AGR_ACC_R_HiRes>:
* Input          : Pointer to LSM303AGR_ACC_HR_t
* Output         : Status of HR see LSM303AGR_ACC_HR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_HiRes(void *handle, LSM303AGR_ACC_HR_t *value)
{
 8013900:	b500      	push	{lr}
 8013902:	b083      	sub	sp, #12
 8013904:	9001      	str	r0, [sp, #4]
 8013906:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
 8013908:	9801      	ldr	r0, [sp, #4]
 801390a:	2123      	movs	r1, #35	; 0x23
 801390c:	9a00      	ldr	r2, [sp, #0]
 801390e:	2301      	movs	r3, #1
 8013910:	f7fe fd06 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013914:	4603      	mov	r3, r0
 8013916:	2b00      	cmp	r3, #0
 8013918:	d101      	bne.n	801391e <LSM303AGR_ACC_R_HiRes+0x1e>
    return MEMS_ERROR;
 801391a:	2300      	movs	r3, #0
 801391c:	e007      	b.n	801392e <LSM303AGR_ACC_R_HiRes+0x2e>

  *value &= LSM303AGR_ACC_HR_MASK; //mask
 801391e:	9b00      	ldr	r3, [sp, #0]
 8013920:	781b      	ldrb	r3, [r3, #0]
 8013922:	f003 0308 	and.w	r3, r3, #8
 8013926:	b2da      	uxtb	r2, r3
 8013928:	9b00      	ldr	r3, [sp, #0]
 801392a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801392c:	2301      	movs	r3, #1
}
 801392e:	4618      	mov	r0, r3
 8013930:	b003      	add	sp, #12
 8013932:	f85d fb04 	ldr.w	pc, [sp], #4
 8013936:	bf00      	nop
 8013938:	f3af 8000 	nop.w
 801393c:	f3af 8000 	nop.w

08013940 <LSM303AGR_ACC_W_LittleBigEndian>:
* Input          : LSM303AGR_ACC_BLE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_LittleBigEndian(void *handle, LSM303AGR_ACC_BLE_t newValue)
{
 8013940:	b500      	push	{lr}
 8013942:	b085      	sub	sp, #20
 8013944:	9001      	str	r0, [sp, #4]
 8013946:	460b      	mov	r3, r1
 8013948:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 801394c:	f10d 030f 	add.w	r3, sp, #15
 8013950:	9801      	ldr	r0, [sp, #4]
 8013952:	2123      	movs	r1, #35	; 0x23
 8013954:	461a      	mov	r2, r3
 8013956:	2301      	movs	r3, #1
 8013958:	f7fe fce2 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 801395c:	4603      	mov	r3, r0
 801395e:	2b00      	cmp	r3, #0
 8013960:	d101      	bne.n	8013966 <LSM303AGR_ACC_W_LittleBigEndian+0x26>
    return MEMS_ERROR;
 8013962:	2300      	movs	r3, #0
 8013964:	e01c      	b.n	80139a0 <LSM303AGR_ACC_W_LittleBigEndian+0x60>

  value &= ~LSM303AGR_ACC_BLE_MASK;
 8013966:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801396a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 801396e:	b2db      	uxtb	r3, r3
 8013970:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013974:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013978:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801397c:	4313      	orrs	r3, r2
 801397e:	b2db      	uxtb	r3, r3
 8013980:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 8013984:	f10d 030f 	add.w	r3, sp, #15
 8013988:	9801      	ldr	r0, [sp, #4]
 801398a:	2123      	movs	r1, #35	; 0x23
 801398c:	461a      	mov	r2, r3
 801398e:	2301      	movs	r3, #1
 8013990:	f7fe fca6 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8013994:	4603      	mov	r3, r0
 8013996:	2b00      	cmp	r3, #0
 8013998:	d101      	bne.n	801399e <LSM303AGR_ACC_W_LittleBigEndian+0x5e>
    return MEMS_ERROR;
 801399a:	2300      	movs	r3, #0
 801399c:	e000      	b.n	80139a0 <LSM303AGR_ACC_W_LittleBigEndian+0x60>

  return MEMS_SUCCESS;
 801399e:	2301      	movs	r3, #1
}
 80139a0:	4618      	mov	r0, r3
 80139a2:	b005      	add	sp, #20
 80139a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80139a8:	f3af 8000 	nop.w
 80139ac:	f3af 8000 	nop.w

080139b0 <LSM303AGR_ACC_R_LittleBigEndian>:
* Input          : Pointer to LSM303AGR_ACC_BLE_t
* Output         : Status of BLE see LSM303AGR_ACC_BLE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_LittleBigEndian(void *handle, LSM303AGR_ACC_BLE_t *value)
{
 80139b0:	b500      	push	{lr}
 80139b2:	b083      	sub	sp, #12
 80139b4:	9001      	str	r0, [sp, #4]
 80139b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
 80139b8:	9801      	ldr	r0, [sp, #4]
 80139ba:	2123      	movs	r1, #35	; 0x23
 80139bc:	9a00      	ldr	r2, [sp, #0]
 80139be:	2301      	movs	r3, #1
 80139c0:	f7fe fcae 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80139c4:	4603      	mov	r3, r0
 80139c6:	2b00      	cmp	r3, #0
 80139c8:	d101      	bne.n	80139ce <LSM303AGR_ACC_R_LittleBigEndian+0x1e>
    return MEMS_ERROR;
 80139ca:	2300      	movs	r3, #0
 80139cc:	e007      	b.n	80139de <LSM303AGR_ACC_R_LittleBigEndian+0x2e>

  *value &= LSM303AGR_ACC_BLE_MASK; //mask
 80139ce:	9b00      	ldr	r3, [sp, #0]
 80139d0:	781b      	ldrb	r3, [r3, #0]
 80139d2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80139d6:	b2da      	uxtb	r2, r3
 80139d8:	9b00      	ldr	r3, [sp, #0]
 80139da:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80139dc:	2301      	movs	r3, #1
}
 80139de:	4618      	mov	r0, r3
 80139e0:	b003      	add	sp, #12
 80139e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80139e6:	bf00      	nop
 80139e8:	f3af 8000 	nop.w
 80139ec:	f3af 8000 	nop.w

080139f0 <LSM303AGR_ACC_W_4D_on_INT2>:
* Input          : LSM303AGR_ACC_D4D_INT2_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_4D_on_INT2(void *handle, LSM303AGR_ACC_D4D_INT2_t newValue)
{
 80139f0:	b500      	push	{lr}
 80139f2:	b085      	sub	sp, #20
 80139f4:	9001      	str	r0, [sp, #4]
 80139f6:	460b      	mov	r3, r1
 80139f8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 80139fc:	f10d 030f 	add.w	r3, sp, #15
 8013a00:	9801      	ldr	r0, [sp, #4]
 8013a02:	2124      	movs	r1, #36	; 0x24
 8013a04:	461a      	mov	r2, r3
 8013a06:	2301      	movs	r3, #1
 8013a08:	f7fe fc8a 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013a0c:	4603      	mov	r3, r0
 8013a0e:	2b00      	cmp	r3, #0
 8013a10:	d101      	bne.n	8013a16 <LSM303AGR_ACC_W_4D_on_INT2+0x26>
    return MEMS_ERROR;
 8013a12:	2300      	movs	r3, #0
 8013a14:	e01c      	b.n	8013a50 <LSM303AGR_ACC_W_4D_on_INT2+0x60>

  value &= ~LSM303AGR_ACC_D4D_INT2_MASK;
 8013a16:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013a1a:	f023 0301 	bic.w	r3, r3, #1
 8013a1e:	b2db      	uxtb	r3, r3
 8013a20:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013a24:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013a28:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013a2c:	4313      	orrs	r3, r2
 8013a2e:	b2db      	uxtb	r3, r3
 8013a30:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8013a34:	f10d 030f 	add.w	r3, sp, #15
 8013a38:	9801      	ldr	r0, [sp, #4]
 8013a3a:	2124      	movs	r1, #36	; 0x24
 8013a3c:	461a      	mov	r2, r3
 8013a3e:	2301      	movs	r3, #1
 8013a40:	f7fe fc4e 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8013a44:	4603      	mov	r3, r0
 8013a46:	2b00      	cmp	r3, #0
 8013a48:	d101      	bne.n	8013a4e <LSM303AGR_ACC_W_4D_on_INT2+0x5e>
    return MEMS_ERROR;
 8013a4a:	2300      	movs	r3, #0
 8013a4c:	e000      	b.n	8013a50 <LSM303AGR_ACC_W_4D_on_INT2+0x60>

  return MEMS_SUCCESS;
 8013a4e:	2301      	movs	r3, #1
}
 8013a50:	4618      	mov	r0, r3
 8013a52:	b005      	add	sp, #20
 8013a54:	f85d fb04 	ldr.w	pc, [sp], #4
 8013a58:	f3af 8000 	nop.w
 8013a5c:	f3af 8000 	nop.w

08013a60 <LSM303AGR_ACC_R_4D_on_INT2>:
* Input          : Pointer to LSM303AGR_ACC_D4D_INT2_t
* Output         : Status of D4D_INT2 see LSM303AGR_ACC_D4D_INT2_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_4D_on_INT2(void *handle, LSM303AGR_ACC_D4D_INT2_t *value)
{
 8013a60:	b500      	push	{lr}
 8013a62:	b083      	sub	sp, #12
 8013a64:	9001      	str	r0, [sp, #4]
 8013a66:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, (u8_t *)value, 1) )
 8013a68:	9801      	ldr	r0, [sp, #4]
 8013a6a:	2124      	movs	r1, #36	; 0x24
 8013a6c:	9a00      	ldr	r2, [sp, #0]
 8013a6e:	2301      	movs	r3, #1
 8013a70:	f7fe fc56 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013a74:	4603      	mov	r3, r0
 8013a76:	2b00      	cmp	r3, #0
 8013a78:	d101      	bne.n	8013a7e <LSM303AGR_ACC_R_4D_on_INT2+0x1e>
    return MEMS_ERROR;
 8013a7a:	2300      	movs	r3, #0
 8013a7c:	e007      	b.n	8013a8e <LSM303AGR_ACC_R_4D_on_INT2+0x2e>

  *value &= LSM303AGR_ACC_D4D_INT2_MASK; //mask
 8013a7e:	9b00      	ldr	r3, [sp, #0]
 8013a80:	781b      	ldrb	r3, [r3, #0]
 8013a82:	f003 0301 	and.w	r3, r3, #1
 8013a86:	b2da      	uxtb	r2, r3
 8013a88:	9b00      	ldr	r3, [sp, #0]
 8013a8a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013a8c:	2301      	movs	r3, #1
}
 8013a8e:	4618      	mov	r0, r3
 8013a90:	b003      	add	sp, #12
 8013a92:	f85d fb04 	ldr.w	pc, [sp], #4
 8013a96:	bf00      	nop
 8013a98:	f3af 8000 	nop.w
 8013a9c:	f3af 8000 	nop.w

08013aa0 <LSM303AGR_ACC_W_LatchInterrupt_on_INT2>:
* Input          : LSM303AGR_ACC_LIR_INT2_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_LatchInterrupt_on_INT2(void *handle, LSM303AGR_ACC_LIR_INT2_t newValue)
{
 8013aa0:	b500      	push	{lr}
 8013aa2:	b085      	sub	sp, #20
 8013aa4:	9001      	str	r0, [sp, #4]
 8013aa6:	460b      	mov	r3, r1
 8013aa8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8013aac:	f10d 030f 	add.w	r3, sp, #15
 8013ab0:	9801      	ldr	r0, [sp, #4]
 8013ab2:	2124      	movs	r1, #36	; 0x24
 8013ab4:	461a      	mov	r2, r3
 8013ab6:	2301      	movs	r3, #1
 8013ab8:	f7fe fc32 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013abc:	4603      	mov	r3, r0
 8013abe:	2b00      	cmp	r3, #0
 8013ac0:	d101      	bne.n	8013ac6 <LSM303AGR_ACC_W_LatchInterrupt_on_INT2+0x26>
    return MEMS_ERROR;
 8013ac2:	2300      	movs	r3, #0
 8013ac4:	e01c      	b.n	8013b00 <LSM303AGR_ACC_W_LatchInterrupt_on_INT2+0x60>

  value &= ~LSM303AGR_ACC_LIR_INT2_MASK;
 8013ac6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013aca:	f023 0302 	bic.w	r3, r3, #2
 8013ace:	b2db      	uxtb	r3, r3
 8013ad0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013ad4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013ad8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013adc:	4313      	orrs	r3, r2
 8013ade:	b2db      	uxtb	r3, r3
 8013ae0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8013ae4:	f10d 030f 	add.w	r3, sp, #15
 8013ae8:	9801      	ldr	r0, [sp, #4]
 8013aea:	2124      	movs	r1, #36	; 0x24
 8013aec:	461a      	mov	r2, r3
 8013aee:	2301      	movs	r3, #1
 8013af0:	f7fe fbf6 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8013af4:	4603      	mov	r3, r0
 8013af6:	2b00      	cmp	r3, #0
 8013af8:	d101      	bne.n	8013afe <LSM303AGR_ACC_W_LatchInterrupt_on_INT2+0x5e>
    return MEMS_ERROR;
 8013afa:	2300      	movs	r3, #0
 8013afc:	e000      	b.n	8013b00 <LSM303AGR_ACC_W_LatchInterrupt_on_INT2+0x60>

  return MEMS_SUCCESS;
 8013afe:	2301      	movs	r3, #1
}
 8013b00:	4618      	mov	r0, r3
 8013b02:	b005      	add	sp, #20
 8013b04:	f85d fb04 	ldr.w	pc, [sp], #4
 8013b08:	f3af 8000 	nop.w
 8013b0c:	f3af 8000 	nop.w

08013b10 <LSM303AGR_ACC_R_LatchInterrupt_on_INT2>:
* Input          : Pointer to LSM303AGR_ACC_LIR_INT2_t
* Output         : Status of LIR_INT2 see LSM303AGR_ACC_LIR_INT2_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_LatchInterrupt_on_INT2(void *handle, LSM303AGR_ACC_LIR_INT2_t *value)
{
 8013b10:	b500      	push	{lr}
 8013b12:	b083      	sub	sp, #12
 8013b14:	9001      	str	r0, [sp, #4]
 8013b16:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, (u8_t *)value, 1) )
 8013b18:	9801      	ldr	r0, [sp, #4]
 8013b1a:	2124      	movs	r1, #36	; 0x24
 8013b1c:	9a00      	ldr	r2, [sp, #0]
 8013b1e:	2301      	movs	r3, #1
 8013b20:	f7fe fbfe 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013b24:	4603      	mov	r3, r0
 8013b26:	2b00      	cmp	r3, #0
 8013b28:	d101      	bne.n	8013b2e <LSM303AGR_ACC_R_LatchInterrupt_on_INT2+0x1e>
    return MEMS_ERROR;
 8013b2a:	2300      	movs	r3, #0
 8013b2c:	e007      	b.n	8013b3e <LSM303AGR_ACC_R_LatchInterrupt_on_INT2+0x2e>

  *value &= LSM303AGR_ACC_LIR_INT2_MASK; //mask
 8013b2e:	9b00      	ldr	r3, [sp, #0]
 8013b30:	781b      	ldrb	r3, [r3, #0]
 8013b32:	f003 0302 	and.w	r3, r3, #2
 8013b36:	b2da      	uxtb	r2, r3
 8013b38:	9b00      	ldr	r3, [sp, #0]
 8013b3a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013b3c:	2301      	movs	r3, #1
}
 8013b3e:	4618      	mov	r0, r3
 8013b40:	b003      	add	sp, #12
 8013b42:	f85d fb04 	ldr.w	pc, [sp], #4
 8013b46:	bf00      	nop
 8013b48:	f3af 8000 	nop.w
 8013b4c:	f3af 8000 	nop.w

08013b50 <LSM303AGR_ACC_W_4D_on_INT1>:
* Input          : LSM303AGR_ACC_D4D_INT1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_4D_on_INT1(void *handle, LSM303AGR_ACC_D4D_INT1_t newValue)
{
 8013b50:	b500      	push	{lr}
 8013b52:	b085      	sub	sp, #20
 8013b54:	9001      	str	r0, [sp, #4]
 8013b56:	460b      	mov	r3, r1
 8013b58:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8013b5c:	f10d 030f 	add.w	r3, sp, #15
 8013b60:	9801      	ldr	r0, [sp, #4]
 8013b62:	2124      	movs	r1, #36	; 0x24
 8013b64:	461a      	mov	r2, r3
 8013b66:	2301      	movs	r3, #1
 8013b68:	f7fe fbda 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013b6c:	4603      	mov	r3, r0
 8013b6e:	2b00      	cmp	r3, #0
 8013b70:	d101      	bne.n	8013b76 <LSM303AGR_ACC_W_4D_on_INT1+0x26>
    return MEMS_ERROR;
 8013b72:	2300      	movs	r3, #0
 8013b74:	e01c      	b.n	8013bb0 <LSM303AGR_ACC_W_4D_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_D4D_INT1_MASK;
 8013b76:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013b7a:	f023 0304 	bic.w	r3, r3, #4
 8013b7e:	b2db      	uxtb	r3, r3
 8013b80:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013b84:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013b88:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013b8c:	4313      	orrs	r3, r2
 8013b8e:	b2db      	uxtb	r3, r3
 8013b90:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8013b94:	f10d 030f 	add.w	r3, sp, #15
 8013b98:	9801      	ldr	r0, [sp, #4]
 8013b9a:	2124      	movs	r1, #36	; 0x24
 8013b9c:	461a      	mov	r2, r3
 8013b9e:	2301      	movs	r3, #1
 8013ba0:	f7fe fb9e 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8013ba4:	4603      	mov	r3, r0
 8013ba6:	2b00      	cmp	r3, #0
 8013ba8:	d101      	bne.n	8013bae <LSM303AGR_ACC_W_4D_on_INT1+0x5e>
    return MEMS_ERROR;
 8013baa:	2300      	movs	r3, #0
 8013bac:	e000      	b.n	8013bb0 <LSM303AGR_ACC_W_4D_on_INT1+0x60>

  return MEMS_SUCCESS;
 8013bae:	2301      	movs	r3, #1
}
 8013bb0:	4618      	mov	r0, r3
 8013bb2:	b005      	add	sp, #20
 8013bb4:	f85d fb04 	ldr.w	pc, [sp], #4
 8013bb8:	f3af 8000 	nop.w
 8013bbc:	f3af 8000 	nop.w

08013bc0 <LSM303AGR_ACC_R_4D_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_D4D_INT1_t
* Output         : Status of D4D_INT1 see LSM303AGR_ACC_D4D_INT1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_4D_on_INT1(void *handle, LSM303AGR_ACC_D4D_INT1_t *value)
{
 8013bc0:	b500      	push	{lr}
 8013bc2:	b083      	sub	sp, #12
 8013bc4:	9001      	str	r0, [sp, #4]
 8013bc6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, (u8_t *)value, 1) )
 8013bc8:	9801      	ldr	r0, [sp, #4]
 8013bca:	2124      	movs	r1, #36	; 0x24
 8013bcc:	9a00      	ldr	r2, [sp, #0]
 8013bce:	2301      	movs	r3, #1
 8013bd0:	f7fe fba6 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013bd4:	4603      	mov	r3, r0
 8013bd6:	2b00      	cmp	r3, #0
 8013bd8:	d101      	bne.n	8013bde <LSM303AGR_ACC_R_4D_on_INT1+0x1e>
    return MEMS_ERROR;
 8013bda:	2300      	movs	r3, #0
 8013bdc:	e007      	b.n	8013bee <LSM303AGR_ACC_R_4D_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_D4D_INT1_MASK; //mask
 8013bde:	9b00      	ldr	r3, [sp, #0]
 8013be0:	781b      	ldrb	r3, [r3, #0]
 8013be2:	f003 0304 	and.w	r3, r3, #4
 8013be6:	b2da      	uxtb	r2, r3
 8013be8:	9b00      	ldr	r3, [sp, #0]
 8013bea:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013bec:	2301      	movs	r3, #1
}
 8013bee:	4618      	mov	r0, r3
 8013bf0:	b003      	add	sp, #12
 8013bf2:	f85d fb04 	ldr.w	pc, [sp], #4
 8013bf6:	bf00      	nop
 8013bf8:	f3af 8000 	nop.w
 8013bfc:	f3af 8000 	nop.w

08013c00 <LSM303AGR_ACC_W_LatchInterrupt_on_INT1>:
* Input          : LSM303AGR_ACC_LIR_INT1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_LatchInterrupt_on_INT1(void *handle, LSM303AGR_ACC_LIR_INT1_t newValue)
{
 8013c00:	b500      	push	{lr}
 8013c02:	b085      	sub	sp, #20
 8013c04:	9001      	str	r0, [sp, #4]
 8013c06:	460b      	mov	r3, r1
 8013c08:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8013c0c:	f10d 030f 	add.w	r3, sp, #15
 8013c10:	9801      	ldr	r0, [sp, #4]
 8013c12:	2124      	movs	r1, #36	; 0x24
 8013c14:	461a      	mov	r2, r3
 8013c16:	2301      	movs	r3, #1
 8013c18:	f7fe fb82 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013c1c:	4603      	mov	r3, r0
 8013c1e:	2b00      	cmp	r3, #0
 8013c20:	d101      	bne.n	8013c26 <LSM303AGR_ACC_W_LatchInterrupt_on_INT1+0x26>
    return MEMS_ERROR;
 8013c22:	2300      	movs	r3, #0
 8013c24:	e01c      	b.n	8013c60 <LSM303AGR_ACC_W_LatchInterrupt_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_LIR_INT1_MASK;
 8013c26:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013c2a:	f023 0308 	bic.w	r3, r3, #8
 8013c2e:	b2db      	uxtb	r3, r3
 8013c30:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013c34:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013c38:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013c3c:	4313      	orrs	r3, r2
 8013c3e:	b2db      	uxtb	r3, r3
 8013c40:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8013c44:	f10d 030f 	add.w	r3, sp, #15
 8013c48:	9801      	ldr	r0, [sp, #4]
 8013c4a:	2124      	movs	r1, #36	; 0x24
 8013c4c:	461a      	mov	r2, r3
 8013c4e:	2301      	movs	r3, #1
 8013c50:	f7fe fb46 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8013c54:	4603      	mov	r3, r0
 8013c56:	2b00      	cmp	r3, #0
 8013c58:	d101      	bne.n	8013c5e <LSM303AGR_ACC_W_LatchInterrupt_on_INT1+0x5e>
    return MEMS_ERROR;
 8013c5a:	2300      	movs	r3, #0
 8013c5c:	e000      	b.n	8013c60 <LSM303AGR_ACC_W_LatchInterrupt_on_INT1+0x60>

  return MEMS_SUCCESS;
 8013c5e:	2301      	movs	r3, #1
}
 8013c60:	4618      	mov	r0, r3
 8013c62:	b005      	add	sp, #20
 8013c64:	f85d fb04 	ldr.w	pc, [sp], #4
 8013c68:	f3af 8000 	nop.w
 8013c6c:	f3af 8000 	nop.w

08013c70 <LSM303AGR_ACC_R_LatchInterrupt_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_LIR_INT1_t
* Output         : Status of LIR_INT1 see LSM303AGR_ACC_LIR_INT1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_LatchInterrupt_on_INT1(void *handle, LSM303AGR_ACC_LIR_INT1_t *value)
{
 8013c70:	b500      	push	{lr}
 8013c72:	b083      	sub	sp, #12
 8013c74:	9001      	str	r0, [sp, #4]
 8013c76:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, (u8_t *)value, 1) )
 8013c78:	9801      	ldr	r0, [sp, #4]
 8013c7a:	2124      	movs	r1, #36	; 0x24
 8013c7c:	9a00      	ldr	r2, [sp, #0]
 8013c7e:	2301      	movs	r3, #1
 8013c80:	f7fe fb4e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013c84:	4603      	mov	r3, r0
 8013c86:	2b00      	cmp	r3, #0
 8013c88:	d101      	bne.n	8013c8e <LSM303AGR_ACC_R_LatchInterrupt_on_INT1+0x1e>
    return MEMS_ERROR;
 8013c8a:	2300      	movs	r3, #0
 8013c8c:	e007      	b.n	8013c9e <LSM303AGR_ACC_R_LatchInterrupt_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_LIR_INT1_MASK; //mask
 8013c8e:	9b00      	ldr	r3, [sp, #0]
 8013c90:	781b      	ldrb	r3, [r3, #0]
 8013c92:	f003 0308 	and.w	r3, r3, #8
 8013c96:	b2da      	uxtb	r2, r3
 8013c98:	9b00      	ldr	r3, [sp, #0]
 8013c9a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013c9c:	2301      	movs	r3, #1
}
 8013c9e:	4618      	mov	r0, r3
 8013ca0:	b003      	add	sp, #12
 8013ca2:	f85d fb04 	ldr.w	pc, [sp], #4
 8013ca6:	bf00      	nop
 8013ca8:	f3af 8000 	nop.w
 8013cac:	f3af 8000 	nop.w

08013cb0 <LSM303AGR_ACC_W_FIFO_EN>:
* Input          : LSM303AGR_ACC_FIFO_EN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_EN(void *handle, LSM303AGR_ACC_FIFO_EN_t newValue)
{
 8013cb0:	b500      	push	{lr}
 8013cb2:	b085      	sub	sp, #20
 8013cb4:	9001      	str	r0, [sp, #4]
 8013cb6:	460b      	mov	r3, r1
 8013cb8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8013cbc:	f10d 030f 	add.w	r3, sp, #15
 8013cc0:	9801      	ldr	r0, [sp, #4]
 8013cc2:	2124      	movs	r1, #36	; 0x24
 8013cc4:	461a      	mov	r2, r3
 8013cc6:	2301      	movs	r3, #1
 8013cc8:	f7fe fb2a 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013ccc:	4603      	mov	r3, r0
 8013cce:	2b00      	cmp	r3, #0
 8013cd0:	d101      	bne.n	8013cd6 <LSM303AGR_ACC_W_FIFO_EN+0x26>
    return MEMS_ERROR;
 8013cd2:	2300      	movs	r3, #0
 8013cd4:	e01c      	b.n	8013d10 <LSM303AGR_ACC_W_FIFO_EN+0x60>

  value &= ~LSM303AGR_ACC_FIFO_EN_MASK;
 8013cd6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013cda:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8013cde:	b2db      	uxtb	r3, r3
 8013ce0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013ce4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013ce8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013cec:	4313      	orrs	r3, r2
 8013cee:	b2db      	uxtb	r3, r3
 8013cf0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8013cf4:	f10d 030f 	add.w	r3, sp, #15
 8013cf8:	9801      	ldr	r0, [sp, #4]
 8013cfa:	2124      	movs	r1, #36	; 0x24
 8013cfc:	461a      	mov	r2, r3
 8013cfe:	2301      	movs	r3, #1
 8013d00:	f7fe faee 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8013d04:	4603      	mov	r3, r0
 8013d06:	2b00      	cmp	r3, #0
 8013d08:	d101      	bne.n	8013d0e <LSM303AGR_ACC_W_FIFO_EN+0x5e>
    return MEMS_ERROR;
 8013d0a:	2300      	movs	r3, #0
 8013d0c:	e000      	b.n	8013d10 <LSM303AGR_ACC_W_FIFO_EN+0x60>

  return MEMS_SUCCESS;
 8013d0e:	2301      	movs	r3, #1
}
 8013d10:	4618      	mov	r0, r3
 8013d12:	b005      	add	sp, #20
 8013d14:	f85d fb04 	ldr.w	pc, [sp], #4
 8013d18:	f3af 8000 	nop.w
 8013d1c:	f3af 8000 	nop.w

08013d20 <LSM303AGR_ACC_R_FIFO_EN>:
* Input          : Pointer to LSM303AGR_ACC_FIFO_EN_t
* Output         : Status of FIFO_EN see LSM303AGR_ACC_FIFO_EN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_EN(void *handle, LSM303AGR_ACC_FIFO_EN_t *value)
{
 8013d20:	b500      	push	{lr}
 8013d22:	b083      	sub	sp, #12
 8013d24:	9001      	str	r0, [sp, #4]
 8013d26:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, (u8_t *)value, 1) )
 8013d28:	9801      	ldr	r0, [sp, #4]
 8013d2a:	2124      	movs	r1, #36	; 0x24
 8013d2c:	9a00      	ldr	r2, [sp, #0]
 8013d2e:	2301      	movs	r3, #1
 8013d30:	f7fe faf6 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013d34:	4603      	mov	r3, r0
 8013d36:	2b00      	cmp	r3, #0
 8013d38:	d101      	bne.n	8013d3e <LSM303AGR_ACC_R_FIFO_EN+0x1e>
    return MEMS_ERROR;
 8013d3a:	2300      	movs	r3, #0
 8013d3c:	e007      	b.n	8013d4e <LSM303AGR_ACC_R_FIFO_EN+0x2e>

  *value &= LSM303AGR_ACC_FIFO_EN_MASK; //mask
 8013d3e:	9b00      	ldr	r3, [sp, #0]
 8013d40:	781b      	ldrb	r3, [r3, #0]
 8013d42:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8013d46:	b2da      	uxtb	r2, r3
 8013d48:	9b00      	ldr	r3, [sp, #0]
 8013d4a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013d4c:	2301      	movs	r3, #1
}
 8013d4e:	4618      	mov	r0, r3
 8013d50:	b003      	add	sp, #12
 8013d52:	f85d fb04 	ldr.w	pc, [sp], #4
 8013d56:	bf00      	nop
 8013d58:	f3af 8000 	nop.w
 8013d5c:	f3af 8000 	nop.w

08013d60 <LSM303AGR_ACC_W_RebootMemory>:
* Input          : LSM303AGR_ACC_BOOT_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_RebootMemory(void *handle, LSM303AGR_ACC_BOOT_t newValue)
{
 8013d60:	b500      	push	{lr}
 8013d62:	b085      	sub	sp, #20
 8013d64:	9001      	str	r0, [sp, #4]
 8013d66:	460b      	mov	r3, r1
 8013d68:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8013d6c:	f10d 030f 	add.w	r3, sp, #15
 8013d70:	9801      	ldr	r0, [sp, #4]
 8013d72:	2124      	movs	r1, #36	; 0x24
 8013d74:	461a      	mov	r2, r3
 8013d76:	2301      	movs	r3, #1
 8013d78:	f7fe fad2 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013d7c:	4603      	mov	r3, r0
 8013d7e:	2b00      	cmp	r3, #0
 8013d80:	d101      	bne.n	8013d86 <LSM303AGR_ACC_W_RebootMemory+0x26>
    return MEMS_ERROR;
 8013d82:	2300      	movs	r3, #0
 8013d84:	e01c      	b.n	8013dc0 <LSM303AGR_ACC_W_RebootMemory+0x60>

  value &= ~LSM303AGR_ACC_BOOT_MASK;
 8013d86:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013d8a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8013d8e:	b2db      	uxtb	r3, r3
 8013d90:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013d94:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013d98:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013d9c:	4313      	orrs	r3, r2
 8013d9e:	b2db      	uxtb	r3, r3
 8013da0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8013da4:	f10d 030f 	add.w	r3, sp, #15
 8013da8:	9801      	ldr	r0, [sp, #4]
 8013daa:	2124      	movs	r1, #36	; 0x24
 8013dac:	461a      	mov	r2, r3
 8013dae:	2301      	movs	r3, #1
 8013db0:	f7fe fa96 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8013db4:	4603      	mov	r3, r0
 8013db6:	2b00      	cmp	r3, #0
 8013db8:	d101      	bne.n	8013dbe <LSM303AGR_ACC_W_RebootMemory+0x5e>
    return MEMS_ERROR;
 8013dba:	2300      	movs	r3, #0
 8013dbc:	e000      	b.n	8013dc0 <LSM303AGR_ACC_W_RebootMemory+0x60>

  return MEMS_SUCCESS;
 8013dbe:	2301      	movs	r3, #1
}
 8013dc0:	4618      	mov	r0, r3
 8013dc2:	b005      	add	sp, #20
 8013dc4:	f85d fb04 	ldr.w	pc, [sp], #4
 8013dc8:	f3af 8000 	nop.w
 8013dcc:	f3af 8000 	nop.w

08013dd0 <LSM303AGR_ACC_R_RebootMemory>:
* Input          : Pointer to LSM303AGR_ACC_BOOT_t
* Output         : Status of BOOT see LSM303AGR_ACC_BOOT_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_RebootMemory(void *handle, LSM303AGR_ACC_BOOT_t *value)
{
 8013dd0:	b500      	push	{lr}
 8013dd2:	b083      	sub	sp, #12
 8013dd4:	9001      	str	r0, [sp, #4]
 8013dd6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, (u8_t *)value, 1) )
 8013dd8:	9801      	ldr	r0, [sp, #4]
 8013dda:	2124      	movs	r1, #36	; 0x24
 8013ddc:	9a00      	ldr	r2, [sp, #0]
 8013dde:	2301      	movs	r3, #1
 8013de0:	f7fe fa9e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013de4:	4603      	mov	r3, r0
 8013de6:	2b00      	cmp	r3, #0
 8013de8:	d101      	bne.n	8013dee <LSM303AGR_ACC_R_RebootMemory+0x1e>
    return MEMS_ERROR;
 8013dea:	2300      	movs	r3, #0
 8013dec:	e007      	b.n	8013dfe <LSM303AGR_ACC_R_RebootMemory+0x2e>

  *value &= LSM303AGR_ACC_BOOT_MASK; //mask
 8013dee:	9b00      	ldr	r3, [sp, #0]
 8013df0:	781b      	ldrb	r3, [r3, #0]
 8013df2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8013df6:	b2da      	uxtb	r2, r3
 8013df8:	9b00      	ldr	r3, [sp, #0]
 8013dfa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013dfc:	2301      	movs	r3, #1
}
 8013dfe:	4618      	mov	r0, r3
 8013e00:	b003      	add	sp, #12
 8013e02:	f85d fb04 	ldr.w	pc, [sp], #4
 8013e06:	bf00      	nop
 8013e08:	f3af 8000 	nop.w
 8013e0c:	f3af 8000 	nop.w

08013e10 <LSM303AGR_ACC_W_IntActive>:
* Input          : LSM303AGR_ACC_H_LACTIVE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_IntActive(void *handle, LSM303AGR_ACC_H_LACTIVE_t newValue)
{
 8013e10:	b500      	push	{lr}
 8013e12:	b085      	sub	sp, #20
 8013e14:	9001      	str	r0, [sp, #4]
 8013e16:	460b      	mov	r3, r1
 8013e18:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8013e1c:	f10d 030f 	add.w	r3, sp, #15
 8013e20:	9801      	ldr	r0, [sp, #4]
 8013e22:	2125      	movs	r1, #37	; 0x25
 8013e24:	461a      	mov	r2, r3
 8013e26:	2301      	movs	r3, #1
 8013e28:	f7fe fa7a 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013e2c:	4603      	mov	r3, r0
 8013e2e:	2b00      	cmp	r3, #0
 8013e30:	d101      	bne.n	8013e36 <LSM303AGR_ACC_W_IntActive+0x26>
    return MEMS_ERROR;
 8013e32:	2300      	movs	r3, #0
 8013e34:	e01c      	b.n	8013e70 <LSM303AGR_ACC_W_IntActive+0x60>

  value &= ~LSM303AGR_ACC_H_LACTIVE_MASK;
 8013e36:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013e3a:	f023 0302 	bic.w	r3, r3, #2
 8013e3e:	b2db      	uxtb	r3, r3
 8013e40:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013e44:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013e48:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013e4c:	4313      	orrs	r3, r2
 8013e4e:	b2db      	uxtb	r3, r3
 8013e50:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8013e54:	f10d 030f 	add.w	r3, sp, #15
 8013e58:	9801      	ldr	r0, [sp, #4]
 8013e5a:	2125      	movs	r1, #37	; 0x25
 8013e5c:	461a      	mov	r2, r3
 8013e5e:	2301      	movs	r3, #1
 8013e60:	f7fe fa3e 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8013e64:	4603      	mov	r3, r0
 8013e66:	2b00      	cmp	r3, #0
 8013e68:	d101      	bne.n	8013e6e <LSM303AGR_ACC_W_IntActive+0x5e>
    return MEMS_ERROR;
 8013e6a:	2300      	movs	r3, #0
 8013e6c:	e000      	b.n	8013e70 <LSM303AGR_ACC_W_IntActive+0x60>

  return MEMS_SUCCESS;
 8013e6e:	2301      	movs	r3, #1
}
 8013e70:	4618      	mov	r0, r3
 8013e72:	b005      	add	sp, #20
 8013e74:	f85d fb04 	ldr.w	pc, [sp], #4
 8013e78:	f3af 8000 	nop.w
 8013e7c:	f3af 8000 	nop.w

08013e80 <LSM303AGR_ACC_R_IntActive>:
* Input          : Pointer to LSM303AGR_ACC_H_LACTIVE_t
* Output         : Status of H_LACTIVE see LSM303AGR_ACC_H_LACTIVE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_IntActive(void *handle, LSM303AGR_ACC_H_LACTIVE_t *value)
{
 8013e80:	b500      	push	{lr}
 8013e82:	b083      	sub	sp, #12
 8013e84:	9001      	str	r0, [sp, #4]
 8013e86:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, (u8_t *)value, 1) )
 8013e88:	9801      	ldr	r0, [sp, #4]
 8013e8a:	2125      	movs	r1, #37	; 0x25
 8013e8c:	9a00      	ldr	r2, [sp, #0]
 8013e8e:	2301      	movs	r3, #1
 8013e90:	f7fe fa46 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013e94:	4603      	mov	r3, r0
 8013e96:	2b00      	cmp	r3, #0
 8013e98:	d101      	bne.n	8013e9e <LSM303AGR_ACC_R_IntActive+0x1e>
    return MEMS_ERROR;
 8013e9a:	2300      	movs	r3, #0
 8013e9c:	e007      	b.n	8013eae <LSM303AGR_ACC_R_IntActive+0x2e>

  *value &= LSM303AGR_ACC_H_LACTIVE_MASK; //mask
 8013e9e:	9b00      	ldr	r3, [sp, #0]
 8013ea0:	781b      	ldrb	r3, [r3, #0]
 8013ea2:	f003 0302 	and.w	r3, r3, #2
 8013ea6:	b2da      	uxtb	r2, r3
 8013ea8:	9b00      	ldr	r3, [sp, #0]
 8013eaa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013eac:	2301      	movs	r3, #1
}
 8013eae:	4618      	mov	r0, r3
 8013eb0:	b003      	add	sp, #12
 8013eb2:	f85d fb04 	ldr.w	pc, [sp], #4
 8013eb6:	bf00      	nop
 8013eb8:	f3af 8000 	nop.w
 8013ebc:	f3af 8000 	nop.w

08013ec0 <LSM303AGR_ACC_W_P2_ACT>:
* Input          : LSM303AGR_ACC_P2_ACT_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_P2_ACT(void *handle, LSM303AGR_ACC_P2_ACT_t newValue)
{
 8013ec0:	b500      	push	{lr}
 8013ec2:	b085      	sub	sp, #20
 8013ec4:	9001      	str	r0, [sp, #4]
 8013ec6:	460b      	mov	r3, r1
 8013ec8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8013ecc:	f10d 030f 	add.w	r3, sp, #15
 8013ed0:	9801      	ldr	r0, [sp, #4]
 8013ed2:	2125      	movs	r1, #37	; 0x25
 8013ed4:	461a      	mov	r2, r3
 8013ed6:	2301      	movs	r3, #1
 8013ed8:	f7fe fa22 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013edc:	4603      	mov	r3, r0
 8013ede:	2b00      	cmp	r3, #0
 8013ee0:	d101      	bne.n	8013ee6 <LSM303AGR_ACC_W_P2_ACT+0x26>
    return MEMS_ERROR;
 8013ee2:	2300      	movs	r3, #0
 8013ee4:	e01c      	b.n	8013f20 <LSM303AGR_ACC_W_P2_ACT+0x60>

  value &= ~LSM303AGR_ACC_P2_ACT_MASK;
 8013ee6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013eea:	f023 0308 	bic.w	r3, r3, #8
 8013eee:	b2db      	uxtb	r3, r3
 8013ef0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013ef4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013ef8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013efc:	4313      	orrs	r3, r2
 8013efe:	b2db      	uxtb	r3, r3
 8013f00:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8013f04:	f10d 030f 	add.w	r3, sp, #15
 8013f08:	9801      	ldr	r0, [sp, #4]
 8013f0a:	2125      	movs	r1, #37	; 0x25
 8013f0c:	461a      	mov	r2, r3
 8013f0e:	2301      	movs	r3, #1
 8013f10:	f7fe f9e6 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8013f14:	4603      	mov	r3, r0
 8013f16:	2b00      	cmp	r3, #0
 8013f18:	d101      	bne.n	8013f1e <LSM303AGR_ACC_W_P2_ACT+0x5e>
    return MEMS_ERROR;
 8013f1a:	2300      	movs	r3, #0
 8013f1c:	e000      	b.n	8013f20 <LSM303AGR_ACC_W_P2_ACT+0x60>

  return MEMS_SUCCESS;
 8013f1e:	2301      	movs	r3, #1
}
 8013f20:	4618      	mov	r0, r3
 8013f22:	b005      	add	sp, #20
 8013f24:	f85d fb04 	ldr.w	pc, [sp], #4
 8013f28:	f3af 8000 	nop.w
 8013f2c:	f3af 8000 	nop.w

08013f30 <LSM303AGR_ACC_R_P2_ACT>:
* Input          : Pointer to LSM303AGR_ACC_P2_ACT_t
* Output         : Status of P2_ACT see LSM303AGR_ACC_P2_ACT_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_P2_ACT(void *handle, LSM303AGR_ACC_P2_ACT_t *value)
{
 8013f30:	b500      	push	{lr}
 8013f32:	b083      	sub	sp, #12
 8013f34:	9001      	str	r0, [sp, #4]
 8013f36:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, (u8_t *)value, 1) )
 8013f38:	9801      	ldr	r0, [sp, #4]
 8013f3a:	2125      	movs	r1, #37	; 0x25
 8013f3c:	9a00      	ldr	r2, [sp, #0]
 8013f3e:	2301      	movs	r3, #1
 8013f40:	f7fe f9ee 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013f44:	4603      	mov	r3, r0
 8013f46:	2b00      	cmp	r3, #0
 8013f48:	d101      	bne.n	8013f4e <LSM303AGR_ACC_R_P2_ACT+0x1e>
    return MEMS_ERROR;
 8013f4a:	2300      	movs	r3, #0
 8013f4c:	e007      	b.n	8013f5e <LSM303AGR_ACC_R_P2_ACT+0x2e>

  *value &= LSM303AGR_ACC_P2_ACT_MASK; //mask
 8013f4e:	9b00      	ldr	r3, [sp, #0]
 8013f50:	781b      	ldrb	r3, [r3, #0]
 8013f52:	f003 0308 	and.w	r3, r3, #8
 8013f56:	b2da      	uxtb	r2, r3
 8013f58:	9b00      	ldr	r3, [sp, #0]
 8013f5a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013f5c:	2301      	movs	r3, #1
}
 8013f5e:	4618      	mov	r0, r3
 8013f60:	b003      	add	sp, #12
 8013f62:	f85d fb04 	ldr.w	pc, [sp], #4
 8013f66:	bf00      	nop
 8013f68:	f3af 8000 	nop.w
 8013f6c:	f3af 8000 	nop.w

08013f70 <LSM303AGR_ACC_W_Boot_on_INT2>:
* Input          : LSM303AGR_ACC_BOOT_I1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Boot_on_INT2(void *handle, LSM303AGR_ACC_BOOT_I1_t newValue)
{
 8013f70:	b500      	push	{lr}
 8013f72:	b085      	sub	sp, #20
 8013f74:	9001      	str	r0, [sp, #4]
 8013f76:	460b      	mov	r3, r1
 8013f78:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8013f7c:	f10d 030f 	add.w	r3, sp, #15
 8013f80:	9801      	ldr	r0, [sp, #4]
 8013f82:	2125      	movs	r1, #37	; 0x25
 8013f84:	461a      	mov	r2, r3
 8013f86:	2301      	movs	r3, #1
 8013f88:	f7fe f9ca 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013f8c:	4603      	mov	r3, r0
 8013f8e:	2b00      	cmp	r3, #0
 8013f90:	d101      	bne.n	8013f96 <LSM303AGR_ACC_W_Boot_on_INT2+0x26>
    return MEMS_ERROR;
 8013f92:	2300      	movs	r3, #0
 8013f94:	e01c      	b.n	8013fd0 <LSM303AGR_ACC_W_Boot_on_INT2+0x60>

  value &= ~LSM303AGR_ACC_BOOT_I1_MASK;
 8013f96:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013f9a:	f023 0310 	bic.w	r3, r3, #16
 8013f9e:	b2db      	uxtb	r3, r3
 8013fa0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013fa4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013fa8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013fac:	4313      	orrs	r3, r2
 8013fae:	b2db      	uxtb	r3, r3
 8013fb0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8013fb4:	f10d 030f 	add.w	r3, sp, #15
 8013fb8:	9801      	ldr	r0, [sp, #4]
 8013fba:	2125      	movs	r1, #37	; 0x25
 8013fbc:	461a      	mov	r2, r3
 8013fbe:	2301      	movs	r3, #1
 8013fc0:	f7fe f98e 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8013fc4:	4603      	mov	r3, r0
 8013fc6:	2b00      	cmp	r3, #0
 8013fc8:	d101      	bne.n	8013fce <LSM303AGR_ACC_W_Boot_on_INT2+0x5e>
    return MEMS_ERROR;
 8013fca:	2300      	movs	r3, #0
 8013fcc:	e000      	b.n	8013fd0 <LSM303AGR_ACC_W_Boot_on_INT2+0x60>

  return MEMS_SUCCESS;
 8013fce:	2301      	movs	r3, #1
}
 8013fd0:	4618      	mov	r0, r3
 8013fd2:	b005      	add	sp, #20
 8013fd4:	f85d fb04 	ldr.w	pc, [sp], #4
 8013fd8:	f3af 8000 	nop.w
 8013fdc:	f3af 8000 	nop.w

08013fe0 <LSM303AGR_ACC_R_Boot_on_INT2>:
* Input          : Pointer to LSM303AGR_ACC_BOOT_I1_t
* Output         : Status of BOOT_I1 see LSM303AGR_ACC_BOOT_I1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Boot_on_INT2(void *handle, LSM303AGR_ACC_BOOT_I1_t *value)
{
 8013fe0:	b500      	push	{lr}
 8013fe2:	b083      	sub	sp, #12
 8013fe4:	9001      	str	r0, [sp, #4]
 8013fe6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, (u8_t *)value, 1) )
 8013fe8:	9801      	ldr	r0, [sp, #4]
 8013fea:	2125      	movs	r1, #37	; 0x25
 8013fec:	9a00      	ldr	r2, [sp, #0]
 8013fee:	2301      	movs	r3, #1
 8013ff0:	f7fe f996 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8013ff4:	4603      	mov	r3, r0
 8013ff6:	2b00      	cmp	r3, #0
 8013ff8:	d101      	bne.n	8013ffe <LSM303AGR_ACC_R_Boot_on_INT2+0x1e>
    return MEMS_ERROR;
 8013ffa:	2300      	movs	r3, #0
 8013ffc:	e007      	b.n	801400e <LSM303AGR_ACC_R_Boot_on_INT2+0x2e>

  *value &= LSM303AGR_ACC_BOOT_I1_MASK; //mask
 8013ffe:	9b00      	ldr	r3, [sp, #0]
 8014000:	781b      	ldrb	r3, [r3, #0]
 8014002:	f003 0310 	and.w	r3, r3, #16
 8014006:	b2da      	uxtb	r2, r3
 8014008:	9b00      	ldr	r3, [sp, #0]
 801400a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801400c:	2301      	movs	r3, #1
}
 801400e:	4618      	mov	r0, r3
 8014010:	b003      	add	sp, #12
 8014012:	f85d fb04 	ldr.w	pc, [sp], #4
 8014016:	bf00      	nop
 8014018:	f3af 8000 	nop.w
 801401c:	f3af 8000 	nop.w

08014020 <LSM303AGR_ACC_W_I2_on_INT2>:
* Input          : LSM303AGR_ACC_I2_INT2_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_I2_on_INT2(void *handle, LSM303AGR_ACC_I2_INT2_t newValue)
{
 8014020:	b500      	push	{lr}
 8014022:	b085      	sub	sp, #20
 8014024:	9001      	str	r0, [sp, #4]
 8014026:	460b      	mov	r3, r1
 8014028:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 801402c:	f10d 030f 	add.w	r3, sp, #15
 8014030:	9801      	ldr	r0, [sp, #4]
 8014032:	2125      	movs	r1, #37	; 0x25
 8014034:	461a      	mov	r2, r3
 8014036:	2301      	movs	r3, #1
 8014038:	f7fe f972 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 801403c:	4603      	mov	r3, r0
 801403e:	2b00      	cmp	r3, #0
 8014040:	d101      	bne.n	8014046 <LSM303AGR_ACC_W_I2_on_INT2+0x26>
    return MEMS_ERROR;
 8014042:	2300      	movs	r3, #0
 8014044:	e01c      	b.n	8014080 <LSM303AGR_ACC_W_I2_on_INT2+0x60>

  value &= ~LSM303AGR_ACC_I2_INT2_MASK;
 8014046:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801404a:	f023 0320 	bic.w	r3, r3, #32
 801404e:	b2db      	uxtb	r3, r3
 8014050:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014054:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014058:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801405c:	4313      	orrs	r3, r2
 801405e:	b2db      	uxtb	r3, r3
 8014060:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8014064:	f10d 030f 	add.w	r3, sp, #15
 8014068:	9801      	ldr	r0, [sp, #4]
 801406a:	2125      	movs	r1, #37	; 0x25
 801406c:	461a      	mov	r2, r3
 801406e:	2301      	movs	r3, #1
 8014070:	f7fe f936 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8014074:	4603      	mov	r3, r0
 8014076:	2b00      	cmp	r3, #0
 8014078:	d101      	bne.n	801407e <LSM303AGR_ACC_W_I2_on_INT2+0x5e>
    return MEMS_ERROR;
 801407a:	2300      	movs	r3, #0
 801407c:	e000      	b.n	8014080 <LSM303AGR_ACC_W_I2_on_INT2+0x60>

  return MEMS_SUCCESS;
 801407e:	2301      	movs	r3, #1
}
 8014080:	4618      	mov	r0, r3
 8014082:	b005      	add	sp, #20
 8014084:	f85d fb04 	ldr.w	pc, [sp], #4
 8014088:	f3af 8000 	nop.w
 801408c:	f3af 8000 	nop.w

08014090 <LSM303AGR_ACC_R_I2_on_INT2>:
* Input          : Pointer to LSM303AGR_ACC_I2_INT2_t
* Output         : Status of I2_INT2 see LSM303AGR_ACC_I2_INT2_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_I2_on_INT2(void *handle, LSM303AGR_ACC_I2_INT2_t *value)
{
 8014090:	b500      	push	{lr}
 8014092:	b083      	sub	sp, #12
 8014094:	9001      	str	r0, [sp, #4]
 8014096:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, (u8_t *)value, 1) )
 8014098:	9801      	ldr	r0, [sp, #4]
 801409a:	2125      	movs	r1, #37	; 0x25
 801409c:	9a00      	ldr	r2, [sp, #0]
 801409e:	2301      	movs	r3, #1
 80140a0:	f7fe f93e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80140a4:	4603      	mov	r3, r0
 80140a6:	2b00      	cmp	r3, #0
 80140a8:	d101      	bne.n	80140ae <LSM303AGR_ACC_R_I2_on_INT2+0x1e>
    return MEMS_ERROR;
 80140aa:	2300      	movs	r3, #0
 80140ac:	e007      	b.n	80140be <LSM303AGR_ACC_R_I2_on_INT2+0x2e>

  *value &= LSM303AGR_ACC_I2_INT2_MASK; //mask
 80140ae:	9b00      	ldr	r3, [sp, #0]
 80140b0:	781b      	ldrb	r3, [r3, #0]
 80140b2:	f003 0320 	and.w	r3, r3, #32
 80140b6:	b2da      	uxtb	r2, r3
 80140b8:	9b00      	ldr	r3, [sp, #0]
 80140ba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80140bc:	2301      	movs	r3, #1
}
 80140be:	4618      	mov	r0, r3
 80140c0:	b003      	add	sp, #12
 80140c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80140c6:	bf00      	nop
 80140c8:	f3af 8000 	nop.w
 80140cc:	f3af 8000 	nop.w

080140d0 <LSM303AGR_ACC_W_I2_on_INT1>:
* Input          : LSM303AGR_ACC_I2_INT1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_I2_on_INT1(void *handle, LSM303AGR_ACC_I2_INT1_t newValue)
{
 80140d0:	b500      	push	{lr}
 80140d2:	b085      	sub	sp, #20
 80140d4:	9001      	str	r0, [sp, #4]
 80140d6:	460b      	mov	r3, r1
 80140d8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 80140dc:	f10d 030f 	add.w	r3, sp, #15
 80140e0:	9801      	ldr	r0, [sp, #4]
 80140e2:	2125      	movs	r1, #37	; 0x25
 80140e4:	461a      	mov	r2, r3
 80140e6:	2301      	movs	r3, #1
 80140e8:	f7fe f91a 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80140ec:	4603      	mov	r3, r0
 80140ee:	2b00      	cmp	r3, #0
 80140f0:	d101      	bne.n	80140f6 <LSM303AGR_ACC_W_I2_on_INT1+0x26>
    return MEMS_ERROR;
 80140f2:	2300      	movs	r3, #0
 80140f4:	e01c      	b.n	8014130 <LSM303AGR_ACC_W_I2_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I2_INT1_MASK;
 80140f6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80140fa:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80140fe:	b2db      	uxtb	r3, r3
 8014100:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014104:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014108:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801410c:	4313      	orrs	r3, r2
 801410e:	b2db      	uxtb	r3, r3
 8014110:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8014114:	f10d 030f 	add.w	r3, sp, #15
 8014118:	9801      	ldr	r0, [sp, #4]
 801411a:	2125      	movs	r1, #37	; 0x25
 801411c:	461a      	mov	r2, r3
 801411e:	2301      	movs	r3, #1
 8014120:	f7fe f8de 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8014124:	4603      	mov	r3, r0
 8014126:	2b00      	cmp	r3, #0
 8014128:	d101      	bne.n	801412e <LSM303AGR_ACC_W_I2_on_INT1+0x5e>
    return MEMS_ERROR;
 801412a:	2300      	movs	r3, #0
 801412c:	e000      	b.n	8014130 <LSM303AGR_ACC_W_I2_on_INT1+0x60>

  return MEMS_SUCCESS;
 801412e:	2301      	movs	r3, #1
}
 8014130:	4618      	mov	r0, r3
 8014132:	b005      	add	sp, #20
 8014134:	f85d fb04 	ldr.w	pc, [sp], #4
 8014138:	f3af 8000 	nop.w
 801413c:	f3af 8000 	nop.w

08014140 <LSM303AGR_ACC_R_I2_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I2_INT1_t
* Output         : Status of I2_INT1 see LSM303AGR_ACC_I2_INT1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_I2_on_INT1(void *handle, LSM303AGR_ACC_I2_INT1_t *value)
{
 8014140:	b500      	push	{lr}
 8014142:	b083      	sub	sp, #12
 8014144:	9001      	str	r0, [sp, #4]
 8014146:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, (u8_t *)value, 1) )
 8014148:	9801      	ldr	r0, [sp, #4]
 801414a:	2125      	movs	r1, #37	; 0x25
 801414c:	9a00      	ldr	r2, [sp, #0]
 801414e:	2301      	movs	r3, #1
 8014150:	f7fe f8e6 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014154:	4603      	mov	r3, r0
 8014156:	2b00      	cmp	r3, #0
 8014158:	d101      	bne.n	801415e <LSM303AGR_ACC_R_I2_on_INT1+0x1e>
    return MEMS_ERROR;
 801415a:	2300      	movs	r3, #0
 801415c:	e007      	b.n	801416e <LSM303AGR_ACC_R_I2_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I2_INT1_MASK; //mask
 801415e:	9b00      	ldr	r3, [sp, #0]
 8014160:	781b      	ldrb	r3, [r3, #0]
 8014162:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8014166:	b2da      	uxtb	r2, r3
 8014168:	9b00      	ldr	r3, [sp, #0]
 801416a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801416c:	2301      	movs	r3, #1
}
 801416e:	4618      	mov	r0, r3
 8014170:	b003      	add	sp, #12
 8014172:	f85d fb04 	ldr.w	pc, [sp], #4
 8014176:	bf00      	nop
 8014178:	f3af 8000 	nop.w
 801417c:	f3af 8000 	nop.w

08014180 <LSM303AGR_ACC_W_Click_on_INT2>:
* Input          : LSM303AGR_ACC_I2_CLICKEN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Click_on_INT2(void *handle, LSM303AGR_ACC_I2_CLICKEN_t newValue)
{
 8014180:	b500      	push	{lr}
 8014182:	b085      	sub	sp, #20
 8014184:	9001      	str	r0, [sp, #4]
 8014186:	460b      	mov	r3, r1
 8014188:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 801418c:	f10d 030f 	add.w	r3, sp, #15
 8014190:	9801      	ldr	r0, [sp, #4]
 8014192:	2125      	movs	r1, #37	; 0x25
 8014194:	461a      	mov	r2, r3
 8014196:	2301      	movs	r3, #1
 8014198:	f7fe f8c2 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 801419c:	4603      	mov	r3, r0
 801419e:	2b00      	cmp	r3, #0
 80141a0:	d101      	bne.n	80141a6 <LSM303AGR_ACC_W_Click_on_INT2+0x26>
    return MEMS_ERROR;
 80141a2:	2300      	movs	r3, #0
 80141a4:	e01c      	b.n	80141e0 <LSM303AGR_ACC_W_Click_on_INT2+0x60>

  value &= ~LSM303AGR_ACC_I2_CLICKEN_MASK;
 80141a6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80141aa:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80141ae:	b2db      	uxtb	r3, r3
 80141b0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80141b4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80141b8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80141bc:	4313      	orrs	r3, r2
 80141be:	b2db      	uxtb	r3, r3
 80141c0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 80141c4:	f10d 030f 	add.w	r3, sp, #15
 80141c8:	9801      	ldr	r0, [sp, #4]
 80141ca:	2125      	movs	r1, #37	; 0x25
 80141cc:	461a      	mov	r2, r3
 80141ce:	2301      	movs	r3, #1
 80141d0:	f7fe f886 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 80141d4:	4603      	mov	r3, r0
 80141d6:	2b00      	cmp	r3, #0
 80141d8:	d101      	bne.n	80141de <LSM303AGR_ACC_W_Click_on_INT2+0x5e>
    return MEMS_ERROR;
 80141da:	2300      	movs	r3, #0
 80141dc:	e000      	b.n	80141e0 <LSM303AGR_ACC_W_Click_on_INT2+0x60>

  return MEMS_SUCCESS;
 80141de:	2301      	movs	r3, #1
}
 80141e0:	4618      	mov	r0, r3
 80141e2:	b005      	add	sp, #20
 80141e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80141e8:	f3af 8000 	nop.w
 80141ec:	f3af 8000 	nop.w

080141f0 <LSM303AGR_ACC_R_Click_on_INT2>:
* Input          : Pointer to LSM303AGR_ACC_I2_CLICKEN_t
* Output         : Status of I2_CLICKEN see LSM303AGR_ACC_I2_CLICKEN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Click_on_INT2(void *handle, LSM303AGR_ACC_I2_CLICKEN_t *value)
{
 80141f0:	b500      	push	{lr}
 80141f2:	b083      	sub	sp, #12
 80141f4:	9001      	str	r0, [sp, #4]
 80141f6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, (u8_t *)value, 1) )
 80141f8:	9801      	ldr	r0, [sp, #4]
 80141fa:	2125      	movs	r1, #37	; 0x25
 80141fc:	9a00      	ldr	r2, [sp, #0]
 80141fe:	2301      	movs	r3, #1
 8014200:	f7fe f88e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014204:	4603      	mov	r3, r0
 8014206:	2b00      	cmp	r3, #0
 8014208:	d101      	bne.n	801420e <LSM303AGR_ACC_R_Click_on_INT2+0x1e>
    return MEMS_ERROR;
 801420a:	2300      	movs	r3, #0
 801420c:	e007      	b.n	801421e <LSM303AGR_ACC_R_Click_on_INT2+0x2e>

  *value &= LSM303AGR_ACC_I2_CLICKEN_MASK; //mask
 801420e:	9b00      	ldr	r3, [sp, #0]
 8014210:	781b      	ldrb	r3, [r3, #0]
 8014212:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8014216:	b2da      	uxtb	r2, r3
 8014218:	9b00      	ldr	r3, [sp, #0]
 801421a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801421c:	2301      	movs	r3, #1
}
 801421e:	4618      	mov	r0, r3
 8014220:	b003      	add	sp, #12
 8014222:	f85d fb04 	ldr.w	pc, [sp], #4
 8014226:	bf00      	nop
 8014228:	f3af 8000 	nop.w
 801422c:	f3af 8000 	nop.w

08014230 <LSM303AGR_ACC_W_ReferenceVal>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ReferenceVal(void *handle, u8_t newValue)
{
 8014230:	b500      	push	{lr}
 8014232:	b085      	sub	sp, #20
 8014234:	9001      	str	r0, [sp, #4]
 8014236:	460b      	mov	r3, r1
 8014238:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_REF_POSITION; //mask
  newValue &= LSM303AGR_ACC_REF_MASK; //coerce

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_REFERENCE, &value, 1) )
 801423c:	f10d 030f 	add.w	r3, sp, #15
 8014240:	9801      	ldr	r0, [sp, #4]
 8014242:	2126      	movs	r1, #38	; 0x26
 8014244:	461a      	mov	r2, r3
 8014246:	2301      	movs	r3, #1
 8014248:	f7fe f86a 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 801424c:	4603      	mov	r3, r0
 801424e:	2b00      	cmp	r3, #0
 8014250:	d101      	bne.n	8014256 <LSM303AGR_ACC_W_ReferenceVal+0x26>
    return MEMS_ERROR;
 8014252:	2300      	movs	r3, #0
 8014254:	e018      	b.n	8014288 <LSM303AGR_ACC_W_ReferenceVal+0x58>

  value &= (u8_t)~LSM303AGR_ACC_REF_MASK;
 8014256:	2300      	movs	r3, #0
 8014258:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 801425c:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014260:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014264:	4313      	orrs	r3, r2
 8014266:	b2db      	uxtb	r3, r3
 8014268:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_REFERENCE, &value, 1) )
 801426c:	f10d 030f 	add.w	r3, sp, #15
 8014270:	9801      	ldr	r0, [sp, #4]
 8014272:	2126      	movs	r1, #38	; 0x26
 8014274:	461a      	mov	r2, r3
 8014276:	2301      	movs	r3, #1
 8014278:	f7fe f832 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 801427c:	4603      	mov	r3, r0
 801427e:	2b00      	cmp	r3, #0
 8014280:	d101      	bne.n	8014286 <LSM303AGR_ACC_W_ReferenceVal+0x56>
    return MEMS_ERROR;
 8014282:	2300      	movs	r3, #0
 8014284:	e000      	b.n	8014288 <LSM303AGR_ACC_W_ReferenceVal+0x58>

  return MEMS_SUCCESS;
 8014286:	2301      	movs	r3, #1
}
 8014288:	4618      	mov	r0, r3
 801428a:	b005      	add	sp, #20
 801428c:	f85d fb04 	ldr.w	pc, [sp], #4

08014290 <LSM303AGR_ACC_R_ReferenceVal>:
* Input          : Pointer to u8_t
* Output         : Status of REF
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ReferenceVal(void *handle, u8_t *value)
{
 8014290:	b500      	push	{lr}
 8014292:	b083      	sub	sp, #12
 8014294:	9001      	str	r0, [sp, #4]
 8014296:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_REFERENCE, (u8_t *)value, 1) )
 8014298:	9801      	ldr	r0, [sp, #4]
 801429a:	2126      	movs	r1, #38	; 0x26
 801429c:	9a00      	ldr	r2, [sp, #0]
 801429e:	2301      	movs	r3, #1
 80142a0:	f7fe f83e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80142a4:	4603      	mov	r3, r0
 80142a6:	2b00      	cmp	r3, #0
 80142a8:	d101      	bne.n	80142ae <LSM303AGR_ACC_R_ReferenceVal+0x1e>
    return MEMS_ERROR;
 80142aa:	2300      	movs	r3, #0
 80142ac:	e008      	b.n	80142c0 <LSM303AGR_ACC_R_ReferenceVal+0x30>

  *value &= LSM303AGR_ACC_REF_MASK; //coerce
 80142ae:	9b00      	ldr	r3, [sp, #0]
 80142b0:	781a      	ldrb	r2, [r3, #0]
 80142b2:	9b00      	ldr	r3, [sp, #0]
 80142b4:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_REF_POSITION; //mask
 80142b6:	9b00      	ldr	r3, [sp, #0]
 80142b8:	781a      	ldrb	r2, [r3, #0]
 80142ba:	9b00      	ldr	r3, [sp, #0]
 80142bc:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80142be:	2301      	movs	r3, #1
}
 80142c0:	4618      	mov	r0, r3
 80142c2:	b003      	add	sp, #12
 80142c4:	f85d fb04 	ldr.w	pc, [sp], #4
 80142c8:	f3af 8000 	nop.w
 80142cc:	f3af 8000 	nop.w

080142d0 <LSM303AGR_ACC_R_XDataAvail>:
* Input          : Pointer to LSM303AGR_ACC_XDA_t
* Output         : Status of XDA see LSM303AGR_ACC_XDA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XDataAvail(void *handle, LSM303AGR_ACC_XDA_t *value)
{
 80142d0:	b500      	push	{lr}
 80142d2:	b083      	sub	sp, #12
 80142d4:	9001      	str	r0, [sp, #4]
 80142d6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 80142d8:	9801      	ldr	r0, [sp, #4]
 80142da:	2127      	movs	r1, #39	; 0x27
 80142dc:	9a00      	ldr	r2, [sp, #0]
 80142de:	2301      	movs	r3, #1
 80142e0:	f7fe f81e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80142e4:	4603      	mov	r3, r0
 80142e6:	2b00      	cmp	r3, #0
 80142e8:	d101      	bne.n	80142ee <LSM303AGR_ACC_R_XDataAvail+0x1e>
    return MEMS_ERROR;
 80142ea:	2300      	movs	r3, #0
 80142ec:	e007      	b.n	80142fe <LSM303AGR_ACC_R_XDataAvail+0x2e>

  *value &= LSM303AGR_ACC_XDA_MASK; //mask
 80142ee:	9b00      	ldr	r3, [sp, #0]
 80142f0:	781b      	ldrb	r3, [r3, #0]
 80142f2:	f003 0301 	and.w	r3, r3, #1
 80142f6:	b2da      	uxtb	r2, r3
 80142f8:	9b00      	ldr	r3, [sp, #0]
 80142fa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80142fc:	2301      	movs	r3, #1
}
 80142fe:	4618      	mov	r0, r3
 8014300:	b003      	add	sp, #12
 8014302:	f85d fb04 	ldr.w	pc, [sp], #4
 8014306:	bf00      	nop
 8014308:	f3af 8000 	nop.w
 801430c:	f3af 8000 	nop.w

08014310 <LSM303AGR_ACC_R_YDataAvail>:
* Input          : Pointer to LSM303AGR_ACC_YDA_t
* Output         : Status of YDA see LSM303AGR_ACC_YDA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_YDataAvail(void *handle, LSM303AGR_ACC_YDA_t *value)
{
 8014310:	b500      	push	{lr}
 8014312:	b083      	sub	sp, #12
 8014314:	9001      	str	r0, [sp, #4]
 8014316:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8014318:	9801      	ldr	r0, [sp, #4]
 801431a:	2127      	movs	r1, #39	; 0x27
 801431c:	9a00      	ldr	r2, [sp, #0]
 801431e:	2301      	movs	r3, #1
 8014320:	f7fd fffe 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014324:	4603      	mov	r3, r0
 8014326:	2b00      	cmp	r3, #0
 8014328:	d101      	bne.n	801432e <LSM303AGR_ACC_R_YDataAvail+0x1e>
    return MEMS_ERROR;
 801432a:	2300      	movs	r3, #0
 801432c:	e007      	b.n	801433e <LSM303AGR_ACC_R_YDataAvail+0x2e>

  *value &= LSM303AGR_ACC_YDA_MASK; //mask
 801432e:	9b00      	ldr	r3, [sp, #0]
 8014330:	781b      	ldrb	r3, [r3, #0]
 8014332:	f003 0302 	and.w	r3, r3, #2
 8014336:	b2da      	uxtb	r2, r3
 8014338:	9b00      	ldr	r3, [sp, #0]
 801433a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801433c:	2301      	movs	r3, #1
}
 801433e:	4618      	mov	r0, r3
 8014340:	b003      	add	sp, #12
 8014342:	f85d fb04 	ldr.w	pc, [sp], #4
 8014346:	bf00      	nop
 8014348:	f3af 8000 	nop.w
 801434c:	f3af 8000 	nop.w

08014350 <LSM303AGR_ACC_R_ZDataAvail>:
* Input          : Pointer to LSM303AGR_ACC_ZDA_t
* Output         : Status of ZDA see LSM303AGR_ACC_ZDA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ZDataAvail(void *handle, LSM303AGR_ACC_ZDA_t *value)
{
 8014350:	b500      	push	{lr}
 8014352:	b083      	sub	sp, #12
 8014354:	9001      	str	r0, [sp, #4]
 8014356:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8014358:	9801      	ldr	r0, [sp, #4]
 801435a:	2127      	movs	r1, #39	; 0x27
 801435c:	9a00      	ldr	r2, [sp, #0]
 801435e:	2301      	movs	r3, #1
 8014360:	f7fd ffde 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014364:	4603      	mov	r3, r0
 8014366:	2b00      	cmp	r3, #0
 8014368:	d101      	bne.n	801436e <LSM303AGR_ACC_R_ZDataAvail+0x1e>
    return MEMS_ERROR;
 801436a:	2300      	movs	r3, #0
 801436c:	e007      	b.n	801437e <LSM303AGR_ACC_R_ZDataAvail+0x2e>

  *value &= LSM303AGR_ACC_ZDA_MASK; //mask
 801436e:	9b00      	ldr	r3, [sp, #0]
 8014370:	781b      	ldrb	r3, [r3, #0]
 8014372:	f003 0304 	and.w	r3, r3, #4
 8014376:	b2da      	uxtb	r2, r3
 8014378:	9b00      	ldr	r3, [sp, #0]
 801437a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801437c:	2301      	movs	r3, #1
}
 801437e:	4618      	mov	r0, r3
 8014380:	b003      	add	sp, #12
 8014382:	f85d fb04 	ldr.w	pc, [sp], #4
 8014386:	bf00      	nop
 8014388:	f3af 8000 	nop.w
 801438c:	f3af 8000 	nop.w

08014390 <LSM303AGR_ACC_R_XYZDataAvail>:
* Input          : Pointer to LSM303AGR_ACC_ZYXDA_t
* Output         : Status of ZYXDA see LSM303AGR_ACC_ZYXDA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XYZDataAvail(void *handle, LSM303AGR_ACC_ZYXDA_t *value)
{
 8014390:	b500      	push	{lr}
 8014392:	b083      	sub	sp, #12
 8014394:	9001      	str	r0, [sp, #4]
 8014396:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8014398:	9801      	ldr	r0, [sp, #4]
 801439a:	2127      	movs	r1, #39	; 0x27
 801439c:	9a00      	ldr	r2, [sp, #0]
 801439e:	2301      	movs	r3, #1
 80143a0:	f7fd ffbe 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80143a4:	4603      	mov	r3, r0
 80143a6:	2b00      	cmp	r3, #0
 80143a8:	d101      	bne.n	80143ae <LSM303AGR_ACC_R_XYZDataAvail+0x1e>
    return MEMS_ERROR;
 80143aa:	2300      	movs	r3, #0
 80143ac:	e007      	b.n	80143be <LSM303AGR_ACC_R_XYZDataAvail+0x2e>

  *value &= LSM303AGR_ACC_ZYXDA_MASK; //mask
 80143ae:	9b00      	ldr	r3, [sp, #0]
 80143b0:	781b      	ldrb	r3, [r3, #0]
 80143b2:	f003 0308 	and.w	r3, r3, #8
 80143b6:	b2da      	uxtb	r2, r3
 80143b8:	9b00      	ldr	r3, [sp, #0]
 80143ba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80143bc:	2301      	movs	r3, #1
}
 80143be:	4618      	mov	r0, r3
 80143c0:	b003      	add	sp, #12
 80143c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80143c6:	bf00      	nop
 80143c8:	f3af 8000 	nop.w
 80143cc:	f3af 8000 	nop.w

080143d0 <LSM303AGR_ACC_R_XDataOverrun>:
* Input          : Pointer to LSM303AGR_ACC_XOR_t
* Output         : Status of XOR see LSM303AGR_ACC_XOR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XDataOverrun(void *handle, LSM303AGR_ACC_XOR_t *value)
{
 80143d0:	b500      	push	{lr}
 80143d2:	b083      	sub	sp, #12
 80143d4:	9001      	str	r0, [sp, #4]
 80143d6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 80143d8:	9801      	ldr	r0, [sp, #4]
 80143da:	2127      	movs	r1, #39	; 0x27
 80143dc:	9a00      	ldr	r2, [sp, #0]
 80143de:	2301      	movs	r3, #1
 80143e0:	f7fd ff9e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80143e4:	4603      	mov	r3, r0
 80143e6:	2b00      	cmp	r3, #0
 80143e8:	d101      	bne.n	80143ee <LSM303AGR_ACC_R_XDataOverrun+0x1e>
    return MEMS_ERROR;
 80143ea:	2300      	movs	r3, #0
 80143ec:	e007      	b.n	80143fe <LSM303AGR_ACC_R_XDataOverrun+0x2e>

  *value &= LSM303AGR_ACC_XOR_MASK; //mask
 80143ee:	9b00      	ldr	r3, [sp, #0]
 80143f0:	781b      	ldrb	r3, [r3, #0]
 80143f2:	f003 0310 	and.w	r3, r3, #16
 80143f6:	b2da      	uxtb	r2, r3
 80143f8:	9b00      	ldr	r3, [sp, #0]
 80143fa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80143fc:	2301      	movs	r3, #1
}
 80143fe:	4618      	mov	r0, r3
 8014400:	b003      	add	sp, #12
 8014402:	f85d fb04 	ldr.w	pc, [sp], #4
 8014406:	bf00      	nop
 8014408:	f3af 8000 	nop.w
 801440c:	f3af 8000 	nop.w

08014410 <LSM303AGR_ACC_R_YDataOverrun>:
* Input          : Pointer to LSM303AGR_ACC_YOR_t
* Output         : Status of YOR see LSM303AGR_ACC_YOR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_YDataOverrun(void *handle, LSM303AGR_ACC_YOR_t *value)
{
 8014410:	b500      	push	{lr}
 8014412:	b083      	sub	sp, #12
 8014414:	9001      	str	r0, [sp, #4]
 8014416:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8014418:	9801      	ldr	r0, [sp, #4]
 801441a:	2127      	movs	r1, #39	; 0x27
 801441c:	9a00      	ldr	r2, [sp, #0]
 801441e:	2301      	movs	r3, #1
 8014420:	f7fd ff7e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014424:	4603      	mov	r3, r0
 8014426:	2b00      	cmp	r3, #0
 8014428:	d101      	bne.n	801442e <LSM303AGR_ACC_R_YDataOverrun+0x1e>
    return MEMS_ERROR;
 801442a:	2300      	movs	r3, #0
 801442c:	e007      	b.n	801443e <LSM303AGR_ACC_R_YDataOverrun+0x2e>

  *value &= LSM303AGR_ACC_YOR_MASK; //mask
 801442e:	9b00      	ldr	r3, [sp, #0]
 8014430:	781b      	ldrb	r3, [r3, #0]
 8014432:	f003 0320 	and.w	r3, r3, #32
 8014436:	b2da      	uxtb	r2, r3
 8014438:	9b00      	ldr	r3, [sp, #0]
 801443a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801443c:	2301      	movs	r3, #1
}
 801443e:	4618      	mov	r0, r3
 8014440:	b003      	add	sp, #12
 8014442:	f85d fb04 	ldr.w	pc, [sp], #4
 8014446:	bf00      	nop
 8014448:	f3af 8000 	nop.w
 801444c:	f3af 8000 	nop.w

08014450 <LSM303AGR_ACC_R_ZDataOverrun>:
* Input          : Pointer to LSM303AGR_ACC_ZOR_t
* Output         : Status of ZOR see LSM303AGR_ACC_ZOR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ZDataOverrun(void *handle, LSM303AGR_ACC_ZOR_t *value)
{
 8014450:	b500      	push	{lr}
 8014452:	b083      	sub	sp, #12
 8014454:	9001      	str	r0, [sp, #4]
 8014456:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8014458:	9801      	ldr	r0, [sp, #4]
 801445a:	2127      	movs	r1, #39	; 0x27
 801445c:	9a00      	ldr	r2, [sp, #0]
 801445e:	2301      	movs	r3, #1
 8014460:	f7fd ff5e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014464:	4603      	mov	r3, r0
 8014466:	2b00      	cmp	r3, #0
 8014468:	d101      	bne.n	801446e <LSM303AGR_ACC_R_ZDataOverrun+0x1e>
    return MEMS_ERROR;
 801446a:	2300      	movs	r3, #0
 801446c:	e007      	b.n	801447e <LSM303AGR_ACC_R_ZDataOverrun+0x2e>

  *value &= LSM303AGR_ACC_ZOR_MASK; //mask
 801446e:	9b00      	ldr	r3, [sp, #0]
 8014470:	781b      	ldrb	r3, [r3, #0]
 8014472:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8014476:	b2da      	uxtb	r2, r3
 8014478:	9b00      	ldr	r3, [sp, #0]
 801447a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801447c:	2301      	movs	r3, #1
}
 801447e:	4618      	mov	r0, r3
 8014480:	b003      	add	sp, #12
 8014482:	f85d fb04 	ldr.w	pc, [sp], #4
 8014486:	bf00      	nop
 8014488:	f3af 8000 	nop.w
 801448c:	f3af 8000 	nop.w

08014490 <LSM303AGR_ACC_R_XYZDataOverrun>:
* Input          : Pointer to LSM303AGR_ACC_ZYXOR_t
* Output         : Status of ZYXOR see LSM303AGR_ACC_ZYXOR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XYZDataOverrun(void *handle, LSM303AGR_ACC_ZYXOR_t *value)
{
 8014490:	b500      	push	{lr}
 8014492:	b083      	sub	sp, #12
 8014494:	9001      	str	r0, [sp, #4]
 8014496:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8014498:	9801      	ldr	r0, [sp, #4]
 801449a:	2127      	movs	r1, #39	; 0x27
 801449c:	9a00      	ldr	r2, [sp, #0]
 801449e:	2301      	movs	r3, #1
 80144a0:	f7fd ff3e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80144a4:	4603      	mov	r3, r0
 80144a6:	2b00      	cmp	r3, #0
 80144a8:	d101      	bne.n	80144ae <LSM303AGR_ACC_R_XYZDataOverrun+0x1e>
    return MEMS_ERROR;
 80144aa:	2300      	movs	r3, #0
 80144ac:	e007      	b.n	80144be <LSM303AGR_ACC_R_XYZDataOverrun+0x2e>

  *value &= LSM303AGR_ACC_ZYXOR_MASK; //mask
 80144ae:	9b00      	ldr	r3, [sp, #0]
 80144b0:	781b      	ldrb	r3, [r3, #0]
 80144b2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80144b6:	b2da      	uxtb	r2, r3
 80144b8:	9b00      	ldr	r3, [sp, #0]
 80144ba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80144bc:	2301      	movs	r3, #1
}
 80144be:	4618      	mov	r0, r3
 80144c0:	b003      	add	sp, #12
 80144c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80144c6:	bf00      	nop
 80144c8:	f3af 8000 	nop.w
 80144cc:	f3af 8000 	nop.w

080144d0 <LSM303AGR_ACC_W_FifoThreshold>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FifoThreshold(void *handle, u8_t newValue)
{
 80144d0:	b500      	push	{lr}
 80144d2:	b085      	sub	sp, #20
 80144d4:	9001      	str	r0, [sp, #4]
 80144d6:	460b      	mov	r3, r1
 80144d8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_FTH_POSITION; //mask
  newValue &= LSM303AGR_ACC_FTH_MASK; //coerce
 80144dc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80144e0:	f003 031f 	and.w	r3, r3, #31
 80144e4:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
 80144e8:	f10d 030f 	add.w	r3, sp, #15
 80144ec:	9801      	ldr	r0, [sp, #4]
 80144ee:	212e      	movs	r1, #46	; 0x2e
 80144f0:	461a      	mov	r2, r3
 80144f2:	2301      	movs	r3, #1
 80144f4:	f7fd ff14 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80144f8:	4603      	mov	r3, r0
 80144fa:	2b00      	cmp	r3, #0
 80144fc:	d101      	bne.n	8014502 <LSM303AGR_ACC_W_FifoThreshold+0x32>
    return MEMS_ERROR;
 80144fe:	2300      	movs	r3, #0
 8014500:	e01c      	b.n	801453c <LSM303AGR_ACC_W_FifoThreshold+0x6c>

  value &= ~LSM303AGR_ACC_FTH_MASK;
 8014502:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014506:	f023 031f 	bic.w	r3, r3, #31
 801450a:	b2db      	uxtb	r3, r3
 801450c:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014510:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014514:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014518:	4313      	orrs	r3, r2
 801451a:	b2db      	uxtb	r3, r3
 801451c:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
 8014520:	f10d 030f 	add.w	r3, sp, #15
 8014524:	9801      	ldr	r0, [sp, #4]
 8014526:	212e      	movs	r1, #46	; 0x2e
 8014528:	461a      	mov	r2, r3
 801452a:	2301      	movs	r3, #1
 801452c:	f7fd fed8 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8014530:	4603      	mov	r3, r0
 8014532:	2b00      	cmp	r3, #0
 8014534:	d101      	bne.n	801453a <LSM303AGR_ACC_W_FifoThreshold+0x6a>
    return MEMS_ERROR;
 8014536:	2300      	movs	r3, #0
 8014538:	e000      	b.n	801453c <LSM303AGR_ACC_W_FifoThreshold+0x6c>

  return MEMS_SUCCESS;
 801453a:	2301      	movs	r3, #1
}
 801453c:	4618      	mov	r0, r3
 801453e:	b005      	add	sp, #20
 8014540:	f85d fb04 	ldr.w	pc, [sp], #4
 8014544:	f3af 8000 	nop.w
 8014548:	f3af 8000 	nop.w
 801454c:	f3af 8000 	nop.w

08014550 <LSM303AGR_ACC_R_FifoThreshold>:
* Input          : Pointer to u8_t
* Output         : Status of FTH
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FifoThreshold(void *handle, u8_t *value)
{
 8014550:	b500      	push	{lr}
 8014552:	b083      	sub	sp, #12
 8014554:	9001      	str	r0, [sp, #4]
 8014556:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, (u8_t *)value, 1) )
 8014558:	9801      	ldr	r0, [sp, #4]
 801455a:	212e      	movs	r1, #46	; 0x2e
 801455c:	9a00      	ldr	r2, [sp, #0]
 801455e:	2301      	movs	r3, #1
 8014560:	f7fd fede 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014564:	4603      	mov	r3, r0
 8014566:	2b00      	cmp	r3, #0
 8014568:	d101      	bne.n	801456e <LSM303AGR_ACC_R_FifoThreshold+0x1e>
    return MEMS_ERROR;
 801456a:	2300      	movs	r3, #0
 801456c:	e00b      	b.n	8014586 <LSM303AGR_ACC_R_FifoThreshold+0x36>

  *value &= LSM303AGR_ACC_FTH_MASK; //coerce
 801456e:	9b00      	ldr	r3, [sp, #0]
 8014570:	781b      	ldrb	r3, [r3, #0]
 8014572:	f003 031f 	and.w	r3, r3, #31
 8014576:	b2da      	uxtb	r2, r3
 8014578:	9b00      	ldr	r3, [sp, #0]
 801457a:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_FTH_POSITION; //mask
 801457c:	9b00      	ldr	r3, [sp, #0]
 801457e:	781a      	ldrb	r2, [r3, #0]
 8014580:	9b00      	ldr	r3, [sp, #0]
 8014582:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014584:	2301      	movs	r3, #1
}
 8014586:	4618      	mov	r0, r3
 8014588:	b003      	add	sp, #12
 801458a:	f85d fb04 	ldr.w	pc, [sp], #4
 801458e:	bf00      	nop

08014590 <LSM303AGR_ACC_W_TriggerSel>:
* Input          : LSM303AGR_ACC_TR_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_TriggerSel(void *handle, LSM303AGR_ACC_TR_t newValue)
{
 8014590:	b500      	push	{lr}
 8014592:	b085      	sub	sp, #20
 8014594:	9001      	str	r0, [sp, #4]
 8014596:	460b      	mov	r3, r1
 8014598:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
 801459c:	f10d 030f 	add.w	r3, sp, #15
 80145a0:	9801      	ldr	r0, [sp, #4]
 80145a2:	212e      	movs	r1, #46	; 0x2e
 80145a4:	461a      	mov	r2, r3
 80145a6:	2301      	movs	r3, #1
 80145a8:	f7fd feba 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80145ac:	4603      	mov	r3, r0
 80145ae:	2b00      	cmp	r3, #0
 80145b0:	d101      	bne.n	80145b6 <LSM303AGR_ACC_W_TriggerSel+0x26>
    return MEMS_ERROR;
 80145b2:	2300      	movs	r3, #0
 80145b4:	e01c      	b.n	80145f0 <LSM303AGR_ACC_W_TriggerSel+0x60>

  value &= ~LSM303AGR_ACC_TR_MASK;
 80145b6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80145ba:	f023 0320 	bic.w	r3, r3, #32
 80145be:	b2db      	uxtb	r3, r3
 80145c0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80145c4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80145c8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80145cc:	4313      	orrs	r3, r2
 80145ce:	b2db      	uxtb	r3, r3
 80145d0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
 80145d4:	f10d 030f 	add.w	r3, sp, #15
 80145d8:	9801      	ldr	r0, [sp, #4]
 80145da:	212e      	movs	r1, #46	; 0x2e
 80145dc:	461a      	mov	r2, r3
 80145de:	2301      	movs	r3, #1
 80145e0:	f7fd fe7e 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 80145e4:	4603      	mov	r3, r0
 80145e6:	2b00      	cmp	r3, #0
 80145e8:	d101      	bne.n	80145ee <LSM303AGR_ACC_W_TriggerSel+0x5e>
    return MEMS_ERROR;
 80145ea:	2300      	movs	r3, #0
 80145ec:	e000      	b.n	80145f0 <LSM303AGR_ACC_W_TriggerSel+0x60>

  return MEMS_SUCCESS;
 80145ee:	2301      	movs	r3, #1
}
 80145f0:	4618      	mov	r0, r3
 80145f2:	b005      	add	sp, #20
 80145f4:	f85d fb04 	ldr.w	pc, [sp], #4
 80145f8:	f3af 8000 	nop.w
 80145fc:	f3af 8000 	nop.w

08014600 <LSM303AGR_ACC_R_TriggerSel>:
* Input          : Pointer to LSM303AGR_ACC_TR_t
* Output         : Status of TR see LSM303AGR_ACC_TR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_TriggerSel(void *handle, LSM303AGR_ACC_TR_t *value)
{
 8014600:	b500      	push	{lr}
 8014602:	b083      	sub	sp, #12
 8014604:	9001      	str	r0, [sp, #4]
 8014606:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, (u8_t *)value, 1) )
 8014608:	9801      	ldr	r0, [sp, #4]
 801460a:	212e      	movs	r1, #46	; 0x2e
 801460c:	9a00      	ldr	r2, [sp, #0]
 801460e:	2301      	movs	r3, #1
 8014610:	f7fd fe86 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014614:	4603      	mov	r3, r0
 8014616:	2b00      	cmp	r3, #0
 8014618:	d101      	bne.n	801461e <LSM303AGR_ACC_R_TriggerSel+0x1e>
    return MEMS_ERROR;
 801461a:	2300      	movs	r3, #0
 801461c:	e007      	b.n	801462e <LSM303AGR_ACC_R_TriggerSel+0x2e>

  *value &= LSM303AGR_ACC_TR_MASK; //mask
 801461e:	9b00      	ldr	r3, [sp, #0]
 8014620:	781b      	ldrb	r3, [r3, #0]
 8014622:	f003 0320 	and.w	r3, r3, #32
 8014626:	b2da      	uxtb	r2, r3
 8014628:	9b00      	ldr	r3, [sp, #0]
 801462a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801462c:	2301      	movs	r3, #1
}
 801462e:	4618      	mov	r0, r3
 8014630:	b003      	add	sp, #12
 8014632:	f85d fb04 	ldr.w	pc, [sp], #4
 8014636:	bf00      	nop
 8014638:	f3af 8000 	nop.w
 801463c:	f3af 8000 	nop.w

08014640 <LSM303AGR_ACC_W_FifoMode>:
* Input          : LSM303AGR_ACC_FM_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FifoMode(void *handle, LSM303AGR_ACC_FM_t newValue)
{
 8014640:	b500      	push	{lr}
 8014642:	b085      	sub	sp, #20
 8014644:	9001      	str	r0, [sp, #4]
 8014646:	460b      	mov	r3, r1
 8014648:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
 801464c:	f10d 030f 	add.w	r3, sp, #15
 8014650:	9801      	ldr	r0, [sp, #4]
 8014652:	212e      	movs	r1, #46	; 0x2e
 8014654:	461a      	mov	r2, r3
 8014656:	2301      	movs	r3, #1
 8014658:	f7fd fe62 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 801465c:	4603      	mov	r3, r0
 801465e:	2b00      	cmp	r3, #0
 8014660:	d101      	bne.n	8014666 <LSM303AGR_ACC_W_FifoMode+0x26>
    return MEMS_ERROR;
 8014662:	2300      	movs	r3, #0
 8014664:	e01c      	b.n	80146a0 <LSM303AGR_ACC_W_FifoMode+0x60>

  value &= ~LSM303AGR_ACC_FM_MASK;
 8014666:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801466a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801466e:	b2db      	uxtb	r3, r3
 8014670:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014674:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014678:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801467c:	4313      	orrs	r3, r2
 801467e:	b2db      	uxtb	r3, r3
 8014680:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
 8014684:	f10d 030f 	add.w	r3, sp, #15
 8014688:	9801      	ldr	r0, [sp, #4]
 801468a:	212e      	movs	r1, #46	; 0x2e
 801468c:	461a      	mov	r2, r3
 801468e:	2301      	movs	r3, #1
 8014690:	f7fd fe26 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8014694:	4603      	mov	r3, r0
 8014696:	2b00      	cmp	r3, #0
 8014698:	d101      	bne.n	801469e <LSM303AGR_ACC_W_FifoMode+0x5e>
    return MEMS_ERROR;
 801469a:	2300      	movs	r3, #0
 801469c:	e000      	b.n	80146a0 <LSM303AGR_ACC_W_FifoMode+0x60>

  return MEMS_SUCCESS;
 801469e:	2301      	movs	r3, #1
}
 80146a0:	4618      	mov	r0, r3
 80146a2:	b005      	add	sp, #20
 80146a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80146a8:	f3af 8000 	nop.w
 80146ac:	f3af 8000 	nop.w

080146b0 <LSM303AGR_ACC_R_FifoMode>:
* Input          : Pointer to LSM303AGR_ACC_FM_t
* Output         : Status of FM see LSM303AGR_ACC_FM_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FifoMode(void *handle, LSM303AGR_ACC_FM_t *value)
{
 80146b0:	b500      	push	{lr}
 80146b2:	b083      	sub	sp, #12
 80146b4:	9001      	str	r0, [sp, #4]
 80146b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, (u8_t *)value, 1) )
 80146b8:	9801      	ldr	r0, [sp, #4]
 80146ba:	212e      	movs	r1, #46	; 0x2e
 80146bc:	9a00      	ldr	r2, [sp, #0]
 80146be:	2301      	movs	r3, #1
 80146c0:	f7fd fe2e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80146c4:	4603      	mov	r3, r0
 80146c6:	2b00      	cmp	r3, #0
 80146c8:	d101      	bne.n	80146ce <LSM303AGR_ACC_R_FifoMode+0x1e>
    return MEMS_ERROR;
 80146ca:	2300      	movs	r3, #0
 80146cc:	e007      	b.n	80146de <LSM303AGR_ACC_R_FifoMode+0x2e>

  *value &= LSM303AGR_ACC_FM_MASK; //mask
 80146ce:	9b00      	ldr	r3, [sp, #0]
 80146d0:	781b      	ldrb	r3, [r3, #0]
 80146d2:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 80146d6:	b2da      	uxtb	r2, r3
 80146d8:	9b00      	ldr	r3, [sp, #0]
 80146da:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80146dc:	2301      	movs	r3, #1
}
 80146de:	4618      	mov	r0, r3
 80146e0:	b003      	add	sp, #12
 80146e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80146e6:	bf00      	nop
 80146e8:	f3af 8000 	nop.w
 80146ec:	f3af 8000 	nop.w

080146f0 <LSM303AGR_ACC_R_FifoSamplesAvail>:
* Input          : Pointer to u8_t
* Output         : Status of FSS
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FifoSamplesAvail(void *handle, u8_t *value)
{
 80146f0:	b500      	push	{lr}
 80146f2:	b083      	sub	sp, #12
 80146f4:	9001      	str	r0, [sp, #4]
 80146f6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_SRC_REG, (u8_t *)value, 1) )
 80146f8:	9801      	ldr	r0, [sp, #4]
 80146fa:	212f      	movs	r1, #47	; 0x2f
 80146fc:	9a00      	ldr	r2, [sp, #0]
 80146fe:	2301      	movs	r3, #1
 8014700:	f7fd fe0e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014704:	4603      	mov	r3, r0
 8014706:	2b00      	cmp	r3, #0
 8014708:	d101      	bne.n	801470e <LSM303AGR_ACC_R_FifoSamplesAvail+0x1e>
    return MEMS_ERROR;
 801470a:	2300      	movs	r3, #0
 801470c:	e00b      	b.n	8014726 <LSM303AGR_ACC_R_FifoSamplesAvail+0x36>

  *value &= LSM303AGR_ACC_FSS_MASK; //coerce
 801470e:	9b00      	ldr	r3, [sp, #0]
 8014710:	781b      	ldrb	r3, [r3, #0]
 8014712:	f003 031f 	and.w	r3, r3, #31
 8014716:	b2da      	uxtb	r2, r3
 8014718:	9b00      	ldr	r3, [sp, #0]
 801471a:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_FSS_POSITION; //mask
 801471c:	9b00      	ldr	r3, [sp, #0]
 801471e:	781a      	ldrb	r2, [r3, #0]
 8014720:	9b00      	ldr	r3, [sp, #0]
 8014722:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014724:	2301      	movs	r3, #1
}
 8014726:	4618      	mov	r0, r3
 8014728:	b003      	add	sp, #12
 801472a:	f85d fb04 	ldr.w	pc, [sp], #4
 801472e:	bf00      	nop

08014730 <LSM303AGR_ACC_R_FifoEmpty>:
* Input          : Pointer to LSM303AGR_ACC_EMPTY_t
* Output         : Status of EMPTY see LSM303AGR_ACC_EMPTY_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FifoEmpty(void *handle, LSM303AGR_ACC_EMPTY_t *value)
{
 8014730:	b500      	push	{lr}
 8014732:	b083      	sub	sp, #12
 8014734:	9001      	str	r0, [sp, #4]
 8014736:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_SRC_REG, (u8_t *)value, 1) )
 8014738:	9801      	ldr	r0, [sp, #4]
 801473a:	212f      	movs	r1, #47	; 0x2f
 801473c:	9a00      	ldr	r2, [sp, #0]
 801473e:	2301      	movs	r3, #1
 8014740:	f7fd fdee 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014744:	4603      	mov	r3, r0
 8014746:	2b00      	cmp	r3, #0
 8014748:	d101      	bne.n	801474e <LSM303AGR_ACC_R_FifoEmpty+0x1e>
    return MEMS_ERROR;
 801474a:	2300      	movs	r3, #0
 801474c:	e007      	b.n	801475e <LSM303AGR_ACC_R_FifoEmpty+0x2e>

  *value &= LSM303AGR_ACC_EMPTY_MASK; //mask
 801474e:	9b00      	ldr	r3, [sp, #0]
 8014750:	781b      	ldrb	r3, [r3, #0]
 8014752:	f003 0320 	and.w	r3, r3, #32
 8014756:	b2da      	uxtb	r2, r3
 8014758:	9b00      	ldr	r3, [sp, #0]
 801475a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801475c:	2301      	movs	r3, #1
}
 801475e:	4618      	mov	r0, r3
 8014760:	b003      	add	sp, #12
 8014762:	f85d fb04 	ldr.w	pc, [sp], #4
 8014766:	bf00      	nop
 8014768:	f3af 8000 	nop.w
 801476c:	f3af 8000 	nop.w

08014770 <LSM303AGR_ACC_R_FifoOverrun>:
* Input          : Pointer to LSM303AGR_ACC_OVRN_FIFO_t
* Output         : Status of OVRN_FIFO see LSM303AGR_ACC_OVRN_FIFO_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FifoOverrun(void *handle, LSM303AGR_ACC_OVRN_FIFO_t *value)
{
 8014770:	b500      	push	{lr}
 8014772:	b083      	sub	sp, #12
 8014774:	9001      	str	r0, [sp, #4]
 8014776:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_SRC_REG, (u8_t *)value, 1) )
 8014778:	9801      	ldr	r0, [sp, #4]
 801477a:	212f      	movs	r1, #47	; 0x2f
 801477c:	9a00      	ldr	r2, [sp, #0]
 801477e:	2301      	movs	r3, #1
 8014780:	f7fd fdce 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014784:	4603      	mov	r3, r0
 8014786:	2b00      	cmp	r3, #0
 8014788:	d101      	bne.n	801478e <LSM303AGR_ACC_R_FifoOverrun+0x1e>
    return MEMS_ERROR;
 801478a:	2300      	movs	r3, #0
 801478c:	e007      	b.n	801479e <LSM303AGR_ACC_R_FifoOverrun+0x2e>

  *value &= LSM303AGR_ACC_OVRN_FIFO_MASK; //mask
 801478e:	9b00      	ldr	r3, [sp, #0]
 8014790:	781b      	ldrb	r3, [r3, #0]
 8014792:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8014796:	b2da      	uxtb	r2, r3
 8014798:	9b00      	ldr	r3, [sp, #0]
 801479a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801479c:	2301      	movs	r3, #1
}
 801479e:	4618      	mov	r0, r3
 80147a0:	b003      	add	sp, #12
 80147a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80147a6:	bf00      	nop
 80147a8:	f3af 8000 	nop.w
 80147ac:	f3af 8000 	nop.w

080147b0 <LSM303AGR_ACC_R_WatermarkLevel>:
* Input          : Pointer to LSM303AGR_ACC_WTM_t
* Output         : Status of WTM see LSM303AGR_ACC_WTM_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_WatermarkLevel(void *handle, LSM303AGR_ACC_WTM_t *value)
{
 80147b0:	b500      	push	{lr}
 80147b2:	b083      	sub	sp, #12
 80147b4:	9001      	str	r0, [sp, #4]
 80147b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_SRC_REG, (u8_t *)value, 1) )
 80147b8:	9801      	ldr	r0, [sp, #4]
 80147ba:	212f      	movs	r1, #47	; 0x2f
 80147bc:	9a00      	ldr	r2, [sp, #0]
 80147be:	2301      	movs	r3, #1
 80147c0:	f7fd fdae 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80147c4:	4603      	mov	r3, r0
 80147c6:	2b00      	cmp	r3, #0
 80147c8:	d101      	bne.n	80147ce <LSM303AGR_ACC_R_WatermarkLevel+0x1e>
    return MEMS_ERROR;
 80147ca:	2300      	movs	r3, #0
 80147cc:	e007      	b.n	80147de <LSM303AGR_ACC_R_WatermarkLevel+0x2e>

  *value &= LSM303AGR_ACC_WTM_MASK; //mask
 80147ce:	9b00      	ldr	r3, [sp, #0]
 80147d0:	781b      	ldrb	r3, [r3, #0]
 80147d2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80147d6:	b2da      	uxtb	r2, r3
 80147d8:	9b00      	ldr	r3, [sp, #0]
 80147da:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80147dc:	2301      	movs	r3, #1
}
 80147de:	4618      	mov	r0, r3
 80147e0:	b003      	add	sp, #12
 80147e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80147e6:	bf00      	nop
 80147e8:	f3af 8000 	nop.w
 80147ec:	f3af 8000 	nop.w

080147f0 <LSM303AGR_ACC_W_Int1EnXLo>:
* Input          : LSM303AGR_ACC_XLIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1EnXLo(void *handle, LSM303AGR_ACC_XLIE_t newValue)
{
 80147f0:	b500      	push	{lr}
 80147f2:	b085      	sub	sp, #20
 80147f4:	9001      	str	r0, [sp, #4]
 80147f6:	460b      	mov	r3, r1
 80147f8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 80147fc:	f10d 030f 	add.w	r3, sp, #15
 8014800:	9801      	ldr	r0, [sp, #4]
 8014802:	2130      	movs	r1, #48	; 0x30
 8014804:	461a      	mov	r2, r3
 8014806:	2301      	movs	r3, #1
 8014808:	f7fd fd8a 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 801480c:	4603      	mov	r3, r0
 801480e:	2b00      	cmp	r3, #0
 8014810:	d101      	bne.n	8014816 <LSM303AGR_ACC_W_Int1EnXLo+0x26>
    return MEMS_ERROR;
 8014812:	2300      	movs	r3, #0
 8014814:	e01c      	b.n	8014850 <LSM303AGR_ACC_W_Int1EnXLo+0x60>

  value &= ~LSM303AGR_ACC_XLIE_MASK;
 8014816:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801481a:	f023 0301 	bic.w	r3, r3, #1
 801481e:	b2db      	uxtb	r3, r3
 8014820:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014824:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014828:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801482c:	4313      	orrs	r3, r2
 801482e:	b2db      	uxtb	r3, r3
 8014830:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8014834:	f10d 030f 	add.w	r3, sp, #15
 8014838:	9801      	ldr	r0, [sp, #4]
 801483a:	2130      	movs	r1, #48	; 0x30
 801483c:	461a      	mov	r2, r3
 801483e:	2301      	movs	r3, #1
 8014840:	f7fd fd4e 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8014844:	4603      	mov	r3, r0
 8014846:	2b00      	cmp	r3, #0
 8014848:	d101      	bne.n	801484e <LSM303AGR_ACC_W_Int1EnXLo+0x5e>
    return MEMS_ERROR;
 801484a:	2300      	movs	r3, #0
 801484c:	e000      	b.n	8014850 <LSM303AGR_ACC_W_Int1EnXLo+0x60>

  return MEMS_SUCCESS;
 801484e:	2301      	movs	r3, #1
}
 8014850:	4618      	mov	r0, r3
 8014852:	b005      	add	sp, #20
 8014854:	f85d fb04 	ldr.w	pc, [sp], #4
 8014858:	f3af 8000 	nop.w
 801485c:	f3af 8000 	nop.w

08014860 <LSM303AGR_ACC_R_Int1EnXLo>:
* Input          : Pointer to LSM303AGR_ACC_XLIE_t
* Output         : Status of XLIE see LSM303AGR_ACC_XLIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1EnXLo(void *handle, LSM303AGR_ACC_XLIE_t *value)
{
 8014860:	b500      	push	{lr}
 8014862:	b083      	sub	sp, #12
 8014864:	9001      	str	r0, [sp, #4]
 8014866:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 8014868:	9801      	ldr	r0, [sp, #4]
 801486a:	2130      	movs	r1, #48	; 0x30
 801486c:	9a00      	ldr	r2, [sp, #0]
 801486e:	2301      	movs	r3, #1
 8014870:	f7fd fd56 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014874:	4603      	mov	r3, r0
 8014876:	2b00      	cmp	r3, #0
 8014878:	d101      	bne.n	801487e <LSM303AGR_ACC_R_Int1EnXLo+0x1e>
    return MEMS_ERROR;
 801487a:	2300      	movs	r3, #0
 801487c:	e007      	b.n	801488e <LSM303AGR_ACC_R_Int1EnXLo+0x2e>

  *value &= LSM303AGR_ACC_XLIE_MASK; //mask
 801487e:	9b00      	ldr	r3, [sp, #0]
 8014880:	781b      	ldrb	r3, [r3, #0]
 8014882:	f003 0301 	and.w	r3, r3, #1
 8014886:	b2da      	uxtb	r2, r3
 8014888:	9b00      	ldr	r3, [sp, #0]
 801488a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801488c:	2301      	movs	r3, #1
}
 801488e:	4618      	mov	r0, r3
 8014890:	b003      	add	sp, #12
 8014892:	f85d fb04 	ldr.w	pc, [sp], #4
 8014896:	bf00      	nop
 8014898:	f3af 8000 	nop.w
 801489c:	f3af 8000 	nop.w

080148a0 <LSM303AGR_ACC_W_Int1EnXHi>:
* Input          : LSM303AGR_ACC_XHIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1EnXHi(void *handle, LSM303AGR_ACC_XHIE_t newValue)
{
 80148a0:	b500      	push	{lr}
 80148a2:	b085      	sub	sp, #20
 80148a4:	9001      	str	r0, [sp, #4]
 80148a6:	460b      	mov	r3, r1
 80148a8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 80148ac:	f10d 030f 	add.w	r3, sp, #15
 80148b0:	9801      	ldr	r0, [sp, #4]
 80148b2:	2130      	movs	r1, #48	; 0x30
 80148b4:	461a      	mov	r2, r3
 80148b6:	2301      	movs	r3, #1
 80148b8:	f7fd fd32 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80148bc:	4603      	mov	r3, r0
 80148be:	2b00      	cmp	r3, #0
 80148c0:	d101      	bne.n	80148c6 <LSM303AGR_ACC_W_Int1EnXHi+0x26>
    return MEMS_ERROR;
 80148c2:	2300      	movs	r3, #0
 80148c4:	e01c      	b.n	8014900 <LSM303AGR_ACC_W_Int1EnXHi+0x60>

  value &= ~LSM303AGR_ACC_XHIE_MASK;
 80148c6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80148ca:	f023 0302 	bic.w	r3, r3, #2
 80148ce:	b2db      	uxtb	r3, r3
 80148d0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80148d4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80148d8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80148dc:	4313      	orrs	r3, r2
 80148de:	b2db      	uxtb	r3, r3
 80148e0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 80148e4:	f10d 030f 	add.w	r3, sp, #15
 80148e8:	9801      	ldr	r0, [sp, #4]
 80148ea:	2130      	movs	r1, #48	; 0x30
 80148ec:	461a      	mov	r2, r3
 80148ee:	2301      	movs	r3, #1
 80148f0:	f7fd fcf6 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 80148f4:	4603      	mov	r3, r0
 80148f6:	2b00      	cmp	r3, #0
 80148f8:	d101      	bne.n	80148fe <LSM303AGR_ACC_W_Int1EnXHi+0x5e>
    return MEMS_ERROR;
 80148fa:	2300      	movs	r3, #0
 80148fc:	e000      	b.n	8014900 <LSM303AGR_ACC_W_Int1EnXHi+0x60>

  return MEMS_SUCCESS;
 80148fe:	2301      	movs	r3, #1
}
 8014900:	4618      	mov	r0, r3
 8014902:	b005      	add	sp, #20
 8014904:	f85d fb04 	ldr.w	pc, [sp], #4
 8014908:	f3af 8000 	nop.w
 801490c:	f3af 8000 	nop.w

08014910 <LSM303AGR_ACC_R_Int1EnXHi>:
* Input          : Pointer to LSM303AGR_ACC_XHIE_t
* Output         : Status of XHIE see LSM303AGR_ACC_XHIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1EnXHi(void *handle, LSM303AGR_ACC_XHIE_t *value)
{
 8014910:	b500      	push	{lr}
 8014912:	b083      	sub	sp, #12
 8014914:	9001      	str	r0, [sp, #4]
 8014916:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 8014918:	9801      	ldr	r0, [sp, #4]
 801491a:	2130      	movs	r1, #48	; 0x30
 801491c:	9a00      	ldr	r2, [sp, #0]
 801491e:	2301      	movs	r3, #1
 8014920:	f7fd fcfe 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014924:	4603      	mov	r3, r0
 8014926:	2b00      	cmp	r3, #0
 8014928:	d101      	bne.n	801492e <LSM303AGR_ACC_R_Int1EnXHi+0x1e>
    return MEMS_ERROR;
 801492a:	2300      	movs	r3, #0
 801492c:	e007      	b.n	801493e <LSM303AGR_ACC_R_Int1EnXHi+0x2e>

  *value &= LSM303AGR_ACC_XHIE_MASK; //mask
 801492e:	9b00      	ldr	r3, [sp, #0]
 8014930:	781b      	ldrb	r3, [r3, #0]
 8014932:	f003 0302 	and.w	r3, r3, #2
 8014936:	b2da      	uxtb	r2, r3
 8014938:	9b00      	ldr	r3, [sp, #0]
 801493a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801493c:	2301      	movs	r3, #1
}
 801493e:	4618      	mov	r0, r3
 8014940:	b003      	add	sp, #12
 8014942:	f85d fb04 	ldr.w	pc, [sp], #4
 8014946:	bf00      	nop
 8014948:	f3af 8000 	nop.w
 801494c:	f3af 8000 	nop.w

08014950 <LSM303AGR_ACC_W_Int1EnYLo>:
* Input          : LSM303AGR_ACC_YLIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1EnYLo(void *handle, LSM303AGR_ACC_YLIE_t newValue)
{
 8014950:	b500      	push	{lr}
 8014952:	b085      	sub	sp, #20
 8014954:	9001      	str	r0, [sp, #4]
 8014956:	460b      	mov	r3, r1
 8014958:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 801495c:	f10d 030f 	add.w	r3, sp, #15
 8014960:	9801      	ldr	r0, [sp, #4]
 8014962:	2130      	movs	r1, #48	; 0x30
 8014964:	461a      	mov	r2, r3
 8014966:	2301      	movs	r3, #1
 8014968:	f7fd fcda 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 801496c:	4603      	mov	r3, r0
 801496e:	2b00      	cmp	r3, #0
 8014970:	d101      	bne.n	8014976 <LSM303AGR_ACC_W_Int1EnYLo+0x26>
    return MEMS_ERROR;
 8014972:	2300      	movs	r3, #0
 8014974:	e01c      	b.n	80149b0 <LSM303AGR_ACC_W_Int1EnYLo+0x60>

  value &= ~LSM303AGR_ACC_YLIE_MASK;
 8014976:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801497a:	f023 0304 	bic.w	r3, r3, #4
 801497e:	b2db      	uxtb	r3, r3
 8014980:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014984:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014988:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801498c:	4313      	orrs	r3, r2
 801498e:	b2db      	uxtb	r3, r3
 8014990:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8014994:	f10d 030f 	add.w	r3, sp, #15
 8014998:	9801      	ldr	r0, [sp, #4]
 801499a:	2130      	movs	r1, #48	; 0x30
 801499c:	461a      	mov	r2, r3
 801499e:	2301      	movs	r3, #1
 80149a0:	f7fd fc9e 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 80149a4:	4603      	mov	r3, r0
 80149a6:	2b00      	cmp	r3, #0
 80149a8:	d101      	bne.n	80149ae <LSM303AGR_ACC_W_Int1EnYLo+0x5e>
    return MEMS_ERROR;
 80149aa:	2300      	movs	r3, #0
 80149ac:	e000      	b.n	80149b0 <LSM303AGR_ACC_W_Int1EnYLo+0x60>

  return MEMS_SUCCESS;
 80149ae:	2301      	movs	r3, #1
}
 80149b0:	4618      	mov	r0, r3
 80149b2:	b005      	add	sp, #20
 80149b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80149b8:	f3af 8000 	nop.w
 80149bc:	f3af 8000 	nop.w

080149c0 <LSM303AGR_ACC_R_Int1EnYLo>:
* Input          : Pointer to LSM303AGR_ACC_YLIE_t
* Output         : Status of YLIE see LSM303AGR_ACC_YLIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1EnYLo(void *handle, LSM303AGR_ACC_YLIE_t *value)
{
 80149c0:	b500      	push	{lr}
 80149c2:	b083      	sub	sp, #12
 80149c4:	9001      	str	r0, [sp, #4]
 80149c6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 80149c8:	9801      	ldr	r0, [sp, #4]
 80149ca:	2130      	movs	r1, #48	; 0x30
 80149cc:	9a00      	ldr	r2, [sp, #0]
 80149ce:	2301      	movs	r3, #1
 80149d0:	f7fd fca6 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80149d4:	4603      	mov	r3, r0
 80149d6:	2b00      	cmp	r3, #0
 80149d8:	d101      	bne.n	80149de <LSM303AGR_ACC_R_Int1EnYLo+0x1e>
    return MEMS_ERROR;
 80149da:	2300      	movs	r3, #0
 80149dc:	e007      	b.n	80149ee <LSM303AGR_ACC_R_Int1EnYLo+0x2e>

  *value &= LSM303AGR_ACC_YLIE_MASK; //mask
 80149de:	9b00      	ldr	r3, [sp, #0]
 80149e0:	781b      	ldrb	r3, [r3, #0]
 80149e2:	f003 0304 	and.w	r3, r3, #4
 80149e6:	b2da      	uxtb	r2, r3
 80149e8:	9b00      	ldr	r3, [sp, #0]
 80149ea:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80149ec:	2301      	movs	r3, #1
}
 80149ee:	4618      	mov	r0, r3
 80149f0:	b003      	add	sp, #12
 80149f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80149f6:	bf00      	nop
 80149f8:	f3af 8000 	nop.w
 80149fc:	f3af 8000 	nop.w

08014a00 <LSM303AGR_ACC_W_Int1EnYHi>:
* Input          : LSM303AGR_ACC_YHIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1EnYHi(void *handle, LSM303AGR_ACC_YHIE_t newValue)
{
 8014a00:	b500      	push	{lr}
 8014a02:	b085      	sub	sp, #20
 8014a04:	9001      	str	r0, [sp, #4]
 8014a06:	460b      	mov	r3, r1
 8014a08:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8014a0c:	f10d 030f 	add.w	r3, sp, #15
 8014a10:	9801      	ldr	r0, [sp, #4]
 8014a12:	2130      	movs	r1, #48	; 0x30
 8014a14:	461a      	mov	r2, r3
 8014a16:	2301      	movs	r3, #1
 8014a18:	f7fd fc82 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014a1c:	4603      	mov	r3, r0
 8014a1e:	2b00      	cmp	r3, #0
 8014a20:	d101      	bne.n	8014a26 <LSM303AGR_ACC_W_Int1EnYHi+0x26>
    return MEMS_ERROR;
 8014a22:	2300      	movs	r3, #0
 8014a24:	e01c      	b.n	8014a60 <LSM303AGR_ACC_W_Int1EnYHi+0x60>

  value &= ~LSM303AGR_ACC_YHIE_MASK;
 8014a26:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014a2a:	f023 0308 	bic.w	r3, r3, #8
 8014a2e:	b2db      	uxtb	r3, r3
 8014a30:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014a34:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014a38:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014a3c:	4313      	orrs	r3, r2
 8014a3e:	b2db      	uxtb	r3, r3
 8014a40:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8014a44:	f10d 030f 	add.w	r3, sp, #15
 8014a48:	9801      	ldr	r0, [sp, #4]
 8014a4a:	2130      	movs	r1, #48	; 0x30
 8014a4c:	461a      	mov	r2, r3
 8014a4e:	2301      	movs	r3, #1
 8014a50:	f7fd fc46 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8014a54:	4603      	mov	r3, r0
 8014a56:	2b00      	cmp	r3, #0
 8014a58:	d101      	bne.n	8014a5e <LSM303AGR_ACC_W_Int1EnYHi+0x5e>
    return MEMS_ERROR;
 8014a5a:	2300      	movs	r3, #0
 8014a5c:	e000      	b.n	8014a60 <LSM303AGR_ACC_W_Int1EnYHi+0x60>

  return MEMS_SUCCESS;
 8014a5e:	2301      	movs	r3, #1
}
 8014a60:	4618      	mov	r0, r3
 8014a62:	b005      	add	sp, #20
 8014a64:	f85d fb04 	ldr.w	pc, [sp], #4
 8014a68:	f3af 8000 	nop.w
 8014a6c:	f3af 8000 	nop.w

08014a70 <LSM303AGR_ACC_R_Int1EnYHi>:
* Input          : Pointer to LSM303AGR_ACC_YHIE_t
* Output         : Status of YHIE see LSM303AGR_ACC_YHIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1EnYHi(void *handle, LSM303AGR_ACC_YHIE_t *value)
{
 8014a70:	b500      	push	{lr}
 8014a72:	b083      	sub	sp, #12
 8014a74:	9001      	str	r0, [sp, #4]
 8014a76:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 8014a78:	9801      	ldr	r0, [sp, #4]
 8014a7a:	2130      	movs	r1, #48	; 0x30
 8014a7c:	9a00      	ldr	r2, [sp, #0]
 8014a7e:	2301      	movs	r3, #1
 8014a80:	f7fd fc4e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014a84:	4603      	mov	r3, r0
 8014a86:	2b00      	cmp	r3, #0
 8014a88:	d101      	bne.n	8014a8e <LSM303AGR_ACC_R_Int1EnYHi+0x1e>
    return MEMS_ERROR;
 8014a8a:	2300      	movs	r3, #0
 8014a8c:	e007      	b.n	8014a9e <LSM303AGR_ACC_R_Int1EnYHi+0x2e>

  *value &= LSM303AGR_ACC_YHIE_MASK; //mask
 8014a8e:	9b00      	ldr	r3, [sp, #0]
 8014a90:	781b      	ldrb	r3, [r3, #0]
 8014a92:	f003 0308 	and.w	r3, r3, #8
 8014a96:	b2da      	uxtb	r2, r3
 8014a98:	9b00      	ldr	r3, [sp, #0]
 8014a9a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014a9c:	2301      	movs	r3, #1
}
 8014a9e:	4618      	mov	r0, r3
 8014aa0:	b003      	add	sp, #12
 8014aa2:	f85d fb04 	ldr.w	pc, [sp], #4
 8014aa6:	bf00      	nop
 8014aa8:	f3af 8000 	nop.w
 8014aac:	f3af 8000 	nop.w

08014ab0 <LSM303AGR_ACC_W_Int1EnZLo>:
* Input          : LSM303AGR_ACC_ZLIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1EnZLo(void *handle, LSM303AGR_ACC_ZLIE_t newValue)
{
 8014ab0:	b500      	push	{lr}
 8014ab2:	b085      	sub	sp, #20
 8014ab4:	9001      	str	r0, [sp, #4]
 8014ab6:	460b      	mov	r3, r1
 8014ab8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8014abc:	f10d 030f 	add.w	r3, sp, #15
 8014ac0:	9801      	ldr	r0, [sp, #4]
 8014ac2:	2130      	movs	r1, #48	; 0x30
 8014ac4:	461a      	mov	r2, r3
 8014ac6:	2301      	movs	r3, #1
 8014ac8:	f7fd fc2a 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014acc:	4603      	mov	r3, r0
 8014ace:	2b00      	cmp	r3, #0
 8014ad0:	d101      	bne.n	8014ad6 <LSM303AGR_ACC_W_Int1EnZLo+0x26>
    return MEMS_ERROR;
 8014ad2:	2300      	movs	r3, #0
 8014ad4:	e01c      	b.n	8014b10 <LSM303AGR_ACC_W_Int1EnZLo+0x60>

  value &= ~LSM303AGR_ACC_ZLIE_MASK;
 8014ad6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014ada:	f023 0310 	bic.w	r3, r3, #16
 8014ade:	b2db      	uxtb	r3, r3
 8014ae0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014ae4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014ae8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014aec:	4313      	orrs	r3, r2
 8014aee:	b2db      	uxtb	r3, r3
 8014af0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8014af4:	f10d 030f 	add.w	r3, sp, #15
 8014af8:	9801      	ldr	r0, [sp, #4]
 8014afa:	2130      	movs	r1, #48	; 0x30
 8014afc:	461a      	mov	r2, r3
 8014afe:	2301      	movs	r3, #1
 8014b00:	f7fd fbee 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8014b04:	4603      	mov	r3, r0
 8014b06:	2b00      	cmp	r3, #0
 8014b08:	d101      	bne.n	8014b0e <LSM303AGR_ACC_W_Int1EnZLo+0x5e>
    return MEMS_ERROR;
 8014b0a:	2300      	movs	r3, #0
 8014b0c:	e000      	b.n	8014b10 <LSM303AGR_ACC_W_Int1EnZLo+0x60>

  return MEMS_SUCCESS;
 8014b0e:	2301      	movs	r3, #1
}
 8014b10:	4618      	mov	r0, r3
 8014b12:	b005      	add	sp, #20
 8014b14:	f85d fb04 	ldr.w	pc, [sp], #4
 8014b18:	f3af 8000 	nop.w
 8014b1c:	f3af 8000 	nop.w

08014b20 <LSM303AGR_ACC_R_Int1EnZLo>:
* Input          : Pointer to LSM303AGR_ACC_ZLIE_t
* Output         : Status of ZLIE see LSM303AGR_ACC_ZLIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1EnZLo(void *handle, LSM303AGR_ACC_ZLIE_t *value)
{
 8014b20:	b500      	push	{lr}
 8014b22:	b083      	sub	sp, #12
 8014b24:	9001      	str	r0, [sp, #4]
 8014b26:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 8014b28:	9801      	ldr	r0, [sp, #4]
 8014b2a:	2130      	movs	r1, #48	; 0x30
 8014b2c:	9a00      	ldr	r2, [sp, #0]
 8014b2e:	2301      	movs	r3, #1
 8014b30:	f7fd fbf6 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014b34:	4603      	mov	r3, r0
 8014b36:	2b00      	cmp	r3, #0
 8014b38:	d101      	bne.n	8014b3e <LSM303AGR_ACC_R_Int1EnZLo+0x1e>
    return MEMS_ERROR;
 8014b3a:	2300      	movs	r3, #0
 8014b3c:	e007      	b.n	8014b4e <LSM303AGR_ACC_R_Int1EnZLo+0x2e>

  *value &= LSM303AGR_ACC_ZLIE_MASK; //mask
 8014b3e:	9b00      	ldr	r3, [sp, #0]
 8014b40:	781b      	ldrb	r3, [r3, #0]
 8014b42:	f003 0310 	and.w	r3, r3, #16
 8014b46:	b2da      	uxtb	r2, r3
 8014b48:	9b00      	ldr	r3, [sp, #0]
 8014b4a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014b4c:	2301      	movs	r3, #1
}
 8014b4e:	4618      	mov	r0, r3
 8014b50:	b003      	add	sp, #12
 8014b52:	f85d fb04 	ldr.w	pc, [sp], #4
 8014b56:	bf00      	nop
 8014b58:	f3af 8000 	nop.w
 8014b5c:	f3af 8000 	nop.w

08014b60 <LSM303AGR_ACC_W_Int1EnZHi>:
* Input          : LSM303AGR_ACC_ZHIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1EnZHi(void *handle, LSM303AGR_ACC_ZHIE_t newValue)
{
 8014b60:	b500      	push	{lr}
 8014b62:	b085      	sub	sp, #20
 8014b64:	9001      	str	r0, [sp, #4]
 8014b66:	460b      	mov	r3, r1
 8014b68:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8014b6c:	f10d 030f 	add.w	r3, sp, #15
 8014b70:	9801      	ldr	r0, [sp, #4]
 8014b72:	2130      	movs	r1, #48	; 0x30
 8014b74:	461a      	mov	r2, r3
 8014b76:	2301      	movs	r3, #1
 8014b78:	f7fd fbd2 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014b7c:	4603      	mov	r3, r0
 8014b7e:	2b00      	cmp	r3, #0
 8014b80:	d101      	bne.n	8014b86 <LSM303AGR_ACC_W_Int1EnZHi+0x26>
    return MEMS_ERROR;
 8014b82:	2300      	movs	r3, #0
 8014b84:	e01c      	b.n	8014bc0 <LSM303AGR_ACC_W_Int1EnZHi+0x60>

  value &= ~LSM303AGR_ACC_ZHIE_MASK;
 8014b86:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014b8a:	f023 0320 	bic.w	r3, r3, #32
 8014b8e:	b2db      	uxtb	r3, r3
 8014b90:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014b94:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014b98:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014b9c:	4313      	orrs	r3, r2
 8014b9e:	b2db      	uxtb	r3, r3
 8014ba0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8014ba4:	f10d 030f 	add.w	r3, sp, #15
 8014ba8:	9801      	ldr	r0, [sp, #4]
 8014baa:	2130      	movs	r1, #48	; 0x30
 8014bac:	461a      	mov	r2, r3
 8014bae:	2301      	movs	r3, #1
 8014bb0:	f7fd fb96 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8014bb4:	4603      	mov	r3, r0
 8014bb6:	2b00      	cmp	r3, #0
 8014bb8:	d101      	bne.n	8014bbe <LSM303AGR_ACC_W_Int1EnZHi+0x5e>
    return MEMS_ERROR;
 8014bba:	2300      	movs	r3, #0
 8014bbc:	e000      	b.n	8014bc0 <LSM303AGR_ACC_W_Int1EnZHi+0x60>

  return MEMS_SUCCESS;
 8014bbe:	2301      	movs	r3, #1
}
 8014bc0:	4618      	mov	r0, r3
 8014bc2:	b005      	add	sp, #20
 8014bc4:	f85d fb04 	ldr.w	pc, [sp], #4
 8014bc8:	f3af 8000 	nop.w
 8014bcc:	f3af 8000 	nop.w

08014bd0 <LSM303AGR_ACC_R_Int1EnZHi>:
* Input          : Pointer to LSM303AGR_ACC_ZHIE_t
* Output         : Status of ZHIE see LSM303AGR_ACC_ZHIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1EnZHi(void *handle, LSM303AGR_ACC_ZHIE_t *value)
{
 8014bd0:	b500      	push	{lr}
 8014bd2:	b083      	sub	sp, #12
 8014bd4:	9001      	str	r0, [sp, #4]
 8014bd6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 8014bd8:	9801      	ldr	r0, [sp, #4]
 8014bda:	2130      	movs	r1, #48	; 0x30
 8014bdc:	9a00      	ldr	r2, [sp, #0]
 8014bde:	2301      	movs	r3, #1
 8014be0:	f7fd fb9e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014be4:	4603      	mov	r3, r0
 8014be6:	2b00      	cmp	r3, #0
 8014be8:	d101      	bne.n	8014bee <LSM303AGR_ACC_R_Int1EnZHi+0x1e>
    return MEMS_ERROR;
 8014bea:	2300      	movs	r3, #0
 8014bec:	e007      	b.n	8014bfe <LSM303AGR_ACC_R_Int1EnZHi+0x2e>

  *value &= LSM303AGR_ACC_ZHIE_MASK; //mask
 8014bee:	9b00      	ldr	r3, [sp, #0]
 8014bf0:	781b      	ldrb	r3, [r3, #0]
 8014bf2:	f003 0320 	and.w	r3, r3, #32
 8014bf6:	b2da      	uxtb	r2, r3
 8014bf8:	9b00      	ldr	r3, [sp, #0]
 8014bfa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014bfc:	2301      	movs	r3, #1
}
 8014bfe:	4618      	mov	r0, r3
 8014c00:	b003      	add	sp, #12
 8014c02:	f85d fb04 	ldr.w	pc, [sp], #4
 8014c06:	bf00      	nop
 8014c08:	f3af 8000 	nop.w
 8014c0c:	f3af 8000 	nop.w

08014c10 <LSM303AGR_ACC_W_Int1_6D>:
* Input          : LSM303AGR_ACC_6D_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1_6D(void *handle, LSM303AGR_ACC_6D_t newValue)
{
 8014c10:	b500      	push	{lr}
 8014c12:	b085      	sub	sp, #20
 8014c14:	9001      	str	r0, [sp, #4]
 8014c16:	460b      	mov	r3, r1
 8014c18:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8014c1c:	f10d 030f 	add.w	r3, sp, #15
 8014c20:	9801      	ldr	r0, [sp, #4]
 8014c22:	2130      	movs	r1, #48	; 0x30
 8014c24:	461a      	mov	r2, r3
 8014c26:	2301      	movs	r3, #1
 8014c28:	f7fd fb7a 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014c2c:	4603      	mov	r3, r0
 8014c2e:	2b00      	cmp	r3, #0
 8014c30:	d101      	bne.n	8014c36 <LSM303AGR_ACC_W_Int1_6D+0x26>
    return MEMS_ERROR;
 8014c32:	2300      	movs	r3, #0
 8014c34:	e01c      	b.n	8014c70 <LSM303AGR_ACC_W_Int1_6D+0x60>

  value &= ~LSM303AGR_ACC_6D_MASK;
 8014c36:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014c3a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8014c3e:	b2db      	uxtb	r3, r3
 8014c40:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014c44:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014c48:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014c4c:	4313      	orrs	r3, r2
 8014c4e:	b2db      	uxtb	r3, r3
 8014c50:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8014c54:	f10d 030f 	add.w	r3, sp, #15
 8014c58:	9801      	ldr	r0, [sp, #4]
 8014c5a:	2130      	movs	r1, #48	; 0x30
 8014c5c:	461a      	mov	r2, r3
 8014c5e:	2301      	movs	r3, #1
 8014c60:	f7fd fb3e 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8014c64:	4603      	mov	r3, r0
 8014c66:	2b00      	cmp	r3, #0
 8014c68:	d101      	bne.n	8014c6e <LSM303AGR_ACC_W_Int1_6D+0x5e>
    return MEMS_ERROR;
 8014c6a:	2300      	movs	r3, #0
 8014c6c:	e000      	b.n	8014c70 <LSM303AGR_ACC_W_Int1_6D+0x60>

  return MEMS_SUCCESS;
 8014c6e:	2301      	movs	r3, #1
}
 8014c70:	4618      	mov	r0, r3
 8014c72:	b005      	add	sp, #20
 8014c74:	f85d fb04 	ldr.w	pc, [sp], #4
 8014c78:	f3af 8000 	nop.w
 8014c7c:	f3af 8000 	nop.w

08014c80 <LSM303AGR_ACC_R_Int1_6D>:
* Input          : Pointer to LSM303AGR_ACC_6D_t
* Output         : Status of 6D see LSM303AGR_ACC_6D_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_6D(void *handle, LSM303AGR_ACC_6D_t *value)
{
 8014c80:	b500      	push	{lr}
 8014c82:	b083      	sub	sp, #12
 8014c84:	9001      	str	r0, [sp, #4]
 8014c86:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 8014c88:	9801      	ldr	r0, [sp, #4]
 8014c8a:	2130      	movs	r1, #48	; 0x30
 8014c8c:	9a00      	ldr	r2, [sp, #0]
 8014c8e:	2301      	movs	r3, #1
 8014c90:	f7fd fb46 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014c94:	4603      	mov	r3, r0
 8014c96:	2b00      	cmp	r3, #0
 8014c98:	d101      	bne.n	8014c9e <LSM303AGR_ACC_R_Int1_6D+0x1e>
    return MEMS_ERROR;
 8014c9a:	2300      	movs	r3, #0
 8014c9c:	e007      	b.n	8014cae <LSM303AGR_ACC_R_Int1_6D+0x2e>

  *value &= LSM303AGR_ACC_6D_MASK; //mask
 8014c9e:	9b00      	ldr	r3, [sp, #0]
 8014ca0:	781b      	ldrb	r3, [r3, #0]
 8014ca2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8014ca6:	b2da      	uxtb	r2, r3
 8014ca8:	9b00      	ldr	r3, [sp, #0]
 8014caa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014cac:	2301      	movs	r3, #1
}
 8014cae:	4618      	mov	r0, r3
 8014cb0:	b003      	add	sp, #12
 8014cb2:	f85d fb04 	ldr.w	pc, [sp], #4
 8014cb6:	bf00      	nop
 8014cb8:	f3af 8000 	nop.w
 8014cbc:	f3af 8000 	nop.w

08014cc0 <LSM303AGR_ACC_W_Int1_AOI>:
* Input          : LSM303AGR_ACC_AOI_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1_AOI(void *handle, LSM303AGR_ACC_AOI_t newValue)
{
 8014cc0:	b500      	push	{lr}
 8014cc2:	b085      	sub	sp, #20
 8014cc4:	9001      	str	r0, [sp, #4]
 8014cc6:	460b      	mov	r3, r1
 8014cc8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8014ccc:	f10d 030f 	add.w	r3, sp, #15
 8014cd0:	9801      	ldr	r0, [sp, #4]
 8014cd2:	2130      	movs	r1, #48	; 0x30
 8014cd4:	461a      	mov	r2, r3
 8014cd6:	2301      	movs	r3, #1
 8014cd8:	f7fd fb22 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014cdc:	4603      	mov	r3, r0
 8014cde:	2b00      	cmp	r3, #0
 8014ce0:	d101      	bne.n	8014ce6 <LSM303AGR_ACC_W_Int1_AOI+0x26>
    return MEMS_ERROR;
 8014ce2:	2300      	movs	r3, #0
 8014ce4:	e01c      	b.n	8014d20 <LSM303AGR_ACC_W_Int1_AOI+0x60>

  value &= ~LSM303AGR_ACC_AOI_MASK;
 8014ce6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014cea:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8014cee:	b2db      	uxtb	r3, r3
 8014cf0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014cf4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014cf8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014cfc:	4313      	orrs	r3, r2
 8014cfe:	b2db      	uxtb	r3, r3
 8014d00:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8014d04:	f10d 030f 	add.w	r3, sp, #15
 8014d08:	9801      	ldr	r0, [sp, #4]
 8014d0a:	2130      	movs	r1, #48	; 0x30
 8014d0c:	461a      	mov	r2, r3
 8014d0e:	2301      	movs	r3, #1
 8014d10:	f7fd fae6 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8014d14:	4603      	mov	r3, r0
 8014d16:	2b00      	cmp	r3, #0
 8014d18:	d101      	bne.n	8014d1e <LSM303AGR_ACC_W_Int1_AOI+0x5e>
    return MEMS_ERROR;
 8014d1a:	2300      	movs	r3, #0
 8014d1c:	e000      	b.n	8014d20 <LSM303AGR_ACC_W_Int1_AOI+0x60>

  return MEMS_SUCCESS;
 8014d1e:	2301      	movs	r3, #1
}
 8014d20:	4618      	mov	r0, r3
 8014d22:	b005      	add	sp, #20
 8014d24:	f85d fb04 	ldr.w	pc, [sp], #4
 8014d28:	f3af 8000 	nop.w
 8014d2c:	f3af 8000 	nop.w

08014d30 <LSM303AGR_ACC_R_Int1_AOI>:
* Input          : Pointer to LSM303AGR_ACC_AOI_t
* Output         : Status of AOI see LSM303AGR_ACC_AOI_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_AOI(void *handle, LSM303AGR_ACC_AOI_t *value)
{
 8014d30:	b500      	push	{lr}
 8014d32:	b083      	sub	sp, #12
 8014d34:	9001      	str	r0, [sp, #4]
 8014d36:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 8014d38:	9801      	ldr	r0, [sp, #4]
 8014d3a:	2130      	movs	r1, #48	; 0x30
 8014d3c:	9a00      	ldr	r2, [sp, #0]
 8014d3e:	2301      	movs	r3, #1
 8014d40:	f7fd faee 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014d44:	4603      	mov	r3, r0
 8014d46:	2b00      	cmp	r3, #0
 8014d48:	d101      	bne.n	8014d4e <LSM303AGR_ACC_R_Int1_AOI+0x1e>
    return MEMS_ERROR;
 8014d4a:	2300      	movs	r3, #0
 8014d4c:	e007      	b.n	8014d5e <LSM303AGR_ACC_R_Int1_AOI+0x2e>

  *value &= LSM303AGR_ACC_AOI_MASK; //mask
 8014d4e:	9b00      	ldr	r3, [sp, #0]
 8014d50:	781b      	ldrb	r3, [r3, #0]
 8014d52:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8014d56:	b2da      	uxtb	r2, r3
 8014d58:	9b00      	ldr	r3, [sp, #0]
 8014d5a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014d5c:	2301      	movs	r3, #1
}
 8014d5e:	4618      	mov	r0, r3
 8014d60:	b003      	add	sp, #12
 8014d62:	f85d fb04 	ldr.w	pc, [sp], #4
 8014d66:	bf00      	nop
 8014d68:	f3af 8000 	nop.w
 8014d6c:	f3af 8000 	nop.w

08014d70 <LSM303AGR_ACC_W_Int2EnXLo>:
* Input          : LSM303AGR_ACC_XLIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2EnXLo(void *handle, LSM303AGR_ACC_XLIE_t newValue)
{
 8014d70:	b500      	push	{lr}
 8014d72:	b085      	sub	sp, #20
 8014d74:	9001      	str	r0, [sp, #4]
 8014d76:	460b      	mov	r3, r1
 8014d78:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8014d7c:	f10d 030f 	add.w	r3, sp, #15
 8014d80:	9801      	ldr	r0, [sp, #4]
 8014d82:	2134      	movs	r1, #52	; 0x34
 8014d84:	461a      	mov	r2, r3
 8014d86:	2301      	movs	r3, #1
 8014d88:	f7fd faca 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014d8c:	4603      	mov	r3, r0
 8014d8e:	2b00      	cmp	r3, #0
 8014d90:	d101      	bne.n	8014d96 <LSM303AGR_ACC_W_Int2EnXLo+0x26>
    return MEMS_ERROR;
 8014d92:	2300      	movs	r3, #0
 8014d94:	e01c      	b.n	8014dd0 <LSM303AGR_ACC_W_Int2EnXLo+0x60>

  value &= ~LSM303AGR_ACC_XLIE_MASK;
 8014d96:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014d9a:	f023 0301 	bic.w	r3, r3, #1
 8014d9e:	b2db      	uxtb	r3, r3
 8014da0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014da4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014da8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014dac:	4313      	orrs	r3, r2
 8014dae:	b2db      	uxtb	r3, r3
 8014db0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8014db4:	f10d 030f 	add.w	r3, sp, #15
 8014db8:	9801      	ldr	r0, [sp, #4]
 8014dba:	2134      	movs	r1, #52	; 0x34
 8014dbc:	461a      	mov	r2, r3
 8014dbe:	2301      	movs	r3, #1
 8014dc0:	f7fd fa8e 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8014dc4:	4603      	mov	r3, r0
 8014dc6:	2b00      	cmp	r3, #0
 8014dc8:	d101      	bne.n	8014dce <LSM303AGR_ACC_W_Int2EnXLo+0x5e>
    return MEMS_ERROR;
 8014dca:	2300      	movs	r3, #0
 8014dcc:	e000      	b.n	8014dd0 <LSM303AGR_ACC_W_Int2EnXLo+0x60>

  return MEMS_SUCCESS;
 8014dce:	2301      	movs	r3, #1
}
 8014dd0:	4618      	mov	r0, r3
 8014dd2:	b005      	add	sp, #20
 8014dd4:	f85d fb04 	ldr.w	pc, [sp], #4
 8014dd8:	f3af 8000 	nop.w
 8014ddc:	f3af 8000 	nop.w

08014de0 <LSM303AGR_ACC_R_Int2EnXLo>:
* Input          : Pointer to LSM303AGR_ACC_XLIE_t
* Output         : Status of XLIE see LSM303AGR_ACC_XLIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2EnXLo(void *handle, LSM303AGR_ACC_XLIE_t *value)
{
 8014de0:	b500      	push	{lr}
 8014de2:	b083      	sub	sp, #12
 8014de4:	9001      	str	r0, [sp, #4]
 8014de6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8014de8:	9801      	ldr	r0, [sp, #4]
 8014dea:	2134      	movs	r1, #52	; 0x34
 8014dec:	9a00      	ldr	r2, [sp, #0]
 8014dee:	2301      	movs	r3, #1
 8014df0:	f7fd fa96 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014df4:	4603      	mov	r3, r0
 8014df6:	2b00      	cmp	r3, #0
 8014df8:	d101      	bne.n	8014dfe <LSM303AGR_ACC_R_Int2EnXLo+0x1e>
    return MEMS_ERROR;
 8014dfa:	2300      	movs	r3, #0
 8014dfc:	e007      	b.n	8014e0e <LSM303AGR_ACC_R_Int2EnXLo+0x2e>

  *value &= LSM303AGR_ACC_XLIE_MASK; //mask
 8014dfe:	9b00      	ldr	r3, [sp, #0]
 8014e00:	781b      	ldrb	r3, [r3, #0]
 8014e02:	f003 0301 	and.w	r3, r3, #1
 8014e06:	b2da      	uxtb	r2, r3
 8014e08:	9b00      	ldr	r3, [sp, #0]
 8014e0a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014e0c:	2301      	movs	r3, #1
}
 8014e0e:	4618      	mov	r0, r3
 8014e10:	b003      	add	sp, #12
 8014e12:	f85d fb04 	ldr.w	pc, [sp], #4
 8014e16:	bf00      	nop
 8014e18:	f3af 8000 	nop.w
 8014e1c:	f3af 8000 	nop.w

08014e20 <LSM303AGR_ACC_W_Int2EnXHi>:
* Input          : LSM303AGR_ACC_XHIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2EnXHi(void *handle, LSM303AGR_ACC_XHIE_t newValue)
{
 8014e20:	b500      	push	{lr}
 8014e22:	b085      	sub	sp, #20
 8014e24:	9001      	str	r0, [sp, #4]
 8014e26:	460b      	mov	r3, r1
 8014e28:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8014e2c:	f10d 030f 	add.w	r3, sp, #15
 8014e30:	9801      	ldr	r0, [sp, #4]
 8014e32:	2134      	movs	r1, #52	; 0x34
 8014e34:	461a      	mov	r2, r3
 8014e36:	2301      	movs	r3, #1
 8014e38:	f7fd fa72 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014e3c:	4603      	mov	r3, r0
 8014e3e:	2b00      	cmp	r3, #0
 8014e40:	d101      	bne.n	8014e46 <LSM303AGR_ACC_W_Int2EnXHi+0x26>
    return MEMS_ERROR;
 8014e42:	2300      	movs	r3, #0
 8014e44:	e01c      	b.n	8014e80 <LSM303AGR_ACC_W_Int2EnXHi+0x60>

  value &= ~LSM303AGR_ACC_XHIE_MASK;
 8014e46:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014e4a:	f023 0302 	bic.w	r3, r3, #2
 8014e4e:	b2db      	uxtb	r3, r3
 8014e50:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014e54:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014e58:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014e5c:	4313      	orrs	r3, r2
 8014e5e:	b2db      	uxtb	r3, r3
 8014e60:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8014e64:	f10d 030f 	add.w	r3, sp, #15
 8014e68:	9801      	ldr	r0, [sp, #4]
 8014e6a:	2134      	movs	r1, #52	; 0x34
 8014e6c:	461a      	mov	r2, r3
 8014e6e:	2301      	movs	r3, #1
 8014e70:	f7fd fa36 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8014e74:	4603      	mov	r3, r0
 8014e76:	2b00      	cmp	r3, #0
 8014e78:	d101      	bne.n	8014e7e <LSM303AGR_ACC_W_Int2EnXHi+0x5e>
    return MEMS_ERROR;
 8014e7a:	2300      	movs	r3, #0
 8014e7c:	e000      	b.n	8014e80 <LSM303AGR_ACC_W_Int2EnXHi+0x60>

  return MEMS_SUCCESS;
 8014e7e:	2301      	movs	r3, #1
}
 8014e80:	4618      	mov	r0, r3
 8014e82:	b005      	add	sp, #20
 8014e84:	f85d fb04 	ldr.w	pc, [sp], #4
 8014e88:	f3af 8000 	nop.w
 8014e8c:	f3af 8000 	nop.w

08014e90 <LSM303AGR_ACC_R_Int2EnXHi>:
* Input          : Pointer to LSM303AGR_ACC_XHIE_t
* Output         : Status of XHIE see LSM303AGR_ACC_XHIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2EnXHi(void *handle, LSM303AGR_ACC_XHIE_t *value)
{
 8014e90:	b500      	push	{lr}
 8014e92:	b083      	sub	sp, #12
 8014e94:	9001      	str	r0, [sp, #4]
 8014e96:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8014e98:	9801      	ldr	r0, [sp, #4]
 8014e9a:	2134      	movs	r1, #52	; 0x34
 8014e9c:	9a00      	ldr	r2, [sp, #0]
 8014e9e:	2301      	movs	r3, #1
 8014ea0:	f7fd fa3e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014ea4:	4603      	mov	r3, r0
 8014ea6:	2b00      	cmp	r3, #0
 8014ea8:	d101      	bne.n	8014eae <LSM303AGR_ACC_R_Int2EnXHi+0x1e>
    return MEMS_ERROR;
 8014eaa:	2300      	movs	r3, #0
 8014eac:	e007      	b.n	8014ebe <LSM303AGR_ACC_R_Int2EnXHi+0x2e>

  *value &= LSM303AGR_ACC_XHIE_MASK; //mask
 8014eae:	9b00      	ldr	r3, [sp, #0]
 8014eb0:	781b      	ldrb	r3, [r3, #0]
 8014eb2:	f003 0302 	and.w	r3, r3, #2
 8014eb6:	b2da      	uxtb	r2, r3
 8014eb8:	9b00      	ldr	r3, [sp, #0]
 8014eba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014ebc:	2301      	movs	r3, #1
}
 8014ebe:	4618      	mov	r0, r3
 8014ec0:	b003      	add	sp, #12
 8014ec2:	f85d fb04 	ldr.w	pc, [sp], #4
 8014ec6:	bf00      	nop
 8014ec8:	f3af 8000 	nop.w
 8014ecc:	f3af 8000 	nop.w

08014ed0 <LSM303AGR_ACC_W_Int2EnYLo>:
* Input          : LSM303AGR_ACC_YLIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2EnYLo(void *handle, LSM303AGR_ACC_YLIE_t newValue)
{
 8014ed0:	b500      	push	{lr}
 8014ed2:	b085      	sub	sp, #20
 8014ed4:	9001      	str	r0, [sp, #4]
 8014ed6:	460b      	mov	r3, r1
 8014ed8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8014edc:	f10d 030f 	add.w	r3, sp, #15
 8014ee0:	9801      	ldr	r0, [sp, #4]
 8014ee2:	2134      	movs	r1, #52	; 0x34
 8014ee4:	461a      	mov	r2, r3
 8014ee6:	2301      	movs	r3, #1
 8014ee8:	f7fd fa1a 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014eec:	4603      	mov	r3, r0
 8014eee:	2b00      	cmp	r3, #0
 8014ef0:	d101      	bne.n	8014ef6 <LSM303AGR_ACC_W_Int2EnYLo+0x26>
    return MEMS_ERROR;
 8014ef2:	2300      	movs	r3, #0
 8014ef4:	e01c      	b.n	8014f30 <LSM303AGR_ACC_W_Int2EnYLo+0x60>

  value &= ~LSM303AGR_ACC_YLIE_MASK;
 8014ef6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014efa:	f023 0304 	bic.w	r3, r3, #4
 8014efe:	b2db      	uxtb	r3, r3
 8014f00:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014f04:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014f08:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014f0c:	4313      	orrs	r3, r2
 8014f0e:	b2db      	uxtb	r3, r3
 8014f10:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8014f14:	f10d 030f 	add.w	r3, sp, #15
 8014f18:	9801      	ldr	r0, [sp, #4]
 8014f1a:	2134      	movs	r1, #52	; 0x34
 8014f1c:	461a      	mov	r2, r3
 8014f1e:	2301      	movs	r3, #1
 8014f20:	f7fd f9de 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8014f24:	4603      	mov	r3, r0
 8014f26:	2b00      	cmp	r3, #0
 8014f28:	d101      	bne.n	8014f2e <LSM303AGR_ACC_W_Int2EnYLo+0x5e>
    return MEMS_ERROR;
 8014f2a:	2300      	movs	r3, #0
 8014f2c:	e000      	b.n	8014f30 <LSM303AGR_ACC_W_Int2EnYLo+0x60>

  return MEMS_SUCCESS;
 8014f2e:	2301      	movs	r3, #1
}
 8014f30:	4618      	mov	r0, r3
 8014f32:	b005      	add	sp, #20
 8014f34:	f85d fb04 	ldr.w	pc, [sp], #4
 8014f38:	f3af 8000 	nop.w
 8014f3c:	f3af 8000 	nop.w

08014f40 <LSM303AGR_ACC_R_Int2EnYLo>:
* Input          : Pointer to LSM303AGR_ACC_YLIE_t
* Output         : Status of YLIE see LSM303AGR_ACC_YLIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2EnYLo(void *handle, LSM303AGR_ACC_YLIE_t *value)
{
 8014f40:	b500      	push	{lr}
 8014f42:	b083      	sub	sp, #12
 8014f44:	9001      	str	r0, [sp, #4]
 8014f46:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8014f48:	9801      	ldr	r0, [sp, #4]
 8014f4a:	2134      	movs	r1, #52	; 0x34
 8014f4c:	9a00      	ldr	r2, [sp, #0]
 8014f4e:	2301      	movs	r3, #1
 8014f50:	f7fd f9e6 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014f54:	4603      	mov	r3, r0
 8014f56:	2b00      	cmp	r3, #0
 8014f58:	d101      	bne.n	8014f5e <LSM303AGR_ACC_R_Int2EnYLo+0x1e>
    return MEMS_ERROR;
 8014f5a:	2300      	movs	r3, #0
 8014f5c:	e007      	b.n	8014f6e <LSM303AGR_ACC_R_Int2EnYLo+0x2e>

  *value &= LSM303AGR_ACC_YLIE_MASK; //mask
 8014f5e:	9b00      	ldr	r3, [sp, #0]
 8014f60:	781b      	ldrb	r3, [r3, #0]
 8014f62:	f003 0304 	and.w	r3, r3, #4
 8014f66:	b2da      	uxtb	r2, r3
 8014f68:	9b00      	ldr	r3, [sp, #0]
 8014f6a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014f6c:	2301      	movs	r3, #1
}
 8014f6e:	4618      	mov	r0, r3
 8014f70:	b003      	add	sp, #12
 8014f72:	f85d fb04 	ldr.w	pc, [sp], #4
 8014f76:	bf00      	nop
 8014f78:	f3af 8000 	nop.w
 8014f7c:	f3af 8000 	nop.w

08014f80 <LSM303AGR_ACC_W_Int2EnYHi>:
* Input          : LSM303AGR_ACC_YHIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2EnYHi(void *handle, LSM303AGR_ACC_YHIE_t newValue)
{
 8014f80:	b500      	push	{lr}
 8014f82:	b085      	sub	sp, #20
 8014f84:	9001      	str	r0, [sp, #4]
 8014f86:	460b      	mov	r3, r1
 8014f88:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8014f8c:	f10d 030f 	add.w	r3, sp, #15
 8014f90:	9801      	ldr	r0, [sp, #4]
 8014f92:	2134      	movs	r1, #52	; 0x34
 8014f94:	461a      	mov	r2, r3
 8014f96:	2301      	movs	r3, #1
 8014f98:	f7fd f9c2 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8014f9c:	4603      	mov	r3, r0
 8014f9e:	2b00      	cmp	r3, #0
 8014fa0:	d101      	bne.n	8014fa6 <LSM303AGR_ACC_W_Int2EnYHi+0x26>
    return MEMS_ERROR;
 8014fa2:	2300      	movs	r3, #0
 8014fa4:	e01c      	b.n	8014fe0 <LSM303AGR_ACC_W_Int2EnYHi+0x60>

  value &= ~LSM303AGR_ACC_YHIE_MASK;
 8014fa6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014faa:	f023 0308 	bic.w	r3, r3, #8
 8014fae:	b2db      	uxtb	r3, r3
 8014fb0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014fb4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014fb8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014fbc:	4313      	orrs	r3, r2
 8014fbe:	b2db      	uxtb	r3, r3
 8014fc0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8014fc4:	f10d 030f 	add.w	r3, sp, #15
 8014fc8:	9801      	ldr	r0, [sp, #4]
 8014fca:	2134      	movs	r1, #52	; 0x34
 8014fcc:	461a      	mov	r2, r3
 8014fce:	2301      	movs	r3, #1
 8014fd0:	f7fd f986 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8014fd4:	4603      	mov	r3, r0
 8014fd6:	2b00      	cmp	r3, #0
 8014fd8:	d101      	bne.n	8014fde <LSM303AGR_ACC_W_Int2EnYHi+0x5e>
    return MEMS_ERROR;
 8014fda:	2300      	movs	r3, #0
 8014fdc:	e000      	b.n	8014fe0 <LSM303AGR_ACC_W_Int2EnYHi+0x60>

  return MEMS_SUCCESS;
 8014fde:	2301      	movs	r3, #1
}
 8014fe0:	4618      	mov	r0, r3
 8014fe2:	b005      	add	sp, #20
 8014fe4:	f85d fb04 	ldr.w	pc, [sp], #4
 8014fe8:	f3af 8000 	nop.w
 8014fec:	f3af 8000 	nop.w

08014ff0 <LSM303AGR_ACC_R_Int2EnYHi>:
* Input          : Pointer to LSM303AGR_ACC_YHIE_t
* Output         : Status of YHIE see LSM303AGR_ACC_YHIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2EnYHi(void *handle, LSM303AGR_ACC_YHIE_t *value)
{
 8014ff0:	b500      	push	{lr}
 8014ff2:	b083      	sub	sp, #12
 8014ff4:	9001      	str	r0, [sp, #4]
 8014ff6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8014ff8:	9801      	ldr	r0, [sp, #4]
 8014ffa:	2134      	movs	r1, #52	; 0x34
 8014ffc:	9a00      	ldr	r2, [sp, #0]
 8014ffe:	2301      	movs	r3, #1
 8015000:	f7fd f98e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015004:	4603      	mov	r3, r0
 8015006:	2b00      	cmp	r3, #0
 8015008:	d101      	bne.n	801500e <LSM303AGR_ACC_R_Int2EnYHi+0x1e>
    return MEMS_ERROR;
 801500a:	2300      	movs	r3, #0
 801500c:	e007      	b.n	801501e <LSM303AGR_ACC_R_Int2EnYHi+0x2e>

  *value &= LSM303AGR_ACC_YHIE_MASK; //mask
 801500e:	9b00      	ldr	r3, [sp, #0]
 8015010:	781b      	ldrb	r3, [r3, #0]
 8015012:	f003 0308 	and.w	r3, r3, #8
 8015016:	b2da      	uxtb	r2, r3
 8015018:	9b00      	ldr	r3, [sp, #0]
 801501a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801501c:	2301      	movs	r3, #1
}
 801501e:	4618      	mov	r0, r3
 8015020:	b003      	add	sp, #12
 8015022:	f85d fb04 	ldr.w	pc, [sp], #4
 8015026:	bf00      	nop
 8015028:	f3af 8000 	nop.w
 801502c:	f3af 8000 	nop.w

08015030 <LSM303AGR_ACC_W_Int2EnZLo>:
* Input          : LSM303AGR_ACC_ZLIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2EnZLo(void *handle, LSM303AGR_ACC_ZLIE_t newValue)
{
 8015030:	b500      	push	{lr}
 8015032:	b085      	sub	sp, #20
 8015034:	9001      	str	r0, [sp, #4]
 8015036:	460b      	mov	r3, r1
 8015038:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 801503c:	f10d 030f 	add.w	r3, sp, #15
 8015040:	9801      	ldr	r0, [sp, #4]
 8015042:	2134      	movs	r1, #52	; 0x34
 8015044:	461a      	mov	r2, r3
 8015046:	2301      	movs	r3, #1
 8015048:	f7fd f96a 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 801504c:	4603      	mov	r3, r0
 801504e:	2b00      	cmp	r3, #0
 8015050:	d101      	bne.n	8015056 <LSM303AGR_ACC_W_Int2EnZLo+0x26>
    return MEMS_ERROR;
 8015052:	2300      	movs	r3, #0
 8015054:	e01c      	b.n	8015090 <LSM303AGR_ACC_W_Int2EnZLo+0x60>

  value &= ~LSM303AGR_ACC_ZLIE_MASK;
 8015056:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801505a:	f023 0310 	bic.w	r3, r3, #16
 801505e:	b2db      	uxtb	r3, r3
 8015060:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015064:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015068:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801506c:	4313      	orrs	r3, r2
 801506e:	b2db      	uxtb	r3, r3
 8015070:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8015074:	f10d 030f 	add.w	r3, sp, #15
 8015078:	9801      	ldr	r0, [sp, #4]
 801507a:	2134      	movs	r1, #52	; 0x34
 801507c:	461a      	mov	r2, r3
 801507e:	2301      	movs	r3, #1
 8015080:	f7fd f92e 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8015084:	4603      	mov	r3, r0
 8015086:	2b00      	cmp	r3, #0
 8015088:	d101      	bne.n	801508e <LSM303AGR_ACC_W_Int2EnZLo+0x5e>
    return MEMS_ERROR;
 801508a:	2300      	movs	r3, #0
 801508c:	e000      	b.n	8015090 <LSM303AGR_ACC_W_Int2EnZLo+0x60>

  return MEMS_SUCCESS;
 801508e:	2301      	movs	r3, #1
}
 8015090:	4618      	mov	r0, r3
 8015092:	b005      	add	sp, #20
 8015094:	f85d fb04 	ldr.w	pc, [sp], #4
 8015098:	f3af 8000 	nop.w
 801509c:	f3af 8000 	nop.w

080150a0 <LSM303AGR_ACC_R_Int2EnZLo>:
* Input          : Pointer to LSM303AGR_ACC_ZLIE_t
* Output         : Status of ZLIE see LSM303AGR_ACC_ZLIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2EnZLo(void *handle, LSM303AGR_ACC_ZLIE_t *value)
{
 80150a0:	b500      	push	{lr}
 80150a2:	b083      	sub	sp, #12
 80150a4:	9001      	str	r0, [sp, #4]
 80150a6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 80150a8:	9801      	ldr	r0, [sp, #4]
 80150aa:	2134      	movs	r1, #52	; 0x34
 80150ac:	9a00      	ldr	r2, [sp, #0]
 80150ae:	2301      	movs	r3, #1
 80150b0:	f7fd f936 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80150b4:	4603      	mov	r3, r0
 80150b6:	2b00      	cmp	r3, #0
 80150b8:	d101      	bne.n	80150be <LSM303AGR_ACC_R_Int2EnZLo+0x1e>
    return MEMS_ERROR;
 80150ba:	2300      	movs	r3, #0
 80150bc:	e007      	b.n	80150ce <LSM303AGR_ACC_R_Int2EnZLo+0x2e>

  *value &= LSM303AGR_ACC_ZLIE_MASK; //mask
 80150be:	9b00      	ldr	r3, [sp, #0]
 80150c0:	781b      	ldrb	r3, [r3, #0]
 80150c2:	f003 0310 	and.w	r3, r3, #16
 80150c6:	b2da      	uxtb	r2, r3
 80150c8:	9b00      	ldr	r3, [sp, #0]
 80150ca:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80150cc:	2301      	movs	r3, #1
}
 80150ce:	4618      	mov	r0, r3
 80150d0:	b003      	add	sp, #12
 80150d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80150d6:	bf00      	nop
 80150d8:	f3af 8000 	nop.w
 80150dc:	f3af 8000 	nop.w

080150e0 <LSM303AGR_ACC_W_Int2EnZHi>:
* Input          : LSM303AGR_ACC_ZHIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2EnZHi(void *handle, LSM303AGR_ACC_ZHIE_t newValue)
{
 80150e0:	b500      	push	{lr}
 80150e2:	b085      	sub	sp, #20
 80150e4:	9001      	str	r0, [sp, #4]
 80150e6:	460b      	mov	r3, r1
 80150e8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 80150ec:	f10d 030f 	add.w	r3, sp, #15
 80150f0:	9801      	ldr	r0, [sp, #4]
 80150f2:	2134      	movs	r1, #52	; 0x34
 80150f4:	461a      	mov	r2, r3
 80150f6:	2301      	movs	r3, #1
 80150f8:	f7fd f912 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80150fc:	4603      	mov	r3, r0
 80150fe:	2b00      	cmp	r3, #0
 8015100:	d101      	bne.n	8015106 <LSM303AGR_ACC_W_Int2EnZHi+0x26>
    return MEMS_ERROR;
 8015102:	2300      	movs	r3, #0
 8015104:	e01c      	b.n	8015140 <LSM303AGR_ACC_W_Int2EnZHi+0x60>

  value &= ~LSM303AGR_ACC_ZHIE_MASK;
 8015106:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801510a:	f023 0320 	bic.w	r3, r3, #32
 801510e:	b2db      	uxtb	r3, r3
 8015110:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015114:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015118:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801511c:	4313      	orrs	r3, r2
 801511e:	b2db      	uxtb	r3, r3
 8015120:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8015124:	f10d 030f 	add.w	r3, sp, #15
 8015128:	9801      	ldr	r0, [sp, #4]
 801512a:	2134      	movs	r1, #52	; 0x34
 801512c:	461a      	mov	r2, r3
 801512e:	2301      	movs	r3, #1
 8015130:	f7fd f8d6 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8015134:	4603      	mov	r3, r0
 8015136:	2b00      	cmp	r3, #0
 8015138:	d101      	bne.n	801513e <LSM303AGR_ACC_W_Int2EnZHi+0x5e>
    return MEMS_ERROR;
 801513a:	2300      	movs	r3, #0
 801513c:	e000      	b.n	8015140 <LSM303AGR_ACC_W_Int2EnZHi+0x60>

  return MEMS_SUCCESS;
 801513e:	2301      	movs	r3, #1
}
 8015140:	4618      	mov	r0, r3
 8015142:	b005      	add	sp, #20
 8015144:	f85d fb04 	ldr.w	pc, [sp], #4
 8015148:	f3af 8000 	nop.w
 801514c:	f3af 8000 	nop.w

08015150 <LSM303AGR_ACC_R_Int2EnZHi>:
* Input          : Pointer to LSM303AGR_ACC_ZHIE_t
* Output         : Status of ZHIE see LSM303AGR_ACC_ZHIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2EnZHi(void *handle, LSM303AGR_ACC_ZHIE_t *value)
{
 8015150:	b500      	push	{lr}
 8015152:	b083      	sub	sp, #12
 8015154:	9001      	str	r0, [sp, #4]
 8015156:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8015158:	9801      	ldr	r0, [sp, #4]
 801515a:	2134      	movs	r1, #52	; 0x34
 801515c:	9a00      	ldr	r2, [sp, #0]
 801515e:	2301      	movs	r3, #1
 8015160:	f7fd f8de 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015164:	4603      	mov	r3, r0
 8015166:	2b00      	cmp	r3, #0
 8015168:	d101      	bne.n	801516e <LSM303AGR_ACC_R_Int2EnZHi+0x1e>
    return MEMS_ERROR;
 801516a:	2300      	movs	r3, #0
 801516c:	e007      	b.n	801517e <LSM303AGR_ACC_R_Int2EnZHi+0x2e>

  *value &= LSM303AGR_ACC_ZHIE_MASK; //mask
 801516e:	9b00      	ldr	r3, [sp, #0]
 8015170:	781b      	ldrb	r3, [r3, #0]
 8015172:	f003 0320 	and.w	r3, r3, #32
 8015176:	b2da      	uxtb	r2, r3
 8015178:	9b00      	ldr	r3, [sp, #0]
 801517a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801517c:	2301      	movs	r3, #1
}
 801517e:	4618      	mov	r0, r3
 8015180:	b003      	add	sp, #12
 8015182:	f85d fb04 	ldr.w	pc, [sp], #4
 8015186:	bf00      	nop
 8015188:	f3af 8000 	nop.w
 801518c:	f3af 8000 	nop.w

08015190 <LSM303AGR_ACC_W_Int2_6D>:
* Input          : LSM303AGR_ACC_6D_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2_6D(void *handle, LSM303AGR_ACC_6D_t newValue)
{
 8015190:	b500      	push	{lr}
 8015192:	b085      	sub	sp, #20
 8015194:	9001      	str	r0, [sp, #4]
 8015196:	460b      	mov	r3, r1
 8015198:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 801519c:	f10d 030f 	add.w	r3, sp, #15
 80151a0:	9801      	ldr	r0, [sp, #4]
 80151a2:	2134      	movs	r1, #52	; 0x34
 80151a4:	461a      	mov	r2, r3
 80151a6:	2301      	movs	r3, #1
 80151a8:	f7fd f8ba 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80151ac:	4603      	mov	r3, r0
 80151ae:	2b00      	cmp	r3, #0
 80151b0:	d101      	bne.n	80151b6 <LSM303AGR_ACC_W_Int2_6D+0x26>
    return MEMS_ERROR;
 80151b2:	2300      	movs	r3, #0
 80151b4:	e01c      	b.n	80151f0 <LSM303AGR_ACC_W_Int2_6D+0x60>

  value &= ~LSM303AGR_ACC_6D_MASK;
 80151b6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80151ba:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80151be:	b2db      	uxtb	r3, r3
 80151c0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80151c4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80151c8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80151cc:	4313      	orrs	r3, r2
 80151ce:	b2db      	uxtb	r3, r3
 80151d0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 80151d4:	f10d 030f 	add.w	r3, sp, #15
 80151d8:	9801      	ldr	r0, [sp, #4]
 80151da:	2134      	movs	r1, #52	; 0x34
 80151dc:	461a      	mov	r2, r3
 80151de:	2301      	movs	r3, #1
 80151e0:	f7fd f87e 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 80151e4:	4603      	mov	r3, r0
 80151e6:	2b00      	cmp	r3, #0
 80151e8:	d101      	bne.n	80151ee <LSM303AGR_ACC_W_Int2_6D+0x5e>
    return MEMS_ERROR;
 80151ea:	2300      	movs	r3, #0
 80151ec:	e000      	b.n	80151f0 <LSM303AGR_ACC_W_Int2_6D+0x60>

  return MEMS_SUCCESS;
 80151ee:	2301      	movs	r3, #1
}
 80151f0:	4618      	mov	r0, r3
 80151f2:	b005      	add	sp, #20
 80151f4:	f85d fb04 	ldr.w	pc, [sp], #4
 80151f8:	f3af 8000 	nop.w
 80151fc:	f3af 8000 	nop.w

08015200 <LSM303AGR_ACC_R_Int2_6D>:
* Input          : Pointer to LSM303AGR_ACC_6D_t
* Output         : Status of 6D see LSM303AGR_ACC_6D_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_6D(void *handle, LSM303AGR_ACC_6D_t *value)
{
 8015200:	b500      	push	{lr}
 8015202:	b083      	sub	sp, #12
 8015204:	9001      	str	r0, [sp, #4]
 8015206:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8015208:	9801      	ldr	r0, [sp, #4]
 801520a:	2134      	movs	r1, #52	; 0x34
 801520c:	9a00      	ldr	r2, [sp, #0]
 801520e:	2301      	movs	r3, #1
 8015210:	f7fd f886 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015214:	4603      	mov	r3, r0
 8015216:	2b00      	cmp	r3, #0
 8015218:	d101      	bne.n	801521e <LSM303AGR_ACC_R_Int2_6D+0x1e>
    return MEMS_ERROR;
 801521a:	2300      	movs	r3, #0
 801521c:	e007      	b.n	801522e <LSM303AGR_ACC_R_Int2_6D+0x2e>

  *value &= LSM303AGR_ACC_6D_MASK; //mask
 801521e:	9b00      	ldr	r3, [sp, #0]
 8015220:	781b      	ldrb	r3, [r3, #0]
 8015222:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8015226:	b2da      	uxtb	r2, r3
 8015228:	9b00      	ldr	r3, [sp, #0]
 801522a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801522c:	2301      	movs	r3, #1
}
 801522e:	4618      	mov	r0, r3
 8015230:	b003      	add	sp, #12
 8015232:	f85d fb04 	ldr.w	pc, [sp], #4
 8015236:	bf00      	nop
 8015238:	f3af 8000 	nop.w
 801523c:	f3af 8000 	nop.w

08015240 <LSM303AGR_ACC_W_Int2_AOI>:
* Input          : LSM303AGR_ACC_AOI_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2_AOI(void *handle, LSM303AGR_ACC_AOI_t newValue)
{
 8015240:	b500      	push	{lr}
 8015242:	b085      	sub	sp, #20
 8015244:	9001      	str	r0, [sp, #4]
 8015246:	460b      	mov	r3, r1
 8015248:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 801524c:	f10d 030f 	add.w	r3, sp, #15
 8015250:	9801      	ldr	r0, [sp, #4]
 8015252:	2134      	movs	r1, #52	; 0x34
 8015254:	461a      	mov	r2, r3
 8015256:	2301      	movs	r3, #1
 8015258:	f7fd f862 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 801525c:	4603      	mov	r3, r0
 801525e:	2b00      	cmp	r3, #0
 8015260:	d101      	bne.n	8015266 <LSM303AGR_ACC_W_Int2_AOI+0x26>
    return MEMS_ERROR;
 8015262:	2300      	movs	r3, #0
 8015264:	e01c      	b.n	80152a0 <LSM303AGR_ACC_W_Int2_AOI+0x60>

  value &= ~LSM303AGR_ACC_AOI_MASK;
 8015266:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801526a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 801526e:	b2db      	uxtb	r3, r3
 8015270:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015274:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015278:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801527c:	4313      	orrs	r3, r2
 801527e:	b2db      	uxtb	r3, r3
 8015280:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8015284:	f10d 030f 	add.w	r3, sp, #15
 8015288:	9801      	ldr	r0, [sp, #4]
 801528a:	2134      	movs	r1, #52	; 0x34
 801528c:	461a      	mov	r2, r3
 801528e:	2301      	movs	r3, #1
 8015290:	f7fd f826 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8015294:	4603      	mov	r3, r0
 8015296:	2b00      	cmp	r3, #0
 8015298:	d101      	bne.n	801529e <LSM303AGR_ACC_W_Int2_AOI+0x5e>
    return MEMS_ERROR;
 801529a:	2300      	movs	r3, #0
 801529c:	e000      	b.n	80152a0 <LSM303AGR_ACC_W_Int2_AOI+0x60>

  return MEMS_SUCCESS;
 801529e:	2301      	movs	r3, #1
}
 80152a0:	4618      	mov	r0, r3
 80152a2:	b005      	add	sp, #20
 80152a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80152a8:	f3af 8000 	nop.w
 80152ac:	f3af 8000 	nop.w

080152b0 <LSM303AGR_ACC_R_Int2_AOI>:
* Input          : Pointer to LSM303AGR_ACC_AOI_t
* Output         : Status of AOI see LSM303AGR_ACC_AOI_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_AOI(void *handle, LSM303AGR_ACC_AOI_t *value)
{
 80152b0:	b500      	push	{lr}
 80152b2:	b083      	sub	sp, #12
 80152b4:	9001      	str	r0, [sp, #4]
 80152b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 80152b8:	9801      	ldr	r0, [sp, #4]
 80152ba:	2134      	movs	r1, #52	; 0x34
 80152bc:	9a00      	ldr	r2, [sp, #0]
 80152be:	2301      	movs	r3, #1
 80152c0:	f7fd f82e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80152c4:	4603      	mov	r3, r0
 80152c6:	2b00      	cmp	r3, #0
 80152c8:	d101      	bne.n	80152ce <LSM303AGR_ACC_R_Int2_AOI+0x1e>
    return MEMS_ERROR;
 80152ca:	2300      	movs	r3, #0
 80152cc:	e007      	b.n	80152de <LSM303AGR_ACC_R_Int2_AOI+0x2e>

  *value &= LSM303AGR_ACC_AOI_MASK; //mask
 80152ce:	9b00      	ldr	r3, [sp, #0]
 80152d0:	781b      	ldrb	r3, [r3, #0]
 80152d2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80152d6:	b2da      	uxtb	r2, r3
 80152d8:	9b00      	ldr	r3, [sp, #0]
 80152da:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80152dc:	2301      	movs	r3, #1
}
 80152de:	4618      	mov	r0, r3
 80152e0:	b003      	add	sp, #12
 80152e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80152e6:	bf00      	nop
 80152e8:	f3af 8000 	nop.w
 80152ec:	f3af 8000 	nop.w

080152f0 <LSM303AGR_ACC_R_Int1_Xlo>:
* Input          : Pointer to LSM303AGR_ACC_XL_t
* Output         : Status of XL see LSM303AGR_ACC_XL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_Xlo(void *handle, LSM303AGR_ACC_XL_t *value)
{
 80152f0:	b500      	push	{lr}
 80152f2:	b083      	sub	sp, #12
 80152f4:	9001      	str	r0, [sp, #4]
 80152f6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 80152f8:	9801      	ldr	r0, [sp, #4]
 80152fa:	2131      	movs	r1, #49	; 0x31
 80152fc:	9a00      	ldr	r2, [sp, #0]
 80152fe:	2301      	movs	r3, #1
 8015300:	f7fd f80e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015304:	4603      	mov	r3, r0
 8015306:	2b00      	cmp	r3, #0
 8015308:	d101      	bne.n	801530e <LSM303AGR_ACC_R_Int1_Xlo+0x1e>
    return MEMS_ERROR;
 801530a:	2300      	movs	r3, #0
 801530c:	e007      	b.n	801531e <LSM303AGR_ACC_R_Int1_Xlo+0x2e>

  *value &= LSM303AGR_ACC_XL_MASK; //mask
 801530e:	9b00      	ldr	r3, [sp, #0]
 8015310:	781b      	ldrb	r3, [r3, #0]
 8015312:	f003 0301 	and.w	r3, r3, #1
 8015316:	b2da      	uxtb	r2, r3
 8015318:	9b00      	ldr	r3, [sp, #0]
 801531a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801531c:	2301      	movs	r3, #1
}
 801531e:	4618      	mov	r0, r3
 8015320:	b003      	add	sp, #12
 8015322:	f85d fb04 	ldr.w	pc, [sp], #4
 8015326:	bf00      	nop
 8015328:	f3af 8000 	nop.w
 801532c:	f3af 8000 	nop.w

08015330 <LSM303AGR_ACC_R_Int1_XHi>:
* Input          : Pointer to LSM303AGR_ACC_XH_t
* Output         : Status of XH see LSM303AGR_ACC_XH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_XHi(void *handle, LSM303AGR_ACC_XH_t *value)
{
 8015330:	b500      	push	{lr}
 8015332:	b083      	sub	sp, #12
 8015334:	9001      	str	r0, [sp, #4]
 8015336:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 8015338:	9801      	ldr	r0, [sp, #4]
 801533a:	2131      	movs	r1, #49	; 0x31
 801533c:	9a00      	ldr	r2, [sp, #0]
 801533e:	2301      	movs	r3, #1
 8015340:	f7fc ffee 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015344:	4603      	mov	r3, r0
 8015346:	2b00      	cmp	r3, #0
 8015348:	d101      	bne.n	801534e <LSM303AGR_ACC_R_Int1_XHi+0x1e>
    return MEMS_ERROR;
 801534a:	2300      	movs	r3, #0
 801534c:	e007      	b.n	801535e <LSM303AGR_ACC_R_Int1_XHi+0x2e>

  *value &= LSM303AGR_ACC_XH_MASK; //mask
 801534e:	9b00      	ldr	r3, [sp, #0]
 8015350:	781b      	ldrb	r3, [r3, #0]
 8015352:	f003 0302 	and.w	r3, r3, #2
 8015356:	b2da      	uxtb	r2, r3
 8015358:	9b00      	ldr	r3, [sp, #0]
 801535a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801535c:	2301      	movs	r3, #1
}
 801535e:	4618      	mov	r0, r3
 8015360:	b003      	add	sp, #12
 8015362:	f85d fb04 	ldr.w	pc, [sp], #4
 8015366:	bf00      	nop
 8015368:	f3af 8000 	nop.w
 801536c:	f3af 8000 	nop.w

08015370 <LSM303AGR_ACC_R_Int1_YLo>:
* Input          : Pointer to LSM303AGR_ACC_YL_t
* Output         : Status of YL see LSM303AGR_ACC_YL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_YLo(void *handle, LSM303AGR_ACC_YL_t *value)
{
 8015370:	b500      	push	{lr}
 8015372:	b083      	sub	sp, #12
 8015374:	9001      	str	r0, [sp, #4]
 8015376:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 8015378:	9801      	ldr	r0, [sp, #4]
 801537a:	2131      	movs	r1, #49	; 0x31
 801537c:	9a00      	ldr	r2, [sp, #0]
 801537e:	2301      	movs	r3, #1
 8015380:	f7fc ffce 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015384:	4603      	mov	r3, r0
 8015386:	2b00      	cmp	r3, #0
 8015388:	d101      	bne.n	801538e <LSM303AGR_ACC_R_Int1_YLo+0x1e>
    return MEMS_ERROR;
 801538a:	2300      	movs	r3, #0
 801538c:	e007      	b.n	801539e <LSM303AGR_ACC_R_Int1_YLo+0x2e>

  *value &= LSM303AGR_ACC_YL_MASK; //mask
 801538e:	9b00      	ldr	r3, [sp, #0]
 8015390:	781b      	ldrb	r3, [r3, #0]
 8015392:	f003 0304 	and.w	r3, r3, #4
 8015396:	b2da      	uxtb	r2, r3
 8015398:	9b00      	ldr	r3, [sp, #0]
 801539a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801539c:	2301      	movs	r3, #1
}
 801539e:	4618      	mov	r0, r3
 80153a0:	b003      	add	sp, #12
 80153a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80153a6:	bf00      	nop
 80153a8:	f3af 8000 	nop.w
 80153ac:	f3af 8000 	nop.w

080153b0 <LSM303AGR_ACC_R_Int1_YHi>:
* Input          : Pointer to LSM303AGR_ACC_YH_t
* Output         : Status of YH see LSM303AGR_ACC_YH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_YHi(void *handle, LSM303AGR_ACC_YH_t *value)
{
 80153b0:	b500      	push	{lr}
 80153b2:	b083      	sub	sp, #12
 80153b4:	9001      	str	r0, [sp, #4]
 80153b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 80153b8:	9801      	ldr	r0, [sp, #4]
 80153ba:	2131      	movs	r1, #49	; 0x31
 80153bc:	9a00      	ldr	r2, [sp, #0]
 80153be:	2301      	movs	r3, #1
 80153c0:	f7fc ffae 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80153c4:	4603      	mov	r3, r0
 80153c6:	2b00      	cmp	r3, #0
 80153c8:	d101      	bne.n	80153ce <LSM303AGR_ACC_R_Int1_YHi+0x1e>
    return MEMS_ERROR;
 80153ca:	2300      	movs	r3, #0
 80153cc:	e007      	b.n	80153de <LSM303AGR_ACC_R_Int1_YHi+0x2e>

  *value &= LSM303AGR_ACC_YH_MASK; //mask
 80153ce:	9b00      	ldr	r3, [sp, #0]
 80153d0:	781b      	ldrb	r3, [r3, #0]
 80153d2:	f003 0308 	and.w	r3, r3, #8
 80153d6:	b2da      	uxtb	r2, r3
 80153d8:	9b00      	ldr	r3, [sp, #0]
 80153da:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80153dc:	2301      	movs	r3, #1
}
 80153de:	4618      	mov	r0, r3
 80153e0:	b003      	add	sp, #12
 80153e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80153e6:	bf00      	nop
 80153e8:	f3af 8000 	nop.w
 80153ec:	f3af 8000 	nop.w

080153f0 <LSM303AGR_ACC_R_Int1_Zlo>:
* Input          : Pointer to LSM303AGR_ACC_ZL_t
* Output         : Status of ZL see LSM303AGR_ACC_ZL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_Zlo(void *handle, LSM303AGR_ACC_ZL_t *value)
{
 80153f0:	b500      	push	{lr}
 80153f2:	b083      	sub	sp, #12
 80153f4:	9001      	str	r0, [sp, #4]
 80153f6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 80153f8:	9801      	ldr	r0, [sp, #4]
 80153fa:	2131      	movs	r1, #49	; 0x31
 80153fc:	9a00      	ldr	r2, [sp, #0]
 80153fe:	2301      	movs	r3, #1
 8015400:	f7fc ff8e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015404:	4603      	mov	r3, r0
 8015406:	2b00      	cmp	r3, #0
 8015408:	d101      	bne.n	801540e <LSM303AGR_ACC_R_Int1_Zlo+0x1e>
    return MEMS_ERROR;
 801540a:	2300      	movs	r3, #0
 801540c:	e007      	b.n	801541e <LSM303AGR_ACC_R_Int1_Zlo+0x2e>

  *value &= LSM303AGR_ACC_ZL_MASK; //mask
 801540e:	9b00      	ldr	r3, [sp, #0]
 8015410:	781b      	ldrb	r3, [r3, #0]
 8015412:	f003 0310 	and.w	r3, r3, #16
 8015416:	b2da      	uxtb	r2, r3
 8015418:	9b00      	ldr	r3, [sp, #0]
 801541a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801541c:	2301      	movs	r3, #1
}
 801541e:	4618      	mov	r0, r3
 8015420:	b003      	add	sp, #12
 8015422:	f85d fb04 	ldr.w	pc, [sp], #4
 8015426:	bf00      	nop
 8015428:	f3af 8000 	nop.w
 801542c:	f3af 8000 	nop.w

08015430 <LSM303AGR_ACC_R_Int1_ZHi>:
* Input          : Pointer to LSM303AGR_ACC_ZH_t
* Output         : Status of ZH see LSM303AGR_ACC_ZH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_ZHi(void *handle, LSM303AGR_ACC_ZH_t *value)
{
 8015430:	b500      	push	{lr}
 8015432:	b083      	sub	sp, #12
 8015434:	9001      	str	r0, [sp, #4]
 8015436:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 8015438:	9801      	ldr	r0, [sp, #4]
 801543a:	2131      	movs	r1, #49	; 0x31
 801543c:	9a00      	ldr	r2, [sp, #0]
 801543e:	2301      	movs	r3, #1
 8015440:	f7fc ff6e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015444:	4603      	mov	r3, r0
 8015446:	2b00      	cmp	r3, #0
 8015448:	d101      	bne.n	801544e <LSM303AGR_ACC_R_Int1_ZHi+0x1e>
    return MEMS_ERROR;
 801544a:	2300      	movs	r3, #0
 801544c:	e007      	b.n	801545e <LSM303AGR_ACC_R_Int1_ZHi+0x2e>

  *value &= LSM303AGR_ACC_ZH_MASK; //mask
 801544e:	9b00      	ldr	r3, [sp, #0]
 8015450:	781b      	ldrb	r3, [r3, #0]
 8015452:	f003 0320 	and.w	r3, r3, #32
 8015456:	b2da      	uxtb	r2, r3
 8015458:	9b00      	ldr	r3, [sp, #0]
 801545a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801545c:	2301      	movs	r3, #1
}
 801545e:	4618      	mov	r0, r3
 8015460:	b003      	add	sp, #12
 8015462:	f85d fb04 	ldr.w	pc, [sp], #4
 8015466:	bf00      	nop
 8015468:	f3af 8000 	nop.w
 801546c:	f3af 8000 	nop.w

08015470 <LSM303AGR_ACC_R_Int1_IA>:
* Input          : Pointer to LSM303AGR_ACC_IA_t
* Output         : Status of IA see LSM303AGR_ACC_IA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_IA(void *handle, LSM303AGR_ACC_IA_t *value)
{
 8015470:	b500      	push	{lr}
 8015472:	b083      	sub	sp, #12
 8015474:	9001      	str	r0, [sp, #4]
 8015476:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 8015478:	9801      	ldr	r0, [sp, #4]
 801547a:	2131      	movs	r1, #49	; 0x31
 801547c:	9a00      	ldr	r2, [sp, #0]
 801547e:	2301      	movs	r3, #1
 8015480:	f7fc ff4e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015484:	4603      	mov	r3, r0
 8015486:	2b00      	cmp	r3, #0
 8015488:	d101      	bne.n	801548e <LSM303AGR_ACC_R_Int1_IA+0x1e>
    return MEMS_ERROR;
 801548a:	2300      	movs	r3, #0
 801548c:	e007      	b.n	801549e <LSM303AGR_ACC_R_Int1_IA+0x2e>

  *value &= LSM303AGR_ACC_IA_MASK; //mask
 801548e:	9b00      	ldr	r3, [sp, #0]
 8015490:	781b      	ldrb	r3, [r3, #0]
 8015492:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8015496:	b2da      	uxtb	r2, r3
 8015498:	9b00      	ldr	r3, [sp, #0]
 801549a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801549c:	2301      	movs	r3, #1
}
 801549e:	4618      	mov	r0, r3
 80154a0:	b003      	add	sp, #12
 80154a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80154a6:	bf00      	nop
 80154a8:	f3af 8000 	nop.w
 80154ac:	f3af 8000 	nop.w

080154b0 <LSM303AGR_ACC_R_Int2_Xlo>:
* Input          : Pointer to LSM303AGR_ACC_XL_t
* Output         : Status of XL see LSM303AGR_ACC_XL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_Xlo(void *handle, LSM303AGR_ACC_XL_t *value)
{
 80154b0:	b500      	push	{lr}
 80154b2:	b083      	sub	sp, #12
 80154b4:	9001      	str	r0, [sp, #4]
 80154b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 80154b8:	9801      	ldr	r0, [sp, #4]
 80154ba:	2135      	movs	r1, #53	; 0x35
 80154bc:	9a00      	ldr	r2, [sp, #0]
 80154be:	2301      	movs	r3, #1
 80154c0:	f7fc ff2e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80154c4:	4603      	mov	r3, r0
 80154c6:	2b00      	cmp	r3, #0
 80154c8:	d101      	bne.n	80154ce <LSM303AGR_ACC_R_Int2_Xlo+0x1e>
    return MEMS_ERROR;
 80154ca:	2300      	movs	r3, #0
 80154cc:	e007      	b.n	80154de <LSM303AGR_ACC_R_Int2_Xlo+0x2e>

  *value &= LSM303AGR_ACC_XL_MASK; //mask
 80154ce:	9b00      	ldr	r3, [sp, #0]
 80154d0:	781b      	ldrb	r3, [r3, #0]
 80154d2:	f003 0301 	and.w	r3, r3, #1
 80154d6:	b2da      	uxtb	r2, r3
 80154d8:	9b00      	ldr	r3, [sp, #0]
 80154da:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80154dc:	2301      	movs	r3, #1
}
 80154de:	4618      	mov	r0, r3
 80154e0:	b003      	add	sp, #12
 80154e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80154e6:	bf00      	nop
 80154e8:	f3af 8000 	nop.w
 80154ec:	f3af 8000 	nop.w

080154f0 <LSM303AGR_ACC_R_Int2_XHi>:
* Input          : Pointer to LSM303AGR_ACC_XH_t
* Output         : Status of XH see LSM303AGR_ACC_XH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_XHi(void *handle, LSM303AGR_ACC_XH_t *value)
{
 80154f0:	b500      	push	{lr}
 80154f2:	b083      	sub	sp, #12
 80154f4:	9001      	str	r0, [sp, #4]
 80154f6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 80154f8:	9801      	ldr	r0, [sp, #4]
 80154fa:	2135      	movs	r1, #53	; 0x35
 80154fc:	9a00      	ldr	r2, [sp, #0]
 80154fe:	2301      	movs	r3, #1
 8015500:	f7fc ff0e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015504:	4603      	mov	r3, r0
 8015506:	2b00      	cmp	r3, #0
 8015508:	d101      	bne.n	801550e <LSM303AGR_ACC_R_Int2_XHi+0x1e>
    return MEMS_ERROR;
 801550a:	2300      	movs	r3, #0
 801550c:	e007      	b.n	801551e <LSM303AGR_ACC_R_Int2_XHi+0x2e>

  *value &= LSM303AGR_ACC_XH_MASK; //mask
 801550e:	9b00      	ldr	r3, [sp, #0]
 8015510:	781b      	ldrb	r3, [r3, #0]
 8015512:	f003 0302 	and.w	r3, r3, #2
 8015516:	b2da      	uxtb	r2, r3
 8015518:	9b00      	ldr	r3, [sp, #0]
 801551a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801551c:	2301      	movs	r3, #1
}
 801551e:	4618      	mov	r0, r3
 8015520:	b003      	add	sp, #12
 8015522:	f85d fb04 	ldr.w	pc, [sp], #4
 8015526:	bf00      	nop
 8015528:	f3af 8000 	nop.w
 801552c:	f3af 8000 	nop.w

08015530 <LSM303AGR_ACC_R_Int2_YLo>:
* Input          : Pointer to LSM303AGR_ACC_YL_t
* Output         : Status of YL see LSM303AGR_ACC_YL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_YLo(void *handle, LSM303AGR_ACC_YL_t *value)
{
 8015530:	b500      	push	{lr}
 8015532:	b083      	sub	sp, #12
 8015534:	9001      	str	r0, [sp, #4]
 8015536:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 8015538:	9801      	ldr	r0, [sp, #4]
 801553a:	2135      	movs	r1, #53	; 0x35
 801553c:	9a00      	ldr	r2, [sp, #0]
 801553e:	2301      	movs	r3, #1
 8015540:	f7fc feee 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015544:	4603      	mov	r3, r0
 8015546:	2b00      	cmp	r3, #0
 8015548:	d101      	bne.n	801554e <LSM303AGR_ACC_R_Int2_YLo+0x1e>
    return MEMS_ERROR;
 801554a:	2300      	movs	r3, #0
 801554c:	e007      	b.n	801555e <LSM303AGR_ACC_R_Int2_YLo+0x2e>

  *value &= LSM303AGR_ACC_YL_MASK; //mask
 801554e:	9b00      	ldr	r3, [sp, #0]
 8015550:	781b      	ldrb	r3, [r3, #0]
 8015552:	f003 0304 	and.w	r3, r3, #4
 8015556:	b2da      	uxtb	r2, r3
 8015558:	9b00      	ldr	r3, [sp, #0]
 801555a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801555c:	2301      	movs	r3, #1
}
 801555e:	4618      	mov	r0, r3
 8015560:	b003      	add	sp, #12
 8015562:	f85d fb04 	ldr.w	pc, [sp], #4
 8015566:	bf00      	nop
 8015568:	f3af 8000 	nop.w
 801556c:	f3af 8000 	nop.w

08015570 <LSM303AGR_ACC_R_Int2_YHi>:
* Input          : Pointer to LSM303AGR_ACC_YH_t
* Output         : Status of YH see LSM303AGR_ACC_YH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_YHi(void *handle, LSM303AGR_ACC_YH_t *value)
{
 8015570:	b500      	push	{lr}
 8015572:	b083      	sub	sp, #12
 8015574:	9001      	str	r0, [sp, #4]
 8015576:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 8015578:	9801      	ldr	r0, [sp, #4]
 801557a:	2135      	movs	r1, #53	; 0x35
 801557c:	9a00      	ldr	r2, [sp, #0]
 801557e:	2301      	movs	r3, #1
 8015580:	f7fc fece 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015584:	4603      	mov	r3, r0
 8015586:	2b00      	cmp	r3, #0
 8015588:	d101      	bne.n	801558e <LSM303AGR_ACC_R_Int2_YHi+0x1e>
    return MEMS_ERROR;
 801558a:	2300      	movs	r3, #0
 801558c:	e007      	b.n	801559e <LSM303AGR_ACC_R_Int2_YHi+0x2e>

  *value &= LSM303AGR_ACC_YH_MASK; //mask
 801558e:	9b00      	ldr	r3, [sp, #0]
 8015590:	781b      	ldrb	r3, [r3, #0]
 8015592:	f003 0308 	and.w	r3, r3, #8
 8015596:	b2da      	uxtb	r2, r3
 8015598:	9b00      	ldr	r3, [sp, #0]
 801559a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801559c:	2301      	movs	r3, #1
}
 801559e:	4618      	mov	r0, r3
 80155a0:	b003      	add	sp, #12
 80155a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80155a6:	bf00      	nop
 80155a8:	f3af 8000 	nop.w
 80155ac:	f3af 8000 	nop.w

080155b0 <LSM303AGR_ACC_R_Int2_Zlo>:
* Input          : Pointer to LSM303AGR_ACC_ZL_t
* Output         : Status of ZL see LSM303AGR_ACC_ZL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_Zlo(void *handle, LSM303AGR_ACC_ZL_t *value)
{
 80155b0:	b500      	push	{lr}
 80155b2:	b083      	sub	sp, #12
 80155b4:	9001      	str	r0, [sp, #4]
 80155b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 80155b8:	9801      	ldr	r0, [sp, #4]
 80155ba:	2135      	movs	r1, #53	; 0x35
 80155bc:	9a00      	ldr	r2, [sp, #0]
 80155be:	2301      	movs	r3, #1
 80155c0:	f7fc feae 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80155c4:	4603      	mov	r3, r0
 80155c6:	2b00      	cmp	r3, #0
 80155c8:	d101      	bne.n	80155ce <LSM303AGR_ACC_R_Int2_Zlo+0x1e>
    return MEMS_ERROR;
 80155ca:	2300      	movs	r3, #0
 80155cc:	e007      	b.n	80155de <LSM303AGR_ACC_R_Int2_Zlo+0x2e>

  *value &= LSM303AGR_ACC_ZL_MASK; //mask
 80155ce:	9b00      	ldr	r3, [sp, #0]
 80155d0:	781b      	ldrb	r3, [r3, #0]
 80155d2:	f003 0310 	and.w	r3, r3, #16
 80155d6:	b2da      	uxtb	r2, r3
 80155d8:	9b00      	ldr	r3, [sp, #0]
 80155da:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80155dc:	2301      	movs	r3, #1
}
 80155de:	4618      	mov	r0, r3
 80155e0:	b003      	add	sp, #12
 80155e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80155e6:	bf00      	nop
 80155e8:	f3af 8000 	nop.w
 80155ec:	f3af 8000 	nop.w

080155f0 <LSM303AGR_ACC_R_Int2_ZHi>:
* Input          : Pointer to LSM303AGR_ACC_ZH_t
* Output         : Status of ZH see LSM303AGR_ACC_ZH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_ZHi(void *handle, LSM303AGR_ACC_ZH_t *value)
{
 80155f0:	b500      	push	{lr}
 80155f2:	b083      	sub	sp, #12
 80155f4:	9001      	str	r0, [sp, #4]
 80155f6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 80155f8:	9801      	ldr	r0, [sp, #4]
 80155fa:	2135      	movs	r1, #53	; 0x35
 80155fc:	9a00      	ldr	r2, [sp, #0]
 80155fe:	2301      	movs	r3, #1
 8015600:	f7fc fe8e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015604:	4603      	mov	r3, r0
 8015606:	2b00      	cmp	r3, #0
 8015608:	d101      	bne.n	801560e <LSM303AGR_ACC_R_Int2_ZHi+0x1e>
    return MEMS_ERROR;
 801560a:	2300      	movs	r3, #0
 801560c:	e007      	b.n	801561e <LSM303AGR_ACC_R_Int2_ZHi+0x2e>

  *value &= LSM303AGR_ACC_ZH_MASK; //mask
 801560e:	9b00      	ldr	r3, [sp, #0]
 8015610:	781b      	ldrb	r3, [r3, #0]
 8015612:	f003 0320 	and.w	r3, r3, #32
 8015616:	b2da      	uxtb	r2, r3
 8015618:	9b00      	ldr	r3, [sp, #0]
 801561a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801561c:	2301      	movs	r3, #1
}
 801561e:	4618      	mov	r0, r3
 8015620:	b003      	add	sp, #12
 8015622:	f85d fb04 	ldr.w	pc, [sp], #4
 8015626:	bf00      	nop
 8015628:	f3af 8000 	nop.w
 801562c:	f3af 8000 	nop.w

08015630 <LSM303AGR_ACC_R_Int2_IA>:
* Input          : Pointer to LSM303AGR_ACC_IA_t
* Output         : Status of IA see LSM303AGR_ACC_IA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_IA(void *handle, LSM303AGR_ACC_IA_t *value)
{
 8015630:	b500      	push	{lr}
 8015632:	b083      	sub	sp, #12
 8015634:	9001      	str	r0, [sp, #4]
 8015636:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 8015638:	9801      	ldr	r0, [sp, #4]
 801563a:	2135      	movs	r1, #53	; 0x35
 801563c:	9a00      	ldr	r2, [sp, #0]
 801563e:	2301      	movs	r3, #1
 8015640:	f7fc fe6e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015644:	4603      	mov	r3, r0
 8015646:	2b00      	cmp	r3, #0
 8015648:	d101      	bne.n	801564e <LSM303AGR_ACC_R_Int2_IA+0x1e>
    return MEMS_ERROR;
 801564a:	2300      	movs	r3, #0
 801564c:	e007      	b.n	801565e <LSM303AGR_ACC_R_Int2_IA+0x2e>

  *value &= LSM303AGR_ACC_IA_MASK; //mask
 801564e:	9b00      	ldr	r3, [sp, #0]
 8015650:	781b      	ldrb	r3, [r3, #0]
 8015652:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8015656:	b2da      	uxtb	r2, r3
 8015658:	9b00      	ldr	r3, [sp, #0]
 801565a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801565c:	2301      	movs	r3, #1
}
 801565e:	4618      	mov	r0, r3
 8015660:	b003      	add	sp, #12
 8015662:	f85d fb04 	ldr.w	pc, [sp], #4
 8015666:	bf00      	nop
 8015668:	f3af 8000 	nop.w
 801566c:	f3af 8000 	nop.w

08015670 <LSM303AGR_ACC_W_Int1_Threshold>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1_Threshold(void *handle, u8_t newValue)
{
 8015670:	b500      	push	{lr}
 8015672:	b085      	sub	sp, #20
 8015674:	9001      	str	r0, [sp, #4]
 8015676:	460b      	mov	r3, r1
 8015678:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_THS_POSITION; //mask
  newValue &= LSM303AGR_ACC_THS_MASK; //coerce
 801567c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015680:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8015684:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_THS, &value, 1) )
 8015688:	f10d 030f 	add.w	r3, sp, #15
 801568c:	9801      	ldr	r0, [sp, #4]
 801568e:	2132      	movs	r1, #50	; 0x32
 8015690:	461a      	mov	r2, r3
 8015692:	2301      	movs	r3, #1
 8015694:	f7fc fe44 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015698:	4603      	mov	r3, r0
 801569a:	2b00      	cmp	r3, #0
 801569c:	d101      	bne.n	80156a2 <LSM303AGR_ACC_W_Int1_Threshold+0x32>
    return MEMS_ERROR;
 801569e:	2300      	movs	r3, #0
 80156a0:	e01c      	b.n	80156dc <LSM303AGR_ACC_W_Int1_Threshold+0x6c>

  value &= ~LSM303AGR_ACC_THS_MASK;
 80156a2:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80156a6:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80156aa:	b2db      	uxtb	r3, r3
 80156ac:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80156b0:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80156b4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80156b8:	4313      	orrs	r3, r2
 80156ba:	b2db      	uxtb	r3, r3
 80156bc:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_THS, &value, 1) )
 80156c0:	f10d 030f 	add.w	r3, sp, #15
 80156c4:	9801      	ldr	r0, [sp, #4]
 80156c6:	2132      	movs	r1, #50	; 0x32
 80156c8:	461a      	mov	r2, r3
 80156ca:	2301      	movs	r3, #1
 80156cc:	f7fc fe08 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 80156d0:	4603      	mov	r3, r0
 80156d2:	2b00      	cmp	r3, #0
 80156d4:	d101      	bne.n	80156da <LSM303AGR_ACC_W_Int1_Threshold+0x6a>
    return MEMS_ERROR;
 80156d6:	2300      	movs	r3, #0
 80156d8:	e000      	b.n	80156dc <LSM303AGR_ACC_W_Int1_Threshold+0x6c>

  return MEMS_SUCCESS;
 80156da:	2301      	movs	r3, #1
}
 80156dc:	4618      	mov	r0, r3
 80156de:	b005      	add	sp, #20
 80156e0:	f85d fb04 	ldr.w	pc, [sp], #4
 80156e4:	f3af 8000 	nop.w
 80156e8:	f3af 8000 	nop.w
 80156ec:	f3af 8000 	nop.w

080156f0 <LSM303AGR_ACC_R_Int1_Threshold>:
* Input          : Pointer to u8_t
* Output         : Status of THS
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_Threshold(void *handle, u8_t *value)
{
 80156f0:	b500      	push	{lr}
 80156f2:	b083      	sub	sp, #12
 80156f4:	9001      	str	r0, [sp, #4]
 80156f6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_THS, (u8_t *)value, 1) )
 80156f8:	9801      	ldr	r0, [sp, #4]
 80156fa:	2132      	movs	r1, #50	; 0x32
 80156fc:	9a00      	ldr	r2, [sp, #0]
 80156fe:	2301      	movs	r3, #1
 8015700:	f7fc fe0e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015704:	4603      	mov	r3, r0
 8015706:	2b00      	cmp	r3, #0
 8015708:	d101      	bne.n	801570e <LSM303AGR_ACC_R_Int1_Threshold+0x1e>
    return MEMS_ERROR;
 801570a:	2300      	movs	r3, #0
 801570c:	e00b      	b.n	8015726 <LSM303AGR_ACC_R_Int1_Threshold+0x36>

  *value &= LSM303AGR_ACC_THS_MASK; //coerce
 801570e:	9b00      	ldr	r3, [sp, #0]
 8015710:	781b      	ldrb	r3, [r3, #0]
 8015712:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8015716:	b2da      	uxtb	r2, r3
 8015718:	9b00      	ldr	r3, [sp, #0]
 801571a:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_THS_POSITION; //mask
 801571c:	9b00      	ldr	r3, [sp, #0]
 801571e:	781a      	ldrb	r2, [r3, #0]
 8015720:	9b00      	ldr	r3, [sp, #0]
 8015722:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015724:	2301      	movs	r3, #1
}
 8015726:	4618      	mov	r0, r3
 8015728:	b003      	add	sp, #12
 801572a:	f85d fb04 	ldr.w	pc, [sp], #4
 801572e:	bf00      	nop

08015730 <LSM303AGR_ACC_W_Int2_Threshold>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2_Threshold(void *handle, u8_t newValue)
{
 8015730:	b500      	push	{lr}
 8015732:	b085      	sub	sp, #20
 8015734:	9001      	str	r0, [sp, #4]
 8015736:	460b      	mov	r3, r1
 8015738:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_THS_POSITION; //mask
  newValue &= LSM303AGR_ACC_THS_MASK; //coerce
 801573c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015740:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8015744:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_THS, &value, 1) )
 8015748:	f10d 030f 	add.w	r3, sp, #15
 801574c:	9801      	ldr	r0, [sp, #4]
 801574e:	2136      	movs	r1, #54	; 0x36
 8015750:	461a      	mov	r2, r3
 8015752:	2301      	movs	r3, #1
 8015754:	f7fc fde4 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015758:	4603      	mov	r3, r0
 801575a:	2b00      	cmp	r3, #0
 801575c:	d101      	bne.n	8015762 <LSM303AGR_ACC_W_Int2_Threshold+0x32>
    return MEMS_ERROR;
 801575e:	2300      	movs	r3, #0
 8015760:	e01c      	b.n	801579c <LSM303AGR_ACC_W_Int2_Threshold+0x6c>

  value &= ~LSM303AGR_ACC_THS_MASK;
 8015762:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015766:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801576a:	b2db      	uxtb	r3, r3
 801576c:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015770:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015774:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015778:	4313      	orrs	r3, r2
 801577a:	b2db      	uxtb	r3, r3
 801577c:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_THS, &value, 1) )
 8015780:	f10d 030f 	add.w	r3, sp, #15
 8015784:	9801      	ldr	r0, [sp, #4]
 8015786:	2136      	movs	r1, #54	; 0x36
 8015788:	461a      	mov	r2, r3
 801578a:	2301      	movs	r3, #1
 801578c:	f7fc fda8 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8015790:	4603      	mov	r3, r0
 8015792:	2b00      	cmp	r3, #0
 8015794:	d101      	bne.n	801579a <LSM303AGR_ACC_W_Int2_Threshold+0x6a>
    return MEMS_ERROR;
 8015796:	2300      	movs	r3, #0
 8015798:	e000      	b.n	801579c <LSM303AGR_ACC_W_Int2_Threshold+0x6c>

  return MEMS_SUCCESS;
 801579a:	2301      	movs	r3, #1
}
 801579c:	4618      	mov	r0, r3
 801579e:	b005      	add	sp, #20
 80157a0:	f85d fb04 	ldr.w	pc, [sp], #4
 80157a4:	f3af 8000 	nop.w
 80157a8:	f3af 8000 	nop.w
 80157ac:	f3af 8000 	nop.w

080157b0 <LSM303AGR_ACC_R_Int2_Threshold>:
* Input          : Pointer to u8_t
* Output         : Status of THS
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_Threshold(void *handle, u8_t *value)
{
 80157b0:	b500      	push	{lr}
 80157b2:	b083      	sub	sp, #12
 80157b4:	9001      	str	r0, [sp, #4]
 80157b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_THS, (u8_t *)value, 1) )
 80157b8:	9801      	ldr	r0, [sp, #4]
 80157ba:	2136      	movs	r1, #54	; 0x36
 80157bc:	9a00      	ldr	r2, [sp, #0]
 80157be:	2301      	movs	r3, #1
 80157c0:	f7fc fdae 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80157c4:	4603      	mov	r3, r0
 80157c6:	2b00      	cmp	r3, #0
 80157c8:	d101      	bne.n	80157ce <LSM303AGR_ACC_R_Int2_Threshold+0x1e>
    return MEMS_ERROR;
 80157ca:	2300      	movs	r3, #0
 80157cc:	e00b      	b.n	80157e6 <LSM303AGR_ACC_R_Int2_Threshold+0x36>

  *value &= LSM303AGR_ACC_THS_MASK; //coerce
 80157ce:	9b00      	ldr	r3, [sp, #0]
 80157d0:	781b      	ldrb	r3, [r3, #0]
 80157d2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80157d6:	b2da      	uxtb	r2, r3
 80157d8:	9b00      	ldr	r3, [sp, #0]
 80157da:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_THS_POSITION; //mask
 80157dc:	9b00      	ldr	r3, [sp, #0]
 80157de:	781a      	ldrb	r2, [r3, #0]
 80157e0:	9b00      	ldr	r3, [sp, #0]
 80157e2:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80157e4:	2301      	movs	r3, #1
}
 80157e6:	4618      	mov	r0, r3
 80157e8:	b003      	add	sp, #12
 80157ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80157ee:	bf00      	nop

080157f0 <LSM303AGR_ACC_W_Int1_Duration>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1_Duration(void *handle, u8_t newValue)
{
 80157f0:	b500      	push	{lr}
 80157f2:	b085      	sub	sp, #20
 80157f4:	9001      	str	r0, [sp, #4]
 80157f6:	460b      	mov	r3, r1
 80157f8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_D_POSITION; //mask
  newValue &= LSM303AGR_ACC_D_MASK; //coerce
 80157fc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015800:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8015804:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_DURATION, &value, 1) )
 8015808:	f10d 030f 	add.w	r3, sp, #15
 801580c:	9801      	ldr	r0, [sp, #4]
 801580e:	2133      	movs	r1, #51	; 0x33
 8015810:	461a      	mov	r2, r3
 8015812:	2301      	movs	r3, #1
 8015814:	f7fc fd84 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015818:	4603      	mov	r3, r0
 801581a:	2b00      	cmp	r3, #0
 801581c:	d101      	bne.n	8015822 <LSM303AGR_ACC_W_Int1_Duration+0x32>
    return MEMS_ERROR;
 801581e:	2300      	movs	r3, #0
 8015820:	e01c      	b.n	801585c <LSM303AGR_ACC_W_Int1_Duration+0x6c>

  value &= ~LSM303AGR_ACC_D_MASK;
 8015822:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015826:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801582a:	b2db      	uxtb	r3, r3
 801582c:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015830:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015834:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015838:	4313      	orrs	r3, r2
 801583a:	b2db      	uxtb	r3, r3
 801583c:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_DURATION, &value, 1) )
 8015840:	f10d 030f 	add.w	r3, sp, #15
 8015844:	9801      	ldr	r0, [sp, #4]
 8015846:	2133      	movs	r1, #51	; 0x33
 8015848:	461a      	mov	r2, r3
 801584a:	2301      	movs	r3, #1
 801584c:	f7fc fd48 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8015850:	4603      	mov	r3, r0
 8015852:	2b00      	cmp	r3, #0
 8015854:	d101      	bne.n	801585a <LSM303AGR_ACC_W_Int1_Duration+0x6a>
    return MEMS_ERROR;
 8015856:	2300      	movs	r3, #0
 8015858:	e000      	b.n	801585c <LSM303AGR_ACC_W_Int1_Duration+0x6c>

  return MEMS_SUCCESS;
 801585a:	2301      	movs	r3, #1
}
 801585c:	4618      	mov	r0, r3
 801585e:	b005      	add	sp, #20
 8015860:	f85d fb04 	ldr.w	pc, [sp], #4
 8015864:	f3af 8000 	nop.w
 8015868:	f3af 8000 	nop.w
 801586c:	f3af 8000 	nop.w

08015870 <LSM303AGR_ACC_R_Int1_Duration>:
* Input          : Pointer to u8_t
* Output         : Status of D
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_Duration(void *handle, u8_t *value)
{
 8015870:	b500      	push	{lr}
 8015872:	b083      	sub	sp, #12
 8015874:	9001      	str	r0, [sp, #4]
 8015876:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_DURATION, (u8_t *)value, 1) )
 8015878:	9801      	ldr	r0, [sp, #4]
 801587a:	2133      	movs	r1, #51	; 0x33
 801587c:	9a00      	ldr	r2, [sp, #0]
 801587e:	2301      	movs	r3, #1
 8015880:	f7fc fd4e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015884:	4603      	mov	r3, r0
 8015886:	2b00      	cmp	r3, #0
 8015888:	d101      	bne.n	801588e <LSM303AGR_ACC_R_Int1_Duration+0x1e>
    return MEMS_ERROR;
 801588a:	2300      	movs	r3, #0
 801588c:	e00b      	b.n	80158a6 <LSM303AGR_ACC_R_Int1_Duration+0x36>

  *value &= LSM303AGR_ACC_D_MASK; //coerce
 801588e:	9b00      	ldr	r3, [sp, #0]
 8015890:	781b      	ldrb	r3, [r3, #0]
 8015892:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8015896:	b2da      	uxtb	r2, r3
 8015898:	9b00      	ldr	r3, [sp, #0]
 801589a:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_D_POSITION; //mask
 801589c:	9b00      	ldr	r3, [sp, #0]
 801589e:	781a      	ldrb	r2, [r3, #0]
 80158a0:	9b00      	ldr	r3, [sp, #0]
 80158a2:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80158a4:	2301      	movs	r3, #1
}
 80158a6:	4618      	mov	r0, r3
 80158a8:	b003      	add	sp, #12
 80158aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80158ae:	bf00      	nop

080158b0 <LSM303AGR_ACC_W_Int2_Duration>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2_Duration(void *handle, u8_t newValue)
{
 80158b0:	b500      	push	{lr}
 80158b2:	b085      	sub	sp, #20
 80158b4:	9001      	str	r0, [sp, #4]
 80158b6:	460b      	mov	r3, r1
 80158b8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_D_POSITION; //mask
  newValue &= LSM303AGR_ACC_D_MASK; //coerce
 80158bc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80158c0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80158c4:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_DURATION, &value, 1) )
 80158c8:	f10d 030f 	add.w	r3, sp, #15
 80158cc:	9801      	ldr	r0, [sp, #4]
 80158ce:	2137      	movs	r1, #55	; 0x37
 80158d0:	461a      	mov	r2, r3
 80158d2:	2301      	movs	r3, #1
 80158d4:	f7fc fd24 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80158d8:	4603      	mov	r3, r0
 80158da:	2b00      	cmp	r3, #0
 80158dc:	d101      	bne.n	80158e2 <LSM303AGR_ACC_W_Int2_Duration+0x32>
    return MEMS_ERROR;
 80158de:	2300      	movs	r3, #0
 80158e0:	e01c      	b.n	801591c <LSM303AGR_ACC_W_Int2_Duration+0x6c>

  value &= ~LSM303AGR_ACC_D_MASK;
 80158e2:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80158e6:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80158ea:	b2db      	uxtb	r3, r3
 80158ec:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80158f0:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80158f4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80158f8:	4313      	orrs	r3, r2
 80158fa:	b2db      	uxtb	r3, r3
 80158fc:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_DURATION, &value, 1) )
 8015900:	f10d 030f 	add.w	r3, sp, #15
 8015904:	9801      	ldr	r0, [sp, #4]
 8015906:	2137      	movs	r1, #55	; 0x37
 8015908:	461a      	mov	r2, r3
 801590a:	2301      	movs	r3, #1
 801590c:	f7fc fce8 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8015910:	4603      	mov	r3, r0
 8015912:	2b00      	cmp	r3, #0
 8015914:	d101      	bne.n	801591a <LSM303AGR_ACC_W_Int2_Duration+0x6a>
    return MEMS_ERROR;
 8015916:	2300      	movs	r3, #0
 8015918:	e000      	b.n	801591c <LSM303AGR_ACC_W_Int2_Duration+0x6c>

  return MEMS_SUCCESS;
 801591a:	2301      	movs	r3, #1
}
 801591c:	4618      	mov	r0, r3
 801591e:	b005      	add	sp, #20
 8015920:	f85d fb04 	ldr.w	pc, [sp], #4
 8015924:	f3af 8000 	nop.w
 8015928:	f3af 8000 	nop.w
 801592c:	f3af 8000 	nop.w

08015930 <LSM303AGR_ACC_R_Int2_Duration>:
* Input          : Pointer to u8_t
* Output         : Status of D
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_Duration(void *handle, u8_t *value)
{
 8015930:	b500      	push	{lr}
 8015932:	b083      	sub	sp, #12
 8015934:	9001      	str	r0, [sp, #4]
 8015936:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_DURATION, (u8_t *)value, 1) )
 8015938:	9801      	ldr	r0, [sp, #4]
 801593a:	2137      	movs	r1, #55	; 0x37
 801593c:	9a00      	ldr	r2, [sp, #0]
 801593e:	2301      	movs	r3, #1
 8015940:	f7fc fcee 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015944:	4603      	mov	r3, r0
 8015946:	2b00      	cmp	r3, #0
 8015948:	d101      	bne.n	801594e <LSM303AGR_ACC_R_Int2_Duration+0x1e>
    return MEMS_ERROR;
 801594a:	2300      	movs	r3, #0
 801594c:	e00b      	b.n	8015966 <LSM303AGR_ACC_R_Int2_Duration+0x36>

  *value &= LSM303AGR_ACC_D_MASK; //coerce
 801594e:	9b00      	ldr	r3, [sp, #0]
 8015950:	781b      	ldrb	r3, [r3, #0]
 8015952:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8015956:	b2da      	uxtb	r2, r3
 8015958:	9b00      	ldr	r3, [sp, #0]
 801595a:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_D_POSITION; //mask
 801595c:	9b00      	ldr	r3, [sp, #0]
 801595e:	781a      	ldrb	r2, [r3, #0]
 8015960:	9b00      	ldr	r3, [sp, #0]
 8015962:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015964:	2301      	movs	r3, #1
}
 8015966:	4618      	mov	r0, r3
 8015968:	b003      	add	sp, #12
 801596a:	f85d fb04 	ldr.w	pc, [sp], #4
 801596e:	bf00      	nop

08015970 <LSM303AGR_ACC_W_XSingle>:
* Input          : LSM303AGR_ACC_XS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_XSingle(void *handle, LSM303AGR_ACC_XS_t newValue)
{
 8015970:	b500      	push	{lr}
 8015972:	b085      	sub	sp, #20
 8015974:	9001      	str	r0, [sp, #4]
 8015976:	460b      	mov	r3, r1
 8015978:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 801597c:	f10d 030f 	add.w	r3, sp, #15
 8015980:	9801      	ldr	r0, [sp, #4]
 8015982:	2138      	movs	r1, #56	; 0x38
 8015984:	461a      	mov	r2, r3
 8015986:	2301      	movs	r3, #1
 8015988:	f7fc fcca 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 801598c:	4603      	mov	r3, r0
 801598e:	2b00      	cmp	r3, #0
 8015990:	d101      	bne.n	8015996 <LSM303AGR_ACC_W_XSingle+0x26>
    return MEMS_ERROR;
 8015992:	2300      	movs	r3, #0
 8015994:	e01c      	b.n	80159d0 <LSM303AGR_ACC_W_XSingle+0x60>

  value &= ~LSM303AGR_ACC_XS_MASK;
 8015996:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801599a:	f023 0301 	bic.w	r3, r3, #1
 801599e:	b2db      	uxtb	r3, r3
 80159a0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80159a4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80159a8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80159ac:	4313      	orrs	r3, r2
 80159ae:	b2db      	uxtb	r3, r3
 80159b0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 80159b4:	f10d 030f 	add.w	r3, sp, #15
 80159b8:	9801      	ldr	r0, [sp, #4]
 80159ba:	2138      	movs	r1, #56	; 0x38
 80159bc:	461a      	mov	r2, r3
 80159be:	2301      	movs	r3, #1
 80159c0:	f7fc fc8e 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 80159c4:	4603      	mov	r3, r0
 80159c6:	2b00      	cmp	r3, #0
 80159c8:	d101      	bne.n	80159ce <LSM303AGR_ACC_W_XSingle+0x5e>
    return MEMS_ERROR;
 80159ca:	2300      	movs	r3, #0
 80159cc:	e000      	b.n	80159d0 <LSM303AGR_ACC_W_XSingle+0x60>

  return MEMS_SUCCESS;
 80159ce:	2301      	movs	r3, #1
}
 80159d0:	4618      	mov	r0, r3
 80159d2:	b005      	add	sp, #20
 80159d4:	f85d fb04 	ldr.w	pc, [sp], #4
 80159d8:	f3af 8000 	nop.w
 80159dc:	f3af 8000 	nop.w

080159e0 <LSM303AGR_ACC_R_XSingle>:
* Input          : Pointer to LSM303AGR_ACC_XS_t
* Output         : Status of XS see LSM303AGR_ACC_XS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XSingle(void *handle, LSM303AGR_ACC_XS_t *value)
{
 80159e0:	b500      	push	{lr}
 80159e2:	b083      	sub	sp, #12
 80159e4:	9001      	str	r0, [sp, #4]
 80159e6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, (u8_t *)value, 1) )
 80159e8:	9801      	ldr	r0, [sp, #4]
 80159ea:	2138      	movs	r1, #56	; 0x38
 80159ec:	9a00      	ldr	r2, [sp, #0]
 80159ee:	2301      	movs	r3, #1
 80159f0:	f7fc fc96 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80159f4:	4603      	mov	r3, r0
 80159f6:	2b00      	cmp	r3, #0
 80159f8:	d101      	bne.n	80159fe <LSM303AGR_ACC_R_XSingle+0x1e>
    return MEMS_ERROR;
 80159fa:	2300      	movs	r3, #0
 80159fc:	e007      	b.n	8015a0e <LSM303AGR_ACC_R_XSingle+0x2e>

  *value &= LSM303AGR_ACC_XS_MASK; //mask
 80159fe:	9b00      	ldr	r3, [sp, #0]
 8015a00:	781b      	ldrb	r3, [r3, #0]
 8015a02:	f003 0301 	and.w	r3, r3, #1
 8015a06:	b2da      	uxtb	r2, r3
 8015a08:	9b00      	ldr	r3, [sp, #0]
 8015a0a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015a0c:	2301      	movs	r3, #1
}
 8015a0e:	4618      	mov	r0, r3
 8015a10:	b003      	add	sp, #12
 8015a12:	f85d fb04 	ldr.w	pc, [sp], #4
 8015a16:	bf00      	nop
 8015a18:	f3af 8000 	nop.w
 8015a1c:	f3af 8000 	nop.w

08015a20 <LSM303AGR_ACC_W_XDouble>:
* Input          : LSM303AGR_ACC_XD_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_XDouble(void *handle, LSM303AGR_ACC_XD_t newValue)
{
 8015a20:	b500      	push	{lr}
 8015a22:	b085      	sub	sp, #20
 8015a24:	9001      	str	r0, [sp, #4]
 8015a26:	460b      	mov	r3, r1
 8015a28:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8015a2c:	f10d 030f 	add.w	r3, sp, #15
 8015a30:	9801      	ldr	r0, [sp, #4]
 8015a32:	2138      	movs	r1, #56	; 0x38
 8015a34:	461a      	mov	r2, r3
 8015a36:	2301      	movs	r3, #1
 8015a38:	f7fc fc72 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015a3c:	4603      	mov	r3, r0
 8015a3e:	2b00      	cmp	r3, #0
 8015a40:	d101      	bne.n	8015a46 <LSM303AGR_ACC_W_XDouble+0x26>
    return MEMS_ERROR;
 8015a42:	2300      	movs	r3, #0
 8015a44:	e01c      	b.n	8015a80 <LSM303AGR_ACC_W_XDouble+0x60>

  value &= ~LSM303AGR_ACC_XD_MASK;
 8015a46:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015a4a:	f023 0302 	bic.w	r3, r3, #2
 8015a4e:	b2db      	uxtb	r3, r3
 8015a50:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015a54:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015a58:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015a5c:	4313      	orrs	r3, r2
 8015a5e:	b2db      	uxtb	r3, r3
 8015a60:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8015a64:	f10d 030f 	add.w	r3, sp, #15
 8015a68:	9801      	ldr	r0, [sp, #4]
 8015a6a:	2138      	movs	r1, #56	; 0x38
 8015a6c:	461a      	mov	r2, r3
 8015a6e:	2301      	movs	r3, #1
 8015a70:	f7fc fc36 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8015a74:	4603      	mov	r3, r0
 8015a76:	2b00      	cmp	r3, #0
 8015a78:	d101      	bne.n	8015a7e <LSM303AGR_ACC_W_XDouble+0x5e>
    return MEMS_ERROR;
 8015a7a:	2300      	movs	r3, #0
 8015a7c:	e000      	b.n	8015a80 <LSM303AGR_ACC_W_XDouble+0x60>

  return MEMS_SUCCESS;
 8015a7e:	2301      	movs	r3, #1
}
 8015a80:	4618      	mov	r0, r3
 8015a82:	b005      	add	sp, #20
 8015a84:	f85d fb04 	ldr.w	pc, [sp], #4
 8015a88:	f3af 8000 	nop.w
 8015a8c:	f3af 8000 	nop.w

08015a90 <LSM303AGR_ACC_R_XDouble>:
* Input          : Pointer to LSM303AGR_ACC_XD_t
* Output         : Status of XD see LSM303AGR_ACC_XD_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XDouble(void *handle, LSM303AGR_ACC_XD_t *value)
{
 8015a90:	b500      	push	{lr}
 8015a92:	b083      	sub	sp, #12
 8015a94:	9001      	str	r0, [sp, #4]
 8015a96:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, (u8_t *)value, 1) )
 8015a98:	9801      	ldr	r0, [sp, #4]
 8015a9a:	2138      	movs	r1, #56	; 0x38
 8015a9c:	9a00      	ldr	r2, [sp, #0]
 8015a9e:	2301      	movs	r3, #1
 8015aa0:	f7fc fc3e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015aa4:	4603      	mov	r3, r0
 8015aa6:	2b00      	cmp	r3, #0
 8015aa8:	d101      	bne.n	8015aae <LSM303AGR_ACC_R_XDouble+0x1e>
    return MEMS_ERROR;
 8015aaa:	2300      	movs	r3, #0
 8015aac:	e007      	b.n	8015abe <LSM303AGR_ACC_R_XDouble+0x2e>

  *value &= LSM303AGR_ACC_XD_MASK; //mask
 8015aae:	9b00      	ldr	r3, [sp, #0]
 8015ab0:	781b      	ldrb	r3, [r3, #0]
 8015ab2:	f003 0302 	and.w	r3, r3, #2
 8015ab6:	b2da      	uxtb	r2, r3
 8015ab8:	9b00      	ldr	r3, [sp, #0]
 8015aba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015abc:	2301      	movs	r3, #1
}
 8015abe:	4618      	mov	r0, r3
 8015ac0:	b003      	add	sp, #12
 8015ac2:	f85d fb04 	ldr.w	pc, [sp], #4
 8015ac6:	bf00      	nop
 8015ac8:	f3af 8000 	nop.w
 8015acc:	f3af 8000 	nop.w

08015ad0 <LSM303AGR_ACC_W_YSingle>:
* Input          : LSM303AGR_ACC_YS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_YSingle(void *handle, LSM303AGR_ACC_YS_t newValue)
{
 8015ad0:	b500      	push	{lr}
 8015ad2:	b085      	sub	sp, #20
 8015ad4:	9001      	str	r0, [sp, #4]
 8015ad6:	460b      	mov	r3, r1
 8015ad8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8015adc:	f10d 030f 	add.w	r3, sp, #15
 8015ae0:	9801      	ldr	r0, [sp, #4]
 8015ae2:	2138      	movs	r1, #56	; 0x38
 8015ae4:	461a      	mov	r2, r3
 8015ae6:	2301      	movs	r3, #1
 8015ae8:	f7fc fc1a 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015aec:	4603      	mov	r3, r0
 8015aee:	2b00      	cmp	r3, #0
 8015af0:	d101      	bne.n	8015af6 <LSM303AGR_ACC_W_YSingle+0x26>
    return MEMS_ERROR;
 8015af2:	2300      	movs	r3, #0
 8015af4:	e01c      	b.n	8015b30 <LSM303AGR_ACC_W_YSingle+0x60>

  value &= ~LSM303AGR_ACC_YS_MASK;
 8015af6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015afa:	f023 0304 	bic.w	r3, r3, #4
 8015afe:	b2db      	uxtb	r3, r3
 8015b00:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015b04:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015b08:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015b0c:	4313      	orrs	r3, r2
 8015b0e:	b2db      	uxtb	r3, r3
 8015b10:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8015b14:	f10d 030f 	add.w	r3, sp, #15
 8015b18:	9801      	ldr	r0, [sp, #4]
 8015b1a:	2138      	movs	r1, #56	; 0x38
 8015b1c:	461a      	mov	r2, r3
 8015b1e:	2301      	movs	r3, #1
 8015b20:	f7fc fbde 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8015b24:	4603      	mov	r3, r0
 8015b26:	2b00      	cmp	r3, #0
 8015b28:	d101      	bne.n	8015b2e <LSM303AGR_ACC_W_YSingle+0x5e>
    return MEMS_ERROR;
 8015b2a:	2300      	movs	r3, #0
 8015b2c:	e000      	b.n	8015b30 <LSM303AGR_ACC_W_YSingle+0x60>

  return MEMS_SUCCESS;
 8015b2e:	2301      	movs	r3, #1
}
 8015b30:	4618      	mov	r0, r3
 8015b32:	b005      	add	sp, #20
 8015b34:	f85d fb04 	ldr.w	pc, [sp], #4
 8015b38:	f3af 8000 	nop.w
 8015b3c:	f3af 8000 	nop.w

08015b40 <LSM303AGR_ACC_R_YSingle>:
* Input          : Pointer to LSM303AGR_ACC_YS_t
* Output         : Status of YS see LSM303AGR_ACC_YS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_YSingle(void *handle, LSM303AGR_ACC_YS_t *value)
{
 8015b40:	b500      	push	{lr}
 8015b42:	b083      	sub	sp, #12
 8015b44:	9001      	str	r0, [sp, #4]
 8015b46:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, (u8_t *)value, 1) )
 8015b48:	9801      	ldr	r0, [sp, #4]
 8015b4a:	2138      	movs	r1, #56	; 0x38
 8015b4c:	9a00      	ldr	r2, [sp, #0]
 8015b4e:	2301      	movs	r3, #1
 8015b50:	f7fc fbe6 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015b54:	4603      	mov	r3, r0
 8015b56:	2b00      	cmp	r3, #0
 8015b58:	d101      	bne.n	8015b5e <LSM303AGR_ACC_R_YSingle+0x1e>
    return MEMS_ERROR;
 8015b5a:	2300      	movs	r3, #0
 8015b5c:	e007      	b.n	8015b6e <LSM303AGR_ACC_R_YSingle+0x2e>

  *value &= LSM303AGR_ACC_YS_MASK; //mask
 8015b5e:	9b00      	ldr	r3, [sp, #0]
 8015b60:	781b      	ldrb	r3, [r3, #0]
 8015b62:	f003 0304 	and.w	r3, r3, #4
 8015b66:	b2da      	uxtb	r2, r3
 8015b68:	9b00      	ldr	r3, [sp, #0]
 8015b6a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015b6c:	2301      	movs	r3, #1
}
 8015b6e:	4618      	mov	r0, r3
 8015b70:	b003      	add	sp, #12
 8015b72:	f85d fb04 	ldr.w	pc, [sp], #4
 8015b76:	bf00      	nop
 8015b78:	f3af 8000 	nop.w
 8015b7c:	f3af 8000 	nop.w

08015b80 <LSM303AGR_ACC_W_YDouble>:
* Input          : LSM303AGR_ACC_YD_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_YDouble(void *handle, LSM303AGR_ACC_YD_t newValue)
{
 8015b80:	b500      	push	{lr}
 8015b82:	b085      	sub	sp, #20
 8015b84:	9001      	str	r0, [sp, #4]
 8015b86:	460b      	mov	r3, r1
 8015b88:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8015b8c:	f10d 030f 	add.w	r3, sp, #15
 8015b90:	9801      	ldr	r0, [sp, #4]
 8015b92:	2138      	movs	r1, #56	; 0x38
 8015b94:	461a      	mov	r2, r3
 8015b96:	2301      	movs	r3, #1
 8015b98:	f7fc fbc2 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015b9c:	4603      	mov	r3, r0
 8015b9e:	2b00      	cmp	r3, #0
 8015ba0:	d101      	bne.n	8015ba6 <LSM303AGR_ACC_W_YDouble+0x26>
    return MEMS_ERROR;
 8015ba2:	2300      	movs	r3, #0
 8015ba4:	e01c      	b.n	8015be0 <LSM303AGR_ACC_W_YDouble+0x60>

  value &= ~LSM303AGR_ACC_YD_MASK;
 8015ba6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015baa:	f023 0308 	bic.w	r3, r3, #8
 8015bae:	b2db      	uxtb	r3, r3
 8015bb0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015bb4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015bb8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015bbc:	4313      	orrs	r3, r2
 8015bbe:	b2db      	uxtb	r3, r3
 8015bc0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8015bc4:	f10d 030f 	add.w	r3, sp, #15
 8015bc8:	9801      	ldr	r0, [sp, #4]
 8015bca:	2138      	movs	r1, #56	; 0x38
 8015bcc:	461a      	mov	r2, r3
 8015bce:	2301      	movs	r3, #1
 8015bd0:	f7fc fb86 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8015bd4:	4603      	mov	r3, r0
 8015bd6:	2b00      	cmp	r3, #0
 8015bd8:	d101      	bne.n	8015bde <LSM303AGR_ACC_W_YDouble+0x5e>
    return MEMS_ERROR;
 8015bda:	2300      	movs	r3, #0
 8015bdc:	e000      	b.n	8015be0 <LSM303AGR_ACC_W_YDouble+0x60>

  return MEMS_SUCCESS;
 8015bde:	2301      	movs	r3, #1
}
 8015be0:	4618      	mov	r0, r3
 8015be2:	b005      	add	sp, #20
 8015be4:	f85d fb04 	ldr.w	pc, [sp], #4
 8015be8:	f3af 8000 	nop.w
 8015bec:	f3af 8000 	nop.w

08015bf0 <LSM303AGR_ACC_R_YDouble>:
* Input          : Pointer to LSM303AGR_ACC_YD_t
* Output         : Status of YD see LSM303AGR_ACC_YD_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_YDouble(void *handle, LSM303AGR_ACC_YD_t *value)
{
 8015bf0:	b500      	push	{lr}
 8015bf2:	b083      	sub	sp, #12
 8015bf4:	9001      	str	r0, [sp, #4]
 8015bf6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, (u8_t *)value, 1) )
 8015bf8:	9801      	ldr	r0, [sp, #4]
 8015bfa:	2138      	movs	r1, #56	; 0x38
 8015bfc:	9a00      	ldr	r2, [sp, #0]
 8015bfe:	2301      	movs	r3, #1
 8015c00:	f7fc fb8e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015c04:	4603      	mov	r3, r0
 8015c06:	2b00      	cmp	r3, #0
 8015c08:	d101      	bne.n	8015c0e <LSM303AGR_ACC_R_YDouble+0x1e>
    return MEMS_ERROR;
 8015c0a:	2300      	movs	r3, #0
 8015c0c:	e007      	b.n	8015c1e <LSM303AGR_ACC_R_YDouble+0x2e>

  *value &= LSM303AGR_ACC_YD_MASK; //mask
 8015c0e:	9b00      	ldr	r3, [sp, #0]
 8015c10:	781b      	ldrb	r3, [r3, #0]
 8015c12:	f003 0308 	and.w	r3, r3, #8
 8015c16:	b2da      	uxtb	r2, r3
 8015c18:	9b00      	ldr	r3, [sp, #0]
 8015c1a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015c1c:	2301      	movs	r3, #1
}
 8015c1e:	4618      	mov	r0, r3
 8015c20:	b003      	add	sp, #12
 8015c22:	f85d fb04 	ldr.w	pc, [sp], #4
 8015c26:	bf00      	nop
 8015c28:	f3af 8000 	nop.w
 8015c2c:	f3af 8000 	nop.w

08015c30 <LSM303AGR_ACC_W_ZSingle>:
* Input          : LSM303AGR_ACC_ZS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ZSingle(void *handle, LSM303AGR_ACC_ZS_t newValue)
{
 8015c30:	b500      	push	{lr}
 8015c32:	b085      	sub	sp, #20
 8015c34:	9001      	str	r0, [sp, #4]
 8015c36:	460b      	mov	r3, r1
 8015c38:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8015c3c:	f10d 030f 	add.w	r3, sp, #15
 8015c40:	9801      	ldr	r0, [sp, #4]
 8015c42:	2138      	movs	r1, #56	; 0x38
 8015c44:	461a      	mov	r2, r3
 8015c46:	2301      	movs	r3, #1
 8015c48:	f7fc fb6a 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015c4c:	4603      	mov	r3, r0
 8015c4e:	2b00      	cmp	r3, #0
 8015c50:	d101      	bne.n	8015c56 <LSM303AGR_ACC_W_ZSingle+0x26>
    return MEMS_ERROR;
 8015c52:	2300      	movs	r3, #0
 8015c54:	e01c      	b.n	8015c90 <LSM303AGR_ACC_W_ZSingle+0x60>

  value &= ~LSM303AGR_ACC_ZS_MASK;
 8015c56:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015c5a:	f023 0310 	bic.w	r3, r3, #16
 8015c5e:	b2db      	uxtb	r3, r3
 8015c60:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015c64:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015c68:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015c6c:	4313      	orrs	r3, r2
 8015c6e:	b2db      	uxtb	r3, r3
 8015c70:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8015c74:	f10d 030f 	add.w	r3, sp, #15
 8015c78:	9801      	ldr	r0, [sp, #4]
 8015c7a:	2138      	movs	r1, #56	; 0x38
 8015c7c:	461a      	mov	r2, r3
 8015c7e:	2301      	movs	r3, #1
 8015c80:	f7fc fb2e 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8015c84:	4603      	mov	r3, r0
 8015c86:	2b00      	cmp	r3, #0
 8015c88:	d101      	bne.n	8015c8e <LSM303AGR_ACC_W_ZSingle+0x5e>
    return MEMS_ERROR;
 8015c8a:	2300      	movs	r3, #0
 8015c8c:	e000      	b.n	8015c90 <LSM303AGR_ACC_W_ZSingle+0x60>

  return MEMS_SUCCESS;
 8015c8e:	2301      	movs	r3, #1
}
 8015c90:	4618      	mov	r0, r3
 8015c92:	b005      	add	sp, #20
 8015c94:	f85d fb04 	ldr.w	pc, [sp], #4
 8015c98:	f3af 8000 	nop.w
 8015c9c:	f3af 8000 	nop.w

08015ca0 <LSM303AGR_ACC_R_ZSingle>:
* Input          : Pointer to LSM303AGR_ACC_ZS_t
* Output         : Status of ZS see LSM303AGR_ACC_ZS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ZSingle(void *handle, LSM303AGR_ACC_ZS_t *value)
{
 8015ca0:	b500      	push	{lr}
 8015ca2:	b083      	sub	sp, #12
 8015ca4:	9001      	str	r0, [sp, #4]
 8015ca6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, (u8_t *)value, 1) )
 8015ca8:	9801      	ldr	r0, [sp, #4]
 8015caa:	2138      	movs	r1, #56	; 0x38
 8015cac:	9a00      	ldr	r2, [sp, #0]
 8015cae:	2301      	movs	r3, #1
 8015cb0:	f7fc fb36 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015cb4:	4603      	mov	r3, r0
 8015cb6:	2b00      	cmp	r3, #0
 8015cb8:	d101      	bne.n	8015cbe <LSM303AGR_ACC_R_ZSingle+0x1e>
    return MEMS_ERROR;
 8015cba:	2300      	movs	r3, #0
 8015cbc:	e007      	b.n	8015cce <LSM303AGR_ACC_R_ZSingle+0x2e>

  *value &= LSM303AGR_ACC_ZS_MASK; //mask
 8015cbe:	9b00      	ldr	r3, [sp, #0]
 8015cc0:	781b      	ldrb	r3, [r3, #0]
 8015cc2:	f003 0310 	and.w	r3, r3, #16
 8015cc6:	b2da      	uxtb	r2, r3
 8015cc8:	9b00      	ldr	r3, [sp, #0]
 8015cca:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015ccc:	2301      	movs	r3, #1
}
 8015cce:	4618      	mov	r0, r3
 8015cd0:	b003      	add	sp, #12
 8015cd2:	f85d fb04 	ldr.w	pc, [sp], #4
 8015cd6:	bf00      	nop
 8015cd8:	f3af 8000 	nop.w
 8015cdc:	f3af 8000 	nop.w

08015ce0 <LSM303AGR_ACC_W_ZDouble>:
* Input          : LSM303AGR_ACC_ZD_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ZDouble(void *handle, LSM303AGR_ACC_ZD_t newValue)
{
 8015ce0:	b500      	push	{lr}
 8015ce2:	b085      	sub	sp, #20
 8015ce4:	9001      	str	r0, [sp, #4]
 8015ce6:	460b      	mov	r3, r1
 8015ce8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8015cec:	f10d 030f 	add.w	r3, sp, #15
 8015cf0:	9801      	ldr	r0, [sp, #4]
 8015cf2:	2138      	movs	r1, #56	; 0x38
 8015cf4:	461a      	mov	r2, r3
 8015cf6:	2301      	movs	r3, #1
 8015cf8:	f7fc fb12 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015cfc:	4603      	mov	r3, r0
 8015cfe:	2b00      	cmp	r3, #0
 8015d00:	d101      	bne.n	8015d06 <LSM303AGR_ACC_W_ZDouble+0x26>
    return MEMS_ERROR;
 8015d02:	2300      	movs	r3, #0
 8015d04:	e01c      	b.n	8015d40 <LSM303AGR_ACC_W_ZDouble+0x60>

  value &= ~LSM303AGR_ACC_ZD_MASK;
 8015d06:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015d0a:	f023 0320 	bic.w	r3, r3, #32
 8015d0e:	b2db      	uxtb	r3, r3
 8015d10:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015d14:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015d18:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015d1c:	4313      	orrs	r3, r2
 8015d1e:	b2db      	uxtb	r3, r3
 8015d20:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8015d24:	f10d 030f 	add.w	r3, sp, #15
 8015d28:	9801      	ldr	r0, [sp, #4]
 8015d2a:	2138      	movs	r1, #56	; 0x38
 8015d2c:	461a      	mov	r2, r3
 8015d2e:	2301      	movs	r3, #1
 8015d30:	f7fc fad6 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8015d34:	4603      	mov	r3, r0
 8015d36:	2b00      	cmp	r3, #0
 8015d38:	d101      	bne.n	8015d3e <LSM303AGR_ACC_W_ZDouble+0x5e>
    return MEMS_ERROR;
 8015d3a:	2300      	movs	r3, #0
 8015d3c:	e000      	b.n	8015d40 <LSM303AGR_ACC_W_ZDouble+0x60>

  return MEMS_SUCCESS;
 8015d3e:	2301      	movs	r3, #1
}
 8015d40:	4618      	mov	r0, r3
 8015d42:	b005      	add	sp, #20
 8015d44:	f85d fb04 	ldr.w	pc, [sp], #4
 8015d48:	f3af 8000 	nop.w
 8015d4c:	f3af 8000 	nop.w

08015d50 <LSM303AGR_ACC_R_ZDouble>:
* Input          : Pointer to LSM303AGR_ACC_ZD_t
* Output         : Status of ZD see LSM303AGR_ACC_ZD_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ZDouble(void *handle, LSM303AGR_ACC_ZD_t *value)
{
 8015d50:	b500      	push	{lr}
 8015d52:	b083      	sub	sp, #12
 8015d54:	9001      	str	r0, [sp, #4]
 8015d56:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, (u8_t *)value, 1) )
 8015d58:	9801      	ldr	r0, [sp, #4]
 8015d5a:	2138      	movs	r1, #56	; 0x38
 8015d5c:	9a00      	ldr	r2, [sp, #0]
 8015d5e:	2301      	movs	r3, #1
 8015d60:	f7fc fade 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015d64:	4603      	mov	r3, r0
 8015d66:	2b00      	cmp	r3, #0
 8015d68:	d101      	bne.n	8015d6e <LSM303AGR_ACC_R_ZDouble+0x1e>
    return MEMS_ERROR;
 8015d6a:	2300      	movs	r3, #0
 8015d6c:	e007      	b.n	8015d7e <LSM303AGR_ACC_R_ZDouble+0x2e>

  *value &= LSM303AGR_ACC_ZD_MASK; //mask
 8015d6e:	9b00      	ldr	r3, [sp, #0]
 8015d70:	781b      	ldrb	r3, [r3, #0]
 8015d72:	f003 0320 	and.w	r3, r3, #32
 8015d76:	b2da      	uxtb	r2, r3
 8015d78:	9b00      	ldr	r3, [sp, #0]
 8015d7a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015d7c:	2301      	movs	r3, #1
}
 8015d7e:	4618      	mov	r0, r3
 8015d80:	b003      	add	sp, #12
 8015d82:	f85d fb04 	ldr.w	pc, [sp], #4
 8015d86:	bf00      	nop
 8015d88:	f3af 8000 	nop.w
 8015d8c:	f3af 8000 	nop.w

08015d90 <LSM303AGR_ACC_R_ClickX>:
* Input          : Pointer to LSM303AGR_ACC_X_t
* Output         : Status of X see LSM303AGR_ACC_X_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickX(void *handle, LSM303AGR_ACC_X_t *value)
{
 8015d90:	b500      	push	{lr}
 8015d92:	b083      	sub	sp, #12
 8015d94:	9001      	str	r0, [sp, #4]
 8015d96:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 8015d98:	9801      	ldr	r0, [sp, #4]
 8015d9a:	2139      	movs	r1, #57	; 0x39
 8015d9c:	9a00      	ldr	r2, [sp, #0]
 8015d9e:	2301      	movs	r3, #1
 8015da0:	f7fc fabe 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015da4:	4603      	mov	r3, r0
 8015da6:	2b00      	cmp	r3, #0
 8015da8:	d101      	bne.n	8015dae <LSM303AGR_ACC_R_ClickX+0x1e>
    return MEMS_ERROR;
 8015daa:	2300      	movs	r3, #0
 8015dac:	e007      	b.n	8015dbe <LSM303AGR_ACC_R_ClickX+0x2e>

  *value &= LSM303AGR_ACC_X_MASK; //mask
 8015dae:	9b00      	ldr	r3, [sp, #0]
 8015db0:	781b      	ldrb	r3, [r3, #0]
 8015db2:	f003 0301 	and.w	r3, r3, #1
 8015db6:	b2da      	uxtb	r2, r3
 8015db8:	9b00      	ldr	r3, [sp, #0]
 8015dba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015dbc:	2301      	movs	r3, #1
}
 8015dbe:	4618      	mov	r0, r3
 8015dc0:	b003      	add	sp, #12
 8015dc2:	f85d fb04 	ldr.w	pc, [sp], #4
 8015dc6:	bf00      	nop
 8015dc8:	f3af 8000 	nop.w
 8015dcc:	f3af 8000 	nop.w

08015dd0 <LSM303AGR_ACC_R_ClickY>:
* Input          : Pointer to LSM303AGR_ACC_Y_t
* Output         : Status of Y see LSM303AGR_ACC_Y_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickY(void *handle, LSM303AGR_ACC_Y_t *value)
{
 8015dd0:	b500      	push	{lr}
 8015dd2:	b083      	sub	sp, #12
 8015dd4:	9001      	str	r0, [sp, #4]
 8015dd6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 8015dd8:	9801      	ldr	r0, [sp, #4]
 8015dda:	2139      	movs	r1, #57	; 0x39
 8015ddc:	9a00      	ldr	r2, [sp, #0]
 8015dde:	2301      	movs	r3, #1
 8015de0:	f7fc fa9e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015de4:	4603      	mov	r3, r0
 8015de6:	2b00      	cmp	r3, #0
 8015de8:	d101      	bne.n	8015dee <LSM303AGR_ACC_R_ClickY+0x1e>
    return MEMS_ERROR;
 8015dea:	2300      	movs	r3, #0
 8015dec:	e007      	b.n	8015dfe <LSM303AGR_ACC_R_ClickY+0x2e>

  *value &= LSM303AGR_ACC_Y_MASK; //mask
 8015dee:	9b00      	ldr	r3, [sp, #0]
 8015df0:	781b      	ldrb	r3, [r3, #0]
 8015df2:	f003 0302 	and.w	r3, r3, #2
 8015df6:	b2da      	uxtb	r2, r3
 8015df8:	9b00      	ldr	r3, [sp, #0]
 8015dfa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015dfc:	2301      	movs	r3, #1
}
 8015dfe:	4618      	mov	r0, r3
 8015e00:	b003      	add	sp, #12
 8015e02:	f85d fb04 	ldr.w	pc, [sp], #4
 8015e06:	bf00      	nop
 8015e08:	f3af 8000 	nop.w
 8015e0c:	f3af 8000 	nop.w

08015e10 <LSM303AGR_ACC_R_ClickZ>:
* Input          : Pointer to LSM303AGR_ACC_Z_t
* Output         : Status of Z see LSM303AGR_ACC_Z_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickZ(void *handle, LSM303AGR_ACC_Z_t *value)
{
 8015e10:	b500      	push	{lr}
 8015e12:	b083      	sub	sp, #12
 8015e14:	9001      	str	r0, [sp, #4]
 8015e16:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 8015e18:	9801      	ldr	r0, [sp, #4]
 8015e1a:	2139      	movs	r1, #57	; 0x39
 8015e1c:	9a00      	ldr	r2, [sp, #0]
 8015e1e:	2301      	movs	r3, #1
 8015e20:	f7fc fa7e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015e24:	4603      	mov	r3, r0
 8015e26:	2b00      	cmp	r3, #0
 8015e28:	d101      	bne.n	8015e2e <LSM303AGR_ACC_R_ClickZ+0x1e>
    return MEMS_ERROR;
 8015e2a:	2300      	movs	r3, #0
 8015e2c:	e007      	b.n	8015e3e <LSM303AGR_ACC_R_ClickZ+0x2e>

  *value &= LSM303AGR_ACC_Z_MASK; //mask
 8015e2e:	9b00      	ldr	r3, [sp, #0]
 8015e30:	781b      	ldrb	r3, [r3, #0]
 8015e32:	f003 0304 	and.w	r3, r3, #4
 8015e36:	b2da      	uxtb	r2, r3
 8015e38:	9b00      	ldr	r3, [sp, #0]
 8015e3a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015e3c:	2301      	movs	r3, #1
}
 8015e3e:	4618      	mov	r0, r3
 8015e40:	b003      	add	sp, #12
 8015e42:	f85d fb04 	ldr.w	pc, [sp], #4
 8015e46:	bf00      	nop
 8015e48:	f3af 8000 	nop.w
 8015e4c:	f3af 8000 	nop.w

08015e50 <LSM303AGR_ACC_R_ClickSign>:
* Input          : Pointer to LSM303AGR_ACC_SIGN_t
* Output         : Status of SIGN see LSM303AGR_ACC_SIGN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickSign(void *handle, LSM303AGR_ACC_SIGN_t *value)
{
 8015e50:	b500      	push	{lr}
 8015e52:	b083      	sub	sp, #12
 8015e54:	9001      	str	r0, [sp, #4]
 8015e56:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 8015e58:	9801      	ldr	r0, [sp, #4]
 8015e5a:	2139      	movs	r1, #57	; 0x39
 8015e5c:	9a00      	ldr	r2, [sp, #0]
 8015e5e:	2301      	movs	r3, #1
 8015e60:	f7fc fa5e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015e64:	4603      	mov	r3, r0
 8015e66:	2b00      	cmp	r3, #0
 8015e68:	d101      	bne.n	8015e6e <LSM303AGR_ACC_R_ClickSign+0x1e>
    return MEMS_ERROR;
 8015e6a:	2300      	movs	r3, #0
 8015e6c:	e007      	b.n	8015e7e <LSM303AGR_ACC_R_ClickSign+0x2e>

  *value &= LSM303AGR_ACC_SIGN_MASK; //mask
 8015e6e:	9b00      	ldr	r3, [sp, #0]
 8015e70:	781b      	ldrb	r3, [r3, #0]
 8015e72:	f003 0308 	and.w	r3, r3, #8
 8015e76:	b2da      	uxtb	r2, r3
 8015e78:	9b00      	ldr	r3, [sp, #0]
 8015e7a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015e7c:	2301      	movs	r3, #1
}
 8015e7e:	4618      	mov	r0, r3
 8015e80:	b003      	add	sp, #12
 8015e82:	f85d fb04 	ldr.w	pc, [sp], #4
 8015e86:	bf00      	nop
 8015e88:	f3af 8000 	nop.w
 8015e8c:	f3af 8000 	nop.w

08015e90 <LSM303AGR_ACC_R_SingleCLICK>:
* Input          : Pointer to LSM303AGR_ACC_SCLICK_t
* Output         : Status of SCLICK see LSM303AGR_ACC_SCLICK_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_SingleCLICK(void *handle, LSM303AGR_ACC_SCLICK_t *value)
{
 8015e90:	b500      	push	{lr}
 8015e92:	b083      	sub	sp, #12
 8015e94:	9001      	str	r0, [sp, #4]
 8015e96:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 8015e98:	9801      	ldr	r0, [sp, #4]
 8015e9a:	2139      	movs	r1, #57	; 0x39
 8015e9c:	9a00      	ldr	r2, [sp, #0]
 8015e9e:	2301      	movs	r3, #1
 8015ea0:	f7fc fa3e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015ea4:	4603      	mov	r3, r0
 8015ea6:	2b00      	cmp	r3, #0
 8015ea8:	d101      	bne.n	8015eae <LSM303AGR_ACC_R_SingleCLICK+0x1e>
    return MEMS_ERROR;
 8015eaa:	2300      	movs	r3, #0
 8015eac:	e007      	b.n	8015ebe <LSM303AGR_ACC_R_SingleCLICK+0x2e>

  *value &= LSM303AGR_ACC_SCLICK_MASK; //mask
 8015eae:	9b00      	ldr	r3, [sp, #0]
 8015eb0:	781b      	ldrb	r3, [r3, #0]
 8015eb2:	f003 0310 	and.w	r3, r3, #16
 8015eb6:	b2da      	uxtb	r2, r3
 8015eb8:	9b00      	ldr	r3, [sp, #0]
 8015eba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015ebc:	2301      	movs	r3, #1
}
 8015ebe:	4618      	mov	r0, r3
 8015ec0:	b003      	add	sp, #12
 8015ec2:	f85d fb04 	ldr.w	pc, [sp], #4
 8015ec6:	bf00      	nop
 8015ec8:	f3af 8000 	nop.w
 8015ecc:	f3af 8000 	nop.w

08015ed0 <LSM303AGR_ACC_R_DoubleCLICK>:
* Input          : Pointer to LSM303AGR_ACC_DCLICK_t
* Output         : Status of DCLICK see LSM303AGR_ACC_DCLICK_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_DoubleCLICK(void *handle, LSM303AGR_ACC_DCLICK_t *value)
{
 8015ed0:	b500      	push	{lr}
 8015ed2:	b083      	sub	sp, #12
 8015ed4:	9001      	str	r0, [sp, #4]
 8015ed6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 8015ed8:	9801      	ldr	r0, [sp, #4]
 8015eda:	2139      	movs	r1, #57	; 0x39
 8015edc:	9a00      	ldr	r2, [sp, #0]
 8015ede:	2301      	movs	r3, #1
 8015ee0:	f7fc fa1e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015ee4:	4603      	mov	r3, r0
 8015ee6:	2b00      	cmp	r3, #0
 8015ee8:	d101      	bne.n	8015eee <LSM303AGR_ACC_R_DoubleCLICK+0x1e>
    return MEMS_ERROR;
 8015eea:	2300      	movs	r3, #0
 8015eec:	e007      	b.n	8015efe <LSM303AGR_ACC_R_DoubleCLICK+0x2e>

  *value &= LSM303AGR_ACC_DCLICK_MASK; //mask
 8015eee:	9b00      	ldr	r3, [sp, #0]
 8015ef0:	781b      	ldrb	r3, [r3, #0]
 8015ef2:	f003 0320 	and.w	r3, r3, #32
 8015ef6:	b2da      	uxtb	r2, r3
 8015ef8:	9b00      	ldr	r3, [sp, #0]
 8015efa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015efc:	2301      	movs	r3, #1
}
 8015efe:	4618      	mov	r0, r3
 8015f00:	b003      	add	sp, #12
 8015f02:	f85d fb04 	ldr.w	pc, [sp], #4
 8015f06:	bf00      	nop
 8015f08:	f3af 8000 	nop.w
 8015f0c:	f3af 8000 	nop.w

08015f10 <LSM303AGR_ACC_R_CLICK_IA>:
* Input          : Pointer to LSM303AGR_ACC_IA_t
* Output         : Status of IA see LSM303AGR_ACC_IA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_CLICK_IA(void *handle, LSM303AGR_ACC_CLICK_IA_t *value)
{
 8015f10:	b500      	push	{lr}
 8015f12:	b083      	sub	sp, #12
 8015f14:	9001      	str	r0, [sp, #4]
 8015f16:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 8015f18:	9801      	ldr	r0, [sp, #4]
 8015f1a:	2139      	movs	r1, #57	; 0x39
 8015f1c:	9a00      	ldr	r2, [sp, #0]
 8015f1e:	2301      	movs	r3, #1
 8015f20:	f7fc f9fe 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015f24:	4603      	mov	r3, r0
 8015f26:	2b00      	cmp	r3, #0
 8015f28:	d101      	bne.n	8015f2e <LSM303AGR_ACC_R_CLICK_IA+0x1e>
    return MEMS_ERROR;
 8015f2a:	2300      	movs	r3, #0
 8015f2c:	e007      	b.n	8015f3e <LSM303AGR_ACC_R_CLICK_IA+0x2e>

  *value &= LSM303AGR_ACC_IA_MASK; //mask
 8015f2e:	9b00      	ldr	r3, [sp, #0]
 8015f30:	781b      	ldrb	r3, [r3, #0]
 8015f32:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8015f36:	b2da      	uxtb	r2, r3
 8015f38:	9b00      	ldr	r3, [sp, #0]
 8015f3a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015f3c:	2301      	movs	r3, #1
}
 8015f3e:	4618      	mov	r0, r3
 8015f40:	b003      	add	sp, #12
 8015f42:	f85d fb04 	ldr.w	pc, [sp], #4
 8015f46:	bf00      	nop
 8015f48:	f3af 8000 	nop.w
 8015f4c:	f3af 8000 	nop.w

08015f50 <LSM303AGR_ACC_W_ClickThreshold>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ClickThreshold(void *handle, u8_t newValue)
{
 8015f50:	b500      	push	{lr}
 8015f52:	b085      	sub	sp, #20
 8015f54:	9001      	str	r0, [sp, #4]
 8015f56:	460b      	mov	r3, r1
 8015f58:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_THS_POSITION; //mask
  newValue &= LSM303AGR_ACC_THS_MASK; //coerce
 8015f5c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015f60:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8015f64:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_THS, &value, 1) )
 8015f68:	f10d 030f 	add.w	r3, sp, #15
 8015f6c:	9801      	ldr	r0, [sp, #4]
 8015f6e:	213a      	movs	r1, #58	; 0x3a
 8015f70:	461a      	mov	r2, r3
 8015f72:	2301      	movs	r3, #1
 8015f74:	f7fc f9d4 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015f78:	4603      	mov	r3, r0
 8015f7a:	2b00      	cmp	r3, #0
 8015f7c:	d101      	bne.n	8015f82 <LSM303AGR_ACC_W_ClickThreshold+0x32>
    return MEMS_ERROR;
 8015f7e:	2300      	movs	r3, #0
 8015f80:	e01c      	b.n	8015fbc <LSM303AGR_ACC_W_ClickThreshold+0x6c>

  value &= ~LSM303AGR_ACC_THS_MASK;
 8015f82:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015f86:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8015f8a:	b2db      	uxtb	r3, r3
 8015f8c:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015f90:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015f94:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015f98:	4313      	orrs	r3, r2
 8015f9a:	b2db      	uxtb	r3, r3
 8015f9c:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_THS, &value, 1) )
 8015fa0:	f10d 030f 	add.w	r3, sp, #15
 8015fa4:	9801      	ldr	r0, [sp, #4]
 8015fa6:	213a      	movs	r1, #58	; 0x3a
 8015fa8:	461a      	mov	r2, r3
 8015faa:	2301      	movs	r3, #1
 8015fac:	f7fc f998 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8015fb0:	4603      	mov	r3, r0
 8015fb2:	2b00      	cmp	r3, #0
 8015fb4:	d101      	bne.n	8015fba <LSM303AGR_ACC_W_ClickThreshold+0x6a>
    return MEMS_ERROR;
 8015fb6:	2300      	movs	r3, #0
 8015fb8:	e000      	b.n	8015fbc <LSM303AGR_ACC_W_ClickThreshold+0x6c>

  return MEMS_SUCCESS;
 8015fba:	2301      	movs	r3, #1
}
 8015fbc:	4618      	mov	r0, r3
 8015fbe:	b005      	add	sp, #20
 8015fc0:	f85d fb04 	ldr.w	pc, [sp], #4
 8015fc4:	f3af 8000 	nop.w
 8015fc8:	f3af 8000 	nop.w
 8015fcc:	f3af 8000 	nop.w

08015fd0 <LSM303AGR_ACC_R_ClickThreshold>:
* Input          : Pointer to u8_t
* Output         : Status of THS
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickThreshold(void *handle, u8_t *value)
{
 8015fd0:	b500      	push	{lr}
 8015fd2:	b083      	sub	sp, #12
 8015fd4:	9001      	str	r0, [sp, #4]
 8015fd6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_THS, (u8_t *)value, 1) )
 8015fd8:	9801      	ldr	r0, [sp, #4]
 8015fda:	213a      	movs	r1, #58	; 0x3a
 8015fdc:	9a00      	ldr	r2, [sp, #0]
 8015fde:	2301      	movs	r3, #1
 8015fe0:	f7fc f99e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8015fe4:	4603      	mov	r3, r0
 8015fe6:	2b00      	cmp	r3, #0
 8015fe8:	d101      	bne.n	8015fee <LSM303AGR_ACC_R_ClickThreshold+0x1e>
    return MEMS_ERROR;
 8015fea:	2300      	movs	r3, #0
 8015fec:	e00b      	b.n	8016006 <LSM303AGR_ACC_R_ClickThreshold+0x36>

  *value &= LSM303AGR_ACC_THS_MASK; //coerce
 8015fee:	9b00      	ldr	r3, [sp, #0]
 8015ff0:	781b      	ldrb	r3, [r3, #0]
 8015ff2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8015ff6:	b2da      	uxtb	r2, r3
 8015ff8:	9b00      	ldr	r3, [sp, #0]
 8015ffa:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_THS_POSITION; //mask
 8015ffc:	9b00      	ldr	r3, [sp, #0]
 8015ffe:	781a      	ldrb	r2, [r3, #0]
 8016000:	9b00      	ldr	r3, [sp, #0]
 8016002:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8016004:	2301      	movs	r3, #1
}
 8016006:	4618      	mov	r0, r3
 8016008:	b003      	add	sp, #12
 801600a:	f85d fb04 	ldr.w	pc, [sp], #4
 801600e:	bf00      	nop

08016010 <LSM303AGR_ACC_W_ClickTimeLimit>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ClickTimeLimit(void *handle, u8_t newValue)
{
 8016010:	b500      	push	{lr}
 8016012:	b085      	sub	sp, #20
 8016014:	9001      	str	r0, [sp, #4]
 8016016:	460b      	mov	r3, r1
 8016018:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_TLI_POSITION; //mask
  newValue &= LSM303AGR_ACC_TLI_MASK; //coerce
 801601c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8016020:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8016024:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TIME_LIMIT, &value, 1) )
 8016028:	f10d 030f 	add.w	r3, sp, #15
 801602c:	9801      	ldr	r0, [sp, #4]
 801602e:	213b      	movs	r1, #59	; 0x3b
 8016030:	461a      	mov	r2, r3
 8016032:	2301      	movs	r3, #1
 8016034:	f7fc f974 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8016038:	4603      	mov	r3, r0
 801603a:	2b00      	cmp	r3, #0
 801603c:	d101      	bne.n	8016042 <LSM303AGR_ACC_W_ClickTimeLimit+0x32>
    return MEMS_ERROR;
 801603e:	2300      	movs	r3, #0
 8016040:	e01c      	b.n	801607c <LSM303AGR_ACC_W_ClickTimeLimit+0x6c>

  value &= ~LSM303AGR_ACC_TLI_MASK;
 8016042:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8016046:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801604a:	b2db      	uxtb	r3, r3
 801604c:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8016050:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8016054:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8016058:	4313      	orrs	r3, r2
 801605a:	b2db      	uxtb	r3, r3
 801605c:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_TIME_LIMIT, &value, 1) )
 8016060:	f10d 030f 	add.w	r3, sp, #15
 8016064:	9801      	ldr	r0, [sp, #4]
 8016066:	213b      	movs	r1, #59	; 0x3b
 8016068:	461a      	mov	r2, r3
 801606a:	2301      	movs	r3, #1
 801606c:	f7fc f938 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 8016070:	4603      	mov	r3, r0
 8016072:	2b00      	cmp	r3, #0
 8016074:	d101      	bne.n	801607a <LSM303AGR_ACC_W_ClickTimeLimit+0x6a>
    return MEMS_ERROR;
 8016076:	2300      	movs	r3, #0
 8016078:	e000      	b.n	801607c <LSM303AGR_ACC_W_ClickTimeLimit+0x6c>

  return MEMS_SUCCESS;
 801607a:	2301      	movs	r3, #1
}
 801607c:	4618      	mov	r0, r3
 801607e:	b005      	add	sp, #20
 8016080:	f85d fb04 	ldr.w	pc, [sp], #4
 8016084:	f3af 8000 	nop.w
 8016088:	f3af 8000 	nop.w
 801608c:	f3af 8000 	nop.w

08016090 <LSM303AGR_ACC_R_ClickTimeLimit>:
* Input          : Pointer to u8_t
* Output         : Status of TLI
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickTimeLimit(void *handle, u8_t *value)
{
 8016090:	b500      	push	{lr}
 8016092:	b083      	sub	sp, #12
 8016094:	9001      	str	r0, [sp, #4]
 8016096:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TIME_LIMIT, (u8_t *)value, 1) )
 8016098:	9801      	ldr	r0, [sp, #4]
 801609a:	213b      	movs	r1, #59	; 0x3b
 801609c:	9a00      	ldr	r2, [sp, #0]
 801609e:	2301      	movs	r3, #1
 80160a0:	f7fc f93e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80160a4:	4603      	mov	r3, r0
 80160a6:	2b00      	cmp	r3, #0
 80160a8:	d101      	bne.n	80160ae <LSM303AGR_ACC_R_ClickTimeLimit+0x1e>
    return MEMS_ERROR;
 80160aa:	2300      	movs	r3, #0
 80160ac:	e00b      	b.n	80160c6 <LSM303AGR_ACC_R_ClickTimeLimit+0x36>

  *value &= LSM303AGR_ACC_TLI_MASK; //coerce
 80160ae:	9b00      	ldr	r3, [sp, #0]
 80160b0:	781b      	ldrb	r3, [r3, #0]
 80160b2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80160b6:	b2da      	uxtb	r2, r3
 80160b8:	9b00      	ldr	r3, [sp, #0]
 80160ba:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_TLI_POSITION; //mask
 80160bc:	9b00      	ldr	r3, [sp, #0]
 80160be:	781a      	ldrb	r2, [r3, #0]
 80160c0:	9b00      	ldr	r3, [sp, #0]
 80160c2:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80160c4:	2301      	movs	r3, #1
}
 80160c6:	4618      	mov	r0, r3
 80160c8:	b003      	add	sp, #12
 80160ca:	f85d fb04 	ldr.w	pc, [sp], #4
 80160ce:	bf00      	nop

080160d0 <LSM303AGR_ACC_W_ClickTimeLatency>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ClickTimeLatency(void *handle, u8_t newValue)
{
 80160d0:	b500      	push	{lr}
 80160d2:	b085      	sub	sp, #20
 80160d4:	9001      	str	r0, [sp, #4]
 80160d6:	460b      	mov	r3, r1
 80160d8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_TLA_POSITION; //mask
  newValue &= LSM303AGR_ACC_TLA_MASK; //coerce

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TIME_LATENCY, &value, 1) )
 80160dc:	f10d 030f 	add.w	r3, sp, #15
 80160e0:	9801      	ldr	r0, [sp, #4]
 80160e2:	213c      	movs	r1, #60	; 0x3c
 80160e4:	461a      	mov	r2, r3
 80160e6:	2301      	movs	r3, #1
 80160e8:	f7fc f91a 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80160ec:	4603      	mov	r3, r0
 80160ee:	2b00      	cmp	r3, #0
 80160f0:	d101      	bne.n	80160f6 <LSM303AGR_ACC_W_ClickTimeLatency+0x26>
    return MEMS_ERROR;
 80160f2:	2300      	movs	r3, #0
 80160f4:	e018      	b.n	8016128 <LSM303AGR_ACC_W_ClickTimeLatency+0x58>

  value &= (u8_t)~LSM303AGR_ACC_TLA_MASK;
 80160f6:	2300      	movs	r3, #0
 80160f8:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80160fc:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8016100:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8016104:	4313      	orrs	r3, r2
 8016106:	b2db      	uxtb	r3, r3
 8016108:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_TIME_LATENCY, &value, 1) )
 801610c:	f10d 030f 	add.w	r3, sp, #15
 8016110:	9801      	ldr	r0, [sp, #4]
 8016112:	213c      	movs	r1, #60	; 0x3c
 8016114:	461a      	mov	r2, r3
 8016116:	2301      	movs	r3, #1
 8016118:	f7fc f8e2 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 801611c:	4603      	mov	r3, r0
 801611e:	2b00      	cmp	r3, #0
 8016120:	d101      	bne.n	8016126 <LSM303AGR_ACC_W_ClickTimeLatency+0x56>
    return MEMS_ERROR;
 8016122:	2300      	movs	r3, #0
 8016124:	e000      	b.n	8016128 <LSM303AGR_ACC_W_ClickTimeLatency+0x58>

  return MEMS_SUCCESS;
 8016126:	2301      	movs	r3, #1
}
 8016128:	4618      	mov	r0, r3
 801612a:	b005      	add	sp, #20
 801612c:	f85d fb04 	ldr.w	pc, [sp], #4

08016130 <LSM303AGR_ACC_R_ClickTimeLatency>:
* Input          : Pointer to u8_t
* Output         : Status of TLA
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickTimeLatency(void *handle, u8_t *value)
{
 8016130:	b500      	push	{lr}
 8016132:	b083      	sub	sp, #12
 8016134:	9001      	str	r0, [sp, #4]
 8016136:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TIME_LATENCY, (u8_t *)value, 1) )
 8016138:	9801      	ldr	r0, [sp, #4]
 801613a:	213c      	movs	r1, #60	; 0x3c
 801613c:	9a00      	ldr	r2, [sp, #0]
 801613e:	2301      	movs	r3, #1
 8016140:	f7fc f8ee 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8016144:	4603      	mov	r3, r0
 8016146:	2b00      	cmp	r3, #0
 8016148:	d101      	bne.n	801614e <LSM303AGR_ACC_R_ClickTimeLatency+0x1e>
    return MEMS_ERROR;
 801614a:	2300      	movs	r3, #0
 801614c:	e008      	b.n	8016160 <LSM303AGR_ACC_R_ClickTimeLatency+0x30>

  *value &= LSM303AGR_ACC_TLA_MASK; //coerce
 801614e:	9b00      	ldr	r3, [sp, #0]
 8016150:	781a      	ldrb	r2, [r3, #0]
 8016152:	9b00      	ldr	r3, [sp, #0]
 8016154:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_TLA_POSITION; //mask
 8016156:	9b00      	ldr	r3, [sp, #0]
 8016158:	781a      	ldrb	r2, [r3, #0]
 801615a:	9b00      	ldr	r3, [sp, #0]
 801615c:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801615e:	2301      	movs	r3, #1
}
 8016160:	4618      	mov	r0, r3
 8016162:	b003      	add	sp, #12
 8016164:	f85d fb04 	ldr.w	pc, [sp], #4
 8016168:	f3af 8000 	nop.w
 801616c:	f3af 8000 	nop.w

08016170 <LSM303AGR_ACC_W_ClickTimeWindow>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ClickTimeWindow(void *handle, u8_t newValue)
{
 8016170:	b500      	push	{lr}
 8016172:	b085      	sub	sp, #20
 8016174:	9001      	str	r0, [sp, #4]
 8016176:	460b      	mov	r3, r1
 8016178:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_TW_POSITION; //mask
  newValue &= LSM303AGR_ACC_TW_MASK; //coerce

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TIME_WINDOW, &value, 1) )
 801617c:	f10d 030f 	add.w	r3, sp, #15
 8016180:	9801      	ldr	r0, [sp, #4]
 8016182:	213d      	movs	r1, #61	; 0x3d
 8016184:	461a      	mov	r2, r3
 8016186:	2301      	movs	r3, #1
 8016188:	f7fc f8ca 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 801618c:	4603      	mov	r3, r0
 801618e:	2b00      	cmp	r3, #0
 8016190:	d101      	bne.n	8016196 <LSM303AGR_ACC_W_ClickTimeWindow+0x26>
    return MEMS_ERROR;
 8016192:	2300      	movs	r3, #0
 8016194:	e018      	b.n	80161c8 <LSM303AGR_ACC_W_ClickTimeWindow+0x58>

  value &= (u8_t)~LSM303AGR_ACC_TW_MASK;
 8016196:	2300      	movs	r3, #0
 8016198:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 801619c:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80161a0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80161a4:	4313      	orrs	r3, r2
 80161a6:	b2db      	uxtb	r3, r3
 80161a8:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_TIME_WINDOW, &value, 1) )
 80161ac:	f10d 030f 	add.w	r3, sp, #15
 80161b0:	9801      	ldr	r0, [sp, #4]
 80161b2:	213d      	movs	r1, #61	; 0x3d
 80161b4:	461a      	mov	r2, r3
 80161b6:	2301      	movs	r3, #1
 80161b8:	f7fc f892 	bl	80122e0 <LSM303AGR_ACC_WriteReg>
 80161bc:	4603      	mov	r3, r0
 80161be:	2b00      	cmp	r3, #0
 80161c0:	d101      	bne.n	80161c6 <LSM303AGR_ACC_W_ClickTimeWindow+0x56>
    return MEMS_ERROR;
 80161c2:	2300      	movs	r3, #0
 80161c4:	e000      	b.n	80161c8 <LSM303AGR_ACC_W_ClickTimeWindow+0x58>

  return MEMS_SUCCESS;
 80161c6:	2301      	movs	r3, #1
}
 80161c8:	4618      	mov	r0, r3
 80161ca:	b005      	add	sp, #20
 80161cc:	f85d fb04 	ldr.w	pc, [sp], #4

080161d0 <LSM303AGR_ACC_R_ClickTimeWindow>:
* Input          : Pointer to u8_t
* Output         : Status of TW
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickTimeWindow(void *handle, u8_t *value)
{
 80161d0:	b500      	push	{lr}
 80161d2:	b083      	sub	sp, #12
 80161d4:	9001      	str	r0, [sp, #4]
 80161d6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TIME_WINDOW, (u8_t *)value, 1) )
 80161d8:	9801      	ldr	r0, [sp, #4]
 80161da:	213d      	movs	r1, #61	; 0x3d
 80161dc:	9a00      	ldr	r2, [sp, #0]
 80161de:	2301      	movs	r3, #1
 80161e0:	f7fc f89e 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 80161e4:	4603      	mov	r3, r0
 80161e6:	2b00      	cmp	r3, #0
 80161e8:	d101      	bne.n	80161ee <LSM303AGR_ACC_R_ClickTimeWindow+0x1e>
    return MEMS_ERROR;
 80161ea:	2300      	movs	r3, #0
 80161ec:	e008      	b.n	8016200 <LSM303AGR_ACC_R_ClickTimeWindow+0x30>

  *value &= LSM303AGR_ACC_TW_MASK; //coerce
 80161ee:	9b00      	ldr	r3, [sp, #0]
 80161f0:	781a      	ldrb	r2, [r3, #0]
 80161f2:	9b00      	ldr	r3, [sp, #0]
 80161f4:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_TW_POSITION; //mask
 80161f6:	9b00      	ldr	r3, [sp, #0]
 80161f8:	781a      	ldrb	r2, [r3, #0]
 80161fa:	9b00      	ldr	r3, [sp, #0]
 80161fc:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80161fe:	2301      	movs	r3, #1
}
 8016200:	4618      	mov	r0, r3
 8016202:	b003      	add	sp, #12
 8016204:	f85d fb04 	ldr.w	pc, [sp], #4
 8016208:	f3af 8000 	nop.w
 801620c:	f3af 8000 	nop.w

08016210 <LSM303AGR_ACC_Get_Voltage_ADC>:
* Input          : pointer to [u8_t]
* Output         : Voltage_ADC buffer u8_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_Get_Voltage_ADC(void *handle, u8_t *buff)
{
 8016210:	b500      	push	{lr}
 8016212:	b085      	sub	sp, #20
 8016214:	9001      	str	r0, [sp, #4]
 8016216:	9100      	str	r1, [sp, #0]
  u8_t i, j, k;
  u8_t numberOfByteForDimension;

  numberOfByteForDimension = 6 / 3;
 8016218:	2302      	movs	r3, #2
 801621a:	f88d 300c 	strb.w	r3, [sp, #12]

  k = 0;
 801621e:	2300      	movs	r3, #0
 8016220:	f88d 300d 	strb.w	r3, [sp, #13]
  for (i = 0; i < 3; i++ )
 8016224:	2300      	movs	r3, #0
 8016226:	f88d 300f 	strb.w	r3, [sp, #15]
 801622a:	e02b      	b.n	8016284 <LSM303AGR_ACC_Get_Voltage_ADC+0x74>
  {
    for (j = 0; j < numberOfByteForDimension; j++ )
 801622c:	2300      	movs	r3, #0
 801622e:	f88d 300e 	strb.w	r3, [sp, #14]
 8016232:	e01c      	b.n	801626e <LSM303AGR_ACC_Get_Voltage_ADC+0x5e>
    {
      if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_OUT_ADC1_L + k, &buff[k], 1 ))
 8016234:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8016238:	3308      	adds	r3, #8
 801623a:	b2da      	uxtb	r2, r3
 801623c:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8016240:	9900      	ldr	r1, [sp, #0]
 8016242:	440b      	add	r3, r1
 8016244:	9801      	ldr	r0, [sp, #4]
 8016246:	4611      	mov	r1, r2
 8016248:	461a      	mov	r2, r3
 801624a:	2301      	movs	r3, #1
 801624c:	f7fc f868 	bl	8012320 <LSM303AGR_ACC_ReadReg>
 8016250:	4603      	mov	r3, r0
 8016252:	2b00      	cmp	r3, #0
 8016254:	d101      	bne.n	801625a <LSM303AGR_ACC_Get_Voltage_ADC+0x4a>
        return MEMS_ERROR;
 8016256:	2300      	movs	r3, #0
 8016258:	e019      	b.n	801628e <LSM303AGR_ACC_Get_Voltage_ADC+0x7e>
      k++;
 801625a:	f89d 300d 	ldrb.w	r3, [sp, #13]
 801625e:	3301      	adds	r3, #1
 8016260:	f88d 300d 	strb.w	r3, [sp, #13]
  numberOfByteForDimension = 6 / 3;

  k = 0;
  for (i = 0; i < 3; i++ )
  {
    for (j = 0; j < numberOfByteForDimension; j++ )
 8016264:	f89d 300e 	ldrb.w	r3, [sp, #14]
 8016268:	3301      	adds	r3, #1
 801626a:	f88d 300e 	strb.w	r3, [sp, #14]
 801626e:	f89d 200e 	ldrb.w	r2, [sp, #14]
 8016272:	f89d 300c 	ldrb.w	r3, [sp, #12]
 8016276:	429a      	cmp	r2, r3
 8016278:	d3dc      	bcc.n	8016234 <LSM303AGR_ACC_Get_Voltage_ADC+0x24>
  u8_t numberOfByteForDimension;

  numberOfByteForDimension = 6 / 3;

  k = 0;
  for (i = 0; i < 3; i++ )
 801627a:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801627e:	3301      	adds	r3, #1
 8016280:	f88d 300f 	strb.w	r3, [sp, #15]
 8016284:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8016288:	2b02      	cmp	r3, #2
 801628a:	d9cf      	bls.n	801622c <LSM303AGR_ACC_Get_Voltage_ADC+0x1c>
        return MEMS_ERROR;
      k++;
    }
  }

  return MEMS_SUCCESS;
 801628c:	2301      	movs	r3, #1
}
 801628e:	4618      	mov	r0, r3
 8016290:	b005      	add	sp, #20
 8016292:	f85d fb04 	ldr.w	pc, [sp], #4
 8016296:	bf00      	nop
 8016298:	f3af 8000 	nop.w
 801629c:	f3af 8000 	nop.w

080162a0 <Hal_Write_Serial>:
* @param  n_bytes2: number of bytes in 2nd buffer
* @retval None
*/
void Hal_Write_Serial(const void* data1, const void* data2, int32_t n_bytes1,
                      int32_t n_bytes2)
{
 80162a0:	b500      	push	{lr}
 80162a2:	b087      	sub	sp, #28
 80162a4:	9005      	str	r0, [sp, #20]
 80162a6:	9104      	str	r1, [sp, #16]
 80162a8:	9203      	str	r2, [sp, #12]
 80162aa:	9302      	str	r3, [sp, #8]
  }
  PRINT_CSV("\n");
#endif
  
  while(1){
    if(Sensor_IO_SPI_BlueNRG_Write(&bluenrg_cfg, (uint8_t *)data1,(uint8_t *)data2, n_bytes1, n_bytes2)==0) break;
 80162ac:	9b03      	ldr	r3, [sp, #12]
 80162ae:	b2db      	uxtb	r3, r3
 80162b0:	9a02      	ldr	r2, [sp, #8]
 80162b2:	b2d2      	uxtb	r2, r2
 80162b4:	9200      	str	r2, [sp, #0]
 80162b6:	4806      	ldr	r0, [pc, #24]	; (80162d0 <Hal_Write_Serial+0x30>)
 80162b8:	9905      	ldr	r1, [sp, #20]
 80162ba:	9a04      	ldr	r2, [sp, #16]
 80162bc:	f7fb fe60 	bl	8011f80 <Sensor_IO_SPI_BlueNRG_Write>
 80162c0:	4603      	mov	r3, r0
 80162c2:	2b00      	cmp	r3, #0
 80162c4:	d100      	bne.n	80162c8 <Hal_Write_Serial+0x28>
 80162c6:	e000      	b.n	80162ca <Hal_Write_Serial+0x2a>
    /*if(Timer_Expired(&t)){
      break;
    }*/
  }
 80162c8:	e7f0      	b.n	80162ac <Hal_Write_Serial+0xc>
}
 80162ca:	b007      	add	sp, #28
 80162cc:	f85d fb04 	ldr.w	pc, [sp], #4
 80162d0:	20000900 	.word	0x20000900
 80162d4:	f3af 8000 	nop.w
 80162d8:	f3af 8000 	nop.w
 80162dc:	f3af 8000 	nop.w

080162e0 <chThdTerminatedX>:
 * @retval true         thread terminated.
 * @retval false        thread not terminated.
 *
 * @xclass
 */
static inline bool chThdTerminatedX(thread_t *tp) {
 80162e0:	b082      	sub	sp, #8
 80162e2:	9001      	str	r0, [sp, #4]

  return (bool)(tp->p_state == CH_STATE_FINAL);
 80162e4:	9b01      	ldr	r3, [sp, #4]
 80162e6:	7f1b      	ldrb	r3, [r3, #28]
 80162e8:	2b0f      	cmp	r3, #15
 80162ea:	bf14      	ite	ne
 80162ec:	2300      	movne	r3, #0
 80162ee:	2301      	moveq	r3, #1
 80162f0:	b2db      	uxtb	r3, r3
}
 80162f2:	4618      	mov	r0, r3
 80162f4:	b002      	add	sp, #8
 80162f6:	4770      	bx	lr
 80162f8:	f3af 8000 	nop.w
 80162fc:	f3af 8000 	nop.w

08016300 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8016300:	b082      	sub	sp, #8
 8016302:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8016304:	4b02      	ldr	r3, [pc, #8]	; (8016310 <chRegSetThreadName+0x10>)
 8016306:	699b      	ldr	r3, [r3, #24]
 8016308:	9a01      	ldr	r2, [sp, #4]
 801630a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 801630c:	b002      	add	sp, #8
 801630e:	4770      	bx	lr
 8016310:	200016e0 	.word	0x200016e0
 8016314:	f3af 8000 	nop.w
 8016318:	f3af 8000 	nop.w
 801631c:	f3af 8000 	nop.w

08016320 <counterThread>:
static void convert_axes(void);

/* Thread that retrieves accelerometer data*/

static THD_WORKING_AREA(waCounterThread,128);
static THD_FUNCTION(counterThread,arg) {
 8016320:	b500      	push	{lr}
 8016322:	b085      	sub	sp, #20
 8016324:	9001      	str	r0, [sp, #4]

  UNUSED(arg);
  chRegSetThreadName("blinker");
 8016326:	4814      	ldr	r0, [pc, #80]	; (8016378 <counterThread+0x58>)
 8016328:	f7ff ffea 	bl	8016300 <chRegSetThreadName>
  int junk;

  while (TRUE) {
    junk = LSM303AGR_ACC_Get_Acceleration(NULL, a_data);
 801632c:	2000      	movs	r0, #0
 801632e:	4913      	ldr	r1, [pc, #76]	; (801637c <counterThread+0x5c>)
 8016330:	f7fc f8f6 	bl	8012520 <LSM303AGR_ACC_Get_Acceleration>
 8016334:	4603      	mov	r3, r0
 8016336:	9303      	str	r3, [sp, #12]
    
    convert_axes();
 8016338:	f000 f96a 	bl	8016610 <convert_axes>
    
    UNUSED(junk);

    if(read_state){
 801633c:	4b10      	ldr	r3, [pc, #64]	; (8016380 <counterThread+0x60>)
 801633e:	681b      	ldr	r3, [r3, #0]
 8016340:	2b00      	cmp	r3, #0
 8016342:	d014      	beq.n	801636e <counterThread+0x4e>
      chprintf((BaseSequentialStream *) &SD5, "X: %d\n\r", a_data[0]) ;
 8016344:	4b0d      	ldr	r3, [pc, #52]	; (801637c <counterThread+0x5c>)
 8016346:	681b      	ldr	r3, [r3, #0]
 8016348:	480e      	ldr	r0, [pc, #56]	; (8016384 <counterThread+0x64>)
 801634a:	490f      	ldr	r1, [pc, #60]	; (8016388 <counterThread+0x68>)
 801634c:	461a      	mov	r2, r3
 801634e:	f7fb f997 	bl	8011680 <chprintf>
      chprintf((BaseSequentialStream *) &SD5, "Y: %d\n\r", a_data[1]) ;
 8016352:	4b0a      	ldr	r3, [pc, #40]	; (801637c <counterThread+0x5c>)
 8016354:	685b      	ldr	r3, [r3, #4]
 8016356:	480b      	ldr	r0, [pc, #44]	; (8016384 <counterThread+0x64>)
 8016358:	490c      	ldr	r1, [pc, #48]	; (801638c <counterThread+0x6c>)
 801635a:	461a      	mov	r2, r3
 801635c:	f7fb f990 	bl	8011680 <chprintf>
      chprintf((BaseSequentialStream *) &SD5, "Z: %d\n\r", a_data[2]) ; 
 8016360:	4b06      	ldr	r3, [pc, #24]	; (801637c <counterThread+0x5c>)
 8016362:	689b      	ldr	r3, [r3, #8]
 8016364:	4807      	ldr	r0, [pc, #28]	; (8016384 <counterThread+0x64>)
 8016366:	490a      	ldr	r1, [pc, #40]	; (8016390 <counterThread+0x70>)
 8016368:	461a      	mov	r2, r3
 801636a:	f7fb f989 	bl	8011680 <chprintf>
    }

    chThdSleepMilliseconds(100);
 801636e:	2064      	movs	r0, #100	; 0x64
 8016370:	f7ea ffae 	bl	80012d0 <chThdSleep>

  }
 8016374:	e7da      	b.n	801632c <counterThread+0xc>
 8016376:	bf00      	nop
 8016378:	08019580 	.word	0x08019580
 801637c:	20001090 	.word	0x20001090
 8016380:	20002230 	.word	0x20002230
 8016384:	20001b20 	.word	0x20001b20
 8016388:	08019588 	.word	0x08019588
 801638c:	08019590 	.word	0x08019590
 8016390:	08019598 	.word	0x08019598
 8016394:	f3af 8000 	nop.w
 8016398:	f3af 8000 	nop.w
 801639c:	f3af 8000 	nop.w

080163a0 <timeStamp>:


/* Thread that retrieves the number of counts every minute */

static THD_WORKING_AREA(timeStampThread,128);
static THD_FUNCTION(timeStamp,arg) {
 80163a0:	b500      	push	{lr}
 80163a2:	b083      	sub	sp, #12
 80163a4:	9001      	str	r0, [sp, #4]

  UNUSED(arg);
  chRegSetThreadName("timer");
 80163a6:	4807      	ldr	r0, [pc, #28]	; (80163c4 <timeStamp+0x24>)
 80163a8:	f7ff ffaa 	bl	8016300 <chRegSetThreadName>
  while (TRUE) {
  //old array write call 
  //time_stamp[timer_index++] = people; // trigger_count (was this)
  // new array write to flash 
  //writeHourlyData(timer_index++, people);
  trigger_count = 0;
 80163ac:	4b06      	ldr	r3, [pc, #24]	; (80163c8 <timeStamp+0x28>)
 80163ae:	2200      	movs	r2, #0
 80163b0:	601a      	str	r2, [r3, #0]
  people = 0;
 80163b2:	4b06      	ldr	r3, [pc, #24]	; (80163cc <timeStamp+0x2c>)
 80163b4:	2200      	movs	r2, #0
 80163b6:	601a      	str	r2, [r3, #0]

   chThdSleepMilliseconds(60000);
 80163b8:	f64e 2060 	movw	r0, #60000	; 0xea60
 80163bc:	f7ea ff88 	bl	80012d0 <chThdSleep>

  }
 80163c0:	e7f4      	b.n	80163ac <timeStamp+0xc>
 80163c2:	bf00      	nop
 80163c4:	080195a0 	.word	0x080195a0
 80163c8:	2000222c 	.word	0x2000222c
 80163cc:	20002234 	.word	0x20002234

080163d0 <throttleCount>:
  *
  */


static THD_WORKING_AREA(throttleThread,256);
static THD_FUNCTION(throttleCount,arg) {
 80163d0:	b500      	push	{lr}
 80163d2:	b083      	sub	sp, #12
 80163d4:	9001      	str	r0, [sp, #4]

  UNUSED(arg);
  chRegSetThreadName("throttle");
 80163d6:	4814      	ldr	r0, [pc, #80]	; (8016428 <throttleCount+0x58>)
 80163d8:	f7ff ff92 	bl	8016300 <chRegSetThreadName>

  while (TRUE) {
    
    if((trigger_count - check_count) > 3){
 80163dc:	4b13      	ldr	r3, [pc, #76]	; (801642c <throttleCount+0x5c>)
 80163de:	681a      	ldr	r2, [r3, #0]
 80163e0:	4b13      	ldr	r3, [pc, #76]	; (8016430 <throttleCount+0x60>)
 80163e2:	681b      	ldr	r3, [r3, #0]
 80163e4:	1ad3      	subs	r3, r2, r3
 80163e6:	2b03      	cmp	r3, #3
 80163e8:	dd13      	ble.n	8016412 <throttleCount+0x42>
      people += trigger_count / 3; 
 80163ea:	4b10      	ldr	r3, [pc, #64]	; (801642c <throttleCount+0x5c>)
 80163ec:	681b      	ldr	r3, [r3, #0]
 80163ee:	4a11      	ldr	r2, [pc, #68]	; (8016434 <throttleCount+0x64>)
 80163f0:	fb82 1203 	smull	r1, r2, r2, r3
 80163f4:	17db      	asrs	r3, r3, #31
 80163f6:	1ad2      	subs	r2, r2, r3
 80163f8:	4b0f      	ldr	r3, [pc, #60]	; (8016438 <throttleCount+0x68>)
 80163fa:	681b      	ldr	r3, [r3, #0]
 80163fc:	441a      	add	r2, r3
 80163fe:	4b0e      	ldr	r3, [pc, #56]	; (8016438 <throttleCount+0x68>)
 8016400:	601a      	str	r2, [r3, #0]
      trigger_count = check_count = 0;
 8016402:	4b0b      	ldr	r3, [pc, #44]	; (8016430 <throttleCount+0x60>)
 8016404:	2200      	movs	r2, #0
 8016406:	601a      	str	r2, [r3, #0]
 8016408:	4b09      	ldr	r3, [pc, #36]	; (8016430 <throttleCount+0x60>)
 801640a:	681a      	ldr	r2, [r3, #0]
 801640c:	4b07      	ldr	r3, [pc, #28]	; (801642c <throttleCount+0x5c>)
 801640e:	601a      	str	r2, [r3, #0]
 8016410:	e004      	b.n	801641c <throttleCount+0x4c>
    } else{
      people++;
 8016412:	4b09      	ldr	r3, [pc, #36]	; (8016438 <throttleCount+0x68>)
 8016414:	681b      	ldr	r3, [r3, #0]
 8016416:	1c5a      	adds	r2, r3, #1
 8016418:	4b07      	ldr	r3, [pc, #28]	; (8016438 <throttleCount+0x68>)
 801641a:	601a      	str	r2, [r3, #0]
    }
    chThdSleepMilliseconds(3000);     // wakes up roughly every 3 seconds 
 801641c:	f640 30b8 	movw	r0, #3000	; 0xbb8
 8016420:	f7ea ff56 	bl	80012d0 <chThdSleep>

  }
 8016424:	e7da      	b.n	80163dc <throttleCount+0xc>
 8016426:	bf00      	nop
 8016428:	080195a8 	.word	0x080195a8
 801642c:	2000222c 	.word	0x2000222c
 8016430:	200010b0 	.word	0x200010b0
 8016434:	55555556 	.word	0x55555556
 8016438:	20002234 	.word	0x20002234
 801643c:	f3af 8000 	nop.w

08016440 <theCounterThread>:
}

/* Thread that increments the count based on trigger parameters */

static THD_WORKING_AREA(accelCounterThread,256);
static THD_FUNCTION(theCounterThread,arg) {
 8016440:	b500      	push	{lr}
 8016442:	b089      	sub	sp, #36	; 0x24
 8016444:	9001      	str	r0, [sp, #4]

  UNUSED(arg);
  chRegSetThreadName("counter");
 8016446:	4869      	ldr	r0, [pc, #420]	; (80165ec <theCounterThread+0x1ac>)
 8016448:	f7ff ff5a 	bl	8016300 <chRegSetThreadName>
  int trash; 

  int32_t x_tuning_offset = 0;
 801644c:	2300      	movs	r3, #0
 801644e:	9307      	str	r3, [sp, #28]
  int32_t y_tuning_offset = 0;
 8016450:	2300      	movs	r3, #0
 8016452:	9306      	str	r3, [sp, #24]
  int32_t z_tuning_offset = 0;
 8016454:	2300      	movs	r3, #0
 8016456:	9305      	str	r3, [sp, #20]
  int32_t sleep_counts = 0;
 8016458:	2300      	movs	r3, #0
 801645a:	9304      	str	r3, [sp, #16]
/*    if(a_data[2] >= Z_Axis_Offset) thresholds |= 0x4;
    if(a_data[1] >= Y_Axis_Offset) thresholds |= 0x2;
    if(a_data[0] >= X_Axis_Offset) thresholds |= 0x1; 
*/

    if(a_data[2] - z_tuning_offset < 0) z_tuning_offset += (a_data[2] - z_tuning_offset);
 801645c:	4b64      	ldr	r3, [pc, #400]	; (80165f0 <theCounterThread+0x1b0>)
 801645e:	689a      	ldr	r2, [r3, #8]
 8016460:	9b05      	ldr	r3, [sp, #20]
 8016462:	1ad3      	subs	r3, r2, r3
 8016464:	2b00      	cmp	r3, #0
 8016466:	da06      	bge.n	8016476 <theCounterThread+0x36>
 8016468:	4b61      	ldr	r3, [pc, #388]	; (80165f0 <theCounterThread+0x1b0>)
 801646a:	689a      	ldr	r2, [r3, #8]
 801646c:	9b05      	ldr	r3, [sp, #20]
 801646e:	1ad3      	subs	r3, r2, r3
 8016470:	9a05      	ldr	r2, [sp, #20]
 8016472:	4413      	add	r3, r2
 8016474:	9305      	str	r3, [sp, #20]
    if(a_data[1] - y_tuning_offset < 0) y_tuning_offset += (a_data[1] - y_tuning_offset);
 8016476:	4b5e      	ldr	r3, [pc, #376]	; (80165f0 <theCounterThread+0x1b0>)
 8016478:	685a      	ldr	r2, [r3, #4]
 801647a:	9b06      	ldr	r3, [sp, #24]
 801647c:	1ad3      	subs	r3, r2, r3
 801647e:	2b00      	cmp	r3, #0
 8016480:	da06      	bge.n	8016490 <theCounterThread+0x50>
 8016482:	4b5b      	ldr	r3, [pc, #364]	; (80165f0 <theCounterThread+0x1b0>)
 8016484:	685a      	ldr	r2, [r3, #4]
 8016486:	9b06      	ldr	r3, [sp, #24]
 8016488:	1ad3      	subs	r3, r2, r3
 801648a:	9a06      	ldr	r2, [sp, #24]
 801648c:	4413      	add	r3, r2
 801648e:	9306      	str	r3, [sp, #24]
    if(a_data[0] - x_tuning_offset < 0) x_tuning_offset += (a_data[0] - x_tuning_offset);
 8016490:	4b57      	ldr	r3, [pc, #348]	; (80165f0 <theCounterThread+0x1b0>)
 8016492:	681a      	ldr	r2, [r3, #0]
 8016494:	9b07      	ldr	r3, [sp, #28]
 8016496:	1ad3      	subs	r3, r2, r3
 8016498:	2b00      	cmp	r3, #0
 801649a:	da06      	bge.n	80164aa <theCounterThread+0x6a>
 801649c:	4b54      	ldr	r3, [pc, #336]	; (80165f0 <theCounterThread+0x1b0>)
 801649e:	681a      	ldr	r2, [r3, #0]
 80164a0:	9b07      	ldr	r3, [sp, #28]
 80164a2:	1ad3      	subs	r3, r2, r3
 80164a4:	9a07      	ldr	r2, [sp, #28]
 80164a6:	4413      	add	r3, r2
 80164a8:	9307      	str	r3, [sp, #28]


    if(abs(a_data[2] - z_tuning_offset) > XYZ_THRESHOLD) thresholds |= 0x4;
 80164aa:	4b51      	ldr	r3, [pc, #324]	; (80165f0 <theCounterThread+0x1b0>)
 80164ac:	689a      	ldr	r2, [r3, #8]
 80164ae:	9b05      	ldr	r3, [sp, #20]
 80164b0:	1ad3      	subs	r3, r2, r3
 80164b2:	2b00      	cmp	r3, #0
 80164b4:	bfb8      	it	lt
 80164b6:	425b      	neglt	r3, r3
 80164b8:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 80164bc:	dd05      	ble.n	80164ca <theCounterThread+0x8a>
 80164be:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80164c2:	f043 0304 	orr.w	r3, r3, #4
 80164c6:	f88d 300f 	strb.w	r3, [sp, #15]
    if(abs(a_data[0] - x_tuning_offset) > XYZ_THRESHOLD) thresholds |= 0x1; 
 80164ca:	4b49      	ldr	r3, [pc, #292]	; (80165f0 <theCounterThread+0x1b0>)
 80164cc:	681a      	ldr	r2, [r3, #0]
 80164ce:	9b07      	ldr	r3, [sp, #28]
 80164d0:	1ad3      	subs	r3, r2, r3
 80164d2:	2b00      	cmp	r3, #0
 80164d4:	bfb8      	it	lt
 80164d6:	425b      	neglt	r3, r3
 80164d8:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 80164dc:	dd05      	ble.n	80164ea <theCounterThread+0xaa>
 80164de:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80164e2:	f043 0301 	orr.w	r3, r3, #1
 80164e6:	f88d 300f 	strb.w	r3, [sp, #15]
    if(abs(a_data[1] - y_tuning_offset) > XYZ_THRESHOLD) thresholds |= 0x2;
 80164ea:	4b41      	ldr	r3, [pc, #260]	; (80165f0 <theCounterThread+0x1b0>)
 80164ec:	685a      	ldr	r2, [r3, #4]
 80164ee:	9b06      	ldr	r3, [sp, #24]
 80164f0:	1ad3      	subs	r3, r2, r3
 80164f2:	2b00      	cmp	r3, #0
 80164f4:	bfb8      	it	lt
 80164f6:	425b      	neglt	r3, r3
 80164f8:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 80164fc:	dd05      	ble.n	801650a <theCounterThread+0xca>
 80164fe:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8016502:	f043 0302 	orr.w	r3, r3, #2
 8016506:	f88d 300f 	strb.w	r3, [sp, #15]
    if((a_data[2] - z_tuning_offset) > XYZ_THRESHOLD) thresholds |= 0x4;
    if((a_data[1] - y_tuning_offset) > XYZ_THRESHOLD) thresholds |= 0x2;
    if((a_data[0] - x_tuning_offset) > XYZ_THRESHOLD) thresholds |= 0x1; 
*/

    tmp_thresholds = thresholds;
 801650a:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801650e:	f88d 300e 	strb.w	r3, [sp, #14]



    if(thresholds != 0){      // axes above the threshold triggering a count
 8016512:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8016516:	2b00      	cmp	r3, #0
 8016518:	d063      	beq.n	80165e2 <theCounterThread+0x1a2>
      
      
      
      sleep_counts = 0;
 801651a:	2300      	movs	r3, #0
 801651c:	9304      	str	r3, [sp, #16]
      while(TRUE){

        chprintf((BaseSequentialStream *) &SD5, "In here\n\r");
 801651e:	4835      	ldr	r0, [pc, #212]	; (80165f4 <theCounterThread+0x1b4>)
 8016520:	4935      	ldr	r1, [pc, #212]	; (80165f8 <theCounterThread+0x1b8>)
 8016522:	f7fb f8ad 	bl	8011680 <chprintf>

        thresholds = 0;
 8016526:	2300      	movs	r3, #0
 8016528:	f88d 300f 	strb.w	r3, [sp, #15]
        trash = LSM303AGR_ACC_Get_Acceleration(NULL, a_data);   // updates thresholds value
 801652c:	2000      	movs	r0, #0
 801652e:	4930      	ldr	r1, [pc, #192]	; (80165f0 <theCounterThread+0x1b0>)
 8016530:	f7fb fff6 	bl	8012520 <LSM303AGR_ACC_Get_Acceleration>
 8016534:	4603      	mov	r3, r0
 8016536:	9302      	str	r3, [sp, #8]

        convert_axes();                 // convert them back wrt to the thresholds 
 8016538:	f000 f86a 	bl	8016610 <convert_axes>


          // same conditional as before
        if(a_data[2] - z_tuning_offset > XYZ_THRESHOLD) thresholds |= 0x4;
 801653c:	4b2c      	ldr	r3, [pc, #176]	; (80165f0 <theCounterThread+0x1b0>)
 801653e:	689a      	ldr	r2, [r3, #8]
 8016540:	9b05      	ldr	r3, [sp, #20]
 8016542:	1ad3      	subs	r3, r2, r3
 8016544:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 8016548:	dd05      	ble.n	8016556 <theCounterThread+0x116>
 801654a:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801654e:	f043 0304 	orr.w	r3, r3, #4
 8016552:	f88d 300f 	strb.w	r3, [sp, #15]
        if(a_data[1] - y_tuning_offset > XYZ_THRESHOLD) thresholds |= 0x2;
 8016556:	4b26      	ldr	r3, [pc, #152]	; (80165f0 <theCounterThread+0x1b0>)
 8016558:	685a      	ldr	r2, [r3, #4]
 801655a:	9b06      	ldr	r3, [sp, #24]
 801655c:	1ad3      	subs	r3, r2, r3
 801655e:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 8016562:	dd05      	ble.n	8016570 <theCounterThread+0x130>
 8016564:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8016568:	f043 0302 	orr.w	r3, r3, #2
 801656c:	f88d 300f 	strb.w	r3, [sp, #15]
        if(a_data[0] - x_tuning_offset > XYZ_THRESHOLD) thresholds |= 0x1; 
 8016570:	4b1f      	ldr	r3, [pc, #124]	; (80165f0 <theCounterThread+0x1b0>)
 8016572:	681a      	ldr	r2, [r3, #0]
 8016574:	9b07      	ldr	r3, [sp, #28]
 8016576:	1ad3      	subs	r3, r2, r3
 8016578:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 801657c:	dd05      	ble.n	801658a <theCounterThread+0x14a>
 801657e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8016582:	f043 0301 	orr.w	r3, r3, #1
 8016586:	f88d 300f 	strb.w	r3, [sp, #15]


        tmp_thresholds = thresholds;
 801658a:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801658e:	f88d 300e 	strb.w	r3, [sp, #14]

        if(tmp_thresholds != 0){
 8016592:	f89d 300e 	ldrb.w	r3, [sp, #14]
 8016596:	2b00      	cmp	r3, #0
 8016598:	d00e      	beq.n	80165b8 <theCounterThread+0x178>
          if (sleep_counts == 100) {
 801659a:	9b04      	ldr	r3, [sp, #16]
 801659c:	2b64      	cmp	r3, #100	; 0x64
 801659e:	d119      	bne.n	80165d4 <theCounterThread+0x194>
/*            z_tuning_offset = (a_data[2] + z_tuning_offset)/2;
            x_tuning_offset = (a_data[1] + y_tuning_offset)/2;
            y_tuning_offset = (a_data[0] + x_tuning_offset)/2;
*/
            z_tuning_offset = a_data[2];
 80165a0:	4b13      	ldr	r3, [pc, #76]	; (80165f0 <theCounterThread+0x1b0>)
 80165a2:	689b      	ldr	r3, [r3, #8]
 80165a4:	9305      	str	r3, [sp, #20]
            y_tuning_offset = a_data[1];
 80165a6:	4b12      	ldr	r3, [pc, #72]	; (80165f0 <theCounterThread+0x1b0>)
 80165a8:	685b      	ldr	r3, [r3, #4]
 80165aa:	9306      	str	r3, [sp, #24]
            x_tuning_offset = a_data[0];
 80165ac:	4b10      	ldr	r3, [pc, #64]	; (80165f0 <theCounterThread+0x1b0>)
 80165ae:	681b      	ldr	r3, [r3, #0]
 80165b0:	9307      	str	r3, [sp, #28]
            sleep_counts = 0;
 80165b2:	2300      	movs	r3, #0
 80165b4:	9304      	str	r3, [sp, #16]
 80165b6:	e00d      	b.n	80165d4 <theCounterThread+0x194>
          }
        } else{
          trigger_count++;
 80165b8:	4b10      	ldr	r3, [pc, #64]	; (80165fc <theCounterThread+0x1bc>)
 80165ba:	681b      	ldr	r3, [r3, #0]
 80165bc:	1c5a      	adds	r2, r3, #1
 80165be:	4b0f      	ldr	r3, [pc, #60]	; (80165fc <theCounterThread+0x1bc>)
 80165c0:	601a      	str	r2, [r3, #0]
          break;
 80165c2:	bf00      	nop
        }
        sleep_counts += 1;
        chThdSleepMilliseconds(1);
      }
      chprintf((BaseSequentialStream *) &SD5, "Incremented: %d\n\r", trigger_count);    
 80165c4:	4b0d      	ldr	r3, [pc, #52]	; (80165fc <theCounterThread+0x1bc>)
 80165c6:	681b      	ldr	r3, [r3, #0]
 80165c8:	480a      	ldr	r0, [pc, #40]	; (80165f4 <theCounterThread+0x1b4>)
 80165ca:	490d      	ldr	r1, [pc, #52]	; (8016600 <theCounterThread+0x1c0>)
 80165cc:	461a      	mov	r2, r3
 80165ce:	f7fb f857 	bl	8011680 <chprintf>
 80165d2:	e006      	b.n	80165e2 <theCounterThread+0x1a2>
          }
        } else{
          trigger_count++;
          break;
        }
        sleep_counts += 1;
 80165d4:	9b04      	ldr	r3, [sp, #16]
 80165d6:	3301      	adds	r3, #1
 80165d8:	9304      	str	r3, [sp, #16]
        chThdSleepMilliseconds(1);
 80165da:	2001      	movs	r0, #1
 80165dc:	f7ea fe78 	bl	80012d0 <chThdSleep>
      }
 80165e0:	e79d      	b.n	801651e <theCounterThread+0xde>
      chprintf((BaseSequentialStream *) &SD5, "Incremented: %d\n\r", trigger_count);    
    } 
    chThdSleepMilliseconds(100);
 80165e2:	2064      	movs	r0, #100	; 0x64
 80165e4:	f7ea fe74 	bl	80012d0 <chThdSleep>

    }
 80165e8:	e738      	b.n	801645c <theCounterThread+0x1c>
 80165ea:	bf00      	nop
 80165ec:	080195b4 	.word	0x080195b4
 80165f0:	20001090 	.word	0x20001090
 80165f4:	20001b20 	.word	0x20001b20
 80165f8:	080195bc 	.word	0x080195bc
 80165fc:	2000222c 	.word	0x2000222c
 8016600:	080195c8 	.word	0x080195c8
 8016604:	f3af 8000 	nop.w
 8016608:	f3af 8000 	nop.w
 801660c:	f3af 8000 	nop.w

08016610 <convert_axes>:
}

// brings Z axis down an order of magnitude for conditional purposes
static void convert_axes(void){

  a_data[2] -= 1000;
 8016610:	4b07      	ldr	r3, [pc, #28]	; (8016630 <convert_axes+0x20>)
 8016612:	689b      	ldr	r3, [r3, #8]
 8016614:	f5a3 727a 	sub.w	r2, r3, #1000	; 0x3e8
 8016618:	4b05      	ldr	r3, [pc, #20]	; (8016630 <convert_axes+0x20>)
 801661a:	609a      	str	r2, [r3, #8]
  a_data[2] = abs(a_data[2]);
 801661c:	4b04      	ldr	r3, [pc, #16]	; (8016630 <convert_axes+0x20>)
 801661e:	689b      	ldr	r3, [r3, #8]
 8016620:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 8016624:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
 8016628:	4b01      	ldr	r3, [pc, #4]	; (8016630 <convert_axes+0x20>)
 801662a:	609a      	str	r2, [r3, #8]

}
 801662c:	4770      	bx	lr
 801662e:	bf00      	nop
 8016630:	20001090 	.word	0x20001090
 8016634:	f3af 8000 	nop.w
 8016638:	f3af 8000 	nop.w
 801663c:	f3af 8000 	nop.w

08016640 <cmd_myecho>:

static void cmd_myecho(BaseSequentialStream *chp, int argc, char *argv[]) {
 8016640:	b500      	push	{lr}
 8016642:	b087      	sub	sp, #28
 8016644:	9003      	str	r0, [sp, #12]
 8016646:	9102      	str	r1, [sp, #8]
 8016648:	9201      	str	r2, [sp, #4]
  int32_t i;

  (void)argv;


  for (i=0;i<argc;i++) {
 801664a:	2300      	movs	r3, #0
 801664c:	9305      	str	r3, [sp, #20]
 801664e:	e00c      	b.n	801666a <cmd_myecho+0x2a>
    chprintf(chp, "%s\n\r", argv[i]);
 8016650:	9b05      	ldr	r3, [sp, #20]
 8016652:	009b      	lsls	r3, r3, #2
 8016654:	9a01      	ldr	r2, [sp, #4]
 8016656:	4413      	add	r3, r2
 8016658:	681b      	ldr	r3, [r3, #0]
 801665a:	9803      	ldr	r0, [sp, #12]
 801665c:	4906      	ldr	r1, [pc, #24]	; (8016678 <cmd_myecho+0x38>)
 801665e:	461a      	mov	r2, r3
 8016660:	f7fb f80e 	bl	8011680 <chprintf>
  int32_t i;

  (void)argv;


  for (i=0;i<argc;i++) {
 8016664:	9b05      	ldr	r3, [sp, #20]
 8016666:	3301      	adds	r3, #1
 8016668:	9305      	str	r3, [sp, #20]
 801666a:	9a05      	ldr	r2, [sp, #20]
 801666c:	9b02      	ldr	r3, [sp, #8]
 801666e:	429a      	cmp	r2, r3
 8016670:	dbee      	blt.n	8016650 <cmd_myecho+0x10>
    chprintf(chp, "%s\n\r", argv[i]);
  }
}
 8016672:	b007      	add	sp, #28
 8016674:	f85d fb04 	ldr.w	pc, [sp], #4
 8016678:	080195dc 	.word	0x080195dc
 801667c:	f3af 8000 	nop.w

08016680 <cmd_accel_test>:


// function that controls a read_state variable, that controls whether or not the accel values are being printed or not
static void cmd_accel_test(BaseSequentialStream *chp, int argc, char *argv[]){
 8016680:	b084      	sub	sp, #16
 8016682:	9003      	str	r0, [sp, #12]
 8016684:	9102      	str	r1, [sp, #8]
 8016686:	9201      	str	r2, [sp, #4]
  UNUSED(argc);
  UNUSED(argv);
  UNUSED(chp);  

  read_state = !read_state;
 8016688:	4b05      	ldr	r3, [pc, #20]	; (80166a0 <cmd_accel_test+0x20>)
 801668a:	681b      	ldr	r3, [r3, #0]
 801668c:	2b00      	cmp	r3, #0
 801668e:	bf14      	ite	ne
 8016690:	2300      	movne	r3, #0
 8016692:	2301      	moveq	r3, #1
 8016694:	b2db      	uxtb	r3, r3
 8016696:	461a      	mov	r2, r3
 8016698:	4b01      	ldr	r3, [pc, #4]	; (80166a0 <cmd_accel_test+0x20>)
 801669a:	601a      	str	r2, [r3, #0]

}
 801669c:	b004      	add	sp, #16
 801669e:	4770      	bx	lr
 80166a0:	20002230 	.word	0x20002230
 80166a4:	f3af 8000 	nop.w
 80166a8:	f3af 8000 	nop.w
 80166ac:	f3af 8000 	nop.w

080166b0 <cmd_display_counts>:


// displays all of the counts stored from the beginning to where it is now
static void cmd_display_counts(BaseSequentialStream *chp, int argc, char *argv[]){
 80166b0:	b500      	push	{lr}
 80166b2:	b087      	sub	sp, #28
 80166b4:	9003      	str	r0, [sp, #12]
 80166b6:	9102      	str	r1, [sp, #8]
 80166b8:	9201      	str	r2, [sp, #4]
  UNUSED(argv);
  int i;


  
  if(timer_index == 0) chprintf(chp, "1 minute has yet to pass.\n\r");
 80166ba:	4b11      	ldr	r3, [pc, #68]	; (8016700 <cmd_display_counts+0x50>)
 80166bc:	681b      	ldr	r3, [r3, #0]
 80166be:	2b00      	cmp	r3, #0
 80166c0:	d104      	bne.n	80166cc <cmd_display_counts+0x1c>
 80166c2:	9803      	ldr	r0, [sp, #12]
 80166c4:	490f      	ldr	r1, [pc, #60]	; (8016704 <cmd_display_counts+0x54>)
 80166c6:	f7fa ffdb 	bl	8011680 <chprintf>
 80166ca:	e015      	b.n	80166f8 <cmd_display_counts+0x48>
  else{
    for(i = 0; i < timer_index; i++){
 80166cc:	2300      	movs	r3, #0
 80166ce:	9305      	str	r3, [sp, #20]
 80166d0:	e00d      	b.n	80166ee <cmd_display_counts+0x3e>
      chprintf(chp, "Minute: %d | Count: %d\n\r", i+1, time_stamp[i]); // timestamp[i] = time_stamp.count || timestamp[i] = timestamp[i - 1].count; time_stamp[i].count, time_stamp[i].time
 80166d2:	9b05      	ldr	r3, [sp, #20]
 80166d4:	1c5a      	adds	r2, r3, #1
 80166d6:	4b0c      	ldr	r3, [pc, #48]	; (8016708 <cmd_display_counts+0x58>)
 80166d8:	9905      	ldr	r1, [sp, #20]
 80166da:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 80166de:	b29b      	uxth	r3, r3
 80166e0:	9803      	ldr	r0, [sp, #12]
 80166e2:	490a      	ldr	r1, [pc, #40]	; (801670c <cmd_display_counts+0x5c>)
 80166e4:	f7fa ffcc 	bl	8011680 <chprintf>


  
  if(timer_index == 0) chprintf(chp, "1 minute has yet to pass.\n\r");
  else{
    for(i = 0; i < timer_index; i++){
 80166e8:	9b05      	ldr	r3, [sp, #20]
 80166ea:	3301      	adds	r3, #1
 80166ec:	9305      	str	r3, [sp, #20]
 80166ee:	4b04      	ldr	r3, [pc, #16]	; (8016700 <cmd_display_counts+0x50>)
 80166f0:	681b      	ldr	r3, [r3, #0]
 80166f2:	9a05      	ldr	r2, [sp, #20]
 80166f4:	429a      	cmp	r2, r3
 80166f6:	dbec      	blt.n	80166d2 <cmd_display_counts+0x22>
      chprintf(chp, "Minute: %d | Count: %d\n\r", i+1, time_stamp[i]); // timestamp[i] = time_stamp.count || timestamp[i] = timestamp[i - 1].count; time_stamp[i].count, time_stamp[i].time
    }
  }
  

}
 80166f8:	b007      	add	sp, #28
 80166fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80166fe:	bf00      	nop
 8016700:	200010ac 	.word	0x200010ac
 8016704:	080195e4 	.word	0x080195e4
 8016708:	08018a40 	.word	0x08018a40
 801670c:	08019600 	.word	0x08019600

08016710 <parse_args>:


// This function converts the arguments into a character array for strtok 
static void parse_args(int argc, char *argv[], char destination[]){
 8016710:	b500      	push	{lr}
 8016712:	b087      	sub	sp, #28
 8016714:	9003      	str	r0, [sp, #12]
 8016716:	9102      	str	r1, [sp, #8]
 8016718:	9201      	str	r2, [sp, #4]

  //chprintf((BaseSequentialStream *) &SD5, "%s\n\r", argv[0]);

  int i, j;

  for(j = 0; j < argc; j++){
 801671a:	2300      	movs	r3, #0
 801671c:	9304      	str	r3, [sp, #16]
 801671e:	e023      	b.n	8016768 <parse_args+0x58>
    for(i = 0; i < (int)strlen(argv[j]); i++){
 8016720:	2300      	movs	r3, #0
 8016722:	9305      	str	r3, [sp, #20]
 8016724:	e010      	b.n	8016748 <parse_args+0x38>
      //chprintf((BaseSequentialStream *) &SD5, "%c\n\r", argv[j][i]);
      destination[j+i] = argv[j][i]; 
 8016726:	9a04      	ldr	r2, [sp, #16]
 8016728:	9b05      	ldr	r3, [sp, #20]
 801672a:	4413      	add	r3, r2
 801672c:	9a01      	ldr	r2, [sp, #4]
 801672e:	4413      	add	r3, r2
 8016730:	9a04      	ldr	r2, [sp, #16]
 8016732:	0092      	lsls	r2, r2, #2
 8016734:	9902      	ldr	r1, [sp, #8]
 8016736:	440a      	add	r2, r1
 8016738:	6811      	ldr	r1, [r2, #0]
 801673a:	9a05      	ldr	r2, [sp, #20]
 801673c:	440a      	add	r2, r1
 801673e:	7812      	ldrb	r2, [r2, #0]
 8016740:	701a      	strb	r2, [r3, #0]
  //chprintf((BaseSequentialStream *) &SD5, "%s\n\r", argv[0]);

  int i, j;

  for(j = 0; j < argc; j++){
    for(i = 0; i < (int)strlen(argv[j]); i++){
 8016742:	9b05      	ldr	r3, [sp, #20]
 8016744:	3301      	adds	r3, #1
 8016746:	9305      	str	r3, [sp, #20]
 8016748:	9b04      	ldr	r3, [sp, #16]
 801674a:	009b      	lsls	r3, r3, #2
 801674c:	9a02      	ldr	r2, [sp, #8]
 801674e:	4413      	add	r3, r2
 8016750:	681b      	ldr	r3, [r3, #0]
 8016752:	4618      	mov	r0, r3
 8016754:	f000 fea4 	bl	80174a0 <strlen>
 8016758:	4603      	mov	r3, r0
 801675a:	461a      	mov	r2, r3
 801675c:	9b05      	ldr	r3, [sp, #20]
 801675e:	429a      	cmp	r2, r3
 8016760:	dce1      	bgt.n	8016726 <parse_args+0x16>

  //chprintf((BaseSequentialStream *) &SD5, "%s\n\r", argv[0]);

  int i, j;

  for(j = 0; j < argc; j++){
 8016762:	9b04      	ldr	r3, [sp, #16]
 8016764:	3301      	adds	r3, #1
 8016766:	9304      	str	r3, [sp, #16]
 8016768:	9a04      	ldr	r2, [sp, #16]
 801676a:	9b03      	ldr	r3, [sp, #12]
 801676c:	429a      	cmp	r2, r3
 801676e:	dbd7      	blt.n	8016720 <parse_args+0x10>
    for(i = 0; i < (int)strlen(argv[j]); i++){
      //chprintf((BaseSequentialStream *) &SD5, "%c\n\r", argv[j][i]);
      destination[j+i] = argv[j][i]; 
    }
  }  
}
 8016770:	b007      	add	sp, #28
 8016772:	f85d fb04 	ldr.w	pc, [sp], #4
 8016776:	bf00      	nop
 8016778:	f3af 8000 	nop.w
 801677c:	f3af 8000 	nop.w

08016780 <cmd_set_time>:


// calibrates the RTC with user input 
static void cmd_set_time(BaseSequentialStream *chp, int argc, char *argv[]){
 8016780:	b500      	push	{lr}
 8016782:	b091      	sub	sp, #68	; 0x44
 8016784:	9003      	str	r0, [sp, #12]
 8016786:	9102      	str	r1, [sp, #8]
 8016788:	9201      	str	r2, [sp, #4]
  UNUSED(argc);
  UNUSED(chp);

  char destination[36];
 
  parse_args(argc, argv, destination);
 801678a:	ab06      	add	r3, sp, #24
 801678c:	9802      	ldr	r0, [sp, #8]
 801678e:	9901      	ldr	r1, [sp, #4]
 8016790:	461a      	mov	r2, r3
 8016792:	f7ff ffbd 	bl	8016710 <parse_args>

  int x;
  for(x = 0; x < (int)sizeof(destination); x++){
 8016796:	2300      	movs	r3, #0
 8016798:	930f      	str	r3, [sp, #60]	; 0x3c
 801679a:	e00b      	b.n	80167b4 <cmd_set_time+0x34>
   chprintf(chp, "%c", destination[x]);
 801679c:	aa06      	add	r2, sp, #24
 801679e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80167a0:	4413      	add	r3, r2
 80167a2:	781b      	ldrb	r3, [r3, #0]
 80167a4:	9803      	ldr	r0, [sp, #12]
 80167a6:	4953      	ldr	r1, [pc, #332]	; (80168f4 <cmd_set_time+0x174>)
 80167a8:	461a      	mov	r2, r3
 80167aa:	f7fa ff69 	bl	8011680 <chprintf>
  char destination[36];
 
  parse_args(argc, argv, destination);

  int x;
  for(x = 0; x < (int)sizeof(destination); x++){
 80167ae:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80167b0:	3301      	adds	r3, #1
 80167b2:	930f      	str	r3, [sp, #60]	; 0x3c
 80167b4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80167b6:	2b23      	cmp	r3, #35	; 0x23
 80167b8:	ddf0      	ble.n	801679c <cmd_set_time+0x1c>
   chprintf(chp, "%c", destination[x]);
  }

  chprintf(chp, "\n\r");
 80167ba:	9803      	ldr	r0, [sp, #12]
 80167bc:	494e      	ldr	r1, [pc, #312]	; (80168f8 <cmd_set_time+0x178>)
 80167be:	f7fa ff5f 	bl	8011680 <chprintf>


  char delim[2] = "/";
 80167c2:	232f      	movs	r3, #47	; 0x2f
 80167c4:	f8ad 3014 	strh.w	r3, [sp, #20]
  char *token;
  UNUSED(token);

  // begins converting key 
  starting_time.year = atoi(strtok(destination,delim)); // str instead of argv
 80167c8:	aa06      	add	r2, sp, #24
 80167ca:	ab05      	add	r3, sp, #20
 80167cc:	4610      	mov	r0, r2
 80167ce:	4619      	mov	r1, r3
 80167d0:	f000 fede 	bl	8017590 <strtok>
 80167d4:	4603      	mov	r3, r0
 80167d6:	4618      	mov	r0, r3
 80167d8:	f000 fe02 	bl	80173e0 <atoi>
 80167dc:	4603      	mov	r3, r0
 80167de:	b2d9      	uxtb	r1, r3
 80167e0:	4a46      	ldr	r2, [pc, #280]	; (80168fc <cmd_set_time+0x17c>)
 80167e2:	7813      	ldrb	r3, [r2, #0]
 80167e4:	f361 0307 	bfi	r3, r1, #0, #8
 80167e8:	7013      	strb	r3, [r2, #0]
  chprintf(chp, "year: %u ", starting_time.year);
 80167ea:	4b44      	ldr	r3, [pc, #272]	; (80168fc <cmd_set_time+0x17c>)
 80167ec:	781b      	ldrb	r3, [r3, #0]
 80167ee:	9803      	ldr	r0, [sp, #12]
 80167f0:	4943      	ldr	r1, [pc, #268]	; (8016900 <cmd_set_time+0x180>)
 80167f2:	461a      	mov	r2, r3
 80167f4:	f7fa ff44 	bl	8011680 <chprintf>
  starting_time.month = atoi(strtok(NULL,delim));
 80167f8:	ab05      	add	r3, sp, #20
 80167fa:	2000      	movs	r0, #0
 80167fc:	4619      	mov	r1, r3
 80167fe:	f000 fec7 	bl	8017590 <strtok>
 8016802:	4603      	mov	r3, r0
 8016804:	4618      	mov	r0, r3
 8016806:	f000 fdeb 	bl	80173e0 <atoi>
 801680a:	4603      	mov	r3, r0
 801680c:	b2db      	uxtb	r3, r3
 801680e:	f003 030f 	and.w	r3, r3, #15
 8016812:	b2d9      	uxtb	r1, r3
 8016814:	4a39      	ldr	r2, [pc, #228]	; (80168fc <cmd_set_time+0x17c>)
 8016816:	7853      	ldrb	r3, [r2, #1]
 8016818:	f361 0303 	bfi	r3, r1, #0, #4
 801681c:	7053      	strb	r3, [r2, #1]
  chprintf(chp, "mon: %u ", starting_time.month);
 801681e:	4b37      	ldr	r3, [pc, #220]	; (80168fc <cmd_set_time+0x17c>)
 8016820:	785b      	ldrb	r3, [r3, #1]
 8016822:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8016826:	b2db      	uxtb	r3, r3
 8016828:	9803      	ldr	r0, [sp, #12]
 801682a:	4936      	ldr	r1, [pc, #216]	; (8016904 <cmd_set_time+0x184>)
 801682c:	461a      	mov	r2, r3
 801682e:	f7fa ff27 	bl	8011680 <chprintf>
  starting_time.day = atoi(strtok(NULL,delim));
 8016832:	ab05      	add	r3, sp, #20
 8016834:	2000      	movs	r0, #0
 8016836:	4619      	mov	r1, r3
 8016838:	f000 feaa 	bl	8017590 <strtok>
 801683c:	4603      	mov	r3, r0
 801683e:	4618      	mov	r0, r3
 8016840:	f000 fdce 	bl	80173e0 <atoi>
 8016844:	4603      	mov	r3, r0
 8016846:	b2db      	uxtb	r3, r3
 8016848:	f003 031f 	and.w	r3, r3, #31
 801684c:	b2d9      	uxtb	r1, r3
 801684e:	4a2b      	ldr	r2, [pc, #172]	; (80168fc <cmd_set_time+0x17c>)
 8016850:	7893      	ldrb	r3, [r2, #2]
 8016852:	f361 0304 	bfi	r3, r1, #0, #5
 8016856:	7093      	strb	r3, [r2, #2]
  chprintf(chp, "day: %u ", starting_time.day);
 8016858:	4b28      	ldr	r3, [pc, #160]	; (80168fc <cmd_set_time+0x17c>)
 801685a:	789b      	ldrb	r3, [r3, #2]
 801685c:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8016860:	b2db      	uxtb	r3, r3
 8016862:	9803      	ldr	r0, [sp, #12]
 8016864:	4928      	ldr	r1, [pc, #160]	; (8016908 <cmd_set_time+0x188>)
 8016866:	461a      	mov	r2, r3
 8016868:	f7fa ff0a 	bl	8011680 <chprintf>
  starting_time.dayofweek = atoi(strtok(NULL,delim));
 801686c:	ab05      	add	r3, sp, #20
 801686e:	2000      	movs	r0, #0
 8016870:	4619      	mov	r1, r3
 8016872:	f000 fe8d 	bl	8017590 <strtok>
 8016876:	4603      	mov	r3, r0
 8016878:	4618      	mov	r0, r3
 801687a:	f000 fdb1 	bl	80173e0 <atoi>
 801687e:	4603      	mov	r3, r0
 8016880:	b2db      	uxtb	r3, r3
 8016882:	f003 0307 	and.w	r3, r3, #7
 8016886:	b2d9      	uxtb	r1, r3
 8016888:	4a1c      	ldr	r2, [pc, #112]	; (80168fc <cmd_set_time+0x17c>)
 801688a:	7853      	ldrb	r3, [r2, #1]
 801688c:	f361 1347 	bfi	r3, r1, #5, #3
 8016890:	7053      	strb	r3, [r2, #1]
  chprintf(chp, "dow: %u ", starting_time.dayofweek);
 8016892:	4b1a      	ldr	r3, [pc, #104]	; (80168fc <cmd_set_time+0x17c>)
 8016894:	785b      	ldrb	r3, [r3, #1]
 8016896:	f3c3 1342 	ubfx	r3, r3, #5, #3
 801689a:	b2db      	uxtb	r3, r3
 801689c:	9803      	ldr	r0, [sp, #12]
 801689e:	491b      	ldr	r1, [pc, #108]	; (801690c <cmd_set_time+0x18c>)
 80168a0:	461a      	mov	r2, r3
 80168a2:	f7fa feed 	bl	8011680 <chprintf>
  starting_time.millisecond = atoi(strtok(NULL,delim));
 80168a6:	ab05      	add	r3, sp, #20
 80168a8:	2000      	movs	r0, #0
 80168aa:	4619      	mov	r1, r3
 80168ac:	f000 fe70 	bl	8017590 <strtok>
 80168b0:	4603      	mov	r3, r0
 80168b2:	4618      	mov	r0, r3
 80168b4:	f000 fd94 	bl	80173e0 <atoi>
 80168b8:	4603      	mov	r3, r0
 80168ba:	f023 4178 	bic.w	r1, r3, #4160749568	; 0xf8000000
 80168be:	4a0f      	ldr	r2, [pc, #60]	; (80168fc <cmd_set_time+0x17c>)
 80168c0:	6853      	ldr	r3, [r2, #4]
 80168c2:	f361 031a 	bfi	r3, r1, #0, #27
 80168c6:	6053      	str	r3, [r2, #4]
  chprintf(chp, "ms: %u\n\r", starting_time.millisecond);
 80168c8:	4b0c      	ldr	r3, [pc, #48]	; (80168fc <cmd_set_time+0x17c>)
 80168ca:	685b      	ldr	r3, [r3, #4]
 80168cc:	f3c3 031a 	ubfx	r3, r3, #0, #27
 80168d0:	9803      	ldr	r0, [sp, #12]
 80168d2:	490f      	ldr	r1, [pc, #60]	; (8016910 <cmd_set_time+0x190>)
 80168d4:	461a      	mov	r2, r3
 80168d6:	f7fa fed3 	bl	8011680 <chprintf>

  rtcSetTime(&RTCD1, &starting_time);
 80168da:	480e      	ldr	r0, [pc, #56]	; (8016914 <cmd_set_time+0x194>)
 80168dc:	4907      	ldr	r1, [pc, #28]	; (80168fc <cmd_set_time+0x17c>)
 80168de:	f7ee fbcf 	bl	8005080 <rtcSetTime>
  remember_time = starting_time;
 80168e2:	4b0d      	ldr	r3, [pc, #52]	; (8016918 <cmd_set_time+0x198>)
 80168e4:	4a05      	ldr	r2, [pc, #20]	; (80168fc <cmd_set_time+0x17c>)
 80168e6:	e892 0003 	ldmia.w	r2, {r0, r1}
 80168ea:	e883 0003 	stmia.w	r3, {r0, r1}

}
 80168ee:	b011      	add	sp, #68	; 0x44
 80168f0:	f85d fb04 	ldr.w	pc, [sp], #4
 80168f4:	0801961c 	.word	0x0801961c
 80168f8:	08019620 	.word	0x08019620
 80168fc:	2000109c 	.word	0x2000109c
 8016900:	08019624 	.word	0x08019624
 8016904:	08019630 	.word	0x08019630
 8016908:	0801963c 	.word	0x0801963c
 801690c:	08019648 	.word	0x08019648
 8016910:	08019654 	.word	0x08019654
 8016914:	20001a70 	.word	0x20001a70
 8016918:	200010a4 	.word	0x200010a4
 801691c:	f3af 8000 	nop.w

08016920 <cmd_get_time>:

// retrieves the RTC values from the data structure 

static void cmd_get_time(BaseSequentialStream *chp, int argc, char *argv[]){
 8016920:	b530      	push	{r4, r5, lr}
 8016922:	b089      	sub	sp, #36	; 0x24
 8016924:	9007      	str	r0, [sp, #28]
 8016926:	9106      	str	r1, [sp, #24]
 8016928:	9205      	str	r2, [sp, #20]

  UNUSED(argc);
  UNUSED(argv);


  rtcGetTime(&RTCD1, &starting_time);
 801692a:	4816      	ldr	r0, [pc, #88]	; (8016984 <cmd_get_time+0x64>)
 801692c:	4916      	ldr	r1, [pc, #88]	; (8016988 <cmd_get_time+0x68>)
 801692e:	f7ee fbb7 	bl	80050a0 <rtcGetTime>
  chprintf(chp, "Year: %d | Month: %d | Day: %d | Day of Week: %d | Seconds: %d\n\r", 
    starting_time.year, starting_time.month, starting_time.day, starting_time.dayofweek,
 8016932:	4b15      	ldr	r3, [pc, #84]	; (8016988 <cmd_get_time+0x68>)
 8016934:	781b      	ldrb	r3, [r3, #0]
  UNUSED(argc);
  UNUSED(argv);


  rtcGetTime(&RTCD1, &starting_time);
  chprintf(chp, "Year: %d | Month: %d | Day: %d | Day of Week: %d | Seconds: %d\n\r", 
 8016936:	461a      	mov	r2, r3
    starting_time.year, starting_time.month, starting_time.day, starting_time.dayofweek,
 8016938:	4b13      	ldr	r3, [pc, #76]	; (8016988 <cmd_get_time+0x68>)
 801693a:	785b      	ldrb	r3, [r3, #1]
 801693c:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8016940:	b2db      	uxtb	r3, r3
  UNUSED(argc);
  UNUSED(argv);


  rtcGetTime(&RTCD1, &starting_time);
  chprintf(chp, "Year: %d | Month: %d | Day: %d | Day of Week: %d | Seconds: %d\n\r", 
 8016942:	461c      	mov	r4, r3
    starting_time.year, starting_time.month, starting_time.day, starting_time.dayofweek,
 8016944:	4b10      	ldr	r3, [pc, #64]	; (8016988 <cmd_get_time+0x68>)
 8016946:	789b      	ldrb	r3, [r3, #2]
 8016948:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801694c:	b2db      	uxtb	r3, r3
  UNUSED(argc);
  UNUSED(argv);


  rtcGetTime(&RTCD1, &starting_time);
  chprintf(chp, "Year: %d | Month: %d | Day: %d | Day of Week: %d | Seconds: %d\n\r", 
 801694e:	4618      	mov	r0, r3
    starting_time.year, starting_time.month, starting_time.day, starting_time.dayofweek,
 8016950:	4b0d      	ldr	r3, [pc, #52]	; (8016988 <cmd_get_time+0x68>)
 8016952:	785b      	ldrb	r3, [r3, #1]
 8016954:	f3c3 1342 	ubfx	r3, r3, #5, #3
 8016958:	b2db      	uxtb	r3, r3
  UNUSED(argc);
  UNUSED(argv);


  rtcGetTime(&RTCD1, &starting_time);
  chprintf(chp, "Year: %d | Month: %d | Day: %d | Day of Week: %d | Seconds: %d\n\r", 
 801695a:	4619      	mov	r1, r3
    starting_time.year, starting_time.month, starting_time.day, starting_time.dayofweek,
    starting_time.millisecond/1000);
 801695c:	4b0a      	ldr	r3, [pc, #40]	; (8016988 <cmd_get_time+0x68>)
 801695e:	685b      	ldr	r3, [r3, #4]
 8016960:	f3c3 031a 	ubfx	r3, r3, #0, #27
  UNUSED(argc);
  UNUSED(argv);


  rtcGetTime(&RTCD1, &starting_time);
  chprintf(chp, "Year: %d | Month: %d | Day: %d | Day of Week: %d | Seconds: %d\n\r", 
 8016964:	4d09      	ldr	r5, [pc, #36]	; (801698c <cmd_get_time+0x6c>)
 8016966:	fb85 c503 	smull	ip, r5, r5, r3
 801696a:	11ad      	asrs	r5, r5, #6
 801696c:	17db      	asrs	r3, r3, #31
 801696e:	1aeb      	subs	r3, r5, r3
 8016970:	9000      	str	r0, [sp, #0]
 8016972:	9101      	str	r1, [sp, #4]
 8016974:	9302      	str	r3, [sp, #8]
 8016976:	9807      	ldr	r0, [sp, #28]
 8016978:	4905      	ldr	r1, [pc, #20]	; (8016990 <cmd_get_time+0x70>)
 801697a:	4623      	mov	r3, r4
 801697c:	f7fa fe80 	bl	8011680 <chprintf>
    starting_time.year, starting_time.month, starting_time.day, starting_time.dayofweek,
    starting_time.millisecond/1000);

}
 8016980:	b009      	add	sp, #36	; 0x24
 8016982:	bd30      	pop	{r4, r5, pc}
 8016984:	20001a70 	.word	0x20001a70
 8016988:	2000109c 	.word	0x2000109c
 801698c:	10624dd3 	.word	0x10624dd3
 8016990:	08019660 	.word	0x08019660
 8016994:	f3af 8000 	nop.w
 8016998:	f3af 8000 	nop.w
 801699c:	f3af 8000 	nop.w

080169a0 <main>:

/*
 * Application entry point.
 */

int main(void) {
 80169a0:	b500      	push	{lr}
 80169a2:	b083      	sub	sp, #12
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  static thread_t *shelltp = NULL;

  halInit();
 80169a4:	f7ed f914 	bl	8003bd0 <halInit>
  chSysInit();
 80169a8:	f7e9 fe7a 	bl	80006a0 <chSysInit>

  LSM303AGR_ACC_Init(); // Initialize the Accelerometer 
 80169ac:	f7fb fc58 	bl	8012260 <LSM303AGR_ACC_Init>
  LSM303AGR_ACC_W_HiRes(NULL, LSM303AGR_ACC_HR_ENABLED);  // enables high-resolution mode
 80169b0:	2000      	movs	r0, #0
 80169b2:	2108      	movs	r1, #8
 80169b4:	f7fc ff6c 	bl	8013890 <LSM303AGR_ACC_W_HiRes>
  LSM303AGR_ACC_W_ODR(NULL, LSM303AGR_ACC_ODR_DO_100Hz);  // sets the data rate to 100Hz
 80169b8:	2000      	movs	r0, #0
 80169ba:	2150      	movs	r1, #80	; 0x50
 80169bc:	f7fb feb8 	bl	8012730 <LSM303AGR_ACC_W_ODR>

  /*
   * Activates the serial driver 5 using the driver default configuration.
   * PC12(TX) and PD2(RX). The default baud rate is 38400.
   */
  sdStart(&SD5, NULL);
 80169c0:	4828      	ldr	r0, [pc, #160]	; (8016a64 <main+0xc4>)
 80169c2:	2100      	movs	r1, #0
 80169c4:	f7ef fc24 	bl	8006210 <sdStart>
  chprintf((BaseSequentialStream*)&SD5, "\n\rUp and Running\n\r");
 80169c8:	4826      	ldr	r0, [pc, #152]	; (8016a64 <main+0xc4>)
 80169ca:	4927      	ldr	r1, [pc, #156]	; (8016a68 <main+0xc8>)
 80169cc:	f7fa fe58 	bl	8011680 <chprintf>

  /* Initialize the command shell */ 
  shellInit();
 80169d0:	f7fb f8de 	bl	8011b90 <shellInit>
  chThdCreateStatic(throttleThread, sizeof(throttleThread), NORMALPRIO+1, throttleCount, NULL);
 80169d4:	2300      	movs	r3, #0
 80169d6:	9300      	str	r3, [sp, #0]
 80169d8:	4824      	ldr	r0, [pc, #144]	; (8016a6c <main+0xcc>)
 80169da:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 80169de:	2241      	movs	r2, #65	; 0x41
 80169e0:	4b23      	ldr	r3, [pc, #140]	; (8016a70 <main+0xd0>)
 80169e2:	f7ea fbfd 	bl	80011e0 <chThdCreateStatic>
  chThdCreateStatic(waCounterThread, sizeof(waCounterThread), NORMALPRIO+1, counterThread, NULL);
 80169e6:	2300      	movs	r3, #0
 80169e8:	9300      	str	r3, [sp, #0]
 80169ea:	4822      	ldr	r0, [pc, #136]	; (8016a74 <main+0xd4>)
 80169ec:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80169f0:	2241      	movs	r2, #65	; 0x41
 80169f2:	4b21      	ldr	r3, [pc, #132]	; (8016a78 <main+0xd8>)
 80169f4:	f7ea fbf4 	bl	80011e0 <chThdCreateStatic>
  chThdCreateStatic(accelCounterThread, sizeof(accelCounterThread), NORMALPRIO+1, theCounterThread, NULL);
 80169f8:	2300      	movs	r3, #0
 80169fa:	9300      	str	r3, [sp, #0]
 80169fc:	481f      	ldr	r0, [pc, #124]	; (8016a7c <main+0xdc>)
 80169fe:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 8016a02:	2241      	movs	r2, #65	; 0x41
 8016a04:	4b1e      	ldr	r3, [pc, #120]	; (8016a80 <main+0xe0>)
 8016a06:	f7ea fbeb 	bl	80011e0 <chThdCreateStatic>
  chThdCreateStatic(timeStampThread, sizeof(timeStampThread), NORMALPRIO+1, timeStamp, NULL);
 8016a0a:	2300      	movs	r3, #0
 8016a0c:	9300      	str	r3, [sp, #0]
 8016a0e:	481d      	ldr	r0, [pc, #116]	; (8016a84 <main+0xe4>)
 8016a10:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8016a14:	2241      	movs	r2, #65	; 0x41
 8016a16:	4b1c      	ldr	r3, [pc, #112]	; (8016a88 <main+0xe8>)
 8016a18:	f7ea fbe2 	bl	80011e0 <chThdCreateStatic>

  while (TRUE) {
    if (!shelltp) {
 8016a1c:	4b1b      	ldr	r3, [pc, #108]	; (8016a8c <main+0xec>)
 8016a1e:	681b      	ldr	r3, [r3, #0]
 8016a20:	2b00      	cmp	r3, #0
 8016a22:	d109      	bne.n	8016a38 <main+0x98>
      shelltp = shellCreate(&shell_cfg1, SHELL_WA_SIZE, NORMALPRIO);
 8016a24:	481a      	ldr	r0, [pc, #104]	; (8016a90 <main+0xf0>)
 8016a26:	f640 01c8 	movw	r1, #2248	; 0x8c8
 8016a2a:	2240      	movs	r2, #64	; 0x40
 8016a2c:	f7fb f8c8 	bl	8011bc0 <shellCreate>
 8016a30:	4602      	mov	r2, r0
 8016a32:	4b16      	ldr	r3, [pc, #88]	; (8016a8c <main+0xec>)
 8016a34:	601a      	str	r2, [r3, #0]
 8016a36:	e00f      	b.n	8016a58 <main+0xb8>
    }
    else if (chThdTerminatedX(shelltp)) {
 8016a38:	4b14      	ldr	r3, [pc, #80]	; (8016a8c <main+0xec>)
 8016a3a:	681b      	ldr	r3, [r3, #0]
 8016a3c:	4618      	mov	r0, r3
 8016a3e:	f7ff fc4f 	bl	80162e0 <chThdTerminatedX>
 8016a42:	4603      	mov	r3, r0
 8016a44:	2b00      	cmp	r3, #0
 8016a46:	d007      	beq.n	8016a58 <main+0xb8>
     chThdRelease(shelltp);    /* Recovers memory of the previous shell.   */
 8016a48:	4b10      	ldr	r3, [pc, #64]	; (8016a8c <main+0xec>)
 8016a4a:	681b      	ldr	r3, [r3, #0]
 8016a4c:	4618      	mov	r0, r3
 8016a4e:	f7ea feb7 	bl	80017c0 <chThdRelease>
     shelltp = NULL;           /* Triggers spawning of a new shell.        */
 8016a52:	4b0e      	ldr	r3, [pc, #56]	; (8016a8c <main+0xec>)
 8016a54:	2200      	movs	r2, #0
 8016a56:	601a      	str	r2, [r3, #0]
    }
    chThdSleepMilliseconds(1000);
 8016a58:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8016a5c:	f7ea fc38 	bl	80012d0 <chThdSleep>
  }
 8016a60:	e7dc      	b.n	8016a1c <main+0x7c>
 8016a62:	bf00      	nop
 8016a64:	20001b20 	.word	0x20001b20
 8016a68:	08019714 	.word	0x08019714
 8016a6c:	20001348 	.word	0x20001348
 8016a70:	080163d1 	.word	0x080163d1
 8016a74:	200010b8 	.word	0x200010b8
 8016a78:	08016321 	.word	0x08016321
 8016a7c:	20001510 	.word	0x20001510
 8016a80:	08016441 	.word	0x08016441
 8016a84:	20001200 	.word	0x20001200
 8016a88:	080163a1 	.word	0x080163a1
 8016a8c:	200016d8 	.word	0x200016d8
 8016a90:	0801970c 	.word	0x0801970c
 8016a94:	f3af 8000 	nop.w
 8016a98:	f3af 8000 	nop.w
 8016a9c:	f3af 8000 	nop.w

08016aa0 <__aeabi_ldivmod>:
 8016aa0:	b973      	cbnz	r3, 8016ac0 <__aeabi_ldivmod+0x20>
 8016aa2:	b96a      	cbnz	r2, 8016ac0 <__aeabi_ldivmod+0x20>
 8016aa4:	2900      	cmp	r1, #0
 8016aa6:	bf08      	it	eq
 8016aa8:	2800      	cmpeq	r0, #0
 8016aaa:	bfbc      	itt	lt
 8016aac:	2000      	movlt	r0, #0
 8016aae:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
 8016ab2:	bfc4      	itt	gt
 8016ab4:	f06f 4100 	mvngt.w	r1, #2147483648	; 0x80000000
 8016ab8:	f04f 30ff 	movgt.w	r0, #4294967295
 8016abc:	f000 b840 	b.w	8016b40 <__aeabi_idiv0>
 8016ac0:	b082      	sub	sp, #8
 8016ac2:	46ec      	mov	ip, sp
 8016ac4:	e92d 5000 	stmdb	sp!, {ip, lr}
 8016ac8:	f000 f80a 	bl	8016ae0 <__gnu_ldivmod_helper>
 8016acc:	f8dd e004 	ldr.w	lr, [sp, #4]
 8016ad0:	b002      	add	sp, #8
 8016ad2:	bc0c      	pop	{r2, r3}
 8016ad4:	4770      	bx	lr
 8016ad6:	bf00      	nop
	...

08016ae0 <__gnu_ldivmod_helper>:
 8016ae0:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
 8016ae4:	9e06      	ldr	r6, [sp, #24]
 8016ae6:	4614      	mov	r4, r2
 8016ae8:	461d      	mov	r5, r3
 8016aea:	4680      	mov	r8, r0
 8016aec:	4689      	mov	r9, r1
 8016aee:	f000 f82f 	bl	8016b50 <__divdi3>
 8016af2:	fb04 f301 	mul.w	r3, r4, r1
 8016af6:	fb00 3305 	mla	r3, r0, r5, r3
 8016afa:	fba4 4500 	umull	r4, r5, r4, r0
 8016afe:	441d      	add	r5, r3
 8016b00:	ebb8 0404 	subs.w	r4, r8, r4
 8016b04:	eb69 0505 	sbc.w	r5, r9, r5
 8016b08:	e9c6 4500 	strd	r4, r5, [r6]
 8016b0c:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

08016b10 <__gnu_uldivmod_helper>:
 8016b10:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
 8016b14:	9e06      	ldr	r6, [sp, #24]
 8016b16:	4614      	mov	r4, r2
 8016b18:	4680      	mov	r8, r0
 8016b1a:	4689      	mov	r9, r1
 8016b1c:	461d      	mov	r5, r3
 8016b1e:	f000 f967 	bl	8016df0 <__udivdi3>
 8016b22:	fb00 f505 	mul.w	r5, r0, r5
 8016b26:	fb04 5301 	mla	r3, r4, r1, r5
 8016b2a:	fba0 4504 	umull	r4, r5, r0, r4
 8016b2e:	441d      	add	r5, r3
 8016b30:	ebb8 0404 	subs.w	r4, r8, r4
 8016b34:	eb69 0505 	sbc.w	r5, r9, r5
 8016b38:	e9c6 4500 	strd	r4, r5, [r6]
 8016b3c:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

08016b40 <__aeabi_idiv0>:
 8016b40:	4770      	bx	lr
 8016b42:	bf00      	nop
	...

08016b50 <__divdi3>:
 8016b50:	2900      	cmp	r1, #0
 8016b52:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8016b56:	f2c0 809f 	blt.w	8016c98 <__divdi3+0x148>
 8016b5a:	2400      	movs	r4, #0
 8016b5c:	2b00      	cmp	r3, #0
 8016b5e:	f2c0 8096 	blt.w	8016c8e <__divdi3+0x13e>
 8016b62:	4615      	mov	r5, r2
 8016b64:	4606      	mov	r6, r0
 8016b66:	460f      	mov	r7, r1
 8016b68:	2b00      	cmp	r3, #0
 8016b6a:	d13e      	bne.n	8016bea <__divdi3+0x9a>
 8016b6c:	428a      	cmp	r2, r1
 8016b6e:	d957      	bls.n	8016c20 <__divdi3+0xd0>
 8016b70:	fab2 f382 	clz	r3, r2
 8016b74:	b14b      	cbz	r3, 8016b8a <__divdi3+0x3a>
 8016b76:	f1c3 0220 	rsb	r2, r3, #32
 8016b7a:	fa01 f703 	lsl.w	r7, r1, r3
 8016b7e:	fa20 f202 	lsr.w	r2, r0, r2
 8016b82:	409d      	lsls	r5, r3
 8016b84:	4317      	orrs	r7, r2
 8016b86:	fa00 f603 	lsl.w	r6, r0, r3
 8016b8a:	0c29      	lsrs	r1, r5, #16
 8016b8c:	fbb7 f2f1 	udiv	r2, r7, r1
 8016b90:	0c33      	lsrs	r3, r6, #16
 8016b92:	fb01 7c12 	mls	ip, r1, r2, r7
 8016b96:	b2a8      	uxth	r0, r5
 8016b98:	ea43 470c 	orr.w	r7, r3, ip, lsl #16
 8016b9c:	fb00 f302 	mul.w	r3, r0, r2
 8016ba0:	42bb      	cmp	r3, r7
 8016ba2:	d909      	bls.n	8016bb8 <__divdi3+0x68>
 8016ba4:	197f      	adds	r7, r7, r5
 8016ba6:	f102 3cff 	add.w	ip, r2, #4294967295
 8016baa:	f080 8101 	bcs.w	8016db0 <__divdi3+0x260>
 8016bae:	42bb      	cmp	r3, r7
 8016bb0:	f240 80fe 	bls.w	8016db0 <__divdi3+0x260>
 8016bb4:	3a02      	subs	r2, #2
 8016bb6:	442f      	add	r7, r5
 8016bb8:	1aff      	subs	r7, r7, r3
 8016bba:	fbb7 f3f1 	udiv	r3, r7, r1
 8016bbe:	b2b6      	uxth	r6, r6
 8016bc0:	fb01 7113 	mls	r1, r1, r3, r7
 8016bc4:	ea46 4101 	orr.w	r1, r6, r1, lsl #16
 8016bc8:	fb00 f003 	mul.w	r0, r0, r3
 8016bcc:	4288      	cmp	r0, r1
 8016bce:	d908      	bls.n	8016be2 <__divdi3+0x92>
 8016bd0:	1949      	adds	r1, r1, r5
 8016bd2:	f103 37ff 	add.w	r7, r3, #4294967295
 8016bd6:	f080 80ed 	bcs.w	8016db4 <__divdi3+0x264>
 8016bda:	4288      	cmp	r0, r1
 8016bdc:	f240 80ea 	bls.w	8016db4 <__divdi3+0x264>
 8016be0:	3b02      	subs	r3, #2
 8016be2:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
 8016be6:	2300      	movs	r3, #0
 8016be8:	e003      	b.n	8016bf2 <__divdi3+0xa2>
 8016bea:	428b      	cmp	r3, r1
 8016bec:	d90a      	bls.n	8016c04 <__divdi3+0xb4>
 8016bee:	2300      	movs	r3, #0
 8016bf0:	461a      	mov	r2, r3
 8016bf2:	4610      	mov	r0, r2
 8016bf4:	4619      	mov	r1, r3
 8016bf6:	b114      	cbz	r4, 8016bfe <__divdi3+0xae>
 8016bf8:	4240      	negs	r0, r0
 8016bfa:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8016bfe:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8016c02:	4770      	bx	lr
 8016c04:	fab3 f883 	clz	r8, r3
 8016c08:	f1b8 0f00 	cmp.w	r8, #0
 8016c0c:	f040 8084 	bne.w	8016d18 <__divdi3+0x1c8>
 8016c10:	428b      	cmp	r3, r1
 8016c12:	d302      	bcc.n	8016c1a <__divdi3+0xca>
 8016c14:	4282      	cmp	r2, r0
 8016c16:	f200 80de 	bhi.w	8016dd6 <__divdi3+0x286>
 8016c1a:	2300      	movs	r3, #0
 8016c1c:	2201      	movs	r2, #1
 8016c1e:	e7e8      	b.n	8016bf2 <__divdi3+0xa2>
 8016c20:	b912      	cbnz	r2, 8016c28 <__divdi3+0xd8>
 8016c22:	2301      	movs	r3, #1
 8016c24:	fbb3 f5f2 	udiv	r5, r3, r2
 8016c28:	fab5 f285 	clz	r2, r5
 8016c2c:	2a00      	cmp	r2, #0
 8016c2e:	d139      	bne.n	8016ca4 <__divdi3+0x154>
 8016c30:	1b7f      	subs	r7, r7, r5
 8016c32:	0c28      	lsrs	r0, r5, #16
 8016c34:	fa1f fc85 	uxth.w	ip, r5
 8016c38:	2301      	movs	r3, #1
 8016c3a:	fbb7 f1f0 	udiv	r1, r7, r0
 8016c3e:	0c32      	lsrs	r2, r6, #16
 8016c40:	fb00 7711 	mls	r7, r0, r1, r7
 8016c44:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
 8016c48:	fb0c f201 	mul.w	r2, ip, r1
 8016c4c:	42ba      	cmp	r2, r7
 8016c4e:	d907      	bls.n	8016c60 <__divdi3+0x110>
 8016c50:	197f      	adds	r7, r7, r5
 8016c52:	f101 38ff 	add.w	r8, r1, #4294967295
 8016c56:	d202      	bcs.n	8016c5e <__divdi3+0x10e>
 8016c58:	42ba      	cmp	r2, r7
 8016c5a:	f200 80c1 	bhi.w	8016de0 <__divdi3+0x290>
 8016c5e:	4641      	mov	r1, r8
 8016c60:	1abf      	subs	r7, r7, r2
 8016c62:	fbb7 f2f0 	udiv	r2, r7, r0
 8016c66:	b2b6      	uxth	r6, r6
 8016c68:	fb00 7012 	mls	r0, r0, r2, r7
 8016c6c:	ea46 4000 	orr.w	r0, r6, r0, lsl #16
 8016c70:	fb0c fc02 	mul.w	ip, ip, r2
 8016c74:	4584      	cmp	ip, r0
 8016c76:	d907      	bls.n	8016c88 <__divdi3+0x138>
 8016c78:	1940      	adds	r0, r0, r5
 8016c7a:	f102 37ff 	add.w	r7, r2, #4294967295
 8016c7e:	d202      	bcs.n	8016c86 <__divdi3+0x136>
 8016c80:	4584      	cmp	ip, r0
 8016c82:	f200 80ab 	bhi.w	8016ddc <__divdi3+0x28c>
 8016c86:	463a      	mov	r2, r7
 8016c88:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8016c8c:	e7b1      	b.n	8016bf2 <__divdi3+0xa2>
 8016c8e:	43e4      	mvns	r4, r4
 8016c90:	4252      	negs	r2, r2
 8016c92:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8016c96:	e764      	b.n	8016b62 <__divdi3+0x12>
 8016c98:	4240      	negs	r0, r0
 8016c9a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8016c9e:	f04f 34ff 	mov.w	r4, #4294967295
 8016ca2:	e75b      	b.n	8016b5c <__divdi3+0xc>
 8016ca4:	4095      	lsls	r5, r2
 8016ca6:	f1c2 0320 	rsb	r3, r2, #32
 8016caa:	fa27 f103 	lsr.w	r1, r7, r3
 8016cae:	0c28      	lsrs	r0, r5, #16
 8016cb0:	fa26 f303 	lsr.w	r3, r6, r3
 8016cb4:	4097      	lsls	r7, r2
 8016cb6:	fbb1 f8f0 	udiv	r8, r1, r0
 8016cba:	431f      	orrs	r7, r3
 8016cbc:	0c3b      	lsrs	r3, r7, #16
 8016cbe:	fb00 1118 	mls	r1, r0, r8, r1
 8016cc2:	fa1f fc85 	uxth.w	ip, r5
 8016cc6:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 8016cca:	fb0c f308 	mul.w	r3, ip, r8
 8016cce:	428b      	cmp	r3, r1
 8016cd0:	fa06 f602 	lsl.w	r6, r6, r2
 8016cd4:	d908      	bls.n	8016ce8 <__divdi3+0x198>
 8016cd6:	1949      	adds	r1, r1, r5
 8016cd8:	f108 32ff 	add.w	r2, r8, #4294967295
 8016cdc:	d279      	bcs.n	8016dd2 <__divdi3+0x282>
 8016cde:	428b      	cmp	r3, r1
 8016ce0:	d977      	bls.n	8016dd2 <__divdi3+0x282>
 8016ce2:	f1a8 0802 	sub.w	r8, r8, #2
 8016ce6:	4429      	add	r1, r5
 8016ce8:	1ac9      	subs	r1, r1, r3
 8016cea:	fbb1 f3f0 	udiv	r3, r1, r0
 8016cee:	b2bf      	uxth	r7, r7
 8016cf0:	fb00 1113 	mls	r1, r0, r3, r1
 8016cf4:	ea47 4701 	orr.w	r7, r7, r1, lsl #16
 8016cf8:	fb0c f203 	mul.w	r2, ip, r3
 8016cfc:	42ba      	cmp	r2, r7
 8016cfe:	d907      	bls.n	8016d10 <__divdi3+0x1c0>
 8016d00:	197f      	adds	r7, r7, r5
 8016d02:	f103 31ff 	add.w	r1, r3, #4294967295
 8016d06:	d260      	bcs.n	8016dca <__divdi3+0x27a>
 8016d08:	42ba      	cmp	r2, r7
 8016d0a:	d95e      	bls.n	8016dca <__divdi3+0x27a>
 8016d0c:	3b02      	subs	r3, #2
 8016d0e:	442f      	add	r7, r5
 8016d10:	1abf      	subs	r7, r7, r2
 8016d12:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8016d16:	e790      	b.n	8016c3a <__divdi3+0xea>
 8016d18:	f1c8 0220 	rsb	r2, r8, #32
 8016d1c:	fa03 fc08 	lsl.w	ip, r3, r8
 8016d20:	fa25 f302 	lsr.w	r3, r5, r2
 8016d24:	ea43 0c0c 	orr.w	ip, r3, ip
 8016d28:	ea4f 491c 	mov.w	r9, ip, lsr #16
 8016d2c:	fa21 f302 	lsr.w	r3, r1, r2
 8016d30:	fa01 f708 	lsl.w	r7, r1, r8
 8016d34:	fa20 f202 	lsr.w	r2, r0, r2
 8016d38:	fbb3 f1f9 	udiv	r1, r3, r9
 8016d3c:	4317      	orrs	r7, r2
 8016d3e:	fb09 3311 	mls	r3, r9, r1, r3
 8016d42:	0c3a      	lsrs	r2, r7, #16
 8016d44:	fa1f fb8c 	uxth.w	fp, ip
 8016d48:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
 8016d4c:	fb0b fa01 	mul.w	sl, fp, r1
 8016d50:	459a      	cmp	sl, r3
 8016d52:	fa05 f008 	lsl.w	r0, r5, r8
 8016d56:	d908      	bls.n	8016d6a <__divdi3+0x21a>
 8016d58:	eb13 030c 	adds.w	r3, r3, ip
 8016d5c:	f101 32ff 	add.w	r2, r1, #4294967295
 8016d60:	d235      	bcs.n	8016dce <__divdi3+0x27e>
 8016d62:	459a      	cmp	sl, r3
 8016d64:	d933      	bls.n	8016dce <__divdi3+0x27e>
 8016d66:	3902      	subs	r1, #2
 8016d68:	4463      	add	r3, ip
 8016d6a:	ebca 0303 	rsb	r3, sl, r3
 8016d6e:	fbb3 f2f9 	udiv	r2, r3, r9
 8016d72:	fb09 3312 	mls	r3, r9, r2, r3
 8016d76:	b2bf      	uxth	r7, r7
 8016d78:	ea47 4703 	orr.w	r7, r7, r3, lsl #16
 8016d7c:	fb0b f902 	mul.w	r9, fp, r2
 8016d80:	45b9      	cmp	r9, r7
 8016d82:	d908      	bls.n	8016d96 <__divdi3+0x246>
 8016d84:	eb17 070c 	adds.w	r7, r7, ip
 8016d88:	f102 33ff 	add.w	r3, r2, #4294967295
 8016d8c:	d21b      	bcs.n	8016dc6 <__divdi3+0x276>
 8016d8e:	45b9      	cmp	r9, r7
 8016d90:	d919      	bls.n	8016dc6 <__divdi3+0x276>
 8016d92:	3a02      	subs	r2, #2
 8016d94:	4467      	add	r7, ip
 8016d96:	ea42 4501 	orr.w	r5, r2, r1, lsl #16
 8016d9a:	fba5 0100 	umull	r0, r1, r5, r0
 8016d9e:	ebc9 0707 	rsb	r7, r9, r7
 8016da2:	428f      	cmp	r7, r1
 8016da4:	f04f 0300 	mov.w	r3, #0
 8016da8:	d30a      	bcc.n	8016dc0 <__divdi3+0x270>
 8016daa:	d005      	beq.n	8016db8 <__divdi3+0x268>
 8016dac:	462a      	mov	r2, r5
 8016dae:	e720      	b.n	8016bf2 <__divdi3+0xa2>
 8016db0:	4662      	mov	r2, ip
 8016db2:	e701      	b.n	8016bb8 <__divdi3+0x68>
 8016db4:	463b      	mov	r3, r7
 8016db6:	e714      	b.n	8016be2 <__divdi3+0x92>
 8016db8:	fa06 f608 	lsl.w	r6, r6, r8
 8016dbc:	4286      	cmp	r6, r0
 8016dbe:	d2f5      	bcs.n	8016dac <__divdi3+0x25c>
 8016dc0:	1e6a      	subs	r2, r5, #1
 8016dc2:	2300      	movs	r3, #0
 8016dc4:	e715      	b.n	8016bf2 <__divdi3+0xa2>
 8016dc6:	461a      	mov	r2, r3
 8016dc8:	e7e5      	b.n	8016d96 <__divdi3+0x246>
 8016dca:	460b      	mov	r3, r1
 8016dcc:	e7a0      	b.n	8016d10 <__divdi3+0x1c0>
 8016dce:	4611      	mov	r1, r2
 8016dd0:	e7cb      	b.n	8016d6a <__divdi3+0x21a>
 8016dd2:	4690      	mov	r8, r2
 8016dd4:	e788      	b.n	8016ce8 <__divdi3+0x198>
 8016dd6:	4643      	mov	r3, r8
 8016dd8:	4642      	mov	r2, r8
 8016dda:	e70a      	b.n	8016bf2 <__divdi3+0xa2>
 8016ddc:	3a02      	subs	r2, #2
 8016dde:	e753      	b.n	8016c88 <__divdi3+0x138>
 8016de0:	3902      	subs	r1, #2
 8016de2:	442f      	add	r7, r5
 8016de4:	e73c      	b.n	8016c60 <__divdi3+0x110>
 8016de6:	bf00      	nop
	...

08016df0 <__udivdi3>:
 8016df0:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8016df4:	4614      	mov	r4, r2
 8016df6:	4605      	mov	r5, r0
 8016df8:	460e      	mov	r6, r1
 8016dfa:	2b00      	cmp	r3, #0
 8016dfc:	d143      	bne.n	8016e86 <__udivdi3+0x96>
 8016dfe:	428a      	cmp	r2, r1
 8016e00:	d953      	bls.n	8016eaa <__udivdi3+0xba>
 8016e02:	fab2 f782 	clz	r7, r2
 8016e06:	b157      	cbz	r7, 8016e1e <__udivdi3+0x2e>
 8016e08:	f1c7 0620 	rsb	r6, r7, #32
 8016e0c:	fa20 f606 	lsr.w	r6, r0, r6
 8016e10:	fa01 f307 	lsl.w	r3, r1, r7
 8016e14:	fa02 f407 	lsl.w	r4, r2, r7
 8016e18:	431e      	orrs	r6, r3
 8016e1a:	fa00 f507 	lsl.w	r5, r0, r7
 8016e1e:	0c21      	lsrs	r1, r4, #16
 8016e20:	fbb6 f2f1 	udiv	r2, r6, r1
 8016e24:	0c2b      	lsrs	r3, r5, #16
 8016e26:	fb01 6712 	mls	r7, r1, r2, r6
 8016e2a:	b2a0      	uxth	r0, r4
 8016e2c:	ea43 4607 	orr.w	r6, r3, r7, lsl #16
 8016e30:	fb00 f302 	mul.w	r3, r0, r2
 8016e34:	42b3      	cmp	r3, r6
 8016e36:	d909      	bls.n	8016e4c <__udivdi3+0x5c>
 8016e38:	1936      	adds	r6, r6, r4
 8016e3a:	f102 37ff 	add.w	r7, r2, #4294967295
 8016e3e:	f080 80f6 	bcs.w	801702e <__udivdi3+0x23e>
 8016e42:	42b3      	cmp	r3, r6
 8016e44:	f240 80f3 	bls.w	801702e <__udivdi3+0x23e>
 8016e48:	3a02      	subs	r2, #2
 8016e4a:	4426      	add	r6, r4
 8016e4c:	1af6      	subs	r6, r6, r3
 8016e4e:	fbb6 f3f1 	udiv	r3, r6, r1
 8016e52:	b2ad      	uxth	r5, r5
 8016e54:	fb01 6113 	mls	r1, r1, r3, r6
 8016e58:	ea45 4101 	orr.w	r1, r5, r1, lsl #16
 8016e5c:	fb00 f003 	mul.w	r0, r0, r3
 8016e60:	4288      	cmp	r0, r1
 8016e62:	d908      	bls.n	8016e76 <__udivdi3+0x86>
 8016e64:	1909      	adds	r1, r1, r4
 8016e66:	f103 36ff 	add.w	r6, r3, #4294967295
 8016e6a:	f080 80e2 	bcs.w	8017032 <__udivdi3+0x242>
 8016e6e:	4288      	cmp	r0, r1
 8016e70:	f240 80df 	bls.w	8017032 <__udivdi3+0x242>
 8016e74:	3b02      	subs	r3, #2
 8016e76:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
 8016e7a:	2300      	movs	r3, #0
 8016e7c:	4610      	mov	r0, r2
 8016e7e:	4619      	mov	r1, r3
 8016e80:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8016e84:	4770      	bx	lr
 8016e86:	428b      	cmp	r3, r1
 8016e88:	d84a      	bhi.n	8016f20 <__udivdi3+0x130>
 8016e8a:	fab3 f683 	clz	r6, r3
 8016e8e:	2e00      	cmp	r6, #0
 8016e90:	d14d      	bne.n	8016f2e <__udivdi3+0x13e>
 8016e92:	428b      	cmp	r3, r1
 8016e94:	d302      	bcc.n	8016e9c <__udivdi3+0xac>
 8016e96:	4282      	cmp	r2, r0
 8016e98:	f200 80d6 	bhi.w	8017048 <__udivdi3+0x258>
 8016e9c:	2300      	movs	r3, #0
 8016e9e:	2201      	movs	r2, #1
 8016ea0:	4610      	mov	r0, r2
 8016ea2:	4619      	mov	r1, r3
 8016ea4:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8016ea8:	4770      	bx	lr
 8016eaa:	b912      	cbnz	r2, 8016eb2 <__udivdi3+0xc2>
 8016eac:	2401      	movs	r4, #1
 8016eae:	fbb4 f4f2 	udiv	r4, r4, r2
 8016eb2:	fab4 f284 	clz	r2, r4
 8016eb6:	2a00      	cmp	r2, #0
 8016eb8:	d17c      	bne.n	8016fb4 <__udivdi3+0x1c4>
 8016eba:	1b09      	subs	r1, r1, r4
 8016ebc:	0c26      	lsrs	r6, r4, #16
 8016ebe:	b2a7      	uxth	r7, r4
 8016ec0:	2301      	movs	r3, #1
 8016ec2:	fbb1 f0f6 	udiv	r0, r1, r6
 8016ec6:	0c2a      	lsrs	r2, r5, #16
 8016ec8:	fb06 1110 	mls	r1, r6, r0, r1
 8016ecc:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
 8016ed0:	fb07 f200 	mul.w	r2, r7, r0
 8016ed4:	428a      	cmp	r2, r1
 8016ed6:	d907      	bls.n	8016ee8 <__udivdi3+0xf8>
 8016ed8:	1909      	adds	r1, r1, r4
 8016eda:	f100 3cff 	add.w	ip, r0, #4294967295
 8016ede:	d202      	bcs.n	8016ee6 <__udivdi3+0xf6>
 8016ee0:	428a      	cmp	r2, r1
 8016ee2:	f200 80c3 	bhi.w	801706c <__udivdi3+0x27c>
 8016ee6:	4660      	mov	r0, ip
 8016ee8:	1a89      	subs	r1, r1, r2
 8016eea:	fbb1 f2f6 	udiv	r2, r1, r6
 8016eee:	b2ad      	uxth	r5, r5
 8016ef0:	fb06 1112 	mls	r1, r6, r2, r1
 8016ef4:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
 8016ef8:	fb07 f702 	mul.w	r7, r7, r2
 8016efc:	42af      	cmp	r7, r5
 8016efe:	d908      	bls.n	8016f12 <__udivdi3+0x122>
 8016f00:	192c      	adds	r4, r5, r4
 8016f02:	f102 31ff 	add.w	r1, r2, #4294967295
 8016f06:	f080 8096 	bcs.w	8017036 <__udivdi3+0x246>
 8016f0a:	42a7      	cmp	r7, r4
 8016f0c:	f240 8093 	bls.w	8017036 <__udivdi3+0x246>
 8016f10:	3a02      	subs	r2, #2
 8016f12:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8016f16:	4610      	mov	r0, r2
 8016f18:	4619      	mov	r1, r3
 8016f1a:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8016f1e:	4770      	bx	lr
 8016f20:	2300      	movs	r3, #0
 8016f22:	461a      	mov	r2, r3
 8016f24:	4610      	mov	r0, r2
 8016f26:	4619      	mov	r1, r3
 8016f28:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8016f2c:	4770      	bx	lr
 8016f2e:	f1c6 0520 	rsb	r5, r6, #32
 8016f32:	fa22 f405 	lsr.w	r4, r2, r5
 8016f36:	40b3      	lsls	r3, r6
 8016f38:	431c      	orrs	r4, r3
 8016f3a:	ea4f 4814 	mov.w	r8, r4, lsr #16
 8016f3e:	fa21 f305 	lsr.w	r3, r1, r5
 8016f42:	fa01 f706 	lsl.w	r7, r1, r6
 8016f46:	fa20 f505 	lsr.w	r5, r0, r5
 8016f4a:	fbb3 fcf8 	udiv	ip, r3, r8
 8016f4e:	432f      	orrs	r7, r5
 8016f50:	fb08 331c 	mls	r3, r8, ip, r3
 8016f54:	0c3d      	lsrs	r5, r7, #16
 8016f56:	fa1f fa84 	uxth.w	sl, r4
 8016f5a:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
 8016f5e:	fb0a f90c 	mul.w	r9, sl, ip
 8016f62:	4599      	cmp	r9, r3
 8016f64:	fa02 fb06 	lsl.w	fp, r2, r6
 8016f68:	d904      	bls.n	8016f74 <__udivdi3+0x184>
 8016f6a:	191b      	adds	r3, r3, r4
 8016f6c:	f10c 32ff 	add.w	r2, ip, #4294967295
 8016f70:	d36d      	bcc.n	801704e <__udivdi3+0x25e>
 8016f72:	4694      	mov	ip, r2
 8016f74:	ebc9 0303 	rsb	r3, r9, r3
 8016f78:	fbb3 f5f8 	udiv	r5, r3, r8
 8016f7c:	fb08 3315 	mls	r3, r8, r5, r3
 8016f80:	b2bf      	uxth	r7, r7
 8016f82:	ea47 4703 	orr.w	r7, r7, r3, lsl #16
 8016f86:	fb0a f805 	mul.w	r8, sl, r5
 8016f8a:	45b8      	cmp	r8, r7
 8016f8c:	d904      	bls.n	8016f98 <__udivdi3+0x1a8>
 8016f8e:	193f      	adds	r7, r7, r4
 8016f90:	f105 33ff 	add.w	r3, r5, #4294967295
 8016f94:	d361      	bcc.n	801705a <__udivdi3+0x26a>
 8016f96:	461d      	mov	r5, r3
 8016f98:	ea45 4c0c 	orr.w	ip, r5, ip, lsl #16
 8016f9c:	fbac 230b 	umull	r2, r3, ip, fp
 8016fa0:	ebc8 0707 	rsb	r7, r8, r7
 8016fa4:	429f      	cmp	r7, r3
 8016fa6:	f04f 0500 	mov.w	r5, #0
 8016faa:	d349      	bcc.n	8017040 <__udivdi3+0x250>
 8016fac:	d045      	beq.n	801703a <__udivdi3+0x24a>
 8016fae:	4662      	mov	r2, ip
 8016fb0:	462b      	mov	r3, r5
 8016fb2:	e763      	b.n	8016e7c <__udivdi3+0x8c>
 8016fb4:	4094      	lsls	r4, r2
 8016fb6:	f1c2 0320 	rsb	r3, r2, #32
 8016fba:	fa21 fc03 	lsr.w	ip, r1, r3
 8016fbe:	0c26      	lsrs	r6, r4, #16
 8016fc0:	fa20 f303 	lsr.w	r3, r0, r3
 8016fc4:	fa01 f502 	lsl.w	r5, r1, r2
 8016fc8:	fbbc f8f6 	udiv	r8, ip, r6
 8016fcc:	ea43 0105 	orr.w	r1, r3, r5
 8016fd0:	0c0b      	lsrs	r3, r1, #16
 8016fd2:	fb06 cc18 	mls	ip, r6, r8, ip
 8016fd6:	b2a7      	uxth	r7, r4
 8016fd8:	ea43 4c0c 	orr.w	ip, r3, ip, lsl #16
 8016fdc:	fb07 f308 	mul.w	r3, r7, r8
 8016fe0:	4563      	cmp	r3, ip
 8016fe2:	fa00 f502 	lsl.w	r5, r0, r2
 8016fe6:	d909      	bls.n	8016ffc <__udivdi3+0x20c>
 8016fe8:	eb1c 0c04 	adds.w	ip, ip, r4
 8016fec:	f108 32ff 	add.w	r2, r8, #4294967295
 8016ff0:	d23a      	bcs.n	8017068 <__udivdi3+0x278>
 8016ff2:	4563      	cmp	r3, ip
 8016ff4:	d938      	bls.n	8017068 <__udivdi3+0x278>
 8016ff6:	f1a8 0802 	sub.w	r8, r8, #2
 8016ffa:	44a4      	add	ip, r4
 8016ffc:	ebc3 0c0c 	rsb	ip, r3, ip
 8017000:	fbbc f3f6 	udiv	r3, ip, r6
 8017004:	b289      	uxth	r1, r1
 8017006:	fb06 cc13 	mls	ip, r6, r3, ip
 801700a:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
 801700e:	fb07 f203 	mul.w	r2, r7, r3
 8017012:	428a      	cmp	r2, r1
 8017014:	d907      	bls.n	8017026 <__udivdi3+0x236>
 8017016:	1909      	adds	r1, r1, r4
 8017018:	f103 30ff 	add.w	r0, r3, #4294967295
 801701c:	d222      	bcs.n	8017064 <__udivdi3+0x274>
 801701e:	428a      	cmp	r2, r1
 8017020:	d920      	bls.n	8017064 <__udivdi3+0x274>
 8017022:	3b02      	subs	r3, #2
 8017024:	4421      	add	r1, r4
 8017026:	1a89      	subs	r1, r1, r2
 8017028:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 801702c:	e749      	b.n	8016ec2 <__udivdi3+0xd2>
 801702e:	463a      	mov	r2, r7
 8017030:	e70c      	b.n	8016e4c <__udivdi3+0x5c>
 8017032:	4633      	mov	r3, r6
 8017034:	e71f      	b.n	8016e76 <__udivdi3+0x86>
 8017036:	460a      	mov	r2, r1
 8017038:	e76b      	b.n	8016f12 <__udivdi3+0x122>
 801703a:	40b0      	lsls	r0, r6
 801703c:	4290      	cmp	r0, r2
 801703e:	d2b6      	bcs.n	8016fae <__udivdi3+0x1be>
 8017040:	f10c 32ff 	add.w	r2, ip, #4294967295
 8017044:	2300      	movs	r3, #0
 8017046:	e719      	b.n	8016e7c <__udivdi3+0x8c>
 8017048:	4633      	mov	r3, r6
 801704a:	4632      	mov	r2, r6
 801704c:	e716      	b.n	8016e7c <__udivdi3+0x8c>
 801704e:	4599      	cmp	r9, r3
 8017050:	d98f      	bls.n	8016f72 <__udivdi3+0x182>
 8017052:	f1ac 0c02 	sub.w	ip, ip, #2
 8017056:	4423      	add	r3, r4
 8017058:	e78c      	b.n	8016f74 <__udivdi3+0x184>
 801705a:	45b8      	cmp	r8, r7
 801705c:	d99b      	bls.n	8016f96 <__udivdi3+0x1a6>
 801705e:	3d02      	subs	r5, #2
 8017060:	4427      	add	r7, r4
 8017062:	e799      	b.n	8016f98 <__udivdi3+0x1a8>
 8017064:	4603      	mov	r3, r0
 8017066:	e7de      	b.n	8017026 <__udivdi3+0x236>
 8017068:	4690      	mov	r8, r2
 801706a:	e7c7      	b.n	8016ffc <__udivdi3+0x20c>
 801706c:	3802      	subs	r0, #2
 801706e:	4421      	add	r1, r4
 8017070:	e73a      	b.n	8016ee8 <__udivdi3+0xf8>
 8017072:	bf00      	nop
	...

08017080 <memcpy>:
 8017080:	4684      	mov	ip, r0
 8017082:	ea41 0300 	orr.w	r3, r1, r0
 8017086:	f013 0303 	ands.w	r3, r3, #3
 801708a:	d16d      	bne.n	8017168 <memcpy+0xe8>
 801708c:	3a40      	subs	r2, #64	; 0x40
 801708e:	d341      	bcc.n	8017114 <memcpy+0x94>
 8017090:	f851 3b04 	ldr.w	r3, [r1], #4
 8017094:	f840 3b04 	str.w	r3, [r0], #4
 8017098:	f851 3b04 	ldr.w	r3, [r1], #4
 801709c:	f840 3b04 	str.w	r3, [r0], #4
 80170a0:	f851 3b04 	ldr.w	r3, [r1], #4
 80170a4:	f840 3b04 	str.w	r3, [r0], #4
 80170a8:	f851 3b04 	ldr.w	r3, [r1], #4
 80170ac:	f840 3b04 	str.w	r3, [r0], #4
 80170b0:	f851 3b04 	ldr.w	r3, [r1], #4
 80170b4:	f840 3b04 	str.w	r3, [r0], #4
 80170b8:	f851 3b04 	ldr.w	r3, [r1], #4
 80170bc:	f840 3b04 	str.w	r3, [r0], #4
 80170c0:	f851 3b04 	ldr.w	r3, [r1], #4
 80170c4:	f840 3b04 	str.w	r3, [r0], #4
 80170c8:	f851 3b04 	ldr.w	r3, [r1], #4
 80170cc:	f840 3b04 	str.w	r3, [r0], #4
 80170d0:	f851 3b04 	ldr.w	r3, [r1], #4
 80170d4:	f840 3b04 	str.w	r3, [r0], #4
 80170d8:	f851 3b04 	ldr.w	r3, [r1], #4
 80170dc:	f840 3b04 	str.w	r3, [r0], #4
 80170e0:	f851 3b04 	ldr.w	r3, [r1], #4
 80170e4:	f840 3b04 	str.w	r3, [r0], #4
 80170e8:	f851 3b04 	ldr.w	r3, [r1], #4
 80170ec:	f840 3b04 	str.w	r3, [r0], #4
 80170f0:	f851 3b04 	ldr.w	r3, [r1], #4
 80170f4:	f840 3b04 	str.w	r3, [r0], #4
 80170f8:	f851 3b04 	ldr.w	r3, [r1], #4
 80170fc:	f840 3b04 	str.w	r3, [r0], #4
 8017100:	f851 3b04 	ldr.w	r3, [r1], #4
 8017104:	f840 3b04 	str.w	r3, [r0], #4
 8017108:	f851 3b04 	ldr.w	r3, [r1], #4
 801710c:	f840 3b04 	str.w	r3, [r0], #4
 8017110:	3a40      	subs	r2, #64	; 0x40
 8017112:	d2bd      	bcs.n	8017090 <memcpy+0x10>
 8017114:	3230      	adds	r2, #48	; 0x30
 8017116:	d311      	bcc.n	801713c <memcpy+0xbc>
 8017118:	f851 3b04 	ldr.w	r3, [r1], #4
 801711c:	f840 3b04 	str.w	r3, [r0], #4
 8017120:	f851 3b04 	ldr.w	r3, [r1], #4
 8017124:	f840 3b04 	str.w	r3, [r0], #4
 8017128:	f851 3b04 	ldr.w	r3, [r1], #4
 801712c:	f840 3b04 	str.w	r3, [r0], #4
 8017130:	f851 3b04 	ldr.w	r3, [r1], #4
 8017134:	f840 3b04 	str.w	r3, [r0], #4
 8017138:	3a10      	subs	r2, #16
 801713a:	d2ed      	bcs.n	8017118 <memcpy+0x98>
 801713c:	320c      	adds	r2, #12
 801713e:	d305      	bcc.n	801714c <memcpy+0xcc>
 8017140:	f851 3b04 	ldr.w	r3, [r1], #4
 8017144:	f840 3b04 	str.w	r3, [r0], #4
 8017148:	3a04      	subs	r2, #4
 801714a:	d2f9      	bcs.n	8017140 <memcpy+0xc0>
 801714c:	3204      	adds	r2, #4
 801714e:	d008      	beq.n	8017162 <memcpy+0xe2>
 8017150:	07d2      	lsls	r2, r2, #31
 8017152:	bf1c      	itt	ne
 8017154:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8017158:	f800 3b01 	strbne.w	r3, [r0], #1
 801715c:	d301      	bcc.n	8017162 <memcpy+0xe2>
 801715e:	880b      	ldrh	r3, [r1, #0]
 8017160:	8003      	strh	r3, [r0, #0]
 8017162:	4660      	mov	r0, ip
 8017164:	4770      	bx	lr
 8017166:	bf00      	nop
 8017168:	2a08      	cmp	r2, #8
 801716a:	d313      	bcc.n	8017194 <memcpy+0x114>
 801716c:	078b      	lsls	r3, r1, #30
 801716e:	d08d      	beq.n	801708c <memcpy+0xc>
 8017170:	f010 0303 	ands.w	r3, r0, #3
 8017174:	d08a      	beq.n	801708c <memcpy+0xc>
 8017176:	f1c3 0304 	rsb	r3, r3, #4
 801717a:	1ad2      	subs	r2, r2, r3
 801717c:	07db      	lsls	r3, r3, #31
 801717e:	bf1c      	itt	ne
 8017180:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8017184:	f800 3b01 	strbne.w	r3, [r0], #1
 8017188:	d380      	bcc.n	801708c <memcpy+0xc>
 801718a:	f831 3b02 	ldrh.w	r3, [r1], #2
 801718e:	f820 3b02 	strh.w	r3, [r0], #2
 8017192:	e77b      	b.n	801708c <memcpy+0xc>
 8017194:	3a04      	subs	r2, #4
 8017196:	d3d9      	bcc.n	801714c <memcpy+0xcc>
 8017198:	3a01      	subs	r2, #1
 801719a:	f811 3b01 	ldrb.w	r3, [r1], #1
 801719e:	f800 3b01 	strb.w	r3, [r0], #1
 80171a2:	d2f9      	bcs.n	8017198 <memcpy+0x118>
 80171a4:	780b      	ldrb	r3, [r1, #0]
 80171a6:	7003      	strb	r3, [r0, #0]
 80171a8:	784b      	ldrb	r3, [r1, #1]
 80171aa:	7043      	strb	r3, [r0, #1]
 80171ac:	788b      	ldrb	r3, [r1, #2]
 80171ae:	7083      	strb	r3, [r0, #2]
 80171b0:	4660      	mov	r0, ip
 80171b2:	4770      	bx	lr
	...

080171c0 <strcmp>:
 80171c0:	ea40 0c01 	orr.w	ip, r0, r1
 80171c4:	f01c 0f07 	tst.w	ip, #7
 80171c8:	d123      	bne.n	8017212 <strcmp+0x52>
 80171ca:	f1bd 0d10 	subs.w	sp, sp, #16
 80171ce:	e9cd 4502 	strd	r4, r5, [sp, #8]
 80171d2:	e9cd 6700 	strd	r6, r7, [sp]
 80171d6:	f06f 0600 	mvn.w	r6, #0
 80171da:	f04f 0700 	mov.w	r7, #0
 80171de:	bf00      	nop
 80171e0:	e8f0 2302 	ldrd	r2, r3, [r0], #8
 80171e4:	e8f1 4502 	ldrd	r4, r5, [r1], #8
 80171e8:	42a2      	cmp	r2, r4
 80171ea:	fa82 fc46 	uadd8	ip, r2, r6
 80171ee:	faa7 fc86 	sel	ip, r7, r6
 80171f2:	bf08      	it	eq
 80171f4:	f1bc 0f00 	cmpeq.w	ip, #0
 80171f8:	f040 80d7 	bne.w	80173aa <strcmp+0x1ea>
 80171fc:	42ab      	cmp	r3, r5
 80171fe:	fa83 fc46 	uadd8	ip, r3, r6
 8017202:	faa7 fc86 	sel	ip, r7, r6
 8017206:	bf08      	it	eq
 8017208:	f1bc 0f00 	cmpeq.w	ip, #0
 801720c:	f040 80ca 	bne.w	80173a4 <strcmp+0x1e4>
 8017210:	e7e6      	b.n	80171e0 <strcmp+0x20>
 8017212:	f010 0c03 	ands.w	ip, r0, #3
 8017216:	d021      	beq.n	801725c <strcmp+0x9c>
 8017218:	f020 0003 	bic.w	r0, r0, #3
 801721c:	f850 2b04 	ldr.w	r2, [r0], #4
 8017220:	ea5f 7ccc 	movs.w	ip, ip, lsl #31
 8017224:	d008      	beq.n	8017238 <strcmp+0x78>
 8017226:	d20f      	bcs.n	8017248 <strcmp+0x88>
 8017228:	f811 cb01 	ldrb.w	ip, [r1], #1
 801722c:	fa5f f392 	uxtb.w	r3, r2, ror #8
 8017230:	ebb3 0c0c 	subs.w	ip, r3, ip
 8017234:	d110      	bne.n	8017258 <strcmp+0x98>
 8017236:	b17b      	cbz	r3, 8017258 <strcmp+0x98>
 8017238:	f811 cb01 	ldrb.w	ip, [r1], #1
 801723c:	fa5f f3a2 	uxtb.w	r3, r2, ror #16
 8017240:	ebb3 0c0c 	subs.w	ip, r3, ip
 8017244:	d108      	bne.n	8017258 <strcmp+0x98>
 8017246:	b13b      	cbz	r3, 8017258 <strcmp+0x98>
 8017248:	f811 cb01 	ldrb.w	ip, [r1], #1
 801724c:	fa5f f3b2 	uxtb.w	r3, r2, ror #24
 8017250:	ebb3 0c0c 	subs.w	ip, r3, ip
 8017254:	d100      	bne.n	8017258 <strcmp+0x98>
 8017256:	b90b      	cbnz	r3, 801725c <strcmp+0x9c>
 8017258:	4660      	mov	r0, ip
 801725a:	4770      	bx	lr
 801725c:	f1bd 0d10 	subs.w	sp, sp, #16
 8017260:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8017264:	e9cd 6700 	strd	r6, r7, [sp]
 8017268:	f06f 0600 	mvn.w	r6, #0
 801726c:	f04f 0700 	mov.w	r7, #0
 8017270:	f011 0c03 	ands.w	ip, r1, #3
 8017274:	d12d      	bne.n	80172d2 <strcmp+0x112>
 8017276:	f010 0f04 	tst.w	r0, #4
 801727a:	d00d      	beq.n	8017298 <strcmp+0xd8>
 801727c:	f850 2b04 	ldr.w	r2, [r0], #4
 8017280:	f851 4b04 	ldr.w	r4, [r1], #4
 8017284:	42a2      	cmp	r2, r4
 8017286:	fa82 fc46 	uadd8	ip, r2, r6
 801728a:	faa7 fc86 	sel	ip, r7, r6
 801728e:	bf08      	it	eq
 8017290:	f1bc 0f00 	cmpeq.w	ip, #0
 8017294:	f040 8089 	bne.w	80173aa <strcmp+0x1ea>
 8017298:	f011 0f04 	tst.w	r1, #4
 801729c:	d09f      	beq.n	80171de <strcmp+0x1e>
 801729e:	f851 5b04 	ldr.w	r5, [r1], #4
 80172a2:	bf00      	nop
 80172a4:	e8f0 2302 	ldrd	r2, r3, [r0], #8
 80172a8:	42aa      	cmp	r2, r5
 80172aa:	fa82 fc46 	uadd8	ip, r2, r6
 80172ae:	faa7 fc86 	sel	ip, r7, r6
 80172b2:	bf08      	it	eq
 80172b4:	f1bc 0f00 	cmpeq.w	ip, #0
 80172b8:	d171      	bne.n	801739e <strcmp+0x1de>
 80172ba:	e8f1 4502 	ldrd	r4, r5, [r1], #8
 80172be:	42a3      	cmp	r3, r4
 80172c0:	fa83 fc46 	uadd8	ip, r3, r6
 80172c4:	faa7 fc86 	sel	ip, r7, r6
 80172c8:	bf08      	it	eq
 80172ca:	f1bc 0f00 	cmpeq.w	ip, #0
 80172ce:	d163      	bne.n	8017398 <strcmp+0x1d8>
 80172d0:	e7e8      	b.n	80172a4 <strcmp+0xe4>
 80172d2:	f021 0103 	bic.w	r1, r1, #3
 80172d6:	f1bc 0f02 	cmp.w	ip, #2
 80172da:	d01e      	beq.n	801731a <strcmp+0x15a>
 80172dc:	da3b      	bge.n	8017356 <strcmp+0x196>
 80172de:	f851 5b04 	ldr.w	r5, [r1], #4
 80172e2:	bf00      	nop
 80172e4:	f850 3b04 	ldr.w	r3, [r0], #4
 80172e8:	ea4f 2515 	mov.w	r5, r5, lsr #8
 80172ec:	fa83 fc46 	uadd8	ip, r3, r6
 80172f0:	faa7 fc86 	sel	ip, r7, r6
 80172f4:	ebb7 2f0c 	cmp.w	r7, ip, lsl #8
 80172f8:	ea03 2216 	and.w	r2, r3, r6, lsr #8
 80172fc:	bf08      	it	eq
 80172fe:	42aa      	cmpeq	r2, r5
 8017300:	d14d      	bne.n	801739e <strcmp+0x1de>
 8017302:	f851 5b04 	ldr.w	r5, [r1], #4
 8017306:	f1bc 0f00 	cmp.w	ip, #0
 801730a:	ea82 0303 	eor.w	r3, r2, r3
 801730e:	ea4f 6205 	mov.w	r2, r5, lsl #24
 8017312:	bf08      	it	eq
 8017314:	4293      	cmpeq	r3, r2
 8017316:	d13c      	bne.n	8017392 <strcmp+0x1d2>
 8017318:	e7e4      	b.n	80172e4 <strcmp+0x124>
 801731a:	f851 5b04 	ldr.w	r5, [r1], #4
 801731e:	bf00      	nop
 8017320:	f850 3b04 	ldr.w	r3, [r0], #4
 8017324:	ea4f 4515 	mov.w	r5, r5, lsr #16
 8017328:	fa83 fc46 	uadd8	ip, r3, r6
 801732c:	faa7 fc86 	sel	ip, r7, r6
 8017330:	ebb7 4f0c 	cmp.w	r7, ip, lsl #16
 8017334:	ea03 4216 	and.w	r2, r3, r6, lsr #16
 8017338:	bf08      	it	eq
 801733a:	42aa      	cmpeq	r2, r5
 801733c:	d12f      	bne.n	801739e <strcmp+0x1de>
 801733e:	f851 5b04 	ldr.w	r5, [r1], #4
 8017342:	f1bc 0f00 	cmp.w	ip, #0
 8017346:	ea82 0303 	eor.w	r3, r2, r3
 801734a:	ea4f 4205 	mov.w	r2, r5, lsl #16
 801734e:	bf08      	it	eq
 8017350:	4293      	cmpeq	r3, r2
 8017352:	d11e      	bne.n	8017392 <strcmp+0x1d2>
 8017354:	e7e4      	b.n	8017320 <strcmp+0x160>
 8017356:	f851 5b04 	ldr.w	r5, [r1], #4
 801735a:	bf00      	nop
 801735c:	f850 3b04 	ldr.w	r3, [r0], #4
 8017360:	ea4f 6515 	mov.w	r5, r5, lsr #24
 8017364:	fa83 fc46 	uadd8	ip, r3, r6
 8017368:	faa7 fc86 	sel	ip, r7, r6
 801736c:	ebb7 6f0c 	cmp.w	r7, ip, lsl #24
 8017370:	ea03 6216 	and.w	r2, r3, r6, lsr #24
 8017374:	bf08      	it	eq
 8017376:	42aa      	cmpeq	r2, r5
 8017378:	d111      	bne.n	801739e <strcmp+0x1de>
 801737a:	f851 5b04 	ldr.w	r5, [r1], #4
 801737e:	f1bc 0f00 	cmp.w	ip, #0
 8017382:	ea82 0303 	eor.w	r3, r2, r3
 8017386:	ea4f 2205 	mov.w	r2, r5, lsl #8
 801738a:	bf08      	it	eq
 801738c:	4293      	cmpeq	r3, r2
 801738e:	d100      	bne.n	8017392 <strcmp+0x1d2>
 8017390:	e7e4      	b.n	801735c <strcmp+0x19c>
 8017392:	ba19      	rev	r1, r3
 8017394:	ba12      	rev	r2, r2
 8017396:	e00a      	b.n	80173ae <strcmp+0x1ee>
 8017398:	ba19      	rev	r1, r3
 801739a:	ba22      	rev	r2, r4
 801739c:	e007      	b.n	80173ae <strcmp+0x1ee>
 801739e:	ba11      	rev	r1, r2
 80173a0:	ba2a      	rev	r2, r5
 80173a2:	e004      	b.n	80173ae <strcmp+0x1ee>
 80173a4:	ba19      	rev	r1, r3
 80173a6:	ba2a      	rev	r2, r5
 80173a8:	e001      	b.n	80173ae <strcmp+0x1ee>
 80173aa:	ba11      	rev	r1, r2
 80173ac:	ba22      	rev	r2, r4
 80173ae:	fa9c f08c 	rev.w	r0, ip
 80173b2:	e9dd 6700 	ldrd	r6, r7, [sp]
 80173b6:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
 80173ba:	f11d 0d10 	adds.w	sp, sp, #16
 80173be:	b138      	cbz	r0, 80173d0 <strcmp+0x210>
 80173c0:	fab0 f080 	clz	r0, r0
 80173c4:	f1c0 0018 	rsb	r0, r0, #24
 80173c8:	fa21 f100 	lsr.w	r1, r1, r0
 80173cc:	fa22 f200 	lsr.w	r2, r2, r0
 80173d0:	2001      	movs	r0, #1
 80173d2:	4291      	cmp	r1, r2
 80173d4:	bf98      	it	ls
 80173d6:	4180      	sbcls	r0, r0
 80173d8:	4770      	bx	lr
 80173da:	bf00      	nop
 80173dc:	0000      	movs	r0, r0
	...

080173e0 <atoi>:
 80173e0:	2100      	movs	r1, #0
 80173e2:	220a      	movs	r2, #10
 80173e4:	f000 b9ac 	b.w	8017740 <strtol>
	...

080173f0 <_atoi_r>:
 80173f0:	2200      	movs	r2, #0
 80173f2:	230a      	movs	r3, #10
 80173f4:	f000 b914 	b.w	8017620 <_strtol_r>
	...

08017400 <memset>:
 8017400:	b4f0      	push	{r4, r5, r6, r7}
 8017402:	0784      	lsls	r4, r0, #30
 8017404:	d043      	beq.n	801748e <memset+0x8e>
 8017406:	1e54      	subs	r4, r2, #1
 8017408:	2a00      	cmp	r2, #0
 801740a:	d03e      	beq.n	801748a <memset+0x8a>
 801740c:	b2cd      	uxtb	r5, r1
 801740e:	4603      	mov	r3, r0
 8017410:	e003      	b.n	801741a <memset+0x1a>
 8017412:	1e62      	subs	r2, r4, #1
 8017414:	2c00      	cmp	r4, #0
 8017416:	d038      	beq.n	801748a <memset+0x8a>
 8017418:	4614      	mov	r4, r2
 801741a:	f803 5b01 	strb.w	r5, [r3], #1
 801741e:	079a      	lsls	r2, r3, #30
 8017420:	d1f7      	bne.n	8017412 <memset+0x12>
 8017422:	2c03      	cmp	r4, #3
 8017424:	d92a      	bls.n	801747c <memset+0x7c>
 8017426:	b2cd      	uxtb	r5, r1
 8017428:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 801742c:	2c0f      	cmp	r4, #15
 801742e:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8017432:	d915      	bls.n	8017460 <memset+0x60>
 8017434:	f1a4 0710 	sub.w	r7, r4, #16
 8017438:	093f      	lsrs	r7, r7, #4
 801743a:	f103 0610 	add.w	r6, r3, #16
 801743e:	eb06 1607 	add.w	r6, r6, r7, lsl #4
 8017442:	461a      	mov	r2, r3
 8017444:	6015      	str	r5, [r2, #0]
 8017446:	6055      	str	r5, [r2, #4]
 8017448:	6095      	str	r5, [r2, #8]
 801744a:	60d5      	str	r5, [r2, #12]
 801744c:	3210      	adds	r2, #16
 801744e:	42b2      	cmp	r2, r6
 8017450:	d1f8      	bne.n	8017444 <memset+0x44>
 8017452:	f004 040f 	and.w	r4, r4, #15
 8017456:	3701      	adds	r7, #1
 8017458:	2c03      	cmp	r4, #3
 801745a:	eb03 1307 	add.w	r3, r3, r7, lsl #4
 801745e:	d90d      	bls.n	801747c <memset+0x7c>
 8017460:	461e      	mov	r6, r3
 8017462:	4622      	mov	r2, r4
 8017464:	3a04      	subs	r2, #4
 8017466:	2a03      	cmp	r2, #3
 8017468:	f846 5b04 	str.w	r5, [r6], #4
 801746c:	d8fa      	bhi.n	8017464 <memset+0x64>
 801746e:	1f22      	subs	r2, r4, #4
 8017470:	f022 0203 	bic.w	r2, r2, #3
 8017474:	3204      	adds	r2, #4
 8017476:	4413      	add	r3, r2
 8017478:	f004 0403 	and.w	r4, r4, #3
 801747c:	b12c      	cbz	r4, 801748a <memset+0x8a>
 801747e:	b2c9      	uxtb	r1, r1
 8017480:	441c      	add	r4, r3
 8017482:	f803 1b01 	strb.w	r1, [r3], #1
 8017486:	42a3      	cmp	r3, r4
 8017488:	d1fb      	bne.n	8017482 <memset+0x82>
 801748a:	bcf0      	pop	{r4, r5, r6, r7}
 801748c:	4770      	bx	lr
 801748e:	4614      	mov	r4, r2
 8017490:	4603      	mov	r3, r0
 8017492:	e7c6      	b.n	8017422 <memset+0x22>
	...

080174a0 <strlen>:
 80174a0:	f020 0103 	bic.w	r1, r0, #3
 80174a4:	f010 0003 	ands.w	r0, r0, #3
 80174a8:	f1c0 0000 	rsb	r0, r0, #0
 80174ac:	f851 3b04 	ldr.w	r3, [r1], #4
 80174b0:	f100 0c04 	add.w	ip, r0, #4
 80174b4:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 80174b8:	f06f 0200 	mvn.w	r2, #0
 80174bc:	bf1c      	itt	ne
 80174be:	fa22 f20c 	lsrne.w	r2, r2, ip
 80174c2:	4313      	orrne	r3, r2
 80174c4:	f04f 0c01 	mov.w	ip, #1
 80174c8:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 80174cc:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 80174d0:	eba3 020c 	sub.w	r2, r3, ip
 80174d4:	ea22 0203 	bic.w	r2, r2, r3
 80174d8:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 80174dc:	bf04      	itt	eq
 80174de:	f851 3b04 	ldreq.w	r3, [r1], #4
 80174e2:	3004      	addeq	r0, #4
 80174e4:	d0f4      	beq.n	80174d0 <strlen+0x30>
 80174e6:	f013 0fff 	tst.w	r3, #255	; 0xff
 80174ea:	bf1f      	itttt	ne
 80174ec:	3001      	addne	r0, #1
 80174ee:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
 80174f2:	3001      	addne	r0, #1
 80174f4:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
 80174f8:	bf18      	it	ne
 80174fa:	3001      	addne	r0, #1
 80174fc:	4770      	bx	lr
 80174fe:	bf00      	nop

08017500 <strpbrk>:
 8017500:	b4f0      	push	{r4, r5, r6, r7}
 8017502:	7804      	ldrb	r4, [r0, #0]
 8017504:	b30c      	cbz	r4, 801754a <strpbrk+0x4a>
 8017506:	780e      	ldrb	r6, [r1, #0]
 8017508:	4607      	mov	r7, r0
 801750a:	b1c6      	cbz	r6, 801753e <strpbrk+0x3e>
 801750c:	42a6      	cmp	r6, r4
 801750e:	d010      	beq.n	8017532 <strpbrk+0x32>
 8017510:	1c4b      	adds	r3, r1, #1
 8017512:	e001      	b.n	8017518 <strpbrk+0x18>
 8017514:	4294      	cmp	r4, r2
 8017516:	d00b      	beq.n	8017530 <strpbrk+0x30>
 8017518:	461d      	mov	r5, r3
 801751a:	f813 2b01 	ldrb.w	r2, [r3], #1
 801751e:	2a00      	cmp	r2, #0
 8017520:	d1f8      	bne.n	8017514 <strpbrk+0x14>
 8017522:	7844      	ldrb	r4, [r0, #1]
 8017524:	3001      	adds	r0, #1
 8017526:	2c00      	cmp	r4, #0
 8017528:	d1ee      	bne.n	8017508 <strpbrk+0x8>
 801752a:	782e      	ldrb	r6, [r5, #0]
 801752c:	4607      	mov	r7, r0
 801752e:	e000      	b.n	8017532 <strpbrk+0x32>
 8017530:	4626      	mov	r6, r4
 8017532:	2e00      	cmp	r6, #0
 8017534:	bf14      	ite	ne
 8017536:	4638      	movne	r0, r7
 8017538:	2000      	moveq	r0, #0
 801753a:	bcf0      	pop	{r4, r5, r6, r7}
 801753c:	4770      	bx	lr
 801753e:	7844      	ldrb	r4, [r0, #1]
 8017540:	460d      	mov	r5, r1
 8017542:	3001      	adds	r0, #1
 8017544:	2c00      	cmp	r4, #0
 8017546:	d1df      	bne.n	8017508 <strpbrk+0x8>
 8017548:	e7ef      	b.n	801752a <strpbrk+0x2a>
 801754a:	4620      	mov	r0, r4
 801754c:	bcf0      	pop	{r4, r5, r6, r7}
 801754e:	4770      	bx	lr

08017550 <strspn>:
 8017550:	b4f0      	push	{r4, r5, r6, r7}
 8017552:	7804      	ldrb	r4, [r0, #0]
 8017554:	b1cc      	cbz	r4, 801758a <strspn+0x3a>
 8017556:	780e      	ldrb	r6, [r1, #0]
 8017558:	4607      	mov	r7, r0
 801755a:	b19e      	cbz	r6, 8017584 <strspn+0x34>
 801755c:	4605      	mov	r5, r0
 801755e:	42b4      	cmp	r4, r6
 8017560:	d00a      	beq.n	8017578 <strspn+0x28>
 8017562:	460a      	mov	r2, r1
 8017564:	e001      	b.n	801756a <strspn+0x1a>
 8017566:	429c      	cmp	r4, r3
 8017568:	d006      	beq.n	8017578 <strspn+0x28>
 801756a:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 801756e:	2b00      	cmp	r3, #0
 8017570:	d1f9      	bne.n	8017566 <strspn+0x16>
 8017572:	1a28      	subs	r0, r5, r0
 8017574:	bcf0      	pop	{r4, r5, r6, r7}
 8017576:	4770      	bx	lr
 8017578:	786c      	ldrb	r4, [r5, #1]
 801757a:	1c7d      	adds	r5, r7, #1
 801757c:	2c00      	cmp	r4, #0
 801757e:	d0f8      	beq.n	8017572 <strspn+0x22>
 8017580:	462f      	mov	r7, r5
 8017582:	e7ec      	b.n	801755e <strspn+0xe>
 8017584:	4630      	mov	r0, r6
 8017586:	bcf0      	pop	{r4, r5, r6, r7}
 8017588:	4770      	bx	lr
 801758a:	4620      	mov	r0, r4
 801758c:	e7f2      	b.n	8017574 <strspn+0x24>
 801758e:	bf00      	nop

08017590 <strtok>:
 8017590:	4b02      	ldr	r3, [pc, #8]	; (801759c <strtok+0xc>)
 8017592:	681a      	ldr	r2, [r3, #0]
 8017594:	2301      	movs	r3, #1
 8017596:	325c      	adds	r2, #92	; 0x5c
 8017598:	f000 b802 	b.w	80175a0 <__strtok_r>
 801759c:	20000d40 	.word	0x20000d40

080175a0 <__strtok_r>:
 80175a0:	b4f0      	push	{r4, r5, r6, r7}
 80175a2:	b320      	cbz	r0, 80175ee <__strtok_r+0x4e>
 80175a4:	4607      	mov	r7, r0
 80175a6:	460d      	mov	r5, r1
 80175a8:	f817 6b01 	ldrb.w	r6, [r7], #1
 80175ac:	e001      	b.n	80175b2 <__strtok_r+0x12>
 80175ae:	42a6      	cmp	r6, r4
 80175b0:	d016      	beq.n	80175e0 <__strtok_r+0x40>
 80175b2:	f815 4b01 	ldrb.w	r4, [r5], #1
 80175b6:	2c00      	cmp	r4, #0
 80175b8:	d1f9      	bne.n	80175ae <__strtok_r+0xe>
 80175ba:	b1ee      	cbz	r6, 80175f8 <__strtok_r+0x58>
 80175bc:	463e      	mov	r6, r7
 80175be:	460c      	mov	r4, r1
 80175c0:	f816 5b01 	ldrb.w	r5, [r6], #1
 80175c4:	e000      	b.n	80175c8 <__strtok_r+0x28>
 80175c6:	b173      	cbz	r3, 80175e6 <__strtok_r+0x46>
 80175c8:	f814 3b01 	ldrb.w	r3, [r4], #1
 80175cc:	42ab      	cmp	r3, r5
 80175ce:	d1fa      	bne.n	80175c6 <__strtok_r+0x26>
 80175d0:	b15d      	cbz	r5, 80175ea <__strtok_r+0x4a>
 80175d2:	2300      	movs	r3, #0
 80175d4:	703b      	strb	r3, [r7, #0]
 80175d6:	6016      	str	r6, [r2, #0]
 80175d8:	4606      	mov	r6, r0
 80175da:	4630      	mov	r0, r6
 80175dc:	bcf0      	pop	{r4, r5, r6, r7}
 80175de:	4770      	bx	lr
 80175e0:	b163      	cbz	r3, 80175fc <__strtok_r+0x5c>
 80175e2:	4638      	mov	r0, r7
 80175e4:	e7de      	b.n	80175a4 <__strtok_r+0x4>
 80175e6:	4637      	mov	r7, r6
 80175e8:	e7e8      	b.n	80175bc <__strtok_r+0x1c>
 80175ea:	462e      	mov	r6, r5
 80175ec:	e7f3      	b.n	80175d6 <__strtok_r+0x36>
 80175ee:	6810      	ldr	r0, [r2, #0]
 80175f0:	2800      	cmp	r0, #0
 80175f2:	d1d7      	bne.n	80175a4 <__strtok_r+0x4>
 80175f4:	4606      	mov	r6, r0
 80175f6:	e7f0      	b.n	80175da <__strtok_r+0x3a>
 80175f8:	6016      	str	r6, [r2, #0]
 80175fa:	e7ee      	b.n	80175da <__strtok_r+0x3a>
 80175fc:	6017      	str	r7, [r2, #0]
 80175fe:	4606      	mov	r6, r0
 8017600:	7003      	strb	r3, [r0, #0]
 8017602:	e7ea      	b.n	80175da <__strtok_r+0x3a>
	...

08017610 <strtok_r>:
 8017610:	2301      	movs	r3, #1
 8017612:	f7ff bfc5 	b.w	80175a0 <__strtok_r>
 8017616:	bf00      	nop
	...

08017620 <_strtol_r>:
 8017620:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8017624:	4c42      	ldr	r4, [pc, #264]	; (8017730 <_strtol_r+0x110>)
 8017626:	b082      	sub	sp, #8
 8017628:	f8d4 c000 	ldr.w	ip, [r4]
 801762c:	9001      	str	r0, [sp, #4]
 801762e:	460e      	mov	r6, r1
 8017630:	e000      	b.n	8017634 <_strtol_r+0x14>
 8017632:	4626      	mov	r6, r4
 8017634:	4634      	mov	r4, r6
 8017636:	f814 5b01 	ldrb.w	r5, [r4], #1
 801763a:	eb0c 0005 	add.w	r0, ip, r5
 801763e:	7840      	ldrb	r0, [r0, #1]
 8017640:	f000 0008 	and.w	r0, r0, #8
 8017644:	f000 0aff 	and.w	sl, r0, #255	; 0xff
 8017648:	2800      	cmp	r0, #0
 801764a:	d1f2      	bne.n	8017632 <_strtol_r+0x12>
 801764c:	2d2d      	cmp	r5, #45	; 0x2d
 801764e:	d05b      	beq.n	8017708 <_strtol_r+0xe8>
 8017650:	2d2b      	cmp	r5, #43	; 0x2b
 8017652:	bf04      	itt	eq
 8017654:	7875      	ldrbeq	r5, [r6, #1]
 8017656:	1cb4      	addeq	r4, r6, #2
 8017658:	f033 0010 	bics.w	r0, r3, #16
 801765c:	d03c      	beq.n	80176d8 <_strtol_r+0xb8>
 801765e:	4699      	mov	r9, r3
 8017660:	f1ba 0f00 	cmp.w	sl, #0
 8017664:	bf0c      	ite	eq
 8017666:	f06f 4b00 	mvneq.w	fp, #2147483648	; 0x80000000
 801766a:	f04f 4b00 	movne.w	fp, #2147483648	; 0x80000000
 801766e:	fbbb f8f9 	udiv	r8, fp, r9
 8017672:	2700      	movs	r7, #0
 8017674:	fb09 bb18 	mls	fp, r9, r8, fp
 8017678:	4638      	mov	r0, r7
 801767a:	e00c      	b.n	8017696 <_strtol_r+0x76>
 801767c:	3d30      	subs	r5, #48	; 0x30
 801767e:	42ab      	cmp	r3, r5
 8017680:	dd19      	ble.n	80176b6 <_strtol_r+0x96>
 8017682:	1c7e      	adds	r6, r7, #1
 8017684:	d005      	beq.n	8017692 <_strtol_r+0x72>
 8017686:	4540      	cmp	r0, r8
 8017688:	d823      	bhi.n	80176d2 <_strtol_r+0xb2>
 801768a:	d020      	beq.n	80176ce <_strtol_r+0xae>
 801768c:	fb09 5000 	mla	r0, r9, r0, r5
 8017690:	2701      	movs	r7, #1
 8017692:	f814 5b01 	ldrb.w	r5, [r4], #1
 8017696:	eb0c 0605 	add.w	r6, ip, r5
 801769a:	7876      	ldrb	r6, [r6, #1]
 801769c:	f016 0f04 	tst.w	r6, #4
 80176a0:	d1ec      	bne.n	801767c <_strtol_r+0x5c>
 80176a2:	f016 0603 	ands.w	r6, r6, #3
 80176a6:	d006      	beq.n	80176b6 <_strtol_r+0x96>
 80176a8:	2e01      	cmp	r6, #1
 80176aa:	bf14      	ite	ne
 80176ac:	2657      	movne	r6, #87	; 0x57
 80176ae:	2637      	moveq	r6, #55	; 0x37
 80176b0:	1bad      	subs	r5, r5, r6
 80176b2:	42ab      	cmp	r3, r5
 80176b4:	dce5      	bgt.n	8017682 <_strtol_r+0x62>
 80176b6:	1c7b      	adds	r3, r7, #1
 80176b8:	d015      	beq.n	80176e6 <_strtol_r+0xc6>
 80176ba:	f1ba 0f00 	cmp.w	sl, #0
 80176be:	d121      	bne.n	8017704 <_strtol_r+0xe4>
 80176c0:	b10a      	cbz	r2, 80176c6 <_strtol_r+0xa6>
 80176c2:	b9ef      	cbnz	r7, 8017700 <_strtol_r+0xe0>
 80176c4:	6011      	str	r1, [r2, #0]
 80176c6:	b002      	add	sp, #8
 80176c8:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80176cc:	4770      	bx	lr
 80176ce:	455d      	cmp	r5, fp
 80176d0:	dddc      	ble.n	801768c <_strtol_r+0x6c>
 80176d2:	f04f 37ff 	mov.w	r7, #4294967295
 80176d6:	e7dc      	b.n	8017692 <_strtol_r+0x72>
 80176d8:	2d30      	cmp	r5, #48	; 0x30
 80176da:	d01a      	beq.n	8017712 <_strtol_r+0xf2>
 80176dc:	2b00      	cmp	r3, #0
 80176de:	d1be      	bne.n	801765e <_strtol_r+0x3e>
 80176e0:	230a      	movs	r3, #10
 80176e2:	4699      	mov	r9, r3
 80176e4:	e7bc      	b.n	8017660 <_strtol_r+0x40>
 80176e6:	9901      	ldr	r1, [sp, #4]
 80176e8:	f1ba 0f00 	cmp.w	sl, #0
 80176ec:	f04f 0322 	mov.w	r3, #34	; 0x22
 80176f0:	bf0c      	ite	eq
 80176f2:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80176f6:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
 80176fa:	600b      	str	r3, [r1, #0]
 80176fc:	2a00      	cmp	r2, #0
 80176fe:	d0e2      	beq.n	80176c6 <_strtol_r+0xa6>
 8017700:	1e61      	subs	r1, r4, #1
 8017702:	e7df      	b.n	80176c4 <_strtol_r+0xa4>
 8017704:	4240      	negs	r0, r0
 8017706:	e7db      	b.n	80176c0 <_strtol_r+0xa0>
 8017708:	1cb4      	adds	r4, r6, #2
 801770a:	7875      	ldrb	r5, [r6, #1]
 801770c:	f04f 0a01 	mov.w	sl, #1
 8017710:	e7a2      	b.n	8017658 <_strtol_r+0x38>
 8017712:	7820      	ldrb	r0, [r4, #0]
 8017714:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 8017718:	2858      	cmp	r0, #88	; 0x58
 801771a:	d003      	beq.n	8017724 <_strtol_r+0x104>
 801771c:	2b00      	cmp	r3, #0
 801771e:	d19e      	bne.n	801765e <_strtol_r+0x3e>
 8017720:	2308      	movs	r3, #8
 8017722:	e79c      	b.n	801765e <_strtol_r+0x3e>
 8017724:	2310      	movs	r3, #16
 8017726:	7865      	ldrb	r5, [r4, #1]
 8017728:	4699      	mov	r9, r3
 801772a:	3402      	adds	r4, #2
 801772c:	e798      	b.n	8017660 <_strtol_r+0x40>
 801772e:	bf00      	nop
 8017730:	20000910 	.word	0x20000910
	...

08017740 <strtol>:
 8017740:	b430      	push	{r4, r5}
 8017742:	4c04      	ldr	r4, [pc, #16]	; (8017754 <strtol+0x14>)
 8017744:	460d      	mov	r5, r1
 8017746:	4613      	mov	r3, r2
 8017748:	4601      	mov	r1, r0
 801774a:	462a      	mov	r2, r5
 801774c:	6820      	ldr	r0, [r4, #0]
 801774e:	bc30      	pop	{r4, r5}
 8017750:	f7ff bf66 	b.w	8017620 <_strtol_r>
 8017754:	20000d40 	.word	0x20000d40
	...

08017760 <ram_areas>:
 8017760:	08019da4 20002238 20002238 20002238     ....8". 8". 8". 
 8017770:	08019da4 00000000 00000000 00000000     ................
 8017780:	08019da4 00000000 00000000 00000000     ................
 8017790:	08019da4 00000000 00000000 00000000     ................
 80177a0:	08019da4 10000000 10000000 10000000     ................
 80177b0:	08019da4 00000000 00000000 00000000     ................
 80177c0:	08019da4 00000000 00000000 00000000     ................
 80177d0:	08019da4 00000000 00000000 00000000     ................
 80177e0:	656c6469 00000000 00000000 00000000     idle............

080177f0 <ch_debug>:
 80177f0:	6e69616d 18451600 08440404 1814100c     main..E...D.....
 8017800:	1e1d1c00 0000001f 00000000 00000000     ................

08017810 <month_len>:
 8017810:	1e1f1e1f 1f1f1e1f 1f1e1f1e 00000000     ................

08017820 <sdc_vmt>:
 8017820:	0800bb91 0800bba1 08005b01 08005cc1     .........[...\..
 8017830:	08005d21 08005d81 08005e11 08005e51     !]...]...^..Q^..

08017840 <vmt>:
 8017840:	08006041 08006071 080060a1 080060d1     A`..q`...`...`..
 8017850:	080060f1 08006121 08006141 08006171     .`..!a..Aa..qa..

08017860 <zero_status>:
 8017860:	00000000                                ....

08017864 <active_status>:
 8017864:	00000000                                ....

08017868 <halted_status>:
 8017868:	00000001 00000000                       ........

08017870 <_stm32_dma_streams>:
 8017870:	40020000 40020008 00000001 400200a8     ...@...@.......@
 8017880:	000b0000 40020000 4002001c 00000002     .......@...@....
 8017890:	400200a8 000c0104 40020000 40020030     ...@.......@0..@
 80178a0:	00000004 400200a8 000d0208 40020000     .......@.......@
 80178b0:	40020044 00000008 400200a8 000e030c     D..@.......@....
 80178c0:	40020000 40020058 00000010 400200a8     ...@X..@.......@
 80178d0:	000f0410 40020000 4002006c 00000020     .......@l..@ ...
 80178e0:	400200a8 00100514 40020000 40020080     ...@.......@...@
 80178f0:	00000040 400200a8 00110618 40020400     @......@.......@
 8017900:	40020408 00000080 400204a8 00380700     ...@.......@..8.
 8017910:	40020400 4002041c 00000100 400204a8     ...@...@.......@
 8017920:	00390804 40020400 40020430 00000200     ..9....@0..@....
 8017930:	400204a8 003a0908 40020400 40020444     ...@..:....@D..@
 8017940:	00000400 400204a8 003b0a0c 40020400     .......@..;....@
 8017950:	40020458 00000800 400204a8 003c0b10     X..@.......@..<.
 8017960:	40020400 4002046c 00001000 400204a8     ...@l..@.......@
 8017970:	00440c14 40020400 40020480 00002000     ..D....@...@. ..
 8017980:	400204a8 00450d18 00000000 00000000     ...@..E.........

08017990 <ep0config>:
 8017990:	00000000 08007011 08007171 08007271     .....p..qq..qr..
 80179a0:	00400040 20000d74 20000d74 00000001     @.@.t.. t.. ....
 80179b0:	20000d84                                ... 

080179b4 <fsparams>:
 80179b4:	00000080 00000140 00000003 5f627375     ....@.......usb_
 80179c4:	5f646c6c 706d7570 00000000              lld_pump....

080179d0 <sdc_default_cfg>:
 80179d0:	00000000 00000001 00000000 00000000     ................

080179e0 <dummytx>:
 80179e0:	0000ffff 20414d44 6c696166 00657275     ....DMA failure.

080179f0 <default_config>:
 80179f0:	00009600 00000000 00004000 00000000     .........@......

08017a00 <pal_default_config>:
 8017a00:	ebffab73 00000000 c3f0fcc0 28000008     s..............(
 8017a10:	0000ffff 55500000 000000b0 00000000     ......PU........
 8017a20:	00000000 b9fcafd4 00000000 cf0f3c3f     ............?<..
 8017a30:	000a0002 0000ffff 06000000 505b0000     ..............[P
	...
 8017a48:	0efff1ec 00000000 0fc3cf3c 00000822     ........<..."...
 8017a58:	0000fdff 00000600 00080000 00000000     ................
 8017a68:	00000000 ffffffef 00000000 ffffffff     ................
 8017a78:	00000000 0000fffe 00000800 00000000     ................
	...
 8017a90:	ffffffff 00000000 ffffffff 55500009     ..............PU
 8017aa0:	0000feff 6ddd0d00 aaaaaa60 00000000     .......m`.......
 8017ab0:	00000000 ffffffff 00000000 ffffffff     ................
 8017ac0:	00000000 0000ffff 00000000 00000000     ................
	...
 8017ad8:	fdffffff 00000000 00000000 00000000     ................
 8017ae8:	0000ffff 00000000 00000000 00000000     ................
 8017af8:	00000000 fffffffd 00000000 00000003     ................
 8017b08:	00000000 0000ffff 00000000 00000000     ................
	...

08017b20 <wa>:
 8017b20:	20001bb8 20001d00 20001e48 20001f90     ... ... H.. ... 
 8017b30:	200020d8 00000a0d 00000000 202a2a2a     . . ........*** 
 8017b40:	62696843 2f534f69 74205452 20747365     ChibiOS/RT test 
 8017b50:	74697573 00000065 002a2a2a 202a2a2a     suite...***.*** 
 8017b60:	6e72654b 203a6c65 20202020 00002020     Kernel:       ..
 8017b70:	2e312e33 00000035 202a2a2a 706d6f43     3.1.5...*** Comp
 8017b80:	64656c69 2020203a 00002020 20727041     iled:     ..Apr 
 8017b90:	32203931 20373130 3631202d 3a33353a     19 2017 - 16:53:
 8017ba0:	00003231 202a2a2a 706d6f43 72656c69     12..*** Compiler
 8017bb0:	2020203a 00002020 20434347 2e382e34     :     ..GCC 4.8.
 8017bc0:	30322034 35303431 28203632 656c6572     4 20140526 (rele
 8017bd0:	29657361 52415b20 6d652f4d 64646562     ase) [ARM/embedd
 8017be0:	342d6465 622d385f 636e6172 65722068     ed-4_8-branch re
 8017bf0:	69736976 32206e6f 35333131 00005d38     vision 211358]..
 8017c00:	202a2a2a 68637241 63657469 65727574     *** Architecture
 8017c10:	0000203a 764d5241 4d2d4537 00000000     : ..ARMv7E-M....
 8017c20:	202a2a2a 65726f43 72615620 746e6169     *** Core Variant
 8017c30:	0000203a 74726f43 4d2d7865 00000034     : ..Cortex-M4...
 8017c40:	202a2a2a 74726f50 666e4920 20203a6f     *** Port Info:  
 8017c50:	00002020 61766441 6465636e 72656b20       ..Advanced ker
 8017c60:	206c656e 65646f6d 00000000 202a2a2a     nel mode....*** 
 8017c70:	74616c50 6d726f66 2020203a 00002020     Platform:     ..
 8017c80:	334d5453 78344c32 6c552078 20617274     STM32L4xx Ultra 
 8017c90:	20776f4c 65776f50 00000072 202a2a2a     Low Power...*** 
 8017ca0:	74736554 616f4220 203a6472 00002020     Test Board:   ..
 8017cb0:	53205453 6f736e65 6c697472 00002065     ST Sensortile ..
 8017cc0:	202d2d2d 74736554 73614320 00002065     --- Test Case ..
 8017cd0:	0000002e 00002820 00000029 202d2d2d     .... (..)...--- 
 8017ce0:	75736552 203a746c 4c494146 20455255     Result: FAILURE 
 8017cf0:	00002328 00005b20 0000295d 202d2d2d     (#.. [..])..--- 
 8017d00:	75736552 203a746c 43435553 00535345     Result: SUCCESS.
 8017d10:	616e6946 6572206c 746c7573 0000203a     Final result: ..
 8017d20:	4c494146 00455255 43435553 00535345     FAILURE.SUCCESS.
 8017d30:	00000045 00000044 00000043 00000042     E...D...C...B...
 8017d40:	00000041 44434241 00000045 65726854     A...ABCDE...Thre
 8017d50:	2c736461 716e6520 69756575 7420676e     ads, enqueuing t
 8017d60:	20747365 00003123                       est #1..

08017d68 <testthd1>:
 8017d68:	08017d4c 00000000 00000000 0800c431     L}..........1...
 8017d78:	65726854 2c736461 716e6520 69756575     Threads, enqueui
 8017d88:	7420676e 20747365 00003223              ng test #2..

08017d94 <testthd2>:
 8017d94:	08017d78 00000000 00000000 0800c531     x}..........1...
 8017da4:	65726854 2c736461 69727020 7469726f     Threads, priorit
 8017db4:	68632079 65676e61 00000000              y change....

08017dc0 <testthd3>:
 8017dc0:	08017da4 00000000 00000000 0800c641     .}..........A...
 8017dd0:	65726854 2c736461 6c656420 00737961     Threads, delays.

08017de0 <testthd4>:
 8017de0:	08017dd0 00000000 00000000 0800c831     .}..........1...

08017df0 <patternthd>:
 8017df0:	08017d68 08017d94 08017dc0 08017de0     h}...}...}...}..
	...
 8017e10:	00000041 00000042 00000043 00000044     A...B...C...D...
 8017e20:	00000045 44434241 00000045 616d6553     E...ABCDE...Sema
 8017e30:	726f6870 202c7365 75716e65 6e697565     phores, enqueuin
 8017e40:	00000067                                g...

08017e44 <testsem1>:
 8017e44:	08017e2c 0800ca81 00000000 0800cab1     ,~..............
 8017e54:	616d6553 726f6870 202c7365 656d6974     Semaphores, time
 8017e64:	0074756f                                out.

08017e68 <testsem2>:
 8017e68:	08017e54 0800cc31 00000000 0800cc71     T~..1.......q...
 8017e78:	616d6553 726f6870 202c7365 6d6f7461     Semaphores, atom
 8017e88:	73206369 616e6769 61772d6c 00007469     ic signal-wait..

08017e98 <testsem3>:
 8017e98:	08017e78 0800ce31 00000000 0800ce61     x~..1.......a...
 8017ea8:	616e6942 53207972 70616d65 65726f68     Binary Semaphore
 8017eb8:	66202c73 74636e75 616e6f69 7974696c     s, functionality
 8017ec8:	00000000                                ....

08017ecc <testsem4>:
 8017ecc:	08017ea8 00000000 00000000 0800cf41     .~..........A...

08017edc <patternsem>:
 8017edc:	08017e44 08017e68 08017e98 08017ecc     D~..h~...~...~..
 8017eec:	00000000 00000045 00000044 00000043     ....E...D...C...
 8017efc:	00000042 00000041 44434241 00000045     B...A...ABCDE...
 8017f0c:	6574754d 2c736578 69727020 7469726f     Mutexes, priorit
 8017f1c:	6e652079 75657571 20676e69 74736574     y enqueuing test
 8017f2c:	00000000                                ....

08017f30 <testmtx1>:
 8017f30:	08017f0c 0800d161 00000000 0800d1a1     ....a...........
 8017f40:	6574754d 2c736578 69727020 7469726f     Mutexes, priorit
 8017f50:	65722079 6e727574 00000000              y return....

08017f5c <testmtx4>:
 8017f5c:	08017f40 0800d2c1 00000000 0800d341     @...........A...
 8017f6c:	6574754d 2c736578 61747320 00737574     Mutexes, status.

08017f7c <testmtx5>:
 8017f7c:	08017f6c 0800d641 00000000 0800d651     l...A.......Q...
 8017f8c:	646e6f43 2c726156 67697320 206c616e     CondVar, signal 
 8017f9c:	74736574 00000000                       test....

08017fa4 <testmtx6>:
 8017fa4:	08017f8c 0800d761 00000000 0800d7b1     ....a...........
 8017fb4:	646e6f43 2c726156 6f726220 61636461     CondVar, broadca
 8017fc4:	74207473 00747365                       st test.

08017fcc <testmtx7>:
 8017fcc:	08017fb4 0800d8d1 00000000 0800d8f1     ................
 8017fdc:	00434241 646e6f43 2c726156 6f6f6220     ABC.CondVar, boo
 8017fec:	74207473 00747365                       st test.

08017ff4 <testmtx8>:
 8017ff4:	08017fe0 0800d9f1 00000000 0800daa1     ................

08018004 <patternmtx>:
 8018004:	08017f30 08017f5c 08017f7c 08017fa4     0...\...|.......
 8018014:	08017fcc 08017ff4 00000000 00434241     ............ABC.
 8018024:	7373654d 73656761 6f6c202c 0000706f     Messages, loop..

08018034 <testmsg1>:
 8018034:	08018024 00000000 00000000 0800dbc1     $...............

08018044 <patternmsg>:
 8018044:	08018034 00000000 00000000 44434241     4...........ABCD
 8018054:	00000045 6c69614d 65786f62 71202c73     E...Mailboxes, q
 8018064:	69756575 6120676e 7420646e 6f656d69     ueuing and timeo
 8018074:	00737475                                uts.

08018078 <testmbox1>:
 8018078:	08018058 0800dd01 00000000 0800dd21     X...........!...

08018088 <patternmbox>:
 8018088:	08018078 00000000                       x.......

08018090 <evhndl>:
 8018090:	0800e651 0800e671 0800e691 00434241     Q...q.......ABC.
 80180a0:	6e657645 202c7374 69676572 61727473     Events, registra
 80180b0:	6e6f6974 646e6120 73696420 63746170     tion and dispatc
 80180c0:	00000068                                h...

080180c4 <testevt1>:
 80180c4:	080180a0 0800e641 00000000 0800e6b1     ....A...........
 80180d4:	00000041 6e657645 202c7374 74696177     A...Events, wait
 80180e4:	646e6120 6f726220 61636461 00007473      and broadcast..

080180f4 <testevt2>:
 80180f4:	080180d8 0800e771 00000000 0800e7d1     ....q...........
 8018104:	6e657645 202c7374 656d6974 7374756f     Events, timeouts
 8018114:	00000000                                ....

08018118 <testevt3>:
 8018118:	08018104 0800eb31 00000000 0800eb41     ....1.......A...

08018128 <patternevt>:
 8018128:	080180c4 080180f4 08018118 00000000     ................
	...
 8018140:	70616548 6c61202c 61636f6c 6e6f6974     Heap, allocation
 8018150:	646e6120 61726620 6e656d67 69746174      and fragmentati
 8018160:	74206e6f 00747365                       on test.

08018168 <testheap1>:
 8018168:	08018140 0800ec41 00000000 0800ec61     @...A.......a...

08018178 <patternheap>:
 8018178:	08018168 00000000 6f6d654d 50207972     h.......Memory P
 8018188:	736c6f6f 7571202c 2f657565 75716564     ools, queue/dequ
 8018198:	00657565                                eue.

0801819c <testpools1>:
 801819c:	08018180 0800ef51 00000000 0800ef71     ....Q.......q...

080181ac <patternpools>:
 80181ac:	0801819c 00000000 00000000 00000000     ................
 80181bc:	00000000 00000041 00000042 00000043     ....A...B...C...
 80181cc:	00004241 616e7944 2063696d 73495041     AB..Dynamic APIs
 80181dc:	6874202c 64616572 72632073 69746165     , threads creati
 80181ec:	66206e6f 206d6f72 70616568 00000000     on from heap....

080181fc <testdyn1>:
 80181fc:	080181d0 0800f0d1 00000000 0800f0f1     ................
 801820c:	00000044 00000045 44434241 00000000     D...E...ABCD....
 801821c:	616e7944 2063696d 73495041 6874202c     Dynamic APIs, th
 801822c:	64616572 72632073 69746165 66206e6f     reads creation f
 801823c:	206d6f72 6f6d656d 70207972 006c6f6f     rom memory pool.

0801824c <testdyn2>:
 801824c:	0801821c 0800f241 00000000 0800f261     ....A.......a...
 801825c:	616e7944 2063696d 73495041 6572202c     Dynamic APIs, re
 801826c:	74736967 61207972 7220646e 72656665     gistry and refer
 801827c:	65636e65 00000073                       ences...

08018284 <testdyn3>:
 8018284:	0801825c 0800f431 00000000 0800f451     \...1.......Q...

08018294 <patterndyn>:
 8018294:	080181fc 0801824c 08018284 00000000     ....L...........
	...
 80182b0:	44434241 00000000 75657551 202c7365     ABCD....Queues, 
 80182c0:	75706e69 75712074 73657565 00000000     input queues....

080182d0 <testqueues1>:
 80182d0:	080182b8 0800f791 00000000 0800f7e1     ................
 80182e0:	75657551 202c7365 7074756f 71207475     Queues, output q
 80182f0:	65756575 00000073                       ueues...

080182f8 <testqueues2>:
 80182f8:	080182e0 0800faf1 00000000 0800fb41     ............A...

08018308 <patternqueues>:
 8018308:	080182d0 080182f8 00000000 00000000     ................
	...
 8018320:	74737953 202c6d65 74697263 6c616369     System, critical
 8018330:	6e6f7a20 00007365                        zones..

08018338 <testsys1>:
 8018338:	08018320 00000000 00000000 08010081      ...............
 8018348:	74737953 202c6d65 65746e69 70757272     System, interrup
 8018358:	68207374 6c646e61 00676e69              ts handling.

08018364 <testsys2>:
 8018364:	08018348 00000000 00000000 08010111     H...............
 8018374:	74737953 202c6d65 65746e69 74697267     System, integrit
 8018384:	00000079                                y...

08018388 <testsys3>:
 8018388:	08018374 00000000 00000000 08010131     t...........1...

08018398 <patternsys>:
 8018398:	08018338 08018364 08018388 00000000     8...d...........
	...
 80183b0:	202d2d2d 726f6353 203a2065 00000000     --- Score : ....
 80183c0:	67736d20 2c532f73 00000020 78746320      msgs/S, ... ctx
 80183d0:	2f637773 00000053 636e6542 72616d68     swc/S...Benchmar
 80183e0:	6d202c6b 61737365 20736567 00003123     k, messages #1..

080183f0 <testbmk1>:
 80183f0:	080183d8 00000000 00000000 08010391     ................
 8018400:	636e6542 72616d68 6d202c6b 61737365     Benchmark, messa
 8018410:	20736567 00003223                       ges #2..

08018418 <testbmk2>:
 8018418:	08018400 00000000 00000000 08010411     ................
 8018428:	636e6542 72616d68 6d202c6b 61737365     Benchmark, messa
 8018438:	20736567 00003323                       ges #3..

08018440 <testbmk3>:
 8018440:	08018428 00000000 00000000 08010491     (...............
 8018450:	636e6542 72616d68 63202c6b 65746e6f     Benchmark, conte
 8018460:	73207478 63746977 00000068              xt switch...

0801846c <testbmk4>:
 801846c:	08018450 00000000 00000000 080105d1     P...............
 801847c:	72687420 73646165 0000532f 636e6542      threads/S..Benc
 801848c:	72616d68 74202c6b 61657268 202c7364     hmark, threads, 
 801849c:	6c6c7566 63796320 0000656c              full cycle..

080184a8 <testbmk5>:
 80184a8:	08018488 00000000 00000000 080106a1     ................
 80184b8:	636e6542 72616d68 74202c6b 61657268     Benchmark, threa
 80184c8:	202c7364 61657263 6f206574 00796c6e     ds, create only.

080184d8 <testbmk6>:
 80184d8:	080184b8 00000000 00000000 08010721     ............!...
 80184e8:	73657220 64656863 73656c75 202c532f      reschedules/S, 
 80184f8:	00000000 636e6542 72616d68 6d202c6b     ....Benchmark, m
 8018508:	20737361 63736572 75646568 202c656c     ass reschedule, 
 8018518:	68742035 64616572 00000073              5 threads...

08018524 <testbmk7>:
 8018524:	080184fc 080107d1 00000000 080107e1     ................
 8018534:	636e6542 72616d68 72202c6b 646e756f     Benchmark, round
 8018544:	626f7220 63206e69 65746e6f 73207478      robin context s
 8018554:	63746977 676e6968 00000000              witching....

08018560 <testbmk8>:
 8018560:	08018534 00000000 00000000 08010961     4...........a...
 8018570:	74796220 532f7365 00000000 636e6542      bytes/S....Benc
 8018580:	72616d68 49202c6b 51204f2f 65756575     hmark, I/O Queue
 8018590:	68742073 67756f72 74757068 00000000     s throughput....

080185a0 <testbmk9>:
 80185a0:	0801857c 00000000 00000000 08010a61     |...........a...
 80185b0:	6d697420 2f737265 00000053 636e6542      timers/S...Benc
 80185c0:	72616d68 76202c6b 75747269 74206c61     hmark, virtual t
 80185d0:	72656d69 65732073 65722f74 00746573     imers set/reset.

080185e0 <testbmk10>:
 80185e0:	080185bc 00000000 00000000 08010b21     ............!...
 80185f0:	69617720 69732b74 6c616e67 0000532f      wait+signal/S..
 8018600:	636e6542 72616d68 73202c6b 70616d65     Benchmark, semap
 8018610:	65726f68 61772073 732f7469 616e6769     hores wait/signa
 8018620:	0000006c                                l...

08018624 <testbmk11>:
 8018624:	08018600 08010bb1 00000000 08010bc1     ................
 8018634:	636f6c20 6e752b6b 6b636f6c 0000532f      lock+unlock/S..
 8018644:	636e6542 72616d68 6d202c6b 78657475     Benchmark, mutex
 8018654:	6c207365 2f6b636f 6f6c6e75 00006b63     es lock/unlock..

08018664 <testbmk12>:
 8018664:	08018644 08010c51 00000000 08010c61     D...Q.......a...
 8018674:	202d2d2d 74737953 203a6d65 00000000     --- System: ....
 8018684:	74796220 00007365 202d2d2d 65726854      bytes..--- Thre
 8018694:	203a6461 00000000 202d2d2d 656d6954     ad: ....--- Time
 80186a4:	203a2072 00000000 202d2d2d 616d6553     r : ....--- Sema
 80186b4:	203a6870 00000000 202d2d2d 6e657645     ph: ....--- Even
 80186c4:	203a5374 00000000 202d2d2d 6e657645     tS: ....--- Even
 80186d4:	203a4c74 00000000 202d2d2d 6574754d     tL: ....--- Mute
 80186e4:	203a2078 00000000 202d2d2d 646e6f43     x : ....--- Cond
 80186f4:	203a2e56 00000000 202d2d2d 75657551     V.: ....--- Queu
 8018704:	203a2065 00000000 202d2d2d 6c69614d     e : ....--- Mail
 8018714:	203a2e42 00000000 636e6542 72616d68     B.: ....Benchmar
 8018724:	52202c6b 66204d41 70746f6f 746e6972     k, RAM footprint
 8018734:	00000000                                ....

08018738 <testbmk13>:
 8018738:	0801871c 00000000 00000000 08010cf1     ................

08018748 <patternbmk>:
 8018748:	080183f0 08018418 08018440 0801846c     ........@...l...
 8018758:	080184a8 080184d8 08018524 08018560     ........$...`...
 8018768:	080185a0 080185e0 08018624 08018664     ........$...d...
 8018778:	08018738 00000000                       8.......

08018780 <vmt>:
 8018780:	08010fe1 08011041 080110a1 080110f1     ....A...........
 8018790:	6c756e28 0000296c 00000000 00000000     (null)..........
 80187a0:	67617355 25203a65 000a0d73 00207325     Usage: %s...%s .
 80187b0:	6f666e69 00000000 6e72654b 203a6c65     info....Kernel: 
 80187c0:	20202020 73252020 00000a0d 2e312e33           %s....3.1.
 80187d0:	00000035 706d6f43 72656c69 2020203a     5...Compiler:   
 80187e0:	73252020 00000a0d 20434347 2e382e34       %s....GCC 4.8.
 80187f0:	30322034 35303431 28203632 656c6572     4 20140526 (rele
 8018800:	29657361 52415b20 6d652f4d 64646562     ase) [ARM/embedd
 8018810:	342d6465 622d385f 636e6172 65722068     ed-4_8-branch re
 8018820:	69736976 32206e6f 35333131 00005d38     vision 211358]..
 8018830:	68637241 63657469 65727574 7325203a     Architecture: %s
 8018840:	00000a0d 764d5241 4d2d4537 00000000     ....ARMv7E-M....
 8018850:	65726f43 72615620 746e6169 7325203a     Core Variant: %s
 8018860:	00000a0d 74726f43 4d2d7865 00000034     ....Cortex-M4...
 8018870:	74726f50 666e4920 20203a6f 73252020     Port Info:    %s
 8018880:	00000a0d 61766441 6465636e 72656b20     ....Advanced ker
 8018890:	206c656e 65646f6d 00000000 74616c50     nel mode....Plat
 80188a0:	6d726f66 2020203a 73252020 00000a0d     form:     %s....
 80188b0:	334d5453 78344c32 6c552078 20617274     STM32L4xx Ultra 
 80188c0:	20776f4c 65776f50 00000072 72616f42     Low Power...Boar
 80188d0:	20203a64 20202020 73252020 00000a0d     d:        %s....
 80188e0:	53205453 6f736e65 6c697472 00002065     ST Sensortile ..
 80188f0:	6c697542 69742064 203a656d 73252020     Build time:   %s
 8018900:	73257325 00000a0d 20727041 32203931     %s%s....Apr 19 2
 8018910:	00373130 00202d20 353a3631 34313a33     017. - .16:53:14
 8018920:	00000000 74737973 00656d69 0d756c25     ....systime.%lu.
 8018930:	0000000a                                ....

08018934 <local_commands>:
 8018934:	080187b0 08011891 08018924 08011961     ........$...a...
	...
 801894c:	6c656873 0000006c 68430a0d 4f696269     shell.....ChibiO
 801895c:	54522f53 65685320 0a0d6c6c 00000000     S/RT Shell......
 801896c:	203e6863 00000000 6f6c0a0d 74756f67     ch> ......logout
 801897c:	00000000 00000920 206f6f74 796e616d     .... ...too many
 801898c:	67726120 6e656d75 0a0d7374 00000000      arguments......
 801899c:	74697865 00000000 706c6568 00000000     exit....help....
 80189ac:	6d6d6f43 73646e61 6568203a 6520706c     Commands: help e
 80189bc:	20746978 00000000 00000a0d 00007325     xit ........%s..
 80189cc:	0a0d3f20 00000000 0000445e 00000000      ?......^D......
 80189dc:	00000000                                ....

080189e0 <LSM303AGR_ACC_Sensitivity_List>:
 80189e0:	000003d4 00000000 0000079e 00000000     ................
 80189f0:	00000f3c 00000000 00002dc8 00000000     <........-......
 8018a00:	00000f3c 00000000 00001e8c 00000000     <...............
 8018a10:	00003d0e 00000000 0000b734 00000000     .=......4.......
 8018a20:	00003d0e 00000000 00007a1c 00000000     .=.......z......
 8018a30:	0000f438 00000000 0002dcbc 00000000     8...............

08018a40 <time_stamp>:
 8018a40:	ffffffff ffffffff ffffffff ffffffff     ................
 8018a50:	ffffffff ffffffff ffffffff ffffffff     ................
 8018a60:	ffffffff ffffffff ffffffff ffffffff     ................
 8018a70:	ffffffff ffffffff ffffffff ffffffff     ................
 8018a80:	ffffffff ffffffff ffffffff ffffffff     ................
 8018a90:	ffffffff ffffffff ffffffff ffffffff     ................
 8018aa0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018ab0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018ac0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018ad0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018ae0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018af0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018b00:	ffffffff ffffffff ffffffff ffffffff     ................
 8018b10:	ffffffff ffffffff ffffffff ffffffff     ................
 8018b20:	ffffffff ffffffff ffffffff ffffffff     ................
 8018b30:	ffffffff ffffffff ffffffff ffffffff     ................
 8018b40:	ffffffff ffffffff ffffffff ffffffff     ................
 8018b50:	ffffffff ffffffff ffffffff ffffffff     ................
 8018b60:	ffffffff ffffffff ffffffff ffffffff     ................
 8018b70:	ffffffff ffffffff ffffffff ffffffff     ................
 8018b80:	ffffffff ffffffff ffffffff ffffffff     ................
 8018b90:	ffffffff ffffffff ffffffff ffffffff     ................
 8018ba0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018bb0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018bc0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018bd0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018be0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018bf0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018c00:	ffffffff ffffffff ffffffff ffffffff     ................
 8018c10:	ffffffff ffffffff ffffffff ffffffff     ................
 8018c20:	ffffffff ffffffff ffffffff ffffffff     ................
 8018c30:	ffffffff ffffffff ffffffff ffffffff     ................
 8018c40:	ffffffff ffffffff ffffffff ffffffff     ................
 8018c50:	ffffffff ffffffff ffffffff ffffffff     ................
 8018c60:	ffffffff ffffffff ffffffff ffffffff     ................
 8018c70:	ffffffff ffffffff ffffffff ffffffff     ................
 8018c80:	ffffffff ffffffff ffffffff ffffffff     ................
 8018c90:	ffffffff ffffffff ffffffff ffffffff     ................
 8018ca0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018cb0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018cc0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018cd0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018ce0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018cf0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018d00:	ffffffff ffffffff ffffffff ffffffff     ................
 8018d10:	ffffffff ffffffff ffffffff ffffffff     ................
 8018d20:	ffffffff ffffffff ffffffff ffffffff     ................
 8018d30:	ffffffff ffffffff ffffffff ffffffff     ................
 8018d40:	ffffffff ffffffff ffffffff ffffffff     ................
 8018d50:	ffffffff ffffffff ffffffff ffffffff     ................
 8018d60:	ffffffff ffffffff ffffffff ffffffff     ................
 8018d70:	ffffffff ffffffff ffffffff ffffffff     ................
 8018d80:	ffffffff ffffffff ffffffff ffffffff     ................
 8018d90:	ffffffff ffffffff ffffffff ffffffff     ................
 8018da0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018db0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018dc0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018dd0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018de0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018df0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018e00:	ffffffff ffffffff ffffffff ffffffff     ................
 8018e10:	ffffffff ffffffff ffffffff ffffffff     ................
 8018e20:	ffffffff ffffffff ffffffff ffffffff     ................
 8018e30:	ffffffff ffffffff ffffffff ffffffff     ................
 8018e40:	ffffffff ffffffff ffffffff ffffffff     ................
 8018e50:	ffffffff ffffffff ffffffff ffffffff     ................
 8018e60:	ffffffff ffffffff ffffffff ffffffff     ................
 8018e70:	ffffffff ffffffff ffffffff ffffffff     ................
 8018e80:	ffffffff ffffffff ffffffff ffffffff     ................
 8018e90:	ffffffff ffffffff ffffffff ffffffff     ................
 8018ea0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018eb0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018ec0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018ed0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018ee0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018ef0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018f00:	ffffffff ffffffff ffffffff ffffffff     ................
 8018f10:	ffffffff ffffffff ffffffff ffffffff     ................
 8018f20:	ffffffff ffffffff ffffffff ffffffff     ................
 8018f30:	ffffffff ffffffff ffffffff ffffffff     ................
 8018f40:	ffffffff ffffffff ffffffff ffffffff     ................
 8018f50:	ffffffff ffffffff ffffffff ffffffff     ................
 8018f60:	ffffffff ffffffff ffffffff ffffffff     ................
 8018f70:	ffffffff ffffffff ffffffff ffffffff     ................
 8018f80:	ffffffff ffffffff ffffffff ffffffff     ................
 8018f90:	ffffffff ffffffff ffffffff ffffffff     ................
 8018fa0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018fb0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018fc0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018fd0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018fe0:	ffffffff ffffffff ffffffff ffffffff     ................
 8018ff0:	ffffffff ffffffff ffffffff ffffffff     ................
 8019000:	ffffffff ffffffff ffffffff ffffffff     ................
 8019010:	ffffffff ffffffff ffffffff ffffffff     ................
 8019020:	ffffffff ffffffff ffffffff ffffffff     ................
 8019030:	ffffffff ffffffff ffffffff ffffffff     ................
 8019040:	ffffffff ffffffff ffffffff ffffffff     ................
 8019050:	ffffffff ffffffff ffffffff ffffffff     ................
 8019060:	ffffffff ffffffff ffffffff ffffffff     ................
 8019070:	ffffffff ffffffff ffffffff ffffffff     ................
 8019080:	ffffffff ffffffff ffffffff ffffffff     ................
 8019090:	ffffffff ffffffff ffffffff ffffffff     ................
 80190a0:	ffffffff ffffffff ffffffff ffffffff     ................
 80190b0:	ffffffff ffffffff ffffffff ffffffff     ................
 80190c0:	ffffffff ffffffff ffffffff ffffffff     ................
 80190d0:	ffffffff ffffffff ffffffff ffffffff     ................
 80190e0:	ffffffff ffffffff ffffffff ffffffff     ................
 80190f0:	ffffffff ffffffff ffffffff ffffffff     ................
 8019100:	ffffffff ffffffff ffffffff ffffffff     ................
 8019110:	ffffffff ffffffff ffffffff ffffffff     ................
 8019120:	ffffffff ffffffff ffffffff ffffffff     ................
 8019130:	ffffffff ffffffff ffffffff ffffffff     ................
 8019140:	ffffffff ffffffff ffffffff ffffffff     ................
 8019150:	ffffffff ffffffff ffffffff ffffffff     ................
 8019160:	ffffffff ffffffff ffffffff ffffffff     ................
 8019170:	ffffffff ffffffff ffffffff ffffffff     ................
 8019180:	ffffffff ffffffff ffffffff ffffffff     ................
 8019190:	ffffffff ffffffff ffffffff ffffffff     ................
 80191a0:	ffffffff ffffffff ffffffff ffffffff     ................
 80191b0:	ffffffff ffffffff ffffffff ffffffff     ................
 80191c0:	ffffffff ffffffff ffffffff ffffffff     ................
 80191d0:	ffffffff ffffffff ffffffff ffffffff     ................
 80191e0:	ffffffff ffffffff ffffffff ffffffff     ................
 80191f0:	ffffffff ffffffff ffffffff ffffffff     ................
 8019200:	ffffffff ffffffff ffffffff ffffffff     ................
 8019210:	ffffffff ffffffff ffffffff ffffffff     ................
 8019220:	ffffffff ffffffff ffffffff ffffffff     ................
 8019230:	ffffffff ffffffff ffffffff ffffffff     ................
 8019240:	ffffffff ffffffff ffffffff ffffffff     ................
 8019250:	ffffffff ffffffff ffffffff ffffffff     ................
 8019260:	ffffffff ffffffff ffffffff ffffffff     ................
 8019270:	ffffffff ffffffff ffffffff ffffffff     ................
 8019280:	ffffffff ffffffff ffffffff ffffffff     ................
 8019290:	ffffffff ffffffff ffffffff ffffffff     ................
 80192a0:	ffffffff ffffffff ffffffff ffffffff     ................
 80192b0:	ffffffff ffffffff ffffffff ffffffff     ................
 80192c0:	ffffffff ffffffff ffffffff ffffffff     ................
 80192d0:	ffffffff ffffffff ffffffff ffffffff     ................
 80192e0:	ffffffff ffffffff ffffffff ffffffff     ................
 80192f0:	ffffffff ffffffff ffffffff ffffffff     ................
 8019300:	ffffffff ffffffff ffffffff ffffffff     ................
 8019310:	ffffffff ffffffff ffffffff ffffffff     ................
 8019320:	ffffffff ffffffff ffffffff ffffffff     ................
 8019330:	ffffffff ffffffff ffffffff ffffffff     ................
 8019340:	ffffffff ffffffff ffffffff ffffffff     ................
 8019350:	ffffffff ffffffff ffffffff ffffffff     ................
 8019360:	ffffffff ffffffff ffffffff ffffffff     ................
 8019370:	ffffffff ffffffff ffffffff ffffffff     ................
 8019380:	ffffffff ffffffff ffffffff ffffffff     ................
 8019390:	ffffffff ffffffff ffffffff ffffffff     ................
 80193a0:	ffffffff ffffffff ffffffff ffffffff     ................
 80193b0:	ffffffff ffffffff ffffffff ffffffff     ................
 80193c0:	ffffffff ffffffff ffffffff ffffffff     ................
 80193d0:	ffffffff ffffffff ffffffff ffffffff     ................
 80193e0:	ffffffff ffffffff ffffffff ffffffff     ................
 80193f0:	ffffffff ffffffff ffffffff ffffffff     ................
 8019400:	ffffffff ffffffff ffffffff ffffffff     ................
 8019410:	ffffffff ffffffff ffffffff ffffffff     ................
 8019420:	ffffffff ffffffff ffffffff ffffffff     ................
 8019430:	ffffffff ffffffff ffffffff ffffffff     ................
 8019440:	ffffffff ffffffff ffffffff ffffffff     ................
 8019450:	ffffffff ffffffff ffffffff ffffffff     ................
 8019460:	ffffffff ffffffff ffffffff ffffffff     ................
 8019470:	ffffffff ffffffff ffffffff ffffffff     ................
 8019480:	ffffffff ffffffff ffffffff ffffffff     ................
 8019490:	ffffffff ffffffff ffffffff ffffffff     ................
 80194a0:	ffffffff ffffffff ffffffff ffffffff     ................
 80194b0:	ffffffff ffffffff ffffffff ffffffff     ................
 80194c0:	ffffffff ffffffff ffffffff ffffffff     ................
 80194d0:	ffffffff ffffffff ffffffff ffffffff     ................
 80194e0:	ffffffff ffffffff ffffffff ffffffff     ................
 80194f0:	ffffffff ffffffff ffffffff ffffffff     ................
 8019500:	ffffffff ffffffff ffffffff ffffffff     ................
 8019510:	ffffffff ffffffff ffffffff ffffffff     ................
 8019520:	ffffffff ffffffff ffffffff ffffffff     ................
 8019530:	ffffffff ffffffff ffffffff ffffffff     ................
 8019540:	ffffffff ffffffff ffffffff ffffffff     ................
 8019550:	ffffffff ffffffff ffffffff ffffffff     ................
 8019560:	ffffffff ffffffff ffffffff ffffffff     ................
 8019570:	ffffffff ffffffff ffffffff ffffffff     ................
 8019580:	6e696c62 0072656b 25203a58 000d0a64     blinker.X: %d...
 8019590:	25203a59 000d0a64 25203a5a 000d0a64     Y: %d...Z: %d...
 80195a0:	656d6974 00000072 6f726874 656c7474     timer...throttle
 80195b0:	00000000 6e756f63 00726574 68206e49     ....counter.In h
 80195c0:	0a657265 0000000d 72636e49 6e656d65     ere.....Incremen
 80195d0:	3a646574 0a642520 0000000d 0d0a7325     ted: %d.....%s..
 80195e0:	00000000 696d2031 6574756e 73616820     ....1 minute has
 80195f0:	74657920 206f7420 73736170 000d0a2e      yet to pass....
 8019600:	756e694d 203a6574 7c206425 756f4320     Minute: %d | Cou
 8019610:	203a746e 0d0a6425 00000000 00006325     nt: %d......%c..
 8019620:	00000d0a 72616579 7525203a 00000020     ....year: %u ...
 8019630:	3a6e6f6d 20752520 00000000 3a796164     mon: %u ....day:
 8019640:	20752520 00000000 3a776f64 20752520      %u ....dow: %u 
 8019650:	00000000 203a736d 0d0a7525 00000000     ....ms: %u......
 8019660:	72616559 6425203a 4d207c20 68746e6f     Year: %d | Month
 8019670:	6425203a 44207c20 203a7961 7c206425     : %d | Day: %d |
 8019680:	79614420 20666f20 6b656557 6425203a      Day of Week: %d
 8019690:	53207c20 6e6f6365 203a7364 0d0a6425      | Seconds: %d..
 80196a0:	00000000 6365796d 00006f68 65636361     ....myecho..acce
 80196b0:	0000006c 70736964 5f79616c 6e756f63     l...display_coun
 80196c0:	00007374 5f746567 656d6974 00000000     ts..get_time....
 80196d0:	5f746573 656d6974 00000000              set_time....

080196dc <commands>:
 80196dc:	080196a4 08016641 080196ac 08016681     ....Af.......f..
 80196ec:	080196b4 080166b1 080196c4 08016921     .....f......!i..
 80196fc:	080196d0 08016781 00000000 00000000     .....g..........

0801970c <shell_cfg1>:
 801970c:	20001b20 080196dc 70550d0a 646e6120      .. ......Up and
 801971c:	6e755220 676e696e 00000d0a 00000000      Running........
 801972c:	00000000                                ....

08019730 <_ctype_>:
 8019730:	20202000 20202020 28282020 20282828     .         ((((( 
 8019740:	20202020 20202020 20202020 20202020                     
 8019750:	10108820 10101010 10101010 10101010      ...............
 8019760:	04040410 04040404 10040404 10101010     ................
 8019770:	41411010 41414141 01010101 01010101     ..AAAAAA........
 8019780:	01010101 01010101 01010101 10101010     ................
 8019790:	42421010 42424242 02020202 02020202     ..BBBBBB........
 80197a0:	02020202 02020202 02020202 10101010     ................
 80197b0:	00000020 00000000 00000000 00000000      ...............
	...
 8019840:	00000043 00000000 00000000 00000000     C...............

08019850 <_global_impure_ptr>:
 8019850:	20000918                                ... 
