
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

08000200 <Reset_Handler>:
                .align  2
                .thumb_func
                .global Reset_Handler
Reset_Handler:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 8000200:	b672      	cpsid	i

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 8000202:	4826      	ldr	r0, [pc, #152]	; (800029c <endfiniloop+0x4>)
                msr     PSP, r0
 8000204:	f380 8809 	msr	PSP, r0

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 8000208:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 800020a:	f380 8814 	msr	CONTROL, r0
                isb
 800020e:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 8000212:	f000 f87d 	bl	8000310 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000216:	f00a fe9b 	bl	800af50 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 800021a:	4821      	ldr	r0, [pc, #132]	; (80002a0 <endfiniloop+0x8>)
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 800021c:	4921      	ldr	r1, [pc, #132]	; (80002a4 <endfiniloop+0xc>)
                ldr     r2, =__main_stack_end__
 800021e:	4a22      	ldr	r2, [pc, #136]	; (80002a8 <endfiniloop+0x10>)

08000220 <msloop>:
msloop:
                cmp     r1, r2
 8000220:	4291      	cmp	r1, r2
                itt     lo
 8000222:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000224:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8000228:	f7ff bffa 	bcc.w	8000220 <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 800022c:	491f      	ldr	r1, [pc, #124]	; (80002ac <endfiniloop+0x14>)
                ldr     r2, =__process_stack_end__
 800022e:	4a1b      	ldr	r2, [pc, #108]	; (800029c <endfiniloop+0x4>)

08000230 <psloop>:
psloop:
                cmp     r1, r2
 8000230:	4291      	cmp	r1, r2
                itt     lo
 8000232:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000234:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 8000238:	f7ff bffa 	bcc.w	8000230 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 800023c:	491c      	ldr	r1, [pc, #112]	; (80002b0 <endfiniloop+0x18>)
                ldr     r2, =_data_start
 800023e:	4a1d      	ldr	r2, [pc, #116]	; (80002b4 <endfiniloop+0x1c>)
                ldr     r3, =_data_end
 8000240:	4b1d      	ldr	r3, [pc, #116]	; (80002b8 <endfiniloop+0x20>)

08000242 <dloop>:
dloop:
                cmp     r2, r3
 8000242:	429a      	cmp	r2, r3
                ittt    lo
 8000244:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000246:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 800024a:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 800024e:	f7ff bff8 	bcc.w	8000242 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000252:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
 8000254:	4919      	ldr	r1, [pc, #100]	; (80002bc <endfiniloop+0x24>)
                ldr     r2, =_bss_end
 8000256:	4a1a      	ldr	r2, [pc, #104]	; (80002c0 <endfiniloop+0x28>)

08000258 <bloop>:
bloop:
                cmp     r1, r2
 8000258:	4291      	cmp	r1, r2
                itt     lo
 800025a:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800025c:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8000260:	f7ff bffa 	bcc.w	8000258 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000264:	f000 f874 	bl	8000350 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000268:	f000 f862 	bl	8000330 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 800026c:	4c15      	ldr	r4, [pc, #84]	; (80002c4 <endfiniloop+0x2c>)
                ldr     r5, =__init_array_end
 800026e:	4d16      	ldr	r5, [pc, #88]	; (80002c8 <endfiniloop+0x30>)

08000270 <initloop>:
initloop:
                cmp     r4, r5
 8000270:	42ac      	cmp	r4, r5
                bge     endinitloop
 8000272:	f280 8005 	bge.w	8000280 <endinitloop>
                ldr     r1, [r4], #4
 8000276:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 800027a:	4788      	blx	r1
                b       initloop
 800027c:	f7ff bff8 	b.w	8000270 <initloop>

08000280 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000280:	f010 ffa6 	bl	80111d0 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 8000284:	4c11      	ldr	r4, [pc, #68]	; (80002cc <endfiniloop+0x34>)
                ldr     r5, =__fini_array_end
 8000286:	4d12      	ldr	r5, [pc, #72]	; (80002d0 <endfiniloop+0x38>)

08000288 <finiloop>:
finiloop:
                cmp     r4, r5
 8000288:	42ac      	cmp	r4, r5
                bge     endfiniloop
 800028a:	f280 8005 	bge.w	8000298 <endfiniloop>
                ldr     r1, [r4], #4
 800028e:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000292:	4788      	blx	r1
                b       finiloop
 8000294:	f7ff bff8 	b.w	8000288 <finiloop>

08000298 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 8000298:	f000 b852 	b.w	8000340 <__default_exit>
Reset_Handler:
                /* Interrupts are globally masked initially.*/
                cpsid   i

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 800029c:	20000800 	.word	0x20000800

                /* Early initialization.*/
                bl      __early_init

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 80002a0:	55555555 	.word	0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 80002a4:	20000000 	.word	0x20000000
                ldr     r2, =__main_stack_end__
 80002a8:	20000400 	.word	0x20000400
                blo     msloop

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 80002ac:	20000400 	.word	0x20000400
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 80002b0:	080171e8 	.word	0x080171e8
                ldr     r2, =_data_start
 80002b4:	20000800 	.word	0x20000800
                ldr     r3, =_data_end
 80002b8:	20000900 	.word	0x20000900

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
                ldr     r1, =_bss_start
 80002bc:	20000900 	.word	0x20000900
                ldr     r2, =_bss_end
 80002c0:	200018a4 	.word	0x200018a4
                /* Late initialization..*/
                bl      __late_init

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 80002c4:	08000200 	.word	0x08000200
                ldr     r5, =__init_array_end
 80002c8:	08000200 	.word	0x08000200
                /* Main program invocation, r0 contains the returned value.*/
                bl      main

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 80002cc:	08000200 	.word	0x08000200
                ldr     r5, =__fini_array_end
 80002d0:	08000200 	.word	0x08000200
	...

080002e0 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80002e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                vpush   {s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80002e4:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80002e8:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80002ea:	469d      	mov	sp, r3
#endif

#if CORTEX_USE_FPU
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80002ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002f0 <_port_thread_start>:
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80002f0:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80002f2:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80002f6:	4628      	mov	r0, r5
                blx     r4
 80002f8:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 80002fa:	2000      	movs	r0, #0
                bl      chThdExit
 80002fc:	f001 f838 	bl	8001370 <chThdExit>

08000300 <_port_switch_from_isr>:
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
 8000300:	f000 fdce 	bl	8000ea0 <chSchDoReschedule>

08000304 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 8000304:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 8000306:	e7fe      	b.n	8000306 <_port_exit_from_isr+0x2>
	...

08000310 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8000310:	4770      	bx	lr
 8000312:	bf00      	nop
 8000314:	f3af 8000 	nop.w
 8000318:	f3af 8000 	nop.w
 800031c:	f3af 8000 	nop.w
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __early_init(void) {}
 8000320:	4770      	bx	lr
 8000322:	bf00      	nop
 8000324:	f3af 8000 	nop.w
 8000328:	f3af 8000 	nop.w
 800032c:	f3af 8000 	nop.w

08000330 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8000330:	4770      	bx	lr
 8000332:	bf00      	nop
 8000334:	f3af 8000 	nop.w
 8000338:	f3af 8000 	nop.w
 800033c:	f3af 8000 	nop.w

08000340 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
  }
 8000340:	e7fe      	b.n	8000340 <__default_exit>
 8000342:	bf00      	nop
 8000344:	f3af 8000 	nop.w
 8000348:	f3af 8000 	nop.w
 800034c:	f3af 8000 	nop.w

08000350 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8000350:	b084      	sub	sp, #16
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8000352:	4b16      	ldr	r3, [pc, #88]	; (80003ac <__init_ram_areas+0x5c>)
 8000354:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 8000356:	9b03      	ldr	r3, [sp, #12]
 8000358:	681b      	ldr	r3, [r3, #0]
 800035a:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 800035c:	9b03      	ldr	r3, [sp, #12]
 800035e:	685b      	ldr	r3, [r3, #4]
 8000360:	9301      	str	r3, [sp, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000362:	e009      	b.n	8000378 <__init_ram_areas+0x28>
      *p = *tp;
 8000364:	9b02      	ldr	r3, [sp, #8]
 8000366:	681a      	ldr	r2, [r3, #0]
 8000368:	9b01      	ldr	r3, [sp, #4]
 800036a:	601a      	str	r2, [r3, #0]
      p++;
 800036c:	9b01      	ldr	r3, [sp, #4]
 800036e:	3304      	adds	r3, #4
 8000370:	9301      	str	r3, [sp, #4]
      tp++;
 8000372:	9b02      	ldr	r3, [sp, #8]
 8000374:	3304      	adds	r3, #4
 8000376:	9302      	str	r3, [sp, #8]
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000378:	9b03      	ldr	r3, [sp, #12]
 800037a:	689a      	ldr	r2, [r3, #8]
 800037c:	9b01      	ldr	r3, [sp, #4]
 800037e:	429a      	cmp	r2, r3
 8000380:	d8f0      	bhi.n	8000364 <__init_ram_areas+0x14>
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000382:	e005      	b.n	8000390 <__init_ram_areas+0x40>
      *p = 0;
 8000384:	9b01      	ldr	r3, [sp, #4]
 8000386:	2200      	movs	r2, #0
 8000388:	601a      	str	r2, [r3, #0]
      p++;
 800038a:	9b01      	ldr	r3, [sp, #4]
 800038c:	3304      	adds	r3, #4
 800038e:	9301      	str	r3, [sp, #4]
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000390:	9b03      	ldr	r3, [sp, #12]
 8000392:	68da      	ldr	r2, [r3, #12]
 8000394:	9b01      	ldr	r3, [sp, #4]
 8000396:	429a      	cmp	r2, r3
 8000398:	d8f4      	bhi.n	8000384 <__init_ram_areas+0x34>
      *p = 0;
      p++;
    }
    rap++;
 800039a:	9b03      	ldr	r3, [sp, #12]
 800039c:	3310      	adds	r3, #16
 800039e:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 80003a0:	9a03      	ldr	r2, [sp, #12]
 80003a2:	4b03      	ldr	r3, [pc, #12]	; (80003b0 <__init_ram_areas+0x60>)
 80003a4:	429a      	cmp	r2, r3
 80003a6:	d3d6      	bcc.n	8000356 <__init_ram_areas+0x6>
#endif
}
 80003a8:	b004      	add	sp, #16
 80003aa:	4770      	bx	lr
 80003ac:	08015e90 	.word	0x08015e90
 80003b0:	08015f10 	.word	0x08015f10
 80003b4:	f3af 8000 	nop.w
 80003b8:	f3af 8000 	nop.w
 80003bc:	f3af 8000 	nop.w

080003c0 <_unhandled_exception>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
/*lint -restore*/

  while (true) {
  }
 80003c0:	e7fe      	b.n	80003c0 <_unhandled_exception>
 80003c2:	bf00      	nop
 80003c4:	f3af 8000 	nop.w
 80003c8:	f3af 8000 	nop.w
 80003cc:	f3af 8000 	nop.w

080003d0 <NVIC_SetPriorityGrouping>:
  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80003d0:	b084      	sub	sp, #16
 80003d2:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 80003d4:	9b01      	ldr	r3, [sp, #4]
 80003d6:	f003 0307 	and.w	r3, r3, #7
 80003da:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80003dc:	4b0a      	ldr	r3, [pc, #40]	; (8000408 <NVIC_SetPriorityGrouping+0x38>)
 80003de:	68db      	ldr	r3, [r3, #12]
 80003e0:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 80003e2:	9a02      	ldr	r2, [sp, #8]
 80003e4:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 80003e8:	4013      	ands	r3, r2
 80003ea:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
 80003ec:	9b03      	ldr	r3, [sp, #12]
 80003ee:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80003f0:	9b02      	ldr	r3, [sp, #8]
 80003f2:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 80003f4:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80003f8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80003fc:	9302      	str	r3, [sp, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 80003fe:	4b02      	ldr	r3, [pc, #8]	; (8000408 <NVIC_SetPriorityGrouping+0x38>)
 8000400:	9a02      	ldr	r2, [sp, #8]
 8000402:	60da      	str	r2, [r3, #12]
}
 8000404:	b004      	add	sp, #16
 8000406:	4770      	bx	lr
 8000408:	e000ed00 	.word	0xe000ed00
 800040c:	f3af 8000 	nop.w

08000410 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8000410:	b082      	sub	sp, #8
 8000412:	4603      	mov	r3, r0
 8000414:	9100      	str	r1, [sp, #0]
 8000416:	f88d 3007 	strb.w	r3, [sp, #7]
  if((int32_t)IRQn < 0) {
 800041a:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 800041e:	2b00      	cmp	r3, #0
 8000420:	da0c      	bge.n	800043c <NVIC_SetPriority+0x2c>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000422:	490c      	ldr	r1, [pc, #48]	; (8000454 <NVIC_SetPriority+0x44>)
 8000424:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000428:	f003 030f 	and.w	r3, r3, #15
 800042c:	3b04      	subs	r3, #4
 800042e:	9a00      	ldr	r2, [sp, #0]
 8000430:	b2d2      	uxtb	r2, r2
 8000432:	0112      	lsls	r2, r2, #4
 8000434:	b2d2      	uxtb	r2, r2
 8000436:	440b      	add	r3, r1
 8000438:	761a      	strb	r2, [r3, #24]
 800043a:	e009      	b.n	8000450 <NVIC_SetPriority+0x40>
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800043c:	4906      	ldr	r1, [pc, #24]	; (8000458 <NVIC_SetPriority+0x48>)
 800043e:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8000442:	9a00      	ldr	r2, [sp, #0]
 8000444:	b2d2      	uxtb	r2, r2
 8000446:	0112      	lsls	r2, r2, #4
 8000448:	b2d2      	uxtb	r2, r2
 800044a:	440b      	add	r3, r1
 800044c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
 8000450:	b002      	add	sp, #8
 8000452:	4770      	bx	lr
 8000454:	e000ed00 	.word	0xe000ed00
 8000458:	e000e100 	.word	0xe000e100
 800045c:	f3af 8000 	nop.w

08000460 <port_init>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
 8000460:	b508      	push	{r3, lr}

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8000462:	4b0e      	ldr	r3, [pc, #56]	; (800049c <port_init+0x3c>)
 8000464:	2200      	movs	r2, #0
 8000466:	609a      	str	r2, [r3, #8]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 8000468:	2003      	movs	r0, #3
 800046a:	f7ff ffb1 	bl	80003d0 <NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800046e:	4b0c      	ldr	r3, [pc, #48]	; (80004a0 <port_init+0x40>)
 8000470:	4a0b      	ldr	r2, [pc, #44]	; (80004a0 <port_init+0x40>)
 8000472:	68d2      	ldr	r2, [r2, #12]
 8000474:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8000478:	60da      	str	r2, [r3, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800047a:	4b0a      	ldr	r3, [pc, #40]	; (80004a4 <port_init+0x44>)
 800047c:	4a09      	ldr	r2, [pc, #36]	; (80004a4 <port_init+0x44>)
 800047e:	6812      	ldr	r2, [r2, #0]
 8000480:	f042 0201 	orr.w	r2, r2, #1
 8000484:	601a      	str	r2, [r3, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 8000486:	f06f 0004 	mvn.w	r0, #4
 800048a:	2101      	movs	r1, #1
 800048c:	f7ff ffc0 	bl	8000410 <NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 8000490:	f06f 0001 	mvn.w	r0, #1
 8000494:	2102      	movs	r1, #2
 8000496:	f7ff ffbb 	bl	8000410 <NVIC_SetPriority>
}
 800049a:	bd08      	pop	{r3, pc}
 800049c:	e000ed00 	.word	0xe000ed00
 80004a0:	e000edf0 	.word	0xe000edf0
 80004a4:	e0001000 	.word	0xe0001000
 80004a8:	f3af 8000 	nop.w
 80004ac:	f3af 8000 	nop.w

080004b0 <port_get_irq_status>:
/**
 * @brief   Returns a word encoding the current interrupts status.
 *
 * @return              The interrupts status.
 */
static inline syssts_t port_get_irq_status(void) {
 80004b0:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80004b2:	f3ef 8311 	mrs	r3, BASEPRI
 80004b6:	9300      	str	r3, [sp, #0]
  return(result);
 80004b8:	9b00      	ldr	r3, [sp, #0]
  syssts_t sts;

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  sts = (syssts_t)__get_BASEPRI();
 80004ba:	9301      	str	r3, [sp, #4]
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  sts = (syssts_t)__get_PRIMASK();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
  return sts;
 80004bc:	9b01      	ldr	r3, [sp, #4]
}
 80004be:	4618      	mov	r0, r3
 80004c0:	b002      	add	sp, #8
 80004c2:	4770      	bx	lr
 80004c4:	f3af 8000 	nop.w
 80004c8:	f3af 8000 	nop.w
 80004cc:	f3af 8000 	nop.w

080004d0 <port_irq_enabled>:
 *
 * @return              The interrupt status.
 * @retvel false        the word specified a disabled interrupts status.
 * @retvel true         the word specified an enabled interrupts status.
 */
static inline bool port_irq_enabled(syssts_t sts) {
 80004d0:	b082      	sub	sp, #8
 80004d2:	9001      	str	r0, [sp, #4]

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  return sts == (syssts_t)CORTEX_BASEPRI_DISABLED;
 80004d4:	9b01      	ldr	r3, [sp, #4]
 80004d6:	2b00      	cmp	r3, #0
 80004d8:	bf14      	ite	ne
 80004da:	2300      	movne	r3, #0
 80004dc:	2301      	moveq	r3, #1
 80004de:	b2db      	uxtb	r3, r3
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  return (sts & (syssts_t)1) == (syssts_t)0;
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80004e0:	4618      	mov	r0, r3
 80004e2:	b002      	add	sp, #8
 80004e4:	4770      	bx	lr
 80004e6:	bf00      	nop
 80004e8:	f3af 8000 	nop.w
 80004ec:	f3af 8000 	nop.w

080004f0 <port_is_isr_context>:
 *
 * @return              The execution context.
 * @retval false        not running in ISR mode.
 * @retval true         running in ISR mode.
 */
static inline bool port_is_isr_context(void) {
 80004f0:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80004f2:	f3ef 8305 	mrs	r3, IPSR
 80004f6:	9301      	str	r3, [sp, #4]
  return(result);
 80004f8:	9b01      	ldr	r3, [sp, #4]

  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
 80004fa:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80004fe:	2b00      	cmp	r3, #0
 8000500:	bf0c      	ite	eq
 8000502:	2300      	moveq	r3, #0
 8000504:	2301      	movne	r3, #1
 8000506:	b2db      	uxtb	r3, r3
}
 8000508:	4618      	mov	r0, r3
 800050a:	b002      	add	sp, #8
 800050c:	4770      	bx	lr
 800050e:	bf00      	nop

08000510 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8000510:	b082      	sub	sp, #8
 8000512:	2320      	movs	r3, #32
 8000514:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000516:	9b01      	ldr	r3, [sp, #4]
 8000518:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800051c:	b002      	add	sp, #8
 800051e:	4770      	bx	lr

08000520 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8000520:	b082      	sub	sp, #8
 8000522:	2300      	movs	r3, #0
 8000524:	9301      	str	r3, [sp, #4]
 8000526:	9b01      	ldr	r3, [sp, #4]
 8000528:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800052c:	b002      	add	sp, #8
 800052e:	4770      	bx	lr

08000530 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000530:	b508      	push	{r3, lr}

  port_lock();
 8000532:	f7ff ffed 	bl	8000510 <port_lock>
}
 8000536:	bd08      	pop	{r3, pc}
 8000538:	f3af 8000 	nop.w
 800053c:	f3af 8000 	nop.w

08000540 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000540:	b508      	push	{r3, lr}

  port_unlock();
 8000542:	f7ff ffed 	bl	8000520 <port_unlock>
}
 8000546:	bd08      	pop	{r3, pc}
 8000548:	f3af 8000 	nop.w
 800054c:	f3af 8000 	nop.w

08000550 <port_disable>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000550:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 8000552:	4770      	bx	lr
 8000554:	f3af 8000 	nop.w
 8000558:	f3af 8000 	nop.w
 800055c:	f3af 8000 	nop.w

08000560 <port_enable>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
 8000560:	b082      	sub	sp, #8
 8000562:	2300      	movs	r3, #0
 8000564:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000566:	9b01      	ldr	r3, [sp, #4]
 8000568:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800056c:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
 800056e:	b002      	add	sp, #8
 8000570:	4770      	bx	lr
 8000572:	bf00      	nop
 8000574:	f3af 8000 	nop.w
 8000578:	f3af 8000 	nop.w
 800057c:	f3af 8000 	nop.w

08000580 <port_wait_for_interrupt>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 8000580:	4770      	bx	lr
 8000582:	bf00      	nop
 8000584:	f3af 8000 	nop.w
 8000588:	f3af 8000 	nop.w
 800058c:	f3af 8000 	nop.w

08000590 <port_rt_get_counter_value>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8000590:	4b01      	ldr	r3, [pc, #4]	; (8000598 <port_rt_get_counter_value+0x8>)
 8000592:	685b      	ldr	r3, [r3, #4]
}
 8000594:	4618      	mov	r0, r3
 8000596:	4770      	bx	lr
 8000598:	e0001000 	.word	0xe0001000
 800059c:	f3af 8000 	nop.w

080005a0 <chSysEnable>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 80005a0:	b508      	push	{r3, lr}

  _dbg_check_enable();
  port_enable();
 80005a2:	f7ff ffdd 	bl	8000560 <port_enable>
}
 80005a6:	bd08      	pop	{r3, pc}
 80005a8:	f3af 8000 	nop.w
 80005ac:	f3af 8000 	nop.w

080005b0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80005b0:	b508      	push	{r3, lr}

  port_lock();
 80005b2:	f7ff ffad 	bl	8000510 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80005b6:	bd08      	pop	{r3, pc}
 80005b8:	f3af 8000 	nop.w
 80005bc:	f3af 8000 	nop.w

080005c0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80005c0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80005c2:	f7ff ffad 	bl	8000520 <port_unlock>
}
 80005c6:	bd08      	pop	{r3, pc}
 80005c8:	f3af 8000 	nop.w
 80005cc:	f3af 8000 	nop.w

080005d0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 80005d0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 80005d2:	f7ff ffad 	bl	8000530 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 80005d6:	bd08      	pop	{r3, pc}
 80005d8:	f3af 8000 	nop.w
 80005dc:	f3af 8000 	nop.w

080005e0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80005e0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 80005e2:	f7ff ffad 	bl	8000540 <port_unlock_from_isr>
}
 80005e6:	bd08      	pop	{r3, pc}
 80005e8:	f3af 8000 	nop.w
 80005ec:	f3af 8000 	nop.w

080005f0 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 80005f0:	b500      	push	{lr}
 80005f2:	b083      	sub	sp, #12

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
 80005f4:	4b18      	ldr	r3, [pc, #96]	; (8000658 <chVTDoTickI+0x68>)
 80005f6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80005f8:	1c5a      	adds	r2, r3, #1
 80005fa:	4b17      	ldr	r3, [pc, #92]	; (8000658 <chVTDoTickI+0x68>)
 80005fc:	629a      	str	r2, [r3, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80005fe:	4b16      	ldr	r3, [pc, #88]	; (8000658 <chVTDoTickI+0x68>)
 8000600:	69da      	ldr	r2, [r3, #28]
 8000602:	4b16      	ldr	r3, [pc, #88]	; (800065c <chVTDoTickI+0x6c>)
 8000604:	429a      	cmp	r2, r3
 8000606:	d024      	beq.n	8000652 <chVTDoTickI+0x62>
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
 8000608:	4b13      	ldr	r3, [pc, #76]	; (8000658 <chVTDoTickI+0x68>)
 800060a:	69db      	ldr	r3, [r3, #28]
 800060c:	689a      	ldr	r2, [r3, #8]
 800060e:	3a01      	subs	r2, #1
 8000610:	609a      	str	r2, [r3, #8]
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
 8000612:	e019      	b.n	8000648 <chVTDoTickI+0x58>
      virtual_timer_t *vtp;
      vtfunc_t fn;

      vtp = ch.vtlist.vt_next;
 8000614:	4b10      	ldr	r3, [pc, #64]	; (8000658 <chVTDoTickI+0x68>)
 8000616:	69db      	ldr	r3, [r3, #28]
 8000618:	9301      	str	r3, [sp, #4]
      fn = vtp->vt_func;
 800061a:	9b01      	ldr	r3, [sp, #4]
 800061c:	68db      	ldr	r3, [r3, #12]
 800061e:	9300      	str	r3, [sp, #0]
      vtp->vt_func = NULL;
 8000620:	9b01      	ldr	r3, [sp, #4]
 8000622:	2200      	movs	r2, #0
 8000624:	60da      	str	r2, [r3, #12]
      vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000626:	9b01      	ldr	r3, [sp, #4]
 8000628:	681b      	ldr	r3, [r3, #0]
 800062a:	4a0c      	ldr	r2, [pc, #48]	; (800065c <chVTDoTickI+0x6c>)
 800062c:	605a      	str	r2, [r3, #4]
      ch.vtlist.vt_next = vtp->vt_next;
 800062e:	9b01      	ldr	r3, [sp, #4]
 8000630:	681a      	ldr	r2, [r3, #0]
 8000632:	4b09      	ldr	r3, [pc, #36]	; (8000658 <chVTDoTickI+0x68>)
 8000634:	61da      	str	r2, [r3, #28]
      chSysUnlockFromISR();
 8000636:	f7ff ffd3 	bl	80005e0 <chSysUnlockFromISR>
      fn(vtp->vt_par);
 800063a:	9b01      	ldr	r3, [sp, #4]
 800063c:	691a      	ldr	r2, [r3, #16]
 800063e:	9b00      	ldr	r3, [sp, #0]
 8000640:	4610      	mov	r0, r2
 8000642:	4798      	blx	r3
      chSysLockFromISR();
 8000644:	f7ff ffc4 	bl	80005d0 <chSysLockFromISR>
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
 8000648:	4b03      	ldr	r3, [pc, #12]	; (8000658 <chVTDoTickI+0x68>)
 800064a:	69db      	ldr	r3, [r3, #28]
 800064c:	689b      	ldr	r3, [r3, #8]
 800064e:	2b00      	cmp	r3, #0
 8000650:	d0e0      	beq.n	8000614 <chVTDoTickI+0x24>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
              (now + delta - ch.vtlist.vt_lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000652:	b003      	add	sp, #12
 8000654:	f85d fb04 	ldr.w	pc, [sp], #4
 8000658:	20000d98 	.word	0x20000d98
 800065c:	20000db4 	.word	0x20000db4

08000660 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8000660:	b082      	sub	sp, #8
 8000662:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8000664:	4b02      	ldr	r3, [pc, #8]	; (8000670 <chRegSetThreadName+0x10>)
 8000666:	699b      	ldr	r3, [r3, #24]
 8000668:	9a01      	ldr	r2, [sp, #4]
 800066a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 800066c:	b002      	add	sp, #8
 800066e:	4770      	bx	lr
 8000670:	20000d98 	.word	0x20000d98
 8000674:	f3af 8000 	nop.w
 8000678:	f3af 8000 	nop.w
 800067c:	f3af 8000 	nop.w

08000680 <chRegSetThreadNameX>:
 * @param[in] tp        pointer to the thread
 * @param[in] name      thread name as a zero terminated string
 *
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {
 8000680:	b082      	sub	sp, #8
 8000682:	9001      	str	r0, [sp, #4]
 8000684:	9100      	str	r1, [sp, #0]

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8000686:	9b01      	ldr	r3, [sp, #4]
 8000688:	9a00      	ldr	r2, [sp, #0]
 800068a:	619a      	str	r2, [r3, #24]
#else
  (void)tp;
  (void)name;
#endif
}
 800068c:	b002      	add	sp, #8
 800068e:	4770      	bx	lr

08000690 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8000690:	b500      	push	{lr}
 8000692:	b083      	sub	sp, #12
 8000694:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 8000696:	f7ff ff73 	bl	8000580 <port_wait_for_interrupt>
    /*lint -restore*/
    CH_CFG_IDLE_LOOP_HOOK();
  }
 800069a:	e7fc      	b.n	8000696 <_idle_thread+0x6>
 800069c:	f3af 8000 	nop.w

080006a0 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 80006a0:	b500      	push	{lr}
 80006a2:	b085      	sub	sp, #20
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
 80006a4:	f7ff fedc 	bl	8000460 <port_init>
  _scheduler_init();
 80006a8:	f000 fa6a 	bl	8000b80 <_scheduler_init>
  _vt_init();
 80006ac:	f000 f958 	bl	8000960 <_vt_init>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
 80006b0:	f000 ffd6 	bl	8001660 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 80006b4:	f002 ffbc 	bl	8003630 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 80006b8:	f003 f81a 	bl	80036f0 <_heap_init>
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80006bc:	480f      	ldr	r0, [pc, #60]	; (80006fc <chSysInit+0x5c>)
 80006be:	2140      	movs	r1, #64	; 0x40
 80006c0:	f000 fd26 	bl	8001110 <_thread_init>
 80006c4:	4602      	mov	r2, r0
 80006c6:	4b0e      	ldr	r3, [pc, #56]	; (8000700 <chSysInit+0x60>)
 80006c8:	619a      	str	r2, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 80006ca:	4b0d      	ldr	r3, [pc, #52]	; (8000700 <chSysInit+0x60>)
 80006cc:	699b      	ldr	r3, [r3, #24]
 80006ce:	2201      	movs	r2, #1
 80006d0:	771a      	strb	r2, [r3, #28]
#if CH_DBG_STATISTICS == TRUE
  /* Starting measurement for this thread.*/
  chTMStartMeasurementX(&currp->p_stats);
#endif

  chSysEnable();
 80006d2:	f7ff ff65 	bl	80005a0 <chSysEnable>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Note, &ch_debug points to the string "main" if the registry is
     active.*/
  chRegSetThreadName((const char *)&ch_debug);
 80006d6:	480b      	ldr	r0, [pc, #44]	; (8000704 <chSysInit+0x64>)
 80006d8:	f7ff ffc2 	bl	8000660 <chRegSetThreadName>
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 80006dc:	2300      	movs	r3, #0
 80006de:	9300      	str	r3, [sp, #0]
 80006e0:	4809      	ldr	r0, [pc, #36]	; (8000708 <chSysInit+0x68>)
 80006e2:	21d8      	movs	r1, #216	; 0xd8
 80006e4:	2201      	movs	r2, #1
 80006e6:	4b09      	ldr	r3, [pc, #36]	; (800070c <chSysInit+0x6c>)
 80006e8:	f000 fd7a 	bl	80011e0 <chThdCreateStatic>
 80006ec:	9003      	str	r0, [sp, #12]
                                      sizeof(ch.idle_thread_wa),
                                      IDLEPRIO,
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
 80006ee:	9803      	ldr	r0, [sp, #12]
 80006f0:	4907      	ldr	r1, [pc, #28]	; (8000710 <chSysInit+0x70>)
 80006f2:	f7ff ffc5 	bl	8000680 <chRegSetThreadNameX>
  }
#endif
}
 80006f6:	b005      	add	sp, #20
 80006f8:	f85d fb04 	ldr.w	pc, [sp], #4
 80006fc:	20000dc8 	.word	0x20000dc8
 8000700:	20000d98 	.word	0x20000d98
 8000704:	08015f20 	.word	0x08015f20
 8000708:	20000e10 	.word	0x20000e10
 800070c:	08000691 	.word	0x08000691
 8000710:	08015f10 	.word	0x08015f10
 8000714:	f3af 8000 	nop.w
 8000718:	f3af 8000 	nop.w
 800071c:	f3af 8000 	nop.w

08000720 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8000720:	b500      	push	{lr}
 8000722:	b083      	sub	sp, #12
 8000724:	9001      	str	r0, [sp, #4]

  port_disable();
 8000726:	f7ff ff13 	bl	8000550 <port_disable>
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 800072a:	4b02      	ldr	r3, [pc, #8]	; (8000734 <chSysHalt+0x14>)
 800072c:	9a01      	ldr	r2, [sp, #4]
 800072e:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Harmless infinite loop.*/
  while (true) {
  }
 8000730:	e7fe      	b.n	8000730 <chSysHalt+0x10>
 8000732:	bf00      	nop
 8000734:	20000d98 	.word	0x20000d98
 8000738:	f3af 8000 	nop.w
 800073c:	f3af 8000 	nop.w

08000740 <chSysIntegrityCheckI>:
 * @retval false        The test succeeded.
 * @retval true         Test failed.
 *
 * @iclass
 */
bool chSysIntegrityCheckI(unsigned testmask) {
 8000740:	b086      	sub	sp, #24
 8000742:	9001      	str	r0, [sp, #4]
  cnt_t n;

  chDbgCheckClassI();

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 8000744:	9b01      	ldr	r3, [sp, #4]
 8000746:	f003 0301 	and.w	r3, r3, #1
 800074a:	2b00      	cmp	r3, #0
 800074c:	d022      	beq.n	8000794 <chSysIntegrityCheckI+0x54>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 800074e:	2300      	movs	r3, #0
 8000750:	9305      	str	r3, [sp, #20]
    tp = ch.rlist.r_queue.p_next;
 8000752:	4b3a      	ldr	r3, [pc, #232]	; (800083c <chSysIntegrityCheckI+0xfc>)
 8000754:	681b      	ldr	r3, [r3, #0]
 8000756:	9304      	str	r3, [sp, #16]
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 8000758:	e005      	b.n	8000766 <chSysIntegrityCheckI+0x26>
      n++;
 800075a:	9b05      	ldr	r3, [sp, #20]
 800075c:	3301      	adds	r3, #1
 800075e:	9305      	str	r3, [sp, #20]
      tp = tp->p_next;
 8000760:	9b04      	ldr	r3, [sp, #16]
 8000762:	681b      	ldr	r3, [r3, #0]
 8000764:	9304      	str	r3, [sp, #16]
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_queue.p_next;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 8000766:	9a04      	ldr	r2, [sp, #16]
 8000768:	4b34      	ldr	r3, [pc, #208]	; (800083c <chSysIntegrityCheckI+0xfc>)
 800076a:	429a      	cmp	r2, r3
 800076c:	d1f5      	bne.n	800075a <chSysIntegrityCheckI+0x1a>
      n++;
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
 800076e:	4b33      	ldr	r3, [pc, #204]	; (800083c <chSysIntegrityCheckI+0xfc>)
 8000770:	685b      	ldr	r3, [r3, #4]
 8000772:	9304      	str	r3, [sp, #16]
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 8000774:	e005      	b.n	8000782 <chSysIntegrityCheckI+0x42>
      n--;
 8000776:	9b05      	ldr	r3, [sp, #20]
 8000778:	3b01      	subs	r3, #1
 800077a:	9305      	str	r3, [sp, #20]
      tp = tp->p_prev;
 800077c:	9b04      	ldr	r3, [sp, #16]
 800077e:	685b      	ldr	r3, [r3, #4]
 8000780:	9304      	str	r3, [sp, #16]
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 8000782:	9a04      	ldr	r2, [sp, #16]
 8000784:	4b2d      	ldr	r3, [pc, #180]	; (800083c <chSysIntegrityCheckI+0xfc>)
 8000786:	429a      	cmp	r2, r3
 8000788:	d1f5      	bne.n	8000776 <chSysIntegrityCheckI+0x36>
      n--;
      tp = tp->p_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800078a:	9b05      	ldr	r3, [sp, #20]
 800078c:	2b00      	cmp	r3, #0
 800078e:	d001      	beq.n	8000794 <chSysIntegrityCheckI+0x54>
      return true;
 8000790:	2301      	movs	r3, #1
 8000792:	e050      	b.n	8000836 <chSysIntegrityCheckI+0xf6>
    }
  }

  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
 8000794:	9b01      	ldr	r3, [sp, #4]
 8000796:	f003 0302 	and.w	r3, r3, #2
 800079a:	2b00      	cmp	r3, #0
 800079c:	d022      	beq.n	80007e4 <chSysIntegrityCheckI+0xa4>
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
 800079e:	2300      	movs	r3, #0
 80007a0:	9305      	str	r3, [sp, #20]
    vtp = ch.vtlist.vt_next;
 80007a2:	4b26      	ldr	r3, [pc, #152]	; (800083c <chSysIntegrityCheckI+0xfc>)
 80007a4:	69db      	ldr	r3, [r3, #28]
 80007a6:	9303      	str	r3, [sp, #12]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80007a8:	e005      	b.n	80007b6 <chSysIntegrityCheckI+0x76>
      n++;
 80007aa:	9b05      	ldr	r3, [sp, #20]
 80007ac:	3301      	adds	r3, #1
 80007ae:	9305      	str	r3, [sp, #20]
      vtp = vtp->vt_next;
 80007b0:	9b03      	ldr	r3, [sp, #12]
 80007b2:	681b      	ldr	r3, [r3, #0]
 80007b4:	9303      	str	r3, [sp, #12]
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80007b6:	9a03      	ldr	r2, [sp, #12]
 80007b8:	4b21      	ldr	r3, [pc, #132]	; (8000840 <chSysIntegrityCheckI+0x100>)
 80007ba:	429a      	cmp	r2, r3
 80007bc:	d1f5      	bne.n	80007aa <chSysIntegrityCheckI+0x6a>
      n++;
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
 80007be:	4b1f      	ldr	r3, [pc, #124]	; (800083c <chSysIntegrityCheckI+0xfc>)
 80007c0:	6a1b      	ldr	r3, [r3, #32]
 80007c2:	9303      	str	r3, [sp, #12]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80007c4:	e005      	b.n	80007d2 <chSysIntegrityCheckI+0x92>
      n--;
 80007c6:	9b05      	ldr	r3, [sp, #20]
 80007c8:	3b01      	subs	r3, #1
 80007ca:	9305      	str	r3, [sp, #20]
      vtp = vtp->vt_prev;
 80007cc:	9b03      	ldr	r3, [sp, #12]
 80007ce:	685b      	ldr	r3, [r3, #4]
 80007d0:	9303      	str	r3, [sp, #12]
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80007d2:	9a03      	ldr	r2, [sp, #12]
 80007d4:	4b1a      	ldr	r3, [pc, #104]	; (8000840 <chSysIntegrityCheckI+0x100>)
 80007d6:	429a      	cmp	r2, r3
 80007d8:	d1f5      	bne.n	80007c6 <chSysIntegrityCheckI+0x86>
      n--;
      vtp = vtp->vt_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 80007da:	9b05      	ldr	r3, [sp, #20]
 80007dc:	2b00      	cmp	r3, #0
 80007de:	d001      	beq.n	80007e4 <chSysIntegrityCheckI+0xa4>
      return true;
 80007e0:	2301      	movs	r3, #1
 80007e2:	e028      	b.n	8000836 <chSysIntegrityCheckI+0xf6>
    }
  }

#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
 80007e4:	9b01      	ldr	r3, [sp, #4]
 80007e6:	f003 0304 	and.w	r3, r3, #4
 80007ea:	2b00      	cmp	r3, #0
 80007ec:	d022      	beq.n	8000834 <chSysIntegrityCheckI+0xf4>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 80007ee:	2300      	movs	r3, #0
 80007f0:	9305      	str	r3, [sp, #20]
    tp = ch.rlist.r_newer;
 80007f2:	4b12      	ldr	r3, [pc, #72]	; (800083c <chSysIntegrityCheckI+0xfc>)
 80007f4:	691b      	ldr	r3, [r3, #16]
 80007f6:	9302      	str	r3, [sp, #8]
    while (tp != (thread_t *)&ch.rlist) {
 80007f8:	e005      	b.n	8000806 <chSysIntegrityCheckI+0xc6>
      n++;
 80007fa:	9b05      	ldr	r3, [sp, #20]
 80007fc:	3301      	adds	r3, #1
 80007fe:	9305      	str	r3, [sp, #20]
      tp = tp->p_newer;
 8000800:	9b02      	ldr	r3, [sp, #8]
 8000802:	691b      	ldr	r3, [r3, #16]
 8000804:	9302      	str	r3, [sp, #8]
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_newer;
    while (tp != (thread_t *)&ch.rlist) {
 8000806:	9a02      	ldr	r2, [sp, #8]
 8000808:	4b0c      	ldr	r3, [pc, #48]	; (800083c <chSysIntegrityCheckI+0xfc>)
 800080a:	429a      	cmp	r2, r3
 800080c:	d1f5      	bne.n	80007fa <chSysIntegrityCheckI+0xba>
      n++;
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
 800080e:	4b0b      	ldr	r3, [pc, #44]	; (800083c <chSysIntegrityCheckI+0xfc>)
 8000810:	695b      	ldr	r3, [r3, #20]
 8000812:	9302      	str	r3, [sp, #8]
    while (tp != (thread_t *)&ch.rlist) {
 8000814:	e005      	b.n	8000822 <chSysIntegrityCheckI+0xe2>
      n--;
 8000816:	9b05      	ldr	r3, [sp, #20]
 8000818:	3b01      	subs	r3, #1
 800081a:	9305      	str	r3, [sp, #20]
      tp = tp->p_older;
 800081c:	9b02      	ldr	r3, [sp, #8]
 800081e:	695b      	ldr	r3, [r3, #20]
 8000820:	9302      	str	r3, [sp, #8]
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
    while (tp != (thread_t *)&ch.rlist) {
 8000822:	9a02      	ldr	r2, [sp, #8]
 8000824:	4b05      	ldr	r3, [pc, #20]	; (800083c <chSysIntegrityCheckI+0xfc>)
 8000826:	429a      	cmp	r2, r3
 8000828:	d1f5      	bne.n	8000816 <chSysIntegrityCheckI+0xd6>
      n--;
      tp = tp->p_older;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800082a:	9b05      	ldr	r3, [sp, #20]
 800082c:	2b00      	cmp	r3, #0
 800082e:	d001      	beq.n	8000834 <chSysIntegrityCheckI+0xf4>
      return true;
 8000830:	2301      	movs	r3, #1
 8000832:	e000      	b.n	8000836 <chSysIntegrityCheckI+0xf6>
  if ((testmask & CH_INTEGRITY_PORT) != 0U) {
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
 8000834:	2300      	movs	r3, #0
}
 8000836:	4618      	mov	r0, r3
 8000838:	b006      	add	sp, #24
 800083a:	4770      	bx	lr
 800083c:	20000d98 	.word	0x20000d98
 8000840:	20000db4 	.word	0x20000db4
 8000844:	f3af 8000 	nop.w
 8000848:	f3af 8000 	nop.w
 800084c:	f3af 8000 	nop.w

08000850 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8000850:	b508      	push	{r3, lr}

  chDbgCheckClassI();

#if CH_CFG_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->p_preempt > (tslices_t)0) {
 8000852:	4b07      	ldr	r3, [pc, #28]	; (8000870 <chSysTimerHandlerI+0x20>)
 8000854:	699b      	ldr	r3, [r3, #24]
 8000856:	7fdb      	ldrb	r3, [r3, #31]
 8000858:	2b00      	cmp	r3, #0
 800085a:	d005      	beq.n	8000868 <chSysTimerHandlerI+0x18>
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
 800085c:	4b04      	ldr	r3, [pc, #16]	; (8000870 <chSysTimerHandlerI+0x20>)
 800085e:	699b      	ldr	r3, [r3, #24]
 8000860:	7fda      	ldrb	r2, [r3, #31]
 8000862:	3a01      	subs	r2, #1
 8000864:	b2d2      	uxtb	r2, r2
 8000866:	77da      	strb	r2, [r3, #31]
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->p_time++;
#endif
  chVTDoTickI();
 8000868:	f7ff fec2 	bl	80005f0 <chVTDoTickI>
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
 800086c:	bd08      	pop	{r3, pc}
 800086e:	bf00      	nop
 8000870:	20000d98 	.word	0x20000d98
 8000874:	f3af 8000 	nop.w
 8000878:	f3af 8000 	nop.w
 800087c:	f3af 8000 	nop.w

08000880 <chSysGetStatusAndLockX>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {
 8000880:	b500      	push	{lr}
 8000882:	b083      	sub	sp, #12

  syssts_t sts = port_get_irq_status();
 8000884:	f7ff fe14 	bl	80004b0 <port_get_irq_status>
 8000888:	9001      	str	r0, [sp, #4]
  if (port_irq_enabled(sts)) {
 800088a:	9801      	ldr	r0, [sp, #4]
 800088c:	f7ff fe20 	bl	80004d0 <port_irq_enabled>
 8000890:	4603      	mov	r3, r0
 8000892:	2b00      	cmp	r3, #0
 8000894:	d009      	beq.n	80008aa <chSysGetStatusAndLockX+0x2a>
    if (port_is_isr_context()) {
 8000896:	f7ff fe2b 	bl	80004f0 <port_is_isr_context>
 800089a:	4603      	mov	r3, r0
 800089c:	2b00      	cmp	r3, #0
 800089e:	d002      	beq.n	80008a6 <chSysGetStatusAndLockX+0x26>
      chSysLockFromISR();
 80008a0:	f7ff fe96 	bl	80005d0 <chSysLockFromISR>
 80008a4:	e001      	b.n	80008aa <chSysGetStatusAndLockX+0x2a>
    }
    else {
      chSysLock();
 80008a6:	f7ff fe83 	bl	80005b0 <chSysLock>
    }
  }
  return sts;
 80008aa:	9b01      	ldr	r3, [sp, #4]
}
 80008ac:	4618      	mov	r0, r3
 80008ae:	b003      	add	sp, #12
 80008b0:	f85d fb04 	ldr.w	pc, [sp], #4
 80008b4:	f3af 8000 	nop.w
 80008b8:	f3af 8000 	nop.w
 80008bc:	f3af 8000 	nop.w

080008c0 <chSysRestoreStatusX>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
 80008c0:	b500      	push	{lr}
 80008c2:	b083      	sub	sp, #12
 80008c4:	9001      	str	r0, [sp, #4]

  if (port_irq_enabled(sts)) {
 80008c6:	9801      	ldr	r0, [sp, #4]
 80008c8:	f7ff fe02 	bl	80004d0 <port_irq_enabled>
 80008cc:	4603      	mov	r3, r0
 80008ce:	2b00      	cmp	r3, #0
 80008d0:	d00b      	beq.n	80008ea <chSysRestoreStatusX+0x2a>
    if (port_is_isr_context()) {
 80008d2:	f7ff fe0d 	bl	80004f0 <port_is_isr_context>
 80008d6:	4603      	mov	r3, r0
 80008d8:	2b00      	cmp	r3, #0
 80008da:	d002      	beq.n	80008e2 <chSysRestoreStatusX+0x22>
      chSysUnlockFromISR();
 80008dc:	f7ff fe80 	bl	80005e0 <chSysUnlockFromISR>
 80008e0:	e003      	b.n	80008ea <chSysRestoreStatusX+0x2a>
    }
    else {
      chSchRescheduleS();
 80008e2:	f000 fa4d 	bl	8000d80 <chSchRescheduleS>
      chSysUnlock();
 80008e6:	f7ff fe6b 	bl	80005c0 <chSysUnlock>
    }
  }
}
 80008ea:	b003      	add	sp, #12
 80008ec:	f85d fb04 	ldr.w	pc, [sp], #4

080008f0 <chSysIsCounterWithinX>:
 * @retval true         current time within the specified time window.
 * @retval false        current time not within the specified time window.
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {
 80008f0:	b084      	sub	sp, #16
 80008f2:	9003      	str	r0, [sp, #12]
 80008f4:	9102      	str	r1, [sp, #8]
 80008f6:	9201      	str	r2, [sp, #4]

  return (bool)((cnt - start) < (end - start));
 80008f8:	9a03      	ldr	r2, [sp, #12]
 80008fa:	9b02      	ldr	r3, [sp, #8]
 80008fc:	1ad2      	subs	r2, r2, r3
 80008fe:	9901      	ldr	r1, [sp, #4]
 8000900:	9b02      	ldr	r3, [sp, #8]
 8000902:	1acb      	subs	r3, r1, r3
 8000904:	429a      	cmp	r2, r3
 8000906:	bf2c      	ite	cs
 8000908:	2300      	movcs	r3, #0
 800090a:	2301      	movcc	r3, #1
 800090c:	b2db      	uxtb	r3, r3
}
 800090e:	4618      	mov	r0, r3
 8000910:	b004      	add	sp, #16
 8000912:	4770      	bx	lr
 8000914:	f3af 8000 	nop.w
 8000918:	f3af 8000 	nop.w
 800091c:	f3af 8000 	nop.w

08000920 <chSysPolledDelayX>:
 *
 * @param[in] cycles    number of cycles
 *
 * @xclass
 */
void chSysPolledDelayX(rtcnt_t cycles) {
 8000920:	b500      	push	{lr}
 8000922:	b085      	sub	sp, #20
 8000924:	9001      	str	r0, [sp, #4]
  rtcnt_t start = chSysGetRealtimeCounterX();
 8000926:	f7ff fe33 	bl	8000590 <port_rt_get_counter_value>
 800092a:	9003      	str	r0, [sp, #12]
  rtcnt_t end  = start + cycles;
 800092c:	9a03      	ldr	r2, [sp, #12]
 800092e:	9b01      	ldr	r3, [sp, #4]
 8000930:	4413      	add	r3, r2
 8000932:	9302      	str	r3, [sp, #8]

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8000934:	bf00      	nop
 8000936:	f7ff fe2b 	bl	8000590 <port_rt_get_counter_value>
 800093a:	4603      	mov	r3, r0
 800093c:	4618      	mov	r0, r3
 800093e:	9903      	ldr	r1, [sp, #12]
 8000940:	9a02      	ldr	r2, [sp, #8]
 8000942:	f7ff ffd5 	bl	80008f0 <chSysIsCounterWithinX>
 8000946:	4603      	mov	r3, r0
 8000948:	2b00      	cmp	r3, #0
 800094a:	d1f4      	bne.n	8000936 <chSysPolledDelayX+0x16>
  }
}
 800094c:	b005      	add	sp, #20
 800094e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000952:	bf00      	nop
 8000954:	f3af 8000 	nop.w
 8000958:	f3af 8000 	nop.w
 800095c:	f3af 8000 	nop.w

08000960 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8000960:	4b06      	ldr	r3, [pc, #24]	; (800097c <_vt_init+0x1c>)
 8000962:	4a07      	ldr	r2, [pc, #28]	; (8000980 <_vt_init+0x20>)
 8000964:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000966:	4b05      	ldr	r3, [pc, #20]	; (800097c <_vt_init+0x1c>)
 8000968:	4a05      	ldr	r2, [pc, #20]	; (8000980 <_vt_init+0x20>)
 800096a:	621a      	str	r2, [r3, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
 800096c:	4b03      	ldr	r3, [pc, #12]	; (800097c <_vt_init+0x1c>)
 800096e:	f04f 32ff 	mov.w	r2, #4294967295
 8000972:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
 8000974:	4b01      	ldr	r3, [pc, #4]	; (800097c <_vt_init+0x1c>)
 8000976:	2200      	movs	r2, #0
 8000978:	629a      	str	r2, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800097a:	4770      	bx	lr
 800097c:	20000d98 	.word	0x20000d98
 8000980:	20000db4 	.word	0x20000db4
 8000984:	f3af 8000 	nop.w
 8000988:	f3af 8000 	nop.w
 800098c:	f3af 8000 	nop.w

08000990 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8000990:	b086      	sub	sp, #24
 8000992:	9003      	str	r0, [sp, #12]
 8000994:	9102      	str	r1, [sp, #8]
 8000996:	9201      	str	r2, [sp, #4]
 8000998:	9300      	str	r3, [sp, #0]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 800099a:	9b03      	ldr	r3, [sp, #12]
 800099c:	9a00      	ldr	r2, [sp, #0]
 800099e:	611a      	str	r2, [r3, #16]
  vtp->vt_func = vtfunc;
 80009a0:	9b03      	ldr	r3, [sp, #12]
 80009a2:	9a01      	ldr	r2, [sp, #4]
 80009a4:	60da      	str	r2, [r3, #12]
      port_timer_set_alarm(ch.vtlist.vt_lasttime + delta);
    }
  }
#else /* CH_CFG_ST_TIMEDELTA == 0 */
  /* Delta is initially equal to the specified delay.*/
  delta = delay;
 80009a6:	9b02      	ldr	r3, [sp, #8]
 80009a8:	9304      	str	r3, [sp, #16]

  /* Pointer to the first element in the delta list.*/
  p = ch.vtlist.vt_next;
 80009aa:	4b17      	ldr	r3, [pc, #92]	; (8000a08 <chVTDoSetI+0x78>)
 80009ac:	69db      	ldr	r3, [r3, #28]
 80009ae:	9305      	str	r3, [sp, #20]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delta) {
 80009b0:	e007      	b.n	80009c2 <chVTDoSetI+0x32>
    delta -= p->vt_delta;
 80009b2:	9b05      	ldr	r3, [sp, #20]
 80009b4:	689b      	ldr	r3, [r3, #8]
 80009b6:	9a04      	ldr	r2, [sp, #16]
 80009b8:	1ad3      	subs	r3, r2, r3
 80009ba:	9304      	str	r3, [sp, #16]
    p = p->vt_next;
 80009bc:	9b05      	ldr	r3, [sp, #20]
 80009be:	681b      	ldr	r3, [r3, #0]
 80009c0:	9305      	str	r3, [sp, #20]
  p = ch.vtlist.vt_next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delta) {
 80009c2:	9b05      	ldr	r3, [sp, #20]
 80009c4:	689a      	ldr	r2, [r3, #8]
 80009c6:	9b04      	ldr	r3, [sp, #16]
 80009c8:	429a      	cmp	r2, r3
 80009ca:	d3f2      	bcc.n	80009b2 <chVTDoSetI+0x22>
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 80009cc:	9b03      	ldr	r3, [sp, #12]
 80009ce:	9a05      	ldr	r2, [sp, #20]
 80009d0:	601a      	str	r2, [r3, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
 80009d2:	9b03      	ldr	r3, [sp, #12]
 80009d4:	681b      	ldr	r3, [r3, #0]
 80009d6:	685a      	ldr	r2, [r3, #4]
 80009d8:	9b03      	ldr	r3, [sp, #12]
 80009da:	605a      	str	r2, [r3, #4]
  vtp->vt_prev->vt_next = vtp;
 80009dc:	9b03      	ldr	r3, [sp, #12]
 80009de:	685b      	ldr	r3, [r3, #4]
 80009e0:	9a03      	ldr	r2, [sp, #12]
 80009e2:	601a      	str	r2, [r3, #0]
  p->vt_prev = vtp;
 80009e4:	9b05      	ldr	r3, [sp, #20]
 80009e6:	9a03      	ldr	r2, [sp, #12]
 80009e8:	605a      	str	r2, [r3, #4]
  vtp->vt_delta = delta
 80009ea:	9b03      	ldr	r3, [sp, #12]
 80009ec:	9a04      	ldr	r2, [sp, #16]
 80009ee:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 80009f0:	9b05      	ldr	r3, [sp, #20]
 80009f2:	689a      	ldr	r2, [r3, #8]
 80009f4:	9b04      	ldr	r3, [sp, #16]
 80009f6:	1ad2      	subs	r2, r2, r3
 80009f8:	9b05      	ldr	r3, [sp, #20]
 80009fa:	609a      	str	r2, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 80009fc:	4b02      	ldr	r3, [pc, #8]	; (8000a08 <chVTDoSetI+0x78>)
 80009fe:	f04f 32ff 	mov.w	r2, #4294967295
 8000a02:	625a      	str	r2, [r3, #36]	; 0x24
}
 8000a04:	b006      	add	sp, #24
 8000a06:	4770      	bx	lr
 8000a08:	20000d98 	.word	0x20000d98
 8000a0c:	f3af 8000 	nop.w

08000a10 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8000a10:	b082      	sub	sp, #8
 8000a12:	9001      	str	r0, [sp, #4]
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 8000a14:	9b01      	ldr	r3, [sp, #4]
 8000a16:	681b      	ldr	r3, [r3, #0]
 8000a18:	9a01      	ldr	r2, [sp, #4]
 8000a1a:	6812      	ldr	r2, [r2, #0]
 8000a1c:	6891      	ldr	r1, [r2, #8]
 8000a1e:	9a01      	ldr	r2, [sp, #4]
 8000a20:	6892      	ldr	r2, [r2, #8]
 8000a22:	440a      	add	r2, r1
 8000a24:	609a      	str	r2, [r3, #8]

 /* Removing the element from the delta list.*/
  vtp->vt_prev->vt_next = vtp->vt_next;
 8000a26:	9b01      	ldr	r3, [sp, #4]
 8000a28:	685b      	ldr	r3, [r3, #4]
 8000a2a:	9a01      	ldr	r2, [sp, #4]
 8000a2c:	6812      	ldr	r2, [r2, #0]
 8000a2e:	601a      	str	r2, [r3, #0]
  vtp->vt_next->vt_prev = vtp->vt_prev;
 8000a30:	9b01      	ldr	r3, [sp, #4]
 8000a32:	681b      	ldr	r3, [r3, #0]
 8000a34:	9a01      	ldr	r2, [sp, #4]
 8000a36:	6852      	ldr	r2, [r2, #4]
 8000a38:	605a      	str	r2, [r3, #4]
  vtp->vt_func = NULL;
 8000a3a:	9b01      	ldr	r3, [sp, #4]
 8000a3c:	2200      	movs	r2, #0
 8000a3e:	60da      	str	r2, [r3, #12]

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 8000a40:	4b02      	ldr	r3, [pc, #8]	; (8000a4c <chVTDoResetI+0x3c>)
 8000a42:	f04f 32ff 	mov.w	r2, #4294967295
 8000a46:	625a      	str	r2, [r3, #36]	; 0x24
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000a48:	b002      	add	sp, #8
 8000a4a:	4770      	bx	lr
 8000a4c:	20000d98 	.word	0x20000d98

08000a50 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8000a50:	b082      	sub	sp, #8
 8000a52:	2320      	movs	r3, #32
 8000a54:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000a56:	9b01      	ldr	r3, [sp, #4]
 8000a58:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000a5c:	b002      	add	sp, #8
 8000a5e:	4770      	bx	lr

08000a60 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8000a60:	b082      	sub	sp, #8
 8000a62:	2300      	movs	r3, #0
 8000a64:	9301      	str	r3, [sp, #4]
 8000a66:	9b01      	ldr	r3, [sp, #4]
 8000a68:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000a6c:	b002      	add	sp, #8
 8000a6e:	4770      	bx	lr

08000a70 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000a70:	b508      	push	{r3, lr}

  port_lock();
 8000a72:	f7ff ffed 	bl	8000a50 <port_lock>
}
 8000a76:	bd08      	pop	{r3, pc}
 8000a78:	f3af 8000 	nop.w
 8000a7c:	f3af 8000 	nop.w

08000a80 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000a80:	b508      	push	{r3, lr}

  port_unlock();
 8000a82:	f7ff ffed 	bl	8000a60 <port_unlock>
}
 8000a86:	bd08      	pop	{r3, pc}
 8000a88:	f3af 8000 	nop.w
 8000a8c:	f3af 8000 	nop.w

08000a90 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8000a90:	b082      	sub	sp, #8
 8000a92:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8000a94:	9b01      	ldr	r3, [sp, #4]
 8000a96:	9a01      	ldr	r2, [sp, #4]
 8000a98:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8000a9a:	9b01      	ldr	r3, [sp, #4]
 8000a9c:	9a01      	ldr	r2, [sp, #4]
 8000a9e:	605a      	str	r2, [r3, #4]
}
 8000aa0:	b002      	add	sp, #8
 8000aa2:	4770      	bx	lr
 8000aa4:	f3af 8000 	nop.w
 8000aa8:	f3af 8000 	nop.w
 8000aac:	f3af 8000 	nop.w

08000ab0 <queue_fifo_remove>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8000ab0:	b084      	sub	sp, #16
 8000ab2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8000ab4:	9b01      	ldr	r3, [sp, #4]
 8000ab6:	681b      	ldr	r3, [r3, #0]
 8000ab8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8000aba:	9b03      	ldr	r3, [sp, #12]
 8000abc:	681a      	ldr	r2, [r3, #0]
 8000abe:	9b01      	ldr	r3, [sp, #4]
 8000ac0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000ac2:	9b01      	ldr	r3, [sp, #4]
 8000ac4:	681b      	ldr	r3, [r3, #0]
 8000ac6:	9a01      	ldr	r2, [sp, #4]
 8000ac8:	605a      	str	r2, [r3, #4]

  return tp;
 8000aca:	9b03      	ldr	r3, [sp, #12]
}
 8000acc:	4618      	mov	r0, r3
 8000ace:	b004      	add	sp, #16
 8000ad0:	4770      	bx	lr
 8000ad2:	bf00      	nop
 8000ad4:	f3af 8000 	nop.w
 8000ad8:	f3af 8000 	nop.w
 8000adc:	f3af 8000 	nop.w

08000ae0 <queue_dequeue>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 8000ae0:	b082      	sub	sp, #8
 8000ae2:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
 8000ae4:	9b01      	ldr	r3, [sp, #4]
 8000ae6:	685b      	ldr	r3, [r3, #4]
 8000ae8:	9a01      	ldr	r2, [sp, #4]
 8000aea:	6812      	ldr	r2, [r2, #0]
 8000aec:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8000aee:	9b01      	ldr	r3, [sp, #4]
 8000af0:	681b      	ldr	r3, [r3, #0]
 8000af2:	9a01      	ldr	r2, [sp, #4]
 8000af4:	6852      	ldr	r2, [r2, #4]
 8000af6:	605a      	str	r2, [r3, #4]

  return tp;
 8000af8:	9b01      	ldr	r3, [sp, #4]
}
 8000afa:	4618      	mov	r0, r3
 8000afc:	b002      	add	sp, #8
 8000afe:	4770      	bx	lr

08000b00 <chSchIsRescRequiredI>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 8000b00:	4b06      	ldr	r3, [pc, #24]	; (8000b1c <chSchIsRescRequiredI+0x1c>)
 8000b02:	681b      	ldr	r3, [r3, #0]
 8000b04:	689a      	ldr	r2, [r3, #8]
 8000b06:	4b05      	ldr	r3, [pc, #20]	; (8000b1c <chSchIsRescRequiredI+0x1c>)
 8000b08:	699b      	ldr	r3, [r3, #24]
 8000b0a:	689b      	ldr	r3, [r3, #8]
 8000b0c:	429a      	cmp	r2, r3
 8000b0e:	bf94      	ite	ls
 8000b10:	2300      	movls	r3, #0
 8000b12:	2301      	movhi	r3, #1
 8000b14:	b2db      	uxtb	r3, r3
}
 8000b16:	4618      	mov	r0, r3
 8000b18:	4770      	bx	lr
 8000b1a:	bf00      	nop
 8000b1c:	20000d98 	.word	0x20000d98

08000b20 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8000b20:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8000b22:	f7ff ffa5 	bl	8000a70 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8000b26:	bd08      	pop	{r3, pc}
 8000b28:	f3af 8000 	nop.w
 8000b2c:	f3af 8000 	nop.w

08000b30 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8000b30:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8000b32:	f7ff ffa5 	bl	8000a80 <port_unlock_from_isr>
}
 8000b36:	bd08      	pop	{r3, pc}
 8000b38:	f3af 8000 	nop.w
 8000b3c:	f3af 8000 	nop.w

08000b40 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 8000b40:	b082      	sub	sp, #8
 8000b42:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->vt_func != NULL);
 8000b44:	9b01      	ldr	r3, [sp, #4]
 8000b46:	68db      	ldr	r3, [r3, #12]
 8000b48:	2b00      	cmp	r3, #0
 8000b4a:	bf0c      	ite	eq
 8000b4c:	2300      	moveq	r3, #0
 8000b4e:	2301      	movne	r3, #1
 8000b50:	b2db      	uxtb	r3, r3
}
 8000b52:	4618      	mov	r0, r3
 8000b54:	b002      	add	sp, #8
 8000b56:	4770      	bx	lr
 8000b58:	f3af 8000 	nop.w
 8000b5c:	f3af 8000 	nop.w

08000b60 <chSemFastSignalI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8000b60:	b082      	sub	sp, #8
 8000b62:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  sp->s_cnt++;
 8000b64:	9b01      	ldr	r3, [sp, #4]
 8000b66:	689b      	ldr	r3, [r3, #8]
 8000b68:	1c5a      	adds	r2, r3, #1
 8000b6a:	9b01      	ldr	r3, [sp, #4]
 8000b6c:	609a      	str	r2, [r3, #8]
}
 8000b6e:	b002      	add	sp, #8
 8000b70:	4770      	bx	lr
 8000b72:	bf00      	nop
 8000b74:	f3af 8000 	nop.w
 8000b78:	f3af 8000 	nop.w
 8000b7c:	f3af 8000 	nop.w

08000b80 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 8000b80:	b508      	push	{r3, lr}

  queue_init(&ch.rlist.r_queue);
 8000b82:	4806      	ldr	r0, [pc, #24]	; (8000b9c <_scheduler_init+0x1c>)
 8000b84:	f7ff ff84 	bl	8000a90 <queue_init>
  ch.rlist.r_prio = NOPRIO;
 8000b88:	4b04      	ldr	r3, [pc, #16]	; (8000b9c <_scheduler_init+0x1c>)
 8000b8a:	2200      	movs	r2, #0
 8000b8c:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 8000b8e:	4b03      	ldr	r3, [pc, #12]	; (8000b9c <_scheduler_init+0x1c>)
 8000b90:	4a02      	ldr	r2, [pc, #8]	; (8000b9c <_scheduler_init+0x1c>)
 8000b92:	611a      	str	r2, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 8000b94:	4b01      	ldr	r3, [pc, #4]	; (8000b9c <_scheduler_init+0x1c>)
 8000b96:	4a01      	ldr	r2, [pc, #4]	; (8000b9c <_scheduler_init+0x1c>)
 8000b98:	615a      	str	r2, [r3, #20]
#endif
}
 8000b9a:	bd08      	pop	{r3, pc}
 8000b9c:	20000d98 	.word	0x20000d98

08000ba0 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8000ba0:	b084      	sub	sp, #16
 8000ba2:	9001      	str	r0, [sp, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000ba4:	9b01      	ldr	r3, [sp, #4]
 8000ba6:	2200      	movs	r2, #0
 8000ba8:	771a      	strb	r2, [r3, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8000baa:	4b0e      	ldr	r3, [pc, #56]	; (8000be4 <chSchReadyI+0x44>)
 8000bac:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 8000bae:	9b03      	ldr	r3, [sp, #12]
 8000bb0:	681b      	ldr	r3, [r3, #0]
 8000bb2:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio >= tp->p_prio);
 8000bb4:	9b03      	ldr	r3, [sp, #12]
 8000bb6:	689a      	ldr	r2, [r3, #8]
 8000bb8:	9b01      	ldr	r3, [sp, #4]
 8000bba:	689b      	ldr	r3, [r3, #8]
 8000bbc:	429a      	cmp	r2, r3
 8000bbe:	d2f6      	bcs.n	8000bae <chSchReadyI+0xe>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000bc0:	9b01      	ldr	r3, [sp, #4]
 8000bc2:	9a03      	ldr	r2, [sp, #12]
 8000bc4:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 8000bc6:	9b03      	ldr	r3, [sp, #12]
 8000bc8:	685a      	ldr	r2, [r3, #4]
 8000bca:	9b01      	ldr	r3, [sp, #4]
 8000bcc:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8000bce:	9b01      	ldr	r3, [sp, #4]
 8000bd0:	685b      	ldr	r3, [r3, #4]
 8000bd2:	9a01      	ldr	r2, [sp, #4]
 8000bd4:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 8000bd6:	9b03      	ldr	r3, [sp, #12]
 8000bd8:	9a01      	ldr	r2, [sp, #4]
 8000bda:	605a      	str	r2, [r3, #4]

  return tp;
 8000bdc:	9b01      	ldr	r3, [sp, #4]
}
 8000bde:	4618      	mov	r0, r3
 8000be0:	b004      	add	sp, #16
 8000be2:	4770      	bx	lr
 8000be4:	20000d98 	.word	0x20000d98
 8000be8:	f3af 8000 	nop.w
 8000bec:	f3af 8000 	nop.w

08000bf0 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8000bf0:	b500      	push	{lr}
 8000bf2:	b085      	sub	sp, #20
 8000bf4:	4603      	mov	r3, r0
 8000bf6:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 8000bfa:	4b0e      	ldr	r3, [pc, #56]	; (8000c34 <chSchGoSleepS+0x44>)
 8000bfc:	699b      	ldr	r3, [r3, #24]
 8000bfe:	9303      	str	r3, [sp, #12]
  otp->p_state = newstate;
 8000c00:	9b03      	ldr	r3, [sp, #12]
 8000c02:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8000c06:	771a      	strb	r2, [r3, #28]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 8000c08:	9b03      	ldr	r3, [sp, #12]
 8000c0a:	220a      	movs	r2, #10
 8000c0c:	77da      	strb	r2, [r3, #31]
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000c0e:	4809      	ldr	r0, [pc, #36]	; (8000c34 <chSchGoSleepS+0x44>)
 8000c10:	f7ff ff4e 	bl	8000ab0 <queue_fifo_remove>
 8000c14:	4602      	mov	r2, r0
 8000c16:	4b07      	ldr	r3, [pc, #28]	; (8000c34 <chSchGoSleepS+0x44>)
 8000c18:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000c1a:	4b06      	ldr	r3, [pc, #24]	; (8000c34 <chSchGoSleepS+0x44>)
 8000c1c:	699b      	ldr	r3, [r3, #24]
 8000c1e:	2201      	movs	r2, #1
 8000c20:	771a      	strb	r2, [r3, #28]
  chSysSwitch(currp, otp);
 8000c22:	4b04      	ldr	r3, [pc, #16]	; (8000c34 <chSchGoSleepS+0x44>)
 8000c24:	699b      	ldr	r3, [r3, #24]
 8000c26:	4618      	mov	r0, r3
 8000c28:	9903      	ldr	r1, [sp, #12]
 8000c2a:	f7ff fb59 	bl	80002e0 <_port_switch>
}
 8000c2e:	b005      	add	sp, #20
 8000c30:	f85d fb04 	ldr.w	pc, [sp], #4
 8000c34:	20000d98 	.word	0x20000d98
 8000c38:	f3af 8000 	nop.w
 8000c3c:	f3af 8000 	nop.w

08000c40 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8000c40:	b500      	push	{lr}
 8000c42:	b085      	sub	sp, #20
 8000c44:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
 8000c46:	9b01      	ldr	r3, [sp, #4]
 8000c48:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 8000c4a:	f7ff ff69 	bl	8000b20 <chSysLockFromISR>
  switch (tp->p_state) {
 8000c4e:	9b03      	ldr	r3, [sp, #12]
 8000c50:	7f1b      	ldrb	r3, [r3, #28]
 8000c52:	2b07      	cmp	r3, #7
 8000c54:	d823      	bhi.n	8000c9e <wakeup+0x5e>
 8000c56:	a201      	add	r2, pc, #4	; (adr r2, 8000c5c <wakeup+0x1c>)
 8000c58:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000c5c:	08000c7d 	.word	0x08000c7d
 8000c60:	08000c9f 	.word	0x08000c9f
 8000c64:	08000c9f 	.word	0x08000c9f
 8000c68:	08000c83 	.word	0x08000c83
 8000c6c:	08000c97 	.word	0x08000c97
 8000c70:	08000c8d 	.word	0x08000c8d
 8000c74:	08000c9f 	.word	0x08000c9f
 8000c78:	08000c97 	.word	0x08000c97
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8000c7c:	f7ff ff58 	bl	8000b30 <chSysUnlockFromISR>
    return;
 8000c80:	e017      	b.n	8000cb2 <wakeup+0x72>
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8000c82:	9b03      	ldr	r3, [sp, #12]
 8000c84:	6a1b      	ldr	r3, [r3, #32]
 8000c86:	2200      	movs	r2, #0
 8000c88:	601a      	str	r2, [r3, #0]
    break;
 8000c8a:	e009      	b.n	8000ca0 <wakeup+0x60>
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 8000c8c:	9b03      	ldr	r3, [sp, #12]
 8000c8e:	6a1b      	ldr	r3, [r3, #32]
 8000c90:	4618      	mov	r0, r3
 8000c92:	f7ff ff65 	bl	8000b60 <chSemFastSignalI>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 8000c96:	9803      	ldr	r0, [sp, #12]
 8000c98:	f7ff ff22 	bl	8000ae0 <queue_dequeue>
    break;
 8000c9c:	e000      	b.n	8000ca0 <wakeup+0x60>
  default:
    /* Any other state, nothing to do.*/
    break;
 8000c9e:	bf00      	nop
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8000ca0:	9b03      	ldr	r3, [sp, #12]
 8000ca2:	f04f 32ff 	mov.w	r2, #4294967295
 8000ca6:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 8000ca8:	9803      	ldr	r0, [sp, #12]
 8000caa:	f7ff ff79 	bl	8000ba0 <chSchReadyI>
  chSysUnlockFromISR();
 8000cae:	f7ff ff3f 	bl	8000b30 <chSysUnlockFromISR>
}
 8000cb2:	b005      	add	sp, #20
 8000cb4:	f85d fb04 	ldr.w	pc, [sp], #4
 8000cb8:	f3af 8000 	nop.w
 8000cbc:	f3af 8000 	nop.w

08000cc0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000cc0:	b500      	push	{lr}
 8000cc2:	b089      	sub	sp, #36	; 0x24
 8000cc4:	4603      	mov	r3, r0
 8000cc6:	9100      	str	r1, [sp, #0]
 8000cc8:	f88d 3007 	strb.w	r3, [sp, #7]

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8000ccc:	9b00      	ldr	r3, [sp, #0]
 8000cce:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000cd2:	d019      	beq.n	8000d08 <chSchGoSleepTimeoutS+0x48>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8000cd4:	4b12      	ldr	r3, [pc, #72]	; (8000d20 <chSchGoSleepTimeoutS+0x60>)
 8000cd6:	699b      	ldr	r3, [r3, #24]
 8000cd8:	aa03      	add	r2, sp, #12
 8000cda:	4610      	mov	r0, r2
 8000cdc:	9900      	ldr	r1, [sp, #0]
 8000cde:	4a11      	ldr	r2, [pc, #68]	; (8000d24 <chSchGoSleepTimeoutS+0x64>)
 8000ce0:	f7ff fe56 	bl	8000990 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8000ce4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000ce8:	4618      	mov	r0, r3
 8000cea:	f7ff ff81 	bl	8000bf0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8000cee:	ab03      	add	r3, sp, #12
 8000cf0:	4618      	mov	r0, r3
 8000cf2:	f7ff ff25 	bl	8000b40 <chVTIsArmedI>
 8000cf6:	4603      	mov	r3, r0
 8000cf8:	2b00      	cmp	r3, #0
 8000cfa:	d004      	beq.n	8000d06 <chSchGoSleepTimeoutS+0x46>
      chVTDoResetI(&vt);
 8000cfc:	ab03      	add	r3, sp, #12
 8000cfe:	4618      	mov	r0, r3
 8000d00:	f7ff fe86 	bl	8000a10 <chVTDoResetI>
 8000d04:	e005      	b.n	8000d12 <chSchGoSleepTimeoutS+0x52>
 8000d06:	e004      	b.n	8000d12 <chSchGoSleepTimeoutS+0x52>
    }
  }
  else {
    chSchGoSleepS(newstate);
 8000d08:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000d0c:	4618      	mov	r0, r3
 8000d0e:	f7ff ff6f 	bl	8000bf0 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 8000d12:	4b03      	ldr	r3, [pc, #12]	; (8000d20 <chSchGoSleepTimeoutS+0x60>)
 8000d14:	699b      	ldr	r3, [r3, #24]
 8000d16:	6a1b      	ldr	r3, [r3, #32]
}
 8000d18:	4618      	mov	r0, r3
 8000d1a:	b009      	add	sp, #36	; 0x24
 8000d1c:	f85d fb04 	ldr.w	pc, [sp], #4
 8000d20:	20000d98 	.word	0x20000d98
 8000d24:	08000c41 	.word	0x08000c41
 8000d28:	f3af 8000 	nop.w
 8000d2c:	f3af 8000 	nop.w

08000d30 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000d30:	b500      	push	{lr}
 8000d32:	b085      	sub	sp, #20
 8000d34:	9001      	str	r0, [sp, #4]
 8000d36:	9100      	str	r1, [sp, #0]
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8000d38:	9b01      	ldr	r3, [sp, #4]
 8000d3a:	9a00      	ldr	r2, [sp, #0]
 8000d3c:	621a      	str	r2, [r3, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8000d3e:	9b01      	ldr	r3, [sp, #4]
 8000d40:	689a      	ldr	r2, [r3, #8]
 8000d42:	4b0e      	ldr	r3, [pc, #56]	; (8000d7c <chSchWakeupS+0x4c>)
 8000d44:	699b      	ldr	r3, [r3, #24]
 8000d46:	689b      	ldr	r3, [r3, #8]
 8000d48:	429a      	cmp	r2, r3
 8000d4a:	d803      	bhi.n	8000d54 <chSchWakeupS+0x24>
    (void) chSchReadyI(ntp);
 8000d4c:	9801      	ldr	r0, [sp, #4]
 8000d4e:	f7ff ff27 	bl	8000ba0 <chSchReadyI>
 8000d52:	e00f      	b.n	8000d74 <chSchWakeupS+0x44>
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8000d54:	4b09      	ldr	r3, [pc, #36]	; (8000d7c <chSchWakeupS+0x4c>)
 8000d56:	699b      	ldr	r3, [r3, #24]
 8000d58:	4618      	mov	r0, r3
 8000d5a:	f7ff ff21 	bl	8000ba0 <chSchReadyI>
 8000d5e:	9003      	str	r0, [sp, #12]
    setcurrp(ntp);
 8000d60:	4b06      	ldr	r3, [pc, #24]	; (8000d7c <chSchWakeupS+0x4c>)
 8000d62:	9a01      	ldr	r2, [sp, #4]
 8000d64:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8000d66:	9b01      	ldr	r3, [sp, #4]
 8000d68:	2201      	movs	r2, #1
 8000d6a:	771a      	strb	r2, [r3, #28]
    chSysSwitch(ntp, otp);
 8000d6c:	9801      	ldr	r0, [sp, #4]
 8000d6e:	9903      	ldr	r1, [sp, #12]
 8000d70:	f7ff fab6 	bl	80002e0 <_port_switch>
  }
}
 8000d74:	b005      	add	sp, #20
 8000d76:	f85d fb04 	ldr.w	pc, [sp], #4
 8000d7a:	bf00      	nop
 8000d7c:	20000d98 	.word	0x20000d98

08000d80 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8000d80:	b508      	push	{r3, lr}

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 8000d82:	f7ff febd 	bl	8000b00 <chSchIsRescRequiredI>
 8000d86:	4603      	mov	r3, r0
 8000d88:	2b00      	cmp	r3, #0
 8000d8a:	d001      	beq.n	8000d90 <chSchRescheduleS+0x10>
    chSchDoRescheduleAhead();
 8000d8c:	f000 f850 	bl	8000e30 <chSchDoRescheduleAhead>
  }
}
 8000d90:	bd08      	pop	{r3, pc}
 8000d92:	bf00      	nop
 8000d94:	f3af 8000 	nop.w
 8000d98:	f3af 8000 	nop.w
 8000d9c:	f3af 8000 	nop.w

08000da0 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8000da0:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8000da2:	4b0f      	ldr	r3, [pc, #60]	; (8000de0 <chSchIsPreemptionRequired+0x40>)
 8000da4:	681b      	ldr	r3, [r3, #0]
 8000da6:	689b      	ldr	r3, [r3, #8]
 8000da8:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->p_prio;
 8000daa:	4b0d      	ldr	r3, [pc, #52]	; (8000de0 <chSchIsPreemptionRequired+0x40>)
 8000dac:	699b      	ldr	r3, [r3, #24]
 8000dae:	689b      	ldr	r3, [r3, #8]
 8000db0:	9300      	str	r3, [sp, #0]
#if CH_CFG_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
 8000db2:	4b0b      	ldr	r3, [pc, #44]	; (8000de0 <chSchIsPreemptionRequired+0x40>)
 8000db4:	699b      	ldr	r3, [r3, #24]
 8000db6:	7fdb      	ldrb	r3, [r3, #31]
 8000db8:	2b00      	cmp	r3, #0
 8000dba:	d007      	beq.n	8000dcc <chSchIsPreemptionRequired+0x2c>
 8000dbc:	9a01      	ldr	r2, [sp, #4]
 8000dbe:	9b00      	ldr	r3, [sp, #0]
 8000dc0:	429a      	cmp	r2, r3
 8000dc2:	bf94      	ite	ls
 8000dc4:	2300      	movls	r3, #0
 8000dc6:	2301      	movhi	r3, #1
 8000dc8:	b2db      	uxtb	r3, r3
 8000dca:	e006      	b.n	8000dda <chSchIsPreemptionRequired+0x3a>
 8000dcc:	9a01      	ldr	r2, [sp, #4]
 8000dce:	9b00      	ldr	r3, [sp, #0]
 8000dd0:	429a      	cmp	r2, r3
 8000dd2:	bf34      	ite	cc
 8000dd4:	2300      	movcc	r3, #0
 8000dd6:	2301      	movcs	r3, #1
 8000dd8:	b2db      	uxtb	r3, r3
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
#endif
}
 8000dda:	4618      	mov	r0, r3
 8000ddc:	b002      	add	sp, #8
 8000dde:	4770      	bx	lr
 8000de0:	20000d98 	.word	0x20000d98
 8000de4:	f3af 8000 	nop.w
 8000de8:	f3af 8000 	nop.w
 8000dec:	f3af 8000 	nop.w

08000df0 <chSchDoRescheduleBehind>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleBehind(void) {
 8000df0:	b500      	push	{lr}
 8000df2:	b083      	sub	sp, #12
  thread_t *otp;

  otp = currp;
 8000df4:	4b0d      	ldr	r3, [pc, #52]	; (8000e2c <chSchDoRescheduleBehind+0x3c>)
 8000df6:	699b      	ldr	r3, [r3, #24]
 8000df8:	9301      	str	r3, [sp, #4]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000dfa:	480c      	ldr	r0, [pc, #48]	; (8000e2c <chSchDoRescheduleBehind+0x3c>)
 8000dfc:	f7ff fe58 	bl	8000ab0 <queue_fifo_remove>
 8000e00:	4602      	mov	r2, r0
 8000e02:	4b0a      	ldr	r3, [pc, #40]	; (8000e2c <chSchDoRescheduleBehind+0x3c>)
 8000e04:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000e06:	4b09      	ldr	r3, [pc, #36]	; (8000e2c <chSchDoRescheduleBehind+0x3c>)
 8000e08:	699b      	ldr	r3, [r3, #24]
 8000e0a:	2201      	movs	r2, #1
 8000e0c:	771a      	strb	r2, [r3, #28]
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 8000e0e:	9b01      	ldr	r3, [sp, #4]
 8000e10:	220a      	movs	r2, #10
 8000e12:	77da      	strb	r2, [r3, #31]
#endif
  (void) chSchReadyI(otp);
 8000e14:	9801      	ldr	r0, [sp, #4]
 8000e16:	f7ff fec3 	bl	8000ba0 <chSchReadyI>
  chSysSwitch(currp, otp);
 8000e1a:	4b04      	ldr	r3, [pc, #16]	; (8000e2c <chSchDoRescheduleBehind+0x3c>)
 8000e1c:	699b      	ldr	r3, [r3, #24]
 8000e1e:	4618      	mov	r0, r3
 8000e20:	9901      	ldr	r1, [sp, #4]
 8000e22:	f7ff fa5d 	bl	80002e0 <_port_switch>
}
 8000e26:	b003      	add	sp, #12
 8000e28:	f85d fb04 	ldr.w	pc, [sp], #4
 8000e2c:	20000d98 	.word	0x20000d98

08000e30 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8000e30:	b500      	push	{lr}
 8000e32:	b083      	sub	sp, #12
  thread_t *otp, *cp;

  otp = currp;
 8000e34:	4b18      	ldr	r3, [pc, #96]	; (8000e98 <chSchDoRescheduleAhead+0x68>)
 8000e36:	699b      	ldr	r3, [r3, #24]
 8000e38:	9300      	str	r3, [sp, #0]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000e3a:	4817      	ldr	r0, [pc, #92]	; (8000e98 <chSchDoRescheduleAhead+0x68>)
 8000e3c:	f7ff fe38 	bl	8000ab0 <queue_fifo_remove>
 8000e40:	4602      	mov	r2, r0
 8000e42:	4b15      	ldr	r3, [pc, #84]	; (8000e98 <chSchDoRescheduleAhead+0x68>)
 8000e44:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000e46:	4b14      	ldr	r3, [pc, #80]	; (8000e98 <chSchDoRescheduleAhead+0x68>)
 8000e48:	699b      	ldr	r3, [r3, #24]
 8000e4a:	2201      	movs	r2, #1
 8000e4c:	771a      	strb	r2, [r3, #28]

  otp->p_state = CH_STATE_READY;
 8000e4e:	9b00      	ldr	r3, [sp, #0]
 8000e50:	2200      	movs	r2, #0
 8000e52:	771a      	strb	r2, [r3, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8000e54:	4b10      	ldr	r3, [pc, #64]	; (8000e98 <chSchDoRescheduleAhead+0x68>)
 8000e56:	9301      	str	r3, [sp, #4]
  do {
    cp = cp->p_next;
 8000e58:	9b01      	ldr	r3, [sp, #4]
 8000e5a:	681b      	ldr	r3, [r3, #0]
 8000e5c:	9301      	str	r3, [sp, #4]
  } while (cp->p_prio > otp->p_prio);
 8000e5e:	9b01      	ldr	r3, [sp, #4]
 8000e60:	689a      	ldr	r2, [r3, #8]
 8000e62:	9b00      	ldr	r3, [sp, #0]
 8000e64:	689b      	ldr	r3, [r3, #8]
 8000e66:	429a      	cmp	r2, r3
 8000e68:	d8f6      	bhi.n	8000e58 <chSchDoRescheduleAhead+0x28>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8000e6a:	9b00      	ldr	r3, [sp, #0]
 8000e6c:	9a01      	ldr	r2, [sp, #4]
 8000e6e:	601a      	str	r2, [r3, #0]
  otp->p_prev = cp->p_prev;
 8000e70:	9b01      	ldr	r3, [sp, #4]
 8000e72:	685a      	ldr	r2, [r3, #4]
 8000e74:	9b00      	ldr	r3, [sp, #0]
 8000e76:	605a      	str	r2, [r3, #4]
  otp->p_prev->p_next = otp;
 8000e78:	9b00      	ldr	r3, [sp, #0]
 8000e7a:	685b      	ldr	r3, [r3, #4]
 8000e7c:	9a00      	ldr	r2, [sp, #0]
 8000e7e:	601a      	str	r2, [r3, #0]
  cp->p_prev = otp;
 8000e80:	9b01      	ldr	r3, [sp, #4]
 8000e82:	9a00      	ldr	r2, [sp, #0]
 8000e84:	605a      	str	r2, [r3, #4]

  chSysSwitch(currp, otp);
 8000e86:	4b04      	ldr	r3, [pc, #16]	; (8000e98 <chSchDoRescheduleAhead+0x68>)
 8000e88:	699b      	ldr	r3, [r3, #24]
 8000e8a:	4618      	mov	r0, r3
 8000e8c:	9900      	ldr	r1, [sp, #0]
 8000e8e:	f7ff fa27 	bl	80002e0 <_port_switch>
}
 8000e92:	b003      	add	sp, #12
 8000e94:	f85d fb04 	ldr.w	pc, [sp], #4
 8000e98:	20000d98 	.word	0x20000d98
 8000e9c:	f3af 8000 	nop.w

08000ea0 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8000ea0:	b508      	push	{r3, lr}

#if CH_CFG_TIME_QUANTUM > 0
  /* If CH_CFG_TIME_QUANTUM is enabled then there are two different scenarios
     to handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == (tslices_t)0) {
 8000ea2:	4b05      	ldr	r3, [pc, #20]	; (8000eb8 <chSchDoReschedule+0x18>)
 8000ea4:	699b      	ldr	r3, [r3, #24]
 8000ea6:	7fdb      	ldrb	r3, [r3, #31]
 8000ea8:	2b00      	cmp	r3, #0
 8000eaa:	d102      	bne.n	8000eb2 <chSchDoReschedule+0x12>
    /* The thread consumed its time quantum so it is enqueued behind threads
       with same priority level, however, it acquires a new time quantum.*/
    chSchDoRescheduleBehind();
 8000eac:	f7ff ffa0 	bl	8000df0 <chSchDoRescheduleBehind>
 8000eb0:	e001      	b.n	8000eb6 <chSchDoReschedule+0x16>
  }
  else {
    /* The thread didn't consume all its time quantum so it is put ahead of
       threads with equal priority and does not acquire a new time quantum.*/
    chSchDoRescheduleAhead();
 8000eb2:	f7ff ffbd 	bl	8000e30 <chSchDoRescheduleAhead>
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 8000eb6:	bd08      	pop	{r3, pc}
 8000eb8:	20000d98 	.word	0x20000d98
 8000ebc:	f3af 8000 	nop.w

08000ec0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8000ec0:	b082      	sub	sp, #8
 8000ec2:	2320      	movs	r3, #32
 8000ec4:	9301      	str	r3, [sp, #4]
 8000ec6:	9b01      	ldr	r3, [sp, #4]
 8000ec8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000ecc:	b002      	add	sp, #8
 8000ece:	4770      	bx	lr

08000ed0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8000ed0:	b082      	sub	sp, #8
 8000ed2:	2300      	movs	r3, #0
 8000ed4:	9301      	str	r3, [sp, #4]
 8000ed6:	9b01      	ldr	r3, [sp, #4]
 8000ed8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000edc:	b002      	add	sp, #8
 8000ede:	4770      	bx	lr

08000ee0 <list_init>:
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
 8000ee0:	b082      	sub	sp, #8
 8000ee2:	9001      	str	r0, [sp, #4]

  tlp->p_next = (thread_t *)tlp;
 8000ee4:	9b01      	ldr	r3, [sp, #4]
 8000ee6:	9a01      	ldr	r2, [sp, #4]
 8000ee8:	601a      	str	r2, [r3, #0]
}
 8000eea:	b002      	add	sp, #8
 8000eec:	4770      	bx	lr
 8000eee:	bf00      	nop

08000ef0 <list_notempty>:
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
 8000ef0:	b082      	sub	sp, #8
 8000ef2:	9001      	str	r0, [sp, #4]

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8000ef4:	9b01      	ldr	r3, [sp, #4]
 8000ef6:	681a      	ldr	r2, [r3, #0]
 8000ef8:	9b01      	ldr	r3, [sp, #4]
 8000efa:	429a      	cmp	r2, r3
 8000efc:	bf0c      	ite	eq
 8000efe:	2300      	moveq	r3, #0
 8000f00:	2301      	movne	r3, #1
 8000f02:	b2db      	uxtb	r3, r3
}
 8000f04:	4618      	mov	r0, r3
 8000f06:	b002      	add	sp, #8
 8000f08:	4770      	bx	lr
 8000f0a:	bf00      	nop
 8000f0c:	f3af 8000 	nop.w

08000f10 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8000f10:	b082      	sub	sp, #8
 8000f12:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8000f14:	9b01      	ldr	r3, [sp, #4]
 8000f16:	9a01      	ldr	r2, [sp, #4]
 8000f18:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8000f1a:	9b01      	ldr	r3, [sp, #4]
 8000f1c:	9a01      	ldr	r2, [sp, #4]
 8000f1e:	605a      	str	r2, [r3, #4]
}
 8000f20:	b002      	add	sp, #8
 8000f22:	4770      	bx	lr
 8000f24:	f3af 8000 	nop.w
 8000f28:	f3af 8000 	nop.w
 8000f2c:	f3af 8000 	nop.w

08000f30 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8000f30:	b082      	sub	sp, #8
 8000f32:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8000f34:	9b01      	ldr	r3, [sp, #4]
 8000f36:	681a      	ldr	r2, [r3, #0]
 8000f38:	9b01      	ldr	r3, [sp, #4]
 8000f3a:	429a      	cmp	r2, r3
 8000f3c:	bf0c      	ite	eq
 8000f3e:	2300      	moveq	r3, #0
 8000f40:	2301      	movne	r3, #1
 8000f42:	b2db      	uxtb	r3, r3
}
 8000f44:	4618      	mov	r0, r3
 8000f46:	b002      	add	sp, #8
 8000f48:	4770      	bx	lr
 8000f4a:	bf00      	nop
 8000f4c:	f3af 8000 	nop.w

08000f50 <list_insert>:

/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void list_insert(thread_t *tp, threads_list_t *tlp) {
 8000f50:	b082      	sub	sp, #8
 8000f52:	9001      	str	r0, [sp, #4]
 8000f54:	9100      	str	r1, [sp, #0]

  tp->p_next = tlp->p_next;
 8000f56:	9b00      	ldr	r3, [sp, #0]
 8000f58:	681a      	ldr	r2, [r3, #0]
 8000f5a:	9b01      	ldr	r3, [sp, #4]
 8000f5c:	601a      	str	r2, [r3, #0]
  tlp->p_next = tp;
 8000f5e:	9b00      	ldr	r3, [sp, #0]
 8000f60:	9a01      	ldr	r2, [sp, #4]
 8000f62:	601a      	str	r2, [r3, #0]
}
 8000f64:	b002      	add	sp, #8
 8000f66:	4770      	bx	lr
 8000f68:	f3af 8000 	nop.w
 8000f6c:	f3af 8000 	nop.w

08000f70 <list_remove>:

static inline thread_t *list_remove(threads_list_t *tlp) {
 8000f70:	b084      	sub	sp, #16
 8000f72:	9001      	str	r0, [sp, #4]

  thread_t *tp = tlp->p_next;
 8000f74:	9b01      	ldr	r3, [sp, #4]
 8000f76:	681b      	ldr	r3, [r3, #0]
 8000f78:	9303      	str	r3, [sp, #12]
  tlp->p_next = tp->p_next;
 8000f7a:	9b03      	ldr	r3, [sp, #12]
 8000f7c:	681a      	ldr	r2, [r3, #0]
 8000f7e:	9b01      	ldr	r3, [sp, #4]
 8000f80:	601a      	str	r2, [r3, #0]

  return tp;
 8000f82:	9b03      	ldr	r3, [sp, #12]
}
 8000f84:	4618      	mov	r0, r3
 8000f86:	b004      	add	sp, #16
 8000f88:	4770      	bx	lr
 8000f8a:	bf00      	nop
 8000f8c:	f3af 8000 	nop.w

08000f90 <queue_insert>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8000f90:	b082      	sub	sp, #8
 8000f92:	9001      	str	r0, [sp, #4]
 8000f94:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 8000f96:	9b01      	ldr	r3, [sp, #4]
 8000f98:	9a00      	ldr	r2, [sp, #0]
 8000f9a:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 8000f9c:	9b00      	ldr	r3, [sp, #0]
 8000f9e:	685a      	ldr	r2, [r3, #4]
 8000fa0:	9b01      	ldr	r3, [sp, #4]
 8000fa2:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8000fa4:	9b01      	ldr	r3, [sp, #4]
 8000fa6:	685b      	ldr	r3, [r3, #4]
 8000fa8:	9a01      	ldr	r2, [sp, #4]
 8000faa:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 8000fac:	9b00      	ldr	r3, [sp, #0]
 8000fae:	9a01      	ldr	r2, [sp, #4]
 8000fb0:	605a      	str	r2, [r3, #4]
}
 8000fb2:	b002      	add	sp, #8
 8000fb4:	4770      	bx	lr
 8000fb6:	bf00      	nop
 8000fb8:	f3af 8000 	nop.w
 8000fbc:	f3af 8000 	nop.w

08000fc0 <queue_fifo_remove>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8000fc0:	b084      	sub	sp, #16
 8000fc2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8000fc4:	9b01      	ldr	r3, [sp, #4]
 8000fc6:	681b      	ldr	r3, [r3, #0]
 8000fc8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8000fca:	9b03      	ldr	r3, [sp, #12]
 8000fcc:	681a      	ldr	r2, [r3, #0]
 8000fce:	9b01      	ldr	r3, [sp, #4]
 8000fd0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000fd2:	9b01      	ldr	r3, [sp, #4]
 8000fd4:	681b      	ldr	r3, [r3, #0]
 8000fd6:	9a01      	ldr	r2, [sp, #4]
 8000fd8:	605a      	str	r2, [r3, #4]

  return tp;
 8000fda:	9b03      	ldr	r3, [sp, #12]
}
 8000fdc:	4618      	mov	r0, r3
 8000fde:	b004      	add	sp, #16
 8000fe0:	4770      	bx	lr
 8000fe2:	bf00      	nop
 8000fe4:	f3af 8000 	nop.w
 8000fe8:	f3af 8000 	nop.w
 8000fec:	f3af 8000 	nop.w

08000ff0 <chSchCanYieldS>:
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.r_queue) >= currp->p_prio;
 8000ff0:	4b06      	ldr	r3, [pc, #24]	; (800100c <chSchCanYieldS+0x1c>)
 8000ff2:	681b      	ldr	r3, [r3, #0]
 8000ff4:	689a      	ldr	r2, [r3, #8]
 8000ff6:	4b05      	ldr	r3, [pc, #20]	; (800100c <chSchCanYieldS+0x1c>)
 8000ff8:	699b      	ldr	r3, [r3, #24]
 8000ffa:	689b      	ldr	r3, [r3, #8]
 8000ffc:	429a      	cmp	r2, r3
 8000ffe:	bf34      	ite	cc
 8001000:	2300      	movcc	r3, #0
 8001002:	2301      	movcs	r3, #1
 8001004:	b2db      	uxtb	r3, r3
}
 8001006:	4618      	mov	r0, r3
 8001008:	4770      	bx	lr
 800100a:	bf00      	nop
 800100c:	20000d98 	.word	0x20000d98

08001010 <chSchDoYieldS>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal or higher priority, if any.
 *
 * @sclass
 */
static inline void chSchDoYieldS(void) {
 8001010:	b508      	push	{r3, lr}

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 8001012:	f7ff ffed 	bl	8000ff0 <chSchCanYieldS>
 8001016:	4603      	mov	r3, r0
 8001018:	2b00      	cmp	r3, #0
 800101a:	d001      	beq.n	8001020 <chSchDoYieldS+0x10>
    chSchDoRescheduleBehind();
 800101c:	f7ff fee8 	bl	8000df0 <chSchDoRescheduleBehind>
  }
}
 8001020:	bd08      	pop	{r3, pc}
 8001022:	bf00      	nop
 8001024:	f3af 8000 	nop.w
 8001028:	f3af 8000 	nop.w
 800102c:	f3af 8000 	nop.w

08001030 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001030:	b508      	push	{r3, lr}

  port_lock();
 8001032:	f7ff ff45 	bl	8000ec0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001036:	bd08      	pop	{r3, pc}
 8001038:	f3af 8000 	nop.w
 800103c:	f3af 8000 	nop.w

08001040 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001040:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001042:	f7ff ff45 	bl	8000ed0 <port_unlock>
}
 8001046:	bd08      	pop	{r3, pc}
 8001048:	f3af 8000 	nop.w
 800104c:	f3af 8000 	nop.w

08001050 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 8001050:	4b01      	ldr	r3, [pc, #4]	; (8001058 <chVTGetSystemTimeX+0x8>)
 8001052:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001054:	4618      	mov	r0, r3
 8001056:	4770      	bx	lr
 8001058:	20000d98 	.word	0x20000d98
 800105c:	f3af 8000 	nop.w

08001060 <chVTIsTimeWithinX>:
 *
 * @xclass
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {
 8001060:	b084      	sub	sp, #16
 8001062:	9003      	str	r0, [sp, #12]
 8001064:	9102      	str	r1, [sp, #8]
 8001066:	9201      	str	r2, [sp, #4]

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 8001068:	9a03      	ldr	r2, [sp, #12]
 800106a:	9b02      	ldr	r3, [sp, #8]
 800106c:	1ad2      	subs	r2, r2, r3
 800106e:	9901      	ldr	r1, [sp, #4]
 8001070:	9b02      	ldr	r3, [sp, #8]
 8001072:	1acb      	subs	r3, r1, r3
 8001074:	429a      	cmp	r2, r3
 8001076:	bf2c      	ite	cs
 8001078:	2300      	movcs	r3, #0
 800107a:	2301      	movcc	r3, #1
 800107c:	b2db      	uxtb	r3, r3
}
 800107e:	4618      	mov	r0, r3
 8001080:	b004      	add	sp, #16
 8001082:	4770      	bx	lr
 8001084:	f3af 8000 	nop.w
 8001088:	f3af 8000 	nop.w
 800108c:	f3af 8000 	nop.w

08001090 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001090:	4b01      	ldr	r3, [pc, #4]	; (8001098 <chThdGetSelfX+0x8>)
 8001092:	699b      	ldr	r3, [r3, #24]
}
 8001094:	4618      	mov	r0, r3
 8001096:	4770      	bx	lr
 8001098:	20000d98 	.word	0x20000d98
 800109c:	f3af 8000 	nop.w

080010a0 <chThdStartI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
static inline thread_t *chThdStartI(thread_t *tp) {
 80010a0:	b500      	push	{lr}
 80010a2:	b083      	sub	sp, #12
 80010a4:	9001      	str	r0, [sp, #4]

  chDbgAssert(tp->p_state == CH_STATE_WTSTART, "wrong state");

  return chSchReadyI(tp);
 80010a6:	9801      	ldr	r0, [sp, #4]
 80010a8:	f7ff fd7a 	bl	8000ba0 <chSchReadyI>
 80010ac:	4603      	mov	r3, r0
}
 80010ae:	4618      	mov	r0, r3
 80010b0:	b003      	add	sp, #12
 80010b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80010b6:	bf00      	nop
 80010b8:	f3af 8000 	nop.w
 80010bc:	f3af 8000 	nop.w

080010c0 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {
 80010c0:	b500      	push	{lr}
 80010c2:	b083      	sub	sp, #12
 80010c4:	9001      	str	r0, [sp, #4]

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 80010c6:	2008      	movs	r0, #8
 80010c8:	9901      	ldr	r1, [sp, #4]
 80010ca:	f7ff fdf9 	bl	8000cc0 <chSchGoSleepTimeoutS>
}
 80010ce:	b003      	add	sp, #12
 80010d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80010d4:	f3af 8000 	nop.w
 80010d8:	f3af 8000 	nop.w
 80010dc:	f3af 8000 	nop.w

080010e0 <chThdDoDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80010e0:	b500      	push	{lr}
 80010e2:	b085      	sub	sp, #20
 80010e4:	9001      	str	r0, [sp, #4]
 80010e6:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);
 80010e8:	9801      	ldr	r0, [sp, #4]
 80010ea:	f7ff ff69 	bl	8000fc0 <queue_fifo_remove>
 80010ee:	9003      	str	r0, [sp, #12]

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 80010f0:	9b03      	ldr	r3, [sp, #12]
 80010f2:	9a00      	ldr	r2, [sp, #0]
 80010f4:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 80010f6:	9803      	ldr	r0, [sp, #12]
 80010f8:	f7ff fd52 	bl	8000ba0 <chSchReadyI>
}
 80010fc:	b005      	add	sp, #20
 80010fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8001102:	bf00      	nop
 8001104:	f3af 8000 	nop.w
 8001108:	f3af 8000 	nop.w
 800110c:	f3af 8000 	nop.w

08001110 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 8001110:	b500      	push	{lr}
 8001112:	b083      	sub	sp, #12
 8001114:	9001      	str	r0, [sp, #4]
 8001116:	9100      	str	r1, [sp, #0]

  tp->p_prio = prio;
 8001118:	9b01      	ldr	r3, [sp, #4]
 800111a:	9a00      	ldr	r2, [sp, #0]
 800111c:	609a      	str	r2, [r3, #8]
  tp->p_state = CH_STATE_WTSTART;
 800111e:	9b01      	ldr	r3, [sp, #4]
 8001120:	2202      	movs	r2, #2
 8001122:	771a      	strb	r2, [r3, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8001124:	9b01      	ldr	r3, [sp, #4]
 8001126:	2200      	movs	r2, #0
 8001128:	775a      	strb	r2, [r3, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 800112a:	9b01      	ldr	r3, [sp, #4]
 800112c:	220a      	movs	r2, #10
 800112e:	77da      	strb	r2, [r3, #31]
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8001130:	9b01      	ldr	r3, [sp, #4]
 8001132:	9a00      	ldr	r2, [sp, #0]
 8001134:	63da      	str	r2, [r3, #60]	; 0x3c
  tp->p_mtxlist = NULL;
 8001136:	9b01      	ldr	r3, [sp, #4]
 8001138:	2200      	movs	r2, #0
 800113a:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 800113c:	9b01      	ldr	r3, [sp, #4]
 800113e:	2200      	movs	r2, #0
 8001140:	635a      	str	r2, [r3, #52]	; 0x34
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8001142:	9b01      	ldr	r3, [sp, #4]
 8001144:	2201      	movs	r2, #1
 8001146:	779a      	strb	r2, [r3, #30]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8001148:	9b01      	ldr	r3, [sp, #4]
 800114a:	2200      	movs	r2, #0
 800114c:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 800114e:	9b01      	ldr	r3, [sp, #4]
 8001150:	4a0d      	ldr	r2, [pc, #52]	; (8001188 <_thread_init+0x78>)
 8001152:	611a      	str	r2, [r3, #16]
 8001154:	4b0c      	ldr	r3, [pc, #48]	; (8001188 <_thread_init+0x78>)
 8001156:	695a      	ldr	r2, [r3, #20]
 8001158:	9b01      	ldr	r3, [sp, #4]
 800115a:	615a      	str	r2, [r3, #20]
 800115c:	9b01      	ldr	r3, [sp, #4]
 800115e:	695b      	ldr	r3, [r3, #20]
 8001160:	9a01      	ldr	r2, [sp, #4]
 8001162:	611a      	str	r2, [r3, #16]
 8001164:	4b08      	ldr	r3, [pc, #32]	; (8001188 <_thread_init+0x78>)
 8001166:	9a01      	ldr	r2, [sp, #4]
 8001168:	615a      	str	r2, [r3, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 800116a:	9b01      	ldr	r3, [sp, #4]
 800116c:	3324      	adds	r3, #36	; 0x24
 800116e:	4618      	mov	r0, r3
 8001170:	f7ff feb6 	bl	8000ee0 <list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 8001174:	9b01      	ldr	r3, [sp, #4]
 8001176:	3328      	adds	r3, #40	; 0x28
 8001178:	4618      	mov	r0, r3
 800117a:	f7ff fec9 	bl	8000f10 <queue_init>
  chTMObjectInit(&tp->p_stats);
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
 800117e:	9b01      	ldr	r3, [sp, #4]
}
 8001180:	4618      	mov	r0, r3
 8001182:	b003      	add	sp, #12
 8001184:	f85d fb04 	ldr.w	pc, [sp], #4
 8001188:	20000d98 	.word	0x20000d98
 800118c:	f3af 8000 	nop.w

08001190 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 8001190:	b500      	push	{lr}
 8001192:	b087      	sub	sp, #28
 8001194:	9003      	str	r0, [sp, #12]
 8001196:	9102      	str	r1, [sp, #8]
 8001198:	9201      	str	r2, [sp, #4]
 800119a:	9300      	str	r3, [sp, #0]
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;
 800119c:	9b03      	ldr	r3, [sp, #12]
 800119e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80011a0:	9b02      	ldr	r3, [sp, #8]
 80011a2:	3b24      	subs	r3, #36	; 0x24
 80011a4:	9a03      	ldr	r2, [sp, #12]
 80011a6:	441a      	add	r2, r3
 80011a8:	9b05      	ldr	r3, [sp, #20]
 80011aa:	60da      	str	r2, [r3, #12]
 80011ac:	9b05      	ldr	r3, [sp, #20]
 80011ae:	68db      	ldr	r3, [r3, #12]
 80011b0:	9a00      	ldr	r2, [sp, #0]
 80011b2:	601a      	str	r2, [r3, #0]
 80011b4:	9b05      	ldr	r3, [sp, #20]
 80011b6:	68db      	ldr	r3, [r3, #12]
 80011b8:	9a08      	ldr	r2, [sp, #32]
 80011ba:	605a      	str	r2, [r3, #4]
 80011bc:	9b05      	ldr	r3, [sp, #20]
 80011be:	68db      	ldr	r3, [r3, #12]
 80011c0:	4a05      	ldr	r2, [pc, #20]	; (80011d8 <chThdCreateI+0x48>)
 80011c2:	621a      	str	r2, [r3, #32]

  return _thread_init(tp, prio);
 80011c4:	9805      	ldr	r0, [sp, #20]
 80011c6:	9901      	ldr	r1, [sp, #4]
 80011c8:	f7ff ffa2 	bl	8001110 <_thread_init>
 80011cc:	4603      	mov	r3, r0
}
 80011ce:	4618      	mov	r0, r3
 80011d0:	b007      	add	sp, #28
 80011d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80011d6:	bf00      	nop
 80011d8:	080002f1 	.word	0x080002f1
 80011dc:	f3af 8000 	nop.w

080011e0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 80011e0:	b500      	push	{lr}
 80011e2:	b089      	sub	sp, #36	; 0x24
 80011e4:	9005      	str	r0, [sp, #20]
 80011e6:	9104      	str	r1, [sp, #16]
 80011e8:	9203      	str	r2, [sp, #12]
 80011ea:	9302      	str	r3, [sp, #8]
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 80011ec:	f7ff ff20 	bl	8001030 <chSysLock>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 80011f0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80011f2:	9300      	str	r3, [sp, #0]
 80011f4:	9805      	ldr	r0, [sp, #20]
 80011f6:	9904      	ldr	r1, [sp, #16]
 80011f8:	9a03      	ldr	r2, [sp, #12]
 80011fa:	9b02      	ldr	r3, [sp, #8]
 80011fc:	f7ff ffc8 	bl	8001190 <chThdCreateI>
 8001200:	9007      	str	r0, [sp, #28]
  chSchWakeupS(tp, MSG_OK);
 8001202:	9807      	ldr	r0, [sp, #28]
 8001204:	2100      	movs	r1, #0
 8001206:	f7ff fd93 	bl	8000d30 <chSchWakeupS>
  chSysUnlock();
 800120a:	f7ff ff19 	bl	8001040 <chSysUnlock>

  return tp;
 800120e:	9b07      	ldr	r3, [sp, #28]
}
 8001210:	4618      	mov	r0, r3
 8001212:	b009      	add	sp, #36	; 0x24
 8001214:	f85d fb04 	ldr.w	pc, [sp], #4
 8001218:	f3af 8000 	nop.w
 800121c:	f3af 8000 	nop.w

08001220 <chThdStart>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdStart(thread_t *tp) {
 8001220:	b500      	push	{lr}
 8001222:	b083      	sub	sp, #12
 8001224:	9001      	str	r0, [sp, #4]

  chSysLock();
 8001226:	f7ff ff03 	bl	8001030 <chSysLock>
  tp = chThdStartI(tp);
 800122a:	9801      	ldr	r0, [sp, #4]
 800122c:	f7ff ff38 	bl	80010a0 <chThdStartI>
 8001230:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 8001232:	f7ff ff05 	bl	8001040 <chSysUnlock>

  return tp;
 8001236:	9b01      	ldr	r3, [sp, #4]
}
 8001238:	4618      	mov	r0, r3
 800123a:	b003      	add	sp, #12
 800123c:	f85d fb04 	ldr.w	pc, [sp], #4

08001240 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 8001240:	b500      	push	{lr}
 8001242:	b085      	sub	sp, #20
 8001244:	9001      	str	r0, [sp, #4]
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO);

  chSysLock();
 8001246:	f7ff fef3 	bl	8001030 <chSysLock>
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->p_realprio;
 800124a:	4b11      	ldr	r3, [pc, #68]	; (8001290 <chThdSetPriority+0x50>)
 800124c:	699b      	ldr	r3, [r3, #24]
 800124e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001250:	9303      	str	r3, [sp, #12]
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio)) {
 8001252:	4b0f      	ldr	r3, [pc, #60]	; (8001290 <chThdSetPriority+0x50>)
 8001254:	699b      	ldr	r3, [r3, #24]
 8001256:	689a      	ldr	r2, [r3, #8]
 8001258:	4b0d      	ldr	r3, [pc, #52]	; (8001290 <chThdSetPriority+0x50>)
 800125a:	699b      	ldr	r3, [r3, #24]
 800125c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800125e:	429a      	cmp	r2, r3
 8001260:	d005      	beq.n	800126e <chThdSetPriority+0x2e>
 8001262:	4b0b      	ldr	r3, [pc, #44]	; (8001290 <chThdSetPriority+0x50>)
 8001264:	699b      	ldr	r3, [r3, #24]
 8001266:	689a      	ldr	r2, [r3, #8]
 8001268:	9b01      	ldr	r3, [sp, #4]
 800126a:	429a      	cmp	r2, r3
 800126c:	d203      	bcs.n	8001276 <chThdSetPriority+0x36>
    currp->p_prio = newprio;
 800126e:	4b08      	ldr	r3, [pc, #32]	; (8001290 <chThdSetPriority+0x50>)
 8001270:	699b      	ldr	r3, [r3, #24]
 8001272:	9a01      	ldr	r2, [sp, #4]
 8001274:	609a      	str	r2, [r3, #8]
  }
  currp->p_realprio = newprio;
 8001276:	4b06      	ldr	r3, [pc, #24]	; (8001290 <chThdSetPriority+0x50>)
 8001278:	699b      	ldr	r3, [r3, #24]
 800127a:	9a01      	ldr	r2, [sp, #4]
 800127c:	63da      	str	r2, [r3, #60]	; 0x3c
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
 800127e:	f7ff fd7f 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 8001282:	f7ff fedd 	bl	8001040 <chSysUnlock>

  return oldprio;
 8001286:	9b03      	ldr	r3, [sp, #12]
}
 8001288:	4618      	mov	r0, r3
 800128a:	b005      	add	sp, #20
 800128c:	f85d fb04 	ldr.w	pc, [sp], #4
 8001290:	20000d98 	.word	0x20000d98
 8001294:	f3af 8000 	nop.w
 8001298:	f3af 8000 	nop.w
 800129c:	f3af 8000 	nop.w

080012a0 <chThdTerminate>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdTerminate(thread_t *tp) {
 80012a0:	b500      	push	{lr}
 80012a2:	b083      	sub	sp, #12
 80012a4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80012a6:	f7ff fec3 	bl	8001030 <chSysLock>
  tp->p_flags |= CH_FLAG_TERMINATE;
 80012aa:	9b01      	ldr	r3, [sp, #4]
 80012ac:	7f5b      	ldrb	r3, [r3, #29]
 80012ae:	f043 0304 	orr.w	r3, r3, #4
 80012b2:	b2da      	uxtb	r2, r3
 80012b4:	9b01      	ldr	r3, [sp, #4]
 80012b6:	775a      	strb	r2, [r3, #29]
  chSysUnlock();
 80012b8:	f7ff fec2 	bl	8001040 <chSysUnlock>
}
 80012bc:	b003      	add	sp, #12
 80012be:	f85d fb04 	ldr.w	pc, [sp], #4
 80012c2:	bf00      	nop
 80012c4:	f3af 8000 	nop.w
 80012c8:	f3af 8000 	nop.w
 80012cc:	f3af 8000 	nop.w

080012d0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 80012d0:	b500      	push	{lr}
 80012d2:	b083      	sub	sp, #12
 80012d4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80012d6:	f7ff feab 	bl	8001030 <chSysLock>
  chThdSleepS(time);
 80012da:	9801      	ldr	r0, [sp, #4]
 80012dc:	f7ff fef0 	bl	80010c0 <chThdSleepS>
  chSysUnlock();
 80012e0:	f7ff feae 	bl	8001040 <chSysUnlock>
}
 80012e4:	b003      	add	sp, #12
 80012e6:	f85d fb04 	ldr.w	pc, [sp], #4
 80012ea:	bf00      	nop
 80012ec:	f3af 8000 	nop.w

080012f0 <chThdSleepUntil>:
 *
 * @param[in] time      absolute system time
 *
 * @api
 */
void chThdSleepUntil(systime_t time) {
 80012f0:	b500      	push	{lr}
 80012f2:	b083      	sub	sp, #12
 80012f4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80012f6:	f7ff fe9b 	bl	8001030 <chSysLock>
  time -= chVTGetSystemTimeX();
 80012fa:	f7ff fea9 	bl	8001050 <chVTGetSystemTimeX>
 80012fe:	4603      	mov	r3, r0
 8001300:	9a01      	ldr	r2, [sp, #4]
 8001302:	1ad3      	subs	r3, r2, r3
 8001304:	9301      	str	r3, [sp, #4]
  if (time > (systime_t)0) {
 8001306:	9b01      	ldr	r3, [sp, #4]
 8001308:	2b00      	cmp	r3, #0
 800130a:	d002      	beq.n	8001312 <chThdSleepUntil+0x22>
    chThdSleepS(time);
 800130c:	9801      	ldr	r0, [sp, #4]
 800130e:	f7ff fed7 	bl	80010c0 <chThdSleepS>
  }
  chSysUnlock();
 8001312:	f7ff fe95 	bl	8001040 <chSysUnlock>
}
 8001316:	b003      	add	sp, #12
 8001318:	f85d fb04 	ldr.w	pc, [sp], #4
 800131c:	f3af 8000 	nop.w

08001320 <chThdSleepUntilWindowed>:
 * @param[in] next      absolute system time of the next deadline
 * @return				the @p next parameter
 *
 * @api
 */
systime_t chThdSleepUntilWindowed(systime_t prev, systime_t next) {
 8001320:	b500      	push	{lr}
 8001322:	b085      	sub	sp, #20
 8001324:	9001      	str	r0, [sp, #4]
 8001326:	9100      	str	r1, [sp, #0]
  systime_t time;

  chSysLock();
 8001328:	f7ff fe82 	bl	8001030 <chSysLock>
  time = chVTGetSystemTimeX();
 800132c:	f7ff fe90 	bl	8001050 <chVTGetSystemTimeX>
 8001330:	9003      	str	r0, [sp, #12]
  if (chVTIsTimeWithinX(time, prev, next)) {
 8001332:	9803      	ldr	r0, [sp, #12]
 8001334:	9901      	ldr	r1, [sp, #4]
 8001336:	9a00      	ldr	r2, [sp, #0]
 8001338:	f7ff fe92 	bl	8001060 <chVTIsTimeWithinX>
 800133c:	4603      	mov	r3, r0
 800133e:	2b00      	cmp	r3, #0
 8001340:	d005      	beq.n	800134e <chThdSleepUntilWindowed+0x2e>
	chThdSleepS(next - time);
 8001342:	9a00      	ldr	r2, [sp, #0]
 8001344:	9b03      	ldr	r3, [sp, #12]
 8001346:	1ad3      	subs	r3, r2, r3
 8001348:	4618      	mov	r0, r3
 800134a:	f7ff feb9 	bl	80010c0 <chThdSleepS>
  }
  chSysUnlock();
 800134e:	f7ff fe77 	bl	8001040 <chSysUnlock>

  return next;
 8001352:	9b00      	ldr	r3, [sp, #0]
}
 8001354:	4618      	mov	r0, r3
 8001356:	b005      	add	sp, #20
 8001358:	f85d fb04 	ldr.w	pc, [sp], #4
 800135c:	f3af 8000 	nop.w

08001360 <chThdYield>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
 8001360:	b508      	push	{r3, lr}

  chSysLock();
 8001362:	f7ff fe65 	bl	8001030 <chSysLock>
  chSchDoYieldS();
 8001366:	f7ff fe53 	bl	8001010 <chSchDoYieldS>
  chSysUnlock();
 800136a:	f7ff fe69 	bl	8001040 <chSysUnlock>
}
 800136e:	bd08      	pop	{r3, pc}

08001370 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8001370:	b500      	push	{lr}
 8001372:	b083      	sub	sp, #12
 8001374:	9001      	str	r0, [sp, #4]

  chSysLock();
 8001376:	f7ff fe5b 	bl	8001030 <chSysLock>
  chThdExitS(msg);
 800137a:	9801      	ldr	r0, [sp, #4]
 800137c:	f000 f808 	bl	8001390 <chThdExitS>
  /* The thread never returns here.*/
}
 8001380:	b003      	add	sp, #12
 8001382:	f85d fb04 	ldr.w	pc, [sp], #4
 8001386:	bf00      	nop
 8001388:	f3af 8000 	nop.w
 800138c:	f3af 8000 	nop.w

08001390 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8001390:	b500      	push	{lr}
 8001392:	b085      	sub	sp, #20
 8001394:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
 8001396:	4b17      	ldr	r3, [pc, #92]	; (80013f4 <chThdExitS+0x64>)
 8001398:	699b      	ldr	r3, [r3, #24]
 800139a:	9303      	str	r3, [sp, #12]

  tp->p_u.exitcode = msg;
 800139c:	9b03      	ldr	r3, [sp, #12]
 800139e:	9a01      	ldr	r2, [sp, #4]
 80013a0:	621a      	str	r2, [r3, #32]
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 80013a2:	e008      	b.n	80013b6 <chThdExitS+0x26>
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 80013a4:	9b03      	ldr	r3, [sp, #12]
 80013a6:	3324      	adds	r3, #36	; 0x24
 80013a8:	4618      	mov	r0, r3
 80013aa:	f7ff fde1 	bl	8000f70 <list_remove>
 80013ae:	4603      	mov	r3, r0
 80013b0:	4618      	mov	r0, r3
 80013b2:	f7ff fbf5 	bl	8000ba0 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 80013b6:	9b03      	ldr	r3, [sp, #12]
 80013b8:	3324      	adds	r3, #36	; 0x24
 80013ba:	4618      	mov	r0, r3
 80013bc:	f7ff fd98 	bl	8000ef0 <list_notempty>
 80013c0:	4603      	mov	r3, r0
 80013c2:	2b00      	cmp	r3, #0
 80013c4:	d1ee      	bne.n	80013a4 <chThdExitS+0x14>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 80013c6:	9b03      	ldr	r3, [sp, #12]
 80013c8:	7f5b      	ldrb	r3, [r3, #29]
 80013ca:	f003 0303 	and.w	r3, r3, #3
 80013ce:	2b00      	cmp	r3, #0
 80013d0:	d109      	bne.n	80013e6 <chThdExitS+0x56>
    REG_REMOVE(tp);
 80013d2:	9b03      	ldr	r3, [sp, #12]
 80013d4:	695b      	ldr	r3, [r3, #20]
 80013d6:	9a03      	ldr	r2, [sp, #12]
 80013d8:	6912      	ldr	r2, [r2, #16]
 80013da:	611a      	str	r2, [r3, #16]
 80013dc:	9b03      	ldr	r3, [sp, #12]
 80013de:	691b      	ldr	r3, [r3, #16]
 80013e0:	9a03      	ldr	r2, [sp, #12]
 80013e2:	6952      	ldr	r2, [r2, #20]
 80013e4:	615a      	str	r2, [r3, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 80013e6:	200f      	movs	r0, #15
 80013e8:	f7ff fc02 	bl	8000bf0 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 80013ec:	b005      	add	sp, #20
 80013ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80013f2:	bf00      	nop
 80013f4:	20000d98 	.word	0x20000d98
 80013f8:	f3af 8000 	nop.w
 80013fc:	f3af 8000 	nop.w

08001400 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
 8001400:	b500      	push	{lr}
 8001402:	b085      	sub	sp, #20
 8001404:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chDbgCheck(tp != NULL);

  chSysLock();
 8001406:	f7ff fe13 	bl	8001030 <chSysLock>
  chDbgAssert(tp != currp, "waiting self");
#if CH_CFG_USE_DYNAMIC == TRUE
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
#endif
  if (tp->p_state != CH_STATE_FINAL) {
 800140a:	9b01      	ldr	r3, [sp, #4]
 800140c:	7f1b      	ldrb	r3, [r3, #28]
 800140e:	2b0f      	cmp	r3, #15
 8001410:	d00a      	beq.n	8001428 <chThdWait+0x28>
    list_insert(currp, &tp->p_waiting);
 8001412:	4b0c      	ldr	r3, [pc, #48]	; (8001444 <chThdWait+0x44>)
 8001414:	699a      	ldr	r2, [r3, #24]
 8001416:	9b01      	ldr	r3, [sp, #4]
 8001418:	3324      	adds	r3, #36	; 0x24
 800141a:	4610      	mov	r0, r2
 800141c:	4619      	mov	r1, r3
 800141e:	f7ff fd97 	bl	8000f50 <list_insert>
    chSchGoSleepS(CH_STATE_WTEXIT);
 8001422:	2009      	movs	r0, #9
 8001424:	f7ff fbe4 	bl	8000bf0 <chSchGoSleepS>
  }
  msg = tp->p_u.exitcode;
 8001428:	9b01      	ldr	r3, [sp, #4]
 800142a:	6a1b      	ldr	r3, [r3, #32]
 800142c:	9303      	str	r3, [sp, #12]
  chSysUnlock();
 800142e:	f7ff fe07 	bl	8001040 <chSysUnlock>

#if CH_CFG_USE_DYNAMIC == TRUE
  /* Releasing a lock if it is a dynamic thread.*/
  chThdRelease(tp);
 8001432:	9801      	ldr	r0, [sp, #4]
 8001434:	f000 f9c4 	bl	80017c0 <chThdRelease>
#endif

  return msg;
 8001438:	9b03      	ldr	r3, [sp, #12]
}
 800143a:	4618      	mov	r0, r3
 800143c:	b005      	add	sp, #20
 800143e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001442:	bf00      	nop
 8001444:	20000d98 	.word	0x20000d98
 8001448:	f3af 8000 	nop.w
 800144c:	f3af 8000 	nop.w

08001450 <chThdSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendS(thread_reference_t *trp) {
 8001450:	b500      	push	{lr}
 8001452:	b085      	sub	sp, #20
 8001454:	9001      	str	r0, [sp, #4]
  thread_t *tp = chThdGetSelfX();
 8001456:	f7ff fe1b 	bl	8001090 <chThdGetSelfX>
 800145a:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
 800145c:	9b01      	ldr	r3, [sp, #4]
 800145e:	9a03      	ldr	r2, [sp, #12]
 8001460:	601a      	str	r2, [r3, #0]
  tp->p_u.wttrp = trp;
 8001462:	9b03      	ldr	r3, [sp, #12]
 8001464:	9a01      	ldr	r2, [sp, #4]
 8001466:	621a      	str	r2, [r3, #32]
  chSchGoSleepS(CH_STATE_SUSPENDED);
 8001468:	2003      	movs	r0, #3
 800146a:	f7ff fbc1 	bl	8000bf0 <chSchGoSleepS>

  return chThdGetSelfX()->p_u.rdymsg;
 800146e:	f7ff fe0f 	bl	8001090 <chThdGetSelfX>
 8001472:	4603      	mov	r3, r0
 8001474:	6a1b      	ldr	r3, [r3, #32]
}
 8001476:	4618      	mov	r0, r3
 8001478:	b005      	add	sp, #20
 800147a:	f85d fb04 	ldr.w	pc, [sp], #4
 800147e:	bf00      	nop

08001480 <chThdSuspendTimeoutS>:
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {
 8001480:	b500      	push	{lr}
 8001482:	b085      	sub	sp, #20
 8001484:	9001      	str	r0, [sp, #4]
 8001486:	9100      	str	r1, [sp, #0]
  thread_t *tp = chThdGetSelfX();
 8001488:	f7ff fe02 	bl	8001090 <chThdGetSelfX>
 800148c:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");

  if (TIME_IMMEDIATE == timeout) {
 800148e:	9b00      	ldr	r3, [sp, #0]
 8001490:	2b00      	cmp	r3, #0
 8001492:	d102      	bne.n	800149a <chThdSuspendTimeoutS+0x1a>
    return MSG_TIMEOUT;
 8001494:	f04f 33ff 	mov.w	r3, #4294967295
 8001498:	e00a      	b.n	80014b0 <chThdSuspendTimeoutS+0x30>
  }

  *trp = tp;
 800149a:	9b01      	ldr	r3, [sp, #4]
 800149c:	9a03      	ldr	r2, [sp, #12]
 800149e:	601a      	str	r2, [r3, #0]
  tp->p_u.wttrp = trp;
 80014a0:	9b03      	ldr	r3, [sp, #12]
 80014a2:	9a01      	ldr	r2, [sp, #4]
 80014a4:	621a      	str	r2, [r3, #32]

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 80014a6:	2003      	movs	r0, #3
 80014a8:	9900      	ldr	r1, [sp, #0]
 80014aa:	f7ff fc09 	bl	8000cc0 <chSchGoSleepTimeoutS>
 80014ae:	4603      	mov	r3, r0
}
 80014b0:	4618      	mov	r0, r3
 80014b2:	b005      	add	sp, #20
 80014b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80014b8:	f3af 8000 	nop.w
 80014bc:	f3af 8000 	nop.w

080014c0 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 80014c0:	b500      	push	{lr}
 80014c2:	b085      	sub	sp, #20
 80014c4:	9001      	str	r0, [sp, #4]
 80014c6:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 80014c8:	9b01      	ldr	r3, [sp, #4]
 80014ca:	681b      	ldr	r3, [r3, #0]
 80014cc:	2b00      	cmp	r3, #0
 80014ce:	d00b      	beq.n	80014e8 <chThdResumeI+0x28>
    thread_t *tp = *trp;
 80014d0:	9b01      	ldr	r3, [sp, #4]
 80014d2:	681b      	ldr	r3, [r3, #0]
 80014d4:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 80014d6:	9b01      	ldr	r3, [sp, #4]
 80014d8:	2200      	movs	r2, #0
 80014da:	601a      	str	r2, [r3, #0]
    tp->p_u.rdymsg = msg;
 80014dc:	9b03      	ldr	r3, [sp, #12]
 80014de:	9a00      	ldr	r2, [sp, #0]
 80014e0:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 80014e2:	9803      	ldr	r0, [sp, #12]
 80014e4:	f7ff fb5c 	bl	8000ba0 <chSchReadyI>
  }
}
 80014e8:	b005      	add	sp, #20
 80014ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80014ee:	bf00      	nop

080014f0 <chThdResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeS(thread_reference_t *trp, msg_t msg) {
 80014f0:	b500      	push	{lr}
 80014f2:	b085      	sub	sp, #20
 80014f4:	9001      	str	r0, [sp, #4]
 80014f6:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 80014f8:	9b01      	ldr	r3, [sp, #4]
 80014fa:	681b      	ldr	r3, [r3, #0]
 80014fc:	2b00      	cmp	r3, #0
 80014fe:	d009      	beq.n	8001514 <chThdResumeS+0x24>
    thread_t *tp = *trp;
 8001500:	9b01      	ldr	r3, [sp, #4]
 8001502:	681b      	ldr	r3, [r3, #0]
 8001504:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 8001506:	9b01      	ldr	r3, [sp, #4]
 8001508:	2200      	movs	r2, #0
 800150a:	601a      	str	r2, [r3, #0]
    chSchWakeupS(tp, msg);
 800150c:	9803      	ldr	r0, [sp, #12]
 800150e:	9900      	ldr	r1, [sp, #0]
 8001510:	f7ff fc0e 	bl	8000d30 <chSchWakeupS>
  }
}
 8001514:	b005      	add	sp, #20
 8001516:	f85d fb04 	ldr.w	pc, [sp], #4
 800151a:	bf00      	nop
 800151c:	f3af 8000 	nop.w

08001520 <chThdResume>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @api
 */
void chThdResume(thread_reference_t *trp, msg_t msg) {
 8001520:	b500      	push	{lr}
 8001522:	b083      	sub	sp, #12
 8001524:	9001      	str	r0, [sp, #4]
 8001526:	9100      	str	r1, [sp, #0]

  chSysLock();
 8001528:	f7ff fd82 	bl	8001030 <chSysLock>
  chThdResumeS(trp, msg);
 800152c:	9801      	ldr	r0, [sp, #4]
 800152e:	9900      	ldr	r1, [sp, #0]
 8001530:	f7ff ffde 	bl	80014f0 <chThdResumeS>
  chSysUnlock();
 8001534:	f7ff fd84 	bl	8001040 <chSysUnlock>
}
 8001538:	b003      	add	sp, #12
 800153a:	f85d fb04 	ldr.w	pc, [sp], #4
 800153e:	bf00      	nop

08001540 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8001540:	b500      	push	{lr}
 8001542:	b083      	sub	sp, #12
 8001544:	9001      	str	r0, [sp, #4]
 8001546:	9100      	str	r1, [sp, #0]

  if (TIME_IMMEDIATE == timeout) {
 8001548:	9b00      	ldr	r3, [sp, #0]
 800154a:	2b00      	cmp	r3, #0
 800154c:	d102      	bne.n	8001554 <chThdEnqueueTimeoutS+0x14>
    return MSG_TIMEOUT;
 800154e:	f04f 33ff 	mov.w	r3, #4294967295
 8001552:	e00a      	b.n	800156a <chThdEnqueueTimeoutS+0x2a>
  }

  queue_insert(currp, tqp);
 8001554:	4b07      	ldr	r3, [pc, #28]	; (8001574 <chThdEnqueueTimeoutS+0x34>)
 8001556:	699b      	ldr	r3, [r3, #24]
 8001558:	4618      	mov	r0, r3
 800155a:	9901      	ldr	r1, [sp, #4]
 800155c:	f7ff fd18 	bl	8000f90 <queue_insert>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001560:	2004      	movs	r0, #4
 8001562:	9900      	ldr	r1, [sp, #0]
 8001564:	f7ff fbac 	bl	8000cc0 <chSchGoSleepTimeoutS>
 8001568:	4603      	mov	r3, r0
}
 800156a:	4618      	mov	r0, r3
 800156c:	b003      	add	sp, #12
 800156e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001572:	bf00      	nop
 8001574:	20000d98 	.word	0x20000d98
 8001578:	f3af 8000 	nop.w
 800157c:	f3af 8000 	nop.w

08001580 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8001580:	b500      	push	{lr}
 8001582:	b083      	sub	sp, #12
 8001584:	9001      	str	r0, [sp, #4]
 8001586:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
 8001588:	9801      	ldr	r0, [sp, #4]
 800158a:	f7ff fcd1 	bl	8000f30 <queue_notempty>
 800158e:	4603      	mov	r3, r0
 8001590:	2b00      	cmp	r3, #0
 8001592:	d003      	beq.n	800159c <chThdDequeueNextI+0x1c>
    chThdDoDequeueNextI(tqp, msg);
 8001594:	9801      	ldr	r0, [sp, #4]
 8001596:	9900      	ldr	r1, [sp, #0]
 8001598:	f7ff fda2 	bl	80010e0 <chThdDoDequeueNextI>
  }
}
 800159c:	b003      	add	sp, #12
 800159e:	f85d fb04 	ldr.w	pc, [sp], #4
 80015a2:	bf00      	nop
 80015a4:	f3af 8000 	nop.w
 80015a8:	f3af 8000 	nop.w
 80015ac:	f3af 8000 	nop.w

080015b0 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 80015b0:	b500      	push	{lr}
 80015b2:	b083      	sub	sp, #12
 80015b4:	9001      	str	r0, [sp, #4]
 80015b6:	9100      	str	r1, [sp, #0]

  while (queue_notempty(tqp)) {
 80015b8:	e003      	b.n	80015c2 <chThdDequeueAllI+0x12>
    chThdDoDequeueNextI(tqp, msg);
 80015ba:	9801      	ldr	r0, [sp, #4]
 80015bc:	9900      	ldr	r1, [sp, #0]
 80015be:	f7ff fd8f 	bl	80010e0 <chThdDoDequeueNextI>
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  while (queue_notempty(tqp)) {
 80015c2:	9801      	ldr	r0, [sp, #4]
 80015c4:	f7ff fcb4 	bl	8000f30 <queue_notempty>
 80015c8:	4603      	mov	r3, r0
 80015ca:	2b00      	cmp	r3, #0
 80015cc:	d1f5      	bne.n	80015ba <chThdDequeueAllI+0xa>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 80015ce:	b003      	add	sp, #12
 80015d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80015d4:	f3af 8000 	nop.w
 80015d8:	f3af 8000 	nop.w
 80015dc:	f3af 8000 	nop.w

080015e0 <port_rt_get_counter_value>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80015e0:	4b01      	ldr	r3, [pc, #4]	; (80015e8 <port_rt_get_counter_value+0x8>)
 80015e2:	685b      	ldr	r3, [r3, #4]
}
 80015e4:	4618      	mov	r0, r3
 80015e6:	4770      	bx	lr
 80015e8:	e0001000 	.word	0xe0001000
 80015ec:	f3af 8000 	nop.w

080015f0 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
 80015f0:	b084      	sub	sp, #16
 80015f2:	9003      	str	r0, [sp, #12]
 80015f4:	9102      	str	r1, [sp, #8]
 80015f6:	9201      	str	r2, [sp, #4]

  tmp->n++;
 80015f8:	9b03      	ldr	r3, [sp, #12]
 80015fa:	68db      	ldr	r3, [r3, #12]
 80015fc:	1c5a      	adds	r2, r3, #1
 80015fe:	9b03      	ldr	r3, [sp, #12]
 8001600:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
 8001602:	9b03      	ldr	r3, [sp, #12]
 8001604:	689b      	ldr	r3, [r3, #8]
 8001606:	9a02      	ldr	r2, [sp, #8]
 8001608:	1ad2      	subs	r2, r2, r3
 800160a:	9b01      	ldr	r3, [sp, #4]
 800160c:	1ad2      	subs	r2, r2, r3
 800160e:	9b03      	ldr	r3, [sp, #12]
 8001610:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8001612:	9b03      	ldr	r3, [sp, #12]
 8001614:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8001618:	9b03      	ldr	r3, [sp, #12]
 800161a:	689b      	ldr	r3, [r3, #8]
 800161c:	461a      	mov	r2, r3
 800161e:	f04f 0300 	mov.w	r3, #0
 8001622:	1812      	adds	r2, r2, r0
 8001624:	eb43 0301 	adc.w	r3, r3, r1
 8001628:	9903      	ldr	r1, [sp, #12]
 800162a:	e9c1 2304 	strd	r2, r3, [r1, #16]
  if (tmp->last > tmp->worst) {
 800162e:	9b03      	ldr	r3, [sp, #12]
 8001630:	689a      	ldr	r2, [r3, #8]
 8001632:	9b03      	ldr	r3, [sp, #12]
 8001634:	685b      	ldr	r3, [r3, #4]
 8001636:	429a      	cmp	r2, r3
 8001638:	d903      	bls.n	8001642 <tm_stop+0x52>
    tmp->worst = tmp->last;
 800163a:	9b03      	ldr	r3, [sp, #12]
 800163c:	689a      	ldr	r2, [r3, #8]
 800163e:	9b03      	ldr	r3, [sp, #12]
 8001640:	605a      	str	r2, [r3, #4]
  }
  if (tmp->last < tmp->best) {
 8001642:	9b03      	ldr	r3, [sp, #12]
 8001644:	689a      	ldr	r2, [r3, #8]
 8001646:	9b03      	ldr	r3, [sp, #12]
 8001648:	681b      	ldr	r3, [r3, #0]
 800164a:	429a      	cmp	r2, r3
 800164c:	d203      	bcs.n	8001656 <tm_stop+0x66>
    tmp->best = tmp->last;
 800164e:	9b03      	ldr	r3, [sp, #12]
 8001650:	689a      	ldr	r2, [r3, #8]
 8001652:	9b03      	ldr	r3, [sp, #12]
 8001654:	601a      	str	r2, [r3, #0]
  }
}
 8001656:	b004      	add	sp, #16
 8001658:	4770      	bx	lr
 800165a:	bf00      	nop
 800165c:	f3af 8000 	nop.w

08001660 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8001660:	b500      	push	{lr}
 8001662:	b087      	sub	sp, #28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8001664:	4b0a      	ldr	r3, [pc, #40]	; (8001690 <_tm_init+0x30>)
 8001666:	2200      	movs	r2, #0
 8001668:	675a      	str	r2, [r3, #116]	; 0x74
  chTMObjectInit(&tm);
 800166a:	466b      	mov	r3, sp
 800166c:	4618      	mov	r0, r3
 800166e:	f000 f817 	bl	80016a0 <chTMObjectInit>
  chTMStartMeasurementX(&tm);
 8001672:	466b      	mov	r3, sp
 8001674:	4618      	mov	r0, r3
 8001676:	f000 f82b 	bl	80016d0 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 800167a:	466b      	mov	r3, sp
 800167c:	4618      	mov	r0, r3
 800167e:	f000 f837 	bl	80016f0 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 8001682:	9a02      	ldr	r2, [sp, #8]
 8001684:	4b02      	ldr	r3, [pc, #8]	; (8001690 <_tm_init+0x30>)
 8001686:	675a      	str	r2, [r3, #116]	; 0x74
}
 8001688:	b007      	add	sp, #28
 800168a:	f85d fb04 	ldr.w	pc, [sp], #4
 800168e:	bf00      	nop
 8001690:	20000d98 	.word	0x20000d98
 8001694:	f3af 8000 	nop.w
 8001698:	f3af 8000 	nop.w
 800169c:	f3af 8000 	nop.w

080016a0 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
 80016a0:	b082      	sub	sp, #8
 80016a2:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
 80016a4:	9b01      	ldr	r3, [sp, #4]
 80016a6:	f04f 32ff 	mov.w	r2, #4294967295
 80016aa:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
 80016ac:	9b01      	ldr	r3, [sp, #4]
 80016ae:	2200      	movs	r2, #0
 80016b0:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
 80016b2:	9b01      	ldr	r3, [sp, #4]
 80016b4:	2200      	movs	r2, #0
 80016b6:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
 80016b8:	9b01      	ldr	r3, [sp, #4]
 80016ba:	2200      	movs	r2, #0
 80016bc:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
 80016be:	9901      	ldr	r1, [sp, #4]
 80016c0:	f04f 0200 	mov.w	r2, #0
 80016c4:	f04f 0300 	mov.w	r3, #0
 80016c8:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
 80016cc:	b002      	add	sp, #8
 80016ce:	4770      	bx	lr

080016d0 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
 80016d0:	b500      	push	{lr}
 80016d2:	b083      	sub	sp, #12
 80016d4:	9001      	str	r0, [sp, #4]

  tmp->last = chSysGetRealtimeCounterX();
 80016d6:	f7ff ff83 	bl	80015e0 <port_rt_get_counter_value>
 80016da:	4602      	mov	r2, r0
 80016dc:	9b01      	ldr	r3, [sp, #4]
 80016de:	609a      	str	r2, [r3, #8]
}
 80016e0:	b003      	add	sp, #12
 80016e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80016e6:	bf00      	nop
 80016e8:	f3af 8000 	nop.w
 80016ec:	f3af 8000 	nop.w

080016f0 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 80016f0:	b500      	push	{lr}
 80016f2:	b083      	sub	sp, #12
 80016f4:	9001      	str	r0, [sp, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80016f6:	f7ff ff73 	bl	80015e0 <port_rt_get_counter_value>
 80016fa:	4602      	mov	r2, r0
 80016fc:	4b04      	ldr	r3, [pc, #16]	; (8001710 <chTMStopMeasurementX+0x20>)
 80016fe:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8001700:	9801      	ldr	r0, [sp, #4]
 8001702:	4611      	mov	r1, r2
 8001704:	461a      	mov	r2, r3
 8001706:	f7ff ff73 	bl	80015f0 <tm_stop>
}
 800170a:	b003      	add	sp, #12
 800170c:	f85d fb04 	ldr.w	pc, [sp], #4
 8001710:	20000d98 	.word	0x20000d98
 8001714:	f3af 8000 	nop.w
 8001718:	f3af 8000 	nop.w
 800171c:	f3af 8000 	nop.w

08001720 <chTMChainMeasurementToX>:
 *
 *
 * @xclass
 */
NOINLINE void chTMChainMeasurementToX(time_measurement_t *tmp1,
                                      time_measurement_t *tmp2) {
 8001720:	b500      	push	{lr}
 8001722:	b083      	sub	sp, #12
 8001724:	9001      	str	r0, [sp, #4]
 8001726:	9100      	str	r1, [sp, #0]

  /* Starts new measurement.*/
  tmp2->last = chSysGetRealtimeCounterX();
 8001728:	f7ff ff5a 	bl	80015e0 <port_rt_get_counter_value>
 800172c:	4602      	mov	r2, r0
 800172e:	9b00      	ldr	r3, [sp, #0]
 8001730:	609a      	str	r2, [r3, #8]

  /* Stops previous measurement using the same time stamp.*/
  tm_stop(tmp1, tmp2->last, (rtcnt_t)0);
 8001732:	9b00      	ldr	r3, [sp, #0]
 8001734:	689b      	ldr	r3, [r3, #8]
 8001736:	9801      	ldr	r0, [sp, #4]
 8001738:	4619      	mov	r1, r3
 800173a:	2200      	movs	r2, #0
 800173c:	f7ff ff58 	bl	80015f0 <tm_stop>
}
 8001740:	b003      	add	sp, #12
 8001742:	f85d fb04 	ldr.w	pc, [sp], #4
 8001746:	bf00      	nop
 8001748:	f3af 8000 	nop.w
 800174c:	f3af 8000 	nop.w

08001750 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8001750:	b082      	sub	sp, #8
 8001752:	2320      	movs	r3, #32
 8001754:	9301      	str	r3, [sp, #4]
 8001756:	9b01      	ldr	r3, [sp, #4]
 8001758:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800175c:	b002      	add	sp, #8
 800175e:	4770      	bx	lr

08001760 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8001760:	b082      	sub	sp, #8
 8001762:	2300      	movs	r3, #0
 8001764:	9301      	str	r3, [sp, #4]
 8001766:	9b01      	ldr	r3, [sp, #4]
 8001768:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800176c:	b002      	add	sp, #8
 800176e:	4770      	bx	lr

08001770 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001770:	b508      	push	{r3, lr}

  port_lock();
 8001772:	f7ff ffed 	bl	8001750 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001776:	bd08      	pop	{r3, pc}
 8001778:	f3af 8000 	nop.w
 800177c:	f3af 8000 	nop.w

08001780 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001780:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001782:	f7ff ffed 	bl	8001760 <port_unlock>
}
 8001786:	bd08      	pop	{r3, pc}
 8001788:	f3af 8000 	nop.w
 800178c:	f3af 8000 	nop.w

08001790 <chThdAddRef>:
 * @return              The same thread pointer passed as parameter
 *                      representing the new reference.
 *
 * @api
 */
thread_t *chThdAddRef(thread_t *tp) {
 8001790:	b500      	push	{lr}
 8001792:	b083      	sub	sp, #12
 8001794:	9001      	str	r0, [sp, #4]

  chSysLock();
 8001796:	f7ff ffeb 	bl	8001770 <chSysLock>
  chDbgAssert(tp->p_refs < (trefs_t)255, "too many references");
  tp->p_refs++;
 800179a:	9b01      	ldr	r3, [sp, #4]
 800179c:	7f9b      	ldrb	r3, [r3, #30]
 800179e:	3301      	adds	r3, #1
 80017a0:	b2da      	uxtb	r2, r3
 80017a2:	9b01      	ldr	r3, [sp, #4]
 80017a4:	779a      	strb	r2, [r3, #30]
  chSysUnlock();
 80017a6:	f7ff ffeb 	bl	8001780 <chSysUnlock>

  return tp;
 80017aa:	9b01      	ldr	r3, [sp, #4]
}
 80017ac:	4618      	mov	r0, r3
 80017ae:	b003      	add	sp, #12
 80017b0:	f85d fb04 	ldr.w	pc, [sp], #4
 80017b4:	f3af 8000 	nop.w
 80017b8:	f3af 8000 	nop.w
 80017bc:	f3af 8000 	nop.w

080017c0 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 80017c0:	b500      	push	{lr}
 80017c2:	b085      	sub	sp, #20
 80017c4:	9001      	str	r0, [sp, #4]
  trefs_t refs;

  chSysLock();
 80017c6:	f7ff ffd3 	bl	8001770 <chSysLock>
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
  tp->p_refs--;
 80017ca:	9b01      	ldr	r3, [sp, #4]
 80017cc:	7f9b      	ldrb	r3, [r3, #30]
 80017ce:	3b01      	subs	r3, #1
 80017d0:	b2da      	uxtb	r2, r3
 80017d2:	9b01      	ldr	r3, [sp, #4]
 80017d4:	779a      	strb	r2, [r3, #30]
  refs = tp->p_refs;
 80017d6:	9b01      	ldr	r3, [sp, #4]
 80017d8:	7f9b      	ldrb	r3, [r3, #30]
 80017da:	f88d 300f 	strb.w	r3, [sp, #15]

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
 80017de:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80017e2:	2b00      	cmp	r3, #0
 80017e4:	d12f      	bne.n	8001846 <chThdRelease+0x86>
 80017e6:	9b01      	ldr	r3, [sp, #4]
 80017e8:	7f1b      	ldrb	r3, [r3, #28]
 80017ea:	2b0f      	cmp	r3, #15
 80017ec:	d12b      	bne.n	8001846 <chThdRelease+0x86>
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
 80017ee:	9b01      	ldr	r3, [sp, #4]
 80017f0:	7f5b      	ldrb	r3, [r3, #29]
 80017f2:	f003 0303 	and.w	r3, r3, #3
 80017f6:	2b01      	cmp	r3, #1
 80017f8:	d002      	beq.n	8001800 <chThdRelease+0x40>
 80017fa:	2b02      	cmp	r3, #2
 80017fc:	d010      	beq.n	8001820 <chThdRelease+0x60>
      return;
#endif
    default:
      /* Nothing to do for static threads, those are removed from the
         registry on exit.*/
      break;
 80017fe:	e022      	b.n	8001846 <chThdRelease+0x86>
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 8001800:	9b01      	ldr	r3, [sp, #4]
 8001802:	695b      	ldr	r3, [r3, #20]
 8001804:	9a01      	ldr	r2, [sp, #4]
 8001806:	6912      	ldr	r2, [r2, #16]
 8001808:	611a      	str	r2, [r3, #16]
 800180a:	9b01      	ldr	r3, [sp, #4]
 800180c:	691b      	ldr	r3, [r3, #16]
 800180e:	9a01      	ldr	r2, [sp, #4]
 8001810:	6952      	ldr	r2, [r2, #20]
 8001812:	615a      	str	r2, [r3, #20]
#endif
      chSysUnlock();
 8001814:	f7ff ffb4 	bl	8001780 <chSysUnlock>
      chHeapFree(tp);
 8001818:	9801      	ldr	r0, [sp, #4]
 800181a:	f002 f819 	bl	8003850 <chHeapFree>
      return;
 800181e:	e014      	b.n	800184a <chThdRelease+0x8a>
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 8001820:	9b01      	ldr	r3, [sp, #4]
 8001822:	695b      	ldr	r3, [r3, #20]
 8001824:	9a01      	ldr	r2, [sp, #4]
 8001826:	6912      	ldr	r2, [r2, #16]
 8001828:	611a      	str	r2, [r3, #16]
 800182a:	9b01      	ldr	r3, [sp, #4]
 800182c:	691b      	ldr	r3, [r3, #16]
 800182e:	9a01      	ldr	r2, [sp, #4]
 8001830:	6952      	ldr	r2, [r2, #20]
 8001832:	615a      	str	r2, [r3, #20]
#endif
      chSysUnlock();
 8001834:	f7ff ffa4 	bl	8001780 <chSysUnlock>
      chPoolFree(tp->p_mpool, tp);
 8001838:	9b01      	ldr	r3, [sp, #4]
 800183a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800183c:	4618      	mov	r0, r3
 800183e:	9901      	ldr	r1, [sp, #4]
 8001840:	f002 f93e 	bl	8003ac0 <chPoolFree>
      return;
 8001844:	e001      	b.n	800184a <chThdRelease+0x8a>
      /* Nothing to do for static threads, those are removed from the
         registry on exit.*/
      break;
    }
  }
  chSysUnlock();
 8001846:	f7ff ff9b 	bl	8001780 <chSysUnlock>
}
 800184a:	b005      	add	sp, #20
 800184c:	f85d fb04 	ldr.w	pc, [sp], #4

08001850 <chThdCreateFromHeap>:
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
                              tprio_t prio, tfunc_t pf, void *arg) {
 8001850:	b500      	push	{lr}
 8001852:	b089      	sub	sp, #36	; 0x24
 8001854:	9005      	str	r0, [sp, #20]
 8001856:	9104      	str	r1, [sp, #16]
 8001858:	9203      	str	r2, [sp, #12]
 800185a:	9302      	str	r3, [sp, #8]
  void *wsp;
  thread_t *tp;

  wsp = chHeapAlloc(heapp, size);
 800185c:	9805      	ldr	r0, [sp, #20]
 800185e:	9904      	ldr	r1, [sp, #16]
 8001860:	f001 ff7e 	bl	8003760 <chHeapAlloc>
 8001864:	9007      	str	r0, [sp, #28]
  if (wsp == NULL) {
 8001866:	9b07      	ldr	r3, [sp, #28]
 8001868:	2b00      	cmp	r3, #0
 800186a:	d101      	bne.n	8001870 <chThdCreateFromHeap+0x20>
    return NULL;
 800186c:	2300      	movs	r3, #0
 800186e:	e014      	b.n	800189a <chThdCreateFromHeap+0x4a>
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 8001870:	f7ff ff7e 	bl	8001770 <chSysLock>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 8001874:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8001876:	9300      	str	r3, [sp, #0]
 8001878:	9807      	ldr	r0, [sp, #28]
 800187a:	9904      	ldr	r1, [sp, #16]
 800187c:	9a03      	ldr	r2, [sp, #12]
 800187e:	9b02      	ldr	r3, [sp, #8]
 8001880:	f7ff fc86 	bl	8001190 <chThdCreateI>
 8001884:	9006      	str	r0, [sp, #24]
  tp->p_flags = CH_FLAG_MODE_HEAP;
 8001886:	9b06      	ldr	r3, [sp, #24]
 8001888:	2201      	movs	r2, #1
 800188a:	775a      	strb	r2, [r3, #29]
  chSchWakeupS(tp, MSG_OK);
 800188c:	9806      	ldr	r0, [sp, #24]
 800188e:	2100      	movs	r1, #0
 8001890:	f7ff fa4e 	bl	8000d30 <chSchWakeupS>
  chSysUnlock();
 8001894:	f7ff ff74 	bl	8001780 <chSysUnlock>

  return tp;
 8001898:	9b06      	ldr	r3, [sp, #24]
}
 800189a:	4618      	mov	r0, r3
 800189c:	b009      	add	sp, #36	; 0x24
 800189e:	f85d fb04 	ldr.w	pc, [sp], #4
 80018a2:	bf00      	nop
 80018a4:	f3af 8000 	nop.w
 80018a8:	f3af 8000 	nop.w
 80018ac:	f3af 8000 	nop.w

080018b0 <chThdCreateFromMemoryPool>:
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, tprio_t prio,
                                    tfunc_t pf, void *arg) {
 80018b0:	b500      	push	{lr}
 80018b2:	b089      	sub	sp, #36	; 0x24
 80018b4:	9005      	str	r0, [sp, #20]
 80018b6:	9104      	str	r1, [sp, #16]
 80018b8:	9203      	str	r2, [sp, #12]
 80018ba:	9302      	str	r3, [sp, #8]
  void *wsp;
  thread_t *tp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 80018bc:	9805      	ldr	r0, [sp, #20]
 80018be:	f002 f8df 	bl	8003a80 <chPoolAlloc>
 80018c2:	9007      	str	r0, [sp, #28]
  if (wsp == NULL) {
 80018c4:	9b07      	ldr	r3, [sp, #28]
 80018c6:	2b00      	cmp	r3, #0
 80018c8:	d101      	bne.n	80018ce <chThdCreateFromMemoryPool+0x1e>
    return NULL;
 80018ca:	2300      	movs	r3, #0
 80018cc:	e019      	b.n	8001902 <chThdCreateFromMemoryPool+0x52>
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
                  (uint8_t *)wsp + mp->mp_object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 80018ce:	f7ff ff4f 	bl	8001770 <chSysLock>
  tp = chThdCreateI(wsp, mp->mp_object_size, prio, pf, arg);
 80018d2:	9b05      	ldr	r3, [sp, #20]
 80018d4:	685b      	ldr	r3, [r3, #4]
 80018d6:	9a02      	ldr	r2, [sp, #8]
 80018d8:	9200      	str	r2, [sp, #0]
 80018da:	9807      	ldr	r0, [sp, #28]
 80018dc:	4619      	mov	r1, r3
 80018de:	9a04      	ldr	r2, [sp, #16]
 80018e0:	9b03      	ldr	r3, [sp, #12]
 80018e2:	f7ff fc55 	bl	8001190 <chThdCreateI>
 80018e6:	9006      	str	r0, [sp, #24]
  tp->p_flags = CH_FLAG_MODE_MPOOL;
 80018e8:	9b06      	ldr	r3, [sp, #24]
 80018ea:	2202      	movs	r2, #2
 80018ec:	775a      	strb	r2, [r3, #29]
  tp->p_mpool = mp;
 80018ee:	9b06      	ldr	r3, [sp, #24]
 80018f0:	9a05      	ldr	r2, [sp, #20]
 80018f2:	641a      	str	r2, [r3, #64]	; 0x40
  chSchWakeupS(tp, MSG_OK);
 80018f4:	9806      	ldr	r0, [sp, #24]
 80018f6:	2100      	movs	r1, #0
 80018f8:	f7ff fa1a 	bl	8000d30 <chSchWakeupS>
  chSysUnlock();
 80018fc:	f7ff ff40 	bl	8001780 <chSysUnlock>

  return tp;
 8001900:	9b06      	ldr	r3, [sp, #24]
}
 8001902:	4618      	mov	r0, r3
 8001904:	b009      	add	sp, #36	; 0x24
 8001906:	f85d fb04 	ldr.w	pc, [sp], #4
 800190a:	bf00      	nop
 800190c:	f3af 8000 	nop.w

08001910 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8001910:	b082      	sub	sp, #8
 8001912:	2320      	movs	r3, #32
 8001914:	9301      	str	r3, [sp, #4]
 8001916:	9b01      	ldr	r3, [sp, #4]
 8001918:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800191c:	b002      	add	sp, #8
 800191e:	4770      	bx	lr

08001920 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8001920:	b082      	sub	sp, #8
 8001922:	2300      	movs	r3, #0
 8001924:	9301      	str	r3, [sp, #4]
 8001926:	9b01      	ldr	r3, [sp, #4]
 8001928:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800192c:	b002      	add	sp, #8
 800192e:	4770      	bx	lr

08001930 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001930:	b508      	push	{r3, lr}

  port_lock();
 8001932:	f7ff ffed 	bl	8001910 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001936:	bd08      	pop	{r3, pc}
 8001938:	f3af 8000 	nop.w
 800193c:	f3af 8000 	nop.w

08001940 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001940:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001942:	f7ff ffed 	bl	8001920 <port_unlock>
}
 8001946:	bd08      	pop	{r3, pc}
 8001948:	f3af 8000 	nop.w
 800194c:	f3af 8000 	nop.w

08001950 <chRegFirstThread>:
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
thread_t *chRegFirstThread(void) {
 8001950:	b500      	push	{lr}
 8001952:	b083      	sub	sp, #12
  thread_t *tp;

  chSysLock();
 8001954:	f7ff ffec 	bl	8001930 <chSysLock>
  tp = ch.rlist.r_newer;
 8001958:	4b07      	ldr	r3, [pc, #28]	; (8001978 <chRegFirstThread+0x28>)
 800195a:	691b      	ldr	r3, [r3, #16]
 800195c:	9301      	str	r3, [sp, #4]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs++;
 800195e:	9b01      	ldr	r3, [sp, #4]
 8001960:	7f9b      	ldrb	r3, [r3, #30]
 8001962:	3301      	adds	r3, #1
 8001964:	b2da      	uxtb	r2, r3
 8001966:	9b01      	ldr	r3, [sp, #4]
 8001968:	779a      	strb	r2, [r3, #30]
#endif
  chSysUnlock();
 800196a:	f7ff ffe9 	bl	8001940 <chSysUnlock>

  return tp;
 800196e:	9b01      	ldr	r3, [sp, #4]
}
 8001970:	4618      	mov	r0, r3
 8001972:	b003      	add	sp, #12
 8001974:	f85d fb04 	ldr.w	pc, [sp], #4
 8001978:	20000d98 	.word	0x20000d98
 800197c:	f3af 8000 	nop.w

08001980 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 8001980:	b500      	push	{lr}
 8001982:	b085      	sub	sp, #20
 8001984:	9001      	str	r0, [sp, #4]
  thread_t *ntp;

  chSysLock();
 8001986:	f7ff ffd3 	bl	8001930 <chSysLock>
  ntp = tp->p_newer;
 800198a:	9b01      	ldr	r3, [sp, #4]
 800198c:	691b      	ldr	r3, [r3, #16]
 800198e:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 8001990:	9a03      	ldr	r2, [sp, #12]
 8001992:	4b0b      	ldr	r3, [pc, #44]	; (80019c0 <chRegNextThread+0x40>)
 8001994:	429a      	cmp	r2, r3
 8001996:	d102      	bne.n	800199e <chRegNextThread+0x1e>
  /*lint -restore*/
    ntp = NULL;
 8001998:	2300      	movs	r3, #0
 800199a:	9303      	str	r3, [sp, #12]
 800199c:	e005      	b.n	80019aa <chRegNextThread+0x2a>
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->p_refs < (trefs_t)255, "too many references");
    ntp->p_refs++;
 800199e:	9b03      	ldr	r3, [sp, #12]
 80019a0:	7f9b      	ldrb	r3, [r3, #30]
 80019a2:	3301      	adds	r3, #1
 80019a4:	b2da      	uxtb	r2, r3
 80019a6:	9b03      	ldr	r3, [sp, #12]
 80019a8:	779a      	strb	r2, [r3, #30]
  }
#endif
  chSysUnlock();
 80019aa:	f7ff ffc9 	bl	8001940 <chSysUnlock>
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 80019ae:	9801      	ldr	r0, [sp, #4]
 80019b0:	f7ff ff06 	bl	80017c0 <chThdRelease>
#endif

  return ntp;
 80019b4:	9b03      	ldr	r3, [sp, #12]
}
 80019b6:	4618      	mov	r0, r3
 80019b8:	b005      	add	sp, #20
 80019ba:	f85d fb04 	ldr.w	pc, [sp], #4
 80019be:	bf00      	nop
 80019c0:	20000d98 	.word	0x20000d98
 80019c4:	f3af 8000 	nop.w
 80019c8:	f3af 8000 	nop.w
 80019cc:	f3af 8000 	nop.w

080019d0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80019d0:	b082      	sub	sp, #8
 80019d2:	2320      	movs	r3, #32
 80019d4:	9301      	str	r3, [sp, #4]
 80019d6:	9b01      	ldr	r3, [sp, #4]
 80019d8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80019dc:	b002      	add	sp, #8
 80019de:	4770      	bx	lr

080019e0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80019e0:	b082      	sub	sp, #8
 80019e2:	2300      	movs	r3, #0
 80019e4:	9301      	str	r3, [sp, #4]
 80019e6:	9b01      	ldr	r3, [sp, #4]
 80019e8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80019ec:	b002      	add	sp, #8
 80019ee:	4770      	bx	lr

080019f0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 80019f0:	b082      	sub	sp, #8
 80019f2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 80019f4:	9b01      	ldr	r3, [sp, #4]
 80019f6:	9a01      	ldr	r2, [sp, #4]
 80019f8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80019fa:	9b01      	ldr	r3, [sp, #4]
 80019fc:	9a01      	ldr	r2, [sp, #4]
 80019fe:	605a      	str	r2, [r3, #4]
}
 8001a00:	b002      	add	sp, #8
 8001a02:	4770      	bx	lr
 8001a04:	f3af 8000 	nop.w
 8001a08:	f3af 8000 	nop.w
 8001a0c:	f3af 8000 	nop.w

08001a10 <queue_insert>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8001a10:	b082      	sub	sp, #8
 8001a12:	9001      	str	r0, [sp, #4]
 8001a14:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 8001a16:	9b01      	ldr	r3, [sp, #4]
 8001a18:	9a00      	ldr	r2, [sp, #0]
 8001a1a:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 8001a1c:	9b00      	ldr	r3, [sp, #0]
 8001a1e:	685a      	ldr	r2, [r3, #4]
 8001a20:	9b01      	ldr	r3, [sp, #4]
 8001a22:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8001a24:	9b01      	ldr	r3, [sp, #4]
 8001a26:	685b      	ldr	r3, [r3, #4]
 8001a28:	9a01      	ldr	r2, [sp, #4]
 8001a2a:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 8001a2c:	9b00      	ldr	r3, [sp, #0]
 8001a2e:	9a01      	ldr	r2, [sp, #4]
 8001a30:	605a      	str	r2, [r3, #4]
}
 8001a32:	b002      	add	sp, #8
 8001a34:	4770      	bx	lr
 8001a36:	bf00      	nop
 8001a38:	f3af 8000 	nop.w
 8001a3c:	f3af 8000 	nop.w

08001a40 <queue_fifo_remove>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8001a40:	b084      	sub	sp, #16
 8001a42:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8001a44:	9b01      	ldr	r3, [sp, #4]
 8001a46:	681b      	ldr	r3, [r3, #0]
 8001a48:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8001a4a:	9b03      	ldr	r3, [sp, #12]
 8001a4c:	681a      	ldr	r2, [r3, #0]
 8001a4e:	9b01      	ldr	r3, [sp, #4]
 8001a50:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001a52:	9b01      	ldr	r3, [sp, #4]
 8001a54:	681b      	ldr	r3, [r3, #0]
 8001a56:	9a01      	ldr	r2, [sp, #4]
 8001a58:	605a      	str	r2, [r3, #4]

  return tp;
 8001a5a:	9b03      	ldr	r3, [sp, #12]
}
 8001a5c:	4618      	mov	r0, r3
 8001a5e:	b004      	add	sp, #16
 8001a60:	4770      	bx	lr
 8001a62:	bf00      	nop
 8001a64:	f3af 8000 	nop.w
 8001a68:	f3af 8000 	nop.w
 8001a6c:	f3af 8000 	nop.w

08001a70 <queue_lifo_remove>:

static inline thread_t *queue_lifo_remove(threads_queue_t *tqp) {
 8001a70:	b084      	sub	sp, #16
 8001a72:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_prev;
 8001a74:	9b01      	ldr	r3, [sp, #4]
 8001a76:	685b      	ldr	r3, [r3, #4]
 8001a78:	9303      	str	r3, [sp, #12]

  tqp->p_prev = tp->p_prev;
 8001a7a:	9b03      	ldr	r3, [sp, #12]
 8001a7c:	685a      	ldr	r2, [r3, #4]
 8001a7e:	9b01      	ldr	r3, [sp, #4]
 8001a80:	605a      	str	r2, [r3, #4]
  tqp->p_prev->p_next = (thread_t *)tqp;
 8001a82:	9b01      	ldr	r3, [sp, #4]
 8001a84:	685b      	ldr	r3, [r3, #4]
 8001a86:	9a01      	ldr	r2, [sp, #4]
 8001a88:	601a      	str	r2, [r3, #0]

  return tp;
 8001a8a:	9b03      	ldr	r3, [sp, #12]
}
 8001a8c:	4618      	mov	r0, r3
 8001a8e:	b004      	add	sp, #16
 8001a90:	4770      	bx	lr
 8001a92:	bf00      	nop
 8001a94:	f3af 8000 	nop.w
 8001a98:	f3af 8000 	nop.w
 8001a9c:	f3af 8000 	nop.w

08001aa0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001aa0:	b508      	push	{r3, lr}

  port_lock();
 8001aa2:	f7ff ff95 	bl	80019d0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001aa6:	bd08      	pop	{r3, pc}
 8001aa8:	f3af 8000 	nop.w
 8001aac:	f3af 8000 	nop.w

08001ab0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001ab0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001ab2:	f7ff ff95 	bl	80019e0 <port_unlock>
}
 8001ab6:	bd08      	pop	{r3, pc}
 8001ab8:	f3af 8000 	nop.w
 8001abc:	f3af 8000 	nop.w

08001ac0 <chSemObjectInit>:
 * @param[in] n         initial value of the semaphore counter. Must be
 *                      non-negative.
 *
 * @init
 */
void chSemObjectInit(semaphore_t *sp, cnt_t n) {
 8001ac0:	b500      	push	{lr}
 8001ac2:	b083      	sub	sp, #12
 8001ac4:	9001      	str	r0, [sp, #4]
 8001ac6:	9100      	str	r1, [sp, #0]

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->s_queue);
 8001ac8:	9b01      	ldr	r3, [sp, #4]
 8001aca:	4618      	mov	r0, r3
 8001acc:	f7ff ff90 	bl	80019f0 <queue_init>
  sp->s_cnt = n;
 8001ad0:	9b01      	ldr	r3, [sp, #4]
 8001ad2:	9a00      	ldr	r2, [sp, #0]
 8001ad4:	609a      	str	r2, [r3, #8]
}
 8001ad6:	b003      	add	sp, #12
 8001ad8:	f85d fb04 	ldr.w	pc, [sp], #4
 8001adc:	f3af 8000 	nop.w

08001ae0 <chSemReset>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {
 8001ae0:	b500      	push	{lr}
 8001ae2:	b083      	sub	sp, #12
 8001ae4:	9001      	str	r0, [sp, #4]
 8001ae6:	9100      	str	r1, [sp, #0]

  chSysLock();
 8001ae8:	f7ff ffda 	bl	8001aa0 <chSysLock>
  chSemResetI(sp, n);
 8001aec:	9801      	ldr	r0, [sp, #4]
 8001aee:	9900      	ldr	r1, [sp, #0]
 8001af0:	f000 f80e 	bl	8001b10 <chSemResetI>
  chSchRescheduleS();
 8001af4:	f7ff f944 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 8001af8:	f7ff ffda 	bl	8001ab0 <chSysUnlock>
}
 8001afc:	b003      	add	sp, #12
 8001afe:	f85d fb04 	ldr.w	pc, [sp], #4
 8001b02:	bf00      	nop
 8001b04:	f3af 8000 	nop.w
 8001b08:	f3af 8000 	nop.w
 8001b0c:	f3af 8000 	nop.w

08001b10 <chSemResetI>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(semaphore_t *sp, cnt_t n) {
 8001b10:	b500      	push	{lr}
 8001b12:	b085      	sub	sp, #20
 8001b14:	9001      	str	r0, [sp, #4]
 8001b16:	9100      	str	r1, [sp, #0]
  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
 8001b18:	9b01      	ldr	r3, [sp, #4]
 8001b1a:	689b      	ldr	r3, [r3, #8]
 8001b1c:	9303      	str	r3, [sp, #12]
  sp->s_cnt = n;
 8001b1e:	9b01      	ldr	r3, [sp, #4]
 8001b20:	9a00      	ldr	r2, [sp, #0]
 8001b22:	609a      	str	r2, [r3, #8]
  while (++cnt <= (cnt_t)0) {
 8001b24:	e00b      	b.n	8001b3e <chSemResetI+0x2e>
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
 8001b26:	9b01      	ldr	r3, [sp, #4]
 8001b28:	4618      	mov	r0, r3
 8001b2a:	f7ff ffa1 	bl	8001a70 <queue_lifo_remove>
 8001b2e:	4603      	mov	r3, r0
 8001b30:	4618      	mov	r0, r3
 8001b32:	f7ff f835 	bl	8000ba0 <chSchReadyI>
 8001b36:	4603      	mov	r3, r0
 8001b38:	f06f 0201 	mvn.w	r2, #1
 8001b3c:	621a      	str	r2, [r3, #32]
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= (cnt_t)0) {
 8001b3e:	9b03      	ldr	r3, [sp, #12]
 8001b40:	3301      	adds	r3, #1
 8001b42:	9303      	str	r3, [sp, #12]
 8001b44:	9b03      	ldr	r3, [sp, #12]
 8001b46:	2b00      	cmp	r3, #0
 8001b48:	dded      	ble.n	8001b26 <chSemResetI+0x16>
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
  }
}
 8001b4a:	b005      	add	sp, #20
 8001b4c:	f85d fb04 	ldr.w	pc, [sp], #4

08001b50 <chSemWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemWait(semaphore_t *sp) {
 8001b50:	b500      	push	{lr}
 8001b52:	b085      	sub	sp, #20
 8001b54:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chSysLock();
 8001b56:	f7ff ffa3 	bl	8001aa0 <chSysLock>
  msg = chSemWaitS(sp);
 8001b5a:	9801      	ldr	r0, [sp, #4]
 8001b5c:	f000 f808 	bl	8001b70 <chSemWaitS>
 8001b60:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8001b62:	f7ff ffa5 	bl	8001ab0 <chSysUnlock>

  return msg;
 8001b66:	9b03      	ldr	r3, [sp, #12]
}
 8001b68:	4618      	mov	r0, r3
 8001b6a:	b005      	add	sp, #20
 8001b6c:	f85d fb04 	ldr.w	pc, [sp], #4

08001b70 <chSemWaitS>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @sclass
 */
msg_t chSemWaitS(semaphore_t *sp) {
 8001b70:	b500      	push	{lr}
 8001b72:	b083      	sub	sp, #12
 8001b74:	9001      	str	r0, [sp, #4]
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 8001b76:	9b01      	ldr	r3, [sp, #4]
 8001b78:	689b      	ldr	r3, [r3, #8]
 8001b7a:	1e5a      	subs	r2, r3, #1
 8001b7c:	9b01      	ldr	r3, [sp, #4]
 8001b7e:	609a      	str	r2, [r3, #8]
 8001b80:	9b01      	ldr	r3, [sp, #4]
 8001b82:	689b      	ldr	r3, [r3, #8]
 8001b84:	2b00      	cmp	r3, #0
 8001b86:	da11      	bge.n	8001bac <chSemWaitS+0x3c>
    currp->p_u.wtsemp = sp;
 8001b88:	4b0b      	ldr	r3, [pc, #44]	; (8001bb8 <chSemWaitS+0x48>)
 8001b8a:	699b      	ldr	r3, [r3, #24]
 8001b8c:	9a01      	ldr	r2, [sp, #4]
 8001b8e:	621a      	str	r2, [r3, #32]
    sem_insert(currp, &sp->s_queue);
 8001b90:	4b09      	ldr	r3, [pc, #36]	; (8001bb8 <chSemWaitS+0x48>)
 8001b92:	699a      	ldr	r2, [r3, #24]
 8001b94:	9b01      	ldr	r3, [sp, #4]
 8001b96:	4610      	mov	r0, r2
 8001b98:	4619      	mov	r1, r3
 8001b9a:	f7ff ff39 	bl	8001a10 <queue_insert>
    chSchGoSleepS(CH_STATE_WTSEM);
 8001b9e:	2005      	movs	r0, #5
 8001ba0:	f7ff f826 	bl	8000bf0 <chSchGoSleepS>

    return currp->p_u.rdymsg;
 8001ba4:	4b04      	ldr	r3, [pc, #16]	; (8001bb8 <chSemWaitS+0x48>)
 8001ba6:	699b      	ldr	r3, [r3, #24]
 8001ba8:	6a1b      	ldr	r3, [r3, #32]
 8001baa:	e000      	b.n	8001bae <chSemWaitS+0x3e>
  }

  return MSG_OK;
 8001bac:	2300      	movs	r3, #0
}
 8001bae:	4618      	mov	r0, r3
 8001bb0:	b003      	add	sp, #12
 8001bb2:	f85d fb04 	ldr.w	pc, [sp], #4
 8001bb6:	bf00      	nop
 8001bb8:	20000d98 	.word	0x20000d98
 8001bbc:	f3af 8000 	nop.w

08001bc0 <chSemWaitTimeout>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t time) {
 8001bc0:	b500      	push	{lr}
 8001bc2:	b085      	sub	sp, #20
 8001bc4:	9001      	str	r0, [sp, #4]
 8001bc6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  chSysLock();
 8001bc8:	f7ff ff6a 	bl	8001aa0 <chSysLock>
  msg = chSemWaitTimeoutS(sp, time);
 8001bcc:	9801      	ldr	r0, [sp, #4]
 8001bce:	9900      	ldr	r1, [sp, #0]
 8001bd0:	f000 f80e 	bl	8001bf0 <chSemWaitTimeoutS>
 8001bd4:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8001bd6:	f7ff ff6b 	bl	8001ab0 <chSysUnlock>

  return msg;
 8001bda:	9b03      	ldr	r3, [sp, #12]
}
 8001bdc:	4618      	mov	r0, r3
 8001bde:	b005      	add	sp, #20
 8001be0:	f85d fb04 	ldr.w	pc, [sp], #4
 8001be4:	f3af 8000 	nop.w
 8001be8:	f3af 8000 	nop.w
 8001bec:	f3af 8000 	nop.w

08001bf0 <chSemWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 8001bf0:	b500      	push	{lr}
 8001bf2:	b083      	sub	sp, #12
 8001bf4:	9001      	str	r0, [sp, #4]
 8001bf6:	9100      	str	r1, [sp, #0]
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 8001bf8:	9b01      	ldr	r3, [sp, #4]
 8001bfa:	689b      	ldr	r3, [r3, #8]
 8001bfc:	1e5a      	subs	r2, r3, #1
 8001bfe:	9b01      	ldr	r3, [sp, #4]
 8001c00:	609a      	str	r2, [r3, #8]
 8001c02:	9b01      	ldr	r3, [sp, #4]
 8001c04:	689b      	ldr	r3, [r3, #8]
 8001c06:	2b00      	cmp	r3, #0
 8001c08:	da1b      	bge.n	8001c42 <chSemWaitTimeoutS+0x52>
    if (TIME_IMMEDIATE == time) {
 8001c0a:	9b00      	ldr	r3, [sp, #0]
 8001c0c:	2b00      	cmp	r3, #0
 8001c0e:	d107      	bne.n	8001c20 <chSemWaitTimeoutS+0x30>
      sp->s_cnt++;
 8001c10:	9b01      	ldr	r3, [sp, #4]
 8001c12:	689b      	ldr	r3, [r3, #8]
 8001c14:	1c5a      	adds	r2, r3, #1
 8001c16:	9b01      	ldr	r3, [sp, #4]
 8001c18:	609a      	str	r2, [r3, #8]

      return MSG_TIMEOUT;
 8001c1a:	f04f 33ff 	mov.w	r3, #4294967295
 8001c1e:	e011      	b.n	8001c44 <chSemWaitTimeoutS+0x54>
    }
    currp->p_u.wtsemp = sp;
 8001c20:	4b0a      	ldr	r3, [pc, #40]	; (8001c4c <chSemWaitTimeoutS+0x5c>)
 8001c22:	699b      	ldr	r3, [r3, #24]
 8001c24:	9a01      	ldr	r2, [sp, #4]
 8001c26:	621a      	str	r2, [r3, #32]
    sem_insert(currp, &sp->s_queue);
 8001c28:	4b08      	ldr	r3, [pc, #32]	; (8001c4c <chSemWaitTimeoutS+0x5c>)
 8001c2a:	699a      	ldr	r2, [r3, #24]
 8001c2c:	9b01      	ldr	r3, [sp, #4]
 8001c2e:	4610      	mov	r0, r2
 8001c30:	4619      	mov	r1, r3
 8001c32:	f7ff feed 	bl	8001a10 <queue_insert>

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 8001c36:	2005      	movs	r0, #5
 8001c38:	9900      	ldr	r1, [sp, #0]
 8001c3a:	f7ff f841 	bl	8000cc0 <chSchGoSleepTimeoutS>
 8001c3e:	4603      	mov	r3, r0
 8001c40:	e000      	b.n	8001c44 <chSemWaitTimeoutS+0x54>
  }

  return MSG_OK;
 8001c42:	2300      	movs	r3, #0
}
 8001c44:	4618      	mov	r0, r3
 8001c46:	b003      	add	sp, #12
 8001c48:	f85d fb04 	ldr.w	pc, [sp], #4
 8001c4c:	20000d98 	.word	0x20000d98

08001c50 <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @api
 */
void chSemSignal(semaphore_t *sp) {
 8001c50:	b500      	push	{lr}
 8001c52:	b083      	sub	sp, #12
 8001c54:	9001      	str	r0, [sp, #4]
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  chSysLock();
 8001c56:	f7ff ff23 	bl	8001aa0 <chSysLock>
  if (++sp->s_cnt <= (cnt_t)0) {
 8001c5a:	9b01      	ldr	r3, [sp, #4]
 8001c5c:	689b      	ldr	r3, [r3, #8]
 8001c5e:	1c5a      	adds	r2, r3, #1
 8001c60:	9b01      	ldr	r3, [sp, #4]
 8001c62:	609a      	str	r2, [r3, #8]
 8001c64:	9b01      	ldr	r3, [sp, #4]
 8001c66:	689b      	ldr	r3, [r3, #8]
 8001c68:	2b00      	cmp	r3, #0
 8001c6a:	dc08      	bgt.n	8001c7e <chSemSignal+0x2e>
    chSchWakeupS(queue_fifo_remove(&sp->s_queue), MSG_OK);
 8001c6c:	9b01      	ldr	r3, [sp, #4]
 8001c6e:	4618      	mov	r0, r3
 8001c70:	f7ff fee6 	bl	8001a40 <queue_fifo_remove>
 8001c74:	4603      	mov	r3, r0
 8001c76:	4618      	mov	r0, r3
 8001c78:	2100      	movs	r1, #0
 8001c7a:	f7ff f859 	bl	8000d30 <chSchWakeupS>
  }
  chSysUnlock();
 8001c7e:	f7ff ff17 	bl	8001ab0 <chSysUnlock>
}
 8001c82:	b003      	add	sp, #12
 8001c84:	f85d fb04 	ldr.w	pc, [sp], #4
 8001c88:	f3af 8000 	nop.w
 8001c8c:	f3af 8000 	nop.w

08001c90 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
 8001c90:	b500      	push	{lr}
 8001c92:	b085      	sub	sp, #20
 8001c94:	9001      	str	r0, [sp, #4]
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (++sp->s_cnt <= (cnt_t)0) {
 8001c96:	9b01      	ldr	r3, [sp, #4]
 8001c98:	689b      	ldr	r3, [r3, #8]
 8001c9a:	1c5a      	adds	r2, r3, #1
 8001c9c:	9b01      	ldr	r3, [sp, #4]
 8001c9e:	609a      	str	r2, [r3, #8]
 8001ca0:	9b01      	ldr	r3, [sp, #4]
 8001ca2:	689b      	ldr	r3, [r3, #8]
 8001ca4:	2b00      	cmp	r3, #0
 8001ca6:	dc0a      	bgt.n	8001cbe <chSemSignalI+0x2e>
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
 8001ca8:	9b01      	ldr	r3, [sp, #4]
 8001caa:	4618      	mov	r0, r3
 8001cac:	f7ff fec8 	bl	8001a40 <queue_fifo_remove>
 8001cb0:	9003      	str	r0, [sp, #12]
    tp->p_u.rdymsg = MSG_OK;
 8001cb2:	9b03      	ldr	r3, [sp, #12]
 8001cb4:	2200      	movs	r2, #0
 8001cb6:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 8001cb8:	9803      	ldr	r0, [sp, #12]
 8001cba:	f7fe ff71 	bl	8000ba0 <chSchReadyI>
  }
}
 8001cbe:	b005      	add	sp, #20
 8001cc0:	f85d fb04 	ldr.w	pc, [sp], #4
 8001cc4:	f3af 8000 	nop.w
 8001cc8:	f3af 8000 	nop.w
 8001ccc:	f3af 8000 	nop.w

08001cd0 <chSemAddCounterI>:
 * @param[in] n         value to be added to the semaphore counter. The value
 *                      must be positive.
 *
 * @iclass
 */
void chSemAddCounterI(semaphore_t *sp, cnt_t n) {
 8001cd0:	b500      	push	{lr}
 8001cd2:	b083      	sub	sp, #12
 8001cd4:	9001      	str	r0, [sp, #4]
 8001cd6:	9100      	str	r1, [sp, #0]
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8001cd8:	e016      	b.n	8001d08 <chSemAddCounterI+0x38>
    if (++sp->s_cnt <= (cnt_t)0) {
 8001cda:	9b01      	ldr	r3, [sp, #4]
 8001cdc:	689b      	ldr	r3, [r3, #8]
 8001cde:	1c5a      	adds	r2, r3, #1
 8001ce0:	9b01      	ldr	r3, [sp, #4]
 8001ce2:	609a      	str	r2, [r3, #8]
 8001ce4:	9b01      	ldr	r3, [sp, #4]
 8001ce6:	689b      	ldr	r3, [r3, #8]
 8001ce8:	2b00      	cmp	r3, #0
 8001cea:	dc0a      	bgt.n	8001d02 <chSemAddCounterI+0x32>
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
 8001cec:	9b01      	ldr	r3, [sp, #4]
 8001cee:	4618      	mov	r0, r3
 8001cf0:	f7ff fea6 	bl	8001a40 <queue_fifo_remove>
 8001cf4:	4603      	mov	r3, r0
 8001cf6:	4618      	mov	r0, r3
 8001cf8:	f7fe ff52 	bl	8000ba0 <chSchReadyI>
 8001cfc:	4603      	mov	r3, r0
 8001cfe:	2200      	movs	r2, #0
 8001d00:	621a      	str	r2, [r3, #32]
    }
    n--;
 8001d02:	9b00      	ldr	r3, [sp, #0]
 8001d04:	3b01      	subs	r3, #1
 8001d06:	9300      	str	r3, [sp, #0]
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8001d08:	9b00      	ldr	r3, [sp, #0]
 8001d0a:	2b00      	cmp	r3, #0
 8001d0c:	dce5      	bgt.n	8001cda <chSemAddCounterI+0xa>
    if (++sp->s_cnt <= (cnt_t)0) {
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
    }
    n--;
  }
}
 8001d0e:	b003      	add	sp, #12
 8001d10:	f85d fb04 	ldr.w	pc, [sp], #4
 8001d14:	f3af 8000 	nop.w
 8001d18:	f3af 8000 	nop.w
 8001d1c:	f3af 8000 	nop.w

08001d20 <chSemSignalWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
 8001d20:	b500      	push	{lr}
 8001d22:	b085      	sub	sp, #20
 8001d24:	9001      	str	r0, [sp, #4]
 8001d26:	9100      	str	r1, [sp, #0]
              "inconsistent semaphore");
  chDbgAssert(((spw->s_cnt >= (cnt_t)0) && queue_isempty(&spw->s_queue)) ||
              ((spw->s_cnt < (cnt_t)0) && queue_notempty(&spw->s_queue)),
              "inconsistent semaphore");

  chSysLock();
 8001d28:	f7ff feba 	bl	8001aa0 <chSysLock>
  if (++sps->s_cnt <= (cnt_t)0) {
 8001d2c:	9b01      	ldr	r3, [sp, #4]
 8001d2e:	689b      	ldr	r3, [r3, #8]
 8001d30:	1c5a      	adds	r2, r3, #1
 8001d32:	9b01      	ldr	r3, [sp, #4]
 8001d34:	609a      	str	r2, [r3, #8]
 8001d36:	9b01      	ldr	r3, [sp, #4]
 8001d38:	689b      	ldr	r3, [r3, #8]
 8001d3a:	2b00      	cmp	r3, #0
 8001d3c:	dc0a      	bgt.n	8001d54 <chSemSignalWait+0x34>
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
 8001d3e:	9b01      	ldr	r3, [sp, #4]
 8001d40:	4618      	mov	r0, r3
 8001d42:	f7ff fe7d 	bl	8001a40 <queue_fifo_remove>
 8001d46:	4603      	mov	r3, r0
 8001d48:	4618      	mov	r0, r3
 8001d4a:	f7fe ff29 	bl	8000ba0 <chSchReadyI>
 8001d4e:	4603      	mov	r3, r0
 8001d50:	2200      	movs	r2, #0
 8001d52:	621a      	str	r2, [r3, #32]
  }
  if (--spw->s_cnt < (cnt_t)0) {
 8001d54:	9b00      	ldr	r3, [sp, #0]
 8001d56:	689b      	ldr	r3, [r3, #8]
 8001d58:	1e5a      	subs	r2, r3, #1
 8001d5a:	9b00      	ldr	r3, [sp, #0]
 8001d5c:	609a      	str	r2, [r3, #8]
 8001d5e:	9b00      	ldr	r3, [sp, #0]
 8001d60:	689b      	ldr	r3, [r3, #8]
 8001d62:	2b00      	cmp	r3, #0
 8001d64:	da11      	bge.n	8001d8a <chSemSignalWait+0x6a>
    thread_t *ctp = currp;
 8001d66:	4b0e      	ldr	r3, [pc, #56]	; (8001da0 <chSemSignalWait+0x80>)
 8001d68:	699b      	ldr	r3, [r3, #24]
 8001d6a:	9302      	str	r3, [sp, #8]
    sem_insert(ctp, &spw->s_queue);
 8001d6c:	9b00      	ldr	r3, [sp, #0]
 8001d6e:	9802      	ldr	r0, [sp, #8]
 8001d70:	4619      	mov	r1, r3
 8001d72:	f7ff fe4d 	bl	8001a10 <queue_insert>
    ctp->p_u.wtsemp = spw;
 8001d76:	9b02      	ldr	r3, [sp, #8]
 8001d78:	9a00      	ldr	r2, [sp, #0]
 8001d7a:	621a      	str	r2, [r3, #32]
    chSchGoSleepS(CH_STATE_WTSEM);
 8001d7c:	2005      	movs	r0, #5
 8001d7e:	f7fe ff37 	bl	8000bf0 <chSchGoSleepS>
    msg = ctp->p_u.rdymsg;
 8001d82:	9b02      	ldr	r3, [sp, #8]
 8001d84:	6a1b      	ldr	r3, [r3, #32]
 8001d86:	9303      	str	r3, [sp, #12]
 8001d88:	e003      	b.n	8001d92 <chSemSignalWait+0x72>
  }
  else {
    chSchRescheduleS();
 8001d8a:	f7fe fff9 	bl	8000d80 <chSchRescheduleS>
    msg = MSG_OK;
 8001d8e:	2300      	movs	r3, #0
 8001d90:	9303      	str	r3, [sp, #12]
  }
  chSysUnlock();
 8001d92:	f7ff fe8d 	bl	8001ab0 <chSysUnlock>

  return msg;
 8001d96:	9b03      	ldr	r3, [sp, #12]
}
 8001d98:	4618      	mov	r0, r3
 8001d9a:	b005      	add	sp, #20
 8001d9c:	f85d fb04 	ldr.w	pc, [sp], #4
 8001da0:	20000d98 	.word	0x20000d98
 8001da4:	f3af 8000 	nop.w
 8001da8:	f3af 8000 	nop.w
 8001dac:	f3af 8000 	nop.w

08001db0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8001db0:	b082      	sub	sp, #8
 8001db2:	2320      	movs	r3, #32
 8001db4:	9301      	str	r3, [sp, #4]
 8001db6:	9b01      	ldr	r3, [sp, #4]
 8001db8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8001dbc:	b002      	add	sp, #8
 8001dbe:	4770      	bx	lr

08001dc0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8001dc0:	b082      	sub	sp, #8
 8001dc2:	2300      	movs	r3, #0
 8001dc4:	9301      	str	r3, [sp, #4]
 8001dc6:	9b01      	ldr	r3, [sp, #4]
 8001dc8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8001dcc:	b002      	add	sp, #8
 8001dce:	4770      	bx	lr

08001dd0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8001dd0:	b082      	sub	sp, #8
 8001dd2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8001dd4:	9b01      	ldr	r3, [sp, #4]
 8001dd6:	9a01      	ldr	r2, [sp, #4]
 8001dd8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8001dda:	9b01      	ldr	r3, [sp, #4]
 8001ddc:	9a01      	ldr	r2, [sp, #4]
 8001dde:	605a      	str	r2, [r3, #4]
}
 8001de0:	b002      	add	sp, #8
 8001de2:	4770      	bx	lr
 8001de4:	f3af 8000 	nop.w
 8001de8:	f3af 8000 	nop.w
 8001dec:	f3af 8000 	nop.w

08001df0 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8001df0:	b082      	sub	sp, #8
 8001df2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8001df4:	9b01      	ldr	r3, [sp, #4]
 8001df6:	681a      	ldr	r2, [r3, #0]
 8001df8:	9b01      	ldr	r3, [sp, #4]
 8001dfa:	429a      	cmp	r2, r3
 8001dfc:	bf0c      	ite	eq
 8001dfe:	2300      	moveq	r3, #0
 8001e00:	2301      	movne	r3, #1
 8001e02:	b2db      	uxtb	r3, r3
}
 8001e04:	4618      	mov	r0, r3
 8001e06:	b002      	add	sp, #8
 8001e08:	4770      	bx	lr
 8001e0a:	bf00      	nop
 8001e0c:	f3af 8000 	nop.w

08001e10 <queue_prio_insert>:
  tlp->p_next = tp->p_next;

  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 8001e10:	b084      	sub	sp, #16
 8001e12:	9001      	str	r0, [sp, #4]
 8001e14:	9100      	str	r1, [sp, #0]

  thread_t *cp = (thread_t *)tqp;
 8001e16:	9b00      	ldr	r3, [sp, #0]
 8001e18:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 8001e1a:	9b03      	ldr	r3, [sp, #12]
 8001e1c:	681b      	ldr	r3, [r3, #0]
 8001e1e:	9303      	str	r3, [sp, #12]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001e20:	9a03      	ldr	r2, [sp, #12]
 8001e22:	9b00      	ldr	r3, [sp, #0]
 8001e24:	429a      	cmp	r2, r3
 8001e26:	d005      	beq.n	8001e34 <queue_prio_insert+0x24>
 8001e28:	9b03      	ldr	r3, [sp, #12]
 8001e2a:	689a      	ldr	r2, [r3, #8]
 8001e2c:	9b01      	ldr	r3, [sp, #4]
 8001e2e:	689b      	ldr	r3, [r3, #8]
 8001e30:	429a      	cmp	r2, r3
 8001e32:	d2f2      	bcs.n	8001e1a <queue_prio_insert+0xa>
  tp->p_next = cp;
 8001e34:	9b01      	ldr	r3, [sp, #4]
 8001e36:	9a03      	ldr	r2, [sp, #12]
 8001e38:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 8001e3a:	9b03      	ldr	r3, [sp, #12]
 8001e3c:	685a      	ldr	r2, [r3, #4]
 8001e3e:	9b01      	ldr	r3, [sp, #4]
 8001e40:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8001e42:	9b01      	ldr	r3, [sp, #4]
 8001e44:	685b      	ldr	r3, [r3, #4]
 8001e46:	9a01      	ldr	r2, [sp, #4]
 8001e48:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 8001e4a:	9b03      	ldr	r3, [sp, #12]
 8001e4c:	9a01      	ldr	r2, [sp, #4]
 8001e4e:	605a      	str	r2, [r3, #4]
}
 8001e50:	b004      	add	sp, #16
 8001e52:	4770      	bx	lr
 8001e54:	f3af 8000 	nop.w
 8001e58:	f3af 8000 	nop.w
 8001e5c:	f3af 8000 	nop.w

08001e60 <queue_fifo_remove>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8001e60:	b084      	sub	sp, #16
 8001e62:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8001e64:	9b01      	ldr	r3, [sp, #4]
 8001e66:	681b      	ldr	r3, [r3, #0]
 8001e68:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8001e6a:	9b03      	ldr	r3, [sp, #12]
 8001e6c:	681a      	ldr	r2, [r3, #0]
 8001e6e:	9b01      	ldr	r3, [sp, #4]
 8001e70:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001e72:	9b01      	ldr	r3, [sp, #4]
 8001e74:	681b      	ldr	r3, [r3, #0]
 8001e76:	9a01      	ldr	r2, [sp, #4]
 8001e78:	605a      	str	r2, [r3, #4]

  return tp;
 8001e7a:	9b03      	ldr	r3, [sp, #12]
}
 8001e7c:	4618      	mov	r0, r3
 8001e7e:	b004      	add	sp, #16
 8001e80:	4770      	bx	lr
 8001e82:	bf00      	nop
 8001e84:	f3af 8000 	nop.w
 8001e88:	f3af 8000 	nop.w
 8001e8c:	f3af 8000 	nop.w

08001e90 <queue_dequeue>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 8001e90:	b082      	sub	sp, #8
 8001e92:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
 8001e94:	9b01      	ldr	r3, [sp, #4]
 8001e96:	685b      	ldr	r3, [r3, #4]
 8001e98:	9a01      	ldr	r2, [sp, #4]
 8001e9a:	6812      	ldr	r2, [r2, #0]
 8001e9c:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8001e9e:	9b01      	ldr	r3, [sp, #4]
 8001ea0:	681b      	ldr	r3, [r3, #0]
 8001ea2:	9a01      	ldr	r2, [sp, #4]
 8001ea4:	6852      	ldr	r2, [r2, #4]
 8001ea6:	605a      	str	r2, [r3, #4]

  return tp;
 8001ea8:	9b01      	ldr	r3, [sp, #4]
}
 8001eaa:	4618      	mov	r0, r3
 8001eac:	b002      	add	sp, #8
 8001eae:	4770      	bx	lr

08001eb0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001eb0:	b508      	push	{r3, lr}

  port_lock();
 8001eb2:	f7ff ff7d 	bl	8001db0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001eb6:	bd08      	pop	{r3, pc}
 8001eb8:	f3af 8000 	nop.w
 8001ebc:	f3af 8000 	nop.w

08001ec0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001ec0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001ec2:	f7ff ff7d 	bl	8001dc0 <port_unlock>
}
 8001ec6:	bd08      	pop	{r3, pc}
 8001ec8:	f3af 8000 	nop.w
 8001ecc:	f3af 8000 	nop.w

08001ed0 <chMtxQueueNotEmptyS>:
 * @return              The mutex queue status.
 *
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
 8001ed0:	b500      	push	{lr}
 8001ed2:	b083      	sub	sp, #12
 8001ed4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();

  return queue_notempty(&mp->m_queue);
 8001ed6:	9b01      	ldr	r3, [sp, #4]
 8001ed8:	4618      	mov	r0, r3
 8001eda:	f7ff ff89 	bl	8001df0 <queue_notempty>
 8001ede:	4603      	mov	r3, r0
}
 8001ee0:	4618      	mov	r0, r3
 8001ee2:	b003      	add	sp, #12
 8001ee4:	f85d fb04 	ldr.w	pc, [sp], #4
 8001ee8:	f3af 8000 	nop.w
 8001eec:	f3af 8000 	nop.w

08001ef0 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8001ef0:	b500      	push	{lr}
 8001ef2:	b083      	sub	sp, #12
 8001ef4:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
 8001ef6:	9b01      	ldr	r3, [sp, #4]
 8001ef8:	4618      	mov	r0, r3
 8001efa:	f7ff ff69 	bl	8001dd0 <queue_init>
  mp->m_owner = NULL;
 8001efe:	9b01      	ldr	r3, [sp, #4]
 8001f00:	2200      	movs	r2, #0
 8001f02:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->m_cnt = (cnt_t)0;
#endif
}
 8001f04:	b003      	add	sp, #12
 8001f06:	f85d fb04 	ldr.w	pc, [sp], #4
 8001f0a:	bf00      	nop
 8001f0c:	f3af 8000 	nop.w

08001f10 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 8001f10:	b500      	push	{lr}
 8001f12:	b083      	sub	sp, #12
 8001f14:	9001      	str	r0, [sp, #4]

  chSysLock();
 8001f16:	f7ff ffcb 	bl	8001eb0 <chSysLock>
  chMtxLockS(mp);
 8001f1a:	9801      	ldr	r0, [sp, #4]
 8001f1c:	f000 f808 	bl	8001f30 <chMtxLockS>
  chSysUnlock();
 8001f20:	f7ff ffce 	bl	8001ec0 <chSysUnlock>
}
 8001f24:	b003      	add	sp, #12
 8001f26:	f85d fb04 	ldr.w	pc, [sp], #4
 8001f2a:	bf00      	nop
 8001f2c:	f3af 8000 	nop.w

08001f30 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8001f30:	b500      	push	{lr}
 8001f32:	b085      	sub	sp, #20
 8001f34:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8001f36:	4b2d      	ldr	r3, [pc, #180]	; (8001fec <chMtxLockS+0xbc>)
 8001f38:	699b      	ldr	r3, [r3, #24]
 8001f3a:	9302      	str	r3, [sp, #8]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 8001f3c:	9b01      	ldr	r3, [sp, #4]
 8001f3e:	689b      	ldr	r3, [r3, #8]
 8001f40:	2b00      	cmp	r3, #0
 8001f42:	d045      	beq.n	8001fd0 <chMtxLockS+0xa0>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;
 8001f44:	9b01      	ldr	r3, [sp, #4]
 8001f46:	689b      	ldr	r3, [r3, #8]
 8001f48:	9303      	str	r3, [sp, #12]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 8001f4a:	e02f      	b.n	8001fac <chMtxLockS+0x7c>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
 8001f4c:	9b02      	ldr	r3, [sp, #8]
 8001f4e:	689a      	ldr	r2, [r3, #8]
 8001f50:	9b03      	ldr	r3, [sp, #12]
 8001f52:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 8001f54:	9b03      	ldr	r3, [sp, #12]
 8001f56:	7f1b      	ldrb	r3, [r3, #28]
 8001f58:	2b06      	cmp	r3, #6
 8001f5a:	d004      	beq.n	8001f66 <chMtxLockS+0x36>
 8001f5c:	2b07      	cmp	r3, #7
 8001f5e:	d011      	beq.n	8001f84 <chMtxLockS+0x54>
 8001f60:	2b00      	cmp	r3, #0
 8001f62:	d01a      	beq.n	8001f9a <chMtxLockS+0x6a>
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
          break;
        default:
          /* Nothing to do for other states.*/
          break;
 8001f64:	e021      	b.n	8001faa <chMtxLockS+0x7a>

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8001f66:	9803      	ldr	r0, [sp, #12]
 8001f68:	f7ff ff92 	bl	8001e90 <queue_dequeue>
 8001f6c:	4602      	mov	r2, r0
 8001f6e:	9b03      	ldr	r3, [sp, #12]
 8001f70:	6a1b      	ldr	r3, [r3, #32]
 8001f72:	4610      	mov	r0, r2
 8001f74:	4619      	mov	r1, r3
 8001f76:	f7ff ff4b 	bl	8001e10 <queue_prio_insert>
          tp = tp->p_u.wtmtxp->m_owner;
 8001f7a:	9b03      	ldr	r3, [sp, #12]
 8001f7c:	6a1b      	ldr	r3, [r3, #32]
 8001f7e:	689b      	ldr	r3, [r3, #8]
 8001f80:	9303      	str	r3, [sp, #12]
          /*lint -e{9042} [16.1] Continues the while.*/
          continue;
 8001f82:	e013      	b.n	8001fac <chMtxLockS+0x7c>
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8001f84:	9803      	ldr	r0, [sp, #12]
 8001f86:	f7ff ff83 	bl	8001e90 <queue_dequeue>
 8001f8a:	4602      	mov	r2, r0
 8001f8c:	9b03      	ldr	r3, [sp, #12]
 8001f8e:	6a1b      	ldr	r3, [r3, #32]
 8001f90:	4610      	mov	r0, r2
 8001f92:	4619      	mov	r1, r3
 8001f94:	f7ff ff3c 	bl	8001e10 <queue_prio_insert>
          break;
 8001f98:	e007      	b.n	8001faa <chMtxLockS+0x7a>
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 8001f9a:	9803      	ldr	r0, [sp, #12]
 8001f9c:	f7ff ff78 	bl	8001e90 <queue_dequeue>
 8001fa0:	4603      	mov	r3, r0
 8001fa2:	4618      	mov	r0, r3
 8001fa4:	f7fe fdfc 	bl	8000ba0 <chSchReadyI>
          break;
 8001fa8:	bf00      	nop
        default:
          /* Nothing to do for other states.*/
          break;
        }
        break;
 8001faa:	e005      	b.n	8001fb8 <chMtxLockS+0x88>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 8001fac:	9b03      	ldr	r3, [sp, #12]
 8001fae:	689a      	ldr	r2, [r3, #8]
 8001fb0:	9b02      	ldr	r3, [sp, #8]
 8001fb2:	689b      	ldr	r3, [r3, #8]
 8001fb4:	429a      	cmp	r2, r3
 8001fb6:	d3c9      	bcc.n	8001f4c <chMtxLockS+0x1c>
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
 8001fb8:	9b01      	ldr	r3, [sp, #4]
 8001fba:	9802      	ldr	r0, [sp, #8]
 8001fbc:	4619      	mov	r1, r3
 8001fbe:	f7ff ff27 	bl	8001e10 <queue_prio_insert>
      ctp->p_u.wtmtxp = mp;
 8001fc2:	9b02      	ldr	r3, [sp, #8]
 8001fc4:	9a01      	ldr	r2, [sp, #4]
 8001fc6:	621a      	str	r2, [r3, #32]
      chSchGoSleepS(CH_STATE_WTMTX);
 8001fc8:	2006      	movs	r0, #6
 8001fca:	f7fe fe11 	bl	8000bf0 <chSchGoSleepS>
 8001fce:	e009      	b.n	8001fe4 <chMtxLockS+0xb4>
    chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 8001fd0:	9b01      	ldr	r3, [sp, #4]
 8001fd2:	9a02      	ldr	r2, [sp, #8]
 8001fd4:	609a      	str	r2, [r3, #8]
    mp->m_next = ctp->p_mtxlist;
 8001fd6:	9b02      	ldr	r3, [sp, #8]
 8001fd8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001fda:	9b01      	ldr	r3, [sp, #4]
 8001fdc:	60da      	str	r2, [r3, #12]
    ctp->p_mtxlist = mp;
 8001fde:	9b02      	ldr	r3, [sp, #8]
 8001fe0:	9a01      	ldr	r2, [sp, #4]
 8001fe2:	639a      	str	r2, [r3, #56]	; 0x38
  }
}
 8001fe4:	b005      	add	sp, #20
 8001fe6:	f85d fb04 	ldr.w	pc, [sp], #4
 8001fea:	bf00      	nop
 8001fec:	20000d98 	.word	0x20000d98

08001ff0 <chMtxTryLock>:
 * @retval true         if the mutex has been successfully acquired
 * @retval false        if the lock attempt failed.
 *
 * @api
 */
bool chMtxTryLock(mutex_t *mp) {
 8001ff0:	b500      	push	{lr}
 8001ff2:	b085      	sub	sp, #20
 8001ff4:	9001      	str	r0, [sp, #4]
  bool b;

  chSysLock();
 8001ff6:	f7ff ff5b 	bl	8001eb0 <chSysLock>
  b = chMtxTryLockS(mp);
 8001ffa:	9801      	ldr	r0, [sp, #4]
 8001ffc:	f000 f810 	bl	8002020 <chMtxTryLockS>
 8002000:	4603      	mov	r3, r0
 8002002:	f88d 300f 	strb.w	r3, [sp, #15]
  chSysUnlock();
 8002006:	f7ff ff5b 	bl	8001ec0 <chSysUnlock>

  return b;
 800200a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 800200e:	4618      	mov	r0, r3
 8002010:	b005      	add	sp, #20
 8002012:	f85d fb04 	ldr.w	pc, [sp], #4
 8002016:	bf00      	nop
 8002018:	f3af 8000 	nop.w
 800201c:	f3af 8000 	nop.w

08002020 <chMtxTryLockS>:
 * @retval true         if the mutex has been successfully acquired
 * @retval false        if the lock attempt failed.
 *
 * @sclass
 */
bool chMtxTryLockS(mutex_t *mp) {
 8002020:	b082      	sub	sp, #8
 8002022:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->m_owner != NULL) {
 8002024:	9b01      	ldr	r3, [sp, #4]
 8002026:	689b      	ldr	r3, [r3, #8]
 8002028:	2b00      	cmp	r3, #0
 800202a:	d001      	beq.n	8002030 <chMtxTryLockS+0x10>
    if (mp->m_owner == currp) {
      mp->m_cnt++;
      return true;
    }
#endif
    return false;
 800202c:	2300      	movs	r3, #0
 800202e:	e00d      	b.n	800204c <chMtxTryLockS+0x2c>

  chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
 8002030:	4b08      	ldr	r3, [pc, #32]	; (8002054 <chMtxTryLockS+0x34>)
 8002032:	699a      	ldr	r2, [r3, #24]
 8002034:	9b01      	ldr	r3, [sp, #4]
 8002036:	609a      	str	r2, [r3, #8]
  mp->m_next = currp->p_mtxlist;
 8002038:	4b06      	ldr	r3, [pc, #24]	; (8002054 <chMtxTryLockS+0x34>)
 800203a:	699b      	ldr	r3, [r3, #24]
 800203c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800203e:	9b01      	ldr	r3, [sp, #4]
 8002040:	60da      	str	r2, [r3, #12]
  currp->p_mtxlist = mp;
 8002042:	4b04      	ldr	r3, [pc, #16]	; (8002054 <chMtxTryLockS+0x34>)
 8002044:	699b      	ldr	r3, [r3, #24]
 8002046:	9a01      	ldr	r2, [sp, #4]
 8002048:	639a      	str	r2, [r3, #56]	; 0x38
  return true;
 800204a:	2301      	movs	r3, #1
}
 800204c:	4618      	mov	r0, r3
 800204e:	b002      	add	sp, #8
 8002050:	4770      	bx	lr
 8002052:	bf00      	nop
 8002054:	20000d98 	.word	0x20000d98
 8002058:	f3af 8000 	nop.w
 800205c:	f3af 8000 	nop.w

08002060 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8002060:	b500      	push	{lr}
 8002062:	b087      	sub	sp, #28
 8002064:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002066:	4b26      	ldr	r3, [pc, #152]	; (8002100 <chMtxUnlock+0xa0>)
 8002068:	699b      	ldr	r3, [r3, #24]
 800206a:	9303      	str	r3, [sp, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);

  chSysLock();
 800206c:	f7ff ff20 	bl	8001eb0 <chSysLock>
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 8002070:	9b01      	ldr	r3, [sp, #4]
 8002072:	68da      	ldr	r2, [r3, #12]
 8002074:	9b03      	ldr	r3, [sp, #12]
 8002076:	639a      	str	r2, [r3, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8002078:	9801      	ldr	r0, [sp, #4]
 800207a:	f7ff ff29 	bl	8001ed0 <chMtxQueueNotEmptyS>
 800207e:	4603      	mov	r3, r0
 8002080:	2b00      	cmp	r3, #0
 8002082:	d034      	beq.n	80020ee <chMtxUnlock+0x8e>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 8002084:	9b03      	ldr	r3, [sp, #12]
 8002086:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002088:	9304      	str	r3, [sp, #16]
      lmp = ctp->p_mtxlist;
 800208a:	9b03      	ldr	r3, [sp, #12]
 800208c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800208e:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 8002090:	e012      	b.n	80020b8 <chMtxUnlock+0x58>
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8002092:	9805      	ldr	r0, [sp, #20]
 8002094:	f7ff ff1c 	bl	8001ed0 <chMtxQueueNotEmptyS>
 8002098:	4603      	mov	r3, r0
 800209a:	2b00      	cmp	r3, #0
 800209c:	d009      	beq.n	80020b2 <chMtxUnlock+0x52>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 800209e:	9b05      	ldr	r3, [sp, #20]
 80020a0:	681b      	ldr	r3, [r3, #0]
 80020a2:	689a      	ldr	r2, [r3, #8]
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80020a4:	9b04      	ldr	r3, [sp, #16]
 80020a6:	429a      	cmp	r2, r3
 80020a8:	d903      	bls.n	80020b2 <chMtxUnlock+0x52>
            (lmp->m_queue.p_next->p_prio > newprio)) {
          newprio = lmp->m_queue.p_next->p_prio;
 80020aa:	9b05      	ldr	r3, [sp, #20]
 80020ac:	681b      	ldr	r3, [r3, #0]
 80020ae:	689b      	ldr	r3, [r3, #8]
 80020b0:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->m_next;
 80020b2:	9b05      	ldr	r3, [sp, #20]
 80020b4:	68db      	ldr	r3, [r3, #12]
 80020b6:	9305      	str	r3, [sp, #20]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 80020b8:	9b05      	ldr	r3, [sp, #20]
 80020ba:	2b00      	cmp	r3, #0
 80020bc:	d1e9      	bne.n	8002092 <chMtxUnlock+0x32>
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 80020be:	9b03      	ldr	r3, [sp, #12]
 80020c0:	9a04      	ldr	r2, [sp, #16]
 80020c2:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
 80020c4:	9b01      	ldr	r3, [sp, #4]
 80020c6:	4618      	mov	r0, r3
 80020c8:	f7ff feca 	bl	8001e60 <queue_fifo_remove>
 80020cc:	9002      	str	r0, [sp, #8]
      mp->m_owner = tp;
 80020ce:	9b01      	ldr	r3, [sp, #4]
 80020d0:	9a02      	ldr	r2, [sp, #8]
 80020d2:	609a      	str	r2, [r3, #8]
      mp->m_next = tp->p_mtxlist;
 80020d4:	9b02      	ldr	r3, [sp, #8]
 80020d6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80020d8:	9b01      	ldr	r3, [sp, #4]
 80020da:	60da      	str	r2, [r3, #12]
      tp->p_mtxlist = mp;
 80020dc:	9b02      	ldr	r3, [sp, #8]
 80020de:	9a01      	ldr	r2, [sp, #4]
 80020e0:	639a      	str	r2, [r3, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 80020e2:	9802      	ldr	r0, [sp, #8]
 80020e4:	f7fe fd5c 	bl	8000ba0 <chSchReadyI>
      chSchRescheduleS();
 80020e8:	f7fe fe4a 	bl	8000d80 <chSchRescheduleS>
 80020ec:	e002      	b.n	80020f4 <chMtxUnlock+0x94>
    }
    else {
      mp->m_owner = NULL;
 80020ee:	9b01      	ldr	r3, [sp, #4]
 80020f0:	2200      	movs	r2, #0
 80020f2:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
 80020f4:	f7ff fee4 	bl	8001ec0 <chSysUnlock>
}
 80020f8:	b007      	add	sp, #28
 80020fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80020fe:	bf00      	nop
 8002100:	20000d98 	.word	0x20000d98
 8002104:	f3af 8000 	nop.w
 8002108:	f3af 8000 	nop.w
 800210c:	f3af 8000 	nop.w

08002110 <chMtxUnlockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 8002110:	b500      	push	{lr}
 8002112:	b087      	sub	sp, #28
 8002114:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002116:	4b23      	ldr	r3, [pc, #140]	; (80021a4 <chMtxUnlockS+0x94>)
 8002118:	699b      	ldr	r3, [r3, #24]
 800211a:	9303      	str	r3, [sp, #12]
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 800211c:	9b01      	ldr	r3, [sp, #4]
 800211e:	68da      	ldr	r2, [r3, #12]
 8002120:	9b03      	ldr	r3, [sp, #12]
 8002122:	639a      	str	r2, [r3, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8002124:	9801      	ldr	r0, [sp, #4]
 8002126:	f7ff fed3 	bl	8001ed0 <chMtxQueueNotEmptyS>
 800212a:	4603      	mov	r3, r0
 800212c:	2b00      	cmp	r3, #0
 800212e:	d032      	beq.n	8002196 <chMtxUnlockS+0x86>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 8002130:	9b03      	ldr	r3, [sp, #12]
 8002132:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002134:	9304      	str	r3, [sp, #16]
      lmp = ctp->p_mtxlist;
 8002136:	9b03      	ldr	r3, [sp, #12]
 8002138:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800213a:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 800213c:	e012      	b.n	8002164 <chMtxUnlockS+0x54>
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800213e:	9805      	ldr	r0, [sp, #20]
 8002140:	f7ff fec6 	bl	8001ed0 <chMtxQueueNotEmptyS>
 8002144:	4603      	mov	r3, r0
 8002146:	2b00      	cmp	r3, #0
 8002148:	d009      	beq.n	800215e <chMtxUnlockS+0x4e>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 800214a:	9b05      	ldr	r3, [sp, #20]
 800214c:	681b      	ldr	r3, [r3, #0]
 800214e:	689a      	ldr	r2, [r3, #8]
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8002150:	9b04      	ldr	r3, [sp, #16]
 8002152:	429a      	cmp	r2, r3
 8002154:	d903      	bls.n	800215e <chMtxUnlockS+0x4e>
            (lmp->m_queue.p_next->p_prio > newprio)) {
          newprio = lmp->m_queue.p_next->p_prio;
 8002156:	9b05      	ldr	r3, [sp, #20]
 8002158:	681b      	ldr	r3, [r3, #0]
 800215a:	689b      	ldr	r3, [r3, #8]
 800215c:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->m_next;
 800215e:	9b05      	ldr	r3, [sp, #20]
 8002160:	68db      	ldr	r3, [r3, #12]
 8002162:	9305      	str	r3, [sp, #20]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8002164:	9b05      	ldr	r3, [sp, #20]
 8002166:	2b00      	cmp	r3, #0
 8002168:	d1e9      	bne.n	800213e <chMtxUnlockS+0x2e>
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 800216a:	9b03      	ldr	r3, [sp, #12]
 800216c:	9a04      	ldr	r2, [sp, #16]
 800216e:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
 8002170:	9b01      	ldr	r3, [sp, #4]
 8002172:	4618      	mov	r0, r3
 8002174:	f7ff fe74 	bl	8001e60 <queue_fifo_remove>
 8002178:	9002      	str	r0, [sp, #8]
      mp->m_owner = tp;
 800217a:	9b01      	ldr	r3, [sp, #4]
 800217c:	9a02      	ldr	r2, [sp, #8]
 800217e:	609a      	str	r2, [r3, #8]
      mp->m_next = tp->p_mtxlist;
 8002180:	9b02      	ldr	r3, [sp, #8]
 8002182:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002184:	9b01      	ldr	r3, [sp, #4]
 8002186:	60da      	str	r2, [r3, #12]
      tp->p_mtxlist = mp;
 8002188:	9b02      	ldr	r3, [sp, #8]
 800218a:	9a01      	ldr	r2, [sp, #4]
 800218c:	639a      	str	r2, [r3, #56]	; 0x38
      (void) chSchReadyI(tp);
 800218e:	9802      	ldr	r0, [sp, #8]
 8002190:	f7fe fd06 	bl	8000ba0 <chSchReadyI>
 8002194:	e002      	b.n	800219c <chMtxUnlockS+0x8c>
    }
    else {
      mp->m_owner = NULL;
 8002196:	9b01      	ldr	r3, [sp, #4]
 8002198:	2200      	movs	r2, #0
 800219a:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 800219c:	b007      	add	sp, #28
 800219e:	f85d fb04 	ldr.w	pc, [sp], #4
 80021a2:	bf00      	nop
 80021a4:	20000d98 	.word	0x20000d98
 80021a8:	f3af 8000 	nop.w
 80021ac:	f3af 8000 	nop.w

080021b0 <chMtxUnlockAll>:
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
 80021b0:	b500      	push	{lr}
 80021b2:	b085      	sub	sp, #20
  thread_t *ctp = currp;
 80021b4:	4b1d      	ldr	r3, [pc, #116]	; (800222c <chMtxUnlockAll+0x7c>)
 80021b6:	699b      	ldr	r3, [r3, #24]
 80021b8:	9303      	str	r3, [sp, #12]

  chSysLock();
 80021ba:	f7ff fe79 	bl	8001eb0 <chSysLock>
  if (ctp->p_mtxlist != NULL) {
 80021be:	9b03      	ldr	r3, [sp, #12]
 80021c0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80021c2:	2b00      	cmp	r3, #0
 80021c4:	d02c      	beq.n	8002220 <chMtxUnlockAll+0x70>
    do {
      mutex_t *mp = ctp->p_mtxlist;
 80021c6:	9b03      	ldr	r3, [sp, #12]
 80021c8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80021ca:	9302      	str	r3, [sp, #8]
      ctp->p_mtxlist = mp->m_next;
 80021cc:	9b02      	ldr	r3, [sp, #8]
 80021ce:	68da      	ldr	r2, [r3, #12]
 80021d0:	9b03      	ldr	r3, [sp, #12]
 80021d2:	639a      	str	r2, [r3, #56]	; 0x38
      if (chMtxQueueNotEmptyS(mp)) {
 80021d4:	9802      	ldr	r0, [sp, #8]
 80021d6:	f7ff fe7b 	bl	8001ed0 <chMtxQueueNotEmptyS>
 80021da:	4603      	mov	r3, r0
 80021dc:	2b00      	cmp	r3, #0
 80021de:	d012      	beq.n	8002206 <chMtxUnlockAll+0x56>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->m_queue);
 80021e0:	9b02      	ldr	r3, [sp, #8]
 80021e2:	4618      	mov	r0, r3
 80021e4:	f7ff fe3c 	bl	8001e60 <queue_fifo_remove>
 80021e8:	9001      	str	r0, [sp, #4]
        mp->m_owner = tp;
 80021ea:	9b02      	ldr	r3, [sp, #8]
 80021ec:	9a01      	ldr	r2, [sp, #4]
 80021ee:	609a      	str	r2, [r3, #8]
        mp->m_next = tp->p_mtxlist;
 80021f0:	9b01      	ldr	r3, [sp, #4]
 80021f2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80021f4:	9b02      	ldr	r3, [sp, #8]
 80021f6:	60da      	str	r2, [r3, #12]
        tp->p_mtxlist = mp;
 80021f8:	9b01      	ldr	r3, [sp, #4]
 80021fa:	9a02      	ldr	r2, [sp, #8]
 80021fc:	639a      	str	r2, [r3, #56]	; 0x38
        (void) chSchReadyI(tp);
 80021fe:	9801      	ldr	r0, [sp, #4]
 8002200:	f7fe fcce 	bl	8000ba0 <chSchReadyI>
 8002204:	e002      	b.n	800220c <chMtxUnlockAll+0x5c>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)0;
#endif
        mp->m_owner = NULL;
 8002206:	9b02      	ldr	r3, [sp, #8]
 8002208:	2200      	movs	r2, #0
 800220a:	609a      	str	r2, [r3, #8]
      }
    } while (ctp->p_mtxlist != NULL);
 800220c:	9b03      	ldr	r3, [sp, #12]
 800220e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002210:	2b00      	cmp	r3, #0
 8002212:	d1d8      	bne.n	80021c6 <chMtxUnlockAll+0x16>
    ctp->p_prio = ctp->p_realprio;
 8002214:	9b03      	ldr	r3, [sp, #12]
 8002216:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8002218:	9b03      	ldr	r3, [sp, #12]
 800221a:	609a      	str	r2, [r3, #8]
    chSchRescheduleS();
 800221c:	f7fe fdb0 	bl	8000d80 <chSchRescheduleS>
  }
  chSysUnlock();
 8002220:	f7ff fe4e 	bl	8001ec0 <chSysUnlock>
}
 8002224:	b005      	add	sp, #20
 8002226:	f85d fb04 	ldr.w	pc, [sp], #4
 800222a:	bf00      	nop
 800222c:	20000d98 	.word	0x20000d98

08002230 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002230:	b082      	sub	sp, #8
 8002232:	2320      	movs	r3, #32
 8002234:	9301      	str	r3, [sp, #4]
 8002236:	9b01      	ldr	r3, [sp, #4]
 8002238:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800223c:	b002      	add	sp, #8
 800223e:	4770      	bx	lr

08002240 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002240:	b082      	sub	sp, #8
 8002242:	2300      	movs	r3, #0
 8002244:	9301      	str	r3, [sp, #4]
 8002246:	9b01      	ldr	r3, [sp, #4]
 8002248:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800224c:	b002      	add	sp, #8
 800224e:	4770      	bx	lr

08002250 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8002250:	b082      	sub	sp, #8
 8002252:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8002254:	9b01      	ldr	r3, [sp, #4]
 8002256:	9a01      	ldr	r2, [sp, #4]
 8002258:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800225a:	9b01      	ldr	r3, [sp, #4]
 800225c:	9a01      	ldr	r2, [sp, #4]
 800225e:	605a      	str	r2, [r3, #4]
}
 8002260:	b002      	add	sp, #8
 8002262:	4770      	bx	lr
 8002264:	f3af 8000 	nop.w
 8002268:	f3af 8000 	nop.w
 800226c:	f3af 8000 	nop.w

08002270 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8002270:	b082      	sub	sp, #8
 8002272:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8002274:	9b01      	ldr	r3, [sp, #4]
 8002276:	681a      	ldr	r2, [r3, #0]
 8002278:	9b01      	ldr	r3, [sp, #4]
 800227a:	429a      	cmp	r2, r3
 800227c:	bf0c      	ite	eq
 800227e:	2300      	moveq	r3, #0
 8002280:	2301      	movne	r3, #1
 8002282:	b2db      	uxtb	r3, r3
}
 8002284:	4618      	mov	r0, r3
 8002286:	b002      	add	sp, #8
 8002288:	4770      	bx	lr
 800228a:	bf00      	nop
 800228c:	f3af 8000 	nop.w

08002290 <queue_prio_insert>:
  tlp->p_next = tp->p_next;

  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 8002290:	b084      	sub	sp, #16
 8002292:	9001      	str	r0, [sp, #4]
 8002294:	9100      	str	r1, [sp, #0]

  thread_t *cp = (thread_t *)tqp;
 8002296:	9b00      	ldr	r3, [sp, #0]
 8002298:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 800229a:	9b03      	ldr	r3, [sp, #12]
 800229c:	681b      	ldr	r3, [r3, #0]
 800229e:	9303      	str	r3, [sp, #12]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 80022a0:	9a03      	ldr	r2, [sp, #12]
 80022a2:	9b00      	ldr	r3, [sp, #0]
 80022a4:	429a      	cmp	r2, r3
 80022a6:	d005      	beq.n	80022b4 <queue_prio_insert+0x24>
 80022a8:	9b03      	ldr	r3, [sp, #12]
 80022aa:	689a      	ldr	r2, [r3, #8]
 80022ac:	9b01      	ldr	r3, [sp, #4]
 80022ae:	689b      	ldr	r3, [r3, #8]
 80022b0:	429a      	cmp	r2, r3
 80022b2:	d2f2      	bcs.n	800229a <queue_prio_insert+0xa>
  tp->p_next = cp;
 80022b4:	9b01      	ldr	r3, [sp, #4]
 80022b6:	9a03      	ldr	r2, [sp, #12]
 80022b8:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 80022ba:	9b03      	ldr	r3, [sp, #12]
 80022bc:	685a      	ldr	r2, [r3, #4]
 80022be:	9b01      	ldr	r3, [sp, #4]
 80022c0:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 80022c2:	9b01      	ldr	r3, [sp, #4]
 80022c4:	685b      	ldr	r3, [r3, #4]
 80022c6:	9a01      	ldr	r2, [sp, #4]
 80022c8:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 80022ca:	9b03      	ldr	r3, [sp, #12]
 80022cc:	9a01      	ldr	r2, [sp, #4]
 80022ce:	605a      	str	r2, [r3, #4]
}
 80022d0:	b004      	add	sp, #16
 80022d2:	4770      	bx	lr
 80022d4:	f3af 8000 	nop.w
 80022d8:	f3af 8000 	nop.w
 80022dc:	f3af 8000 	nop.w

080022e0 <queue_fifo_remove>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 80022e0:	b084      	sub	sp, #16
 80022e2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 80022e4:	9b01      	ldr	r3, [sp, #4]
 80022e6:	681b      	ldr	r3, [r3, #0]
 80022e8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 80022ea:	9b03      	ldr	r3, [sp, #12]
 80022ec:	681a      	ldr	r2, [r3, #0]
 80022ee:	9b01      	ldr	r3, [sp, #4]
 80022f0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80022f2:	9b01      	ldr	r3, [sp, #4]
 80022f4:	681b      	ldr	r3, [r3, #0]
 80022f6:	9a01      	ldr	r2, [sp, #4]
 80022f8:	605a      	str	r2, [r3, #4]

  return tp;
 80022fa:	9b03      	ldr	r3, [sp, #12]
}
 80022fc:	4618      	mov	r0, r3
 80022fe:	b004      	add	sp, #16
 8002300:	4770      	bx	lr
 8002302:	bf00      	nop
 8002304:	f3af 8000 	nop.w
 8002308:	f3af 8000 	nop.w
 800230c:	f3af 8000 	nop.w

08002310 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8002310:	b508      	push	{r3, lr}

  port_lock();
 8002312:	f7ff ff8d 	bl	8002230 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002316:	bd08      	pop	{r3, pc}
 8002318:	f3af 8000 	nop.w
 800231c:	f3af 8000 	nop.w

08002320 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002320:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8002322:	f7ff ff8d 	bl	8002240 <port_unlock>
}
 8002326:	bd08      	pop	{r3, pc}
 8002328:	f3af 8000 	nop.w
 800232c:	f3af 8000 	nop.w

08002330 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002330:	4b01      	ldr	r3, [pc, #4]	; (8002338 <chThdGetSelfX+0x8>)
 8002332:	699b      	ldr	r3, [r3, #24]
}
 8002334:	4618      	mov	r0, r3
 8002336:	4770      	bx	lr
 8002338:	20000d98 	.word	0x20000d98
 800233c:	f3af 8000 	nop.w

08002340 <chMtxGetNextMutexS>:
 * @return              A pointer to the next mutex in the stack.
 * @retval NULL         if the stack is empty.
 *
 * @sclass
 */
static inline mutex_t *chMtxGetNextMutexS(void) {
 8002340:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_mtxlist;
 8002342:	f7ff fff5 	bl	8002330 <chThdGetSelfX>
 8002346:	4603      	mov	r3, r0
 8002348:	6b9b      	ldr	r3, [r3, #56]	; 0x38
}
 800234a:	4618      	mov	r0, r3
 800234c:	bd08      	pop	{r3, pc}
 800234e:	bf00      	nop

08002350 <chCondObjectInit>:
 *
 * @param[out] cp       pointer to a @p condition_variable_t structure
 *
 * @init
 */
void chCondObjectInit(condition_variable_t *cp) {
 8002350:	b500      	push	{lr}
 8002352:	b083      	sub	sp, #12
 8002354:	9001      	str	r0, [sp, #4]

  chDbgCheck(cp != NULL);

  queue_init(&cp->c_queue);
 8002356:	9b01      	ldr	r3, [sp, #4]
 8002358:	4618      	mov	r0, r3
 800235a:	f7ff ff79 	bl	8002250 <queue_init>
}
 800235e:	b003      	add	sp, #12
 8002360:	f85d fb04 	ldr.w	pc, [sp], #4
 8002364:	f3af 8000 	nop.w
 8002368:	f3af 8000 	nop.w
 800236c:	f3af 8000 	nop.w

08002370 <chCondSignal>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondSignal(condition_variable_t *cp) {
 8002370:	b500      	push	{lr}
 8002372:	b083      	sub	sp, #12
 8002374:	9001      	str	r0, [sp, #4]

  chDbgCheck(cp != NULL);

  chSysLock();
 8002376:	f7ff ffcb 	bl	8002310 <chSysLock>
  if (queue_notempty(&cp->c_queue)) {
 800237a:	9b01      	ldr	r3, [sp, #4]
 800237c:	4618      	mov	r0, r3
 800237e:	f7ff ff77 	bl	8002270 <queue_notempty>
 8002382:	4603      	mov	r3, r0
 8002384:	2b00      	cmp	r3, #0
 8002386:	d008      	beq.n	800239a <chCondSignal+0x2a>
    chSchWakeupS(queue_fifo_remove(&cp->c_queue), MSG_OK);
 8002388:	9b01      	ldr	r3, [sp, #4]
 800238a:	4618      	mov	r0, r3
 800238c:	f7ff ffa8 	bl	80022e0 <queue_fifo_remove>
 8002390:	4603      	mov	r3, r0
 8002392:	4618      	mov	r0, r3
 8002394:	2100      	movs	r1, #0
 8002396:	f7fe fccb 	bl	8000d30 <chSchWakeupS>
  }
  chSysUnlock();
 800239a:	f7ff ffc1 	bl	8002320 <chSysUnlock>
}
 800239e:	b003      	add	sp, #12
 80023a0:	f85d fb04 	ldr.w	pc, [sp], #4
 80023a4:	f3af 8000 	nop.w
 80023a8:	f3af 8000 	nop.w
 80023ac:	f3af 8000 	nop.w

080023b0 <chCondSignalI>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondSignalI(condition_variable_t *cp) {
 80023b0:	b500      	push	{lr}
 80023b2:	b085      	sub	sp, #20
 80023b4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->c_queue)) {
 80023b6:	9b01      	ldr	r3, [sp, #4]
 80023b8:	4618      	mov	r0, r3
 80023ba:	f7ff ff59 	bl	8002270 <queue_notempty>
 80023be:	4603      	mov	r3, r0
 80023c0:	2b00      	cmp	r3, #0
 80023c2:	d00a      	beq.n	80023da <chCondSignalI+0x2a>
    thread_t *tp = queue_fifo_remove(&cp->c_queue);
 80023c4:	9b01      	ldr	r3, [sp, #4]
 80023c6:	4618      	mov	r0, r3
 80023c8:	f7ff ff8a 	bl	80022e0 <queue_fifo_remove>
 80023cc:	9003      	str	r0, [sp, #12]
    tp->p_u.rdymsg = MSG_OK;
 80023ce:	9b03      	ldr	r3, [sp, #12]
 80023d0:	2200      	movs	r2, #0
 80023d2:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 80023d4:	9803      	ldr	r0, [sp, #12]
 80023d6:	f7fe fbe3 	bl	8000ba0 <chSchReadyI>
  }
}
 80023da:	b005      	add	sp, #20
 80023dc:	f85d fb04 	ldr.w	pc, [sp], #4

080023e0 <chCondBroadcast>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondBroadcast(condition_variable_t *cp) {
 80023e0:	b500      	push	{lr}
 80023e2:	b083      	sub	sp, #12
 80023e4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80023e6:	f7ff ff93 	bl	8002310 <chSysLock>
  chCondBroadcastI(cp);
 80023ea:	9801      	ldr	r0, [sp, #4]
 80023ec:	f000 f808 	bl	8002400 <chCondBroadcastI>
  chSchRescheduleS();
 80023f0:	f7fe fcc6 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 80023f4:	f7ff ff94 	bl	8002320 <chSysUnlock>
}
 80023f8:	b003      	add	sp, #12
 80023fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80023fe:	bf00      	nop

08002400 <chCondBroadcastI>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondBroadcastI(condition_variable_t *cp) {
 8002400:	b500      	push	{lr}
 8002402:	b083      	sub	sp, #12
 8002404:	9001      	str	r0, [sp, #4]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
 8002406:	e00b      	b.n	8002420 <chCondBroadcastI+0x20>
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
 8002408:	9b01      	ldr	r3, [sp, #4]
 800240a:	4618      	mov	r0, r3
 800240c:	f7ff ff68 	bl	80022e0 <queue_fifo_remove>
 8002410:	4603      	mov	r3, r0
 8002412:	4618      	mov	r0, r3
 8002414:	f7fe fbc4 	bl	8000ba0 <chSchReadyI>
 8002418:	4603      	mov	r3, r0
 800241a:	f06f 0201 	mvn.w	r2, #1
 800241e:	621a      	str	r2, [r3, #32]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
 8002420:	9b01      	ldr	r3, [sp, #4]
 8002422:	4618      	mov	r0, r3
 8002424:	f7ff ff24 	bl	8002270 <queue_notempty>
 8002428:	4603      	mov	r3, r0
 800242a:	2b00      	cmp	r3, #0
 800242c:	d1ec      	bne.n	8002408 <chCondBroadcastI+0x8>
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
  }
}
 800242e:	b003      	add	sp, #12
 8002430:	f85d fb04 	ldr.w	pc, [sp], #4
 8002434:	f3af 8000 	nop.w
 8002438:	f3af 8000 	nop.w
 800243c:	f3af 8000 	nop.w

08002440 <chCondWait>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @api
 */
msg_t chCondWait(condition_variable_t *cp) {
 8002440:	b500      	push	{lr}
 8002442:	b085      	sub	sp, #20
 8002444:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chSysLock();
 8002446:	f7ff ff63 	bl	8002310 <chSysLock>
  msg = chCondWaitS(cp);
 800244a:	9801      	ldr	r0, [sp, #4]
 800244c:	f000 f808 	bl	8002460 <chCondWaitS>
 8002450:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8002452:	f7ff ff65 	bl	8002320 <chSysUnlock>
  return msg;
 8002456:	9b03      	ldr	r3, [sp, #12]
}
 8002458:	4618      	mov	r0, r3
 800245a:	b005      	add	sp, #20
 800245c:	f85d fb04 	ldr.w	pc, [sp], #4

08002460 <chCondWaitS>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
 8002460:	b500      	push	{lr}
 8002462:	b087      	sub	sp, #28
 8002464:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002466:	4b0f      	ldr	r3, [pc, #60]	; (80024a4 <chCondWaitS+0x44>)
 8002468:	699b      	ldr	r3, [r3, #24]
 800246a:	9305      	str	r3, [sp, #20]
  chDbgCheckClassS();
  chDbgCheck(cp != NULL);
  chDbgAssert(ctp->p_mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
 800246c:	f7ff ff68 	bl	8002340 <chMtxGetNextMutexS>
 8002470:	9004      	str	r0, [sp, #16]
  chMtxUnlockS(mp);
 8002472:	9804      	ldr	r0, [sp, #16]
 8002474:	f7ff fe4c 	bl	8002110 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  ctp->p_u.wtobjp = cp;
 8002478:	9b05      	ldr	r3, [sp, #20]
 800247a:	9a01      	ldr	r2, [sp, #4]
 800247c:	621a      	str	r2, [r3, #32]
  queue_prio_insert(ctp, &cp->c_queue);
 800247e:	9b01      	ldr	r3, [sp, #4]
 8002480:	9805      	ldr	r0, [sp, #20]
 8002482:	4619      	mov	r1, r3
 8002484:	f7ff ff04 	bl	8002290 <queue_prio_insert>
  chSchGoSleepS(CH_STATE_WTCOND);
 8002488:	2007      	movs	r0, #7
 800248a:	f7fe fbb1 	bl	8000bf0 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
 800248e:	9b05      	ldr	r3, [sp, #20]
 8002490:	6a1b      	ldr	r3, [r3, #32]
 8002492:	9303      	str	r3, [sp, #12]
  chMtxLockS(mp);
 8002494:	9804      	ldr	r0, [sp, #16]
 8002496:	f7ff fd4b 	bl	8001f30 <chMtxLockS>

  return msg;
 800249a:	9b03      	ldr	r3, [sp, #12]
}
 800249c:	4618      	mov	r0, r3
 800249e:	b007      	add	sp, #28
 80024a0:	f85d fb04 	ldr.w	pc, [sp], #4
 80024a4:	20000d98 	.word	0x20000d98
 80024a8:	f3af 8000 	nop.w
 80024ac:	f3af 8000 	nop.w

080024b0 <chCondWaitTimeout>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chCondWaitTimeout(condition_variable_t *cp, systime_t time) {
 80024b0:	b500      	push	{lr}
 80024b2:	b085      	sub	sp, #20
 80024b4:	9001      	str	r0, [sp, #4]
 80024b6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  chSysLock();
 80024b8:	f7ff ff2a 	bl	8002310 <chSysLock>
  msg = chCondWaitTimeoutS(cp, time);
 80024bc:	9801      	ldr	r0, [sp, #4]
 80024be:	9900      	ldr	r1, [sp, #0]
 80024c0:	f000 f80e 	bl	80024e0 <chCondWaitTimeoutS>
 80024c4:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 80024c6:	f7ff ff2b 	bl	8002320 <chSysUnlock>

  return msg;
 80024ca:	9b03      	ldr	r3, [sp, #12]
}
 80024cc:	4618      	mov	r0, r3
 80024ce:	b005      	add	sp, #20
 80024d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80024d4:	f3af 8000 	nop.w
 80024d8:	f3af 8000 	nop.w
 80024dc:	f3af 8000 	nop.w

080024e0 <chCondWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chCondWaitTimeoutS(condition_variable_t *cp, systime_t time) {
 80024e0:	b500      	push	{lr}
 80024e2:	b085      	sub	sp, #20
 80024e4:	9001      	str	r0, [sp, #4]
 80024e6:	9100      	str	r1, [sp, #0]
  chDbgCheckClassS();
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE));
  chDbgAssert(currp->p_mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
 80024e8:	f7ff ff2a 	bl	8002340 <chMtxGetNextMutexS>
 80024ec:	9003      	str	r0, [sp, #12]
  chMtxUnlockS(mp);
 80024ee:	9803      	ldr	r0, [sp, #12]
 80024f0:	f7ff fe0e 	bl	8002110 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->p_u.wtobjp = cp;
 80024f4:	4b0d      	ldr	r3, [pc, #52]	; (800252c <chCondWaitTimeoutS+0x4c>)
 80024f6:	699b      	ldr	r3, [r3, #24]
 80024f8:	9a01      	ldr	r2, [sp, #4]
 80024fa:	621a      	str	r2, [r3, #32]
  queue_prio_insert(currp, &cp->c_queue);
 80024fc:	4b0b      	ldr	r3, [pc, #44]	; (800252c <chCondWaitTimeoutS+0x4c>)
 80024fe:	699a      	ldr	r2, [r3, #24]
 8002500:	9b01      	ldr	r3, [sp, #4]
 8002502:	4610      	mov	r0, r2
 8002504:	4619      	mov	r1, r3
 8002506:	f7ff fec3 	bl	8002290 <queue_prio_insert>
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, time);
 800250a:	2007      	movs	r0, #7
 800250c:	9900      	ldr	r1, [sp, #0]
 800250e:	f7fe fbd7 	bl	8000cc0 <chSchGoSleepTimeoutS>
 8002512:	9002      	str	r0, [sp, #8]
  if (msg != MSG_TIMEOUT) {
 8002514:	9b02      	ldr	r3, [sp, #8]
 8002516:	f1b3 3fff 	cmp.w	r3, #4294967295
 800251a:	d002      	beq.n	8002522 <chCondWaitTimeoutS+0x42>
    chMtxLockS(mp);
 800251c:	9803      	ldr	r0, [sp, #12]
 800251e:	f7ff fd07 	bl	8001f30 <chMtxLockS>
  }

  return msg;
 8002522:	9b02      	ldr	r3, [sp, #8]
}
 8002524:	4618      	mov	r0, r3
 8002526:	b005      	add	sp, #20
 8002528:	f85d fb04 	ldr.w	pc, [sp], #4
 800252c:	20000d98 	.word	0x20000d98

08002530 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002530:	b082      	sub	sp, #8
 8002532:	2320      	movs	r3, #32
 8002534:	9301      	str	r3, [sp, #4]
 8002536:	9b01      	ldr	r3, [sp, #4]
 8002538:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800253c:	b002      	add	sp, #8
 800253e:	4770      	bx	lr

08002540 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002540:	b082      	sub	sp, #8
 8002542:	2300      	movs	r3, #0
 8002544:	9301      	str	r3, [sp, #4]
 8002546:	9b01      	ldr	r3, [sp, #4]
 8002548:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800254c:	b002      	add	sp, #8
 800254e:	4770      	bx	lr

08002550 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8002550:	b508      	push	{r3, lr}

  port_lock();
 8002552:	f7ff ffed 	bl	8002530 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002556:	bd08      	pop	{r3, pc}
 8002558:	f3af 8000 	nop.w
 800255c:	f3af 8000 	nop.w

08002560 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002560:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8002562:	f7ff ffed 	bl	8002540 <port_unlock>
}
 8002566:	bd08      	pop	{r3, pc}
 8002568:	f3af 8000 	nop.w
 800256c:	f3af 8000 	nop.w

08002570 <chEvtRegisterMaskWithFlags>:
 * @api
 */
void chEvtRegisterMaskWithFlags(event_source_t *esp,
                                event_listener_t *elp,
                                eventmask_t events,
                                eventflags_t wflags) {
 8002570:	b500      	push	{lr}
 8002572:	b085      	sub	sp, #20
 8002574:	9003      	str	r0, [sp, #12]
 8002576:	9102      	str	r1, [sp, #8]
 8002578:	9201      	str	r2, [sp, #4]
 800257a:	9300      	str	r3, [sp, #0]

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
 800257c:	f7ff ffe8 	bl	8002550 <chSysLock>
  elp->el_next     = esp->es_next;
 8002580:	9b03      	ldr	r3, [sp, #12]
 8002582:	681a      	ldr	r2, [r3, #0]
 8002584:	9b02      	ldr	r3, [sp, #8]
 8002586:	601a      	str	r2, [r3, #0]
  esp->es_next     = elp;
 8002588:	9b03      	ldr	r3, [sp, #12]
 800258a:	9a02      	ldr	r2, [sp, #8]
 800258c:	601a      	str	r2, [r3, #0]
  elp->el_listener = currp;
 800258e:	4b09      	ldr	r3, [pc, #36]	; (80025b4 <chEvtRegisterMaskWithFlags+0x44>)
 8002590:	699a      	ldr	r2, [r3, #24]
 8002592:	9b02      	ldr	r3, [sp, #8]
 8002594:	605a      	str	r2, [r3, #4]
  elp->el_events   = events;
 8002596:	9b02      	ldr	r3, [sp, #8]
 8002598:	9a01      	ldr	r2, [sp, #4]
 800259a:	609a      	str	r2, [r3, #8]
  elp->el_flags    = (eventflags_t)0;
 800259c:	9b02      	ldr	r3, [sp, #8]
 800259e:	2200      	movs	r2, #0
 80025a0:	60da      	str	r2, [r3, #12]
  elp->el_wflags   = wflags;
 80025a2:	9b02      	ldr	r3, [sp, #8]
 80025a4:	9a00      	ldr	r2, [sp, #0]
 80025a6:	611a      	str	r2, [r3, #16]
  chSysUnlock();
 80025a8:	f7ff ffda 	bl	8002560 <chSysUnlock>
}
 80025ac:	b005      	add	sp, #20
 80025ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80025b2:	bf00      	nop
 80025b4:	20000d98 	.word	0x20000d98
 80025b8:	f3af 8000 	nop.w
 80025bc:	f3af 8000 	nop.w

080025c0 <chEvtUnregister>:
 * @param[in] esp       pointer to the  @p event_source_t structure
 * @param[in] elp       pointer to the @p event_listener_t structure
 *
 * @api
 */
void chEvtUnregister(event_source_t *esp, event_listener_t *elp) {
 80025c0:	b500      	push	{lr}
 80025c2:	b085      	sub	sp, #20
 80025c4:	9001      	str	r0, [sp, #4]
 80025c6:	9100      	str	r1, [sp, #0]
  event_listener_t *p;

  chDbgCheck((esp != NULL) && (elp != NULL));

  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
 80025c8:	9b01      	ldr	r3, [sp, #4]
 80025ca:	9303      	str	r3, [sp, #12]
  /*lint -restore*/
  chSysLock();
 80025cc:	f7ff ffc0 	bl	8002550 <chSysLock>
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
 80025d0:	e00c      	b.n	80025ec <chEvtUnregister+0x2c>
  /*lint -restore*/
    if (p->el_next == elp) {
 80025d2:	9b03      	ldr	r3, [sp, #12]
 80025d4:	681a      	ldr	r2, [r3, #0]
 80025d6:	9b00      	ldr	r3, [sp, #0]
 80025d8:	429a      	cmp	r2, r3
 80025da:	d104      	bne.n	80025e6 <chEvtUnregister+0x26>
      p->el_next = elp->el_next;
 80025dc:	9b00      	ldr	r3, [sp, #0]
 80025de:	681a      	ldr	r2, [r3, #0]
 80025e0:	9b03      	ldr	r3, [sp, #12]
 80025e2:	601a      	str	r2, [r3, #0]
      break;
 80025e4:	e007      	b.n	80025f6 <chEvtUnregister+0x36>
    }
    p = p->el_next;
 80025e6:	9b03      	ldr	r3, [sp, #12]
 80025e8:	681b      	ldr	r3, [r3, #0]
 80025ea:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
 80025ec:	9b03      	ldr	r3, [sp, #12]
 80025ee:	681a      	ldr	r2, [r3, #0]
 80025f0:	9b01      	ldr	r3, [sp, #4]
 80025f2:	429a      	cmp	r2, r3
 80025f4:	d1ed      	bne.n	80025d2 <chEvtUnregister+0x12>
      p->el_next = elp->el_next;
      break;
    }
    p = p->el_next;
  }
  chSysUnlock();
 80025f6:	f7ff ffb3 	bl	8002560 <chSysUnlock>
}
 80025fa:	b005      	add	sp, #20
 80025fc:	f85d fb04 	ldr.w	pc, [sp], #4

08002600 <chEvtGetAndClearEvents>:
 * @param[in] events    the events to be cleared
 * @return              The pending events that were cleared.
 *
 * @api
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
 8002600:	b500      	push	{lr}
 8002602:	b085      	sub	sp, #20
 8002604:	9001      	str	r0, [sp, #4]
  eventmask_t m;

  chSysLock();
 8002606:	f7ff ffa3 	bl	8002550 <chSysLock>
  m = currp->p_epending & events;
 800260a:	4b0b      	ldr	r3, [pc, #44]	; (8002638 <chEvtGetAndClearEvents+0x38>)
 800260c:	699b      	ldr	r3, [r3, #24]
 800260e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002610:	9b01      	ldr	r3, [sp, #4]
 8002612:	4013      	ands	r3, r2
 8002614:	9303      	str	r3, [sp, #12]
  currp->p_epending &= ~events;
 8002616:	4b08      	ldr	r3, [pc, #32]	; (8002638 <chEvtGetAndClearEvents+0x38>)
 8002618:	699b      	ldr	r3, [r3, #24]
 800261a:	4a07      	ldr	r2, [pc, #28]	; (8002638 <chEvtGetAndClearEvents+0x38>)
 800261c:	6992      	ldr	r2, [r2, #24]
 800261e:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8002620:	9a01      	ldr	r2, [sp, #4]
 8002622:	43d2      	mvns	r2, r2
 8002624:	400a      	ands	r2, r1
 8002626:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8002628:	f7ff ff9a 	bl	8002560 <chSysUnlock>

  return m;
 800262c:	9b03      	ldr	r3, [sp, #12]
}
 800262e:	4618      	mov	r0, r3
 8002630:	b005      	add	sp, #20
 8002632:	f85d fb04 	ldr.w	pc, [sp], #4
 8002636:	bf00      	nop
 8002638:	20000d98 	.word	0x20000d98
 800263c:	f3af 8000 	nop.w

08002640 <chEvtAddEvents>:
 * @param[in] events    the events to be added
 * @return              The current pending events.
 *
 * @api
 */
eventmask_t chEvtAddEvents(eventmask_t events) {
 8002640:	b500      	push	{lr}
 8002642:	b083      	sub	sp, #12
 8002644:	9001      	str	r0, [sp, #4]

  chSysLock();
 8002646:	f7ff ff83 	bl	8002550 <chSysLock>
  currp->p_epending |= events;
 800264a:	4b09      	ldr	r3, [pc, #36]	; (8002670 <chEvtAddEvents+0x30>)
 800264c:	699b      	ldr	r3, [r3, #24]
 800264e:	4a08      	ldr	r2, [pc, #32]	; (8002670 <chEvtAddEvents+0x30>)
 8002650:	6992      	ldr	r2, [r2, #24]
 8002652:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8002654:	9a01      	ldr	r2, [sp, #4]
 8002656:	430a      	orrs	r2, r1
 8002658:	635a      	str	r2, [r3, #52]	; 0x34
  events = currp->p_epending;
 800265a:	4b05      	ldr	r3, [pc, #20]	; (8002670 <chEvtAddEvents+0x30>)
 800265c:	699b      	ldr	r3, [r3, #24]
 800265e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002660:	9301      	str	r3, [sp, #4]
  chSysUnlock();
 8002662:	f7ff ff7d 	bl	8002560 <chSysUnlock>

  return events;
 8002666:	9b01      	ldr	r3, [sp, #4]
}
 8002668:	4618      	mov	r0, r3
 800266a:	b003      	add	sp, #12
 800266c:	f85d fb04 	ldr.w	pc, [sp], #4
 8002670:	20000d98 	.word	0x20000d98
 8002674:	f3af 8000 	nop.w
 8002678:	f3af 8000 	nop.w
 800267c:	f3af 8000 	nop.w

08002680 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8002680:	b500      	push	{lr}
 8002682:	b085      	sub	sp, #20
 8002684:	9001      	str	r0, [sp, #4]
 8002686:	9100      	str	r1, [sp, #0]
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 8002688:	9b01      	ldr	r3, [sp, #4]
 800268a:	681b      	ldr	r3, [r3, #0]
 800268c:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 800268e:	e01a      	b.n	80026c6 <chEvtBroadcastFlagsI+0x46>
  /*lint -restore*/
    elp->el_flags |= flags;
 8002690:	9b03      	ldr	r3, [sp, #12]
 8002692:	68da      	ldr	r2, [r3, #12]
 8002694:	9b00      	ldr	r3, [sp, #0]
 8002696:	431a      	orrs	r2, r3
 8002698:	9b03      	ldr	r3, [sp, #12]
 800269a:	60da      	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 800269c:	9b00      	ldr	r3, [sp, #0]
 800269e:	2b00      	cmp	r3, #0
 80026a0:	d006      	beq.n	80026b0 <chEvtBroadcastFlagsI+0x30>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
 80026a2:	9b03      	ldr	r3, [sp, #12]
 80026a4:	68da      	ldr	r2, [r3, #12]
 80026a6:	9b03      	ldr	r3, [sp, #12]
 80026a8:	691b      	ldr	r3, [r3, #16]
 80026aa:	4013      	ands	r3, r2
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 80026ac:	2b00      	cmp	r3, #0
 80026ae:	d007      	beq.n	80026c0 <chEvtBroadcastFlagsI+0x40>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 80026b0:	9b03      	ldr	r3, [sp, #12]
 80026b2:	685a      	ldr	r2, [r3, #4]
 80026b4:	9b03      	ldr	r3, [sp, #12]
 80026b6:	689b      	ldr	r3, [r3, #8]
 80026b8:	4610      	mov	r0, r2
 80026ba:	4619      	mov	r1, r3
 80026bc:	f000 f840 	bl	8002740 <chEvtSignalI>
    }
    elp = elp->el_next;
 80026c0:	9b03      	ldr	r3, [sp, #12]
 80026c2:	681b      	ldr	r3, [r3, #0]
 80026c4:	9303      	str	r3, [sp, #12]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80026c6:	9a03      	ldr	r2, [sp, #12]
 80026c8:	9b01      	ldr	r3, [sp, #4]
 80026ca:	429a      	cmp	r2, r3
 80026cc:	d1e0      	bne.n	8002690 <chEvtBroadcastFlagsI+0x10>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
  }
}
 80026ce:	b005      	add	sp, #20
 80026d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80026d4:	f3af 8000 	nop.w
 80026d8:	f3af 8000 	nop.w
 80026dc:	f3af 8000 	nop.w

080026e0 <chEvtGetAndClearFlags>:
 * @return              The flags added to the listener by the associated
 *                      event source.
 *
 * @api
 */
eventflags_t chEvtGetAndClearFlags(event_listener_t *elp) {
 80026e0:	b500      	push	{lr}
 80026e2:	b085      	sub	sp, #20
 80026e4:	9001      	str	r0, [sp, #4]
  eventflags_t flags;

  chSysLock();
 80026e6:	f7ff ff33 	bl	8002550 <chSysLock>
  flags = elp->el_flags;
 80026ea:	9b01      	ldr	r3, [sp, #4]
 80026ec:	68db      	ldr	r3, [r3, #12]
 80026ee:	9303      	str	r3, [sp, #12]
  elp->el_flags = (eventflags_t)0;
 80026f0:	9b01      	ldr	r3, [sp, #4]
 80026f2:	2200      	movs	r2, #0
 80026f4:	60da      	str	r2, [r3, #12]
  chSysUnlock();
 80026f6:	f7ff ff33 	bl	8002560 <chSysUnlock>

  return flags;
 80026fa:	9b03      	ldr	r3, [sp, #12]
}
 80026fc:	4618      	mov	r0, r3
 80026fe:	b005      	add	sp, #20
 8002700:	f85d fb04 	ldr.w	pc, [sp], #4
 8002704:	f3af 8000 	nop.w
 8002708:	f3af 8000 	nop.w
 800270c:	f3af 8000 	nop.w

08002710 <chEvtSignal>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @api
 */
void chEvtSignal(thread_t *tp, eventmask_t events) {
 8002710:	b500      	push	{lr}
 8002712:	b083      	sub	sp, #12
 8002714:	9001      	str	r0, [sp, #4]
 8002716:	9100      	str	r1, [sp, #0]

  chDbgCheck(tp != NULL);

  chSysLock();
 8002718:	f7ff ff1a 	bl	8002550 <chSysLock>
  chEvtSignalI(tp, events);
 800271c:	9801      	ldr	r0, [sp, #4]
 800271e:	9900      	ldr	r1, [sp, #0]
 8002720:	f000 f80e 	bl	8002740 <chEvtSignalI>
  chSchRescheduleS();
 8002724:	f7fe fb2c 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 8002728:	f7ff ff1a 	bl	8002560 <chSysUnlock>
}
 800272c:	b003      	add	sp, #12
 800272e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002732:	bf00      	nop
 8002734:	f3af 8000 	nop.w
 8002738:	f3af 8000 	nop.w
 800273c:	f3af 8000 	nop.w

08002740 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8002740:	b500      	push	{lr}
 8002742:	b083      	sub	sp, #12
 8002744:	9001      	str	r0, [sp, #4]
 8002746:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8002748:	9b01      	ldr	r3, [sp, #4]
 800274a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800274c:	9b00      	ldr	r3, [sp, #0]
 800274e:	431a      	orrs	r2, r3
 8002750:	9b01      	ldr	r3, [sp, #4]
 8002752:	635a      	str	r2, [r3, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8002754:	9b01      	ldr	r3, [sp, #4]
 8002756:	7f1b      	ldrb	r3, [r3, #28]
 8002758:	2b0a      	cmp	r3, #10
 800275a:	d106      	bne.n	800276a <chEvtSignalI+0x2a>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800275c:	9b01      	ldr	r3, [sp, #4]
 800275e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002760:	9b01      	ldr	r3, [sp, #4]
 8002762:	6a1b      	ldr	r3, [r3, #32]
 8002764:	4013      	ands	r3, r2
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8002766:	2b00      	cmp	r3, #0
 8002768:	d10c      	bne.n	8002784 <chEvtSignalI+0x44>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 800276a:	9b01      	ldr	r3, [sp, #4]
 800276c:	7f1b      	ldrb	r3, [r3, #28]
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800276e:	2b0b      	cmp	r3, #11
 8002770:	d10e      	bne.n	8002790 <chEvtSignalI+0x50>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8002772:	9b01      	ldr	r3, [sp, #4]
 8002774:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002776:	9b01      	ldr	r3, [sp, #4]
 8002778:	6a1b      	ldr	r3, [r3, #32]
 800277a:	401a      	ands	r2, r3
 800277c:	9b01      	ldr	r3, [sp, #4]
 800277e:	6a1b      	ldr	r3, [r3, #32]

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8002780:	429a      	cmp	r2, r3
 8002782:	d105      	bne.n	8002790 <chEvtSignalI+0x50>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8002784:	9b01      	ldr	r3, [sp, #4]
 8002786:	2200      	movs	r2, #0
 8002788:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 800278a:	9801      	ldr	r0, [sp, #4]
 800278c:	f7fe fa08 	bl	8000ba0 <chSchReadyI>
  }
}
 8002790:	b003      	add	sp, #12
 8002792:	f85d fb04 	ldr.w	pc, [sp], #4
 8002796:	bf00      	nop
 8002798:	f3af 8000 	nop.w
 800279c:	f3af 8000 	nop.w

080027a0 <chEvtBroadcastFlags>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {
 80027a0:	b500      	push	{lr}
 80027a2:	b083      	sub	sp, #12
 80027a4:	9001      	str	r0, [sp, #4]
 80027a6:	9100      	str	r1, [sp, #0]

  chSysLock();
 80027a8:	f7ff fed2 	bl	8002550 <chSysLock>
  chEvtBroadcastFlagsI(esp, flags);
 80027ac:	9801      	ldr	r0, [sp, #4]
 80027ae:	9900      	ldr	r1, [sp, #0]
 80027b0:	f7ff ff66 	bl	8002680 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 80027b4:	f7fe fae4 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 80027b8:	f7ff fed2 	bl	8002560 <chSysUnlock>
}
 80027bc:	b003      	add	sp, #12
 80027be:	f85d fb04 	ldr.w	pc, [sp], #4
 80027c2:	bf00      	nop
 80027c4:	f3af 8000 	nop.w
 80027c8:	f3af 8000 	nop.w
 80027cc:	f3af 8000 	nop.w

080027d0 <chEvtGetAndClearFlagsI>:
 * @return              The flags added to the listener by the associated
 *                      event source.
 *
 * @iclass
 */
eventflags_t chEvtGetAndClearFlagsI(event_listener_t *elp) {
 80027d0:	b084      	sub	sp, #16
 80027d2:	9001      	str	r0, [sp, #4]
  eventflags_t flags;

  flags = elp->el_flags;
 80027d4:	9b01      	ldr	r3, [sp, #4]
 80027d6:	68db      	ldr	r3, [r3, #12]
 80027d8:	9303      	str	r3, [sp, #12]
  elp->el_flags = (eventflags_t)0;
 80027da:	9b01      	ldr	r3, [sp, #4]
 80027dc:	2200      	movs	r2, #0
 80027de:	60da      	str	r2, [r3, #12]

  return flags;
 80027e0:	9b03      	ldr	r3, [sp, #12]
}
 80027e2:	4618      	mov	r0, r3
 80027e4:	b004      	add	sp, #16
 80027e6:	4770      	bx	lr
 80027e8:	f3af 8000 	nop.w
 80027ec:	f3af 8000 	nop.w

080027f0 <chEvtDispatch>:
 * @param[in] handlers  an array of @p evhandler_t. The array must have size
 *                      equal to the number of bits in eventmask_t.
 *
 * @api
 */
void chEvtDispatch(const evhandler_t *handlers, eventmask_t events) {
 80027f0:	b500      	push	{lr}
 80027f2:	b085      	sub	sp, #20
 80027f4:	9001      	str	r0, [sp, #4]
 80027f6:	9100      	str	r1, [sp, #0]
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
 80027f8:	2300      	movs	r3, #0
 80027fa:	9303      	str	r3, [sp, #12]
  while (events != (eventmask_t)0) {
 80027fc:	e019      	b.n	8002832 <chEvtDispatch+0x42>
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 80027fe:	9a00      	ldr	r2, [sp, #0]
 8002800:	9b03      	ldr	r3, [sp, #12]
 8002802:	fa22 f303 	lsr.w	r3, r2, r3
 8002806:	f003 0301 	and.w	r3, r3, #1
 800280a:	2b00      	cmp	r3, #0
 800280c:	d00e      	beq.n	800282c <chEvtDispatch+0x3c>
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 800280e:	2201      	movs	r2, #1
 8002810:	9b03      	ldr	r3, [sp, #12]
 8002812:	fa02 f303 	lsl.w	r3, r2, r3
 8002816:	43db      	mvns	r3, r3
 8002818:	9a00      	ldr	r2, [sp, #0]
 800281a:	4013      	ands	r3, r2
 800281c:	9300      	str	r3, [sp, #0]
      handlers[eid](eid);
 800281e:	9b03      	ldr	r3, [sp, #12]
 8002820:	009b      	lsls	r3, r3, #2
 8002822:	9a01      	ldr	r2, [sp, #4]
 8002824:	4413      	add	r3, r2
 8002826:	681b      	ldr	r3, [r3, #0]
 8002828:	9803      	ldr	r0, [sp, #12]
 800282a:	4798      	blx	r3
    }
    eid++;
 800282c:	9b03      	ldr	r3, [sp, #12]
 800282e:	3301      	adds	r3, #1
 8002830:	9303      	str	r3, [sp, #12]
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 8002832:	9b00      	ldr	r3, [sp, #0]
 8002834:	2b00      	cmp	r3, #0
 8002836:	d1e2      	bne.n	80027fe <chEvtDispatch+0xe>
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
  }
}
 8002838:	b005      	add	sp, #20
 800283a:	f85d fb04 	ldr.w	pc, [sp], #4
 800283e:	bf00      	nop

08002840 <chEvtWaitOne>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
 8002840:	b500      	push	{lr}
 8002842:	b085      	sub	sp, #20
 8002844:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002846:	4b15      	ldr	r3, [pc, #84]	; (800289c <chEvtWaitOne+0x5c>)
 8002848:	699b      	ldr	r3, [r3, #24]
 800284a:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 800284c:	f7ff fe80 	bl	8002550 <chSysLock>
  m = ctp->p_epending & events;
 8002850:	9b02      	ldr	r3, [sp, #8]
 8002852:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002854:	9b01      	ldr	r3, [sp, #4]
 8002856:	4013      	ands	r3, r2
 8002858:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 800285a:	9b03      	ldr	r3, [sp, #12]
 800285c:	2b00      	cmp	r3, #0
 800285e:	d10a      	bne.n	8002876 <chEvtWaitOne+0x36>
    ctp->p_u.ewmask = events;
 8002860:	9b02      	ldr	r3, [sp, #8]
 8002862:	9a01      	ldr	r2, [sp, #4]
 8002864:	621a      	str	r2, [r3, #32]
    chSchGoSleepS(CH_STATE_WTOREVT);
 8002866:	200a      	movs	r0, #10
 8002868:	f7fe f9c2 	bl	8000bf0 <chSchGoSleepS>
    m = ctp->p_epending & events;
 800286c:	9b02      	ldr	r3, [sp, #8]
 800286e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002870:	9b01      	ldr	r3, [sp, #4]
 8002872:	4013      	ands	r3, r2
 8002874:	9303      	str	r3, [sp, #12]
  }
  m ^= m & (m - (eventmask_t)1);
 8002876:	9b03      	ldr	r3, [sp, #12]
 8002878:	425b      	negs	r3, r3
 800287a:	9a03      	ldr	r2, [sp, #12]
 800287c:	4013      	ands	r3, r2
 800287e:	9303      	str	r3, [sp, #12]
  ctp->p_epending &= ~m;
 8002880:	9b02      	ldr	r3, [sp, #8]
 8002882:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002884:	9b03      	ldr	r3, [sp, #12]
 8002886:	43db      	mvns	r3, r3
 8002888:	401a      	ands	r2, r3
 800288a:	9b02      	ldr	r3, [sp, #8]
 800288c:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 800288e:	f7ff fe67 	bl	8002560 <chSysUnlock>

  return m;
 8002892:	9b03      	ldr	r3, [sp, #12]
}
 8002894:	4618      	mov	r0, r3
 8002896:	b005      	add	sp, #20
 8002898:	f85d fb04 	ldr.w	pc, [sp], #4
 800289c:	20000d98 	.word	0x20000d98

080028a0 <chEvtWaitAny>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
 80028a0:	b500      	push	{lr}
 80028a2:	b085      	sub	sp, #20
 80028a4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 80028a6:	4b13      	ldr	r3, [pc, #76]	; (80028f4 <chEvtWaitAny+0x54>)
 80028a8:	699b      	ldr	r3, [r3, #24]
 80028aa:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 80028ac:	f7ff fe50 	bl	8002550 <chSysLock>
  m = ctp->p_epending & events;
 80028b0:	9b02      	ldr	r3, [sp, #8]
 80028b2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80028b4:	9b01      	ldr	r3, [sp, #4]
 80028b6:	4013      	ands	r3, r2
 80028b8:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 80028ba:	9b03      	ldr	r3, [sp, #12]
 80028bc:	2b00      	cmp	r3, #0
 80028be:	d10a      	bne.n	80028d6 <chEvtWaitAny+0x36>
    ctp->p_u.ewmask = events;
 80028c0:	9b02      	ldr	r3, [sp, #8]
 80028c2:	9a01      	ldr	r2, [sp, #4]
 80028c4:	621a      	str	r2, [r3, #32]
    chSchGoSleepS(CH_STATE_WTOREVT);
 80028c6:	200a      	movs	r0, #10
 80028c8:	f7fe f992 	bl	8000bf0 <chSchGoSleepS>
    m = ctp->p_epending & events;
 80028cc:	9b02      	ldr	r3, [sp, #8]
 80028ce:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80028d0:	9b01      	ldr	r3, [sp, #4]
 80028d2:	4013      	ands	r3, r2
 80028d4:	9303      	str	r3, [sp, #12]
  }
  ctp->p_epending &= ~m;
 80028d6:	9b02      	ldr	r3, [sp, #8]
 80028d8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80028da:	9b03      	ldr	r3, [sp, #12]
 80028dc:	43db      	mvns	r3, r3
 80028de:	401a      	ands	r2, r3
 80028e0:	9b02      	ldr	r3, [sp, #8]
 80028e2:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 80028e4:	f7ff fe3c 	bl	8002560 <chSysUnlock>

  return m;
 80028e8:	9b03      	ldr	r3, [sp, #12]
}
 80028ea:	4618      	mov	r0, r3
 80028ec:	b005      	add	sp, #20
 80028ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80028f2:	bf00      	nop
 80028f4:	20000d98 	.word	0x20000d98
 80028f8:	f3af 8000 	nop.w
 80028fc:	f3af 8000 	nop.w

08002900 <chEvtWaitAll>:
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
 8002900:	b500      	push	{lr}
 8002902:	b085      	sub	sp, #20
 8002904:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002906:	4b10      	ldr	r3, [pc, #64]	; (8002948 <chEvtWaitAll+0x48>)
 8002908:	699b      	ldr	r3, [r3, #24]
 800290a:	9303      	str	r3, [sp, #12]

  chSysLock();
 800290c:	f7ff fe20 	bl	8002550 <chSysLock>
  if ((ctp->p_epending & events) != events) {
 8002910:	9b03      	ldr	r3, [sp, #12]
 8002912:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002914:	9b01      	ldr	r3, [sp, #4]
 8002916:	401a      	ands	r2, r3
 8002918:	9b01      	ldr	r3, [sp, #4]
 800291a:	429a      	cmp	r2, r3
 800291c:	d005      	beq.n	800292a <chEvtWaitAll+0x2a>
    ctp->p_u.ewmask = events;
 800291e:	9b03      	ldr	r3, [sp, #12]
 8002920:	9a01      	ldr	r2, [sp, #4]
 8002922:	621a      	str	r2, [r3, #32]
    chSchGoSleepS(CH_STATE_WTANDEVT);
 8002924:	200b      	movs	r0, #11
 8002926:	f7fe f963 	bl	8000bf0 <chSchGoSleepS>
  }
  ctp->p_epending &= ~events;
 800292a:	9b03      	ldr	r3, [sp, #12]
 800292c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800292e:	9b01      	ldr	r3, [sp, #4]
 8002930:	43db      	mvns	r3, r3
 8002932:	401a      	ands	r2, r3
 8002934:	9b03      	ldr	r3, [sp, #12]
 8002936:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8002938:	f7ff fe12 	bl	8002560 <chSysUnlock>

  return events;
 800293c:	9b01      	ldr	r3, [sp, #4]
}
 800293e:	4618      	mov	r0, r3
 8002940:	b005      	add	sp, #20
 8002942:	f85d fb04 	ldr.w	pc, [sp], #4
 8002946:	bf00      	nop
 8002948:	20000d98 	.word	0x20000d98
 800294c:	f3af 8000 	nop.w

08002950 <chEvtWaitOneTimeout>:
 * @return              The mask of the lowest event id served and cleared.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
 8002950:	b500      	push	{lr}
 8002952:	b085      	sub	sp, #20
 8002954:	9001      	str	r0, [sp, #4]
 8002956:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 8002958:	4b1c      	ldr	r3, [pc, #112]	; (80029cc <chEvtWaitOneTimeout+0x7c>)
 800295a:	699b      	ldr	r3, [r3, #24]
 800295c:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 800295e:	f7ff fdf7 	bl	8002550 <chSysLock>
  m = ctp->p_epending & events;
 8002962:	9b02      	ldr	r3, [sp, #8]
 8002964:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002966:	9b01      	ldr	r3, [sp, #4]
 8002968:	4013      	ands	r3, r2
 800296a:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 800296c:	9b03      	ldr	r3, [sp, #12]
 800296e:	2b00      	cmp	r3, #0
 8002970:	d119      	bne.n	80029a6 <chEvtWaitOneTimeout+0x56>
    if (TIME_IMMEDIATE == time) {
 8002972:	9b00      	ldr	r3, [sp, #0]
 8002974:	2b00      	cmp	r3, #0
 8002976:	d103      	bne.n	8002980 <chEvtWaitOneTimeout+0x30>
      chSysUnlock();
 8002978:	f7ff fdf2 	bl	8002560 <chSysUnlock>
      return (eventmask_t)0;
 800297c:	2300      	movs	r3, #0
 800297e:	e021      	b.n	80029c4 <chEvtWaitOneTimeout+0x74>
    }
    ctp->p_u.ewmask = events;
 8002980:	9b02      	ldr	r3, [sp, #8]
 8002982:	9a01      	ldr	r2, [sp, #4]
 8002984:	621a      	str	r2, [r3, #32]
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8002986:	200a      	movs	r0, #10
 8002988:	9900      	ldr	r1, [sp, #0]
 800298a:	f7fe f999 	bl	8000cc0 <chSchGoSleepTimeoutS>
 800298e:	4603      	mov	r3, r0
 8002990:	2b00      	cmp	r3, #0
 8002992:	da03      	bge.n	800299c <chEvtWaitOneTimeout+0x4c>
      chSysUnlock();
 8002994:	f7ff fde4 	bl	8002560 <chSysUnlock>
      return (eventmask_t)0;
 8002998:	2300      	movs	r3, #0
 800299a:	e013      	b.n	80029c4 <chEvtWaitOneTimeout+0x74>
    }
    m = ctp->p_epending & events;
 800299c:	9b02      	ldr	r3, [sp, #8]
 800299e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80029a0:	9b01      	ldr	r3, [sp, #4]
 80029a2:	4013      	ands	r3, r2
 80029a4:	9303      	str	r3, [sp, #12]
  }
  m ^= m & (m - (eventmask_t)1);
 80029a6:	9b03      	ldr	r3, [sp, #12]
 80029a8:	425b      	negs	r3, r3
 80029aa:	9a03      	ldr	r2, [sp, #12]
 80029ac:	4013      	ands	r3, r2
 80029ae:	9303      	str	r3, [sp, #12]
  ctp->p_epending &= ~m;
 80029b0:	9b02      	ldr	r3, [sp, #8]
 80029b2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80029b4:	9b03      	ldr	r3, [sp, #12]
 80029b6:	43db      	mvns	r3, r3
 80029b8:	401a      	ands	r2, r3
 80029ba:	9b02      	ldr	r3, [sp, #8]
 80029bc:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 80029be:	f7ff fdcf 	bl	8002560 <chSysUnlock>

  return m;
 80029c2:	9b03      	ldr	r3, [sp, #12]
}
 80029c4:	4618      	mov	r0, r3
 80029c6:	b005      	add	sp, #20
 80029c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80029cc:	20000d98 	.word	0x20000d98

080029d0 <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
 80029d0:	b500      	push	{lr}
 80029d2:	b085      	sub	sp, #20
 80029d4:	9001      	str	r0, [sp, #4]
 80029d6:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 80029d8:	4b1a      	ldr	r3, [pc, #104]	; (8002a44 <chEvtWaitAnyTimeout+0x74>)
 80029da:	699b      	ldr	r3, [r3, #24]
 80029dc:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 80029de:	f7ff fdb7 	bl	8002550 <chSysLock>
  m = ctp->p_epending & events;
 80029e2:	9b02      	ldr	r3, [sp, #8]
 80029e4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80029e6:	9b01      	ldr	r3, [sp, #4]
 80029e8:	4013      	ands	r3, r2
 80029ea:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 80029ec:	9b03      	ldr	r3, [sp, #12]
 80029ee:	2b00      	cmp	r3, #0
 80029f0:	d119      	bne.n	8002a26 <chEvtWaitAnyTimeout+0x56>
    if (TIME_IMMEDIATE == time) {
 80029f2:	9b00      	ldr	r3, [sp, #0]
 80029f4:	2b00      	cmp	r3, #0
 80029f6:	d103      	bne.n	8002a00 <chEvtWaitAnyTimeout+0x30>
      chSysUnlock();
 80029f8:	f7ff fdb2 	bl	8002560 <chSysUnlock>
      return (eventmask_t)0;
 80029fc:	2300      	movs	r3, #0
 80029fe:	e01c      	b.n	8002a3a <chEvtWaitAnyTimeout+0x6a>
    }
    ctp->p_u.ewmask = events;
 8002a00:	9b02      	ldr	r3, [sp, #8]
 8002a02:	9a01      	ldr	r2, [sp, #4]
 8002a04:	621a      	str	r2, [r3, #32]
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8002a06:	200a      	movs	r0, #10
 8002a08:	9900      	ldr	r1, [sp, #0]
 8002a0a:	f7fe f959 	bl	8000cc0 <chSchGoSleepTimeoutS>
 8002a0e:	4603      	mov	r3, r0
 8002a10:	2b00      	cmp	r3, #0
 8002a12:	da03      	bge.n	8002a1c <chEvtWaitAnyTimeout+0x4c>
      chSysUnlock();
 8002a14:	f7ff fda4 	bl	8002560 <chSysUnlock>
      return (eventmask_t)0;
 8002a18:	2300      	movs	r3, #0
 8002a1a:	e00e      	b.n	8002a3a <chEvtWaitAnyTimeout+0x6a>
    }
    m = ctp->p_epending & events;
 8002a1c:	9b02      	ldr	r3, [sp, #8]
 8002a1e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002a20:	9b01      	ldr	r3, [sp, #4]
 8002a22:	4013      	ands	r3, r2
 8002a24:	9303      	str	r3, [sp, #12]
  }
  ctp->p_epending &= ~m;
 8002a26:	9b02      	ldr	r3, [sp, #8]
 8002a28:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002a2a:	9b03      	ldr	r3, [sp, #12]
 8002a2c:	43db      	mvns	r3, r3
 8002a2e:	401a      	ands	r2, r3
 8002a30:	9b02      	ldr	r3, [sp, #8]
 8002a32:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8002a34:	f7ff fd94 	bl	8002560 <chSysUnlock>

  return m;
 8002a38:	9b03      	ldr	r3, [sp, #12]
}
 8002a3a:	4618      	mov	r0, r3
 8002a3c:	b005      	add	sp, #20
 8002a3e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002a42:	bf00      	nop
 8002a44:	20000d98 	.word	0x20000d98
 8002a48:	f3af 8000 	nop.w
 8002a4c:	f3af 8000 	nop.w

08002a50 <chEvtWaitAllTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
 8002a50:	b500      	push	{lr}
 8002a52:	b085      	sub	sp, #20
 8002a54:	9001      	str	r0, [sp, #4]
 8002a56:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 8002a58:	4b17      	ldr	r3, [pc, #92]	; (8002ab8 <chEvtWaitAllTimeout+0x68>)
 8002a5a:	699b      	ldr	r3, [r3, #24]
 8002a5c:	9303      	str	r3, [sp, #12]

  chSysLock();
 8002a5e:	f7ff fd77 	bl	8002550 <chSysLock>
  if ((ctp->p_epending & events) != events) {
 8002a62:	9b03      	ldr	r3, [sp, #12]
 8002a64:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002a66:	9b01      	ldr	r3, [sp, #4]
 8002a68:	401a      	ands	r2, r3
 8002a6a:	9b01      	ldr	r3, [sp, #4]
 8002a6c:	429a      	cmp	r2, r3
 8002a6e:	d014      	beq.n	8002a9a <chEvtWaitAllTimeout+0x4a>
    if (TIME_IMMEDIATE == time) {
 8002a70:	9b00      	ldr	r3, [sp, #0]
 8002a72:	2b00      	cmp	r3, #0
 8002a74:	d103      	bne.n	8002a7e <chEvtWaitAllTimeout+0x2e>
      chSysUnlock();
 8002a76:	f7ff fd73 	bl	8002560 <chSysUnlock>
      return (eventmask_t)0;
 8002a7a:	2300      	movs	r3, #0
 8002a7c:	e017      	b.n	8002aae <chEvtWaitAllTimeout+0x5e>
    }
    ctp->p_u.ewmask = events;
 8002a7e:	9b03      	ldr	r3, [sp, #12]
 8002a80:	9a01      	ldr	r2, [sp, #4]
 8002a82:	621a      	str	r2, [r3, #32]
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, time) < MSG_OK) {
 8002a84:	200b      	movs	r0, #11
 8002a86:	9900      	ldr	r1, [sp, #0]
 8002a88:	f7fe f91a 	bl	8000cc0 <chSchGoSleepTimeoutS>
 8002a8c:	4603      	mov	r3, r0
 8002a8e:	2b00      	cmp	r3, #0
 8002a90:	da03      	bge.n	8002a9a <chEvtWaitAllTimeout+0x4a>
      chSysUnlock();
 8002a92:	f7ff fd65 	bl	8002560 <chSysUnlock>
      return (eventmask_t)0;
 8002a96:	2300      	movs	r3, #0
 8002a98:	e009      	b.n	8002aae <chEvtWaitAllTimeout+0x5e>
    }
  }
  ctp->p_epending &= ~events;
 8002a9a:	9b03      	ldr	r3, [sp, #12]
 8002a9c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002a9e:	9b01      	ldr	r3, [sp, #4]
 8002aa0:	43db      	mvns	r3, r3
 8002aa2:	401a      	ands	r2, r3
 8002aa4:	9b03      	ldr	r3, [sp, #12]
 8002aa6:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8002aa8:	f7ff fd5a 	bl	8002560 <chSysUnlock>

  return events;
 8002aac:	9b01      	ldr	r3, [sp, #4]
}
 8002aae:	4618      	mov	r0, r3
 8002ab0:	b005      	add	sp, #20
 8002ab2:	f85d fb04 	ldr.w	pc, [sp], #4
 8002ab6:	bf00      	nop
 8002ab8:	20000d98 	.word	0x20000d98
 8002abc:	f3af 8000 	nop.w

08002ac0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002ac0:	b082      	sub	sp, #8
 8002ac2:	2320      	movs	r3, #32
 8002ac4:	9301      	str	r3, [sp, #4]
 8002ac6:	9b01      	ldr	r3, [sp, #4]
 8002ac8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002acc:	b002      	add	sp, #8
 8002ace:	4770      	bx	lr

08002ad0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002ad0:	b082      	sub	sp, #8
 8002ad2:	2300      	movs	r3, #0
 8002ad4:	9301      	str	r3, [sp, #4]
 8002ad6:	9b01      	ldr	r3, [sp, #4]
 8002ad8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002adc:	b002      	add	sp, #8
 8002ade:	4770      	bx	lr

08002ae0 <queue_insert>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8002ae0:	b082      	sub	sp, #8
 8002ae2:	9001      	str	r0, [sp, #4]
 8002ae4:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 8002ae6:	9b01      	ldr	r3, [sp, #4]
 8002ae8:	9a00      	ldr	r2, [sp, #0]
 8002aea:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 8002aec:	9b00      	ldr	r3, [sp, #0]
 8002aee:	685a      	ldr	r2, [r3, #4]
 8002af0:	9b01      	ldr	r3, [sp, #4]
 8002af2:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8002af4:	9b01      	ldr	r3, [sp, #4]
 8002af6:	685b      	ldr	r3, [r3, #4]
 8002af8:	9a01      	ldr	r2, [sp, #4]
 8002afa:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 8002afc:	9b00      	ldr	r3, [sp, #0]
 8002afe:	9a01      	ldr	r2, [sp, #4]
 8002b00:	605a      	str	r2, [r3, #4]
}
 8002b02:	b002      	add	sp, #8
 8002b04:	4770      	bx	lr
 8002b06:	bf00      	nop
 8002b08:	f3af 8000 	nop.w
 8002b0c:	f3af 8000 	nop.w

08002b10 <queue_fifo_remove>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8002b10:	b084      	sub	sp, #16
 8002b12:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8002b14:	9b01      	ldr	r3, [sp, #4]
 8002b16:	681b      	ldr	r3, [r3, #0]
 8002b18:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8002b1a:	9b03      	ldr	r3, [sp, #12]
 8002b1c:	681a      	ldr	r2, [r3, #0]
 8002b1e:	9b01      	ldr	r3, [sp, #4]
 8002b20:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8002b22:	9b01      	ldr	r3, [sp, #4]
 8002b24:	681b      	ldr	r3, [r3, #0]
 8002b26:	9a01      	ldr	r2, [sp, #4]
 8002b28:	605a      	str	r2, [r3, #4]

  return tp;
 8002b2a:	9b03      	ldr	r3, [sp, #12]
}
 8002b2c:	4618      	mov	r0, r3
 8002b2e:	b004      	add	sp, #16
 8002b30:	4770      	bx	lr
 8002b32:	bf00      	nop
 8002b34:	f3af 8000 	nop.w
 8002b38:	f3af 8000 	nop.w
 8002b3c:	f3af 8000 	nop.w

08002b40 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8002b40:	b508      	push	{r3, lr}

  port_lock();
 8002b42:	f7ff ffbd 	bl	8002ac0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002b46:	bd08      	pop	{r3, pc}
 8002b48:	f3af 8000 	nop.w
 8002b4c:	f3af 8000 	nop.w

08002b50 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002b50:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8002b52:	f7ff ffbd 	bl	8002ad0 <port_unlock>
}
 8002b56:	bd08      	pop	{r3, pc}
 8002b58:	f3af 8000 	nop.w
 8002b5c:	f3af 8000 	nop.w

08002b60 <chMsgIsPendingI>:
 * @param[in] tp        pointer to the thread
 * @return              The pending messages status.
 *
 * @iclass
 */
static inline bool chMsgIsPendingI(thread_t *tp) {
 8002b60:	b082      	sub	sp, #8
 8002b62:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(tp->p_msgqueue.p_next != (thread_t *)&tp->p_msgqueue);
 8002b64:	9b01      	ldr	r3, [sp, #4]
 8002b66:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8002b68:	9b01      	ldr	r3, [sp, #4]
 8002b6a:	3328      	adds	r3, #40	; 0x28
 8002b6c:	429a      	cmp	r2, r3
 8002b6e:	bf0c      	ite	eq
 8002b70:	2300      	moveq	r3, #0
 8002b72:	2301      	movne	r3, #1
 8002b74:	b2db      	uxtb	r3, r3
}
 8002b76:	4618      	mov	r0, r3
 8002b78:	b002      	add	sp, #8
 8002b7a:	4770      	bx	lr
 8002b7c:	f3af 8000 	nop.w

08002b80 <chMsgReleaseS>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @sclass
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {
 8002b80:	b500      	push	{lr}
 8002b82:	b083      	sub	sp, #12
 8002b84:	9001      	str	r0, [sp, #4]
 8002b86:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();

  chSchWakeupS(tp, msg);
 8002b88:	9801      	ldr	r0, [sp, #4]
 8002b8a:	9900      	ldr	r1, [sp, #0]
 8002b8c:	f7fe f8d0 	bl	8000d30 <chSchWakeupS>
}
 8002b90:	b003      	add	sp, #12
 8002b92:	f85d fb04 	ldr.w	pc, [sp], #4
 8002b96:	bf00      	nop
 8002b98:	f3af 8000 	nop.w
 8002b9c:	f3af 8000 	nop.w

08002ba0 <chMsgSend>:
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 8002ba0:	b500      	push	{lr}
 8002ba2:	b085      	sub	sp, #20
 8002ba4:	9001      	str	r0, [sp, #4]
 8002ba6:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 8002ba8:	4b13      	ldr	r3, [pc, #76]	; (8002bf8 <chMsgSend+0x58>)
 8002baa:	699b      	ldr	r3, [r3, #24]
 8002bac:	9303      	str	r3, [sp, #12]

  chDbgCheck(tp != NULL);

  chSysLock();
 8002bae:	f7ff ffc7 	bl	8002b40 <chSysLock>
  ctp->p_msg = msg;
 8002bb2:	9b03      	ldr	r3, [sp, #12]
 8002bb4:	9a00      	ldr	r2, [sp, #0]
 8002bb6:	631a      	str	r2, [r3, #48]	; 0x30
  ctp->p_u.wtobjp = &tp->p_msgqueue;
 8002bb8:	9b01      	ldr	r3, [sp, #4]
 8002bba:	f103 0228 	add.w	r2, r3, #40	; 0x28
 8002bbe:	9b03      	ldr	r3, [sp, #12]
 8002bc0:	621a      	str	r2, [r3, #32]
  msg_insert(ctp, &tp->p_msgqueue);
 8002bc2:	9b01      	ldr	r3, [sp, #4]
 8002bc4:	3328      	adds	r3, #40	; 0x28
 8002bc6:	9803      	ldr	r0, [sp, #12]
 8002bc8:	4619      	mov	r1, r3
 8002bca:	f7ff ff89 	bl	8002ae0 <queue_insert>
  if (tp->p_state == CH_STATE_WTMSG) {
 8002bce:	9b01      	ldr	r3, [sp, #4]
 8002bd0:	7f1b      	ldrb	r3, [r3, #28]
 8002bd2:	2b0e      	cmp	r3, #14
 8002bd4:	d102      	bne.n	8002bdc <chMsgSend+0x3c>
    (void) chSchReadyI(tp);
 8002bd6:	9801      	ldr	r0, [sp, #4]
 8002bd8:	f7fd ffe2 	bl	8000ba0 <chSchReadyI>
  }
  chSchGoSleepS(CH_STATE_SNDMSGQ);
 8002bdc:	200c      	movs	r0, #12
 8002bde:	f7fe f807 	bl	8000bf0 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
 8002be2:	9b03      	ldr	r3, [sp, #12]
 8002be4:	6a1b      	ldr	r3, [r3, #32]
 8002be6:	9300      	str	r3, [sp, #0]
  chSysUnlock();
 8002be8:	f7ff ffb2 	bl	8002b50 <chSysUnlock>

  return msg;
 8002bec:	9b00      	ldr	r3, [sp, #0]
}
 8002bee:	4618      	mov	r0, r3
 8002bf0:	b005      	add	sp, #20
 8002bf2:	f85d fb04 	ldr.w	pc, [sp], #4
 8002bf6:	bf00      	nop
 8002bf8:	20000d98 	.word	0x20000d98
 8002bfc:	f3af 8000 	nop.w

08002c00 <chMsgWait>:
 *
 * @return              A reference to the thread carrying the message.
 *
 * @api
 */
thread_t *chMsgWait(void) {
 8002c00:	b500      	push	{lr}
 8002c02:	b083      	sub	sp, #12
  thread_t *tp;

  chSysLock();
 8002c04:	f7ff ff9c 	bl	8002b40 <chSysLock>
  if (!chMsgIsPendingI(currp)) {
 8002c08:	4b0f      	ldr	r3, [pc, #60]	; (8002c48 <chMsgWait+0x48>)
 8002c0a:	699b      	ldr	r3, [r3, #24]
 8002c0c:	4618      	mov	r0, r3
 8002c0e:	f7ff ffa7 	bl	8002b60 <chMsgIsPendingI>
 8002c12:	4603      	mov	r3, r0
 8002c14:	f083 0301 	eor.w	r3, r3, #1
 8002c18:	b2db      	uxtb	r3, r3
 8002c1a:	2b00      	cmp	r3, #0
 8002c1c:	d002      	beq.n	8002c24 <chMsgWait+0x24>
    chSchGoSleepS(CH_STATE_WTMSG);
 8002c1e:	200e      	movs	r0, #14
 8002c20:	f7fd ffe6 	bl	8000bf0 <chSchGoSleepS>
  }
  tp = queue_fifo_remove(&currp->p_msgqueue);
 8002c24:	4b08      	ldr	r3, [pc, #32]	; (8002c48 <chMsgWait+0x48>)
 8002c26:	699b      	ldr	r3, [r3, #24]
 8002c28:	3328      	adds	r3, #40	; 0x28
 8002c2a:	4618      	mov	r0, r3
 8002c2c:	f7ff ff70 	bl	8002b10 <queue_fifo_remove>
 8002c30:	9001      	str	r0, [sp, #4]
  tp->p_state = CH_STATE_SNDMSG;
 8002c32:	9b01      	ldr	r3, [sp, #4]
 8002c34:	220d      	movs	r2, #13
 8002c36:	771a      	strb	r2, [r3, #28]
  chSysUnlock();
 8002c38:	f7ff ff8a 	bl	8002b50 <chSysUnlock>

  return tp;
 8002c3c:	9b01      	ldr	r3, [sp, #4]
}
 8002c3e:	4618      	mov	r0, r3
 8002c40:	b003      	add	sp, #12
 8002c42:	f85d fb04 	ldr.w	pc, [sp], #4
 8002c46:	bf00      	nop
 8002c48:	20000d98 	.word	0x20000d98
 8002c4c:	f3af 8000 	nop.w

08002c50 <chMsgRelease>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @api
 */
void chMsgRelease(thread_t *tp, msg_t msg) {
 8002c50:	b500      	push	{lr}
 8002c52:	b083      	sub	sp, #12
 8002c54:	9001      	str	r0, [sp, #4]
 8002c56:	9100      	str	r1, [sp, #0]

  chSysLock();
 8002c58:	f7ff ff72 	bl	8002b40 <chSysLock>
  chDbgAssert(tp->p_state == CH_STATE_SNDMSG, "invalid state");
  chMsgReleaseS(tp, msg);
 8002c5c:	9801      	ldr	r0, [sp, #4]
 8002c5e:	9900      	ldr	r1, [sp, #0]
 8002c60:	f7ff ff8e 	bl	8002b80 <chMsgReleaseS>
  chSysUnlock();
 8002c64:	f7ff ff74 	bl	8002b50 <chSysUnlock>
}
 8002c68:	b003      	add	sp, #12
 8002c6a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002c6e:	bf00      	nop

08002c70 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002c70:	b082      	sub	sp, #8
 8002c72:	2320      	movs	r3, #32
 8002c74:	9301      	str	r3, [sp, #4]
 8002c76:	9b01      	ldr	r3, [sp, #4]
 8002c78:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002c7c:	b002      	add	sp, #8
 8002c7e:	4770      	bx	lr

08002c80 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002c80:	b082      	sub	sp, #8
 8002c82:	2300      	movs	r3, #0
 8002c84:	9301      	str	r3, [sp, #4]
 8002c86:	9b01      	ldr	r3, [sp, #4]
 8002c88:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002c8c:	b002      	add	sp, #8
 8002c8e:	4770      	bx	lr

08002c90 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8002c90:	b508      	push	{r3, lr}

  port_lock();
 8002c92:	f7ff ffed 	bl	8002c70 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002c96:	bd08      	pop	{r3, pc}
 8002c98:	f3af 8000 	nop.w
 8002c9c:	f3af 8000 	nop.w

08002ca0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002ca0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8002ca2:	f7ff ffed 	bl	8002c80 <port_unlock>
}
 8002ca6:	bd08      	pop	{r3, pc}
 8002ca8:	f3af 8000 	nop.w
 8002cac:	f3af 8000 	nop.w

08002cb0 <chSemFastWaitI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastWaitI(semaphore_t *sp) {
 8002cb0:	b082      	sub	sp, #8
 8002cb2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  sp->s_cnt--;
 8002cb4:	9b01      	ldr	r3, [sp, #4]
 8002cb6:	689b      	ldr	r3, [r3, #8]
 8002cb8:	1e5a      	subs	r2, r3, #1
 8002cba:	9b01      	ldr	r3, [sp, #4]
 8002cbc:	609a      	str	r2, [r3, #8]
}
 8002cbe:	b002      	add	sp, #8
 8002cc0:	4770      	bx	lr
 8002cc2:	bf00      	nop
 8002cc4:	f3af 8000 	nop.w
 8002cc8:	f3af 8000 	nop.w
 8002ccc:	f3af 8000 	nop.w

08002cd0 <chSemGetCounterI>:
 * @param[in] sp        pointer to a @p semaphore_t structure
 * @return              The semaphore counter value.
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {
 8002cd0:	b082      	sub	sp, #8
 8002cd2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return sp->s_cnt;
 8002cd4:	9b01      	ldr	r3, [sp, #4]
 8002cd6:	689b      	ldr	r3, [r3, #8]
}
 8002cd8:	4618      	mov	r0, r3
 8002cda:	b002      	add	sp, #8
 8002cdc:	4770      	bx	lr
 8002cde:	bf00      	nop

08002ce0 <chMBObjectInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {
 8002ce0:	b500      	push	{lr}
 8002ce2:	b085      	sub	sp, #20
 8002ce4:	9003      	str	r0, [sp, #12]
 8002ce6:	9102      	str	r1, [sp, #8]
 8002ce8:	9201      	str	r2, [sp, #4]

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->mb_buffer = buf;
 8002cea:	9b03      	ldr	r3, [sp, #12]
 8002cec:	9a02      	ldr	r2, [sp, #8]
 8002cee:	601a      	str	r2, [r3, #0]
  mbp->mb_rdptr = buf;
 8002cf0:	9b03      	ldr	r3, [sp, #12]
 8002cf2:	9a02      	ldr	r2, [sp, #8]
 8002cf4:	60da      	str	r2, [r3, #12]
  mbp->mb_wrptr = buf;
 8002cf6:	9b03      	ldr	r3, [sp, #12]
 8002cf8:	9a02      	ldr	r2, [sp, #8]
 8002cfa:	609a      	str	r2, [r3, #8]
  mbp->mb_top = &buf[n];
 8002cfc:	9b01      	ldr	r3, [sp, #4]
 8002cfe:	009b      	lsls	r3, r3, #2
 8002d00:	9a02      	ldr	r2, [sp, #8]
 8002d02:	441a      	add	r2, r3
 8002d04:	9b03      	ldr	r3, [sp, #12]
 8002d06:	605a      	str	r2, [r3, #4]
  chSemObjectInit(&mbp->mb_emptysem, n);
 8002d08:	9b03      	ldr	r3, [sp, #12]
 8002d0a:	331c      	adds	r3, #28
 8002d0c:	4618      	mov	r0, r3
 8002d0e:	9901      	ldr	r1, [sp, #4]
 8002d10:	f7fe fed6 	bl	8001ac0 <chSemObjectInit>
  chSemObjectInit(&mbp->mb_fullsem, (cnt_t)0);
 8002d14:	9b03      	ldr	r3, [sp, #12]
 8002d16:	3310      	adds	r3, #16
 8002d18:	4618      	mov	r0, r3
 8002d1a:	2100      	movs	r1, #0
 8002d1c:	f7fe fed0 	bl	8001ac0 <chSemObjectInit>
}
 8002d20:	b005      	add	sp, #20
 8002d22:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d26:	bf00      	nop
 8002d28:	f3af 8000 	nop.w
 8002d2c:	f3af 8000 	nop.w

08002d30 <chMBReset>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBReset(mailbox_t *mbp) {
 8002d30:	b500      	push	{lr}
 8002d32:	b083      	sub	sp, #12
 8002d34:	9001      	str	r0, [sp, #4]

  chSysLock();
 8002d36:	f7ff ffab 	bl	8002c90 <chSysLock>
  chMBResetI(mbp);
 8002d3a:	9801      	ldr	r0, [sp, #4]
 8002d3c:	f000 f808 	bl	8002d50 <chMBResetI>
  chSchRescheduleS();
 8002d40:	f7fe f81e 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 8002d44:	f7ff ffac 	bl	8002ca0 <chSysUnlock>
}
 8002d48:	b003      	add	sp, #12
 8002d4a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d4e:	bf00      	nop

08002d50 <chMBResetI>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBResetI(mailbox_t *mbp) {
 8002d50:	b500      	push	{lr}
 8002d52:	b083      	sub	sp, #12
 8002d54:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_buffer;
 8002d56:	9b01      	ldr	r3, [sp, #4]
 8002d58:	681a      	ldr	r2, [r3, #0]
 8002d5a:	9b01      	ldr	r3, [sp, #4]
 8002d5c:	609a      	str	r2, [r3, #8]
  mbp->mb_rdptr = mbp->mb_buffer;
 8002d5e:	9b01      	ldr	r3, [sp, #4]
 8002d60:	681a      	ldr	r2, [r3, #0]
 8002d62:	9b01      	ldr	r3, [sp, #4]
 8002d64:	60da      	str	r2, [r3, #12]
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
 8002d66:	9b01      	ldr	r3, [sp, #4]
 8002d68:	f103 021c 	add.w	r2, r3, #28
 8002d6c:	9b01      	ldr	r3, [sp, #4]
 8002d6e:	685b      	ldr	r3, [r3, #4]
 8002d70:	4619      	mov	r1, r3
 8002d72:	9b01      	ldr	r3, [sp, #4]
 8002d74:	681b      	ldr	r3, [r3, #0]
 8002d76:	1acb      	subs	r3, r1, r3
 8002d78:	109b      	asrs	r3, r3, #2
 8002d7a:	4610      	mov	r0, r2
 8002d7c:	4619      	mov	r1, r3
 8002d7e:	f7fe fec7 	bl	8001b10 <chSemResetI>
  chSemResetI(&mbp->mb_fullsem, (cnt_t)0);
 8002d82:	9b01      	ldr	r3, [sp, #4]
 8002d84:	3310      	adds	r3, #16
 8002d86:	4618      	mov	r0, r3
 8002d88:	2100      	movs	r1, #0
 8002d8a:	f7fe fec1 	bl	8001b10 <chSemResetI>
}
 8002d8e:	b003      	add	sp, #12
 8002d90:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d94:	f3af 8000 	nop.w
 8002d98:	f3af 8000 	nop.w
 8002d9c:	f3af 8000 	nop.w

08002da0 <chMBPost>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8002da0:	b500      	push	{lr}
 8002da2:	b087      	sub	sp, #28
 8002da4:	9003      	str	r0, [sp, #12]
 8002da6:	9102      	str	r1, [sp, #8]
 8002da8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 8002daa:	f7ff ff71 	bl	8002c90 <chSysLock>
  rdymsg = chMBPostS(mbp, msg, timeout);
 8002dae:	9803      	ldr	r0, [sp, #12]
 8002db0:	9902      	ldr	r1, [sp, #8]
 8002db2:	9a01      	ldr	r2, [sp, #4]
 8002db4:	f000 f80c 	bl	8002dd0 <chMBPostS>
 8002db8:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 8002dba:	f7ff ff71 	bl	8002ca0 <chSysUnlock>

  return rdymsg;
 8002dbe:	9b05      	ldr	r3, [sp, #20]
}
 8002dc0:	4618      	mov	r0, r3
 8002dc2:	b007      	add	sp, #28
 8002dc4:	f85d fb04 	ldr.w	pc, [sp], #4
 8002dc8:	f3af 8000 	nop.w
 8002dcc:	f3af 8000 	nop.w

08002dd0 <chMBPostS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8002dd0:	b500      	push	{lr}
 8002dd2:	b087      	sub	sp, #28
 8002dd4:	9003      	str	r0, [sp, #12]
 8002dd6:	9102      	str	r1, [sp, #8]
 8002dd8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 8002dda:	9b03      	ldr	r3, [sp, #12]
 8002ddc:	331c      	adds	r3, #28
 8002dde:	4618      	mov	r0, r3
 8002de0:	9901      	ldr	r1, [sp, #4]
 8002de2:	f7fe ff05 	bl	8001bf0 <chSemWaitTimeoutS>
 8002de6:	9005      	str	r0, [sp, #20]
  if (rdymsg == MSG_OK) {
 8002de8:	9b05      	ldr	r3, [sp, #20]
 8002dea:	2b00      	cmp	r3, #0
 8002dec:	d117      	bne.n	8002e1e <chMBPostS+0x4e>
    *mbp->mb_wrptr++ = msg;
 8002dee:	9b03      	ldr	r3, [sp, #12]
 8002df0:	689b      	ldr	r3, [r3, #8]
 8002df2:	1d19      	adds	r1, r3, #4
 8002df4:	9a03      	ldr	r2, [sp, #12]
 8002df6:	6091      	str	r1, [r2, #8]
 8002df8:	9a02      	ldr	r2, [sp, #8]
 8002dfa:	601a      	str	r2, [r3, #0]
    if (mbp->mb_wrptr >= mbp->mb_top) {
 8002dfc:	9b03      	ldr	r3, [sp, #12]
 8002dfe:	689a      	ldr	r2, [r3, #8]
 8002e00:	9b03      	ldr	r3, [sp, #12]
 8002e02:	685b      	ldr	r3, [r3, #4]
 8002e04:	429a      	cmp	r2, r3
 8002e06:	d303      	bcc.n	8002e10 <chMBPostS+0x40>
      mbp->mb_wrptr = mbp->mb_buffer;
 8002e08:	9b03      	ldr	r3, [sp, #12]
 8002e0a:	681a      	ldr	r2, [r3, #0]
 8002e0c:	9b03      	ldr	r3, [sp, #12]
 8002e0e:	609a      	str	r2, [r3, #8]
    }
    chSemSignalI(&mbp->mb_fullsem);
 8002e10:	9b03      	ldr	r3, [sp, #12]
 8002e12:	3310      	adds	r3, #16
 8002e14:	4618      	mov	r0, r3
 8002e16:	f7fe ff3b 	bl	8001c90 <chSemSignalI>
    chSchRescheduleS();
 8002e1a:	f7fd ffb1 	bl	8000d80 <chSchRescheduleS>
  }

  return rdymsg;
 8002e1e:	9b05      	ldr	r3, [sp, #20]
}
 8002e20:	4618      	mov	r0, r3
 8002e22:	b007      	add	sp, #28
 8002e24:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e28:	f3af 8000 	nop.w
 8002e2c:	f3af 8000 	nop.w

08002e30 <chMBPostI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 8002e30:	b500      	push	{lr}
 8002e32:	b083      	sub	sp, #12
 8002e34:	9001      	str	r0, [sp, #4]
 8002e36:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
 8002e38:	9b01      	ldr	r3, [sp, #4]
 8002e3a:	331c      	adds	r3, #28
 8002e3c:	4618      	mov	r0, r3
 8002e3e:	f7ff ff47 	bl	8002cd0 <chSemGetCounterI>
 8002e42:	4603      	mov	r3, r0
 8002e44:	2b00      	cmp	r3, #0
 8002e46:	dc02      	bgt.n	8002e4e <chMBPostI+0x1e>
    return MSG_TIMEOUT;
 8002e48:	f04f 33ff 	mov.w	r3, #4294967295
 8002e4c:	e01b      	b.n	8002e86 <chMBPostI+0x56>
  }

  chSemFastWaitI(&mbp->mb_emptysem);
 8002e4e:	9b01      	ldr	r3, [sp, #4]
 8002e50:	331c      	adds	r3, #28
 8002e52:	4618      	mov	r0, r3
 8002e54:	f7ff ff2c 	bl	8002cb0 <chSemFastWaitI>
  *mbp->mb_wrptr++ = msg;
 8002e58:	9b01      	ldr	r3, [sp, #4]
 8002e5a:	689b      	ldr	r3, [r3, #8]
 8002e5c:	1d19      	adds	r1, r3, #4
 8002e5e:	9a01      	ldr	r2, [sp, #4]
 8002e60:	6091      	str	r1, [r2, #8]
 8002e62:	9a00      	ldr	r2, [sp, #0]
 8002e64:	601a      	str	r2, [r3, #0]
  if (mbp->mb_wrptr >= mbp->mb_top) {
 8002e66:	9b01      	ldr	r3, [sp, #4]
 8002e68:	689a      	ldr	r2, [r3, #8]
 8002e6a:	9b01      	ldr	r3, [sp, #4]
 8002e6c:	685b      	ldr	r3, [r3, #4]
 8002e6e:	429a      	cmp	r2, r3
 8002e70:	d303      	bcc.n	8002e7a <chMBPostI+0x4a>
     mbp->mb_wrptr = mbp->mb_buffer;
 8002e72:	9b01      	ldr	r3, [sp, #4]
 8002e74:	681a      	ldr	r2, [r3, #0]
 8002e76:	9b01      	ldr	r3, [sp, #4]
 8002e78:	609a      	str	r2, [r3, #8]
  }
  chSemSignalI(&mbp->mb_fullsem);
 8002e7a:	9b01      	ldr	r3, [sp, #4]
 8002e7c:	3310      	adds	r3, #16
 8002e7e:	4618      	mov	r0, r3
 8002e80:	f7fe ff06 	bl	8001c90 <chSemSignalI>

  return MSG_OK;
 8002e84:	2300      	movs	r3, #0
}
 8002e86:	4618      	mov	r0, r3
 8002e88:	b003      	add	sp, #12
 8002e8a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e8e:	bf00      	nop

08002e90 <chMBPostAhead>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPostAhead(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8002e90:	b500      	push	{lr}
 8002e92:	b087      	sub	sp, #28
 8002e94:	9003      	str	r0, [sp, #12]
 8002e96:	9102      	str	r1, [sp, #8]
 8002e98:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 8002e9a:	f7ff fef9 	bl	8002c90 <chSysLock>
  rdymsg = chMBPostAheadS(mbp, msg, timeout);
 8002e9e:	9803      	ldr	r0, [sp, #12]
 8002ea0:	9902      	ldr	r1, [sp, #8]
 8002ea2:	9a01      	ldr	r2, [sp, #4]
 8002ea4:	f000 f80c 	bl	8002ec0 <chMBPostAheadS>
 8002ea8:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 8002eaa:	f7ff fef9 	bl	8002ca0 <chSysUnlock>

  return rdymsg;
 8002eae:	9b05      	ldr	r3, [sp, #20]
}
 8002eb0:	4618      	mov	r0, r3
 8002eb2:	b007      	add	sp, #28
 8002eb4:	f85d fb04 	ldr.w	pc, [sp], #4
 8002eb8:	f3af 8000 	nop.w
 8002ebc:	f3af 8000 	nop.w

08002ec0 <chMBPostAheadS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostAheadS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8002ec0:	b500      	push	{lr}
 8002ec2:	b087      	sub	sp, #28
 8002ec4:	9003      	str	r0, [sp, #12]
 8002ec6:	9102      	str	r1, [sp, #8]
 8002ec8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 8002eca:	9b03      	ldr	r3, [sp, #12]
 8002ecc:	331c      	adds	r3, #28
 8002ece:	4618      	mov	r0, r3
 8002ed0:	9901      	ldr	r1, [sp, #4]
 8002ed2:	f7fe fe8d 	bl	8001bf0 <chSemWaitTimeoutS>
 8002ed6:	9005      	str	r0, [sp, #20]
  if (rdymsg == MSG_OK) {
 8002ed8:	9b05      	ldr	r3, [sp, #20]
 8002eda:	2b00      	cmp	r3, #0
 8002edc:	d11a      	bne.n	8002f14 <chMBPostAheadS+0x54>
    if (--mbp->mb_rdptr < mbp->mb_buffer) {
 8002ede:	9b03      	ldr	r3, [sp, #12]
 8002ee0:	68db      	ldr	r3, [r3, #12]
 8002ee2:	1f1a      	subs	r2, r3, #4
 8002ee4:	9b03      	ldr	r3, [sp, #12]
 8002ee6:	60da      	str	r2, [r3, #12]
 8002ee8:	9b03      	ldr	r3, [sp, #12]
 8002eea:	68da      	ldr	r2, [r3, #12]
 8002eec:	9b03      	ldr	r3, [sp, #12]
 8002eee:	681b      	ldr	r3, [r3, #0]
 8002ef0:	429a      	cmp	r2, r3
 8002ef2:	d204      	bcs.n	8002efe <chMBPostAheadS+0x3e>
      mbp->mb_rdptr = mbp->mb_top - 1;
 8002ef4:	9b03      	ldr	r3, [sp, #12]
 8002ef6:	685b      	ldr	r3, [r3, #4]
 8002ef8:	1f1a      	subs	r2, r3, #4
 8002efa:	9b03      	ldr	r3, [sp, #12]
 8002efc:	60da      	str	r2, [r3, #12]
    }
    *mbp->mb_rdptr = msg;
 8002efe:	9b03      	ldr	r3, [sp, #12]
 8002f00:	68db      	ldr	r3, [r3, #12]
 8002f02:	9a02      	ldr	r2, [sp, #8]
 8002f04:	601a      	str	r2, [r3, #0]
    chSemSignalI(&mbp->mb_fullsem);
 8002f06:	9b03      	ldr	r3, [sp, #12]
 8002f08:	3310      	adds	r3, #16
 8002f0a:	4618      	mov	r0, r3
 8002f0c:	f7fe fec0 	bl	8001c90 <chSemSignalI>
    chSchRescheduleS();
 8002f10:	f7fd ff36 	bl	8000d80 <chSchRescheduleS>
  }

  return rdymsg;
 8002f14:	9b05      	ldr	r3, [sp, #20]
}
 8002f16:	4618      	mov	r0, r3
 8002f18:	b007      	add	sp, #28
 8002f1a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002f1e:	bf00      	nop

08002f20 <chMBPostAheadI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
 8002f20:	b500      	push	{lr}
 8002f22:	b083      	sub	sp, #12
 8002f24:	9001      	str	r0, [sp, #4]
 8002f26:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
 8002f28:	9b01      	ldr	r3, [sp, #4]
 8002f2a:	331c      	adds	r3, #28
 8002f2c:	4618      	mov	r0, r3
 8002f2e:	f7ff fecf 	bl	8002cd0 <chSemGetCounterI>
 8002f32:	4603      	mov	r3, r0
 8002f34:	2b00      	cmp	r3, #0
 8002f36:	dc02      	bgt.n	8002f3e <chMBPostAheadI+0x1e>
    return MSG_TIMEOUT;
 8002f38:	f04f 33ff 	mov.w	r3, #4294967295
 8002f3c:	e01e      	b.n	8002f7c <chMBPostAheadI+0x5c>
  }
  chSemFastWaitI(&mbp->mb_emptysem);
 8002f3e:	9b01      	ldr	r3, [sp, #4]
 8002f40:	331c      	adds	r3, #28
 8002f42:	4618      	mov	r0, r3
 8002f44:	f7ff feb4 	bl	8002cb0 <chSemFastWaitI>
  if (--mbp->mb_rdptr < mbp->mb_buffer) {
 8002f48:	9b01      	ldr	r3, [sp, #4]
 8002f4a:	68db      	ldr	r3, [r3, #12]
 8002f4c:	1f1a      	subs	r2, r3, #4
 8002f4e:	9b01      	ldr	r3, [sp, #4]
 8002f50:	60da      	str	r2, [r3, #12]
 8002f52:	9b01      	ldr	r3, [sp, #4]
 8002f54:	68da      	ldr	r2, [r3, #12]
 8002f56:	9b01      	ldr	r3, [sp, #4]
 8002f58:	681b      	ldr	r3, [r3, #0]
 8002f5a:	429a      	cmp	r2, r3
 8002f5c:	d204      	bcs.n	8002f68 <chMBPostAheadI+0x48>
    mbp->mb_rdptr = mbp->mb_top - 1;
 8002f5e:	9b01      	ldr	r3, [sp, #4]
 8002f60:	685b      	ldr	r3, [r3, #4]
 8002f62:	1f1a      	subs	r2, r3, #4
 8002f64:	9b01      	ldr	r3, [sp, #4]
 8002f66:	60da      	str	r2, [r3, #12]
  }
  *mbp->mb_rdptr = msg;
 8002f68:	9b01      	ldr	r3, [sp, #4]
 8002f6a:	68db      	ldr	r3, [r3, #12]
 8002f6c:	9a00      	ldr	r2, [sp, #0]
 8002f6e:	601a      	str	r2, [r3, #0]
  chSemSignalI(&mbp->mb_fullsem);
 8002f70:	9b01      	ldr	r3, [sp, #4]
 8002f72:	3310      	adds	r3, #16
 8002f74:	4618      	mov	r0, r3
 8002f76:	f7fe fe8b 	bl	8001c90 <chSemSignalI>

  return MSG_OK;
 8002f7a:	2300      	movs	r3, #0
}
 8002f7c:	4618      	mov	r0, r3
 8002f7e:	b003      	add	sp, #12
 8002f80:	f85d fb04 	ldr.w	pc, [sp], #4
 8002f84:	f3af 8000 	nop.w
 8002f88:	f3af 8000 	nop.w
 8002f8c:	f3af 8000 	nop.w

08002f90 <chMBFetch>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 8002f90:	b500      	push	{lr}
 8002f92:	b087      	sub	sp, #28
 8002f94:	9003      	str	r0, [sp, #12]
 8002f96:	9102      	str	r1, [sp, #8]
 8002f98:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 8002f9a:	f7ff fe79 	bl	8002c90 <chSysLock>
  rdymsg = chMBFetchS(mbp, msgp, timeout);
 8002f9e:	9803      	ldr	r0, [sp, #12]
 8002fa0:	9902      	ldr	r1, [sp, #8]
 8002fa2:	9a01      	ldr	r2, [sp, #4]
 8002fa4:	f000 f80c 	bl	8002fc0 <chMBFetchS>
 8002fa8:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 8002faa:	f7ff fe79 	bl	8002ca0 <chSysUnlock>

  return rdymsg;
 8002fae:	9b05      	ldr	r3, [sp, #20]
}
 8002fb0:	4618      	mov	r0, r3
 8002fb2:	b007      	add	sp, #28
 8002fb4:	f85d fb04 	ldr.w	pc, [sp], #4
 8002fb8:	f3af 8000 	nop.w
 8002fbc:	f3af 8000 	nop.w

08002fc0 <chMBFetchS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 8002fc0:	b500      	push	{lr}
 8002fc2:	b087      	sub	sp, #28
 8002fc4:	9003      	str	r0, [sp, #12]
 8002fc6:	9102      	str	r1, [sp, #8]
 8002fc8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
 8002fca:	9b03      	ldr	r3, [sp, #12]
 8002fcc:	3310      	adds	r3, #16
 8002fce:	4618      	mov	r0, r3
 8002fd0:	9901      	ldr	r1, [sp, #4]
 8002fd2:	f7fe fe0d 	bl	8001bf0 <chSemWaitTimeoutS>
 8002fd6:	9005      	str	r0, [sp, #20]
  if (rdymsg == MSG_OK) {
 8002fd8:	9b05      	ldr	r3, [sp, #20]
 8002fda:	2b00      	cmp	r3, #0
 8002fdc:	d118      	bne.n	8003010 <chMBFetchS+0x50>
    *msgp = *mbp->mb_rdptr++;
 8002fde:	9b03      	ldr	r3, [sp, #12]
 8002fe0:	68db      	ldr	r3, [r3, #12]
 8002fe2:	1d19      	adds	r1, r3, #4
 8002fe4:	9a03      	ldr	r2, [sp, #12]
 8002fe6:	60d1      	str	r1, [r2, #12]
 8002fe8:	681a      	ldr	r2, [r3, #0]
 8002fea:	9b02      	ldr	r3, [sp, #8]
 8002fec:	601a      	str	r2, [r3, #0]
    if (mbp->mb_rdptr >= mbp->mb_top) {
 8002fee:	9b03      	ldr	r3, [sp, #12]
 8002ff0:	68da      	ldr	r2, [r3, #12]
 8002ff2:	9b03      	ldr	r3, [sp, #12]
 8002ff4:	685b      	ldr	r3, [r3, #4]
 8002ff6:	429a      	cmp	r2, r3
 8002ff8:	d303      	bcc.n	8003002 <chMBFetchS+0x42>
      mbp->mb_rdptr = mbp->mb_buffer;
 8002ffa:	9b03      	ldr	r3, [sp, #12]
 8002ffc:	681a      	ldr	r2, [r3, #0]
 8002ffe:	9b03      	ldr	r3, [sp, #12]
 8003000:	60da      	str	r2, [r3, #12]
    }
    chSemSignalI(&mbp->mb_emptysem);
 8003002:	9b03      	ldr	r3, [sp, #12]
 8003004:	331c      	adds	r3, #28
 8003006:	4618      	mov	r0, r3
 8003008:	f7fe fe42 	bl	8001c90 <chSemSignalI>
    chSchRescheduleS();
 800300c:	f7fd feb8 	bl	8000d80 <chSchRescheduleS>
  }

  return rdymsg;
 8003010:	9b05      	ldr	r3, [sp, #20]
}
 8003012:	4618      	mov	r0, r3
 8003014:	b007      	add	sp, #28
 8003016:	f85d fb04 	ldr.w	pc, [sp], #4
 800301a:	bf00      	nop
 800301c:	f3af 8000 	nop.w

08003020 <chMBFetchI>:
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
 8003020:	b500      	push	{lr}
 8003022:	b083      	sub	sp, #12
 8003024:	9001      	str	r0, [sp, #4]
 8003026:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
 8003028:	9b01      	ldr	r3, [sp, #4]
 800302a:	3310      	adds	r3, #16
 800302c:	4618      	mov	r0, r3
 800302e:	f7ff fe4f 	bl	8002cd0 <chSemGetCounterI>
 8003032:	4603      	mov	r3, r0
 8003034:	2b00      	cmp	r3, #0
 8003036:	dc02      	bgt.n	800303e <chMBFetchI+0x1e>
    return MSG_TIMEOUT;
 8003038:	f04f 33ff 	mov.w	r3, #4294967295
 800303c:	e01c      	b.n	8003078 <chMBFetchI+0x58>
  }
  chSemFastWaitI(&mbp->mb_fullsem);
 800303e:	9b01      	ldr	r3, [sp, #4]
 8003040:	3310      	adds	r3, #16
 8003042:	4618      	mov	r0, r3
 8003044:	f7ff fe34 	bl	8002cb0 <chSemFastWaitI>
  *msgp = *mbp->mb_rdptr++;
 8003048:	9b01      	ldr	r3, [sp, #4]
 800304a:	68db      	ldr	r3, [r3, #12]
 800304c:	1d19      	adds	r1, r3, #4
 800304e:	9a01      	ldr	r2, [sp, #4]
 8003050:	60d1      	str	r1, [r2, #12]
 8003052:	681a      	ldr	r2, [r3, #0]
 8003054:	9b00      	ldr	r3, [sp, #0]
 8003056:	601a      	str	r2, [r3, #0]
  if (mbp->mb_rdptr >= mbp->mb_top) {
 8003058:	9b01      	ldr	r3, [sp, #4]
 800305a:	68da      	ldr	r2, [r3, #12]
 800305c:	9b01      	ldr	r3, [sp, #4]
 800305e:	685b      	ldr	r3, [r3, #4]
 8003060:	429a      	cmp	r2, r3
 8003062:	d303      	bcc.n	800306c <chMBFetchI+0x4c>
    mbp->mb_rdptr = mbp->mb_buffer;
 8003064:	9b01      	ldr	r3, [sp, #4]
 8003066:	681a      	ldr	r2, [r3, #0]
 8003068:	9b01      	ldr	r3, [sp, #4]
 800306a:	60da      	str	r2, [r3, #12]
  }
  chSemSignalI(&mbp->mb_emptysem);
 800306c:	9b01      	ldr	r3, [sp, #4]
 800306e:	331c      	adds	r3, #28
 8003070:	4618      	mov	r0, r3
 8003072:	f7fe fe0d 	bl	8001c90 <chSemSignalI>

  return MSG_OK;
 8003076:	2300      	movs	r3, #0
}
 8003078:	4618      	mov	r0, r3
 800307a:	b003      	add	sp, #12
 800307c:	f85d fb04 	ldr.w	pc, [sp], #4

08003080 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003080:	b082      	sub	sp, #8
 8003082:	2320      	movs	r3, #32
 8003084:	9301      	str	r3, [sp, #4]
 8003086:	9b01      	ldr	r3, [sp, #4]
 8003088:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800308c:	b002      	add	sp, #8
 800308e:	4770      	bx	lr

08003090 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003090:	b082      	sub	sp, #8
 8003092:	2300      	movs	r3, #0
 8003094:	9301      	str	r3, [sp, #4]
 8003096:	9b01      	ldr	r3, [sp, #4]
 8003098:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800309c:	b002      	add	sp, #8
 800309e:	4770      	bx	lr

080030a0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 80030a0:	b082      	sub	sp, #8
 80030a2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 80030a4:	9b01      	ldr	r3, [sp, #4]
 80030a6:	9a01      	ldr	r2, [sp, #4]
 80030a8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80030aa:	9b01      	ldr	r3, [sp, #4]
 80030ac:	9a01      	ldr	r2, [sp, #4]
 80030ae:	605a      	str	r2, [r3, #4]
}
 80030b0:	b002      	add	sp, #8
 80030b2:	4770      	bx	lr
 80030b4:	f3af 8000 	nop.w
 80030b8:	f3af 8000 	nop.w
 80030bc:	f3af 8000 	nop.w

080030c0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80030c0:	b508      	push	{r3, lr}

  port_lock();
 80030c2:	f7ff ffdd 	bl	8003080 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80030c6:	bd08      	pop	{r3, pc}
 80030c8:	f3af 8000 	nop.w
 80030cc:	f3af 8000 	nop.w

080030d0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80030d0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80030d2:	f7ff ffdd 	bl	8003090 <port_unlock>
}
 80030d6:	bd08      	pop	{r3, pc}
 80030d8:	f3af 8000 	nop.w
 80030dc:	f3af 8000 	nop.w

080030e0 <chThdQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 80030e0:	b500      	push	{lr}
 80030e2:	b083      	sub	sp, #12
 80030e4:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 80030e6:	9801      	ldr	r0, [sp, #4]
 80030e8:	f7ff ffda 	bl	80030a0 <queue_init>
}
 80030ec:	b003      	add	sp, #12
 80030ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80030f2:	bf00      	nop
 80030f4:	f3af 8000 	nop.w
 80030f8:	f3af 8000 	nop.w
 80030fc:	f3af 8000 	nop.w

08003100 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 8003100:	b082      	sub	sp, #8
 8003102:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8003104:	9b01      	ldr	r3, [sp, #4]
 8003106:	689b      	ldr	r3, [r3, #8]
 8003108:	2b00      	cmp	r3, #0
 800310a:	bf14      	ite	ne
 800310c:	2300      	movne	r3, #0
 800310e:	2301      	moveq	r3, #1
 8003110:	b2db      	uxtb	r3, r3
}
 8003112:	4618      	mov	r0, r3
 8003114:	b002      	add	sp, #8
 8003116:	4770      	bx	lr
 8003118:	f3af 8000 	nop.w
 800311c:	f3af 8000 	nop.w

08003120 <chIQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {
 8003120:	b082      	sub	sp, #8
 8003122:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8003124:	9b01      	ldr	r3, [sp, #4]
 8003126:	695a      	ldr	r2, [r3, #20]
 8003128:	9b01      	ldr	r3, [sp, #4]
 800312a:	699b      	ldr	r3, [r3, #24]
 800312c:	429a      	cmp	r2, r3
 800312e:	d105      	bne.n	800313c <chIQIsFullI+0x1c>
 8003130:	9b01      	ldr	r3, [sp, #4]
 8003132:	689b      	ldr	r3, [r3, #8]
 8003134:	2b00      	cmp	r3, #0
 8003136:	d001      	beq.n	800313c <chIQIsFullI+0x1c>
 8003138:	2301      	movs	r3, #1
 800313a:	e000      	b.n	800313e <chIQIsFullI+0x1e>
 800313c:	2300      	movs	r3, #0
 800313e:	f003 0301 	and.w	r3, r3, #1
 8003142:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 8003144:	4618      	mov	r0, r3
 8003146:	b002      	add	sp, #8
 8003148:	4770      	bx	lr
 800314a:	bf00      	nop
 800314c:	f3af 8000 	nop.w

08003150 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 8003150:	b082      	sub	sp, #8
 8003152:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8003154:	9b01      	ldr	r3, [sp, #4]
 8003156:	695a      	ldr	r2, [r3, #20]
 8003158:	9b01      	ldr	r3, [sp, #4]
 800315a:	699b      	ldr	r3, [r3, #24]
 800315c:	429a      	cmp	r2, r3
 800315e:	d105      	bne.n	800316c <chOQIsEmptyI+0x1c>
 8003160:	9b01      	ldr	r3, [sp, #4]
 8003162:	689b      	ldr	r3, [r3, #8]
 8003164:	2b00      	cmp	r3, #0
 8003166:	d001      	beq.n	800316c <chOQIsEmptyI+0x1c>
 8003168:	2301      	movs	r3, #1
 800316a:	e000      	b.n	800316e <chOQIsEmptyI+0x1e>
 800316c:	2300      	movs	r3, #0
 800316e:	f003 0301 	and.w	r3, r3, #1
 8003172:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 8003174:	4618      	mov	r0, r3
 8003176:	b002      	add	sp, #8
 8003178:	4770      	bx	lr
 800317a:	bf00      	nop
 800317c:	f3af 8000 	nop.w

08003180 <chOQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
 8003180:	b082      	sub	sp, #8
 8003182:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8003184:	9b01      	ldr	r3, [sp, #4]
 8003186:	689b      	ldr	r3, [r3, #8]
 8003188:	2b00      	cmp	r3, #0
 800318a:	bf14      	ite	ne
 800318c:	2300      	movne	r3, #0
 800318e:	2301      	moveq	r3, #1
 8003190:	b2db      	uxtb	r3, r3
}
 8003192:	4618      	mov	r0, r3
 8003194:	b002      	add	sp, #8
 8003196:	4770      	bx	lr
 8003198:	f3af 8000 	nop.w
 800319c:	f3af 8000 	nop.w

080031a0 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
 80031a0:	b500      	push	{lr}
 80031a2:	b085      	sub	sp, #20
 80031a4:	9003      	str	r0, [sp, #12]
 80031a6:	9102      	str	r1, [sp, #8]
 80031a8:	9201      	str	r2, [sp, #4]
 80031aa:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&iqp->q_waiting);
 80031ac:	9b03      	ldr	r3, [sp, #12]
 80031ae:	4618      	mov	r0, r3
 80031b0:	f7ff ff96 	bl	80030e0 <chThdQueueObjectInit>
  iqp->q_counter = 0;
 80031b4:	9b03      	ldr	r3, [sp, #12]
 80031b6:	2200      	movs	r2, #0
 80031b8:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
 80031ba:	9b03      	ldr	r3, [sp, #12]
 80031bc:	9a02      	ldr	r2, [sp, #8]
 80031be:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 80031c0:	9b03      	ldr	r3, [sp, #12]
 80031c2:	9a02      	ldr	r2, [sp, #8]
 80031c4:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 80031c6:	9b03      	ldr	r3, [sp, #12]
 80031c8:	9a02      	ldr	r2, [sp, #8]
 80031ca:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 80031cc:	9a02      	ldr	r2, [sp, #8]
 80031ce:	9b01      	ldr	r3, [sp, #4]
 80031d0:	441a      	add	r2, r3
 80031d2:	9b03      	ldr	r3, [sp, #12]
 80031d4:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 80031d6:	9b03      	ldr	r3, [sp, #12]
 80031d8:	9a00      	ldr	r2, [sp, #0]
 80031da:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 80031dc:	9b03      	ldr	r3, [sp, #12]
 80031de:	9a06      	ldr	r2, [sp, #24]
 80031e0:	621a      	str	r2, [r3, #32]
}
 80031e2:	b005      	add	sp, #20
 80031e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80031e8:	f3af 8000 	nop.w
 80031ec:	f3af 8000 	nop.w

080031f0 <chIQResetI>:
 *
 * @param[in] iqp       pointer to an @p input_queue_t structure
 *
 * @iclass
 */
void chIQResetI(input_queue_t *iqp) {
 80031f0:	b500      	push	{lr}
 80031f2:	b083      	sub	sp, #12
 80031f4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
 80031f6:	9b01      	ldr	r3, [sp, #4]
 80031f8:	68da      	ldr	r2, [r3, #12]
 80031fa:	9b01      	ldr	r3, [sp, #4]
 80031fc:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr = iqp->q_buffer;
 80031fe:	9b01      	ldr	r3, [sp, #4]
 8003200:	68da      	ldr	r2, [r3, #12]
 8003202:	9b01      	ldr	r3, [sp, #4]
 8003204:	615a      	str	r2, [r3, #20]
  iqp->q_counter = 0;
 8003206:	9b01      	ldr	r3, [sp, #4]
 8003208:	2200      	movs	r2, #0
 800320a:	609a      	str	r2, [r3, #8]
  chThdDequeueAllI(&iqp->q_waiting, Q_RESET);
 800320c:	9b01      	ldr	r3, [sp, #4]
 800320e:	4618      	mov	r0, r3
 8003210:	f06f 0101 	mvn.w	r1, #1
 8003214:	f7fe f9cc 	bl	80015b0 <chThdDequeueAllI>
}
 8003218:	b003      	add	sp, #12
 800321a:	f85d fb04 	ldr.w	pc, [sp], #4
 800321e:	bf00      	nop

08003220 <chIQPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
 8003220:	b500      	push	{lr}
 8003222:	b083      	sub	sp, #12
 8003224:	9001      	str	r0, [sp, #4]
 8003226:	460b      	mov	r3, r1
 8003228:	f88d 3003 	strb.w	r3, [sp, #3]

  chDbgCheckClassI();

  if (chIQIsFullI(iqp)) {
 800322c:	9801      	ldr	r0, [sp, #4]
 800322e:	f7ff ff77 	bl	8003120 <chIQIsFullI>
 8003232:	4603      	mov	r3, r0
 8003234:	2b00      	cmp	r3, #0
 8003236:	d002      	beq.n	800323e <chIQPutI+0x1e>
    return Q_FULL;
 8003238:	f06f 0303 	mvn.w	r3, #3
 800323c:	e01c      	b.n	8003278 <chIQPutI+0x58>
  }

  iqp->q_counter++;
 800323e:	9b01      	ldr	r3, [sp, #4]
 8003240:	689b      	ldr	r3, [r3, #8]
 8003242:	1c5a      	adds	r2, r3, #1
 8003244:	9b01      	ldr	r3, [sp, #4]
 8003246:	609a      	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
 8003248:	9b01      	ldr	r3, [sp, #4]
 800324a:	695b      	ldr	r3, [r3, #20]
 800324c:	1c59      	adds	r1, r3, #1
 800324e:	9a01      	ldr	r2, [sp, #4]
 8003250:	6151      	str	r1, [r2, #20]
 8003252:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8003256:	701a      	strb	r2, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8003258:	9b01      	ldr	r3, [sp, #4]
 800325a:	695a      	ldr	r2, [r3, #20]
 800325c:	9b01      	ldr	r3, [sp, #4]
 800325e:	691b      	ldr	r3, [r3, #16]
 8003260:	429a      	cmp	r2, r3
 8003262:	d303      	bcc.n	800326c <chIQPutI+0x4c>
    iqp->q_wrptr = iqp->q_buffer;
 8003264:	9b01      	ldr	r3, [sp, #4]
 8003266:	68da      	ldr	r2, [r3, #12]
 8003268:	9b01      	ldr	r3, [sp, #4]
 800326a:	615a      	str	r2, [r3, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
 800326c:	9b01      	ldr	r3, [sp, #4]
 800326e:	4618      	mov	r0, r3
 8003270:	2100      	movs	r1, #0
 8003272:	f7fe f985 	bl	8001580 <chThdDequeueNextI>

  return Q_OK;
 8003276:	2300      	movs	r3, #0
}
 8003278:	4618      	mov	r0, r3
 800327a:	b003      	add	sp, #12
 800327c:	f85d fb04 	ldr.w	pc, [sp], #4

08003280 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8003280:	b500      	push	{lr}
 8003282:	b085      	sub	sp, #20
 8003284:	9001      	str	r0, [sp, #4]
 8003286:	9100      	str	r1, [sp, #0]
  uint8_t b;

  chSysLock();
 8003288:	f7ff ff1a 	bl	80030c0 <chSysLock>
  if (iqp->q_notify != NULL) {
 800328c:	9b01      	ldr	r3, [sp, #4]
 800328e:	69db      	ldr	r3, [r3, #28]
 8003290:	2b00      	cmp	r3, #0
 8003292:	d004      	beq.n	800329e <chIQGetTimeout+0x1e>
    iqp->q_notify(iqp);
 8003294:	9b01      	ldr	r3, [sp, #4]
 8003296:	69db      	ldr	r3, [r3, #28]
 8003298:	9801      	ldr	r0, [sp, #4]
 800329a:	4798      	blx	r3
  }

  while (chIQIsEmptyI(iqp)) {
 800329c:	e00d      	b.n	80032ba <chIQGetTimeout+0x3a>
 800329e:	e00c      	b.n	80032ba <chIQGetTimeout+0x3a>
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 80032a0:	9b01      	ldr	r3, [sp, #4]
 80032a2:	4618      	mov	r0, r3
 80032a4:	9900      	ldr	r1, [sp, #0]
 80032a6:	f7fe f94b 	bl	8001540 <chThdEnqueueTimeoutS>
 80032aa:	9003      	str	r0, [sp, #12]
    if (msg < Q_OK) {
 80032ac:	9b03      	ldr	r3, [sp, #12]
 80032ae:	2b00      	cmp	r3, #0
 80032b0:	da03      	bge.n	80032ba <chIQGetTimeout+0x3a>
      chSysUnlock();
 80032b2:	f7ff ff0d 	bl	80030d0 <chSysUnlock>
      return msg;
 80032b6:	9b03      	ldr	r3, [sp, #12]
 80032b8:	e020      	b.n	80032fc <chIQGetTimeout+0x7c>
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 80032ba:	9801      	ldr	r0, [sp, #4]
 80032bc:	f7ff ff20 	bl	8003100 <chIQIsEmptyI>
 80032c0:	4603      	mov	r3, r0
 80032c2:	2b00      	cmp	r3, #0
 80032c4:	d1ec      	bne.n	80032a0 <chIQGetTimeout+0x20>
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 80032c6:	9b01      	ldr	r3, [sp, #4]
 80032c8:	689b      	ldr	r3, [r3, #8]
 80032ca:	1e5a      	subs	r2, r3, #1
 80032cc:	9b01      	ldr	r3, [sp, #4]
 80032ce:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
 80032d0:	9b01      	ldr	r3, [sp, #4]
 80032d2:	699b      	ldr	r3, [r3, #24]
 80032d4:	1c59      	adds	r1, r3, #1
 80032d6:	9a01      	ldr	r2, [sp, #4]
 80032d8:	6191      	str	r1, [r2, #24]
 80032da:	781b      	ldrb	r3, [r3, #0]
 80032dc:	f88d 300b 	strb.w	r3, [sp, #11]
  if (iqp->q_rdptr >= iqp->q_top) {
 80032e0:	9b01      	ldr	r3, [sp, #4]
 80032e2:	699a      	ldr	r2, [r3, #24]
 80032e4:	9b01      	ldr	r3, [sp, #4]
 80032e6:	691b      	ldr	r3, [r3, #16]
 80032e8:	429a      	cmp	r2, r3
 80032ea:	d303      	bcc.n	80032f4 <chIQGetTimeout+0x74>
    iqp->q_rdptr = iqp->q_buffer;
 80032ec:	9b01      	ldr	r3, [sp, #4]
 80032ee:	68da      	ldr	r2, [r3, #12]
 80032f0:	9b01      	ldr	r3, [sp, #4]
 80032f2:	619a      	str	r2, [r3, #24]
  }
  chSysUnlock();
 80032f4:	f7ff feec 	bl	80030d0 <chSysUnlock>

  return (msg_t)b;
 80032f8:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 80032fc:	4618      	mov	r0, r3
 80032fe:	b005      	add	sp, #20
 8003300:	f85d fb04 	ldr.w	pc, [sp], #4
 8003304:	f3af 8000 	nop.w
 8003308:	f3af 8000 	nop.w
 800330c:	f3af 8000 	nop.w

08003310 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 8003310:	b500      	push	{lr}
 8003312:	b087      	sub	sp, #28
 8003314:	9003      	str	r0, [sp, #12]
 8003316:	9102      	str	r1, [sp, #8]
 8003318:	9201      	str	r2, [sp, #4]
 800331a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = iqp->q_notify;
 800331c:	9b03      	ldr	r3, [sp, #12]
 800331e:	69db      	ldr	r3, [r3, #28]
 8003320:	9304      	str	r3, [sp, #16]
  size_t r = 0;
 8003322:	2300      	movs	r3, #0
 8003324:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);

  chSysLock();
 8003326:	f7ff fecb 	bl	80030c0 <chSysLock>
  while (true) {
    if (nfy != NULL) {
 800332a:	9b04      	ldr	r3, [sp, #16]
 800332c:	2b00      	cmp	r3, #0
 800332e:	d003      	beq.n	8003338 <chIQReadTimeout+0x28>
      nfy(iqp);
 8003330:	9b04      	ldr	r3, [sp, #16]
 8003332:	9803      	ldr	r0, [sp, #12]
 8003334:	4798      	blx	r3
    }

    while (chIQIsEmptyI(iqp)) {
 8003336:	e00c      	b.n	8003352 <chIQReadTimeout+0x42>
 8003338:	e00b      	b.n	8003352 <chIQReadTimeout+0x42>
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 800333a:	9b03      	ldr	r3, [sp, #12]
 800333c:	4618      	mov	r0, r3
 800333e:	9900      	ldr	r1, [sp, #0]
 8003340:	f7fe f8fe 	bl	8001540 <chThdEnqueueTimeoutS>
 8003344:	4603      	mov	r3, r0
 8003346:	2b00      	cmp	r3, #0
 8003348:	d003      	beq.n	8003352 <chIQReadTimeout+0x42>
        chSysUnlock();
 800334a:	f7ff fec1 	bl	80030d0 <chSysUnlock>
        return r;
 800334e:	9b05      	ldr	r3, [sp, #20]
 8003350:	e02e      	b.n	80033b0 <chIQReadTimeout+0xa0>
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 8003352:	9803      	ldr	r0, [sp, #12]
 8003354:	f7ff fed4 	bl	8003100 <chIQIsEmptyI>
 8003358:	4603      	mov	r3, r0
 800335a:	2b00      	cmp	r3, #0
 800335c:	d1ed      	bne.n	800333a <chIQReadTimeout+0x2a>
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 800335e:	9b03      	ldr	r3, [sp, #12]
 8003360:	689b      	ldr	r3, [r3, #8]
 8003362:	1e5a      	subs	r2, r3, #1
 8003364:	9b03      	ldr	r3, [sp, #12]
 8003366:	609a      	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
 8003368:	9b02      	ldr	r3, [sp, #8]
 800336a:	1c5a      	adds	r2, r3, #1
 800336c:	9202      	str	r2, [sp, #8]
 800336e:	9a03      	ldr	r2, [sp, #12]
 8003370:	6992      	ldr	r2, [r2, #24]
 8003372:	1c50      	adds	r0, r2, #1
 8003374:	9903      	ldr	r1, [sp, #12]
 8003376:	6188      	str	r0, [r1, #24]
 8003378:	7812      	ldrb	r2, [r2, #0]
 800337a:	701a      	strb	r2, [r3, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 800337c:	9b03      	ldr	r3, [sp, #12]
 800337e:	699a      	ldr	r2, [r3, #24]
 8003380:	9b03      	ldr	r3, [sp, #12]
 8003382:	691b      	ldr	r3, [r3, #16]
 8003384:	429a      	cmp	r2, r3
 8003386:	d303      	bcc.n	8003390 <chIQReadTimeout+0x80>
      iqp->q_rdptr = iqp->q_buffer;
 8003388:	9b03      	ldr	r3, [sp, #12]
 800338a:	68da      	ldr	r2, [r3, #12]
 800338c:	9b03      	ldr	r3, [sp, #12]
 800338e:	619a      	str	r2, [r3, #24]
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 8003390:	f7ff fe9e 	bl	80030d0 <chSysUnlock>

    r++;
 8003394:	9b05      	ldr	r3, [sp, #20]
 8003396:	3301      	adds	r3, #1
 8003398:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 800339a:	9b01      	ldr	r3, [sp, #4]
 800339c:	3b01      	subs	r3, #1
 800339e:	9301      	str	r3, [sp, #4]
 80033a0:	9b01      	ldr	r3, [sp, #4]
 80033a2:	2b00      	cmp	r3, #0
 80033a4:	d101      	bne.n	80033aa <chIQReadTimeout+0x9a>
      return r;
 80033a6:	9b05      	ldr	r3, [sp, #20]
 80033a8:	e002      	b.n	80033b0 <chIQReadTimeout+0xa0>
    }

    chSysLock();
 80033aa:	f7ff fe89 	bl	80030c0 <chSysLock>
  }
 80033ae:	e7bc      	b.n	800332a <chIQReadTimeout+0x1a>
}
 80033b0:	4618      	mov	r0, r3
 80033b2:	b007      	add	sp, #28
 80033b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80033b8:	f3af 8000 	nop.w
 80033bc:	f3af 8000 	nop.w

080033c0 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
 80033c0:	b500      	push	{lr}
 80033c2:	b085      	sub	sp, #20
 80033c4:	9003      	str	r0, [sp, #12]
 80033c6:	9102      	str	r1, [sp, #8]
 80033c8:	9201      	str	r2, [sp, #4]
 80033ca:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&oqp->q_waiting);
 80033cc:	9b03      	ldr	r3, [sp, #12]
 80033ce:	4618      	mov	r0, r3
 80033d0:	f7ff fe86 	bl	80030e0 <chThdQueueObjectInit>
  oqp->q_counter = size;
 80033d4:	9b03      	ldr	r3, [sp, #12]
 80033d6:	9a01      	ldr	r2, [sp, #4]
 80033d8:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 80033da:	9b03      	ldr	r3, [sp, #12]
 80033dc:	9a02      	ldr	r2, [sp, #8]
 80033de:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 80033e0:	9b03      	ldr	r3, [sp, #12]
 80033e2:	9a02      	ldr	r2, [sp, #8]
 80033e4:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 80033e6:	9b03      	ldr	r3, [sp, #12]
 80033e8:	9a02      	ldr	r2, [sp, #8]
 80033ea:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 80033ec:	9a02      	ldr	r2, [sp, #8]
 80033ee:	9b01      	ldr	r3, [sp, #4]
 80033f0:	441a      	add	r2, r3
 80033f2:	9b03      	ldr	r3, [sp, #12]
 80033f4:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 80033f6:	9b03      	ldr	r3, [sp, #12]
 80033f8:	9a00      	ldr	r2, [sp, #0]
 80033fa:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 80033fc:	9b03      	ldr	r3, [sp, #12]
 80033fe:	9a06      	ldr	r2, [sp, #24]
 8003400:	621a      	str	r2, [r3, #32]
}
 8003402:	b005      	add	sp, #20
 8003404:	f85d fb04 	ldr.w	pc, [sp], #4
 8003408:	f3af 8000 	nop.w
 800340c:	f3af 8000 	nop.w

08003410 <chOQResetI>:
 *
 * @param[in] oqp       pointer to an @p output_queue_t structure
 *
 * @iclass
 */
void chOQResetI(output_queue_t *oqp) {
 8003410:	b500      	push	{lr}
 8003412:	b083      	sub	sp, #12
 8003414:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
 8003416:	9b01      	ldr	r3, [sp, #4]
 8003418:	68da      	ldr	r2, [r3, #12]
 800341a:	9b01      	ldr	r3, [sp, #4]
 800341c:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr = oqp->q_buffer;
 800341e:	9b01      	ldr	r3, [sp, #4]
 8003420:	68da      	ldr	r2, [r3, #12]
 8003422:	9b01      	ldr	r3, [sp, #4]
 8003424:	615a      	str	r2, [r3, #20]
  oqp->q_counter = chQSizeX(oqp);
 8003426:	9b01      	ldr	r3, [sp, #4]
 8003428:	691b      	ldr	r3, [r3, #16]
 800342a:	461a      	mov	r2, r3
 800342c:	9b01      	ldr	r3, [sp, #4]
 800342e:	68db      	ldr	r3, [r3, #12]
 8003430:	1ad3      	subs	r3, r2, r3
 8003432:	461a      	mov	r2, r3
 8003434:	9b01      	ldr	r3, [sp, #4]
 8003436:	609a      	str	r2, [r3, #8]
  chThdDequeueAllI(&oqp->q_waiting, Q_RESET);
 8003438:	9b01      	ldr	r3, [sp, #4]
 800343a:	4618      	mov	r0, r3
 800343c:	f06f 0101 	mvn.w	r1, #1
 8003440:	f7fe f8b6 	bl	80015b0 <chThdDequeueAllI>
}
 8003444:	b003      	add	sp, #12
 8003446:	f85d fb04 	ldr.w	pc, [sp], #4
 800344a:	bf00      	nop
 800344c:	f3af 8000 	nop.w

08003450 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8003450:	b500      	push	{lr}
 8003452:	b087      	sub	sp, #28
 8003454:	9003      	str	r0, [sp, #12]
 8003456:	460b      	mov	r3, r1
 8003458:	9201      	str	r2, [sp, #4]
 800345a:	f88d 300b 	strb.w	r3, [sp, #11]

  chSysLock();
 800345e:	f7ff fe2f 	bl	80030c0 <chSysLock>
  while (chOQIsFullI(oqp)) {
 8003462:	e00c      	b.n	800347e <chOQPutTimeout+0x2e>
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8003464:	9b03      	ldr	r3, [sp, #12]
 8003466:	4618      	mov	r0, r3
 8003468:	9901      	ldr	r1, [sp, #4]
 800346a:	f7fe f869 	bl	8001540 <chThdEnqueueTimeoutS>
 800346e:	9005      	str	r0, [sp, #20]
    if (msg < Q_OK) {
 8003470:	9b05      	ldr	r3, [sp, #20]
 8003472:	2b00      	cmp	r3, #0
 8003474:	da03      	bge.n	800347e <chOQPutTimeout+0x2e>
      chSysUnlock();
 8003476:	f7ff fe2b 	bl	80030d0 <chSysUnlock>
      return msg;
 800347a:	9b05      	ldr	r3, [sp, #20]
 800347c:	e027      	b.n	80034ce <chOQPutTimeout+0x7e>
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 800347e:	9803      	ldr	r0, [sp, #12]
 8003480:	f7ff fe7e 	bl	8003180 <chOQIsFullI>
 8003484:	4603      	mov	r3, r0
 8003486:	2b00      	cmp	r3, #0
 8003488:	d1ec      	bne.n	8003464 <chOQPutTimeout+0x14>
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 800348a:	9b03      	ldr	r3, [sp, #12]
 800348c:	689b      	ldr	r3, [r3, #8]
 800348e:	1e5a      	subs	r2, r3, #1
 8003490:	9b03      	ldr	r3, [sp, #12]
 8003492:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
 8003494:	9b03      	ldr	r3, [sp, #12]
 8003496:	695b      	ldr	r3, [r3, #20]
 8003498:	1c59      	adds	r1, r3, #1
 800349a:	9a03      	ldr	r2, [sp, #12]
 800349c:	6151      	str	r1, [r2, #20]
 800349e:	f89d 200b 	ldrb.w	r2, [sp, #11]
 80034a2:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 80034a4:	9b03      	ldr	r3, [sp, #12]
 80034a6:	695a      	ldr	r2, [r3, #20]
 80034a8:	9b03      	ldr	r3, [sp, #12]
 80034aa:	691b      	ldr	r3, [r3, #16]
 80034ac:	429a      	cmp	r2, r3
 80034ae:	d303      	bcc.n	80034b8 <chOQPutTimeout+0x68>
    oqp->q_wrptr = oqp->q_buffer;
 80034b0:	9b03      	ldr	r3, [sp, #12]
 80034b2:	68da      	ldr	r2, [r3, #12]
 80034b4:	9b03      	ldr	r3, [sp, #12]
 80034b6:	615a      	str	r2, [r3, #20]
  }

  if (oqp->q_notify != NULL) {
 80034b8:	9b03      	ldr	r3, [sp, #12]
 80034ba:	69db      	ldr	r3, [r3, #28]
 80034bc:	2b00      	cmp	r3, #0
 80034be:	d003      	beq.n	80034c8 <chOQPutTimeout+0x78>
    oqp->q_notify(oqp);
 80034c0:	9b03      	ldr	r3, [sp, #12]
 80034c2:	69db      	ldr	r3, [r3, #28]
 80034c4:	9803      	ldr	r0, [sp, #12]
 80034c6:	4798      	blx	r3
  }
  chSysUnlock();
 80034c8:	f7ff fe02 	bl	80030d0 <chSysUnlock>

  return Q_OK;
 80034cc:	2300      	movs	r3, #0
}
 80034ce:	4618      	mov	r0, r3
 80034d0:	b007      	add	sp, #28
 80034d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80034d6:	bf00      	nop
 80034d8:	f3af 8000 	nop.w
 80034dc:	f3af 8000 	nop.w

080034e0 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
 80034e0:	b500      	push	{lr}
 80034e2:	b085      	sub	sp, #20
 80034e4:	9001      	str	r0, [sp, #4]
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp)) {
 80034e6:	9801      	ldr	r0, [sp, #4]
 80034e8:	f7ff fe32 	bl	8003150 <chOQIsEmptyI>
 80034ec:	4603      	mov	r3, r0
 80034ee:	2b00      	cmp	r3, #0
 80034f0:	d002      	beq.n	80034f8 <chOQGetI+0x18>
    return Q_EMPTY;
 80034f2:	f06f 0302 	mvn.w	r3, #2
 80034f6:	e01d      	b.n	8003534 <chOQGetI+0x54>
  }

  oqp->q_counter++;
 80034f8:	9b01      	ldr	r3, [sp, #4]
 80034fa:	689b      	ldr	r3, [r3, #8]
 80034fc:	1c5a      	adds	r2, r3, #1
 80034fe:	9b01      	ldr	r3, [sp, #4]
 8003500:	609a      	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
 8003502:	9b01      	ldr	r3, [sp, #4]
 8003504:	699b      	ldr	r3, [r3, #24]
 8003506:	1c59      	adds	r1, r3, #1
 8003508:	9a01      	ldr	r2, [sp, #4]
 800350a:	6191      	str	r1, [r2, #24]
 800350c:	781b      	ldrb	r3, [r3, #0]
 800350e:	f88d 300f 	strb.w	r3, [sp, #15]
  if (oqp->q_rdptr >= oqp->q_top) {
 8003512:	9b01      	ldr	r3, [sp, #4]
 8003514:	699a      	ldr	r2, [r3, #24]
 8003516:	9b01      	ldr	r3, [sp, #4]
 8003518:	691b      	ldr	r3, [r3, #16]
 800351a:	429a      	cmp	r2, r3
 800351c:	d303      	bcc.n	8003526 <chOQGetI+0x46>
    oqp->q_rdptr = oqp->q_buffer;
 800351e:	9b01      	ldr	r3, [sp, #4]
 8003520:	68da      	ldr	r2, [r3, #12]
 8003522:	9b01      	ldr	r3, [sp, #4]
 8003524:	619a      	str	r2, [r3, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
 8003526:	9b01      	ldr	r3, [sp, #4]
 8003528:	4618      	mov	r0, r3
 800352a:	2100      	movs	r1, #0
 800352c:	f7fe f828 	bl	8001580 <chThdDequeueNextI>

  return (msg_t)b;
 8003530:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8003534:	4618      	mov	r0, r3
 8003536:	b005      	add	sp, #20
 8003538:	f85d fb04 	ldr.w	pc, [sp], #4
 800353c:	f3af 8000 	nop.w

08003540 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8003540:	b500      	push	{lr}
 8003542:	b087      	sub	sp, #28
 8003544:	9003      	str	r0, [sp, #12]
 8003546:	9102      	str	r1, [sp, #8]
 8003548:	9201      	str	r2, [sp, #4]
 800354a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = oqp->q_notify;
 800354c:	9b03      	ldr	r3, [sp, #12]
 800354e:	69db      	ldr	r3, [r3, #28]
 8003550:	9304      	str	r3, [sp, #16]
  size_t w = 0;
 8003552:	2300      	movs	r3, #0
 8003554:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);

  chSysLock();
 8003556:	f7ff fdb3 	bl	80030c0 <chSysLock>
  while (true) {
    while (chOQIsFullI(oqp)) {
 800355a:	e00b      	b.n	8003574 <chOQWriteTimeout+0x34>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 800355c:	9b03      	ldr	r3, [sp, #12]
 800355e:	4618      	mov	r0, r3
 8003560:	9900      	ldr	r1, [sp, #0]
 8003562:	f7fd ffed 	bl	8001540 <chThdEnqueueTimeoutS>
 8003566:	4603      	mov	r3, r0
 8003568:	2b00      	cmp	r3, #0
 800356a:	d003      	beq.n	8003574 <chOQWriteTimeout+0x34>
        chSysUnlock();
 800356c:	f7ff fdb0 	bl	80030d0 <chSysUnlock>
        return w;
 8003570:	9b05      	ldr	r3, [sp, #20]
 8003572:	e035      	b.n	80035e0 <chOQWriteTimeout+0xa0>

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8003574:	9803      	ldr	r0, [sp, #12]
 8003576:	f7ff fe03 	bl	8003180 <chOQIsFullI>
 800357a:	4603      	mov	r3, r0
 800357c:	2b00      	cmp	r3, #0
 800357e:	d1ed      	bne.n	800355c <chOQWriteTimeout+0x1c>
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8003580:	9b03      	ldr	r3, [sp, #12]
 8003582:	689b      	ldr	r3, [r3, #8]
 8003584:	1e5a      	subs	r2, r3, #1
 8003586:	9b03      	ldr	r3, [sp, #12]
 8003588:	609a      	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
 800358a:	9b03      	ldr	r3, [sp, #12]
 800358c:	695b      	ldr	r3, [r3, #20]
 800358e:	1c59      	adds	r1, r3, #1
 8003590:	9a03      	ldr	r2, [sp, #12]
 8003592:	6151      	str	r1, [r2, #20]
 8003594:	9a02      	ldr	r2, [sp, #8]
 8003596:	1c51      	adds	r1, r2, #1
 8003598:	9102      	str	r1, [sp, #8]
 800359a:	7812      	ldrb	r2, [r2, #0]
 800359c:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 800359e:	9b03      	ldr	r3, [sp, #12]
 80035a0:	695a      	ldr	r2, [r3, #20]
 80035a2:	9b03      	ldr	r3, [sp, #12]
 80035a4:	691b      	ldr	r3, [r3, #16]
 80035a6:	429a      	cmp	r2, r3
 80035a8:	d303      	bcc.n	80035b2 <chOQWriteTimeout+0x72>
      oqp->q_wrptr = oqp->q_buffer;
 80035aa:	9b03      	ldr	r3, [sp, #12]
 80035ac:	68da      	ldr	r2, [r3, #12]
 80035ae:	9b03      	ldr	r3, [sp, #12]
 80035b0:	615a      	str	r2, [r3, #20]
    }

    if (nfy != NULL) {
 80035b2:	9b04      	ldr	r3, [sp, #16]
 80035b4:	2b00      	cmp	r3, #0
 80035b6:	d002      	beq.n	80035be <chOQWriteTimeout+0x7e>
      nfy(oqp);
 80035b8:	9b04      	ldr	r3, [sp, #16]
 80035ba:	9803      	ldr	r0, [sp, #12]
 80035bc:	4798      	blx	r3
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 80035be:	f7ff fd87 	bl	80030d0 <chSysUnlock>

    w++;
 80035c2:	9b05      	ldr	r3, [sp, #20]
 80035c4:	3301      	adds	r3, #1
 80035c6:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 80035c8:	9b01      	ldr	r3, [sp, #4]
 80035ca:	3b01      	subs	r3, #1
 80035cc:	9301      	str	r3, [sp, #4]
 80035ce:	9b01      	ldr	r3, [sp, #4]
 80035d0:	2b00      	cmp	r3, #0
 80035d2:	d101      	bne.n	80035d8 <chOQWriteTimeout+0x98>
      return w;
 80035d4:	9b05      	ldr	r3, [sp, #20]
 80035d6:	e003      	b.n	80035e0 <chOQWriteTimeout+0xa0>
    }
    chSysLock();
 80035d8:	f7ff fd72 	bl	80030c0 <chSysLock>
  }
 80035dc:	bf00      	nop

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 80035de:	e7c9      	b.n	8003574 <chOQWriteTimeout+0x34>
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 80035e0:	4618      	mov	r0, r3
 80035e2:	b007      	add	sp, #28
 80035e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80035e8:	f3af 8000 	nop.w
 80035ec:	f3af 8000 	nop.w

080035f0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80035f0:	b082      	sub	sp, #8
 80035f2:	2320      	movs	r3, #32
 80035f4:	9301      	str	r3, [sp, #4]
 80035f6:	9b01      	ldr	r3, [sp, #4]
 80035f8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80035fc:	b002      	add	sp, #8
 80035fe:	4770      	bx	lr

08003600 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003600:	b082      	sub	sp, #8
 8003602:	2300      	movs	r3, #0
 8003604:	9301      	str	r3, [sp, #4]
 8003606:	9b01      	ldr	r3, [sp, #4]
 8003608:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800360c:	b002      	add	sp, #8
 800360e:	4770      	bx	lr

08003610 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8003610:	b508      	push	{r3, lr}

  port_lock();
 8003612:	f7ff ffed 	bl	80035f0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8003616:	bd08      	pop	{r3, pc}
 8003618:	f3af 8000 	nop.w
 800361c:	f3af 8000 	nop.w

08003620 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8003620:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8003622:	f7ff ffed 	bl	8003600 <port_unlock>
}
 8003626:	bd08      	pop	{r3, pc}
 8003628:	f3af 8000 	nop.w
 800362c:	f3af 8000 	nop.w

08003630 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8003630:	4b06      	ldr	r3, [pc, #24]	; (800364c <_core_init+0x1c>)
 8003632:	3307      	adds	r3, #7
 8003634:	f023 0307 	bic.w	r3, r3, #7
 8003638:	461a      	mov	r2, r3
 800363a:	4b05      	ldr	r3, [pc, #20]	; (8003650 <_core_init+0x20>)
 800363c:	601a      	str	r2, [r3, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 800363e:	4b05      	ldr	r3, [pc, #20]	; (8003654 <_core_init+0x24>)
 8003640:	f023 0307 	bic.w	r3, r3, #7
 8003644:	461a      	mov	r2, r3
 8003646:	4b04      	ldr	r3, [pc, #16]	; (8003658 <_core_init+0x28>)
 8003648:	601a      	str	r2, [r3, #0]

  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_CFG_MEMCORE_SIZE) /
                              MEM_ALIGN_SIZE];
#endif
}
 800364a:	4770      	bx	lr
 800364c:	200018a8 	.word	0x200018a8
 8003650:	20000900 	.word	0x20000900
 8003654:	20018000 	.word	0x20018000
 8003658:	20000904 	.word	0x20000904
 800365c:	f3af 8000 	nop.w

08003660 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8003660:	b500      	push	{lr}
 8003662:	b085      	sub	sp, #20
 8003664:	9001      	str	r0, [sp, #4]
  void *p;

  chSysLock();
 8003666:	f7ff ffd3 	bl	8003610 <chSysLock>
  p = chCoreAllocI(size);
 800366a:	9801      	ldr	r0, [sp, #4]
 800366c:	f000 f808 	bl	8003680 <chCoreAllocI>
 8003670:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8003672:	f7ff ffd5 	bl	8003620 <chSysUnlock>

  return p;
 8003676:	9b03      	ldr	r3, [sp, #12]
}
 8003678:	4618      	mov	r0, r3
 800367a:	b005      	add	sp, #20
 800367c:	f85d fb04 	ldr.w	pc, [sp], #4

08003680 <chCoreAllocI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
 8003680:	b084      	sub	sp, #16
 8003682:	9001      	str	r0, [sp, #4]
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8003684:	9b01      	ldr	r3, [sp, #4]
 8003686:	3307      	adds	r3, #7
 8003688:	f023 0307 	bic.w	r3, r3, #7
 800368c:	9301      	str	r3, [sp, #4]
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 800368e:	4b0c      	ldr	r3, [pc, #48]	; (80036c0 <chCoreAllocI+0x40>)
 8003690:	681b      	ldr	r3, [r3, #0]
 8003692:	461a      	mov	r2, r3
 8003694:	4b0b      	ldr	r3, [pc, #44]	; (80036c4 <chCoreAllocI+0x44>)
 8003696:	681b      	ldr	r3, [r3, #0]
 8003698:	1ad3      	subs	r3, r2, r3
 800369a:	461a      	mov	r2, r3
 800369c:	9b01      	ldr	r3, [sp, #4]
 800369e:	429a      	cmp	r2, r3
 80036a0:	d201      	bcs.n	80036a6 <chCoreAllocI+0x26>
  /*lint -restore*/
    return NULL;
 80036a2:	2300      	movs	r3, #0
 80036a4:	e009      	b.n	80036ba <chCoreAllocI+0x3a>
  }
  p = nextmem;
 80036a6:	4b07      	ldr	r3, [pc, #28]	; (80036c4 <chCoreAllocI+0x44>)
 80036a8:	681b      	ldr	r3, [r3, #0]
 80036aa:	9303      	str	r3, [sp, #12]
  nextmem += size;
 80036ac:	4b05      	ldr	r3, [pc, #20]	; (80036c4 <chCoreAllocI+0x44>)
 80036ae:	681a      	ldr	r2, [r3, #0]
 80036b0:	9b01      	ldr	r3, [sp, #4]
 80036b2:	441a      	add	r2, r3
 80036b4:	4b03      	ldr	r3, [pc, #12]	; (80036c4 <chCoreAllocI+0x44>)
 80036b6:	601a      	str	r2, [r3, #0]

  return p;
 80036b8:	9b03      	ldr	r3, [sp, #12]
}
 80036ba:	4618      	mov	r0, r3
 80036bc:	b004      	add	sp, #16
 80036be:	4770      	bx	lr
 80036c0:	20000904 	.word	0x20000904
 80036c4:	20000900 	.word	0x20000900
 80036c8:	f3af 8000 	nop.w
 80036cc:	f3af 8000 	nop.w

080036d0 <chCoreGetStatusX>:
 * @xclass
 */
size_t chCoreGetStatusX(void) {

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(endmem - nextmem);
 80036d0:	4b03      	ldr	r3, [pc, #12]	; (80036e0 <chCoreGetStatusX+0x10>)
 80036d2:	681b      	ldr	r3, [r3, #0]
 80036d4:	461a      	mov	r2, r3
 80036d6:	4b03      	ldr	r3, [pc, #12]	; (80036e4 <chCoreGetStatusX+0x14>)
 80036d8:	681b      	ldr	r3, [r3, #0]
 80036da:	1ad3      	subs	r3, r2, r3
  /*lint -restore*/
}
 80036dc:	4618      	mov	r0, r3
 80036de:	4770      	bx	lr
 80036e0:	20000904 	.word	0x20000904
 80036e4:	20000900 	.word	0x20000900
 80036e8:	f3af 8000 	nop.w
 80036ec:	f3af 8000 	nop.w

080036f0 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 80036f0:	b508      	push	{r3, lr}

  default_heap.h_provider = chCoreAlloc;
 80036f2:	4b06      	ldr	r3, [pc, #24]	; (800370c <_heap_init+0x1c>)
 80036f4:	4a06      	ldr	r2, [pc, #24]	; (8003710 <_heap_init+0x20>)
 80036f6:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
 80036f8:	4b04      	ldr	r3, [pc, #16]	; (800370c <_heap_init+0x1c>)
 80036fa:	2200      	movs	r2, #0
 80036fc:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 80036fe:	4b03      	ldr	r3, [pc, #12]	; (800370c <_heap_init+0x1c>)
 8003700:	2200      	movs	r2, #0
 8003702:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8003704:	4803      	ldr	r0, [pc, #12]	; (8003714 <_heap_init+0x24>)
 8003706:	f7fe fbf3 	bl	8001ef0 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.h_sem, (cnt_t)1);
#endif
}
 800370a:	bd08      	pop	{r3, pc}
 800370c:	20000908 	.word	0x20000908
 8003710:	08003661 	.word	0x08003661
 8003714:	20000918 	.word	0x20000918
 8003718:	f3af 8000 	nop.w
 800371c:	f3af 8000 	nop.w

08003720 <chHeapObjectInit>:
 * @param[in] buf       heap buffer base
 * @param[in] size      heap size
 *
 * @init
 */
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
 8003720:	b500      	push	{lr}
 8003722:	b087      	sub	sp, #28
 8003724:	9003      	str	r0, [sp, #12]
 8003726:	9102      	str	r1, [sp, #8]
 8003728:	9201      	str	r2, [sp, #4]
  union heap_header *hp = buf;
 800372a:	9b02      	ldr	r3, [sp, #8]
 800372c:	9305      	str	r3, [sp, #20]

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 800372e:	9b03      	ldr	r3, [sp, #12]
 8003730:	2200      	movs	r2, #0
 8003732:	601a      	str	r2, [r3, #0]
  heapp->h_free.h.u.next = hp;
 8003734:	9b03      	ldr	r3, [sp, #12]
 8003736:	9a05      	ldr	r2, [sp, #20]
 8003738:	609a      	str	r2, [r3, #8]
  heapp->h_free.h.size = 0;
 800373a:	9b03      	ldr	r3, [sp, #12]
 800373c:	2200      	movs	r2, #0
 800373e:	60da      	str	r2, [r3, #12]
  hp->h.u.next = NULL;
 8003740:	9b05      	ldr	r3, [sp, #20]
 8003742:	2200      	movs	r2, #0
 8003744:	601a      	str	r2, [r3, #0]
  hp->h.size = size - sizeof(union heap_header);
 8003746:	9b01      	ldr	r3, [sp, #4]
 8003748:	f1a3 0208 	sub.w	r2, r3, #8
 800374c:	9b05      	ldr	r3, [sp, #20]
 800374e:	605a      	str	r2, [r3, #4]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&heapp->h_mtx);
 8003750:	9b03      	ldr	r3, [sp, #12]
 8003752:	3310      	adds	r3, #16
 8003754:	4618      	mov	r0, r3
 8003756:	f7fe fbcb 	bl	8001ef0 <chMtxObjectInit>
#else
  chSemObjectInit(&heapp->h_sem, (cnt_t)1);
#endif
}
 800375a:	b007      	add	sp, #28
 800375c:	f85d fb04 	ldr.w	pc, [sp], #4

08003760 <chHeapAlloc>:
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
 8003760:	b500      	push	{lr}
 8003762:	b087      	sub	sp, #28
 8003764:	9001      	str	r0, [sp, #4]
 8003766:	9100      	str	r1, [sp, #0]
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL) {
 8003768:	9b01      	ldr	r3, [sp, #4]
 800376a:	2b00      	cmp	r3, #0
 800376c:	d101      	bne.n	8003772 <chHeapAlloc+0x12>
    heapp = &default_heap;
 800376e:	4b37      	ldr	r3, [pc, #220]	; (800384c <chHeapAlloc+0xec>)
 8003770:	9301      	str	r3, [sp, #4]
  }

  size = MEM_ALIGN_NEXT(size);
 8003772:	9b00      	ldr	r3, [sp, #0]
 8003774:	3307      	adds	r3, #7
 8003776:	f023 0307 	bic.w	r3, r3, #7
 800377a:	9300      	str	r3, [sp, #0]
  qp = &heapp->h_free;
 800377c:	9b01      	ldr	r3, [sp, #4]
 800377e:	3308      	adds	r3, #8
 8003780:	9305      	str	r3, [sp, #20]

  H_LOCK(heapp);
 8003782:	9b01      	ldr	r3, [sp, #4]
 8003784:	3310      	adds	r3, #16
 8003786:	4618      	mov	r0, r3
 8003788:	f7fe fbc2 	bl	8001f10 <chMtxLock>
  while (qp->h.u.next != NULL) {
 800378c:	e036      	b.n	80037fc <chHeapAlloc+0x9c>
    hp = qp->h.u.next;
 800378e:	9b05      	ldr	r3, [sp, #20]
 8003790:	681b      	ldr	r3, [r3, #0]
 8003792:	9304      	str	r3, [sp, #16]
    if (hp->h.size >= size) {
 8003794:	9b04      	ldr	r3, [sp, #16]
 8003796:	685a      	ldr	r2, [r3, #4]
 8003798:	9b00      	ldr	r3, [sp, #0]
 800379a:	429a      	cmp	r2, r3
 800379c:	d32c      	bcc.n	80037f8 <chHeapAlloc+0x98>
      if (hp->h.size < (size + sizeof(union heap_header))) {
 800379e:	9b04      	ldr	r3, [sp, #16]
 80037a0:	685a      	ldr	r2, [r3, #4]
 80037a2:	9b00      	ldr	r3, [sp, #0]
 80037a4:	3308      	adds	r3, #8
 80037a6:	429a      	cmp	r2, r3
 80037a8:	d204      	bcs.n	80037b4 <chHeapAlloc+0x54>
        /* Gets the whole block even if it is slightly bigger than the
           requested size because the fragment would be too small to be
           useful.*/
        qp->h.u.next = hp->h.u.next;
 80037aa:	9b04      	ldr	r3, [sp, #16]
 80037ac:	681a      	ldr	r2, [r3, #0]
 80037ae:	9b05      	ldr	r3, [sp, #20]
 80037b0:	601a      	str	r2, [r3, #0]
 80037b2:	e016      	b.n	80037e2 <chHeapAlloc+0x82>
      }
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
 80037b4:	9b00      	ldr	r3, [sp, #0]
 80037b6:	3308      	adds	r3, #8
 80037b8:	9a04      	ldr	r2, [sp, #16]
 80037ba:	4413      	add	r3, r2
 80037bc:	9303      	str	r3, [sp, #12]
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
 80037be:	9b04      	ldr	r3, [sp, #16]
 80037c0:	681a      	ldr	r2, [r3, #0]
 80037c2:	9b03      	ldr	r3, [sp, #12]
 80037c4:	601a      	str	r2, [r3, #0]
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 80037c6:	9b04      	ldr	r3, [sp, #16]
 80037c8:	685a      	ldr	r2, [r3, #4]
 80037ca:	9b00      	ldr	r3, [sp, #0]
 80037cc:	1ad3      	subs	r3, r2, r3
 80037ce:	f1a3 0208 	sub.w	r2, r3, #8
 80037d2:	9b03      	ldr	r3, [sp, #12]
 80037d4:	605a      	str	r2, [r3, #4]
        qp->h.u.next = fp;
 80037d6:	9b05      	ldr	r3, [sp, #20]
 80037d8:	9a03      	ldr	r2, [sp, #12]
 80037da:	601a      	str	r2, [r3, #0]
        hp->h.size = size;
 80037dc:	9b04      	ldr	r3, [sp, #16]
 80037de:	9a00      	ldr	r2, [sp, #0]
 80037e0:	605a      	str	r2, [r3, #4]
      }
      hp->h.u.heap = heapp;
 80037e2:	9b04      	ldr	r3, [sp, #16]
 80037e4:	9a01      	ldr	r2, [sp, #4]
 80037e6:	601a      	str	r2, [r3, #0]
      H_UNLOCK(heapp);
 80037e8:	9b01      	ldr	r3, [sp, #4]
 80037ea:	3310      	adds	r3, #16
 80037ec:	4618      	mov	r0, r3
 80037ee:	f7fe fc37 	bl	8002060 <chMtxUnlock>

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)(hp + 1);
 80037f2:	9b04      	ldr	r3, [sp, #16]
 80037f4:	3308      	adds	r3, #8
 80037f6:	e024      	b.n	8003842 <chHeapAlloc+0xe2>
      /*lint -restore*/
    }
    qp = hp;
 80037f8:	9b04      	ldr	r3, [sp, #16]
 80037fa:	9305      	str	r3, [sp, #20]

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
 80037fc:	9b05      	ldr	r3, [sp, #20]
 80037fe:	681b      	ldr	r3, [r3, #0]
 8003800:	2b00      	cmp	r3, #0
 8003802:	d1c4      	bne.n	800378e <chHeapAlloc+0x2e>
      return (void *)(hp + 1);
      /*lint -restore*/
    }
    qp = hp;
  }
  H_UNLOCK(heapp);
 8003804:	9b01      	ldr	r3, [sp, #4]
 8003806:	3310      	adds	r3, #16
 8003808:	4618      	mov	r0, r3
 800380a:	f7fe fc29 	bl	8002060 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider != NULL) {
 800380e:	9b01      	ldr	r3, [sp, #4]
 8003810:	681b      	ldr	r3, [r3, #0]
 8003812:	2b00      	cmp	r3, #0
 8003814:	d014      	beq.n	8003840 <chHeapAlloc+0xe0>
    hp = heapp->h_provider(size + sizeof(union heap_header));
 8003816:	9b01      	ldr	r3, [sp, #4]
 8003818:	681b      	ldr	r3, [r3, #0]
 800381a:	9a00      	ldr	r2, [sp, #0]
 800381c:	3208      	adds	r2, #8
 800381e:	4610      	mov	r0, r2
 8003820:	4798      	blx	r3
 8003822:	9004      	str	r0, [sp, #16]
    if (hp != NULL) {
 8003824:	9b04      	ldr	r3, [sp, #16]
 8003826:	2b00      	cmp	r3, #0
 8003828:	d00a      	beq.n	8003840 <chHeapAlloc+0xe0>
      hp->h.u.heap = heapp;
 800382a:	9b04      	ldr	r3, [sp, #16]
 800382c:	9a01      	ldr	r2, [sp, #4]
 800382e:	601a      	str	r2, [r3, #0]
      hp->h.size = size;
 8003830:	9b04      	ldr	r3, [sp, #16]
 8003832:	9a00      	ldr	r2, [sp, #0]
 8003834:	605a      	str	r2, [r3, #4]
      hp++;
 8003836:	9b04      	ldr	r3, [sp, #16]
 8003838:	3308      	adds	r3, #8
 800383a:	9304      	str	r3, [sp, #16]

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)hp;
 800383c:	9b04      	ldr	r3, [sp, #16]
 800383e:	e000      	b.n	8003842 <chHeapAlloc+0xe2>
      /*lint -restore*/
    }
  }

  return NULL;
 8003840:	2300      	movs	r3, #0
}
 8003842:	4618      	mov	r0, r3
 8003844:	b007      	add	sp, #28
 8003846:	f85d fb04 	ldr.w	pc, [sp], #4
 800384a:	bf00      	nop
 800384c:	20000908 	.word	0x20000908

08003850 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8003850:	b500      	push	{lr}
 8003852:	b087      	sub	sp, #28
 8003854:	9001      	str	r0, [sp, #4]
  memory_heap_t *heapp;

  chDbgCheck(p != NULL);

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
 8003856:	9b01      	ldr	r3, [sp, #4]
 8003858:	3b08      	subs	r3, #8
 800385a:	9304      	str	r3, [sp, #16]
  /*lint -restore*/
  heapp = hp->h.u.heap;
 800385c:	9b04      	ldr	r3, [sp, #16]
 800385e:	681b      	ldr	r3, [r3, #0]
 8003860:	9303      	str	r3, [sp, #12]
  qp = &heapp->h_free;
 8003862:	9b03      	ldr	r3, [sp, #12]
 8003864:	3308      	adds	r3, #8
 8003866:	9305      	str	r3, [sp, #20]

  H_LOCK(heapp);
 8003868:	9b03      	ldr	r3, [sp, #12]
 800386a:	3310      	adds	r3, #16
 800386c:	4618      	mov	r0, r3
 800386e:	f7fe fb4f 	bl	8001f10 <chMtxLock>
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 8003872:	9b03      	ldr	r3, [sp, #12]
 8003874:	f103 0208 	add.w	r2, r3, #8
 8003878:	9b05      	ldr	r3, [sp, #20]
 800387a:	429a      	cmp	r2, r3
 800387c:	d003      	beq.n	8003886 <chHeapFree+0x36>
 800387e:	9a04      	ldr	r2, [sp, #16]
 8003880:	9b05      	ldr	r3, [sp, #20]
 8003882:	429a      	cmp	r2, r3
 8003884:	d93e      	bls.n	8003904 <chHeapFree+0xb4>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 8003886:	9b05      	ldr	r3, [sp, #20]
 8003888:	681b      	ldr	r3, [r3, #0]

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 800388a:	2b00      	cmp	r3, #0
 800388c:	d004      	beq.n	8003898 <chHeapFree+0x48>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 800388e:	9b05      	ldr	r3, [sp, #20]
 8003890:	681a      	ldr	r2, [r3, #0]
 8003892:	9b04      	ldr	r3, [sp, #16]
 8003894:	429a      	cmp	r2, r3
 8003896:	d935      	bls.n	8003904 <chHeapFree+0xb4>
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
 8003898:	9b05      	ldr	r3, [sp, #20]
 800389a:	681a      	ldr	r2, [r3, #0]
 800389c:	9b04      	ldr	r3, [sp, #16]
 800389e:	601a      	str	r2, [r3, #0]
      qp->h.u.next = hp;
 80038a0:	9b05      	ldr	r3, [sp, #20]
 80038a2:	9a04      	ldr	r2, [sp, #16]
 80038a4:	601a      	str	r2, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 80038a6:	9b04      	ldr	r3, [sp, #16]
 80038a8:	685b      	ldr	r3, [r3, #4]
 80038aa:	3308      	adds	r3, #8
 80038ac:	9a04      	ldr	r2, [sp, #16]
 80038ae:	441a      	add	r2, r3
 80038b0:	9b04      	ldr	r3, [sp, #16]
 80038b2:	681b      	ldr	r3, [r3, #0]
 80038b4:	429a      	cmp	r2, r3
 80038b6:	d10e      	bne.n	80038d6 <chHeapFree+0x86>
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 80038b8:	9b04      	ldr	r3, [sp, #16]
 80038ba:	685a      	ldr	r2, [r3, #4]
 80038bc:	9b04      	ldr	r3, [sp, #16]
 80038be:	681b      	ldr	r3, [r3, #0]
 80038c0:	685b      	ldr	r3, [r3, #4]
 80038c2:	4413      	add	r3, r2
 80038c4:	f103 0208 	add.w	r2, r3, #8
 80038c8:	9b04      	ldr	r3, [sp, #16]
 80038ca:	605a      	str	r2, [r3, #4]
        hp->h.u.next = hp->h.u.next->h.u.next;
 80038cc:	9b04      	ldr	r3, [sp, #16]
 80038ce:	681b      	ldr	r3, [r3, #0]
 80038d0:	681a      	ldr	r2, [r3, #0]
 80038d2:	9b04      	ldr	r3, [sp, #16]
 80038d4:	601a      	str	r2, [r3, #0]
      }
      if ((LIMIT(qp) == hp)) {
 80038d6:	9b05      	ldr	r3, [sp, #20]
 80038d8:	685b      	ldr	r3, [r3, #4]
 80038da:	3308      	adds	r3, #8
 80038dc:	9a05      	ldr	r2, [sp, #20]
 80038de:	441a      	add	r2, r3
 80038e0:	9b04      	ldr	r3, [sp, #16]
 80038e2:	429a      	cmp	r2, r3
 80038e4:	d10d      	bne.n	8003902 <chHeapFree+0xb2>
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 80038e6:	9b05      	ldr	r3, [sp, #20]
 80038e8:	685a      	ldr	r2, [r3, #4]
 80038ea:	9b04      	ldr	r3, [sp, #16]
 80038ec:	685b      	ldr	r3, [r3, #4]
 80038ee:	4413      	add	r3, r2
 80038f0:	f103 0208 	add.w	r2, r3, #8
 80038f4:	9b05      	ldr	r3, [sp, #20]
 80038f6:	605a      	str	r2, [r3, #4]
        qp->h.u.next = hp->h.u.next;
 80038f8:	9b04      	ldr	r3, [sp, #16]
 80038fa:	681a      	ldr	r2, [r3, #0]
 80038fc:	9b05      	ldr	r3, [sp, #20]
 80038fe:	601a      	str	r2, [r3, #0]
      }
      break;
 8003900:	e004      	b.n	800390c <chHeapFree+0xbc>
 8003902:	e003      	b.n	800390c <chHeapFree+0xbc>
    }
    qp = qp->h.u.next;
 8003904:	9b05      	ldr	r3, [sp, #20]
 8003906:	681b      	ldr	r3, [r3, #0]
 8003908:	9305      	str	r3, [sp, #20]
  }
 800390a:	e7b2      	b.n	8003872 <chHeapFree+0x22>
  H_UNLOCK(heapp);
 800390c:	9b03      	ldr	r3, [sp, #12]
 800390e:	3310      	adds	r3, #16
 8003910:	4618      	mov	r0, r3
 8003912:	f7fe fba5 	bl	8002060 <chMtxUnlock>

  return;
 8003916:	bf00      	nop
}
 8003918:	b007      	add	sp, #28
 800391a:	f85d fb04 	ldr.w	pc, [sp], #4
 800391e:	bf00      	nop

08003920 <chHeapStatus>:
 *                      fragmented free space
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *sizep) {
 8003920:	b500      	push	{lr}
 8003922:	b087      	sub	sp, #28
 8003924:	9001      	str	r0, [sp, #4]
 8003926:	9100      	str	r1, [sp, #0]
  union heap_header *qp;
  size_t n, sz;

  if (heapp == NULL) {
 8003928:	9b01      	ldr	r3, [sp, #4]
 800392a:	2b00      	cmp	r3, #0
 800392c:	d101      	bne.n	8003932 <chHeapStatus+0x12>
    heapp = &default_heap;
 800392e:	4b17      	ldr	r3, [pc, #92]	; (800398c <chHeapStatus+0x6c>)
 8003930:	9301      	str	r3, [sp, #4]
  }

  H_LOCK(heapp);
 8003932:	9b01      	ldr	r3, [sp, #4]
 8003934:	3310      	adds	r3, #16
 8003936:	4618      	mov	r0, r3
 8003938:	f7fe faea 	bl	8001f10 <chMtxLock>
  sz = 0;
 800393c:	2300      	movs	r3, #0
 800393e:	9303      	str	r3, [sp, #12]
  n = 0;
 8003940:	2300      	movs	r3, #0
 8003942:	9304      	str	r3, [sp, #16]
  qp = &heapp->h_free;
 8003944:	9b01      	ldr	r3, [sp, #4]
 8003946:	3308      	adds	r3, #8
 8003948:	9305      	str	r3, [sp, #20]
  while (qp->h.u.next != NULL) {
 800394a:	e00b      	b.n	8003964 <chHeapStatus+0x44>
    sz += qp->h.u.next->h.size;
 800394c:	9b05      	ldr	r3, [sp, #20]
 800394e:	681b      	ldr	r3, [r3, #0]
 8003950:	685b      	ldr	r3, [r3, #4]
 8003952:	9a03      	ldr	r2, [sp, #12]
 8003954:	4413      	add	r3, r2
 8003956:	9303      	str	r3, [sp, #12]
    n++;
 8003958:	9b04      	ldr	r3, [sp, #16]
 800395a:	3301      	adds	r3, #1
 800395c:	9304      	str	r3, [sp, #16]
    qp = qp->h.u.next;
 800395e:	9b05      	ldr	r3, [sp, #20]
 8003960:	681b      	ldr	r3, [r3, #0]
 8003962:	9305      	str	r3, [sp, #20]

  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 8003964:	9b05      	ldr	r3, [sp, #20]
 8003966:	681b      	ldr	r3, [r3, #0]
 8003968:	2b00      	cmp	r3, #0
 800396a:	d1ef      	bne.n	800394c <chHeapStatus+0x2c>
    sz += qp->h.u.next->h.size;
    n++;
    qp = qp->h.u.next;
  }
  if (sizep != NULL) {
 800396c:	9b00      	ldr	r3, [sp, #0]
 800396e:	2b00      	cmp	r3, #0
 8003970:	d002      	beq.n	8003978 <chHeapStatus+0x58>
    *sizep = sz;
 8003972:	9b00      	ldr	r3, [sp, #0]
 8003974:	9a03      	ldr	r2, [sp, #12]
 8003976:	601a      	str	r2, [r3, #0]
  }
  H_UNLOCK(heapp);
 8003978:	9b01      	ldr	r3, [sp, #4]
 800397a:	3310      	adds	r3, #16
 800397c:	4618      	mov	r0, r3
 800397e:	f7fe fb6f 	bl	8002060 <chMtxUnlock>

  return n;
 8003982:	9b04      	ldr	r3, [sp, #16]
}
 8003984:	4618      	mov	r0, r3
 8003986:	b007      	add	sp, #28
 8003988:	f85d fb04 	ldr.w	pc, [sp], #4
 800398c:	20000908 	.word	0x20000908

08003990 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003990:	b082      	sub	sp, #8
 8003992:	2320      	movs	r3, #32
 8003994:	9301      	str	r3, [sp, #4]
 8003996:	9b01      	ldr	r3, [sp, #4]
 8003998:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800399c:	b002      	add	sp, #8
 800399e:	4770      	bx	lr

080039a0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80039a0:	b082      	sub	sp, #8
 80039a2:	2300      	movs	r3, #0
 80039a4:	9301      	str	r3, [sp, #4]
 80039a6:	9b01      	ldr	r3, [sp, #4]
 80039a8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80039ac:	b002      	add	sp, #8
 80039ae:	4770      	bx	lr

080039b0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80039b0:	b508      	push	{r3, lr}

  port_lock();
 80039b2:	f7ff ffed 	bl	8003990 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80039b6:	bd08      	pop	{r3, pc}
 80039b8:	f3af 8000 	nop.w
 80039bc:	f3af 8000 	nop.w

080039c0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80039c0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80039c2:	f7ff ffed 	bl	80039a0 <port_unlock>
}
 80039c6:	bd08      	pop	{r3, pc}
 80039c8:	f3af 8000 	nop.w
 80039cc:	f3af 8000 	nop.w

080039d0 <chPoolAdd>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be added
 *
 * @api
 */
static inline void chPoolAdd(memory_pool_t *mp, void *objp) {
 80039d0:	b500      	push	{lr}
 80039d2:	b083      	sub	sp, #12
 80039d4:	9001      	str	r0, [sp, #4]
 80039d6:	9100      	str	r1, [sp, #0]

  chPoolFree(mp, objp);
 80039d8:	9801      	ldr	r0, [sp, #4]
 80039da:	9900      	ldr	r1, [sp, #0]
 80039dc:	f000 f870 	bl	8003ac0 <chPoolFree>
}
 80039e0:	b003      	add	sp, #12
 80039e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80039e6:	bf00      	nop
 80039e8:	f3af 8000 	nop.w
 80039ec:	f3af 8000 	nop.w

080039f0 <chPoolObjectInit>:
 *                      @p NULL if the pool is not allowed to grow
 *                      automatically
 *
 * @init
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {
 80039f0:	b084      	sub	sp, #16
 80039f2:	9003      	str	r0, [sp, #12]
 80039f4:	9102      	str	r1, [sp, #8]
 80039f6:	9201      	str	r2, [sp, #4]

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 80039f8:	9b03      	ldr	r3, [sp, #12]
 80039fa:	2200      	movs	r2, #0
 80039fc:	601a      	str	r2, [r3, #0]
  mp->mp_object_size = size;
 80039fe:	9b03      	ldr	r3, [sp, #12]
 8003a00:	9a02      	ldr	r2, [sp, #8]
 8003a02:	605a      	str	r2, [r3, #4]
  mp->mp_provider = provider;
 8003a04:	9b03      	ldr	r3, [sp, #12]
 8003a06:	9a01      	ldr	r2, [sp, #4]
 8003a08:	609a      	str	r2, [r3, #8]
}
 8003a0a:	b004      	add	sp, #16
 8003a0c:	4770      	bx	lr
 8003a0e:	bf00      	nop

08003a10 <chPoolLoadArray>:
 * @param[in] p         pointer to the array first element
 * @param[in] n         number of elements in the array
 *
 * @api
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {
 8003a10:	b500      	push	{lr}
 8003a12:	b085      	sub	sp, #20
 8003a14:	9003      	str	r0, [sp, #12]
 8003a16:	9102      	str	r1, [sp, #8]
 8003a18:	9201      	str	r2, [sp, #4]

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8003a1a:	e00b      	b.n	8003a34 <chPoolLoadArray+0x24>
    chPoolAdd(mp, p);
 8003a1c:	9803      	ldr	r0, [sp, #12]
 8003a1e:	9902      	ldr	r1, [sp, #8]
 8003a20:	f7ff ffd6 	bl	80039d0 <chPoolAdd>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
 8003a24:	9b03      	ldr	r3, [sp, #12]
 8003a26:	685b      	ldr	r3, [r3, #4]
 8003a28:	9a02      	ldr	r2, [sp, #8]
 8003a2a:	4413      	add	r3, r2
 8003a2c:	9302      	str	r3, [sp, #8]
    /*lint -restore*/
    n--;
 8003a2e:	9b01      	ldr	r3, [sp, #4]
 8003a30:	3b01      	subs	r3, #1
 8003a32:	9301      	str	r3, [sp, #4]
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8003a34:	9b01      	ldr	r3, [sp, #4]
 8003a36:	2b00      	cmp	r3, #0
 8003a38:	d1f0      	bne.n	8003a1c <chPoolLoadArray+0xc>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
    /*lint -restore*/
    n--;
  }
}
 8003a3a:	b005      	add	sp, #20
 8003a3c:	f85d fb04 	ldr.w	pc, [sp], #4

08003a40 <chPoolAllocI>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(memory_pool_t *mp) {
 8003a40:	b500      	push	{lr}
 8003a42:	b085      	sub	sp, #20
 8003a44:	9001      	str	r0, [sp, #4]
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);

  objp = mp->mp_next;
 8003a46:	9b01      	ldr	r3, [sp, #4]
 8003a48:	681b      	ldr	r3, [r3, #0]
 8003a4a:	9303      	str	r3, [sp, #12]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 8003a4c:	9b03      	ldr	r3, [sp, #12]
 8003a4e:	2b00      	cmp	r3, #0
 8003a50:	d005      	beq.n	8003a5e <chPoolAllocI+0x1e>
    mp->mp_next = mp->mp_next->ph_next;
 8003a52:	9b01      	ldr	r3, [sp, #4]
 8003a54:	681b      	ldr	r3, [r3, #0]
 8003a56:	681a      	ldr	r2, [r3, #0]
 8003a58:	9b01      	ldr	r3, [sp, #4]
 8003a5a:	601a      	str	r2, [r3, #0]
 8003a5c:	e00a      	b.n	8003a74 <chPoolAllocI+0x34>
  }
  else if (mp->mp_provider != NULL) {
 8003a5e:	9b01      	ldr	r3, [sp, #4]
 8003a60:	689b      	ldr	r3, [r3, #8]
 8003a62:	2b00      	cmp	r3, #0
 8003a64:	d006      	beq.n	8003a74 <chPoolAllocI+0x34>
    objp = mp->mp_provider(mp->mp_object_size);
 8003a66:	9b01      	ldr	r3, [sp, #4]
 8003a68:	689b      	ldr	r3, [r3, #8]
 8003a6a:	9a01      	ldr	r2, [sp, #4]
 8003a6c:	6852      	ldr	r2, [r2, #4]
 8003a6e:	4610      	mov	r0, r2
 8003a70:	4798      	blx	r3
 8003a72:	9003      	str	r0, [sp, #12]
  }
  /*lint -restore*/

  return objp;
 8003a74:	9b03      	ldr	r3, [sp, #12]
}
 8003a76:	4618      	mov	r0, r3
 8003a78:	b005      	add	sp, #20
 8003a7a:	f85d fb04 	ldr.w	pc, [sp], #4
 8003a7e:	bf00      	nop

08003a80 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
 8003a80:	b500      	push	{lr}
 8003a82:	b085      	sub	sp, #20
 8003a84:	9001      	str	r0, [sp, #4]
  void *objp;

  chSysLock();
 8003a86:	f7ff ff93 	bl	80039b0 <chSysLock>
  objp = chPoolAllocI(mp);
 8003a8a:	9801      	ldr	r0, [sp, #4]
 8003a8c:	f7ff ffd8 	bl	8003a40 <chPoolAllocI>
 8003a90:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8003a92:	f7ff ff95 	bl	80039c0 <chSysUnlock>

  return objp;
 8003a96:	9b03      	ldr	r3, [sp, #12]
}
 8003a98:	4618      	mov	r0, r3
 8003a9a:	b005      	add	sp, #20
 8003a9c:	f85d fb04 	ldr.w	pc, [sp], #4

08003aa0 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 8003aa0:	b084      	sub	sp, #16
 8003aa2:	9001      	str	r0, [sp, #4]
 8003aa4:	9100      	str	r1, [sp, #0]
  struct pool_header *php = objp;
 8003aa6:	9b00      	ldr	r3, [sp, #0]
 8003aa8:	9303      	str	r3, [sp, #12]

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 8003aaa:	9b01      	ldr	r3, [sp, #4]
 8003aac:	681a      	ldr	r2, [r3, #0]
 8003aae:	9b03      	ldr	r3, [sp, #12]
 8003ab0:	601a      	str	r2, [r3, #0]
  mp->mp_next = php;
 8003ab2:	9b01      	ldr	r3, [sp, #4]
 8003ab4:	9a03      	ldr	r2, [sp, #12]
 8003ab6:	601a      	str	r2, [r3, #0]
}
 8003ab8:	b004      	add	sp, #16
 8003aba:	4770      	bx	lr
 8003abc:	f3af 8000 	nop.w

08003ac0 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
 8003ac0:	b500      	push	{lr}
 8003ac2:	b083      	sub	sp, #12
 8003ac4:	9001      	str	r0, [sp, #4]
 8003ac6:	9100      	str	r1, [sp, #0]

  chSysLock();
 8003ac8:	f7ff ff72 	bl	80039b0 <chSysLock>
  chPoolFreeI(mp, objp);
 8003acc:	9801      	ldr	r0, [sp, #4]
 8003ace:	9900      	ldr	r1, [sp, #0]
 8003ad0:	f7ff ffe6 	bl	8003aa0 <chPoolFreeI>
  chSysUnlock();
 8003ad4:	f7ff ff74 	bl	80039c0 <chSysUnlock>
}
 8003ad8:	b003      	add	sp, #12
 8003ada:	f85d fb04 	ldr.w	pc, [sp], #4
 8003ade:	bf00      	nop

08003ae0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003ae0:	b082      	sub	sp, #8
 8003ae2:	2320      	movs	r3, #32
 8003ae4:	9301      	str	r3, [sp, #4]
 8003ae6:	9b01      	ldr	r3, [sp, #4]
 8003ae8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003aec:	b002      	add	sp, #8
 8003aee:	4770      	bx	lr

08003af0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003af0:	b082      	sub	sp, #8
 8003af2:	2300      	movs	r3, #0
 8003af4:	9301      	str	r3, [sp, #4]
 8003af6:	9b01      	ldr	r3, [sp, #4]
 8003af8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003afc:	b002      	add	sp, #8
 8003afe:	4770      	bx	lr

08003b00 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8003b00:	b508      	push	{r3, lr}

  port_lock();
 8003b02:	f7ff ffed 	bl	8003ae0 <port_lock>
}
 8003b06:	bd08      	pop	{r3, pc}
 8003b08:	f3af 8000 	nop.w
 8003b0c:	f3af 8000 	nop.w

08003b10 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8003b10:	b508      	push	{r3, lr}

  port_unlock();
 8003b12:	f7ff ffed 	bl	8003af0 <port_unlock>
}
 8003b16:	bd08      	pop	{r3, pc}
 8003b18:	f3af 8000 	nop.w
 8003b1c:	f3af 8000 	nop.w

08003b20 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 8003b20:	b510      	push	{r4, lr}
 8003b22:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003b24:	f3ef 8309 	mrs	r3, PSP
 8003b28:	461c      	mov	r4, r3
  return(result);
 8003b2a:	4623      	mov	r3, r4
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
#endif

  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();
 8003b2c:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8003b2e:	9b01      	ldr	r3, [sp, #4]
 8003b30:	3320      	adds	r3, #32
 8003b32:	9301      	str	r3, [sp, #4]

  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);
 8003b34:	9b01      	ldr	r3, [sp, #4]
 8003b36:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8003b38:	9b00      	ldr	r3, [sp, #0]
 8003b3a:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 8003b3e:	f7ff ffe7 	bl	8003b10 <port_unlock_from_isr>
}
 8003b42:	b002      	add	sp, #8
 8003b44:	bd10      	pop	{r4, pc}
 8003b46:	bf00      	nop
 8003b48:	f3af 8000 	nop.w
 8003b4c:	f3af 8000 	nop.w

08003b50 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8003b50:	b510      	push	{r4, lr}
 8003b52:	b082      	sub	sp, #8

  port_lock_from_isr();
 8003b54:	f7ff ffd4 	bl	8003b00 <port_lock_from_isr>
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8003b58:	4b13      	ldr	r3, [pc, #76]	; (8003ba8 <_port_irq_epilogue+0x58>)
 8003b5a:	685b      	ldr	r3, [r3, #4]
 8003b5c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8003b60:	2b00      	cmp	r3, #0
 8003b62:	d01d      	beq.n	8003ba0 <_port_irq_epilogue+0x50>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003b64:	f3ef 8309 	mrs	r3, PSP
 8003b68:	461c      	mov	r4, r3
  return(result);
 8003b6a:	4623      	mov	r3, r4
      /* Enforcing a lazy FPU state save by accessing the FPCSR register.*/
      (void) __get_FPSCR();
#endif

    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 8003b6c:	9301      	str	r3, [sp, #4]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8003b6e:	9b01      	ldr	r3, [sp, #4]
 8003b70:	3b20      	subs	r3, #32
 8003b72:	9301      	str	r3, [sp, #4]

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8003b74:	9b01      	ldr	r3, [sp, #4]
 8003b76:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8003b7a:	61da      	str	r2, [r3, #28]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
#endif

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 8003b7c:	9b01      	ldr	r3, [sp, #4]
 8003b7e:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8003b80:	9b00      	ldr	r3, [sp, #0]
 8003b82:	f383 8809 	msr	PSP, r3

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8003b86:	f7fd f90b 	bl	8000da0 <chSchIsPreemptionRequired>
 8003b8a:	4603      	mov	r3, r0
 8003b8c:	2b00      	cmp	r3, #0
 8003b8e:	d003      	beq.n	8003b98 <_port_irq_epilogue+0x48>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8003b90:	9b01      	ldr	r3, [sp, #4]
 8003b92:	4a06      	ldr	r2, [pc, #24]	; (8003bac <_port_irq_epilogue+0x5c>)
 8003b94:	619a      	str	r2, [r3, #24]
      ctxp->pc = (regarm_t)_port_exit_from_isr;
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
 8003b96:	e005      	b.n	8003ba4 <_port_irq_epilogue+0x54>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8003b98:	9b01      	ldr	r3, [sp, #4]
 8003b9a:	4a05      	ldr	r2, [pc, #20]	; (8003bb0 <_port_irq_epilogue+0x60>)
 8003b9c:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
 8003b9e:	e001      	b.n	8003ba4 <_port_irq_epilogue+0x54>
  }
  port_unlock_from_isr();
 8003ba0:	f7ff ffb6 	bl	8003b10 <port_unlock_from_isr>
}
 8003ba4:	b002      	add	sp, #8
 8003ba6:	bd10      	pop	{r4, pc}
 8003ba8:	e000ed00 	.word	0xe000ed00
 8003bac:	08000301 	.word	0x08000301
 8003bb0:	08000304 	.word	0x08000304
 8003bb4:	f3af 8000 	nop.w
 8003bb8:	f3af 8000 	nop.w
 8003bbc:	f3af 8000 	nop.w

08003bc0 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 8003bc0:	4770      	bx	lr
 8003bc2:	bf00      	nop
 8003bc4:	f3af 8000 	nop.w
 8003bc8:	f3af 8000 	nop.w
 8003bcc:	f3af 8000 	nop.w

08003bd0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8003bd0:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8003bd2:	f7ff fff5 	bl	8003bc0 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 8003bd6:	f003 fa7b 	bl	80070d0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 8003bda:	4808      	ldr	r0, [pc, #32]	; (8003bfc <halInit+0x2c>)
 8003bdc:	f004 f840 	bl	8007c60 <_pal_lld_init>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 8003be0:	f002 f906 	bl	8005df0 <sdInit>
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
 8003be4:	f001 fd6c 	bl	80056c0 <sdcInit>
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
 8003be8:	f002 fa5a 	bl	80060a0 <spiInit>
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
#endif
#if (HAL_USE_USB == TRUE) || defined(__DOXYGEN__)
  usbInit();
 8003bec:	f002 fe48 	bl	8006880 <usbInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8003bf0:	f007 f9c6 	bl	800af80 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8003bf4:	f000 f82c 	bl	8003c50 <stInit>
#endif
}
 8003bf8:	bd08      	pop	{r3, pc}
 8003bfa:	bf00      	nop
 8003bfc:	08016120 	.word	0x08016120

08003c00 <st_lld_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
 8003c00:	b082      	sub	sp, #8
 8003c02:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003c04:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003c08:	9a01      	ldr	r2, [sp, #4]
 8003c0a:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8003c0c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003c10:	2200      	movs	r2, #0
 8003c12:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8003c14:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003c18:	2202      	movs	r2, #2
 8003c1a:	60da      	str	r2, [r3, #12]
}
 8003c1c:	b002      	add	sp, #8
 8003c1e:	4770      	bx	lr

08003c20 <st_lld_stop_alarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8003c20:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003c24:	2200      	movs	r2, #0
 8003c26:	60da      	str	r2, [r3, #12]
}
 8003c28:	4770      	bx	lr
 8003c2a:	bf00      	nop
 8003c2c:	f3af 8000 	nop.w

08003c30 <st_lld_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
 8003c30:	b082      	sub	sp, #8
 8003c32:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003c34:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003c38:	9a01      	ldr	r2, [sp, #4]
 8003c3a:	635a      	str	r2, [r3, #52]	; 0x34
}
 8003c3c:	b002      	add	sp, #8
 8003c3e:	4770      	bx	lr

08003c40 <st_lld_get_alarm>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_alarm(void) {

  return (systime_t)STM32_ST_TIM->CCR[0];
 8003c40:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003c44:	6b5b      	ldr	r3, [r3, #52]	; 0x34
}
 8003c46:	4618      	mov	r0, r3
 8003c48:	4770      	bx	lr
 8003c4a:	bf00      	nop
 8003c4c:	f3af 8000 	nop.w

08003c50 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8003c50:	b508      	push	{r3, lr}

  st_lld_init();
 8003c52:	f003 ffbd 	bl	8007bd0 <st_lld_init>
}
 8003c56:	bd08      	pop	{r3, pc}
 8003c58:	f3af 8000 	nop.w
 8003c5c:	f3af 8000 	nop.w

08003c60 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 8003c60:	b500      	push	{lr}
 8003c62:	b083      	sub	sp, #12
 8003c64:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
 8003c66:	9801      	ldr	r0, [sp, #4]
 8003c68:	f7ff ffca 	bl	8003c00 <st_lld_start_alarm>
}
 8003c6c:	b003      	add	sp, #12
 8003c6e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003c72:	bf00      	nop
 8003c74:	f3af 8000 	nop.w
 8003c78:	f3af 8000 	nop.w
 8003c7c:	f3af 8000 	nop.w

08003c80 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8003c80:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 8003c82:	f7ff ffcd 	bl	8003c20 <st_lld_stop_alarm>
}
 8003c86:	bd08      	pop	{r3, pc}
 8003c88:	f3af 8000 	nop.w
 8003c8c:	f3af 8000 	nop.w

08003c90 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8003c90:	b500      	push	{lr}
 8003c92:	b083      	sub	sp, #12
 8003c94:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
 8003c96:	9801      	ldr	r0, [sp, #4]
 8003c98:	f7ff ffca 	bl	8003c30 <st_lld_set_alarm>
}
 8003c9c:	b003      	add	sp, #12
 8003c9e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003ca2:	bf00      	nop
 8003ca4:	f3af 8000 	nop.w
 8003ca8:	f3af 8000 	nop.w
 8003cac:	f3af 8000 	nop.w

08003cb0 <stGetAlarm>:
 *
 * @return              The currently set alarm time.
 *
 * @api
 */
systime_t stGetAlarm(void) {
 8003cb0:	b508      	push	{r3, lr}

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  return st_lld_get_alarm();
 8003cb2:	f7ff ffc5 	bl	8003c40 <st_lld_get_alarm>
 8003cb6:	4603      	mov	r3, r0
}
 8003cb8:	4618      	mov	r0, r3
 8003cba:	bd08      	pop	{r3, pc}
 8003cbc:	f3af 8000 	nop.w

08003cc0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003cc0:	b082      	sub	sp, #8
 8003cc2:	2320      	movs	r3, #32
 8003cc4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003cc6:	9b01      	ldr	r3, [sp, #4]
 8003cc8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003ccc:	b002      	add	sp, #8
 8003cce:	4770      	bx	lr

08003cd0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003cd0:	b082      	sub	sp, #8
 8003cd2:	2300      	movs	r3, #0
 8003cd4:	9301      	str	r3, [sp, #4]
 8003cd6:	9b01      	ldr	r3, [sp, #4]
 8003cd8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003cdc:	b002      	add	sp, #8
 8003cde:	4770      	bx	lr

08003ce0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8003ce0:	b082      	sub	sp, #8
 8003ce2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8003ce4:	9b01      	ldr	r3, [sp, #4]
 8003ce6:	9a01      	ldr	r2, [sp, #4]
 8003ce8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8003cea:	9b01      	ldr	r3, [sp, #4]
 8003cec:	9a01      	ldr	r2, [sp, #4]
 8003cee:	605a      	str	r2, [r3, #4]
}
 8003cf0:	b002      	add	sp, #8
 8003cf2:	4770      	bx	lr
 8003cf4:	f3af 8000 	nop.w
 8003cf8:	f3af 8000 	nop.w
 8003cfc:	f3af 8000 	nop.w

08003d00 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8003d00:	b508      	push	{r3, lr}

  port_lock();
 8003d02:	f7ff ffdd 	bl	8003cc0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8003d06:	bd08      	pop	{r3, pc}
 8003d08:	f3af 8000 	nop.w
 8003d0c:	f3af 8000 	nop.w

08003d10 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8003d10:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8003d12:	f7ff ffdd 	bl	8003cd0 <port_unlock>
}
 8003d16:	bd08      	pop	{r3, pc}
 8003d18:	f3af 8000 	nop.w
 8003d1c:	f3af 8000 	nop.w

08003d20 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 8003d20:	4b01      	ldr	r3, [pc, #4]	; (8003d28 <chVTGetSystemTimeX+0x8>)
 8003d22:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8003d24:	4618      	mov	r0, r3
 8003d26:	4770      	bx	lr
 8003d28:	20000d98 	.word	0x20000d98
 8003d2c:	f3af 8000 	nop.w

08003d30 <chThdQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8003d30:	b500      	push	{lr}
 8003d32:	b083      	sub	sp, #12
 8003d34:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 8003d36:	9801      	ldr	r0, [sp, #4]
 8003d38:	f7ff ffd2 	bl	8003ce0 <queue_init>
}
 8003d3c:	b003      	add	sp, #12
 8003d3e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003d42:	bf00      	nop
 8003d44:	f3af 8000 	nop.w
 8003d48:	f3af 8000 	nop.w
 8003d4c:	f3af 8000 	nop.w

08003d50 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8003d50:	b508      	push	{r3, lr}

  chSysLock();
 8003d52:	f7ff ffd5 	bl	8003d00 <chSysLock>
}
 8003d56:	bd08      	pop	{r3, pc}
 8003d58:	f3af 8000 	nop.w
 8003d5c:	f3af 8000 	nop.w

08003d60 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8003d60:	b508      	push	{r3, lr}

  chSysUnlock();
 8003d62:	f7ff ffd5 	bl	8003d10 <chSysUnlock>
}
 8003d66:	bd08      	pop	{r3, pc}
 8003d68:	f3af 8000 	nop.w
 8003d6c:	f3af 8000 	nop.w

08003d70 <osalOsGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t osalOsGetSystemTimeX(void) {
 8003d70:	b508      	push	{r3, lr}

  return chVTGetSystemTimeX();
 8003d72:	f7ff ffd5 	bl	8003d20 <chVTGetSystemTimeX>
 8003d76:	4603      	mov	r3, r0
}
 8003d78:	4618      	mov	r0, r3
 8003d7a:	bd08      	pop	{r3, pc}
 8003d7c:	f3af 8000 	nop.w

08003d80 <osalThreadQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 8003d80:	b500      	push	{lr}
 8003d82:	b083      	sub	sp, #12
 8003d84:	9001      	str	r0, [sp, #4]

  chThdQueueObjectInit(tqp);
 8003d86:	9801      	ldr	r0, [sp, #4]
 8003d88:	f7ff ffd2 	bl	8003d30 <chThdQueueObjectInit>
}
 8003d8c:	b003      	add	sp, #12
 8003d8e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003d92:	bf00      	nop
 8003d94:	f3af 8000 	nop.w
 8003d98:	f3af 8000 	nop.w
 8003d9c:	f3af 8000 	nop.w

08003da0 <osalThreadEnqueueTimeoutS>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
 8003da0:	b500      	push	{lr}
 8003da2:	b083      	sub	sp, #12
 8003da4:	9001      	str	r0, [sp, #4]
 8003da6:	9100      	str	r1, [sp, #0]

  return chThdEnqueueTimeoutS(tqp, time);
 8003da8:	9801      	ldr	r0, [sp, #4]
 8003daa:	9900      	ldr	r1, [sp, #0]
 8003dac:	f7fd fbc8 	bl	8001540 <chThdEnqueueTimeoutS>
 8003db0:	4603      	mov	r3, r0
}
 8003db2:	4618      	mov	r0, r3
 8003db4:	b003      	add	sp, #12
 8003db6:	f85d fb04 	ldr.w	pc, [sp], #4
 8003dba:	bf00      	nop
 8003dbc:	f3af 8000 	nop.w

08003dc0 <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8003dc0:	b500      	push	{lr}
 8003dc2:	b083      	sub	sp, #12
 8003dc4:	9001      	str	r0, [sp, #4]
 8003dc6:	9100      	str	r1, [sp, #0]

  chThdDequeueNextI(tqp, msg);
 8003dc8:	9801      	ldr	r0, [sp, #4]
 8003dca:	9900      	ldr	r1, [sp, #0]
 8003dcc:	f7fd fbd8 	bl	8001580 <chThdDequeueNextI>
}
 8003dd0:	b003      	add	sp, #12
 8003dd2:	f85d fb04 	ldr.w	pc, [sp], #4
 8003dd6:	bf00      	nop
 8003dd8:	f3af 8000 	nop.w
 8003ddc:	f3af 8000 	nop.w

08003de0 <osalThreadDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8003de0:	b500      	push	{lr}
 8003de2:	b083      	sub	sp, #12
 8003de4:	9001      	str	r0, [sp, #4]
 8003de6:	9100      	str	r1, [sp, #0]

  chThdDequeueAllI(tqp, msg);
 8003de8:	9801      	ldr	r0, [sp, #4]
 8003dea:	9900      	ldr	r1, [sp, #0]
 8003dec:	f7fd fbe0 	bl	80015b0 <chThdDequeueAllI>
}
 8003df0:	b003      	add	sp, #12
 8003df2:	f85d fb04 	ldr.w	pc, [sp], #4
 8003df6:	bf00      	nop
 8003df8:	f3af 8000 	nop.w
 8003dfc:	f3af 8000 	nop.w

08003e00 <ibqObjectInit>:
 *
 * @init
 */
void ibqObjectInit(input_buffers_queue_t *ibqp, uint8_t *bp,
                   size_t size, size_t n,
                   bqnotify_t infy, void *link) {
 8003e00:	b500      	push	{lr}
 8003e02:	b085      	sub	sp, #20
 8003e04:	9003      	str	r0, [sp, #12]
 8003e06:	9102      	str	r1, [sp, #8]
 8003e08:	9201      	str	r2, [sp, #4]
 8003e0a:	9300      	str	r3, [sp, #0]

  osalDbgCheck((ibqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&ibqp->waiting);
 8003e0c:	9b03      	ldr	r3, [sp, #12]
 8003e0e:	4618      	mov	r0, r3
 8003e10:	f7ff ffb6 	bl	8003d80 <osalThreadQueueObjectInit>
  ibqp->bcounter = 0;
 8003e14:	9b03      	ldr	r3, [sp, #12]
 8003e16:	2200      	movs	r2, #0
 8003e18:	609a      	str	r2, [r3, #8]
  ibqp->brdptr   = bp;
 8003e1a:	9b03      	ldr	r3, [sp, #12]
 8003e1c:	9a02      	ldr	r2, [sp, #8]
 8003e1e:	611a      	str	r2, [r3, #16]
  ibqp->bwrptr   = bp;
 8003e20:	9b03      	ldr	r3, [sp, #12]
 8003e22:	9a02      	ldr	r2, [sp, #8]
 8003e24:	60da      	str	r2, [r3, #12]
  ibqp->btop     = bp + ((size + sizeof (size_t)) * n);
 8003e26:	9b01      	ldr	r3, [sp, #4]
 8003e28:	3304      	adds	r3, #4
 8003e2a:	9a00      	ldr	r2, [sp, #0]
 8003e2c:	fb02 f303 	mul.w	r3, r2, r3
 8003e30:	9a02      	ldr	r2, [sp, #8]
 8003e32:	441a      	add	r2, r3
 8003e34:	9b03      	ldr	r3, [sp, #12]
 8003e36:	615a      	str	r2, [r3, #20]
  ibqp->bsize    = size + sizeof (size_t);
 8003e38:	9b01      	ldr	r3, [sp, #4]
 8003e3a:	1d1a      	adds	r2, r3, #4
 8003e3c:	9b03      	ldr	r3, [sp, #12]
 8003e3e:	619a      	str	r2, [r3, #24]
  ibqp->bn       = n;
 8003e40:	9b03      	ldr	r3, [sp, #12]
 8003e42:	9a00      	ldr	r2, [sp, #0]
 8003e44:	61da      	str	r2, [r3, #28]
  ibqp->buffers  = bp;
 8003e46:	9b03      	ldr	r3, [sp, #12]
 8003e48:	9a02      	ldr	r2, [sp, #8]
 8003e4a:	621a      	str	r2, [r3, #32]
  ibqp->ptr      = NULL;
 8003e4c:	9b03      	ldr	r3, [sp, #12]
 8003e4e:	2200      	movs	r2, #0
 8003e50:	625a      	str	r2, [r3, #36]	; 0x24
  ibqp->top      = NULL;
 8003e52:	9b03      	ldr	r3, [sp, #12]
 8003e54:	2200      	movs	r2, #0
 8003e56:	629a      	str	r2, [r3, #40]	; 0x28
  ibqp->notify   = infy;
 8003e58:	9b03      	ldr	r3, [sp, #12]
 8003e5a:	9a06      	ldr	r2, [sp, #24]
 8003e5c:	62da      	str	r2, [r3, #44]	; 0x2c
  ibqp->link     = link;
 8003e5e:	9b03      	ldr	r3, [sp, #12]
 8003e60:	9a07      	ldr	r2, [sp, #28]
 8003e62:	631a      	str	r2, [r3, #48]	; 0x30
}
 8003e64:	b005      	add	sp, #20
 8003e66:	f85d fb04 	ldr.w	pc, [sp], #4
 8003e6a:	bf00      	nop
 8003e6c:	f3af 8000 	nop.w

08003e70 <ibqResetI>:
 *
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 *
 * @iclass
 */
void ibqResetI(input_buffers_queue_t *ibqp) {
 8003e70:	b500      	push	{lr}
 8003e72:	b083      	sub	sp, #12
 8003e74:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  ibqp->bcounter = 0;
 8003e76:	9b01      	ldr	r3, [sp, #4]
 8003e78:	2200      	movs	r2, #0
 8003e7a:	609a      	str	r2, [r3, #8]
  ibqp->brdptr   = ibqp->buffers;
 8003e7c:	9b01      	ldr	r3, [sp, #4]
 8003e7e:	6a1a      	ldr	r2, [r3, #32]
 8003e80:	9b01      	ldr	r3, [sp, #4]
 8003e82:	611a      	str	r2, [r3, #16]
  ibqp->bwrptr   = ibqp->buffers;
 8003e84:	9b01      	ldr	r3, [sp, #4]
 8003e86:	6a1a      	ldr	r2, [r3, #32]
 8003e88:	9b01      	ldr	r3, [sp, #4]
 8003e8a:	60da      	str	r2, [r3, #12]
  ibqp->ptr      = NULL;
 8003e8c:	9b01      	ldr	r3, [sp, #4]
 8003e8e:	2200      	movs	r2, #0
 8003e90:	625a      	str	r2, [r3, #36]	; 0x24
  ibqp->top      = NULL;
 8003e92:	9b01      	ldr	r3, [sp, #4]
 8003e94:	2200      	movs	r2, #0
 8003e96:	629a      	str	r2, [r3, #40]	; 0x28
  osalThreadDequeueAllI(&ibqp->waiting, MSG_RESET);
 8003e98:	9b01      	ldr	r3, [sp, #4]
 8003e9a:	4618      	mov	r0, r3
 8003e9c:	f06f 0101 	mvn.w	r1, #1
 8003ea0:	f7ff ff9e 	bl	8003de0 <osalThreadDequeueAllI>
}
 8003ea4:	b003      	add	sp, #12
 8003ea6:	f85d fb04 	ldr.w	pc, [sp], #4
 8003eaa:	bf00      	nop
 8003eac:	f3af 8000 	nop.w

08003eb0 <ibqGetEmptyBufferI>:
 * @return              A pointer to the next buffer to be filled.
 * @retval NULL         if the queue is full.
 *
 * @iclass
 */
uint8_t *ibqGetEmptyBufferI(input_buffers_queue_t *ibqp) {
 8003eb0:	b082      	sub	sp, #8
 8003eb2:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  if (ibqIsFullI(ibqp)) {
 8003eb4:	9b01      	ldr	r3, [sp, #4]
 8003eb6:	68da      	ldr	r2, [r3, #12]
 8003eb8:	9b01      	ldr	r3, [sp, #4]
 8003eba:	691b      	ldr	r3, [r3, #16]
 8003ebc:	429a      	cmp	r2, r3
 8003ebe:	d105      	bne.n	8003ecc <ibqGetEmptyBufferI+0x1c>
 8003ec0:	9b01      	ldr	r3, [sp, #4]
 8003ec2:	689b      	ldr	r3, [r3, #8]
 8003ec4:	2b00      	cmp	r3, #0
 8003ec6:	d001      	beq.n	8003ecc <ibqGetEmptyBufferI+0x1c>
 8003ec8:	2301      	movs	r3, #1
 8003eca:	e000      	b.n	8003ece <ibqGetEmptyBufferI+0x1e>
 8003ecc:	2300      	movs	r3, #0
 8003ece:	f003 0301 	and.w	r3, r3, #1
 8003ed2:	b2db      	uxtb	r3, r3
 8003ed4:	2b00      	cmp	r3, #0
 8003ed6:	d001      	beq.n	8003edc <ibqGetEmptyBufferI+0x2c>
    return NULL;
 8003ed8:	2300      	movs	r3, #0
 8003eda:	e002      	b.n	8003ee2 <ibqGetEmptyBufferI+0x32>
  }

  return ibqp->bwrptr + sizeof (size_t);
 8003edc:	9b01      	ldr	r3, [sp, #4]
 8003ede:	68db      	ldr	r3, [r3, #12]
 8003ee0:	3304      	adds	r3, #4
}
 8003ee2:	4618      	mov	r0, r3
 8003ee4:	b002      	add	sp, #8
 8003ee6:	4770      	bx	lr
 8003ee8:	f3af 8000 	nop.w
 8003eec:	f3af 8000 	nop.w

08003ef0 <ibqPostFullBufferI>:
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @iclass
 */
void ibqPostFullBufferI(input_buffers_queue_t *ibqp, size_t size) {
 8003ef0:	b500      	push	{lr}
 8003ef2:	b083      	sub	sp, #12
 8003ef4:	9001      	str	r0, [sp, #4]
 8003ef6:	9100      	str	r1, [sp, #0]

  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;
 8003ef8:	9b01      	ldr	r3, [sp, #4]
 8003efa:	68db      	ldr	r3, [r3, #12]
 8003efc:	9a00      	ldr	r2, [sp, #0]
 8003efe:	601a      	str	r2, [r3, #0]

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
 8003f00:	9b01      	ldr	r3, [sp, #4]
 8003f02:	689b      	ldr	r3, [r3, #8]
 8003f04:	1c5a      	adds	r2, r3, #1
 8003f06:	9b01      	ldr	r3, [sp, #4]
 8003f08:	609a      	str	r2, [r3, #8]
  ibqp->bwrptr += ibqp->bsize;
 8003f0a:	9b01      	ldr	r3, [sp, #4]
 8003f0c:	68da      	ldr	r2, [r3, #12]
 8003f0e:	9b01      	ldr	r3, [sp, #4]
 8003f10:	699b      	ldr	r3, [r3, #24]
 8003f12:	441a      	add	r2, r3
 8003f14:	9b01      	ldr	r3, [sp, #4]
 8003f16:	60da      	str	r2, [r3, #12]
  if (ibqp->bwrptr >= ibqp->btop) {
 8003f18:	9b01      	ldr	r3, [sp, #4]
 8003f1a:	68da      	ldr	r2, [r3, #12]
 8003f1c:	9b01      	ldr	r3, [sp, #4]
 8003f1e:	695b      	ldr	r3, [r3, #20]
 8003f20:	429a      	cmp	r2, r3
 8003f22:	d303      	bcc.n	8003f2c <ibqPostFullBufferI+0x3c>
    ibqp->bwrptr = ibqp->buffers;
 8003f24:	9b01      	ldr	r3, [sp, #4]
 8003f26:	6a1a      	ldr	r2, [r3, #32]
 8003f28:	9b01      	ldr	r3, [sp, #4]
 8003f2a:	60da      	str	r2, [r3, #12]
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&ibqp->waiting, MSG_OK);
 8003f2c:	9b01      	ldr	r3, [sp, #4]
 8003f2e:	4618      	mov	r0, r3
 8003f30:	2100      	movs	r1, #0
 8003f32:	f7ff ff45 	bl	8003dc0 <osalThreadDequeueNextI>
}
 8003f36:	b003      	add	sp, #12
 8003f38:	f85d fb04 	ldr.w	pc, [sp], #4
 8003f3c:	f3af 8000 	nop.w

08003f40 <ibqGetFullBufferTimeout>:
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t ibqGetFullBufferTimeout(input_buffers_queue_t *ibqp,
                              systime_t timeout) {
 8003f40:	b500      	push	{lr}
 8003f42:	b085      	sub	sp, #20
 8003f44:	9001      	str	r0, [sp, #4]
 8003f46:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalSysLock();
 8003f48:	f7ff ff02 	bl	8003d50 <osalSysLock>
  msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8003f4c:	9801      	ldr	r0, [sp, #4]
 8003f4e:	9900      	ldr	r1, [sp, #0]
 8003f50:	f000 f80e 	bl	8003f70 <ibqGetFullBufferTimeoutS>
 8003f54:	9003      	str	r0, [sp, #12]
  osalSysUnlock();
 8003f56:	f7ff ff03 	bl	8003d60 <osalSysUnlock>

  return msg;
 8003f5a:	9b03      	ldr	r3, [sp, #12]
}
 8003f5c:	4618      	mov	r0, r3
 8003f5e:	b005      	add	sp, #20
 8003f60:	f85d fb04 	ldr.w	pc, [sp], #4
 8003f64:	f3af 8000 	nop.w
 8003f68:	f3af 8000 	nop.w
 8003f6c:	f3af 8000 	nop.w

08003f70 <ibqGetFullBufferTimeoutS>:
   * @retval MSG_RESET    if the queue has been reset.
   *
   * @sclass
   */
  msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp,
                                 systime_t timeout) {
 8003f70:	b500      	push	{lr}
 8003f72:	b085      	sub	sp, #20
 8003f74:	9001      	str	r0, [sp, #4]
 8003f76:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassS();

  while (ibqIsEmptyI(ibqp)) {
 8003f78:	e00a      	b.n	8003f90 <ibqGetFullBufferTimeoutS+0x20>
    msg_t msg = osalThreadEnqueueTimeoutS(&ibqp->waiting, timeout);
 8003f7a:	9b01      	ldr	r3, [sp, #4]
 8003f7c:	4618      	mov	r0, r3
 8003f7e:	9900      	ldr	r1, [sp, #0]
 8003f80:	f7ff ff0e 	bl	8003da0 <osalThreadEnqueueTimeoutS>
 8003f84:	9003      	str	r0, [sp, #12]
    if (msg < MSG_OK) {
 8003f86:	9b03      	ldr	r3, [sp, #12]
 8003f88:	2b00      	cmp	r3, #0
 8003f8a:	da01      	bge.n	8003f90 <ibqGetFullBufferTimeoutS+0x20>
       return msg;
 8003f8c:	9b03      	ldr	r3, [sp, #12]
 8003f8e:	e011      	b.n	8003fb4 <ibqGetFullBufferTimeoutS+0x44>
  msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp,
                                 systime_t timeout) {

  osalDbgCheckClassS();

  while (ibqIsEmptyI(ibqp)) {
 8003f90:	9b01      	ldr	r3, [sp, #4]
 8003f92:	689b      	ldr	r3, [r3, #8]
 8003f94:	2b00      	cmp	r3, #0
 8003f96:	d0f0      	beq.n	8003f7a <ibqGetFullBufferTimeoutS+0xa>
  }

  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");

  /* Setting up the "current" buffer and its boundary.*/
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8003f98:	9b01      	ldr	r3, [sp, #4]
 8003f9a:	691b      	ldr	r3, [r3, #16]
 8003f9c:	1d1a      	adds	r2, r3, #4
 8003f9e:	9b01      	ldr	r3, [sp, #4]
 8003fa0:	625a      	str	r2, [r3, #36]	; 0x24
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 8003fa2:	9b01      	ldr	r3, [sp, #4]
 8003fa4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8003fa6:	9b01      	ldr	r3, [sp, #4]
 8003fa8:	691b      	ldr	r3, [r3, #16]
 8003faa:	681b      	ldr	r3, [r3, #0]
 8003fac:	441a      	add	r2, r3
 8003fae:	9b01      	ldr	r3, [sp, #4]
 8003fb0:	629a      	str	r2, [r3, #40]	; 0x28

  return MSG_OK;
 8003fb2:	2300      	movs	r3, #0
}
 8003fb4:	4618      	mov	r0, r3
 8003fb6:	b005      	add	sp, #20
 8003fb8:	f85d fb04 	ldr.w	pc, [sp], #4
 8003fbc:	f3af 8000 	nop.w

08003fc0 <ibqReleaseEmptyBuffer>:
 *
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 *
 * @api
 */
void ibqReleaseEmptyBuffer(input_buffers_queue_t *ibqp) {
 8003fc0:	b500      	push	{lr}
 8003fc2:	b083      	sub	sp, #12
 8003fc4:	9001      	str	r0, [sp, #4]

  osalSysLock();
 8003fc6:	f7ff fec3 	bl	8003d50 <osalSysLock>
  ibqReleaseEmptyBufferS(ibqp);
 8003fca:	9801      	ldr	r0, [sp, #4]
 8003fcc:	f000 f808 	bl	8003fe0 <ibqReleaseEmptyBufferS>
  osalSysUnlock();
 8003fd0:	f7ff fec6 	bl	8003d60 <osalSysUnlock>
}
 8003fd4:	b003      	add	sp, #12
 8003fd6:	f85d fb04 	ldr.w	pc, [sp], #4
 8003fda:	bf00      	nop
 8003fdc:	f3af 8000 	nop.w

08003fe0 <ibqReleaseEmptyBufferS>:
   *
   * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
   *
   * @sclass
   */
  void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {
 8003fe0:	b500      	push	{lr}
 8003fe2:	b083      	sub	sp, #12
 8003fe4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassS();
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
 8003fe6:	9b01      	ldr	r3, [sp, #4]
 8003fe8:	689b      	ldr	r3, [r3, #8]
 8003fea:	1e5a      	subs	r2, r3, #1
 8003fec:	9b01      	ldr	r3, [sp, #4]
 8003fee:	609a      	str	r2, [r3, #8]
  ibqp->brdptr += ibqp->bsize;
 8003ff0:	9b01      	ldr	r3, [sp, #4]
 8003ff2:	691a      	ldr	r2, [r3, #16]
 8003ff4:	9b01      	ldr	r3, [sp, #4]
 8003ff6:	699b      	ldr	r3, [r3, #24]
 8003ff8:	441a      	add	r2, r3
 8003ffa:	9b01      	ldr	r3, [sp, #4]
 8003ffc:	611a      	str	r2, [r3, #16]
  if (ibqp->brdptr >= ibqp->btop) {
 8003ffe:	9b01      	ldr	r3, [sp, #4]
 8004000:	691a      	ldr	r2, [r3, #16]
 8004002:	9b01      	ldr	r3, [sp, #4]
 8004004:	695b      	ldr	r3, [r3, #20]
 8004006:	429a      	cmp	r2, r3
 8004008:	d303      	bcc.n	8004012 <ibqReleaseEmptyBufferS+0x32>
    ibqp->brdptr = ibqp->buffers;
 800400a:	9b01      	ldr	r3, [sp, #4]
 800400c:	6a1a      	ldr	r2, [r3, #32]
 800400e:	9b01      	ldr	r3, [sp, #4]
 8004010:	611a      	str	r2, [r3, #16]
  }

  /* No "current" buffer.*/
  ibqp->ptr = NULL;
 8004012:	9b01      	ldr	r3, [sp, #4]
 8004014:	2200      	movs	r2, #0
 8004016:	625a      	str	r2, [r3, #36]	; 0x24

  /* Notifying the buffer release.*/
  if (ibqp->notify != NULL) {
 8004018:	9b01      	ldr	r3, [sp, #4]
 800401a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800401c:	2b00      	cmp	r3, #0
 800401e:	d003      	beq.n	8004028 <ibqReleaseEmptyBufferS+0x48>
    ibqp->notify(ibqp);
 8004020:	9b01      	ldr	r3, [sp, #4]
 8004022:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004024:	9801      	ldr	r0, [sp, #4]
 8004026:	4798      	blx	r3
  }
}
 8004028:	b003      	add	sp, #12
 800402a:	f85d fb04 	ldr.w	pc, [sp], #4
 800402e:	bf00      	nop

08004030 <ibqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, systime_t timeout) {
 8004030:	b500      	push	{lr}
 8004032:	b085      	sub	sp, #20
 8004034:	9001      	str	r0, [sp, #4]
 8004036:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalSysLock();
 8004038:	f7ff fe8a 	bl	8003d50 <osalSysLock>

  /* This condition indicates that a new buffer must be acquired.*/
  if (ibqp->ptr == NULL) {
 800403c:	9b01      	ldr	r3, [sp, #4]
 800403e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004040:	2b00      	cmp	r3, #0
 8004042:	d10b      	bne.n	800405c <ibqGetTimeout+0x2c>
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8004044:	9801      	ldr	r0, [sp, #4]
 8004046:	9900      	ldr	r1, [sp, #0]
 8004048:	f7ff ff92 	bl	8003f70 <ibqGetFullBufferTimeoutS>
 800404c:	9003      	str	r0, [sp, #12]
    if (msg != MSG_OK) {
 800404e:	9b03      	ldr	r3, [sp, #12]
 8004050:	2b00      	cmp	r3, #0
 8004052:	d003      	beq.n	800405c <ibqGetTimeout+0x2c>
      osalSysUnlock();
 8004054:	f7ff fe84 	bl	8003d60 <osalSysUnlock>
      return msg;
 8004058:	9b03      	ldr	r3, [sp, #12]
 800405a:	e014      	b.n	8004086 <ibqGetTimeout+0x56>
    }
  }

  /* Next byte from the buffer.*/
  msg = (msg_t)*ibqp->ptr;
 800405c:	9b01      	ldr	r3, [sp, #4]
 800405e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004060:	781b      	ldrb	r3, [r3, #0]
 8004062:	9303      	str	r3, [sp, #12]
  ibqp->ptr++;
 8004064:	9b01      	ldr	r3, [sp, #4]
 8004066:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004068:	1c5a      	adds	r2, r3, #1
 800406a:	9b01      	ldr	r3, [sp, #4]
 800406c:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the current buffer has been fully read then it is returned as
     empty in the queue.*/
  if (ibqp->ptr >= ibqp->top) {
 800406e:	9b01      	ldr	r3, [sp, #4]
 8004070:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004072:	9b01      	ldr	r3, [sp, #4]
 8004074:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004076:	429a      	cmp	r2, r3
 8004078:	d302      	bcc.n	8004080 <ibqGetTimeout+0x50>
    ibqReleaseEmptyBufferS(ibqp);
 800407a:	9801      	ldr	r0, [sp, #4]
 800407c:	f7ff ffb0 	bl	8003fe0 <ibqReleaseEmptyBufferS>
  }

  osalSysUnlock();
 8004080:	f7ff fe6e 	bl	8003d60 <osalSysUnlock>
  return msg;
 8004084:	9b03      	ldr	r3, [sp, #12]
}
 8004086:	4618      	mov	r0, r3
 8004088:	b005      	add	sp, #20
 800408a:	f85d fb04 	ldr.w	pc, [sp], #4
 800408e:	bf00      	nop

08004090 <ibqReadTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
                      size_t n, systime_t timeout) {
 8004090:	b500      	push	{lr}
 8004092:	b08b      	sub	sp, #44	; 0x2c
 8004094:	9003      	str	r0, [sp, #12]
 8004096:	9102      	str	r1, [sp, #8]
 8004098:	9201      	str	r2, [sp, #4]
 800409a:	9300      	str	r3, [sp, #0]
  size_t r = 0;
 800409c:	2300      	movs	r3, #0
 800409e:	9309      	str	r3, [sp, #36]	; 0x24
  systime_t deadline;

  osalSysLock();
 80040a0:	f7ff fe56 	bl	8003d50 <osalSysLock>

  /* Time window for the whole operation.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 80040a4:	f7ff fe64 	bl	8003d70 <osalOsGetSystemTimeX>
 80040a8:	4602      	mov	r2, r0
 80040aa:	9b00      	ldr	r3, [sp, #0]
 80040ac:	4413      	add	r3, r2
 80040ae:	9306      	str	r3, [sp, #24]

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (ibqp->ptr == NULL) {
 80040b0:	9b03      	ldr	r3, [sp, #12]
 80040b2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80040b4:	2b00      	cmp	r3, #0
 80040b6:	d126      	bne.n	8004106 <ibqReadTimeout+0x76>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80040b8:	9b00      	ldr	r3, [sp, #0]
 80040ba:	f1b3 3fff 	cmp.w	r3, #4294967295
 80040be:	d002      	beq.n	80040c6 <ibqReadTimeout+0x36>
 80040c0:	9b00      	ldr	r3, [sp, #0]
 80040c2:	2b00      	cmp	r3, #0
 80040c4:	d105      	bne.n	80040d2 <ibqReadTimeout+0x42>
        msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 80040c6:	9803      	ldr	r0, [sp, #12]
 80040c8:	9900      	ldr	r1, [sp, #0]
 80040ca:	f7ff ff51 	bl	8003f70 <ibqGetFullBufferTimeoutS>
 80040ce:	9007      	str	r0, [sp, #28]
 80040d0:	e012      	b.n	80040f8 <ibqReadTimeout+0x68>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 80040d2:	f7ff fe4d 	bl	8003d70 <osalOsGetSystemTimeX>
 80040d6:	4603      	mov	r3, r0
 80040d8:	9a06      	ldr	r2, [sp, #24]
 80040da:	1ad3      	subs	r3, r2, r3
 80040dc:	9305      	str	r3, [sp, #20]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 80040de:	9a05      	ldr	r2, [sp, #20]
 80040e0:	9b00      	ldr	r3, [sp, #0]
 80040e2:	429a      	cmp	r2, r3
 80040e4:	d903      	bls.n	80040ee <ibqReadTimeout+0x5e>
          osalSysUnlock();
 80040e6:	f7ff fe3b 	bl	8003d60 <osalSysUnlock>
          return r;
 80040ea:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80040ec:	e05c      	b.n	80041a8 <ibqReadTimeout+0x118>
        }
        msg = ibqGetFullBufferTimeoutS(ibqp, next_timeout);
 80040ee:	9803      	ldr	r0, [sp, #12]
 80040f0:	9905      	ldr	r1, [sp, #20]
 80040f2:	f7ff ff3d 	bl	8003f70 <ibqGetFullBufferTimeoutS>
 80040f6:	9007      	str	r0, [sp, #28]
      }

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 80040f8:	9b07      	ldr	r3, [sp, #28]
 80040fa:	2b00      	cmp	r3, #0
 80040fc:	d003      	beq.n	8004106 <ibqReadTimeout+0x76>
        osalSysUnlock();
 80040fe:	f7ff fe2f 	bl	8003d60 <osalSysUnlock>
        return r;
 8004102:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004104:	e050      	b.n	80041a8 <ibqReadTimeout+0x118>
      }
    }

    /* Size of the data chunk present in the current buffer.*/
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8004106:	9b03      	ldr	r3, [sp, #12]
 8004108:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800410a:	461a      	mov	r2, r3
 800410c:	9b03      	ldr	r3, [sp, #12]
 800410e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004110:	1ad3      	subs	r3, r2, r3
 8004112:	9308      	str	r3, [sp, #32]
    if (size > (n - r)) {
 8004114:	9a01      	ldr	r2, [sp, #4]
 8004116:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004118:	1ad2      	subs	r2, r2, r3
 800411a:	9b08      	ldr	r3, [sp, #32]
 800411c:	429a      	cmp	r2, r3
 800411e:	d203      	bcs.n	8004128 <ibqReadTimeout+0x98>
      size = n - r;
 8004120:	9a01      	ldr	r2, [sp, #4]
 8004122:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004124:	1ad3      	subs	r3, r2, r3
 8004126:	9308      	str	r3, [sp, #32]
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
 8004128:	9b08      	ldr	r3, [sp, #32]
 800412a:	2b40      	cmp	r3, #64	; 0x40
 800412c:	d913      	bls.n	8004156 <ibqReadTimeout+0xc6>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(bp, ibqp->ptr, 64U);
 800412e:	9b03      	ldr	r3, [sp, #12]
 8004130:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004132:	9802      	ldr	r0, [sp, #8]
 8004134:	4619      	mov	r1, r3
 8004136:	2240      	movs	r2, #64	; 0x40
 8004138:	f011 fc62 	bl	8015a00 <memcpy>
      bp        += 64U;
 800413c:	9b02      	ldr	r3, [sp, #8]
 800413e:	3340      	adds	r3, #64	; 0x40
 8004140:	9302      	str	r3, [sp, #8]
      ibqp->ptr += 64U;
 8004142:	9b03      	ldr	r3, [sp, #12]
 8004144:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004146:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800414a:	9b03      	ldr	r3, [sp, #12]
 800414c:	625a      	str	r2, [r3, #36]	; 0x24
      r         += 64U;
 800414e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004150:	3340      	adds	r3, #64	; 0x40
 8004152:	9309      	str	r3, [sp, #36]	; 0x24
 8004154:	e014      	b.n	8004180 <ibqReadTimeout+0xf0>
    }
    else {
      memcpy(bp, ibqp->ptr, size);
 8004156:	9b03      	ldr	r3, [sp, #12]
 8004158:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800415a:	9802      	ldr	r0, [sp, #8]
 800415c:	4619      	mov	r1, r3
 800415e:	9a08      	ldr	r2, [sp, #32]
 8004160:	f011 fc4e 	bl	8015a00 <memcpy>
      bp        += size;
 8004164:	9a02      	ldr	r2, [sp, #8]
 8004166:	9b08      	ldr	r3, [sp, #32]
 8004168:	4413      	add	r3, r2
 800416a:	9302      	str	r3, [sp, #8]
      ibqp->ptr += size;
 800416c:	9b03      	ldr	r3, [sp, #12]
 800416e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004170:	9b08      	ldr	r3, [sp, #32]
 8004172:	441a      	add	r2, r3
 8004174:	9b03      	ldr	r3, [sp, #12]
 8004176:	625a      	str	r2, [r3, #36]	; 0x24
      r         += size;
 8004178:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800417a:	9b08      	ldr	r3, [sp, #32]
 800417c:	4413      	add	r3, r2
 800417e:	9309      	str	r3, [sp, #36]	; 0x24
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 8004180:	9b03      	ldr	r3, [sp, #12]
 8004182:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004184:	9b03      	ldr	r3, [sp, #12]
 8004186:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004188:	429a      	cmp	r2, r3
 800418a:	d302      	bcc.n	8004192 <ibqReadTimeout+0x102>
      ibqReleaseEmptyBufferS(ibqp);
 800418c:	9803      	ldr	r0, [sp, #12]
 800418e:	f7ff ff27 	bl	8003fe0 <ibqReleaseEmptyBufferS>
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
 8004192:	f7ff fde5 	bl	8003d60 <osalSysUnlock>
    if (r >= n) {
 8004196:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8004198:	9b01      	ldr	r3, [sp, #4]
 800419a:	429a      	cmp	r2, r3
 800419c:	d301      	bcc.n	80041a2 <ibqReadTimeout+0x112>
      return r;
 800419e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80041a0:	e002      	b.n	80041a8 <ibqReadTimeout+0x118>
    }
    osalSysLock();
 80041a2:	f7ff fdd5 	bl	8003d50 <osalSysLock>
  }
 80041a6:	e783      	b.n	80040b0 <ibqReadTimeout+0x20>
}
 80041a8:	4618      	mov	r0, r3
 80041aa:	b00b      	add	sp, #44	; 0x2c
 80041ac:	f85d fb04 	ldr.w	pc, [sp], #4

080041b0 <obqObjectInit>:
 *
 * @init
 */
void obqObjectInit(output_buffers_queue_t *obqp, uint8_t *bp,
                   size_t size, size_t n,
                   bqnotify_t onfy, void *link) {
 80041b0:	b500      	push	{lr}
 80041b2:	b085      	sub	sp, #20
 80041b4:	9003      	str	r0, [sp, #12]
 80041b6:	9102      	str	r1, [sp, #8]
 80041b8:	9201      	str	r2, [sp, #4]
 80041ba:	9300      	str	r3, [sp, #0]

  osalDbgCheck((obqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&obqp->waiting);
 80041bc:	9b03      	ldr	r3, [sp, #12]
 80041be:	4618      	mov	r0, r3
 80041c0:	f7ff fdde 	bl	8003d80 <osalThreadQueueObjectInit>
  obqp->bcounter = n;
 80041c4:	9b03      	ldr	r3, [sp, #12]
 80041c6:	9a00      	ldr	r2, [sp, #0]
 80041c8:	609a      	str	r2, [r3, #8]
  obqp->brdptr   = bp;
 80041ca:	9b03      	ldr	r3, [sp, #12]
 80041cc:	9a02      	ldr	r2, [sp, #8]
 80041ce:	611a      	str	r2, [r3, #16]
  obqp->bwrptr   = bp;
 80041d0:	9b03      	ldr	r3, [sp, #12]
 80041d2:	9a02      	ldr	r2, [sp, #8]
 80041d4:	60da      	str	r2, [r3, #12]
  obqp->btop     = bp + ((size + sizeof (size_t)) * n);
 80041d6:	9b01      	ldr	r3, [sp, #4]
 80041d8:	3304      	adds	r3, #4
 80041da:	9a00      	ldr	r2, [sp, #0]
 80041dc:	fb02 f303 	mul.w	r3, r2, r3
 80041e0:	9a02      	ldr	r2, [sp, #8]
 80041e2:	441a      	add	r2, r3
 80041e4:	9b03      	ldr	r3, [sp, #12]
 80041e6:	615a      	str	r2, [r3, #20]
  obqp->bsize    = size + sizeof (size_t);
 80041e8:	9b01      	ldr	r3, [sp, #4]
 80041ea:	1d1a      	adds	r2, r3, #4
 80041ec:	9b03      	ldr	r3, [sp, #12]
 80041ee:	619a      	str	r2, [r3, #24]
  obqp->bn       = n;
 80041f0:	9b03      	ldr	r3, [sp, #12]
 80041f2:	9a00      	ldr	r2, [sp, #0]
 80041f4:	61da      	str	r2, [r3, #28]
  obqp->buffers  = bp;
 80041f6:	9b03      	ldr	r3, [sp, #12]
 80041f8:	9a02      	ldr	r2, [sp, #8]
 80041fa:	621a      	str	r2, [r3, #32]
  obqp->ptr      = NULL;
 80041fc:	9b03      	ldr	r3, [sp, #12]
 80041fe:	2200      	movs	r2, #0
 8004200:	625a      	str	r2, [r3, #36]	; 0x24
  obqp->top      = NULL;
 8004202:	9b03      	ldr	r3, [sp, #12]
 8004204:	2200      	movs	r2, #0
 8004206:	629a      	str	r2, [r3, #40]	; 0x28
  obqp->notify   = onfy;
 8004208:	9b03      	ldr	r3, [sp, #12]
 800420a:	9a06      	ldr	r2, [sp, #24]
 800420c:	62da      	str	r2, [r3, #44]	; 0x2c
  obqp->link     = link;
 800420e:	9b03      	ldr	r3, [sp, #12]
 8004210:	9a07      	ldr	r2, [sp, #28]
 8004212:	631a      	str	r2, [r3, #48]	; 0x30
}
 8004214:	b005      	add	sp, #20
 8004216:	f85d fb04 	ldr.w	pc, [sp], #4
 800421a:	bf00      	nop
 800421c:	f3af 8000 	nop.w

08004220 <obqResetI>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @iclass
 */
void obqResetI(output_buffers_queue_t *obqp) {
 8004220:	b500      	push	{lr}
 8004222:	b083      	sub	sp, #12
 8004224:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  obqp->bcounter = bqSizeX(obqp);
 8004226:	9b01      	ldr	r3, [sp, #4]
 8004228:	69da      	ldr	r2, [r3, #28]
 800422a:	9b01      	ldr	r3, [sp, #4]
 800422c:	609a      	str	r2, [r3, #8]
  obqp->brdptr   = obqp->buffers;
 800422e:	9b01      	ldr	r3, [sp, #4]
 8004230:	6a1a      	ldr	r2, [r3, #32]
 8004232:	9b01      	ldr	r3, [sp, #4]
 8004234:	611a      	str	r2, [r3, #16]
  obqp->bwrptr   = obqp->buffers;
 8004236:	9b01      	ldr	r3, [sp, #4]
 8004238:	6a1a      	ldr	r2, [r3, #32]
 800423a:	9b01      	ldr	r3, [sp, #4]
 800423c:	60da      	str	r2, [r3, #12]
  obqp->ptr      = NULL;
 800423e:	9b01      	ldr	r3, [sp, #4]
 8004240:	2200      	movs	r2, #0
 8004242:	625a      	str	r2, [r3, #36]	; 0x24
  obqp->top      = NULL;
 8004244:	9b01      	ldr	r3, [sp, #4]
 8004246:	2200      	movs	r2, #0
 8004248:	629a      	str	r2, [r3, #40]	; 0x28
  osalThreadDequeueAllI(&obqp->waiting, MSG_RESET);
 800424a:	9b01      	ldr	r3, [sp, #4]
 800424c:	4618      	mov	r0, r3
 800424e:	f06f 0101 	mvn.w	r1, #1
 8004252:	f7ff fdc5 	bl	8003de0 <osalThreadDequeueAllI>
}
 8004256:	b003      	add	sp, #12
 8004258:	f85d fb04 	ldr.w	pc, [sp], #4
 800425c:	f3af 8000 	nop.w

08004260 <obqGetFullBufferI>:
 * @retval NULL         if the queue is empty.
 *
 * @iclass
 */
uint8_t *obqGetFullBufferI(output_buffers_queue_t *obqp,
                           size_t *sizep) {
 8004260:	b082      	sub	sp, #8
 8004262:	9001      	str	r0, [sp, #4]
 8004264:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassI();

  if (obqIsEmptyI(obqp)) {
 8004266:	9b01      	ldr	r3, [sp, #4]
 8004268:	68da      	ldr	r2, [r3, #12]
 800426a:	9b01      	ldr	r3, [sp, #4]
 800426c:	691b      	ldr	r3, [r3, #16]
 800426e:	429a      	cmp	r2, r3
 8004270:	d105      	bne.n	800427e <obqGetFullBufferI+0x1e>
 8004272:	9b01      	ldr	r3, [sp, #4]
 8004274:	689b      	ldr	r3, [r3, #8]
 8004276:	2b00      	cmp	r3, #0
 8004278:	d001      	beq.n	800427e <obqGetFullBufferI+0x1e>
 800427a:	2301      	movs	r3, #1
 800427c:	e000      	b.n	8004280 <obqGetFullBufferI+0x20>
 800427e:	2300      	movs	r3, #0
 8004280:	f003 0301 	and.w	r3, r3, #1
 8004284:	b2db      	uxtb	r3, r3
 8004286:	2b00      	cmp	r3, #0
 8004288:	d001      	beq.n	800428e <obqGetFullBufferI+0x2e>
    return NULL;
 800428a:	2300      	movs	r3, #0
 800428c:	e007      	b.n	800429e <obqGetFullBufferI+0x3e>
  }

  /* Buffer size.*/
  *sizep = *((size_t *)obqp->brdptr);
 800428e:	9b01      	ldr	r3, [sp, #4]
 8004290:	691b      	ldr	r3, [r3, #16]
 8004292:	681a      	ldr	r2, [r3, #0]
 8004294:	9b00      	ldr	r3, [sp, #0]
 8004296:	601a      	str	r2, [r3, #0]

  return obqp->brdptr + sizeof (size_t);
 8004298:	9b01      	ldr	r3, [sp, #4]
 800429a:	691b      	ldr	r3, [r3, #16]
 800429c:	3304      	adds	r3, #4
}
 800429e:	4618      	mov	r0, r3
 80042a0:	b002      	add	sp, #8
 80042a2:	4770      	bx	lr
 80042a4:	f3af 8000 	nop.w
 80042a8:	f3af 8000 	nop.w
 80042ac:	f3af 8000 	nop.w

080042b0 <obqReleaseEmptyBufferI>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @iclass
 */
void obqReleaseEmptyBufferI(output_buffers_queue_t *obqp) {
 80042b0:	b500      	push	{lr}
 80042b2:	b083      	sub	sp, #12
 80042b4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
 80042b6:	9b01      	ldr	r3, [sp, #4]
 80042b8:	689b      	ldr	r3, [r3, #8]
 80042ba:	1c5a      	adds	r2, r3, #1
 80042bc:	9b01      	ldr	r3, [sp, #4]
 80042be:	609a      	str	r2, [r3, #8]
  obqp->brdptr += obqp->bsize;
 80042c0:	9b01      	ldr	r3, [sp, #4]
 80042c2:	691a      	ldr	r2, [r3, #16]
 80042c4:	9b01      	ldr	r3, [sp, #4]
 80042c6:	699b      	ldr	r3, [r3, #24]
 80042c8:	441a      	add	r2, r3
 80042ca:	9b01      	ldr	r3, [sp, #4]
 80042cc:	611a      	str	r2, [r3, #16]
  if (obqp->brdptr >= obqp->btop) {
 80042ce:	9b01      	ldr	r3, [sp, #4]
 80042d0:	691a      	ldr	r2, [r3, #16]
 80042d2:	9b01      	ldr	r3, [sp, #4]
 80042d4:	695b      	ldr	r3, [r3, #20]
 80042d6:	429a      	cmp	r2, r3
 80042d8:	d303      	bcc.n	80042e2 <obqReleaseEmptyBufferI+0x32>
    obqp->brdptr = obqp->buffers;
 80042da:	9b01      	ldr	r3, [sp, #4]
 80042dc:	6a1a      	ldr	r2, [r3, #32]
 80042de:	9b01      	ldr	r3, [sp, #4]
 80042e0:	611a      	str	r2, [r3, #16]
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&obqp->waiting, MSG_OK);
 80042e2:	9b01      	ldr	r3, [sp, #4]
 80042e4:	4618      	mov	r0, r3
 80042e6:	2100      	movs	r1, #0
 80042e8:	f7ff fd6a 	bl	8003dc0 <osalThreadDequeueNextI>
}
 80042ec:	b003      	add	sp, #12
 80042ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80042f2:	bf00      	nop
 80042f4:	f3af 8000 	nop.w
 80042f8:	f3af 8000 	nop.w
 80042fc:	f3af 8000 	nop.w

08004300 <obqGetEmptyBufferTimeout>:
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t obqGetEmptyBufferTimeout(output_buffers_queue_t *obqp,
                                systime_t timeout) {
 8004300:	b500      	push	{lr}
 8004302:	b085      	sub	sp, #20
 8004304:	9001      	str	r0, [sp, #4]
 8004306:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalSysLock();
 8004308:	f7ff fd22 	bl	8003d50 <osalSysLock>
  msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 800430c:	9801      	ldr	r0, [sp, #4]
 800430e:	9900      	ldr	r1, [sp, #0]
 8004310:	f000 f80e 	bl	8004330 <obqGetEmptyBufferTimeoutS>
 8004314:	9003      	str	r0, [sp, #12]
  osalSysUnlock();
 8004316:	f7ff fd23 	bl	8003d60 <osalSysUnlock>

  return msg;
 800431a:	9b03      	ldr	r3, [sp, #12]
}
 800431c:	4618      	mov	r0, r3
 800431e:	b005      	add	sp, #20
 8004320:	f85d fb04 	ldr.w	pc, [sp], #4
 8004324:	f3af 8000 	nop.w
 8004328:	f3af 8000 	nop.w
 800432c:	f3af 8000 	nop.w

08004330 <obqGetEmptyBufferTimeoutS>:
   * @retval MSG_RESET    if the queue has been reset.
   *
   * @sclass
   */
  msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                  systime_t timeout) {
 8004330:	b500      	push	{lr}
 8004332:	b085      	sub	sp, #20
 8004334:	9001      	str	r0, [sp, #4]
 8004336:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassS();

  while (obqIsFullI(obqp)) {
 8004338:	e00a      	b.n	8004350 <obqGetEmptyBufferTimeoutS+0x20>
    msg_t msg = osalThreadEnqueueTimeoutS(&obqp->waiting, timeout);
 800433a:	9b01      	ldr	r3, [sp, #4]
 800433c:	4618      	mov	r0, r3
 800433e:	9900      	ldr	r1, [sp, #0]
 8004340:	f7ff fd2e 	bl	8003da0 <osalThreadEnqueueTimeoutS>
 8004344:	9003      	str	r0, [sp, #12]
    if (msg < MSG_OK) {
 8004346:	9b03      	ldr	r3, [sp, #12]
 8004348:	2b00      	cmp	r3, #0
 800434a:	da01      	bge.n	8004350 <obqGetEmptyBufferTimeoutS+0x20>
      return msg;
 800434c:	9b03      	ldr	r3, [sp, #12]
 800434e:	e010      	b.n	8004372 <obqGetEmptyBufferTimeoutS+0x42>
  msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                  systime_t timeout) {

  osalDbgCheckClassS();

  while (obqIsFullI(obqp)) {
 8004350:	9b01      	ldr	r3, [sp, #4]
 8004352:	689b      	ldr	r3, [r3, #8]
 8004354:	2b00      	cmp	r3, #0
 8004356:	d0f0      	beq.n	800433a <obqGetEmptyBufferTimeoutS+0xa>
  }

  osalDbgAssert(!obqIsFullI(obqp), "still full");

  /* Setting up the "current" buffer and its boundary.*/
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 8004358:	9b01      	ldr	r3, [sp, #4]
 800435a:	68db      	ldr	r3, [r3, #12]
 800435c:	1d1a      	adds	r2, r3, #4
 800435e:	9b01      	ldr	r3, [sp, #4]
 8004360:	625a      	str	r2, [r3, #36]	; 0x24
  obqp->top = obqp->bwrptr + obqp->bsize;
 8004362:	9b01      	ldr	r3, [sp, #4]
 8004364:	68da      	ldr	r2, [r3, #12]
 8004366:	9b01      	ldr	r3, [sp, #4]
 8004368:	699b      	ldr	r3, [r3, #24]
 800436a:	441a      	add	r2, r3
 800436c:	9b01      	ldr	r3, [sp, #4]
 800436e:	629a      	str	r2, [r3, #40]	; 0x28

  return MSG_OK;
 8004370:	2300      	movs	r3, #0
}
 8004372:	4618      	mov	r0, r3
 8004374:	b005      	add	sp, #20
 8004376:	f85d fb04 	ldr.w	pc, [sp], #4
 800437a:	bf00      	nop
 800437c:	f3af 8000 	nop.w

08004380 <obqPostFullBuffer>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @api
 */
void obqPostFullBuffer(output_buffers_queue_t *obqp, size_t size) {
 8004380:	b500      	push	{lr}
 8004382:	b083      	sub	sp, #12
 8004384:	9001      	str	r0, [sp, #4]
 8004386:	9100      	str	r1, [sp, #0]

  osalSysLock();
 8004388:	f7ff fce2 	bl	8003d50 <osalSysLock>
  obqPostFullBufferS(obqp, size);
 800438c:	9801      	ldr	r0, [sp, #4]
 800438e:	9900      	ldr	r1, [sp, #0]
 8004390:	f000 f806 	bl	80043a0 <obqPostFullBufferS>
  osalSysUnlock();
 8004394:	f7ff fce4 	bl	8003d60 <osalSysUnlock>
}
 8004398:	b003      	add	sp, #12
 800439a:	f85d fb04 	ldr.w	pc, [sp], #4
 800439e:	bf00      	nop

080043a0 <obqPostFullBufferS>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @sclass
 */
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {
 80043a0:	b500      	push	{lr}
 80043a2:	b083      	sub	sp, #12
 80043a4:	9001      	str	r0, [sp, #4]
 80043a6:	9100      	str	r1, [sp, #0]
  osalDbgCheckClassS();
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;
 80043a8:	9b01      	ldr	r3, [sp, #4]
 80043aa:	68db      	ldr	r3, [r3, #12]
 80043ac:	9a00      	ldr	r2, [sp, #0]
 80043ae:	601a      	str	r2, [r3, #0]

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
 80043b0:	9b01      	ldr	r3, [sp, #4]
 80043b2:	689b      	ldr	r3, [r3, #8]
 80043b4:	1e5a      	subs	r2, r3, #1
 80043b6:	9b01      	ldr	r3, [sp, #4]
 80043b8:	609a      	str	r2, [r3, #8]
  obqp->bwrptr += obqp->bsize;
 80043ba:	9b01      	ldr	r3, [sp, #4]
 80043bc:	68da      	ldr	r2, [r3, #12]
 80043be:	9b01      	ldr	r3, [sp, #4]
 80043c0:	699b      	ldr	r3, [r3, #24]
 80043c2:	441a      	add	r2, r3
 80043c4:	9b01      	ldr	r3, [sp, #4]
 80043c6:	60da      	str	r2, [r3, #12]
  if (obqp->bwrptr >= obqp->btop) {
 80043c8:	9b01      	ldr	r3, [sp, #4]
 80043ca:	68da      	ldr	r2, [r3, #12]
 80043cc:	9b01      	ldr	r3, [sp, #4]
 80043ce:	695b      	ldr	r3, [r3, #20]
 80043d0:	429a      	cmp	r2, r3
 80043d2:	d303      	bcc.n	80043dc <obqPostFullBufferS+0x3c>
    obqp->bwrptr = obqp->buffers;
 80043d4:	9b01      	ldr	r3, [sp, #4]
 80043d6:	6a1a      	ldr	r2, [r3, #32]
 80043d8:	9b01      	ldr	r3, [sp, #4]
 80043da:	60da      	str	r2, [r3, #12]
  }

  /* No "current" buffer.*/
  obqp->ptr = NULL;
 80043dc:	9b01      	ldr	r3, [sp, #4]
 80043de:	2200      	movs	r2, #0
 80043e0:	625a      	str	r2, [r3, #36]	; 0x24

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
 80043e2:	9b01      	ldr	r3, [sp, #4]
 80043e4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80043e6:	2b00      	cmp	r3, #0
 80043e8:	d003      	beq.n	80043f2 <obqPostFullBufferS+0x52>
    obqp->notify(obqp);
 80043ea:	9b01      	ldr	r3, [sp, #4]
 80043ec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80043ee:	9801      	ldr	r0, [sp, #4]
 80043f0:	4798      	blx	r3
  }
}
 80043f2:	b003      	add	sp, #12
 80043f4:	f85d fb04 	ldr.w	pc, [sp], #4
 80043f8:	f3af 8000 	nop.w
 80043fc:	f3af 8000 	nop.w

08004400 <obqPutTimeout>:
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t obqPutTimeout(output_buffers_queue_t *obqp, uint8_t b,
                    systime_t timeout) {
 8004400:	b500      	push	{lr}
 8004402:	b087      	sub	sp, #28
 8004404:	9003      	str	r0, [sp, #12]
 8004406:	460b      	mov	r3, r1
 8004408:	9201      	str	r2, [sp, #4]
 800440a:	f88d 300b 	strb.w	r3, [sp, #11]
  msg_t msg;

  osalSysLock();
 800440e:	f7ff fc9f 	bl	8003d50 <osalSysLock>

  /* This condition indicates that a new buffer must be acquired.*/
  if (obqp->ptr == NULL) {
 8004412:	9b03      	ldr	r3, [sp, #12]
 8004414:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004416:	2b00      	cmp	r3, #0
 8004418:	d10b      	bne.n	8004432 <obqPutTimeout+0x32>
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 800441a:	9803      	ldr	r0, [sp, #12]
 800441c:	9901      	ldr	r1, [sp, #4]
 800441e:	f7ff ff87 	bl	8004330 <obqGetEmptyBufferTimeoutS>
 8004422:	9005      	str	r0, [sp, #20]
    if (msg != MSG_OK) {
 8004424:	9b05      	ldr	r3, [sp, #20]
 8004426:	2b00      	cmp	r3, #0
 8004428:	d003      	beq.n	8004432 <obqPutTimeout+0x32>
      osalSysUnlock();
 800442a:	f7ff fc99 	bl	8003d60 <osalSysUnlock>
      return msg;
 800442e:	9b05      	ldr	r3, [sp, #20]
 8004430:	e019      	b.n	8004466 <obqPutTimeout+0x66>
    }
  }

  /* Writing the byte to the buffer.*/
  *obqp->ptr = b;
 8004432:	9b03      	ldr	r3, [sp, #12]
 8004434:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004436:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800443a:	701a      	strb	r2, [r3, #0]
  obqp->ptr++;
 800443c:	9b03      	ldr	r3, [sp, #12]
 800443e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004440:	1c5a      	adds	r2, r3, #1
 8004442:	9b03      	ldr	r3, [sp, #12]
 8004444:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
 8004446:	9b03      	ldr	r3, [sp, #12]
 8004448:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800444a:	9b03      	ldr	r3, [sp, #12]
 800444c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800444e:	429a      	cmp	r2, r3
 8004450:	d306      	bcc.n	8004460 <obqPutTimeout+0x60>
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8004452:	9b03      	ldr	r3, [sp, #12]
 8004454:	699b      	ldr	r3, [r3, #24]
 8004456:	3b04      	subs	r3, #4
 8004458:	9803      	ldr	r0, [sp, #12]
 800445a:	4619      	mov	r1, r3
 800445c:	f7ff ffa0 	bl	80043a0 <obqPostFullBufferS>
  }

  osalSysUnlock();
 8004460:	f7ff fc7e 	bl	8003d60 <osalSysUnlock>
  return MSG_OK;
 8004464:	2300      	movs	r3, #0
}
 8004466:	4618      	mov	r0, r3
 8004468:	b007      	add	sp, #28
 800446a:	f85d fb04 	ldr.w	pc, [sp], #4
 800446e:	bf00      	nop

08004470 <obqWriteTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
                       size_t n, systime_t timeout) {
 8004470:	b500      	push	{lr}
 8004472:	b08b      	sub	sp, #44	; 0x2c
 8004474:	9003      	str	r0, [sp, #12]
 8004476:	9102      	str	r1, [sp, #8]
 8004478:	9201      	str	r2, [sp, #4]
 800447a:	9300      	str	r3, [sp, #0]
  size_t w = 0;
 800447c:	2300      	movs	r3, #0
 800447e:	9309      	str	r3, [sp, #36]	; 0x24
  systime_t deadline;

  osalSysLock();
 8004480:	f7ff fc66 	bl	8003d50 <osalSysLock>

  /* Time window for the whole operation.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8004484:	f7ff fc74 	bl	8003d70 <osalOsGetSystemTimeX>
 8004488:	4602      	mov	r2, r0
 800448a:	9b00      	ldr	r3, [sp, #0]
 800448c:	4413      	add	r3, r2
 800448e:	9306      	str	r3, [sp, #24]

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (obqp->ptr == NULL) {
 8004490:	9b03      	ldr	r3, [sp, #12]
 8004492:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004494:	2b00      	cmp	r3, #0
 8004496:	d126      	bne.n	80044e6 <obqWriteTimeout+0x76>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8004498:	9b00      	ldr	r3, [sp, #0]
 800449a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800449e:	d002      	beq.n	80044a6 <obqWriteTimeout+0x36>
 80044a0:	9b00      	ldr	r3, [sp, #0]
 80044a2:	2b00      	cmp	r3, #0
 80044a4:	d105      	bne.n	80044b2 <obqWriteTimeout+0x42>
        msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 80044a6:	9803      	ldr	r0, [sp, #12]
 80044a8:	9900      	ldr	r1, [sp, #0]
 80044aa:	f7ff ff41 	bl	8004330 <obqGetEmptyBufferTimeoutS>
 80044ae:	9007      	str	r0, [sp, #28]
 80044b0:	e012      	b.n	80044d8 <obqWriteTimeout+0x68>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 80044b2:	f7ff fc5d 	bl	8003d70 <osalOsGetSystemTimeX>
 80044b6:	4603      	mov	r3, r0
 80044b8:	9a06      	ldr	r2, [sp, #24]
 80044ba:	1ad3      	subs	r3, r2, r3
 80044bc:	9305      	str	r3, [sp, #20]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 80044be:	9a05      	ldr	r2, [sp, #20]
 80044c0:	9b00      	ldr	r3, [sp, #0]
 80044c2:	429a      	cmp	r2, r3
 80044c4:	d903      	bls.n	80044ce <obqWriteTimeout+0x5e>
          osalSysUnlock();
 80044c6:	f7ff fc4b 	bl	8003d60 <osalSysUnlock>
          return w;
 80044ca:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80044cc:	e060      	b.n	8004590 <obqWriteTimeout+0x120>
        }
        msg = obqGetEmptyBufferTimeoutS(obqp, next_timeout);
 80044ce:	9803      	ldr	r0, [sp, #12]
 80044d0:	9905      	ldr	r1, [sp, #20]
 80044d2:	f7ff ff2d 	bl	8004330 <obqGetEmptyBufferTimeoutS>
 80044d6:	9007      	str	r0, [sp, #28]
      }

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 80044d8:	9b07      	ldr	r3, [sp, #28]
 80044da:	2b00      	cmp	r3, #0
 80044dc:	d003      	beq.n	80044e6 <obqWriteTimeout+0x76>
        osalSysUnlock();
 80044de:	f7ff fc3f 	bl	8003d60 <osalSysUnlock>
        return w;
 80044e2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80044e4:	e054      	b.n	8004590 <obqWriteTimeout+0x120>
      }
    }

    /* Size of the space available in the current buffer.*/
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 80044e6:	9b03      	ldr	r3, [sp, #12]
 80044e8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80044ea:	461a      	mov	r2, r3
 80044ec:	9b03      	ldr	r3, [sp, #12]
 80044ee:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80044f0:	1ad3      	subs	r3, r2, r3
 80044f2:	9308      	str	r3, [sp, #32]
    if (size > (n - w)) {
 80044f4:	9a01      	ldr	r2, [sp, #4]
 80044f6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80044f8:	1ad2      	subs	r2, r2, r3
 80044fa:	9b08      	ldr	r3, [sp, #32]
 80044fc:	429a      	cmp	r2, r3
 80044fe:	d203      	bcs.n	8004508 <obqWriteTimeout+0x98>
      size = n - w;
 8004500:	9a01      	ldr	r2, [sp, #4]
 8004502:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004504:	1ad3      	subs	r3, r2, r3
 8004506:	9308      	str	r3, [sp, #32]
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
 8004508:	9b08      	ldr	r3, [sp, #32]
 800450a:	2b40      	cmp	r3, #64	; 0x40
 800450c:	d913      	bls.n	8004536 <obqWriteTimeout+0xc6>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, 64U);
 800450e:	9b03      	ldr	r3, [sp, #12]
 8004510:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004512:	4618      	mov	r0, r3
 8004514:	9902      	ldr	r1, [sp, #8]
 8004516:	2240      	movs	r2, #64	; 0x40
 8004518:	f011 fa72 	bl	8015a00 <memcpy>
      bp        += 64U;
 800451c:	9b02      	ldr	r3, [sp, #8]
 800451e:	3340      	adds	r3, #64	; 0x40
 8004520:	9302      	str	r3, [sp, #8]
      obqp->ptr += 64U;
 8004522:	9b03      	ldr	r3, [sp, #12]
 8004524:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004526:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800452a:	9b03      	ldr	r3, [sp, #12]
 800452c:	625a      	str	r2, [r3, #36]	; 0x24
      w         += 64U;
 800452e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004530:	3340      	adds	r3, #64	; 0x40
 8004532:	9309      	str	r3, [sp, #36]	; 0x24
 8004534:	e014      	b.n	8004560 <obqWriteTimeout+0xf0>
    }
    else {
      memcpy(obqp->ptr, bp, size);
 8004536:	9b03      	ldr	r3, [sp, #12]
 8004538:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800453a:	4618      	mov	r0, r3
 800453c:	9902      	ldr	r1, [sp, #8]
 800453e:	9a08      	ldr	r2, [sp, #32]
 8004540:	f011 fa5e 	bl	8015a00 <memcpy>
      bp        += size;
 8004544:	9a02      	ldr	r2, [sp, #8]
 8004546:	9b08      	ldr	r3, [sp, #32]
 8004548:	4413      	add	r3, r2
 800454a:	9302      	str	r3, [sp, #8]
      obqp->ptr += size;
 800454c:	9b03      	ldr	r3, [sp, #12]
 800454e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004550:	9b08      	ldr	r3, [sp, #32]
 8004552:	441a      	add	r2, r3
 8004554:	9b03      	ldr	r3, [sp, #12]
 8004556:	625a      	str	r2, [r3, #36]	; 0x24
      w         += size;
 8004558:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800455a:	9b08      	ldr	r3, [sp, #32]
 800455c:	4413      	add	r3, r2
 800455e:	9309      	str	r3, [sp, #36]	; 0x24
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 8004560:	9b03      	ldr	r3, [sp, #12]
 8004562:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004564:	9b03      	ldr	r3, [sp, #12]
 8004566:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004568:	429a      	cmp	r2, r3
 800456a:	d306      	bcc.n	800457a <obqWriteTimeout+0x10a>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 800456c:	9b03      	ldr	r3, [sp, #12]
 800456e:	699b      	ldr	r3, [r3, #24]
 8004570:	3b04      	subs	r3, #4
 8004572:	9803      	ldr	r0, [sp, #12]
 8004574:	4619      	mov	r1, r3
 8004576:	f7ff ff13 	bl	80043a0 <obqPostFullBufferS>
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
 800457a:	f7ff fbf1 	bl	8003d60 <osalSysUnlock>
    if (w >= n) {
 800457e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8004580:	9b01      	ldr	r3, [sp, #4]
 8004582:	429a      	cmp	r2, r3
 8004584:	d301      	bcc.n	800458a <obqWriteTimeout+0x11a>
      return w;
 8004586:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004588:	e002      	b.n	8004590 <obqWriteTimeout+0x120>
    }
    osalSysLock();
 800458a:	f7ff fbe1 	bl	8003d50 <osalSysLock>
  }
 800458e:	e77f      	b.n	8004490 <obqWriteTimeout+0x20>
}
 8004590:	4618      	mov	r0, r3
 8004592:	b00b      	add	sp, #44	; 0x2c
 8004594:	f85d fb04 	ldr.w	pc, [sp], #4
 8004598:	f3af 8000 	nop.w
 800459c:	f3af 8000 	nop.w

080045a0 <obqTryFlushI>:
 * @retval false        if no new filled buffer has been posted to the queue.
 * @retval true         if a new filled buffer has been posted to the queue.
 *
 * @iclass
 */
bool obqTryFlushI(output_buffers_queue_t *obqp) {
 80045a0:	b084      	sub	sp, #16
 80045a2:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 80045a4:	9b01      	ldr	r3, [sp, #4]
 80045a6:	68da      	ldr	r2, [r3, #12]
 80045a8:	9b01      	ldr	r3, [sp, #4]
 80045aa:	691b      	ldr	r3, [r3, #16]
 80045ac:	429a      	cmp	r2, r3
 80045ae:	d105      	bne.n	80045bc <obqTryFlushI+0x1c>
 80045b0:	9b01      	ldr	r3, [sp, #4]
 80045b2:	689b      	ldr	r3, [r3, #8]
 80045b4:	2b00      	cmp	r3, #0
 80045b6:	d001      	beq.n	80045bc <obqTryFlushI+0x1c>
 80045b8:	2301      	movs	r3, #1
 80045ba:	e000      	b.n	80045be <obqTryFlushI+0x1e>
 80045bc:	2300      	movs	r3, #0
 80045be:	f003 0301 	and.w	r3, r3, #1
 80045c2:	b2db      	uxtb	r3, r3
 80045c4:	2b00      	cmp	r3, #0
 80045c6:	d02d      	beq.n	8004624 <obqTryFlushI+0x84>
 80045c8:	9b01      	ldr	r3, [sp, #4]
 80045ca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80045cc:	2b00      	cmp	r3, #0
 80045ce:	d029      	beq.n	8004624 <obqTryFlushI+0x84>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
 80045d0:	9b01      	ldr	r3, [sp, #4]
 80045d2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80045d4:	461a      	mov	r2, r3
 80045d6:	9b01      	ldr	r3, [sp, #4]
 80045d8:	68db      	ldr	r3, [r3, #12]
 80045da:	1ad3      	subs	r3, r2, r3
 80045dc:	3b04      	subs	r3, #4
 80045de:	9303      	str	r3, [sp, #12]

    if (size > 0U) {
 80045e0:	9b03      	ldr	r3, [sp, #12]
 80045e2:	2b00      	cmp	r3, #0
 80045e4:	d01e      	beq.n	8004624 <obqTryFlushI+0x84>

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;
 80045e6:	9b01      	ldr	r3, [sp, #4]
 80045e8:	68db      	ldr	r3, [r3, #12]
 80045ea:	9a03      	ldr	r2, [sp, #12]
 80045ec:	601a      	str	r2, [r3, #0]

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
 80045ee:	9b01      	ldr	r3, [sp, #4]
 80045f0:	689b      	ldr	r3, [r3, #8]
 80045f2:	1e5a      	subs	r2, r3, #1
 80045f4:	9b01      	ldr	r3, [sp, #4]
 80045f6:	609a      	str	r2, [r3, #8]
      obqp->bwrptr += obqp->bsize;
 80045f8:	9b01      	ldr	r3, [sp, #4]
 80045fa:	68da      	ldr	r2, [r3, #12]
 80045fc:	9b01      	ldr	r3, [sp, #4]
 80045fe:	699b      	ldr	r3, [r3, #24]
 8004600:	441a      	add	r2, r3
 8004602:	9b01      	ldr	r3, [sp, #4]
 8004604:	60da      	str	r2, [r3, #12]
      if (obqp->bwrptr >= obqp->btop) {
 8004606:	9b01      	ldr	r3, [sp, #4]
 8004608:	68da      	ldr	r2, [r3, #12]
 800460a:	9b01      	ldr	r3, [sp, #4]
 800460c:	695b      	ldr	r3, [r3, #20]
 800460e:	429a      	cmp	r2, r3
 8004610:	d303      	bcc.n	800461a <obqTryFlushI+0x7a>
        obqp->bwrptr = obqp->buffers;
 8004612:	9b01      	ldr	r3, [sp, #4]
 8004614:	6a1a      	ldr	r2, [r3, #32]
 8004616:	9b01      	ldr	r3, [sp, #4]
 8004618:	60da      	str	r2, [r3, #12]
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
 800461a:	9b01      	ldr	r3, [sp, #4]
 800461c:	2200      	movs	r2, #0
 800461e:	625a      	str	r2, [r3, #36]	; 0x24

      return true;
 8004620:	2301      	movs	r3, #1
 8004622:	e000      	b.n	8004626 <obqTryFlushI+0x86>
    }
  }
  return false;
 8004624:	2300      	movs	r3, #0
}
 8004626:	4618      	mov	r0, r3
 8004628:	b004      	add	sp, #16
 800462a:	4770      	bx	lr
 800462c:	f3af 8000 	nop.w

08004630 <obqFlush>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @api
 */
void obqFlush(output_buffers_queue_t *obqp) {
 8004630:	b500      	push	{lr}
 8004632:	b085      	sub	sp, #20
 8004634:	9001      	str	r0, [sp, #4]

  osalSysLock();
 8004636:	f7ff fb8b 	bl	8003d50 <osalSysLock>

  /* If there is a buffer partially filled and not being written.*/
  if (obqp->ptr != NULL) {
 800463a:	9b01      	ldr	r3, [sp, #4]
 800463c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800463e:	2b00      	cmp	r3, #0
 8004640:	d00e      	beq.n	8004660 <obqFlush+0x30>
    size_t size = (size_t)obqp->ptr - (size_t)obqp->bwrptr - sizeof (size_t);
 8004642:	9b01      	ldr	r3, [sp, #4]
 8004644:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004646:	461a      	mov	r2, r3
 8004648:	9b01      	ldr	r3, [sp, #4]
 800464a:	68db      	ldr	r3, [r3, #12]
 800464c:	1ad3      	subs	r3, r2, r3
 800464e:	3b04      	subs	r3, #4
 8004650:	9303      	str	r3, [sp, #12]

    if (size > 0U) {
 8004652:	9b03      	ldr	r3, [sp, #12]
 8004654:	2b00      	cmp	r3, #0
 8004656:	d003      	beq.n	8004660 <obqFlush+0x30>
      obqPostFullBufferS(obqp, size);
 8004658:	9801      	ldr	r0, [sp, #4]
 800465a:	9903      	ldr	r1, [sp, #12]
 800465c:	f7ff fea0 	bl	80043a0 <obqPostFullBufferS>
    }
  }

  osalSysUnlock();
 8004660:	f7ff fb7e 	bl	8003d60 <osalSysUnlock>
}
 8004664:	b005      	add	sp, #20
 8004666:	f85d fb04 	ldr.w	pc, [sp], #4
 800466a:	bf00      	nop
 800466c:	f3af 8000 	nop.w

08004670 <_mmcsd_get_slice>:
 *
 * @notapi
 */
uint32_t _mmcsd_get_slice(const uint32_t *data,
                          uint32_t end,
                          uint32_t start) {
 8004670:	b088      	sub	sp, #32
 8004672:	9003      	str	r0, [sp, #12]
 8004674:	9102      	str	r1, [sp, #8]
 8004676:	9201      	str	r2, [sp, #4]
  unsigned startidx, endidx, startoff;
  uint32_t endmask;

  osalDbgCheck((end >= start) && ((end - start) < 32U));

  startidx = start / 32U;
 8004678:	9b01      	ldr	r3, [sp, #4]
 800467a:	095b      	lsrs	r3, r3, #5
 800467c:	9307      	str	r3, [sp, #28]
  startoff = start % 32U;
 800467e:	9b01      	ldr	r3, [sp, #4]
 8004680:	f003 031f 	and.w	r3, r3, #31
 8004684:	9306      	str	r3, [sp, #24]
  endidx   = end / 32U;
 8004686:	9b02      	ldr	r3, [sp, #8]
 8004688:	095b      	lsrs	r3, r3, #5
 800468a:	9305      	str	r3, [sp, #20]
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;
 800468c:	9b02      	ldr	r3, [sp, #8]
 800468e:	f003 031f 	and.w	r3, r3, #31
 8004692:	3301      	adds	r3, #1
 8004694:	2201      	movs	r2, #1
 8004696:	fa02 f303 	lsl.w	r3, r2, r3
 800469a:	3b01      	subs	r3, #1
 800469c:	9304      	str	r3, [sp, #16]

  /* One or two pieces?*/
  if (startidx < endidx) {
 800469e:	9a07      	ldr	r2, [sp, #28]
 80046a0:	9b05      	ldr	r3, [sp, #20]
 80046a2:	429a      	cmp	r2, r3
 80046a4:	d214      	bcs.n	80046d0 <_mmcsd_get_slice+0x60>
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 80046a6:	9b07      	ldr	r3, [sp, #28]
 80046a8:	009b      	lsls	r3, r3, #2
 80046aa:	9a03      	ldr	r2, [sp, #12]
 80046ac:	4413      	add	r3, r2
 80046ae:	681a      	ldr	r2, [r3, #0]
 80046b0:	9b06      	ldr	r3, [sp, #24]
 80046b2:	40da      	lsrs	r2, r3
           ((data[endidx] & endmask) << (32U - startoff));
 80046b4:	9b05      	ldr	r3, [sp, #20]
 80046b6:	009b      	lsls	r3, r3, #2
 80046b8:	9903      	ldr	r1, [sp, #12]
 80046ba:	440b      	add	r3, r1
 80046bc:	6819      	ldr	r1, [r3, #0]
 80046be:	9b04      	ldr	r3, [sp, #16]
 80046c0:	4019      	ands	r1, r3
 80046c2:	9b06      	ldr	r3, [sp, #24]
 80046c4:	f1c3 0320 	rsb	r3, r3, #32
 80046c8:	fa01 f303 	lsl.w	r3, r1, r3
  endidx   = end / 32U;
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;

  /* One or two pieces?*/
  if (startidx < endidx) {
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 80046cc:	4313      	orrs	r3, r2
 80046ce:	e009      	b.n	80046e4 <_mmcsd_get_slice+0x74>
           ((data[endidx] & endmask) << (32U - startoff));
  }
  return (data[startidx] & endmask) >> startoff;        /* One piece case.  */
 80046d0:	9b07      	ldr	r3, [sp, #28]
 80046d2:	009b      	lsls	r3, r3, #2
 80046d4:	9a03      	ldr	r2, [sp, #12]
 80046d6:	4413      	add	r3, r2
 80046d8:	681a      	ldr	r2, [r3, #0]
 80046da:	9b04      	ldr	r3, [sp, #16]
 80046dc:	401a      	ands	r2, r3
 80046de:	9b06      	ldr	r3, [sp, #24]
 80046e0:	fa22 f303 	lsr.w	r3, r2, r3
}
 80046e4:	4618      	mov	r0, r3
 80046e6:	b008      	add	sp, #32
 80046e8:	4770      	bx	lr
 80046ea:	bf00      	nop
 80046ec:	f3af 8000 	nop.w

080046f0 <_mmcsd_get_capacity>:
 * @return              The card capacity.
 * @retval 0            CSD format error
 *
 * @notapi
 */
uint32_t _mmcsd_get_capacity(const uint32_t *csd) {
 80046f0:	b500      	push	{lr}
 80046f2:	b087      	sub	sp, #28
 80046f4:	9001      	str	r0, [sp, #4]
  uint32_t a, b, c;

  osalDbgCheck(NULL != csd);

  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 80046f6:	9801      	ldr	r0, [sp, #4]
 80046f8:	217f      	movs	r1, #127	; 0x7f
 80046fa:	227e      	movs	r2, #126	; 0x7e
 80046fc:	f7ff ffb8 	bl	8004670 <_mmcsd_get_slice>
 8004700:	4603      	mov	r3, r0
 8004702:	2b00      	cmp	r3, #0
 8004704:	d004      	beq.n	8004710 <_mmcsd_get_capacity+0x20>
 8004706:	2b01      	cmp	r3, #1
 8004708:	d01e      	beq.n	8004748 <_mmcsd_get_capacity+0x58>
  case 1:
    /* CSD version 2.0.*/
    return 1024U * (_mmcsd_get_slice(csd, MMCSD_CSD_20_C_SIZE_SLICE) + 1U);
  default:
    /* Reserved value detected.*/
    break;
 800470a:	bf00      	nop
  }
  return 0U;
 800470c:	2300      	movs	r3, #0
 800470e:	e023      	b.n	8004758 <_mmcsd_get_capacity+0x68>
  osalDbgCheck(NULL != csd);

  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
  case 0:
    /* CSD version 1.0 */
    a = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_SLICE);
 8004710:	9801      	ldr	r0, [sp, #4]
 8004712:	2149      	movs	r1, #73	; 0x49
 8004714:	223e      	movs	r2, #62	; 0x3e
 8004716:	f7ff ffab 	bl	8004670 <_mmcsd_get_slice>
 800471a:	9005      	str	r0, [sp, #20]
    b = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_MULT_SLICE);
 800471c:	9801      	ldr	r0, [sp, #4]
 800471e:	2131      	movs	r1, #49	; 0x31
 8004720:	222f      	movs	r2, #47	; 0x2f
 8004722:	f7ff ffa5 	bl	8004670 <_mmcsd_get_slice>
 8004726:	9004      	str	r0, [sp, #16]
    c = _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_LEN_SLICE);
 8004728:	9801      	ldr	r0, [sp, #4]
 800472a:	2153      	movs	r1, #83	; 0x53
 800472c:	2250      	movs	r2, #80	; 0x50
 800472e:	f7ff ff9f 	bl	8004670 <_mmcsd_get_slice>
 8004732:	9003      	str	r0, [sp, #12]
    return ((a + 1U) << (b + 2U)) << (c - 9U);  /* 2^9 == MMCSD_BLOCK_SIZE. */
 8004734:	9b05      	ldr	r3, [sp, #20]
 8004736:	1c5a      	adds	r2, r3, #1
 8004738:	9b04      	ldr	r3, [sp, #16]
 800473a:	3302      	adds	r3, #2
 800473c:	409a      	lsls	r2, r3
 800473e:	9b03      	ldr	r3, [sp, #12]
 8004740:	3b09      	subs	r3, #9
 8004742:	fa02 f303 	lsl.w	r3, r2, r3
 8004746:	e007      	b.n	8004758 <_mmcsd_get_capacity+0x68>
  case 1:
    /* CSD version 2.0.*/
    return 1024U * (_mmcsd_get_slice(csd, MMCSD_CSD_20_C_SIZE_SLICE) + 1U);
 8004748:	9801      	ldr	r0, [sp, #4]
 800474a:	2145      	movs	r1, #69	; 0x45
 800474c:	2230      	movs	r2, #48	; 0x30
 800474e:	f7ff ff8f 	bl	8004670 <_mmcsd_get_slice>
 8004752:	4603      	mov	r3, r0
 8004754:	3301      	adds	r3, #1
 8004756:	029b      	lsls	r3, r3, #10
  default:
    /* Reserved value detected.*/
    break;
  }
  return 0U;
}
 8004758:	4618      	mov	r0, r3
 800475a:	b007      	add	sp, #28
 800475c:	f85d fb04 	ldr.w	pc, [sp], #4

08004760 <_mmcsd_get_capacity_ext>:
 *
 * @return              The card capacity.
 *
 * @notapi
 */
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {
 8004760:	b082      	sub	sp, #8
 8004762:	9001      	str	r0, [sp, #4]

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
 8004764:	9b01      	ldr	r3, [sp, #4]
 8004766:	33d7      	adds	r3, #215	; 0xd7
 8004768:	781b      	ldrb	r3, [r3, #0]
 800476a:	061a      	lsls	r2, r3, #24
         ((uint32_t)ext_csd[214] << 16U) +
 800476c:	9b01      	ldr	r3, [sp, #4]
 800476e:	33d6      	adds	r3, #214	; 0xd6
 8004770:	781b      	ldrb	r3, [r3, #0]
 8004772:	041b      	lsls	r3, r3, #16
 */
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
 8004774:	441a      	add	r2, r3
         ((uint32_t)ext_csd[214] << 16U) +
         ((uint32_t)ext_csd[213] << 8U)  +
 8004776:	9b01      	ldr	r3, [sp, #4]
 8004778:	33d5      	adds	r3, #213	; 0xd5
 800477a:	781b      	ldrb	r3, [r3, #0]
 800477c:	021b      	lsls	r3, r3, #8
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
         ((uint32_t)ext_csd[214] << 16U) +
 800477e:	441a      	add	r2, r3
         ((uint32_t)ext_csd[213] << 8U)  +
         (uint32_t)ext_csd[212];
 8004780:	9b01      	ldr	r3, [sp, #4]
 8004782:	33d4      	adds	r3, #212	; 0xd4
 8004784:	781b      	ldrb	r3, [r3, #0]
 */
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
 8004786:	4413      	add	r3, r2
         ((uint32_t)ext_csd[214] << 16U) +
         ((uint32_t)ext_csd[213] << 8U)  +
         (uint32_t)ext_csd[212];
}
 8004788:	4618      	mov	r0, r3
 800478a:	b002      	add	sp, #8
 800478c:	4770      	bx	lr
 800478e:	bf00      	nop

08004790 <_mmcsd_unpack_sdc_cid>:
 * @param[out] cidsdc   pointer to the @p unpacked_sdc_cid_t object
 *
 * @notapi
 */
void _mmcsd_unpack_sdc_cid(const MMCSDBlockDevice *sdcp,
                           unpacked_sdc_cid_t *cidsdc) {
 8004790:	b500      	push	{lr}
 8004792:	b085      	sub	sp, #20
 8004794:	9001      	str	r0, [sp, #4]
 8004796:	9100      	str	r1, [sp, #0]
  const uint32_t *cid;

  osalDbgCheck((NULL != sdcp) && (NULL != cidsdc));

  cid = sdcp->cid;
 8004798:	9b01      	ldr	r3, [sp, #4]
 800479a:	3308      	adds	r3, #8
 800479c:	9303      	str	r3, [sp, #12]
  cidsdc->crc    = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_SDC_CRC_SLICE);
 800479e:	9803      	ldr	r0, [sp, #12]
 80047a0:	2107      	movs	r1, #7
 80047a2:	2201      	movs	r2, #1
 80047a4:	f7ff ff64 	bl	8004670 <_mmcsd_get_slice>
 80047a8:	4603      	mov	r3, r0
 80047aa:	b2da      	uxtb	r2, r3
 80047ac:	9b00      	ldr	r3, [sp, #0]
 80047ae:	751a      	strb	r2, [r3, #20]
  cidsdc->mdt_y  = (uint16_t)_mmcsd_get_slice(cid, MMCSD_CID_SDC_MDT_Y_SLICE) +
 80047b0:	9803      	ldr	r0, [sp, #12]
 80047b2:	2113      	movs	r1, #19
 80047b4:	220c      	movs	r2, #12
 80047b6:	f7ff ff5b 	bl	8004670 <_mmcsd_get_slice>
 80047ba:	4603      	mov	r3, r0
 80047bc:	b29b      	uxth	r3, r3
 80047be:	f503 63fa 	add.w	r3, r3, #2000	; 0x7d0
 80047c2:	b29a      	uxth	r2, r3
 80047c4:	9b00      	ldr	r3, [sp, #0]
 80047c6:	825a      	strh	r2, [r3, #18]
                             2000U;
  cidsdc->mdt_m  = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_SDC_MDT_M_SLICE);
 80047c8:	9803      	ldr	r0, [sp, #12]
 80047ca:	210b      	movs	r1, #11
 80047cc:	2208      	movs	r2, #8
 80047ce:	f7ff ff4f 	bl	8004670 <_mmcsd_get_slice>
 80047d2:	4603      	mov	r3, r0
 80047d4:	b2da      	uxtb	r2, r3
 80047d6:	9b00      	ldr	r3, [sp, #0]
 80047d8:	741a      	strb	r2, [r3, #16]
  cidsdc->mid    = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_SDC_MID_SLICE);
 80047da:	9803      	ldr	r0, [sp, #12]
 80047dc:	217f      	movs	r1, #127	; 0x7f
 80047de:	2278      	movs	r2, #120	; 0x78
 80047e0:	f7ff ff46 	bl	8004670 <_mmcsd_get_slice>
 80047e4:	4603      	mov	r3, r0
 80047e6:	b2da      	uxtb	r2, r3
 80047e8:	9b00      	ldr	r3, [sp, #0]
 80047ea:	701a      	strb	r2, [r3, #0]
  cidsdc->oid    = (uint16_t)_mmcsd_get_slice(cid, MMCSD_CID_SDC_OID_SLICE);
 80047ec:	9803      	ldr	r0, [sp, #12]
 80047ee:	2177      	movs	r1, #119	; 0x77
 80047f0:	2268      	movs	r2, #104	; 0x68
 80047f2:	f7ff ff3d 	bl	8004670 <_mmcsd_get_slice>
 80047f6:	4603      	mov	r3, r0
 80047f8:	b29a      	uxth	r2, r3
 80047fa:	9b00      	ldr	r3, [sp, #0]
 80047fc:	805a      	strh	r2, [r3, #2]
  cidsdc->pnm[4] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_SDC_PNM0_SLICE);
 80047fe:	9803      	ldr	r0, [sp, #12]
 8004800:	2147      	movs	r1, #71	; 0x47
 8004802:	2240      	movs	r2, #64	; 0x40
 8004804:	f7ff ff34 	bl	8004670 <_mmcsd_get_slice>
 8004808:	4603      	mov	r3, r0
 800480a:	b2da      	uxtb	r2, r3
 800480c:	9b00      	ldr	r3, [sp, #0]
 800480e:	721a      	strb	r2, [r3, #8]
  cidsdc->pnm[3] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_SDC_PNM1_SLICE);
 8004810:	9803      	ldr	r0, [sp, #12]
 8004812:	214f      	movs	r1, #79	; 0x4f
 8004814:	2248      	movs	r2, #72	; 0x48
 8004816:	f7ff ff2b 	bl	8004670 <_mmcsd_get_slice>
 800481a:	4603      	mov	r3, r0
 800481c:	b2da      	uxtb	r2, r3
 800481e:	9b00      	ldr	r3, [sp, #0]
 8004820:	71da      	strb	r2, [r3, #7]
  cidsdc->pnm[2] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_SDC_PNM2_SLICE);
 8004822:	9803      	ldr	r0, [sp, #12]
 8004824:	2157      	movs	r1, #87	; 0x57
 8004826:	2250      	movs	r2, #80	; 0x50
 8004828:	f7ff ff22 	bl	8004670 <_mmcsd_get_slice>
 800482c:	4603      	mov	r3, r0
 800482e:	b2da      	uxtb	r2, r3
 8004830:	9b00      	ldr	r3, [sp, #0]
 8004832:	719a      	strb	r2, [r3, #6]
  cidsdc->pnm[1] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_SDC_PNM3_SLICE);
 8004834:	9803      	ldr	r0, [sp, #12]
 8004836:	215f      	movs	r1, #95	; 0x5f
 8004838:	2258      	movs	r2, #88	; 0x58
 800483a:	f7ff ff19 	bl	8004670 <_mmcsd_get_slice>
 800483e:	4603      	mov	r3, r0
 8004840:	b2da      	uxtb	r2, r3
 8004842:	9b00      	ldr	r3, [sp, #0]
 8004844:	715a      	strb	r2, [r3, #5]
  cidsdc->pnm[0] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_SDC_PNM4_SLICE);
 8004846:	9803      	ldr	r0, [sp, #12]
 8004848:	2167      	movs	r1, #103	; 0x67
 800484a:	2260      	movs	r2, #96	; 0x60
 800484c:	f7ff ff10 	bl	8004670 <_mmcsd_get_slice>
 8004850:	4603      	mov	r3, r0
 8004852:	b2da      	uxtb	r2, r3
 8004854:	9b00      	ldr	r3, [sp, #0]
 8004856:	711a      	strb	r2, [r3, #4]
  cidsdc->prv_n  = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_SDC_PRV_N_SLICE);
 8004858:	9803      	ldr	r0, [sp, #12]
 800485a:	213f      	movs	r1, #63	; 0x3f
 800485c:	223c      	movs	r2, #60	; 0x3c
 800485e:	f7ff ff07 	bl	8004670 <_mmcsd_get_slice>
 8004862:	4603      	mov	r3, r0
 8004864:	b2da      	uxtb	r2, r3
 8004866:	9b00      	ldr	r3, [sp, #0]
 8004868:	725a      	strb	r2, [r3, #9]
  cidsdc->prv_m  = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_SDC_PRV_M_SLICE);
 800486a:	9803      	ldr	r0, [sp, #12]
 800486c:	213b      	movs	r1, #59	; 0x3b
 800486e:	2238      	movs	r2, #56	; 0x38
 8004870:	f7ff fefe 	bl	8004670 <_mmcsd_get_slice>
 8004874:	4603      	mov	r3, r0
 8004876:	b2da      	uxtb	r2, r3
 8004878:	9b00      	ldr	r3, [sp, #0]
 800487a:	729a      	strb	r2, [r3, #10]
  cidsdc->psn    =           _mmcsd_get_slice(cid, MMCSD_CID_SDC_PSN_SLICE);
 800487c:	9803      	ldr	r0, [sp, #12]
 800487e:	2137      	movs	r1, #55	; 0x37
 8004880:	2218      	movs	r2, #24
 8004882:	f7ff fef5 	bl	8004670 <_mmcsd_get_slice>
 8004886:	4602      	mov	r2, r0
 8004888:	9b00      	ldr	r3, [sp, #0]
 800488a:	60da      	str	r2, [r3, #12]
}
 800488c:	b005      	add	sp, #20
 800488e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004892:	bf00      	nop
 8004894:	f3af 8000 	nop.w
 8004898:	f3af 8000 	nop.w
 800489c:	f3af 8000 	nop.w

080048a0 <_mmcsd_unpack_mmc_cid>:
 * @param[out] cidmmc   pointer to the @p unpacked_mmc_cid_t object
 *
 * @notapi
 */
void _mmcsd_unpack_mmc_cid(const MMCSDBlockDevice *sdcp,
                           unpacked_mmc_cid_t *cidmmc) {
 80048a0:	b500      	push	{lr}
 80048a2:	b085      	sub	sp, #20
 80048a4:	9001      	str	r0, [sp, #4]
 80048a6:	9100      	str	r1, [sp, #0]
  const uint32_t *cid;

  osalDbgCheck((NULL != sdcp) && (NULL != cidmmc));

  cid = sdcp->cid;
 80048a8:	9b01      	ldr	r3, [sp, #4]
 80048aa:	3308      	adds	r3, #8
 80048ac:	9303      	str	r3, [sp, #12]
  cidmmc->crc    = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_MMC_CRC_SLICE);
 80048ae:	9803      	ldr	r0, [sp, #12]
 80048b0:	2107      	movs	r1, #7
 80048b2:	2201      	movs	r2, #1
 80048b4:	f7ff fedc 	bl	8004670 <_mmcsd_get_slice>
 80048b8:	4603      	mov	r3, r0
 80048ba:	b2da      	uxtb	r2, r3
 80048bc:	9b00      	ldr	r3, [sp, #0]
 80048be:	751a      	strb	r2, [r3, #20]
  cidmmc->mdt_y  = (uint16_t)_mmcsd_get_slice(cid, MMCSD_CID_MMC_MDT_Y_SLICE) +
 80048c0:	9803      	ldr	r0, [sp, #12]
 80048c2:	210b      	movs	r1, #11
 80048c4:	2208      	movs	r2, #8
 80048c6:	f7ff fed3 	bl	8004670 <_mmcsd_get_slice>
 80048ca:	4603      	mov	r3, r0
 80048cc:	b29b      	uxth	r3, r3
 80048ce:	f203 73cd 	addw	r3, r3, #1997	; 0x7cd
 80048d2:	b29a      	uxth	r2, r3
 80048d4:	9b00      	ldr	r3, [sp, #0]
 80048d6:	825a      	strh	r2, [r3, #18]
                             1997U;
  cidmmc->mdt_m  = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_MMC_MDT_M_SLICE);
 80048d8:	9803      	ldr	r0, [sp, #12]
 80048da:	210f      	movs	r1, #15
 80048dc:	220c      	movs	r2, #12
 80048de:	f7ff fec7 	bl	8004670 <_mmcsd_get_slice>
 80048e2:	4603      	mov	r3, r0
 80048e4:	b2da      	uxtb	r2, r3
 80048e6:	9b00      	ldr	r3, [sp, #0]
 80048e8:	741a      	strb	r2, [r3, #16]
  cidmmc->mid    = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_MMC_MID_SLICE);
 80048ea:	9803      	ldr	r0, [sp, #12]
 80048ec:	217f      	movs	r1, #127	; 0x7f
 80048ee:	2278      	movs	r2, #120	; 0x78
 80048f0:	f7ff febe 	bl	8004670 <_mmcsd_get_slice>
 80048f4:	4603      	mov	r3, r0
 80048f6:	b2da      	uxtb	r2, r3
 80048f8:	9b00      	ldr	r3, [sp, #0]
 80048fa:	701a      	strb	r2, [r3, #0]
  cidmmc->oid    = (uint16_t)_mmcsd_get_slice(cid, MMCSD_CID_MMC_OID_SLICE);
 80048fc:	9803      	ldr	r0, [sp, #12]
 80048fe:	2177      	movs	r1, #119	; 0x77
 8004900:	2268      	movs	r2, #104	; 0x68
 8004902:	f7ff feb5 	bl	8004670 <_mmcsd_get_slice>
 8004906:	4603      	mov	r3, r0
 8004908:	b29a      	uxth	r2, r3
 800490a:	9b00      	ldr	r3, [sp, #0]
 800490c:	805a      	strh	r2, [r3, #2]
  cidmmc->pnm[5] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_MMC_PNM0_SLICE);
 800490e:	9803      	ldr	r0, [sp, #12]
 8004910:	213f      	movs	r1, #63	; 0x3f
 8004912:	2238      	movs	r2, #56	; 0x38
 8004914:	f7ff feac 	bl	8004670 <_mmcsd_get_slice>
 8004918:	4603      	mov	r3, r0
 800491a:	b2da      	uxtb	r2, r3
 800491c:	9b00      	ldr	r3, [sp, #0]
 800491e:	725a      	strb	r2, [r3, #9]
  cidmmc->pnm[4] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_MMC_PNM1_SLICE);
 8004920:	9803      	ldr	r0, [sp, #12]
 8004922:	2147      	movs	r1, #71	; 0x47
 8004924:	2240      	movs	r2, #64	; 0x40
 8004926:	f7ff fea3 	bl	8004670 <_mmcsd_get_slice>
 800492a:	4603      	mov	r3, r0
 800492c:	b2da      	uxtb	r2, r3
 800492e:	9b00      	ldr	r3, [sp, #0]
 8004930:	721a      	strb	r2, [r3, #8]
  cidmmc->pnm[3] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_MMC_PNM2_SLICE);
 8004932:	9803      	ldr	r0, [sp, #12]
 8004934:	214f      	movs	r1, #79	; 0x4f
 8004936:	2248      	movs	r2, #72	; 0x48
 8004938:	f7ff fe9a 	bl	8004670 <_mmcsd_get_slice>
 800493c:	4603      	mov	r3, r0
 800493e:	b2da      	uxtb	r2, r3
 8004940:	9b00      	ldr	r3, [sp, #0]
 8004942:	71da      	strb	r2, [r3, #7]
  cidmmc->pnm[2] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_MMC_PNM3_SLICE);
 8004944:	9803      	ldr	r0, [sp, #12]
 8004946:	2157      	movs	r1, #87	; 0x57
 8004948:	2250      	movs	r2, #80	; 0x50
 800494a:	f7ff fe91 	bl	8004670 <_mmcsd_get_slice>
 800494e:	4603      	mov	r3, r0
 8004950:	b2da      	uxtb	r2, r3
 8004952:	9b00      	ldr	r3, [sp, #0]
 8004954:	719a      	strb	r2, [r3, #6]
  cidmmc->pnm[1] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_MMC_PNM4_SLICE);
 8004956:	9803      	ldr	r0, [sp, #12]
 8004958:	215f      	movs	r1, #95	; 0x5f
 800495a:	2258      	movs	r2, #88	; 0x58
 800495c:	f7ff fe88 	bl	8004670 <_mmcsd_get_slice>
 8004960:	4603      	mov	r3, r0
 8004962:	b2da      	uxtb	r2, r3
 8004964:	9b00      	ldr	r3, [sp, #0]
 8004966:	715a      	strb	r2, [r3, #5]
  cidmmc->pnm[0] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_MMC_PNM5_SLICE);
 8004968:	9803      	ldr	r0, [sp, #12]
 800496a:	2167      	movs	r1, #103	; 0x67
 800496c:	2260      	movs	r2, #96	; 0x60
 800496e:	f7ff fe7f 	bl	8004670 <_mmcsd_get_slice>
 8004972:	4603      	mov	r3, r0
 8004974:	b2da      	uxtb	r2, r3
 8004976:	9b00      	ldr	r3, [sp, #0]
 8004978:	711a      	strb	r2, [r3, #4]
  cidmmc->prv_n  = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_MMC_PRV_N_SLICE);
 800497a:	9803      	ldr	r0, [sp, #12]
 800497c:	2137      	movs	r1, #55	; 0x37
 800497e:	2234      	movs	r2, #52	; 0x34
 8004980:	f7ff fe76 	bl	8004670 <_mmcsd_get_slice>
 8004984:	4603      	mov	r3, r0
 8004986:	b2da      	uxtb	r2, r3
 8004988:	9b00      	ldr	r3, [sp, #0]
 800498a:	729a      	strb	r2, [r3, #10]
  cidmmc->prv_m  = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_MMC_PRV_M_SLICE);
 800498c:	9803      	ldr	r0, [sp, #12]
 800498e:	2133      	movs	r1, #51	; 0x33
 8004990:	2230      	movs	r2, #48	; 0x30
 8004992:	f7ff fe6d 	bl	8004670 <_mmcsd_get_slice>
 8004996:	4603      	mov	r3, r0
 8004998:	b2da      	uxtb	r2, r3
 800499a:	9b00      	ldr	r3, [sp, #0]
 800499c:	72da      	strb	r2, [r3, #11]
  cidmmc->psn    =           _mmcsd_get_slice(cid, MMCSD_CID_MMC_PSN_SLICE);
 800499e:	9803      	ldr	r0, [sp, #12]
 80049a0:	212f      	movs	r1, #47	; 0x2f
 80049a2:	2210      	movs	r2, #16
 80049a4:	f7ff fe64 	bl	8004670 <_mmcsd_get_slice>
 80049a8:	4602      	mov	r2, r0
 80049aa:	9b00      	ldr	r3, [sp, #0]
 80049ac:	60da      	str	r2, [r3, #12]
}
 80049ae:	b005      	add	sp, #20
 80049b0:	f85d fb04 	ldr.w	pc, [sp], #4
 80049b4:	f3af 8000 	nop.w
 80049b8:	f3af 8000 	nop.w
 80049bc:	f3af 8000 	nop.w

080049c0 <_mmcsd_unpack_csd_mmc>:
 * @param[out] csdmmc   pointer to the @p unpacked_mmc_csd_t object
 *
 * @notapi
 */
void _mmcsd_unpack_csd_mmc(const MMCSDBlockDevice *sdcp,
                           unpacked_mmc_csd_t *csdmmc) {
 80049c0:	b500      	push	{lr}
 80049c2:	b085      	sub	sp, #20
 80049c4:	9001      	str	r0, [sp, #4]
 80049c6:	9100      	str	r1, [sp, #0]
  const uint32_t *csd;

  osalDbgCheck((NULL != sdcp) && (NULL != csdmmc));

  csd = sdcp->csd;
 80049c8:	9b01      	ldr	r3, [sp, #4]
 80049ca:	3318      	adds	r3, #24
 80049cc:	9303      	str	r3, [sp, #12]
  csdmmc->c_size             = (uint16_t)_mmcsd_get_slice(csd, MMCSD_CSD_MMC_C_SIZE_SLICE);
 80049ce:	9803      	ldr	r0, [sp, #12]
 80049d0:	2149      	movs	r1, #73	; 0x49
 80049d2:	223e      	movs	r2, #62	; 0x3e
 80049d4:	f7ff fe4c 	bl	8004670 <_mmcsd_get_slice>
 80049d8:	4603      	mov	r3, r0
 80049da:	b29a      	uxth	r2, r3
 80049dc:	9b00      	ldr	r3, [sp, #0]
 80049de:	81da      	strh	r2, [r3, #14]
  csdmmc->c_size_mult        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_C_SIZE_MULT_SLICE);
 80049e0:	9803      	ldr	r0, [sp, #12]
 80049e2:	2131      	movs	r1, #49	; 0x31
 80049e4:	222f      	movs	r2, #47	; 0x2f
 80049e6:	f7ff fe43 	bl	8004670 <_mmcsd_get_slice>
 80049ea:	4603      	mov	r3, r0
 80049ec:	b2da      	uxtb	r2, r3
 80049ee:	9b00      	ldr	r3, [sp, #0]
 80049f0:	751a      	strb	r2, [r3, #20]
  csdmmc->ccc                = (uint16_t)_mmcsd_get_slice(csd, MMCSD_CSD_MMC_CCC_SLICE);
 80049f2:	9803      	ldr	r0, [sp, #12]
 80049f4:	215f      	movs	r1, #95	; 0x5f
 80049f6:	2254      	movs	r2, #84	; 0x54
 80049f8:	f7ff fe3a 	bl	8004670 <_mmcsd_get_slice>
 80049fc:	4603      	mov	r3, r0
 80049fe:	b29a      	uxth	r2, r3
 8004a00:	9b00      	ldr	r3, [sp, #0]
 8004a02:	80da      	strh	r2, [r3, #6]
  csdmmc->copy               = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_COPY_SLICE);
 8004a04:	9803      	ldr	r0, [sp, #12]
 8004a06:	210e      	movs	r1, #14
 8004a08:	220e      	movs	r2, #14
 8004a0a:	f7ff fe31 	bl	8004670 <_mmcsd_get_slice>
 8004a0e:	4603      	mov	r3, r0
 8004a10:	b2da      	uxtb	r2, r3
 8004a12:	9b00      	ldr	r3, [sp, #0]
 8004a14:	77da      	strb	r2, [r3, #31]
  csdmmc->crc                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_CRC_SLICE);
 8004a16:	9803      	ldr	r0, [sp, #12]
 8004a18:	2107      	movs	r1, #7
 8004a1a:	2201      	movs	r2, #1
 8004a1c:	f7ff fe28 	bl	8004670 <_mmcsd_get_slice>
 8004a20:	4603      	mov	r3, r0
 8004a22:	b2da      	uxtb	r2, r3
 8004a24:	9b00      	ldr	r3, [sp, #0]
 8004a26:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  csdmmc->csd_structure      = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_CSD_STRUCTURE_SLICE);
 8004a2a:	9803      	ldr	r0, [sp, #12]
 8004a2c:	217f      	movs	r1, #127	; 0x7f
 8004a2e:	227e      	movs	r2, #126	; 0x7e
 8004a30:	f7ff fe1e 	bl	8004670 <_mmcsd_get_slice>
 8004a34:	4603      	mov	r3, r0
 8004a36:	b2da      	uxtb	r2, r3
 8004a38:	9b00      	ldr	r3, [sp, #0]
 8004a3a:	701a      	strb	r2, [r3, #0]
  csdmmc->dsr_imp            = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_DSR_IMP_SLICE);
 8004a3c:	9803      	ldr	r0, [sp, #12]
 8004a3e:	214c      	movs	r1, #76	; 0x4c
 8004a40:	224c      	movs	r2, #76	; 0x4c
 8004a42:	f7ff fe15 	bl	8004670 <_mmcsd_get_slice>
 8004a46:	4603      	mov	r3, r0
 8004a48:	b2da      	uxtb	r2, r3
 8004a4a:	9b00      	ldr	r3, [sp, #0]
 8004a4c:	731a      	strb	r2, [r3, #12]
  csdmmc->ecc                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_ECC_SLICE);
 8004a4e:	9803      	ldr	r0, [sp, #12]
 8004a50:	2109      	movs	r1, #9
 8004a52:	2208      	movs	r2, #8
 8004a54:	f7ff fe0c 	bl	8004670 <_mmcsd_get_slice>
 8004a58:	4603      	mov	r3, r0
 8004a5a:	b2da      	uxtb	r2, r3
 8004a5c:	9b00      	ldr	r3, [sp, #0]
 8004a5e:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
  csdmmc->erase_grp_mult     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_ERASE_GRP_MULT_SLICE);
 8004a62:	9803      	ldr	r0, [sp, #12]
 8004a64:	2129      	movs	r1, #41	; 0x29
 8004a66:	2225      	movs	r2, #37	; 0x25
 8004a68:	f7ff fe02 	bl	8004670 <_mmcsd_get_slice>
 8004a6c:	4603      	mov	r3, r0
 8004a6e:	b2da      	uxtb	r2, r3
 8004a70:	9b00      	ldr	r3, [sp, #0]
 8004a72:	759a      	strb	r2, [r3, #22]
  csdmmc->erase_grp_size     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_ERASE_GRP_SIZE_SLICE);
 8004a74:	9803      	ldr	r0, [sp, #12]
 8004a76:	212e      	movs	r1, #46	; 0x2e
 8004a78:	222a      	movs	r2, #42	; 0x2a
 8004a7a:	f7ff fdf9 	bl	8004670 <_mmcsd_get_slice>
 8004a7e:	4603      	mov	r3, r0
 8004a80:	b2da      	uxtb	r2, r3
 8004a82:	9b00      	ldr	r3, [sp, #0]
 8004a84:	755a      	strb	r2, [r3, #21]
  csdmmc->file_format        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_FILE_FORMAT_SLICE);
 8004a86:	9803      	ldr	r0, [sp, #12]
 8004a88:	210b      	movs	r1, #11
 8004a8a:	220a      	movs	r2, #10
 8004a8c:	f7ff fdf0 	bl	8004670 <_mmcsd_get_slice>
 8004a90:	4603      	mov	r3, r0
 8004a92:	b2da      	uxtb	r2, r3
 8004a94:	9b00      	ldr	r3, [sp, #0]
 8004a96:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  csdmmc->file_format_grp    = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_FILE_FORMAT_GRP_SLICE);
 8004a9a:	9803      	ldr	r0, [sp, #12]
 8004a9c:	210f      	movs	r1, #15
 8004a9e:	220f      	movs	r2, #15
 8004aa0:	f7ff fde6 	bl	8004670 <_mmcsd_get_slice>
 8004aa4:	4603      	mov	r3, r0
 8004aa6:	b2da      	uxtb	r2, r3
 8004aa8:	9b00      	ldr	r3, [sp, #0]
 8004aaa:	779a      	strb	r2, [r3, #30]
  csdmmc->nsac               = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_NSAC_SLICE);
 8004aac:	9803      	ldr	r0, [sp, #12]
 8004aae:	216f      	movs	r1, #111	; 0x6f
 8004ab0:	2268      	movs	r2, #104	; 0x68
 8004ab2:	f7ff fddd 	bl	8004670 <_mmcsd_get_slice>
 8004ab6:	4603      	mov	r3, r0
 8004ab8:	b2da      	uxtb	r2, r3
 8004aba:	9b00      	ldr	r3, [sp, #0]
 8004abc:	70da      	strb	r2, [r3, #3]
  csdmmc->perm_write_protect = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_PERM_WRITE_PROTECT_SLICE);
 8004abe:	9803      	ldr	r0, [sp, #12]
 8004ac0:	210d      	movs	r1, #13
 8004ac2:	220d      	movs	r2, #13
 8004ac4:	f7ff fdd4 	bl	8004670 <_mmcsd_get_slice>
 8004ac8:	4603      	mov	r3, r0
 8004aca:	b2da      	uxtb	r2, r3
 8004acc:	9b00      	ldr	r3, [sp, #0]
 8004ace:	f883 2020 	strb.w	r2, [r3, #32]
  csdmmc->r2w_factor         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_R2W_FACTOR_SLICE);
 8004ad2:	9803      	ldr	r0, [sp, #12]
 8004ad4:	211c      	movs	r1, #28
 8004ad6:	221a      	movs	r2, #26
 8004ad8:	f7ff fdca 	bl	8004670 <_mmcsd_get_slice>
 8004adc:	4603      	mov	r3, r0
 8004ade:	b2da      	uxtb	r2, r3
 8004ae0:	9b00      	ldr	r3, [sp, #0]
 8004ae2:	769a      	strb	r2, [r3, #26]
  csdmmc->read_bl_len        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_READ_BL_LEN_SLICE);
 8004ae4:	9803      	ldr	r0, [sp, #12]
 8004ae6:	2153      	movs	r1, #83	; 0x53
 8004ae8:	2250      	movs	r2, #80	; 0x50
 8004aea:	f7ff fdc1 	bl	8004670 <_mmcsd_get_slice>
 8004aee:	4603      	mov	r3, r0
 8004af0:	b2da      	uxtb	r2, r3
 8004af2:	9b00      	ldr	r3, [sp, #0]
 8004af4:	721a      	strb	r2, [r3, #8]
  csdmmc->read_bl_partial    = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_READ_BL_PARTIAL_SLICE);
 8004af6:	9803      	ldr	r0, [sp, #12]
 8004af8:	214f      	movs	r1, #79	; 0x4f
 8004afa:	224f      	movs	r2, #79	; 0x4f
 8004afc:	f7ff fdb8 	bl	8004670 <_mmcsd_get_slice>
 8004b00:	4603      	mov	r3, r0
 8004b02:	b2da      	uxtb	r2, r3
 8004b04:	9b00      	ldr	r3, [sp, #0]
 8004b06:	725a      	strb	r2, [r3, #9]
  csdmmc->read_blk_misalign  = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_READ_BLK_MISALIGN_SLICE);
 8004b08:	9803      	ldr	r0, [sp, #12]
 8004b0a:	214d      	movs	r1, #77	; 0x4d
 8004b0c:	224d      	movs	r2, #77	; 0x4d
 8004b0e:	f7ff fdaf 	bl	8004670 <_mmcsd_get_slice>
 8004b12:	4603      	mov	r3, r0
 8004b14:	b2da      	uxtb	r2, r3
 8004b16:	9b00      	ldr	r3, [sp, #0]
 8004b18:	72da      	strb	r2, [r3, #11]
  csdmmc->spec_vers          = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_SPEC_VERS_SLICE);
 8004b1a:	9803      	ldr	r0, [sp, #12]
 8004b1c:	217d      	movs	r1, #125	; 0x7d
 8004b1e:	227a      	movs	r2, #122	; 0x7a
 8004b20:	f7ff fda6 	bl	8004670 <_mmcsd_get_slice>
 8004b24:	4603      	mov	r3, r0
 8004b26:	b2da      	uxtb	r2, r3
 8004b28:	9b00      	ldr	r3, [sp, #0]
 8004b2a:	705a      	strb	r2, [r3, #1]
  csdmmc->taac               = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_TAAC_SLICE);
 8004b2c:	9803      	ldr	r0, [sp, #12]
 8004b2e:	2177      	movs	r1, #119	; 0x77
 8004b30:	2270      	movs	r2, #112	; 0x70
 8004b32:	f7ff fd9d 	bl	8004670 <_mmcsd_get_slice>
 8004b36:	4603      	mov	r3, r0
 8004b38:	b2da      	uxtb	r2, r3
 8004b3a:	9b00      	ldr	r3, [sp, #0]
 8004b3c:	709a      	strb	r2, [r3, #2]
  csdmmc->tmp_write_protect  = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_TMP_WRITE_PROTECT_SLICE);
 8004b3e:	9803      	ldr	r0, [sp, #12]
 8004b40:	210c      	movs	r1, #12
 8004b42:	220c      	movs	r2, #12
 8004b44:	f7ff fd94 	bl	8004670 <_mmcsd_get_slice>
 8004b48:	4603      	mov	r3, r0
 8004b4a:	b2da      	uxtb	r2, r3
 8004b4c:	9b00      	ldr	r3, [sp, #0]
 8004b4e:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  csdmmc->tran_speed         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_TRAN_SPEED_SLICE);
 8004b52:	9803      	ldr	r0, [sp, #12]
 8004b54:	2167      	movs	r1, #103	; 0x67
 8004b56:	2260      	movs	r2, #96	; 0x60
 8004b58:	f7ff fd8a 	bl	8004670 <_mmcsd_get_slice>
 8004b5c:	4603      	mov	r3, r0
 8004b5e:	b2da      	uxtb	r2, r3
 8004b60:	9b00      	ldr	r3, [sp, #0]
 8004b62:	711a      	strb	r2, [r3, #4]
  csdmmc->vdd_r_curr_max     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_VDD_R_CURR_MAX_SLICE);
 8004b64:	9803      	ldr	r0, [sp, #12]
 8004b66:	213a      	movs	r1, #58	; 0x3a
 8004b68:	2238      	movs	r2, #56	; 0x38
 8004b6a:	f7ff fd81 	bl	8004670 <_mmcsd_get_slice>
 8004b6e:	4603      	mov	r3, r0
 8004b70:	b2da      	uxtb	r2, r3
 8004b72:	9b00      	ldr	r3, [sp, #0]
 8004b74:	745a      	strb	r2, [r3, #17]
  csdmmc->vdd_r_curr_min     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_VDD_R_CURR_MIN_SLICE);
 8004b76:	9803      	ldr	r0, [sp, #12]
 8004b78:	213d      	movs	r1, #61	; 0x3d
 8004b7a:	223b      	movs	r2, #59	; 0x3b
 8004b7c:	f7ff fd78 	bl	8004670 <_mmcsd_get_slice>
 8004b80:	4603      	mov	r3, r0
 8004b82:	b2da      	uxtb	r2, r3
 8004b84:	9b00      	ldr	r3, [sp, #0]
 8004b86:	741a      	strb	r2, [r3, #16]
  csdmmc->vdd_w_curr_max     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_VDD_W_CURR_MAX_SLICE);
 8004b88:	9803      	ldr	r0, [sp, #12]
 8004b8a:	2134      	movs	r1, #52	; 0x34
 8004b8c:	2232      	movs	r2, #50	; 0x32
 8004b8e:	f7ff fd6f 	bl	8004670 <_mmcsd_get_slice>
 8004b92:	4603      	mov	r3, r0
 8004b94:	b2da      	uxtb	r2, r3
 8004b96:	9b00      	ldr	r3, [sp, #0]
 8004b98:	74da      	strb	r2, [r3, #19]
  csdmmc->vdd_w_curr_min     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_VDD_W_CURR_MIN_SLICE);
 8004b9a:	9803      	ldr	r0, [sp, #12]
 8004b9c:	2137      	movs	r1, #55	; 0x37
 8004b9e:	2235      	movs	r2, #53	; 0x35
 8004ba0:	f7ff fd66 	bl	8004670 <_mmcsd_get_slice>
 8004ba4:	4603      	mov	r3, r0
 8004ba6:	b2da      	uxtb	r2, r3
 8004ba8:	9b00      	ldr	r3, [sp, #0]
 8004baa:	749a      	strb	r2, [r3, #18]
  csdmmc->wp_grp_enable      = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_WP_GRP_ENABLE_SLICE);
 8004bac:	9803      	ldr	r0, [sp, #12]
 8004bae:	211f      	movs	r1, #31
 8004bb0:	221f      	movs	r2, #31
 8004bb2:	f7ff fd5d 	bl	8004670 <_mmcsd_get_slice>
 8004bb6:	4603      	mov	r3, r0
 8004bb8:	b2da      	uxtb	r2, r3
 8004bba:	9b00      	ldr	r3, [sp, #0]
 8004bbc:	761a      	strb	r2, [r3, #24]
  csdmmc->wp_grp_size        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_WP_GRP_SIZE_SLICE);
 8004bbe:	9803      	ldr	r0, [sp, #12]
 8004bc0:	2124      	movs	r1, #36	; 0x24
 8004bc2:	2220      	movs	r2, #32
 8004bc4:	f7ff fd54 	bl	8004670 <_mmcsd_get_slice>
 8004bc8:	4603      	mov	r3, r0
 8004bca:	b2da      	uxtb	r2, r3
 8004bcc:	9b00      	ldr	r3, [sp, #0]
 8004bce:	75da      	strb	r2, [r3, #23]
  csdmmc->write_bl_len       = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_WRITE_BL_LEN_SLICE);
 8004bd0:	9803      	ldr	r0, [sp, #12]
 8004bd2:	2119      	movs	r1, #25
 8004bd4:	2216      	movs	r2, #22
 8004bd6:	f7ff fd4b 	bl	8004670 <_mmcsd_get_slice>
 8004bda:	4603      	mov	r3, r0
 8004bdc:	b2da      	uxtb	r2, r3
 8004bde:	9b00      	ldr	r3, [sp, #0]
 8004be0:	76da      	strb	r2, [r3, #27]
  csdmmc->write_bl_partial   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_WRITE_BL_PARTIAL_SLICE);
 8004be2:	9803      	ldr	r0, [sp, #12]
 8004be4:	2115      	movs	r1, #21
 8004be6:	2215      	movs	r2, #21
 8004be8:	f7ff fd42 	bl	8004670 <_mmcsd_get_slice>
 8004bec:	4603      	mov	r3, r0
 8004bee:	b2da      	uxtb	r2, r3
 8004bf0:	9b00      	ldr	r3, [sp, #0]
 8004bf2:	771a      	strb	r2, [r3, #28]
  csdmmc->write_blk_misalign = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_WRITE_BLK_MISALIGN_SLICE);
 8004bf4:	9803      	ldr	r0, [sp, #12]
 8004bf6:	214e      	movs	r1, #78	; 0x4e
 8004bf8:	224e      	movs	r2, #78	; 0x4e
 8004bfa:	f7ff fd39 	bl	8004670 <_mmcsd_get_slice>
 8004bfe:	4603      	mov	r3, r0
 8004c00:	b2da      	uxtb	r2, r3
 8004c02:	9b00      	ldr	r3, [sp, #0]
 8004c04:	729a      	strb	r2, [r3, #10]
}
 8004c06:	b005      	add	sp, #20
 8004c08:	f85d fb04 	ldr.w	pc, [sp], #4
 8004c0c:	f3af 8000 	nop.w

08004c10 <_mmcsd_unpack_csd_v10>:
 * @param[out] csd10    pointer to the @p unpacked_sdc_csd_10_t object
 *
 * @notapi
 */
void _mmcsd_unpack_csd_v10(const MMCSDBlockDevice *sdcp,
                           unpacked_sdc_csd_10_t *csd10) {
 8004c10:	b500      	push	{lr}
 8004c12:	b085      	sub	sp, #20
 8004c14:	9001      	str	r0, [sp, #4]
 8004c16:	9100      	str	r1, [sp, #0]
  const uint32_t *csd;

  osalDbgCheck(NULL != sdcp);

  csd = sdcp->csd;
 8004c18:	9b01      	ldr	r3, [sp, #4]
 8004c1a:	3318      	adds	r3, #24
 8004c1c:	9303      	str	r3, [sp, #12]
  csd10->c_size              = (uint16_t)_mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_SLICE);
 8004c1e:	9803      	ldr	r0, [sp, #12]
 8004c20:	2149      	movs	r1, #73	; 0x49
 8004c22:	223e      	movs	r2, #62	; 0x3e
 8004c24:	f7ff fd24 	bl	8004670 <_mmcsd_get_slice>
 8004c28:	4603      	mov	r3, r0
 8004c2a:	b29a      	uxth	r2, r3
 8004c2c:	9b00      	ldr	r3, [sp, #0]
 8004c2e:	819a      	strh	r2, [r3, #12]
  csd10->c_size_mult         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_MULT_SLICE);
 8004c30:	9803      	ldr	r0, [sp, #12]
 8004c32:	2131      	movs	r1, #49	; 0x31
 8004c34:	222f      	movs	r2, #47	; 0x2f
 8004c36:	f7ff fd1b 	bl	8004670 <_mmcsd_get_slice>
 8004c3a:	4603      	mov	r3, r0
 8004c3c:	b2da      	uxtb	r2, r3
 8004c3e:	9b00      	ldr	r3, [sp, #0]
 8004c40:	749a      	strb	r2, [r3, #18]
  csd10->ccc                 = (uint16_t)_mmcsd_get_slice(csd, MMCSD_CSD_10_CCC_SLICE);
 8004c42:	9803      	ldr	r0, [sp, #12]
 8004c44:	215f      	movs	r1, #95	; 0x5f
 8004c46:	2254      	movs	r2, #84	; 0x54
 8004c48:	f7ff fd12 	bl	8004670 <_mmcsd_get_slice>
 8004c4c:	4603      	mov	r3, r0
 8004c4e:	b29a      	uxth	r2, r3
 8004c50:	9b00      	ldr	r3, [sp, #0]
 8004c52:	809a      	strh	r2, [r3, #4]
  csd10->copy                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_COPY_SLICE);
 8004c54:	9803      	ldr	r0, [sp, #12]
 8004c56:	210e      	movs	r1, #14
 8004c58:	220e      	movs	r2, #14
 8004c5a:	f7ff fd09 	bl	8004670 <_mmcsd_get_slice>
 8004c5e:	4603      	mov	r3, r0
 8004c60:	b2da      	uxtb	r2, r3
 8004c62:	9b00      	ldr	r3, [sp, #0]
 8004c64:	76da      	strb	r2, [r3, #27]
  csd10->crc                 = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_CRC_SLICE);
 8004c66:	9803      	ldr	r0, [sp, #12]
 8004c68:	2107      	movs	r1, #7
 8004c6a:	2201      	movs	r2, #1
 8004c6c:	f7ff fd00 	bl	8004670 <_mmcsd_get_slice>
 8004c70:	4603      	mov	r3, r0
 8004c72:	b2da      	uxtb	r2, r3
 8004c74:	9b00      	ldr	r3, [sp, #0]
 8004c76:	77da      	strb	r2, [r3, #31]
  csd10->csd_structure       = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE);
 8004c78:	9803      	ldr	r0, [sp, #12]
 8004c7a:	217f      	movs	r1, #127	; 0x7f
 8004c7c:	227e      	movs	r2, #126	; 0x7e
 8004c7e:	f7ff fcf7 	bl	8004670 <_mmcsd_get_slice>
 8004c82:	4603      	mov	r3, r0
 8004c84:	b2da      	uxtb	r2, r3
 8004c86:	9b00      	ldr	r3, [sp, #0]
 8004c88:	701a      	strb	r2, [r3, #0]
  csd10->dsr_imp             = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_DSR_IMP_SLICE);
 8004c8a:	9803      	ldr	r0, [sp, #12]
 8004c8c:	214c      	movs	r1, #76	; 0x4c
 8004c8e:	224c      	movs	r2, #76	; 0x4c
 8004c90:	f7ff fcee 	bl	8004670 <_mmcsd_get_slice>
 8004c94:	4603      	mov	r3, r0
 8004c96:	b2da      	uxtb	r2, r3
 8004c98:	9b00      	ldr	r3, [sp, #0]
 8004c9a:	729a      	strb	r2, [r3, #10]
  csd10->erase_blk_en        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_ERASE_BLK_EN_SLICE);
 8004c9c:	9803      	ldr	r0, [sp, #12]
 8004c9e:	212e      	movs	r1, #46	; 0x2e
 8004ca0:	222e      	movs	r2, #46	; 0x2e
 8004ca2:	f7ff fce5 	bl	8004670 <_mmcsd_get_slice>
 8004ca6:	4603      	mov	r3, r0
 8004ca8:	b2da      	uxtb	r2, r3
 8004caa:	9b00      	ldr	r3, [sp, #0]
 8004cac:	74da      	strb	r2, [r3, #19]
  csd10->erase_sector_size   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_ERASE_SECTOR_SIZE_SLICE);
 8004cae:	9803      	ldr	r0, [sp, #12]
 8004cb0:	212d      	movs	r1, #45	; 0x2d
 8004cb2:	2227      	movs	r2, #39	; 0x27
 8004cb4:	f7ff fcdc 	bl	8004670 <_mmcsd_get_slice>
 8004cb8:	4603      	mov	r3, r0
 8004cba:	b2da      	uxtb	r2, r3
 8004cbc:	9b00      	ldr	r3, [sp, #0]
 8004cbe:	751a      	strb	r2, [r3, #20]
  csd10->file_format         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_FILE_FORMAT_SLICE);
 8004cc0:	9803      	ldr	r0, [sp, #12]
 8004cc2:	210b      	movs	r1, #11
 8004cc4:	220a      	movs	r2, #10
 8004cc6:	f7ff fcd3 	bl	8004670 <_mmcsd_get_slice>
 8004cca:	4603      	mov	r3, r0
 8004ccc:	b2da      	uxtb	r2, r3
 8004cce:	9b00      	ldr	r3, [sp, #0]
 8004cd0:	779a      	strb	r2, [r3, #30]
  csd10->file_format_grp     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_FILE_FORMAT_GRP_SLICE);
 8004cd2:	9803      	ldr	r0, [sp, #12]
 8004cd4:	210f      	movs	r1, #15
 8004cd6:	220f      	movs	r2, #15
 8004cd8:	f7ff fcca 	bl	8004670 <_mmcsd_get_slice>
 8004cdc:	4603      	mov	r3, r0
 8004cde:	b2da      	uxtb	r2, r3
 8004ce0:	9b00      	ldr	r3, [sp, #0]
 8004ce2:	769a      	strb	r2, [r3, #26]
  csd10->nsac                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_NSAC_SLICE);
 8004ce4:	9803      	ldr	r0, [sp, #12]
 8004ce6:	216f      	movs	r1, #111	; 0x6f
 8004ce8:	2268      	movs	r2, #104	; 0x68
 8004cea:	f7ff fcc1 	bl	8004670 <_mmcsd_get_slice>
 8004cee:	4603      	mov	r3, r0
 8004cf0:	b2da      	uxtb	r2, r3
 8004cf2:	9b00      	ldr	r3, [sp, #0]
 8004cf4:	709a      	strb	r2, [r3, #2]
  csd10->perm_write_protect  = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_PERM_WRITE_PROTECT_SLICE);
 8004cf6:	9803      	ldr	r0, [sp, #12]
 8004cf8:	210d      	movs	r1, #13
 8004cfa:	220d      	movs	r2, #13
 8004cfc:	f7ff fcb8 	bl	8004670 <_mmcsd_get_slice>
 8004d00:	4603      	mov	r3, r0
 8004d02:	b2da      	uxtb	r2, r3
 8004d04:	9b00      	ldr	r3, [sp, #0]
 8004d06:	771a      	strb	r2, [r3, #28]
  csd10->r2w_factor          = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_R2W_FACTOR_SLICE);
 8004d08:	9803      	ldr	r0, [sp, #12]
 8004d0a:	211c      	movs	r1, #28
 8004d0c:	221a      	movs	r2, #26
 8004d0e:	f7ff fcaf 	bl	8004670 <_mmcsd_get_slice>
 8004d12:	4603      	mov	r3, r0
 8004d14:	b2da      	uxtb	r2, r3
 8004d16:	9b00      	ldr	r3, [sp, #0]
 8004d18:	75da      	strb	r2, [r3, #23]
  csd10->read_bl_len         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_LEN_SLICE);
 8004d1a:	9803      	ldr	r0, [sp, #12]
 8004d1c:	2153      	movs	r1, #83	; 0x53
 8004d1e:	2250      	movs	r2, #80	; 0x50
 8004d20:	f7ff fca6 	bl	8004670 <_mmcsd_get_slice>
 8004d24:	4603      	mov	r3, r0
 8004d26:	b2da      	uxtb	r2, r3
 8004d28:	9b00      	ldr	r3, [sp, #0]
 8004d2a:	719a      	strb	r2, [r3, #6]
  csd10->read_bl_partial     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_PARTIAL_SLICE);
 8004d2c:	9803      	ldr	r0, [sp, #12]
 8004d2e:	214f      	movs	r1, #79	; 0x4f
 8004d30:	224f      	movs	r2, #79	; 0x4f
 8004d32:	f7ff fc9d 	bl	8004670 <_mmcsd_get_slice>
 8004d36:	4603      	mov	r3, r0
 8004d38:	b2da      	uxtb	r2, r3
 8004d3a:	9b00      	ldr	r3, [sp, #0]
 8004d3c:	71da      	strb	r2, [r3, #7]
  csd10->read_blk_misalign   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BLK_MISALIGN_SLICE);
 8004d3e:	9803      	ldr	r0, [sp, #12]
 8004d40:	214d      	movs	r1, #77	; 0x4d
 8004d42:	224d      	movs	r2, #77	; 0x4d
 8004d44:	f7ff fc94 	bl	8004670 <_mmcsd_get_slice>
 8004d48:	4603      	mov	r3, r0
 8004d4a:	b2da      	uxtb	r2, r3
 8004d4c:	9b00      	ldr	r3, [sp, #0]
 8004d4e:	725a      	strb	r2, [r3, #9]
  csd10->taac                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_TAAC_SLICE);
 8004d50:	9803      	ldr	r0, [sp, #12]
 8004d52:	2177      	movs	r1, #119	; 0x77
 8004d54:	2270      	movs	r2, #112	; 0x70
 8004d56:	f7ff fc8b 	bl	8004670 <_mmcsd_get_slice>
 8004d5a:	4603      	mov	r3, r0
 8004d5c:	b2da      	uxtb	r2, r3
 8004d5e:	9b00      	ldr	r3, [sp, #0]
 8004d60:	705a      	strb	r2, [r3, #1]
  csd10->tmp_write_protect   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_TMP_WRITE_PROTECT_SLICE);
 8004d62:	9803      	ldr	r0, [sp, #12]
 8004d64:	210c      	movs	r1, #12
 8004d66:	220c      	movs	r2, #12
 8004d68:	f7ff fc82 	bl	8004670 <_mmcsd_get_slice>
 8004d6c:	4603      	mov	r3, r0
 8004d6e:	b2da      	uxtb	r2, r3
 8004d70:	9b00      	ldr	r3, [sp, #0]
 8004d72:	775a      	strb	r2, [r3, #29]
  csd10->tran_speed          = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_TRANS_SPEED_SLICE);
 8004d74:	9803      	ldr	r0, [sp, #12]
 8004d76:	2167      	movs	r1, #103	; 0x67
 8004d78:	2260      	movs	r2, #96	; 0x60
 8004d7a:	f7ff fc79 	bl	8004670 <_mmcsd_get_slice>
 8004d7e:	4603      	mov	r3, r0
 8004d80:	b2da      	uxtb	r2, r3
 8004d82:	9b00      	ldr	r3, [sp, #0]
 8004d84:	70da      	strb	r2, [r3, #3]
  csd10->wp_grp_enable       = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_WP_GRP_ENABLE_SLICE);
 8004d86:	9803      	ldr	r0, [sp, #12]
 8004d88:	211f      	movs	r1, #31
 8004d8a:	221f      	movs	r2, #31
 8004d8c:	f7ff fc70 	bl	8004670 <_mmcsd_get_slice>
 8004d90:	4603      	mov	r3, r0
 8004d92:	b2da      	uxtb	r2, r3
 8004d94:	9b00      	ldr	r3, [sp, #0]
 8004d96:	759a      	strb	r2, [r3, #22]
  csd10->wp_grp_size         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_WP_GRP_SIZE_SLICE);
 8004d98:	9803      	ldr	r0, [sp, #12]
 8004d9a:	2126      	movs	r1, #38	; 0x26
 8004d9c:	2220      	movs	r2, #32
 8004d9e:	f7ff fc67 	bl	8004670 <_mmcsd_get_slice>
 8004da2:	4603      	mov	r3, r0
 8004da4:	b2da      	uxtb	r2, r3
 8004da6:	9b00      	ldr	r3, [sp, #0]
 8004da8:	755a      	strb	r2, [r3, #21]
  csd10->write_bl_len        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_WRITE_BL_LEN_SLICE);
 8004daa:	9803      	ldr	r0, [sp, #12]
 8004dac:	2119      	movs	r1, #25
 8004dae:	220c      	movs	r2, #12
 8004db0:	f7ff fc5e 	bl	8004670 <_mmcsd_get_slice>
 8004db4:	4603      	mov	r3, r0
 8004db6:	b2da      	uxtb	r2, r3
 8004db8:	9b00      	ldr	r3, [sp, #0]
 8004dba:	761a      	strb	r2, [r3, #24]
  csd10->write_bl_partial    = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_WRITE_BL_PARTIAL_SLICE);
 8004dbc:	9803      	ldr	r0, [sp, #12]
 8004dbe:	2115      	movs	r1, #21
 8004dc0:	2215      	movs	r2, #21
 8004dc2:	f7ff fc55 	bl	8004670 <_mmcsd_get_slice>
 8004dc6:	4603      	mov	r3, r0
 8004dc8:	b2da      	uxtb	r2, r3
 8004dca:	9b00      	ldr	r3, [sp, #0]
 8004dcc:	765a      	strb	r2, [r3, #25]
  csd10->write_blk_misalign  = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_WRITE_BLK_MISALIGN_SLICE);
 8004dce:	9803      	ldr	r0, [sp, #12]
 8004dd0:	214e      	movs	r1, #78	; 0x4e
 8004dd2:	224e      	movs	r2, #78	; 0x4e
 8004dd4:	f7ff fc4c 	bl	8004670 <_mmcsd_get_slice>
 8004dd8:	4603      	mov	r3, r0
 8004dda:	b2da      	uxtb	r2, r3
 8004ddc:	9b00      	ldr	r3, [sp, #0]
 8004dde:	721a      	strb	r2, [r3, #8]
}
 8004de0:	b005      	add	sp, #20
 8004de2:	f85d fb04 	ldr.w	pc, [sp], #4
 8004de6:	bf00      	nop
 8004de8:	f3af 8000 	nop.w
 8004dec:	f3af 8000 	nop.w

08004df0 <_mmcsd_unpack_csd_v20>:
 * @param[out] csd20    pointer to the @p unpacked_sdc_csd_20_t object
 *
 * @notapi
 */
void _mmcsd_unpack_csd_v20(const MMCSDBlockDevice *sdcp,
                           unpacked_sdc_csd_20_t *csd20) {
 8004df0:	b500      	push	{lr}
 8004df2:	b085      	sub	sp, #20
 8004df4:	9001      	str	r0, [sp, #4]
 8004df6:	9100      	str	r1, [sp, #0]
  const uint32_t *csd;

  osalDbgCheck(NULL != sdcp);

  csd = sdcp->csd;
 8004df8:	9b01      	ldr	r3, [sp, #4]
 8004dfa:	3318      	adds	r3, #24
 8004dfc:	9303      	str	r3, [sp, #12]
  csd20->c_size              =           _mmcsd_get_slice(csd, MMCSD_CSD_20_C_SIZE_SLICE);
 8004dfe:	9803      	ldr	r0, [sp, #12]
 8004e00:	2145      	movs	r1, #69	; 0x45
 8004e02:	2230      	movs	r2, #48	; 0x30
 8004e04:	f7ff fc34 	bl	8004670 <_mmcsd_get_slice>
 8004e08:	4602      	mov	r2, r0
 8004e0a:	9b00      	ldr	r3, [sp, #0]
 8004e0c:	60da      	str	r2, [r3, #12]
  csd20->crc                 = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_CRC_SLICE);
 8004e0e:	9803      	ldr	r0, [sp, #12]
 8004e10:	2107      	movs	r1, #7
 8004e12:	2201      	movs	r2, #1
 8004e14:	f7ff fc2c 	bl	8004670 <_mmcsd_get_slice>
 8004e18:	4603      	mov	r3, r0
 8004e1a:	b2da      	uxtb	r2, r3
 8004e1c:	9b00      	ldr	r3, [sp, #0]
 8004e1e:	771a      	strb	r2, [r3, #28]
  csd20->ccc                 = (uint16_t)_mmcsd_get_slice(csd, MMCSD_CSD_20_CCC_SLICE);
 8004e20:	9803      	ldr	r0, [sp, #12]
 8004e22:	215f      	movs	r1, #95	; 0x5f
 8004e24:	2254      	movs	r2, #84	; 0x54
 8004e26:	f7ff fc23 	bl	8004670 <_mmcsd_get_slice>
 8004e2a:	4603      	mov	r3, r0
 8004e2c:	b29a      	uxth	r2, r3
 8004e2e:	9b00      	ldr	r3, [sp, #0]
 8004e30:	809a      	strh	r2, [r3, #4]
  csd20->copy                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_COPY_SLICE);
 8004e32:	9803      	ldr	r0, [sp, #12]
 8004e34:	210e      	movs	r1, #14
 8004e36:	220e      	movs	r2, #14
 8004e38:	f7ff fc1a 	bl	8004670 <_mmcsd_get_slice>
 8004e3c:	4603      	mov	r3, r0
 8004e3e:	b2da      	uxtb	r2, r3
 8004e40:	9b00      	ldr	r3, [sp, #0]
 8004e42:	761a      	strb	r2, [r3, #24]
  csd20->csd_structure       = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_CSD_STRUCTURE_SLICE);
 8004e44:	9803      	ldr	r0, [sp, #12]
 8004e46:	217f      	movs	r1, #127	; 0x7f
 8004e48:	227e      	movs	r2, #126	; 0x7e
 8004e4a:	f7ff fc11 	bl	8004670 <_mmcsd_get_slice>
 8004e4e:	4603      	mov	r3, r0
 8004e50:	b2da      	uxtb	r2, r3
 8004e52:	9b00      	ldr	r3, [sp, #0]
 8004e54:	701a      	strb	r2, [r3, #0]
  csd20->dsr_imp             = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_DSR_IMP_SLICE);
 8004e56:	9803      	ldr	r0, [sp, #12]
 8004e58:	214c      	movs	r1, #76	; 0x4c
 8004e5a:	224c      	movs	r2, #76	; 0x4c
 8004e5c:	f7ff fc08 	bl	8004670 <_mmcsd_get_slice>
 8004e60:	4603      	mov	r3, r0
 8004e62:	b2da      	uxtb	r2, r3
 8004e64:	9b00      	ldr	r3, [sp, #0]
 8004e66:	729a      	strb	r2, [r3, #10]
  csd20->erase_blk_en        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_ERASE_BLK_EN_SLICE);
 8004e68:	9803      	ldr	r0, [sp, #12]
 8004e6a:	212e      	movs	r1, #46	; 0x2e
 8004e6c:	222e      	movs	r2, #46	; 0x2e
 8004e6e:	f7ff fbff 	bl	8004670 <_mmcsd_get_slice>
 8004e72:	4603      	mov	r3, r0
 8004e74:	b2da      	uxtb	r2, r3
 8004e76:	9b00      	ldr	r3, [sp, #0]
 8004e78:	741a      	strb	r2, [r3, #16]
  csd20->file_format         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_FILE_FORMAT_SLICE);
 8004e7a:	9803      	ldr	r0, [sp, #12]
 8004e7c:	210b      	movs	r1, #11
 8004e7e:	220a      	movs	r2, #10
 8004e80:	f7ff fbf6 	bl	8004670 <_mmcsd_get_slice>
 8004e84:	4603      	mov	r3, r0
 8004e86:	b2da      	uxtb	r2, r3
 8004e88:	9b00      	ldr	r3, [sp, #0]
 8004e8a:	76da      	strb	r2, [r3, #27]
  csd20->file_format_grp     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_FILE_FORMAT_GRP_SLICE);
 8004e8c:	9803      	ldr	r0, [sp, #12]
 8004e8e:	210f      	movs	r1, #15
 8004e90:	220f      	movs	r2, #15
 8004e92:	f7ff fbed 	bl	8004670 <_mmcsd_get_slice>
 8004e96:	4603      	mov	r3, r0
 8004e98:	b2da      	uxtb	r2, r3
 8004e9a:	9b00      	ldr	r3, [sp, #0]
 8004e9c:	75da      	strb	r2, [r3, #23]
  csd20->nsac                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_NSAC_SLICE);
 8004e9e:	9803      	ldr	r0, [sp, #12]
 8004ea0:	216f      	movs	r1, #111	; 0x6f
 8004ea2:	2268      	movs	r2, #104	; 0x68
 8004ea4:	f7ff fbe4 	bl	8004670 <_mmcsd_get_slice>
 8004ea8:	4603      	mov	r3, r0
 8004eaa:	b2da      	uxtb	r2, r3
 8004eac:	9b00      	ldr	r3, [sp, #0]
 8004eae:	709a      	strb	r2, [r3, #2]
  csd20->perm_write_protect  = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_PERM_WRITE_PROTECT_SLICE);
 8004eb0:	9803      	ldr	r0, [sp, #12]
 8004eb2:	210d      	movs	r1, #13
 8004eb4:	220d      	movs	r2, #13
 8004eb6:	f7ff fbdb 	bl	8004670 <_mmcsd_get_slice>
 8004eba:	4603      	mov	r3, r0
 8004ebc:	b2da      	uxtb	r2, r3
 8004ebe:	9b00      	ldr	r3, [sp, #0]
 8004ec0:	765a      	strb	r2, [r3, #25]
  csd20->r2w_factor          = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_R2W_FACTOR_SLICE);
 8004ec2:	9803      	ldr	r0, [sp, #12]
 8004ec4:	211c      	movs	r1, #28
 8004ec6:	221a      	movs	r2, #26
 8004ec8:	f7ff fbd2 	bl	8004670 <_mmcsd_get_slice>
 8004ecc:	4603      	mov	r3, r0
 8004ece:	b2da      	uxtb	r2, r3
 8004ed0:	9b00      	ldr	r3, [sp, #0]
 8004ed2:	751a      	strb	r2, [r3, #20]
  csd20->read_bl_len         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_READ_BL_LEN_SLICE);
 8004ed4:	9803      	ldr	r0, [sp, #12]
 8004ed6:	2153      	movs	r1, #83	; 0x53
 8004ed8:	2250      	movs	r2, #80	; 0x50
 8004eda:	f7ff fbc9 	bl	8004670 <_mmcsd_get_slice>
 8004ede:	4603      	mov	r3, r0
 8004ee0:	b2da      	uxtb	r2, r3
 8004ee2:	9b00      	ldr	r3, [sp, #0]
 8004ee4:	719a      	strb	r2, [r3, #6]
  csd20->read_bl_partial     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_READ_BL_PARTIAL_SLICE);
 8004ee6:	9803      	ldr	r0, [sp, #12]
 8004ee8:	214f      	movs	r1, #79	; 0x4f
 8004eea:	224f      	movs	r2, #79	; 0x4f
 8004eec:	f7ff fbc0 	bl	8004670 <_mmcsd_get_slice>
 8004ef0:	4603      	mov	r3, r0
 8004ef2:	b2da      	uxtb	r2, r3
 8004ef4:	9b00      	ldr	r3, [sp, #0]
 8004ef6:	71da      	strb	r2, [r3, #7]
  csd20->read_blk_misalign   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_READ_BLK_MISALIGN_SLICE);
 8004ef8:	9803      	ldr	r0, [sp, #12]
 8004efa:	214d      	movs	r1, #77	; 0x4d
 8004efc:	224d      	movs	r2, #77	; 0x4d
 8004efe:	f7ff fbb7 	bl	8004670 <_mmcsd_get_slice>
 8004f02:	4603      	mov	r3, r0
 8004f04:	b2da      	uxtb	r2, r3
 8004f06:	9b00      	ldr	r3, [sp, #0]
 8004f08:	725a      	strb	r2, [r3, #9]
  csd20->erase_sector_size   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_ERASE_SECTOR_SIZE_SLICE);
 8004f0a:	9803      	ldr	r0, [sp, #12]
 8004f0c:	212d      	movs	r1, #45	; 0x2d
 8004f0e:	2227      	movs	r2, #39	; 0x27
 8004f10:	f7ff fbae 	bl	8004670 <_mmcsd_get_slice>
 8004f14:	4603      	mov	r3, r0
 8004f16:	b2da      	uxtb	r2, r3
 8004f18:	9b00      	ldr	r3, [sp, #0]
 8004f1a:	745a      	strb	r2, [r3, #17]
  csd20->taac                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_TAAC_SLICE);
 8004f1c:	9803      	ldr	r0, [sp, #12]
 8004f1e:	2177      	movs	r1, #119	; 0x77
 8004f20:	2270      	movs	r2, #112	; 0x70
 8004f22:	f7ff fba5 	bl	8004670 <_mmcsd_get_slice>
 8004f26:	4603      	mov	r3, r0
 8004f28:	b2da      	uxtb	r2, r3
 8004f2a:	9b00      	ldr	r3, [sp, #0]
 8004f2c:	705a      	strb	r2, [r3, #1]
  csd20->tmp_write_protect   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_TMP_WRITE_PROTECT_SLICE);
 8004f2e:	9803      	ldr	r0, [sp, #12]
 8004f30:	210c      	movs	r1, #12
 8004f32:	220c      	movs	r2, #12
 8004f34:	f7ff fb9c 	bl	8004670 <_mmcsd_get_slice>
 8004f38:	4603      	mov	r3, r0
 8004f3a:	b2da      	uxtb	r2, r3
 8004f3c:	9b00      	ldr	r3, [sp, #0]
 8004f3e:	769a      	strb	r2, [r3, #26]
  csd20->tran_speed          = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_TRANS_SPEED_SLICE);
 8004f40:	9803      	ldr	r0, [sp, #12]
 8004f42:	2167      	movs	r1, #103	; 0x67
 8004f44:	2260      	movs	r2, #96	; 0x60
 8004f46:	f7ff fb93 	bl	8004670 <_mmcsd_get_slice>
 8004f4a:	4603      	mov	r3, r0
 8004f4c:	b2da      	uxtb	r2, r3
 8004f4e:	9b00      	ldr	r3, [sp, #0]
 8004f50:	70da      	strb	r2, [r3, #3]
  csd20->wp_grp_enable       = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_WP_GRP_ENABLE_SLICE);
 8004f52:	9803      	ldr	r0, [sp, #12]
 8004f54:	211f      	movs	r1, #31
 8004f56:	221f      	movs	r2, #31
 8004f58:	f7ff fb8a 	bl	8004670 <_mmcsd_get_slice>
 8004f5c:	4603      	mov	r3, r0
 8004f5e:	b2da      	uxtb	r2, r3
 8004f60:	9b00      	ldr	r3, [sp, #0]
 8004f62:	74da      	strb	r2, [r3, #19]
  csd20->wp_grp_size         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_WP_GRP_SIZE_SLICE);
 8004f64:	9803      	ldr	r0, [sp, #12]
 8004f66:	2126      	movs	r1, #38	; 0x26
 8004f68:	2220      	movs	r2, #32
 8004f6a:	f7ff fb81 	bl	8004670 <_mmcsd_get_slice>
 8004f6e:	4603      	mov	r3, r0
 8004f70:	b2da      	uxtb	r2, r3
 8004f72:	9b00      	ldr	r3, [sp, #0]
 8004f74:	749a      	strb	r2, [r3, #18]
  csd20->write_bl_len        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_WRITE_BL_LEN_SLICE);
 8004f76:	9803      	ldr	r0, [sp, #12]
 8004f78:	2119      	movs	r1, #25
 8004f7a:	220c      	movs	r2, #12
 8004f7c:	f7ff fb78 	bl	8004670 <_mmcsd_get_slice>
 8004f80:	4603      	mov	r3, r0
 8004f82:	b2da      	uxtb	r2, r3
 8004f84:	9b00      	ldr	r3, [sp, #0]
 8004f86:	755a      	strb	r2, [r3, #21]
  csd20->write_bl_partial    = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_WRITE_BL_PARTIAL_SLICE);
 8004f88:	9803      	ldr	r0, [sp, #12]
 8004f8a:	2115      	movs	r1, #21
 8004f8c:	2215      	movs	r2, #21
 8004f8e:	f7ff fb6f 	bl	8004670 <_mmcsd_get_slice>
 8004f92:	4603      	mov	r3, r0
 8004f94:	b2da      	uxtb	r2, r3
 8004f96:	9b00      	ldr	r3, [sp, #0]
 8004f98:	759a      	strb	r2, [r3, #22]
  csd20->write_blk_misalign  = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_WRITE_BLK_MISALIGN_SLICE);
 8004f9a:	9803      	ldr	r0, [sp, #12]
 8004f9c:	214e      	movs	r1, #78	; 0x4e
 8004f9e:	224e      	movs	r2, #78	; 0x4e
 8004fa0:	f7ff fb66 	bl	8004670 <_mmcsd_get_slice>
 8004fa4:	4603      	mov	r3, r0
 8004fa6:	b2da      	uxtb	r2, r3
 8004fa8:	9b00      	ldr	r3, [sp, #0]
 8004faa:	721a      	strb	r2, [r3, #8]
}
 8004fac:	b005      	add	sp, #20
 8004fae:	f85d fb04 	ldr.w	pc, [sp], #4
 8004fb2:	bf00      	nop
 8004fb4:	f3af 8000 	nop.w
 8004fb8:	f3af 8000 	nop.w
 8004fbc:	f3af 8000 	nop.w

08004fc0 <palReadBus>:
 * @param[in] bus       the I/O bus, pointer to a @p IOBus structure
 * @return              The bus logical states.
 *
 * @special
 */
ioportmask_t palReadBus(IOBus *bus) {
 8004fc0:	b082      	sub	sp, #8
 8004fc2:	9001      	str	r0, [sp, #4]

  osalDbgCheck((bus != NULL) && (bus->offset < PAL_IOPORTS_WIDTH));

  return palReadGroup(bus->portid, bus->mask, bus->offset);
 8004fc4:	9b01      	ldr	r3, [sp, #4]
 8004fc6:	681b      	ldr	r3, [r3, #0]
 8004fc8:	691a      	ldr	r2, [r3, #16]
 8004fca:	9b01      	ldr	r3, [sp, #4]
 8004fcc:	689b      	ldr	r3, [r3, #8]
 8004fce:	40da      	lsrs	r2, r3
 8004fd0:	9b01      	ldr	r3, [sp, #4]
 8004fd2:	685b      	ldr	r3, [r3, #4]
 8004fd4:	4013      	ands	r3, r2
}
 8004fd6:	4618      	mov	r0, r3
 8004fd8:	b002      	add	sp, #8
 8004fda:	4770      	bx	lr
 8004fdc:	f3af 8000 	nop.w

08004fe0 <palWriteBus>:
 *                      the bus width are masked so most significant bits are
 *                      lost.
 *
 * @special
 */
void palWriteBus(IOBus *bus, ioportmask_t bits) {
 8004fe0:	b082      	sub	sp, #8
 8004fe2:	9001      	str	r0, [sp, #4]
 8004fe4:	9100      	str	r1, [sp, #0]

  osalDbgCheck((bus != NULL) && (bus->offset < PAL_IOPORTS_WIDTH));

  palWriteGroup(bus->portid, bus->mask, bus->offset, bits);
 8004fe6:	9b01      	ldr	r3, [sp, #4]
 8004fe8:	681b      	ldr	r3, [r3, #0]
 8004fea:	9a00      	ldr	r2, [sp, #0]
 8004fec:	43d1      	mvns	r1, r2
 8004fee:	9a01      	ldr	r2, [sp, #4]
 8004ff0:	6852      	ldr	r2, [r2, #4]
 8004ff2:	4011      	ands	r1, r2
 8004ff4:	9a01      	ldr	r2, [sp, #4]
 8004ff6:	6892      	ldr	r2, [r2, #8]
 8004ff8:	3210      	adds	r2, #16
 8004ffa:	4091      	lsls	r1, r2
 8004ffc:	9a01      	ldr	r2, [sp, #4]
 8004ffe:	6850      	ldr	r0, [r2, #4]
 8005000:	9a00      	ldr	r2, [sp, #0]
 8005002:	4010      	ands	r0, r2
 8005004:	9a01      	ldr	r2, [sp, #4]
 8005006:	6892      	ldr	r2, [r2, #8]
 8005008:	fa00 f202 	lsl.w	r2, r0, r2
 800500c:	430a      	orrs	r2, r1
 800500e:	619a      	str	r2, [r3, #24]
}
 8005010:	b002      	add	sp, #8
 8005012:	4770      	bx	lr
 8005014:	f3af 8000 	nop.w
 8005018:	f3af 8000 	nop.w
 800501c:	f3af 8000 	nop.w

08005020 <palSetBusMode>:
 * @param[in] bus       the I/O bus, pointer to a @p IOBus structure
 * @param[in] mode      the mode
 *
 * @special
 */
void palSetBusMode(IOBus *bus, iomode_t mode) {
 8005020:	b500      	push	{lr}
 8005022:	b083      	sub	sp, #12
 8005024:	9001      	str	r0, [sp, #4]
 8005026:	9100      	str	r1, [sp, #0]

  osalDbgCheck((bus != NULL) && (bus->offset < PAL_IOPORTS_WIDTH));

  palSetGroupMode(bus->portid, bus->mask, bus->offset, mode);
 8005028:	9b01      	ldr	r3, [sp, #4]
 800502a:	681a      	ldr	r2, [r3, #0]
 800502c:	9b01      	ldr	r3, [sp, #4]
 800502e:	6859      	ldr	r1, [r3, #4]
 8005030:	9b01      	ldr	r3, [sp, #4]
 8005032:	689b      	ldr	r3, [r3, #8]
 8005034:	fa01 f303 	lsl.w	r3, r1, r3
 8005038:	4610      	mov	r0, r2
 800503a:	4619      	mov	r1, r3
 800503c:	9a00      	ldr	r2, [sp, #0]
 800503e:	f002 fe5f 	bl	8007d00 <_pal_lld_setgroupmode>
}
 8005042:	b003      	add	sp, #12
 8005044:	f85d fb04 	ldr.w	pc, [sp], #4
 8005048:	f3af 8000 	nop.w
 800504c:	f3af 8000 	nop.w

08005050 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8005050:	b082      	sub	sp, #8
 8005052:	2320      	movs	r3, #32
 8005054:	9301      	str	r3, [sp, #4]
 8005056:	9b01      	ldr	r3, [sp, #4]
 8005058:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800505c:	b002      	add	sp, #8
 800505e:	4770      	bx	lr

08005060 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8005060:	b082      	sub	sp, #8
 8005062:	2300      	movs	r3, #0
 8005064:	9301      	str	r3, [sp, #4]
 8005066:	9b01      	ldr	r3, [sp, #4]
 8005068:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800506c:	b002      	add	sp, #8
 800506e:	4770      	bx	lr

08005070 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8005070:	b508      	push	{r3, lr}

  port_lock();
 8005072:	f7ff ffed 	bl	8005050 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8005076:	bd08      	pop	{r3, pc}
 8005078:	f3af 8000 	nop.w
 800507c:	f3af 8000 	nop.w

08005080 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8005080:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8005082:	f7ff ffed 	bl	8005060 <port_unlock>
}
 8005086:	bd08      	pop	{r3, pc}
 8005088:	f3af 8000 	nop.w
 800508c:	f3af 8000 	nop.w

08005090 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8005090:	b508      	push	{r3, lr}

  chSysLock();
 8005092:	f7ff ffed 	bl	8005070 <chSysLock>
}
 8005096:	bd08      	pop	{r3, pc}
 8005098:	f3af 8000 	nop.w
 800509c:	f3af 8000 	nop.w

080050a0 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 80050a0:	b508      	push	{r3, lr}

  chSysUnlock();
 80050a2:	f7ff ffed 	bl	8005080 <chSysUnlock>
}
 80050a6:	bd08      	pop	{r3, pc}
 80050a8:	f3af 8000 	nop.w
 80050ac:	f3af 8000 	nop.w

080050b0 <osalThreadSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
static inline void osalThreadSleep(systime_t time) {
 80050b0:	b500      	push	{lr}
 80050b2:	b083      	sub	sp, #12
 80050b4:	9001      	str	r0, [sp, #4]

  chThdSleep(time);
 80050b6:	9801      	ldr	r0, [sp, #4]
 80050b8:	f7fc f90a 	bl	80012d0 <chThdSleep>
}
 80050bc:	b003      	add	sp, #12
 80050be:	f85d fb04 	ldr.w	pc, [sp], #4
 80050c2:	bf00      	nop
 80050c4:	f3af 8000 	nop.w
 80050c8:	f3af 8000 	nop.w
 80050cc:	f3af 8000 	nop.w

080050d0 <mode_detect>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool mode_detect(SDCDriver *sdcp) {
 80050d0:	b500      	push	{lr}
 80050d2:	b085      	sub	sp, #20
 80050d4:	9001      	str	r0, [sp, #4]
  uint32_t resp[1];

  /* V2.0 cards detection.*/
  if (!sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_IF_COND,
 80050d6:	ab03      	add	r3, sp, #12
 80050d8:	9801      	ldr	r0, [sp, #4]
 80050da:	2108      	movs	r1, #8
 80050dc:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
 80050e0:	f004 fe3e 	bl	8009d60 <sdc_lld_send_cmd_short_crc>
 80050e4:	4603      	mov	r3, r0
 80050e6:	f083 0301 	eor.w	r3, r3, #1
 80050ea:	b2db      	uxtb	r3, r3
 80050ec:	2b00      	cmp	r3, #0
 80050ee:	d01a      	beq.n	8005126 <mode_detect+0x56>
                                  MMCSD_CMD8_PATTERN, resp)) {
    sdcp->cardmode = SDC_MODE_CARDTYPE_SDV20;
 80050f0:	9b01      	ldr	r3, [sp, #4]
 80050f2:	2201      	movs	r2, #1
 80050f4:	631a      	str	r2, [r3, #48]	; 0x30
    /* Voltage verification.*/
    if (((resp[0] >> 8U) & 0xFU) != 1U) {
 80050f6:	9b03      	ldr	r3, [sp, #12]
 80050f8:	0a1b      	lsrs	r3, r3, #8
 80050fa:	f003 030f 	and.w	r3, r3, #15
 80050fe:	2b01      	cmp	r3, #1
 8005100:	d001      	beq.n	8005106 <mode_detect+0x36>
      return HAL_FAILED;
 8005102:	2301      	movs	r3, #1
 8005104:	e02a      	b.n	800515c <mode_detect+0x8c>
    }
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 8005106:	ab03      	add	r3, sp, #12
 8005108:	9801      	ldr	r0, [sp, #4]
 800510a:	2137      	movs	r1, #55	; 0x37
 800510c:	2200      	movs	r2, #0
 800510e:	f004 fe27 	bl	8009d60 <sdc_lld_send_cmd_short_crc>
 8005112:	4603      	mov	r3, r0
 8005114:	2b00      	cmp	r3, #0
 8005116:	d104      	bne.n	8005122 <mode_detect+0x52>
        MMCSD_R1_ERROR(resp[0])) {
 8005118:	9a03      	ldr	r2, [sp, #12]
 800511a:	4b12      	ldr	r3, [pc, #72]	; (8005164 <mode_detect+0x94>)
 800511c:	4013      	ands	r3, r2
    sdcp->cardmode = SDC_MODE_CARDTYPE_SDV20;
    /* Voltage verification.*/
    if (((resp[0] >> 8U) & 0xFU) != 1U) {
      return HAL_FAILED;
    }
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 800511e:	2b00      	cmp	r3, #0
 8005120:	d01b      	beq.n	800515a <mode_detect+0x8a>
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
 8005122:	2301      	movs	r3, #1
 8005124:	e01a      	b.n	800515c <mode_detect+0x8c>
    }
  }
  else {
    /* MMC or SD V1.1 detection.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 8005126:	ab03      	add	r3, sp, #12
 8005128:	9801      	ldr	r0, [sp, #4]
 800512a:	2137      	movs	r1, #55	; 0x37
 800512c:	2200      	movs	r2, #0
 800512e:	f004 fe17 	bl	8009d60 <sdc_lld_send_cmd_short_crc>
 8005132:	4603      	mov	r3, r0
 8005134:	2b00      	cmp	r3, #0
 8005136:	d104      	bne.n	8005142 <mode_detect+0x72>
        MMCSD_R1_ERROR(resp[0])) {
 8005138:	9a03      	ldr	r2, [sp, #12]
 800513a:	4b0a      	ldr	r3, [pc, #40]	; (8005164 <mode_detect+0x94>)
 800513c:	4013      	ands	r3, r2
      return HAL_FAILED;
    }
  }
  else {
    /* MMC or SD V1.1 detection.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 800513e:	2b00      	cmp	r3, #0
 8005140:	d003      	beq.n	800514a <mode_detect+0x7a>
        MMCSD_R1_ERROR(resp[0])) {
      sdcp->cardmode = SDC_MODE_CARDTYPE_MMC;
 8005142:	9b01      	ldr	r3, [sp, #4]
 8005144:	2202      	movs	r2, #2
 8005146:	631a      	str	r2, [r3, #48]	; 0x30
 8005148:	e007      	b.n	800515a <mode_detect+0x8a>
    }
    else {
      sdcp->cardmode = SDC_MODE_CARDTYPE_SDV11;
 800514a:	9b01      	ldr	r3, [sp, #4]
 800514c:	2200      	movs	r2, #0
 800514e:	631a      	str	r2, [r3, #48]	; 0x30
    
      /* Reset error flag illegal command.*/
      sdc_lld_send_cmd_none(sdcp, MMCSD_CMD_GO_IDLE_STATE, 0);
 8005150:	9801      	ldr	r0, [sp, #4]
 8005152:	2100      	movs	r1, #0
 8005154:	2200      	movs	r2, #0
 8005156:	f004 fda3 	bl	8009ca0 <sdc_lld_send_cmd_none>
    }
  }

  return HAL_SUCCESS;
 800515a:	2300      	movs	r3, #0
}
 800515c:	4618      	mov	r0, r3
 800515e:	b005      	add	sp, #20
 8005160:	f85d fb04 	ldr.w	pc, [sp], #4
 8005164:	fdffe008 	.word	0xfdffe008
 8005168:	f3af 8000 	nop.w
 800516c:	f3af 8000 	nop.w

08005170 <mmc_init>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool mmc_init(SDCDriver *sdcp) {
 8005170:	b500      	push	{lr}
 8005172:	b087      	sub	sp, #28
 8005174:	9001      	str	r0, [sp, #4]
  uint32_t ocr;
  unsigned i;
  uint32_t resp[1];

  ocr = 0xC0FF8000U;
 8005176:	4b18      	ldr	r3, [pc, #96]	; (80051d8 <mmc_init+0x68>)
 8005178:	9304      	str	r3, [sp, #16]
  i = 0;
 800517a:	2300      	movs	r3, #0
 800517c:	9305      	str	r3, [sp, #20]
  while (true) {
    if (sdc_lld_send_cmd_short(sdcp, MMCSD_CMD_INIT, ocr, resp)) {
 800517e:	ab03      	add	r3, sp, #12
 8005180:	9801      	ldr	r0, [sp, #4]
 8005182:	2101      	movs	r1, #1
 8005184:	9a04      	ldr	r2, [sp, #16]
 8005186:	f004 fdab 	bl	8009ce0 <sdc_lld_send_cmd_short>
 800518a:	4603      	mov	r3, r0
 800518c:	2b00      	cmp	r3, #0
 800518e:	d001      	beq.n	8005194 <mmc_init+0x24>
      return HAL_FAILED;
 8005190:	2301      	movs	r3, #1
 8005192:	e01c      	b.n	80051ce <mmc_init+0x5e>
    }
    if ((resp[0] & 0x80000000U) != 0U) {
 8005194:	9b03      	ldr	r3, [sp, #12]
 8005196:	2b00      	cmp	r3, #0
 8005198:	da0c      	bge.n	80051b4 <mmc_init+0x44>
      if ((resp[0] & 0x40000000U) != 0U) {
 800519a:	9b03      	ldr	r3, [sp, #12]
 800519c:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 80051a0:	2b00      	cmp	r3, #0
 80051a2:	d006      	beq.n	80051b2 <mmc_init+0x42>
        sdcp->cardmode |= SDC_MODE_HIGH_CAPACITY;
 80051a4:	9b01      	ldr	r3, [sp, #4]
 80051a6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80051a8:	f043 0210 	orr.w	r2, r3, #16
 80051ac:	9b01      	ldr	r3, [sp, #4]
 80051ae:	631a      	str	r2, [r3, #48]	; 0x30
      }
      break;
 80051b0:	e00c      	b.n	80051cc <mmc_init+0x5c>
 80051b2:	e00b      	b.n	80051cc <mmc_init+0x5c>
    }
    if (++i >= (unsigned)SDC_INIT_RETRY) {
 80051b4:	9b05      	ldr	r3, [sp, #20]
 80051b6:	3301      	adds	r3, #1
 80051b8:	9305      	str	r3, [sp, #20]
 80051ba:	9b05      	ldr	r3, [sp, #20]
 80051bc:	2b63      	cmp	r3, #99	; 0x63
 80051be:	d901      	bls.n	80051c4 <mmc_init+0x54>
      return HAL_FAILED;
 80051c0:	2301      	movs	r3, #1
 80051c2:	e004      	b.n	80051ce <mmc_init+0x5e>
    }
    osalThreadSleepMilliseconds(10);
 80051c4:	200a      	movs	r0, #10
 80051c6:	f7ff ff73 	bl	80050b0 <osalThreadSleep>
  }
 80051ca:	e7d8      	b.n	800517e <mmc_init+0xe>

  return HAL_SUCCESS;
 80051cc:	2300      	movs	r3, #0
}
 80051ce:	4618      	mov	r0, r3
 80051d0:	b007      	add	sp, #28
 80051d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80051d6:	bf00      	nop
 80051d8:	c0ff8000 	.word	0xc0ff8000
 80051dc:	f3af 8000 	nop.w

080051e0 <sdc_init>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_init(SDCDriver *sdcp) {
 80051e0:	b500      	push	{lr}
 80051e2:	b087      	sub	sp, #28
 80051e4:	9001      	str	r0, [sp, #4]
  unsigned i;
  uint32_t ocr;
  uint32_t resp[1];

  if ((sdcp->cardmode &  SDC_MODE_CARDTYPE_MASK) == SDC_MODE_CARDTYPE_SDV20) {
 80051e6:	9b01      	ldr	r3, [sp, #4]
 80051e8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80051ea:	f003 030f 	and.w	r3, r3, #15
 80051ee:	2b01      	cmp	r3, #1
 80051f0:	d102      	bne.n	80051f8 <sdc_init+0x18>
    ocr = 0xC0100000U;
 80051f2:	4b21      	ldr	r3, [pc, #132]	; (8005278 <sdc_init+0x98>)
 80051f4:	9304      	str	r3, [sp, #16]
 80051f6:	e001      	b.n	80051fc <sdc_init+0x1c>
  }
  else {
    ocr = 0x80100000U;
 80051f8:	4b20      	ldr	r3, [pc, #128]	; (800527c <sdc_init+0x9c>)
 80051fa:	9304      	str	r3, [sp, #16]
  }

  i = 0;
 80051fc:	2300      	movs	r3, #0
 80051fe:	9305      	str	r3, [sp, #20]
  while (true) {
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 8005200:	ab03      	add	r3, sp, #12
 8005202:	9801      	ldr	r0, [sp, #4]
 8005204:	2137      	movs	r1, #55	; 0x37
 8005206:	2200      	movs	r2, #0
 8005208:	f004 fdaa 	bl	8009d60 <sdc_lld_send_cmd_short_crc>
 800520c:	4603      	mov	r3, r0
 800520e:	2b00      	cmp	r3, #0
 8005210:	d104      	bne.n	800521c <sdc_init+0x3c>
        MMCSD_R1_ERROR(resp[0])) {
 8005212:	9a03      	ldr	r2, [sp, #12]
 8005214:	4b1a      	ldr	r3, [pc, #104]	; (8005280 <sdc_init+0xa0>)
 8005216:	4013      	ands	r3, r2
    ocr = 0x80100000U;
  }

  i = 0;
  while (true) {
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 8005218:	2b00      	cmp	r3, #0
 800521a:	d001      	beq.n	8005220 <sdc_init+0x40>
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
 800521c:	2301      	movs	r3, #1
 800521e:	e027      	b.n	8005270 <sdc_init+0x90>
    }
    if (sdc_lld_send_cmd_short(sdcp, MMCSD_CMD_APP_OP_COND, ocr, resp)) {
 8005220:	ab03      	add	r3, sp, #12
 8005222:	9801      	ldr	r0, [sp, #4]
 8005224:	2129      	movs	r1, #41	; 0x29
 8005226:	9a04      	ldr	r2, [sp, #16]
 8005228:	f004 fd5a 	bl	8009ce0 <sdc_lld_send_cmd_short>
 800522c:	4603      	mov	r3, r0
 800522e:	2b00      	cmp	r3, #0
 8005230:	d001      	beq.n	8005236 <sdc_init+0x56>
      return HAL_FAILED;
 8005232:	2301      	movs	r3, #1
 8005234:	e01c      	b.n	8005270 <sdc_init+0x90>
    }
    if ((resp[0] & 0x80000000U) != 0U) {
 8005236:	9b03      	ldr	r3, [sp, #12]
 8005238:	2b00      	cmp	r3, #0
 800523a:	da0c      	bge.n	8005256 <sdc_init+0x76>
      if ((resp[0] & 0x40000000U) != 0U) {
 800523c:	9b03      	ldr	r3, [sp, #12]
 800523e:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8005242:	2b00      	cmp	r3, #0
 8005244:	d006      	beq.n	8005254 <sdc_init+0x74>
        sdcp->cardmode |= SDC_MODE_HIGH_CAPACITY;
 8005246:	9b01      	ldr	r3, [sp, #4]
 8005248:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800524a:	f043 0210 	orr.w	r2, r3, #16
 800524e:	9b01      	ldr	r3, [sp, #4]
 8005250:	631a      	str	r2, [r3, #48]	; 0x30
      }
      break;
 8005252:	e00c      	b.n	800526e <sdc_init+0x8e>
 8005254:	e00b      	b.n	800526e <sdc_init+0x8e>
    }
    if (++i >= (unsigned)SDC_INIT_RETRY) {
 8005256:	9b05      	ldr	r3, [sp, #20]
 8005258:	3301      	adds	r3, #1
 800525a:	9305      	str	r3, [sp, #20]
 800525c:	9b05      	ldr	r3, [sp, #20]
 800525e:	2b63      	cmp	r3, #99	; 0x63
 8005260:	d901      	bls.n	8005266 <sdc_init+0x86>
      return HAL_FAILED;
 8005262:	2301      	movs	r3, #1
 8005264:	e004      	b.n	8005270 <sdc_init+0x90>
    }
    osalThreadSleepMilliseconds(10);
 8005266:	200a      	movs	r0, #10
 8005268:	f7ff ff22 	bl	80050b0 <osalThreadSleep>
  }
 800526c:	e7c8      	b.n	8005200 <sdc_init+0x20>

  return HAL_SUCCESS;
 800526e:	2300      	movs	r3, #0
}
 8005270:	4618      	mov	r0, r3
 8005272:	b007      	add	sp, #28
 8005274:	f85d fb04 	ldr.w	pc, [sp], #4
 8005278:	c0100000 	.word	0xc0100000
 800527c:	80100000 	.word	0x80100000
 8005280:	fdffe008 	.word	0xfdffe008
 8005284:	f3af 8000 	nop.w
 8005288:	f3af 8000 	nop.w
 800528c:	f3af 8000 	nop.w

08005290 <mmc_cmd6_construct>:
 * @return              CMD6 argument.
 *
 * @notapi
 */
static uint32_t mmc_cmd6_construct(mmc_switch_t access, uint32_t idx,
                                   uint32_t value, uint32_t cmd_set) {
 8005290:	b084      	sub	sp, #16
 8005292:	9102      	str	r1, [sp, #8]
 8005294:	9201      	str	r2, [sp, #4]
 8005296:	9300      	str	r3, [sp, #0]
 8005298:	4603      	mov	r3, r0
 800529a:	f88d 300f 	strb.w	r3, [sp, #15]

  osalDbgAssert(idx <= 191U, "This field is not writable");
  osalDbgAssert(cmd_set < 8U, "This field has only 3 bits");

  return ((uint32_t)access << 24U) | (idx << 16U) | (value << 8U) | cmd_set;
 800529e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80052a2:	061a      	lsls	r2, r3, #24
 80052a4:	9b02      	ldr	r3, [sp, #8]
 80052a6:	041b      	lsls	r3, r3, #16
 80052a8:	431a      	orrs	r2, r3
 80052aa:	9b01      	ldr	r3, [sp, #4]
 80052ac:	021b      	lsls	r3, r3, #8
 80052ae:	431a      	orrs	r2, r3
 80052b0:	9b00      	ldr	r3, [sp, #0]
 80052b2:	4313      	orrs	r3, r2
}
 80052b4:	4618      	mov	r0, r3
 80052b6:	b004      	add	sp, #16
 80052b8:	4770      	bx	lr
 80052ba:	bf00      	nop
 80052bc:	f3af 8000 	nop.w

080052c0 <sdc_cmd6_construct>:
 *
 * @notapi
 */
static uint32_t sdc_cmd6_construct(sd_switch_t mode,
                                   sd_switch_function_t function,
                                   uint32_t value) {
 80052c0:	b084      	sub	sp, #16
 80052c2:	460b      	mov	r3, r1
 80052c4:	9200      	str	r2, [sp, #0]
 80052c6:	4602      	mov	r2, r0
 80052c8:	f88d 2007 	strb.w	r2, [sp, #7]
 80052cc:	f88d 3006 	strb.w	r3, [sp, #6]
  uint32_t ret = 0xFFFFFF;
 80052d0:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 80052d4:	9303      	str	r3, [sp, #12]

  osalDbgAssert((value < 16U), "This field has only 4 bits");

  ret &= ~((uint32_t)0xFU << ((uint32_t)function * 4U));
 80052d6:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80052da:	009b      	lsls	r3, r3, #2
 80052dc:	220f      	movs	r2, #15
 80052de:	fa02 f303 	lsl.w	r3, r2, r3
 80052e2:	43db      	mvns	r3, r3
 80052e4:	9a03      	ldr	r2, [sp, #12]
 80052e6:	4013      	ands	r3, r2
 80052e8:	9303      	str	r3, [sp, #12]
  ret |= value << ((uint32_t)function * 4U);
 80052ea:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80052ee:	009b      	lsls	r3, r3, #2
 80052f0:	9a00      	ldr	r2, [sp, #0]
 80052f2:	fa02 f303 	lsl.w	r3, r2, r3
 80052f6:	9a03      	ldr	r2, [sp, #12]
 80052f8:	4313      	orrs	r3, r2
 80052fa:	9303      	str	r3, [sp, #12]
  return ret | ((uint32_t)mode << 31U);
 80052fc:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8005300:	07da      	lsls	r2, r3, #31
 8005302:	9b03      	ldr	r3, [sp, #12]
 8005304:	4313      	orrs	r3, r2
}
 8005306:	4618      	mov	r0, r3
 8005308:	b004      	add	sp, #16
 800530a:	4770      	bx	lr
 800530c:	f3af 8000 	nop.w

08005310 <sdc_cmd6_extract_info>:
 * @return              extracted answer.
 *
 * @notapi
 */
static uint16_t sdc_cmd6_extract_info(sd_switch_function_t function,
                                      const uint8_t *buf) {
 8005310:	b084      	sub	sp, #16
 8005312:	4603      	mov	r3, r0
 8005314:	9100      	str	r1, [sp, #0]
 8005316:	f88d 3007 	strb.w	r3, [sp, #7]

  unsigned start = 12U - ((unsigned)function * 2U);
 800531a:	f89d 2007 	ldrb.w	r2, [sp, #7]
 800531e:	4613      	mov	r3, r2
 8005320:	07db      	lsls	r3, r3, #31
 8005322:	1a9b      	subs	r3, r3, r2
 8005324:	005b      	lsls	r3, r3, #1
 8005326:	330c      	adds	r3, #12
 8005328:	9303      	str	r3, [sp, #12]

  return ((uint16_t)buf[start] << 8U) | (uint16_t)buf[start + 1U];
 800532a:	9a00      	ldr	r2, [sp, #0]
 800532c:	9b03      	ldr	r3, [sp, #12]
 800532e:	4413      	add	r3, r2
 8005330:	781b      	ldrb	r3, [r3, #0]
 8005332:	021b      	lsls	r3, r3, #8
 8005334:	b29a      	uxth	r2, r3
 8005336:	9b03      	ldr	r3, [sp, #12]
 8005338:	3301      	adds	r3, #1
 800533a:	9900      	ldr	r1, [sp, #0]
 800533c:	440b      	add	r3, r1
 800533e:	781b      	ldrb	r3, [r3, #0]
 8005340:	4313      	orrs	r3, r2
 8005342:	b29b      	uxth	r3, r3
 8005344:	b29b      	uxth	r3, r3
}
 8005346:	4618      	mov	r0, r3
 8005348:	b004      	add	sp, #16
 800534a:	4770      	bx	lr
 800534c:	f3af 8000 	nop.w

08005350 <sdc_cmd6_check_status>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_cmd6_check_status(sd_switch_function_t function,
                                 const uint8_t *buf) {
 8005350:	b084      	sub	sp, #16
 8005352:	4603      	mov	r3, r0
 8005354:	9100      	str	r1, [sp, #0]
 8005356:	f88d 3007 	strb.w	r3, [sp, #7]

  uint32_t tmp;
  uint32_t status;

  tmp = ((uint32_t)buf[14] << 16U) |
 800535a:	9b00      	ldr	r3, [sp, #0]
 800535c:	330e      	adds	r3, #14
 800535e:	781b      	ldrb	r3, [r3, #0]
 8005360:	041a      	lsls	r2, r3, #16
        ((uint32_t)buf[15] << 8U) |
 8005362:	9b00      	ldr	r3, [sp, #0]
 8005364:	330f      	adds	r3, #15
 8005366:	781b      	ldrb	r3, [r3, #0]
 8005368:	021b      	lsls	r3, r3, #8
                                 const uint8_t *buf) {

  uint32_t tmp;
  uint32_t status;

  tmp = ((uint32_t)buf[14] << 16U) |
 800536a:	431a      	orrs	r2, r3
        ((uint32_t)buf[15] << 8U) |
        (uint32_t)buf[16];
 800536c:	9b00      	ldr	r3, [sp, #0]
 800536e:	3310      	adds	r3, #16
 8005370:	781b      	ldrb	r3, [r3, #0]
                                 const uint8_t *buf) {

  uint32_t tmp;
  uint32_t status;

  tmp = ((uint32_t)buf[14] << 16U) |
 8005372:	4313      	orrs	r3, r2
 8005374:	9303      	str	r3, [sp, #12]
        ((uint32_t)buf[15] << 8U) |
        (uint32_t)buf[16];
  status = (tmp >> ((uint32_t)function * 4U)) & 0xFU;
 8005376:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800537a:	009b      	lsls	r3, r3, #2
 800537c:	9a03      	ldr	r2, [sp, #12]
 800537e:	fa22 f303 	lsr.w	r3, r2, r3
 8005382:	f003 030f 	and.w	r3, r3, #15
 8005386:	9302      	str	r3, [sp, #8]
  if (0xFU != status) {
 8005388:	9b02      	ldr	r3, [sp, #8]
 800538a:	2b0f      	cmp	r3, #15
 800538c:	d001      	beq.n	8005392 <sdc_cmd6_check_status+0x42>
    return HAL_SUCCESS;
 800538e:	2300      	movs	r3, #0
 8005390:	e000      	b.n	8005394 <sdc_cmd6_check_status+0x44>
  }
  return HAL_FAILED;
 8005392:	2301      	movs	r3, #1
}
 8005394:	4618      	mov	r0, r3
 8005396:	b004      	add	sp, #16
 8005398:	4770      	bx	lr
 800539a:	bf00      	nop
 800539c:	f3af 8000 	nop.w

080053a0 <sdc_detect_bus_clk>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_detect_bus_clk(SDCDriver *sdcp, sdcbusclk_t *clk) {
 80053a0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80053a2:	b089      	sub	sp, #36	; 0x24
 80053a4:	af02      	add	r7, sp, #8
 80053a6:	6078      	str	r0, [r7, #4]
 80053a8:	6039      	str	r1, [r7, #0]
 80053aa:	4669      	mov	r1, sp
 80053ac:	460e      	mov	r6, r1
  uint32_t cmdarg;
  const size_t N = 64;
 80053ae:	2140      	movs	r1, #64	; 0x40
 80053b0:	6179      	str	r1, [r7, #20]
  uint8_t tmp[N];
 80053b2:	6979      	ldr	r1, [r7, #20]
 80053b4:	3901      	subs	r1, #1
 80053b6:	6139      	str	r1, [r7, #16]
 80053b8:	6979      	ldr	r1, [r7, #20]
 80053ba:	4608      	mov	r0, r1
 80053bc:	f04f 0100 	mov.w	r1, #0
 80053c0:	00cd      	lsls	r5, r1, #3
 80053c2:	ea45 7550 	orr.w	r5, r5, r0, lsr #29
 80053c6:	00c4      	lsls	r4, r0, #3
 80053c8:	6979      	ldr	r1, [r7, #20]
 80053ca:	4608      	mov	r0, r1
 80053cc:	f04f 0100 	mov.w	r1, #0
 80053d0:	00cb      	lsls	r3, r1, #3
 80053d2:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 80053d6:	00c2      	lsls	r2, r0, #3
 80053d8:	697b      	ldr	r3, [r7, #20]
 80053da:	3307      	adds	r3, #7
 80053dc:	08db      	lsrs	r3, r3, #3
 80053de:	00db      	lsls	r3, r3, #3
 80053e0:	ebad 0d03 	sub.w	sp, sp, r3
 80053e4:	ab02      	add	r3, sp, #8
 80053e6:	3300      	adds	r3, #0
 80053e8:	60fb      	str	r3, [r7, #12]

  /* Safe default.*/
  *clk = SDC_CLK_25MHz;
 80053ea:	683b      	ldr	r3, [r7, #0]
 80053ec:	2200      	movs	r2, #0
 80053ee:	701a      	strb	r2, [r3, #0]

  /* Looks like only "high capacity" cards produce meaningful results during
     this clock detection procedure.*/
  if (0U == _mmcsd_get_slice(sdcp->csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 80053f0:	687b      	ldr	r3, [r7, #4]
 80053f2:	3318      	adds	r3, #24
 80053f4:	4618      	mov	r0, r3
 80053f6:	217f      	movs	r1, #127	; 0x7f
 80053f8:	227e      	movs	r2, #126	; 0x7e
 80053fa:	f7ff f939 	bl	8004670 <_mmcsd_get_slice>
 80053fe:	4603      	mov	r3, r0
 8005400:	2b00      	cmp	r3, #0
 8005402:	d104      	bne.n	800540e <sdc_detect_bus_clk+0x6e>
    *clk = SDC_CLK_25MHz;
 8005404:	683b      	ldr	r3, [r7, #0]
 8005406:	2200      	movs	r2, #0
 8005408:	701a      	strb	r2, [r3, #0]
    return HAL_SUCCESS;
 800540a:	2300      	movs	r3, #0
 800540c:	e03e      	b.n	800548c <sdc_detect_bus_clk+0xec>
  }

  /* Read switch functions' register.*/
  if (sdc_lld_read_special(sdcp, tmp, N, MMCSD_CMD_SWITCH, 0)) {
 800540e:	68fb      	ldr	r3, [r7, #12]
 8005410:	2200      	movs	r2, #0
 8005412:	9200      	str	r2, [sp, #0]
 8005414:	6878      	ldr	r0, [r7, #4]
 8005416:	4619      	mov	r1, r3
 8005418:	697a      	ldr	r2, [r7, #20]
 800541a:	2306      	movs	r3, #6
 800541c:	f004 fd30 	bl	8009e80 <sdc_lld_read_special>
 8005420:	4603      	mov	r3, r0
 8005422:	2b00      	cmp	r3, #0
 8005424:	d001      	beq.n	800542a <sdc_detect_bus_clk+0x8a>
    return HAL_FAILED;
 8005426:	2301      	movs	r3, #1
 8005428:	e030      	b.n	800548c <sdc_detect_bus_clk+0xec>
  }

  /* Check card capabilities parsing acquired data.*/
  if ((sdc_cmd6_extract_info(SD_SWITCH_FUNCTION_SPEED, tmp) & 2U) == 2U) {
 800542a:	68fb      	ldr	r3, [r7, #12]
 800542c:	2000      	movs	r0, #0
 800542e:	4619      	mov	r1, r3
 8005430:	f7ff ff6e 	bl	8005310 <sdc_cmd6_extract_info>
 8005434:	4603      	mov	r3, r0
 8005436:	f003 0302 	and.w	r3, r3, #2
 800543a:	2b00      	cmp	r3, #0
 800543c:	d025      	beq.n	800548a <sdc_detect_bus_clk+0xea>
    /* Construct command to set the bus speed.*/
    cmdarg = sdc_cmd6_construct(SD_SWITCH_SET, SD_SWITCH_FUNCTION_SPEED, 1);
 800543e:	2001      	movs	r0, #1
 8005440:	2100      	movs	r1, #0
 8005442:	2201      	movs	r2, #1
 8005444:	f7ff ff3c 	bl	80052c0 <sdc_cmd6_construct>
 8005448:	60b8      	str	r0, [r7, #8]

    /* Write constructed command and read operation status in single call.*/
    if (sdc_lld_read_special(sdcp, tmp, N, MMCSD_CMD_SWITCH, cmdarg)) {
 800544a:	68fb      	ldr	r3, [r7, #12]
 800544c:	68ba      	ldr	r2, [r7, #8]
 800544e:	9200      	str	r2, [sp, #0]
 8005450:	6878      	ldr	r0, [r7, #4]
 8005452:	4619      	mov	r1, r3
 8005454:	697a      	ldr	r2, [r7, #20]
 8005456:	2306      	movs	r3, #6
 8005458:	f004 fd12 	bl	8009e80 <sdc_lld_read_special>
 800545c:	4603      	mov	r3, r0
 800545e:	2b00      	cmp	r3, #0
 8005460:	d001      	beq.n	8005466 <sdc_detect_bus_clk+0xc6>
      return HAL_FAILED;
 8005462:	2301      	movs	r3, #1
 8005464:	e012      	b.n	800548c <sdc_detect_bus_clk+0xec>
    }

    /* Check card answer for success status bits.*/
    if (HAL_SUCCESS == sdc_cmd6_check_status(SD_SWITCH_FUNCTION_SPEED, tmp)) {
 8005466:	68fb      	ldr	r3, [r7, #12]
 8005468:	2000      	movs	r0, #0
 800546a:	4619      	mov	r1, r3
 800546c:	f7ff ff70 	bl	8005350 <sdc_cmd6_check_status>
 8005470:	4603      	mov	r3, r0
 8005472:	f083 0301 	eor.w	r3, r3, #1
 8005476:	b2db      	uxtb	r3, r3
 8005478:	2b00      	cmp	r3, #0
 800547a:	d003      	beq.n	8005484 <sdc_detect_bus_clk+0xe4>
      *clk = SDC_CLK_50MHz;
 800547c:	683b      	ldr	r3, [r7, #0]
 800547e:	2201      	movs	r2, #1
 8005480:	701a      	strb	r2, [r3, #0]
 8005482:	e002      	b.n	800548a <sdc_detect_bus_clk+0xea>
    }
    else {
      *clk = SDC_CLK_25MHz;
 8005484:	683b      	ldr	r3, [r7, #0]
 8005486:	2200      	movs	r2, #0
 8005488:	701a      	strb	r2, [r3, #0]
    }
  }

  return HAL_SUCCESS;
 800548a:	2300      	movs	r3, #0
 800548c:	46b5      	mov	sp, r6
}
 800548e:	4618      	mov	r0, r3
 8005490:	371c      	adds	r7, #28
 8005492:	46bd      	mov	sp, r7
 8005494:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005496:	bf00      	nop
 8005498:	f3af 8000 	nop.w
 800549c:	f3af 8000 	nop.w

080054a0 <mmc_detect_bus_clk>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool mmc_detect_bus_clk(SDCDriver *sdcp, sdcbusclk_t *clk) {
 80054a0:	b500      	push	{lr}
 80054a2:	b087      	sub	sp, #28
 80054a4:	9001      	str	r0, [sp, #4]
 80054a6:	9100      	str	r1, [sp, #0]
  uint32_t cmdarg;
  uint32_t resp[1];
  uint8_t *scratchpad = sdcp->config->scratchpad;
 80054a8:	9b01      	ldr	r3, [sp, #4]
 80054aa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80054ac:	681b      	ldr	r3, [r3, #0]
 80054ae:	9305      	str	r3, [sp, #20]

  /* Safe default.*/
  *clk = SDC_CLK_25MHz;
 80054b0:	9b00      	ldr	r3, [sp, #0]
 80054b2:	2200      	movs	r2, #0
 80054b4:	701a      	strb	r2, [r3, #0]

  /* Use safe default when there is no space for data.*/
  if (NULL == scratchpad) {
 80054b6:	9b05      	ldr	r3, [sp, #20]
 80054b8:	2b00      	cmp	r3, #0
 80054ba:	d101      	bne.n	80054c0 <mmc_detect_bus_clk+0x20>
    return HAL_SUCCESS;
 80054bc:	2300      	movs	r3, #0
 80054be:	e01b      	b.n	80054f8 <mmc_detect_bus_clk+0x58>
  }

  cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 185, 1, 0);
 80054c0:	2003      	movs	r0, #3
 80054c2:	21b9      	movs	r1, #185	; 0xb9
 80054c4:	2201      	movs	r2, #1
 80054c6:	2300      	movs	r3, #0
 80054c8:	f7ff fee2 	bl	8005290 <mmc_cmd6_construct>
 80054cc:	9004      	str	r0, [sp, #16]
  if (!(sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 80054ce:	ab03      	add	r3, sp, #12
 80054d0:	9801      	ldr	r0, [sp, #4]
 80054d2:	2106      	movs	r1, #6
 80054d4:	9a04      	ldr	r2, [sp, #16]
 80054d6:	f004 fc43 	bl	8009d60 <sdc_lld_send_cmd_short_crc>
 80054da:	4603      	mov	r3, r0
 80054dc:	f083 0301 	eor.w	r3, r3, #1
 80054e0:	b2db      	uxtb	r3, r3
 80054e2:	2b00      	cmp	r3, #0
 80054e4:	d007      	beq.n	80054f6 <mmc_detect_bus_clk+0x56>
                                   MMCSD_R1_ERROR(resp[0]))) {
 80054e6:	9a03      	ldr	r2, [sp, #12]
 80054e8:	4b05      	ldr	r3, [pc, #20]	; (8005500 <mmc_detect_bus_clk+0x60>)
 80054ea:	4013      	ands	r3, r2
  if (NULL == scratchpad) {
    return HAL_SUCCESS;
  }

  cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 185, 1, 0);
  if (!(sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 80054ec:	2b00      	cmp	r3, #0
 80054ee:	d102      	bne.n	80054f6 <mmc_detect_bus_clk+0x56>
                                   MMCSD_R1_ERROR(resp[0]))) {
    *clk = SDC_CLK_50MHz;
 80054f0:	9b00      	ldr	r3, [sp, #0]
 80054f2:	2201      	movs	r2, #1
 80054f4:	701a      	strb	r2, [r3, #0]
  }

  return HAL_SUCCESS;
 80054f6:	2300      	movs	r3, #0
}
 80054f8:	4618      	mov	r0, r3
 80054fa:	b007      	add	sp, #28
 80054fc:	f85d fb04 	ldr.w	pc, [sp], #4
 8005500:	fdffe008 	.word	0xfdffe008
 8005504:	f3af 8000 	nop.w
 8005508:	f3af 8000 	nop.w
 800550c:	f3af 8000 	nop.w

08005510 <detect_bus_clk>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool detect_bus_clk(SDCDriver *sdcp, sdcbusclk_t *clk) {
 8005510:	b500      	push	{lr}
 8005512:	b083      	sub	sp, #12
 8005514:	9001      	str	r0, [sp, #4]
 8005516:	9100      	str	r1, [sp, #0]

  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
 8005518:	9b01      	ldr	r3, [sp, #4]
 800551a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800551c:	f003 030f 	and.w	r3, r3, #15
 8005520:	2b02      	cmp	r3, #2
 8005522:	d105      	bne.n	8005530 <detect_bus_clk+0x20>
    return mmc_detect_bus_clk(sdcp, clk);
 8005524:	9801      	ldr	r0, [sp, #4]
 8005526:	9900      	ldr	r1, [sp, #0]
 8005528:	f7ff ffba 	bl	80054a0 <mmc_detect_bus_clk>
 800552c:	4603      	mov	r3, r0
 800552e:	e004      	b.n	800553a <detect_bus_clk+0x2a>
  }
  return sdc_detect_bus_clk(sdcp, clk);
 8005530:	9801      	ldr	r0, [sp, #4]
 8005532:	9900      	ldr	r1, [sp, #0]
 8005534:	f7ff ff34 	bl	80053a0 <sdc_detect_bus_clk>
 8005538:	4603      	mov	r3, r0
}
 800553a:	4618      	mov	r0, r3
 800553c:	b003      	add	sp, #12
 800553e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005542:	bf00      	nop
 8005544:	f3af 8000 	nop.w
 8005548:	f3af 8000 	nop.w
 800554c:	f3af 8000 	nop.w

08005550 <sdc_set_bus_width>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_set_bus_width(SDCDriver *sdcp) {
 8005550:	b500      	push	{lr}
 8005552:	b085      	sub	sp, #20
 8005554:	9001      	str	r0, [sp, #4]
  uint32_t resp[1];

  if (SDC_MODE_1BIT == sdcp->config->bus_width) {
 8005556:	9b01      	ldr	r3, [sp, #4]
 8005558:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800555a:	791b      	ldrb	r3, [r3, #4]
 800555c:	2b00      	cmp	r3, #0
 800555e:	d101      	bne.n	8005564 <sdc_set_bus_width+0x14>
    /* Nothing to do. Bus is already in 1bit mode.*/
    return HAL_SUCCESS;
 8005560:	2300      	movs	r3, #0
 8005562:	e02c      	b.n	80055be <sdc_set_bus_width+0x6e>
  }
  else if (SDC_MODE_4BIT == sdcp->config->bus_width) {
 8005564:	9b01      	ldr	r3, [sp, #4]
 8005566:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005568:	791b      	ldrb	r3, [r3, #4]
 800556a:	2b01      	cmp	r3, #1
 800556c:	d124      	bne.n	80055b8 <sdc_set_bus_width+0x68>
    sdc_lld_set_bus_mode(sdcp, SDC_MODE_4BIT);
 800556e:	9801      	ldr	r0, [sp, #4]
 8005570:	2101      	movs	r1, #1
 8005572:	f004 fb6d 	bl	8009c50 <sdc_lld_set_bus_mode>
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, sdcp->rca, resp) ||
 8005576:	9b01      	ldr	r3, [sp, #4]
 8005578:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800557a:	ab03      	add	r3, sp, #12
 800557c:	9801      	ldr	r0, [sp, #4]
 800557e:	2137      	movs	r1, #55	; 0x37
 8005580:	f004 fbee 	bl	8009d60 <sdc_lld_send_cmd_short_crc>
 8005584:	4603      	mov	r3, r0
 8005586:	2b00      	cmp	r3, #0
 8005588:	d104      	bne.n	8005594 <sdc_set_bus_width+0x44>
        MMCSD_R1_ERROR(resp[0])) {
 800558a:	9a03      	ldr	r2, [sp, #12]
 800558c:	4b0e      	ldr	r3, [pc, #56]	; (80055c8 <sdc_set_bus_width+0x78>)
 800558e:	4013      	ands	r3, r2
    /* Nothing to do. Bus is already in 1bit mode.*/
    return HAL_SUCCESS;
  }
  else if (SDC_MODE_4BIT == sdcp->config->bus_width) {
    sdc_lld_set_bus_mode(sdcp, SDC_MODE_4BIT);
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, sdcp->rca, resp) ||
 8005590:	2b00      	cmp	r3, #0
 8005592:	d001      	beq.n	8005598 <sdc_set_bus_width+0x48>
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
 8005594:	2301      	movs	r3, #1
 8005596:	e012      	b.n	80055be <sdc_set_bus_width+0x6e>
    }

    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BUS_WIDTH, 2, resp) ||
 8005598:	ab03      	add	r3, sp, #12
 800559a:	9801      	ldr	r0, [sp, #4]
 800559c:	2106      	movs	r1, #6
 800559e:	2202      	movs	r2, #2
 80055a0:	f004 fbde 	bl	8009d60 <sdc_lld_send_cmd_short_crc>
 80055a4:	4603      	mov	r3, r0
 80055a6:	2b00      	cmp	r3, #0
 80055a8:	d104      	bne.n	80055b4 <sdc_set_bus_width+0x64>
        MMCSD_R1_ERROR(resp[0])) {
 80055aa:	9a03      	ldr	r2, [sp, #12]
 80055ac:	4b06      	ldr	r3, [pc, #24]	; (80055c8 <sdc_set_bus_width+0x78>)
 80055ae:	4013      	ands	r3, r2
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, sdcp->rca, resp) ||
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
    }

    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BUS_WIDTH, 2, resp) ||
 80055b0:	2b00      	cmp	r3, #0
 80055b2:	d003      	beq.n	80055bc <sdc_set_bus_width+0x6c>
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
 80055b4:	2301      	movs	r3, #1
 80055b6:	e002      	b.n	80055be <sdc_set_bus_width+0x6e>
    }
  }
  else {
    /* SD card does not support 8bit bus.*/
    return HAL_FAILED;
 80055b8:	2301      	movs	r3, #1
 80055ba:	e000      	b.n	80055be <sdc_set_bus_width+0x6e>
  }

  return HAL_SUCCESS;
 80055bc:	2300      	movs	r3, #0
}
 80055be:	4618      	mov	r0, r3
 80055c0:	b005      	add	sp, #20
 80055c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80055c6:	bf00      	nop
 80055c8:	fdffe008 	.word	0xfdffe008
 80055cc:	f3af 8000 	nop.w

080055d0 <mmc_set_bus_width>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool mmc_set_bus_width(SDCDriver *sdcp) {
 80055d0:	b500      	push	{lr}
 80055d2:	b085      	sub	sp, #20
 80055d4:	9001      	str	r0, [sp, #4]
  uint32_t resp[1];
  uint32_t cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 0, 0);
 80055d6:	2003      	movs	r0, #3
 80055d8:	21b7      	movs	r1, #183	; 0xb7
 80055da:	2200      	movs	r2, #0
 80055dc:	2300      	movs	r3, #0
 80055de:	f7ff fe57 	bl	8005290 <mmc_cmd6_construct>
 80055e2:	9003      	str	r0, [sp, #12]

  switch(sdcp->config->bus_width){
 80055e4:	9b01      	ldr	r3, [sp, #4]
 80055e6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80055e8:	791b      	ldrb	r3, [r3, #4]
 80055ea:	2b01      	cmp	r3, #1
 80055ec:	d006      	beq.n	80055fc <mmc_set_bus_width+0x2c>
 80055ee:	2b02      	cmp	r3, #2
 80055f0:	d00c      	beq.n	800560c <mmc_set_bus_width+0x3c>
 80055f2:	2b00      	cmp	r3, #0
 80055f4:	d000      	beq.n	80055f8 <mmc_set_bus_width+0x28>
  case SDC_MODE_8BIT:
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 2, 0);
    break;
  default:
    osalDbgAssert(false, "unexpected case");
    break;
 80055f6:	e011      	b.n	800561c <mmc_set_bus_width+0x4c>
  uint32_t cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 0, 0);

  switch(sdcp->config->bus_width){
  case SDC_MODE_1BIT:
    /* Nothing to do. Bus is already in 1bit mode.*/
    return HAL_SUCCESS;
 80055f8:	2300      	movs	r3, #0
 80055fa:	e027      	b.n	800564c <mmc_set_bus_width+0x7c>
  case SDC_MODE_4BIT:
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 1, 0);
 80055fc:	2003      	movs	r0, #3
 80055fe:	21b7      	movs	r1, #183	; 0xb7
 8005600:	2201      	movs	r2, #1
 8005602:	2300      	movs	r3, #0
 8005604:	f7ff fe44 	bl	8005290 <mmc_cmd6_construct>
 8005608:	9003      	str	r0, [sp, #12]
    break;
 800560a:	e007      	b.n	800561c <mmc_set_bus_width+0x4c>
  case SDC_MODE_8BIT:
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 2, 0);
 800560c:	2003      	movs	r0, #3
 800560e:	21b7      	movs	r1, #183	; 0xb7
 8005610:	2202      	movs	r2, #2
 8005612:	2300      	movs	r3, #0
 8005614:	f7ff fe3c 	bl	8005290 <mmc_cmd6_construct>
 8005618:	9003      	str	r0, [sp, #12]
    break;
 800561a:	bf00      	nop
  default:
    osalDbgAssert(false, "unexpected case");
    break;
  }

  sdc_lld_set_bus_mode(sdcp, sdcp->config->bus_width);
 800561c:	9b01      	ldr	r3, [sp, #4]
 800561e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005620:	791b      	ldrb	r3, [r3, #4]
 8005622:	9801      	ldr	r0, [sp, #4]
 8005624:	4619      	mov	r1, r3
 8005626:	f004 fb13 	bl	8009c50 <sdc_lld_set_bus_mode>
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 800562a:	ab02      	add	r3, sp, #8
 800562c:	9801      	ldr	r0, [sp, #4]
 800562e:	2106      	movs	r1, #6
 8005630:	9a03      	ldr	r2, [sp, #12]
 8005632:	f004 fb95 	bl	8009d60 <sdc_lld_send_cmd_short_crc>
 8005636:	4603      	mov	r3, r0
 8005638:	2b00      	cmp	r3, #0
 800563a:	d104      	bne.n	8005646 <mmc_set_bus_width+0x76>
      MMCSD_R1_ERROR(resp[0])) {
 800563c:	9a02      	ldr	r2, [sp, #8]
 800563e:	4b05      	ldr	r3, [pc, #20]	; (8005654 <mmc_set_bus_width+0x84>)
 8005640:	4013      	ands	r3, r2
    osalDbgAssert(false, "unexpected case");
    break;
  }

  sdc_lld_set_bus_mode(sdcp, sdcp->config->bus_width);
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 8005642:	2b00      	cmp	r3, #0
 8005644:	d001      	beq.n	800564a <mmc_set_bus_width+0x7a>
      MMCSD_R1_ERROR(resp[0])) {
    return HAL_FAILED;
 8005646:	2301      	movs	r3, #1
 8005648:	e000      	b.n	800564c <mmc_set_bus_width+0x7c>
  }

  return HAL_SUCCESS;
 800564a:	2300      	movs	r3, #0
}
 800564c:	4618      	mov	r0, r3
 800564e:	b005      	add	sp, #20
 8005650:	f85d fb04 	ldr.w	pc, [sp], #4
 8005654:	fdffe008 	.word	0xfdffe008
 8005658:	f3af 8000 	nop.w
 800565c:	f3af 8000 	nop.w

08005660 <_sdc_wait_for_transfer_state>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool _sdc_wait_for_transfer_state(SDCDriver *sdcp) {
 8005660:	b500      	push	{lr}
 8005662:	b085      	sub	sp, #20
 8005664:	9001      	str	r0, [sp, #4]
  uint32_t resp[1];

  while (true) {
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_STATUS,
 8005666:	9b01      	ldr	r3, [sp, #4]
 8005668:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800566a:	ab03      	add	r3, sp, #12
 800566c:	9801      	ldr	r0, [sp, #4]
 800566e:	210d      	movs	r1, #13
 8005670:	f004 fb76 	bl	8009d60 <sdc_lld_send_cmd_short_crc>
 8005674:	4603      	mov	r3, r0
 8005676:	2b00      	cmp	r3, #0
 8005678:	d104      	bne.n	8005684 <_sdc_wait_for_transfer_state+0x24>
                                   sdcp->rca, resp) ||
        MMCSD_R1_ERROR(resp[0])) {
 800567a:	9a03      	ldr	r2, [sp, #12]
 800567c:	4b0d      	ldr	r3, [pc, #52]	; (80056b4 <_sdc_wait_for_transfer_state+0x54>)
 800567e:	4013      	ands	r3, r2
bool _sdc_wait_for_transfer_state(SDCDriver *sdcp) {
  uint32_t resp[1];

  while (true) {
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_STATUS,
                                   sdcp->rca, resp) ||
 8005680:	2b00      	cmp	r3, #0
 8005682:	d001      	beq.n	8005688 <_sdc_wait_for_transfer_state+0x28>
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
 8005684:	2301      	movs	r3, #1
 8005686:	e011      	b.n	80056ac <_sdc_wait_for_transfer_state+0x4c>
    }

    switch (MMCSD_R1_STS(resp[0])) {
 8005688:	9b03      	ldr	r3, [sp, #12]
 800568a:	0a5b      	lsrs	r3, r3, #9
 800568c:	f003 030f 	and.w	r3, r3, #15
 8005690:	2b04      	cmp	r3, #4
 8005692:	d004      	beq.n	800569e <_sdc_wait_for_transfer_state+0x3e>
 8005694:	2b04      	cmp	r3, #4
 8005696:	d308      	bcc.n	80056aa <_sdc_wait_for_transfer_state+0x4a>
 8005698:	2b07      	cmp	r3, #7
 800569a:	d806      	bhi.n	80056aa <_sdc_wait_for_transfer_state+0x4a>
 800569c:	e001      	b.n	80056a2 <_sdc_wait_for_transfer_state+0x42>
    case MMCSD_STS_TRAN:
      return HAL_SUCCESS;
 800569e:	2300      	movs	r3, #0
 80056a0:	e004      	b.n	80056ac <_sdc_wait_for_transfer_state+0x4c>
    case MMCSD_STS_DATA:
    case MMCSD_STS_RCV:
    case MMCSD_STS_PRG:
#if SDC_NICE_WAITING == TRUE
      osalThreadSleepMilliseconds(1);
 80056a2:	2001      	movs	r0, #1
 80056a4:	f7ff fd04 	bl	80050b0 <osalThreadSleep>
    default:
      /* The card should have been initialized so any other state is not
         valid and is reported as an error.*/
      return HAL_FAILED;
    }
  }
 80056a8:	e7dd      	b.n	8005666 <_sdc_wait_for_transfer_state+0x6>
#endif
      continue;
    default:
      /* The card should have been initialized so any other state is not
         valid and is reported as an error.*/
      return HAL_FAILED;
 80056aa:	2301      	movs	r3, #1
    }
  }
}
 80056ac:	4618      	mov	r0, r3
 80056ae:	b005      	add	sp, #20
 80056b0:	f85d fb04 	ldr.w	pc, [sp], #4
 80056b4:	fdffe008 	.word	0xfdffe008
 80056b8:	f3af 8000 	nop.w
 80056bc:	f3af 8000 	nop.w

080056c0 <sdcInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdcInit(void) {
 80056c0:	b508      	push	{r3, lr}

  sdc_lld_init();
 80056c2:	f004 f9f5 	bl	8009ab0 <sdc_lld_init>
}
 80056c6:	bd08      	pop	{r3, pc}
 80056c8:	f3af 8000 	nop.w
 80056cc:	f3af 8000 	nop.w

080056d0 <sdcObjectInit>:
 *
 * @param[out] sdcp     pointer to the @p SDCDriver object
 *
 * @init
 */
void sdcObjectInit(SDCDriver *sdcp) {
 80056d0:	b082      	sub	sp, #8
 80056d2:	9001      	str	r0, [sp, #4]

  sdcp->vmt      = &sdc_vmt;
 80056d4:	9b01      	ldr	r3, [sp, #4]
 80056d6:	4a08      	ldr	r2, [pc, #32]	; (80056f8 <sdcObjectInit+0x28>)
 80056d8:	601a      	str	r2, [r3, #0]
  sdcp->state    = BLK_STOP;
 80056da:	9b01      	ldr	r3, [sp, #4]
 80056dc:	2201      	movs	r2, #1
 80056de:	711a      	strb	r2, [r3, #4]
  sdcp->errors   = SDC_NO_ERROR;
 80056e0:	9b01      	ldr	r3, [sp, #4]
 80056e2:	2200      	movs	r2, #0
 80056e4:	635a      	str	r2, [r3, #52]	; 0x34
  sdcp->config   = NULL;
 80056e6:	9b01      	ldr	r3, [sp, #4]
 80056e8:	2200      	movs	r2, #0
 80056ea:	62da      	str	r2, [r3, #44]	; 0x2c
  sdcp->capacity = 0;
 80056ec:	9b01      	ldr	r3, [sp, #4]
 80056ee:	2200      	movs	r2, #0
 80056f0:	629a      	str	r2, [r3, #40]	; 0x28
}
 80056f2:	b002      	add	sp, #8
 80056f4:	4770      	bx	lr
 80056f6:	bf00      	nop
 80056f8:	08015f40 	.word	0x08015f40
 80056fc:	f3af 8000 	nop.w

08005700 <sdcStart>:
 *                      the driver supports a default configuration or
 *                      requires no configuration
 *
 * @api
 */
void sdcStart(SDCDriver *sdcp, const SDCConfig *config) {
 8005700:	b500      	push	{lr}
 8005702:	b083      	sub	sp, #12
 8005704:	9001      	str	r0, [sp, #4]
 8005706:	9100      	str	r1, [sp, #0]

  osalDbgCheck(sdcp != NULL);

  osalSysLock();
 8005708:	f7ff fcc2 	bl	8005090 <osalSysLock>
  osalDbgAssert((sdcp->state == BLK_STOP) || (sdcp->state == BLK_ACTIVE),
                "invalid state");
  sdcp->config = config;
 800570c:	9b01      	ldr	r3, [sp, #4]
 800570e:	9a00      	ldr	r2, [sp, #0]
 8005710:	62da      	str	r2, [r3, #44]	; 0x2c
  sdc_lld_start(sdcp);
 8005712:	9801      	ldr	r0, [sp, #4]
 8005714:	f004 f9e4 	bl	8009ae0 <sdc_lld_start>
  sdcp->state = BLK_ACTIVE;
 8005718:	9b01      	ldr	r3, [sp, #4]
 800571a:	2202      	movs	r2, #2
 800571c:	711a      	strb	r2, [r3, #4]
  osalSysUnlock();
 800571e:	f7ff fcbf 	bl	80050a0 <osalSysUnlock>
}
 8005722:	b003      	add	sp, #12
 8005724:	f85d fb04 	ldr.w	pc, [sp], #4
 8005728:	f3af 8000 	nop.w
 800572c:	f3af 8000 	nop.w

08005730 <sdcStop>:
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 *
 * @api
 */
void sdcStop(SDCDriver *sdcp) {
 8005730:	b500      	push	{lr}
 8005732:	b083      	sub	sp, #12
 8005734:	9001      	str	r0, [sp, #4]

  osalDbgCheck(sdcp != NULL);

  osalSysLock();
 8005736:	f7ff fcab 	bl	8005090 <osalSysLock>
  osalDbgAssert((sdcp->state == BLK_STOP) || (sdcp->state == BLK_ACTIVE),
                "invalid state");
  sdc_lld_stop(sdcp);
 800573a:	9801      	ldr	r0, [sp, #4]
 800573c:	f004 fa18 	bl	8009b70 <sdc_lld_stop>
  sdcp->state = BLK_STOP;
 8005740:	9b01      	ldr	r3, [sp, #4]
 8005742:	2201      	movs	r2, #1
 8005744:	711a      	strb	r2, [r3, #4]
  osalSysUnlock();
 8005746:	f7ff fcab 	bl	80050a0 <osalSysUnlock>
}
 800574a:	b003      	add	sp, #12
 800574c:	f85d fb04 	ldr.w	pc, [sp], #4

08005750 <sdcConnect>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcConnect(SDCDriver *sdcp) {
 8005750:	b500      	push	{lr}
 8005752:	b089      	sub	sp, #36	; 0x24
 8005754:	9003      	str	r0, [sp, #12]
  uint32_t resp[1];
  sdcbusclk_t clk = SDC_CLK_25MHz;
 8005756:	2300      	movs	r3, #0
 8005758:	f88d 3017 	strb.w	r3, [sp, #23]
  osalDbgCheck(sdcp != NULL);
  osalDbgAssert((sdcp->state == BLK_ACTIVE) || (sdcp->state == BLK_READY),
                "invalid state");

  /* Connection procedure in progress.*/
  sdcp->state = BLK_CONNECTING;
 800575c:	9b03      	ldr	r3, [sp, #12]
 800575e:	2203      	movs	r2, #3
 8005760:	711a      	strb	r2, [r3, #4]

  /* Card clock initialization.*/
  sdc_lld_start_clk(sdcp);
 8005762:	9803      	ldr	r0, [sp, #12]
 8005764:	f004 fa34 	bl	8009bd0 <sdc_lld_start_clk>

  /* Enforces the initial card state.*/
  sdc_lld_send_cmd_none(sdcp, MMCSD_CMD_GO_IDLE_STATE, 0);
 8005768:	9803      	ldr	r0, [sp, #12]
 800576a:	2100      	movs	r1, #0
 800576c:	2200      	movs	r2, #0
 800576e:	f004 fa97 	bl	8009ca0 <sdc_lld_send_cmd_none>

  /* Detect card type.*/
  if (HAL_FAILED == mode_detect(sdcp)) {
 8005772:	9803      	ldr	r0, [sp, #12]
 8005774:	f7ff fcac 	bl	80050d0 <mode_detect>
 8005778:	4603      	mov	r3, r0
 800577a:	2b00      	cmp	r3, #0
 800577c:	d000      	beq.n	8005780 <sdcConnect+0x30>
    goto failed;
 800577e:	e0ba      	b.n	80058f6 <sdcConnect+0x1a6>
  }

  /* Perform specific initialization procedure.*/
  if ((sdcp->cardmode &  SDC_MODE_CARDTYPE_MASK) == SDC_MODE_CARDTYPE_MMC) {
 8005780:	9b03      	ldr	r3, [sp, #12]
 8005782:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005784:	f003 030f 	and.w	r3, r3, #15
 8005788:	2b02      	cmp	r3, #2
 800578a:	d106      	bne.n	800579a <sdcConnect+0x4a>
    if (HAL_FAILED == mmc_init(sdcp)) {
 800578c:	9803      	ldr	r0, [sp, #12]
 800578e:	f7ff fcef 	bl	8005170 <mmc_init>
 8005792:	4603      	mov	r3, r0
 8005794:	2b00      	cmp	r3, #0
 8005796:	d007      	beq.n	80057a8 <sdcConnect+0x58>
      goto failed;
 8005798:	e0ad      	b.n	80058f6 <sdcConnect+0x1a6>
    }
  }
  else {
    if (HAL_FAILED == sdc_init(sdcp)) {
 800579a:	9803      	ldr	r0, [sp, #12]
 800579c:	f7ff fd20 	bl	80051e0 <sdc_init>
 80057a0:	4603      	mov	r3, r0
 80057a2:	2b00      	cmp	r3, #0
 80057a4:	d000      	beq.n	80057a8 <sdcConnect+0x58>
      goto failed;
 80057a6:	e0a6      	b.n	80058f6 <sdcConnect+0x1a6>
    }
  }

  /* Reads CID.*/
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_ALL_SEND_CID, 0, sdcp->cid)) {
 80057a8:	9b03      	ldr	r3, [sp, #12]
 80057aa:	3308      	adds	r3, #8
 80057ac:	9803      	ldr	r0, [sp, #12]
 80057ae:	2102      	movs	r1, #2
 80057b0:	2200      	movs	r2, #0
 80057b2:	f004 fb15 	bl	8009de0 <sdc_lld_send_cmd_long_crc>
 80057b6:	4603      	mov	r3, r0
 80057b8:	2b00      	cmp	r3, #0
 80057ba:	d000      	beq.n	80057be <sdcConnect+0x6e>
    goto failed;
 80057bc:	e09b      	b.n	80058f6 <sdcConnect+0x1a6>
  }

  /* Asks for the RCA.*/
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_RELATIVE_ADDR,
 80057be:	9b03      	ldr	r3, [sp, #12]
 80057c0:	3338      	adds	r3, #56	; 0x38
 80057c2:	9803      	ldr	r0, [sp, #12]
 80057c4:	2103      	movs	r1, #3
 80057c6:	2200      	movs	r2, #0
 80057c8:	f004 faca 	bl	8009d60 <sdc_lld_send_cmd_short_crc>
 80057cc:	4603      	mov	r3, r0
 80057ce:	2b00      	cmp	r3, #0
 80057d0:	d000      	beq.n	80057d4 <sdcConnect+0x84>
                                 0, &sdcp->rca)) {
    goto failed;
 80057d2:	e090      	b.n	80058f6 <sdcConnect+0x1a6>
  }

  /* Reads CSD.*/
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_SEND_CSD,
 80057d4:	9b03      	ldr	r3, [sp, #12]
 80057d6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
                                sdcp->rca, sdcp->csd)) {
 80057d8:	9b03      	ldr	r3, [sp, #12]
 80057da:	3318      	adds	r3, #24
                                 0, &sdcp->rca)) {
    goto failed;
  }

  /* Reads CSD.*/
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_SEND_CSD,
 80057dc:	9803      	ldr	r0, [sp, #12]
 80057de:	2109      	movs	r1, #9
 80057e0:	f004 fafe 	bl	8009de0 <sdc_lld_send_cmd_long_crc>
 80057e4:	4603      	mov	r3, r0
 80057e6:	2b00      	cmp	r3, #0
 80057e8:	d000      	beq.n	80057ec <sdcConnect+0x9c>
                                sdcp->rca, sdcp->csd)) {
    goto failed;
 80057ea:	e084      	b.n	80058f6 <sdcConnect+0x1a6>
  }

  /* Selects the card for operations.*/
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEL_DESEL_CARD,
 80057ec:	9b03      	ldr	r3, [sp, #12]
 80057ee:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80057f0:	ab06      	add	r3, sp, #24
 80057f2:	9803      	ldr	r0, [sp, #12]
 80057f4:	2107      	movs	r1, #7
 80057f6:	f004 fab3 	bl	8009d60 <sdc_lld_send_cmd_short_crc>
 80057fa:	4603      	mov	r3, r0
 80057fc:	2b00      	cmp	r3, #0
 80057fe:	d000      	beq.n	8005802 <sdcConnect+0xb2>
                                 sdcp->rca, resp)) {
    goto failed;
 8005800:	e079      	b.n	80058f6 <sdcConnect+0x1a6>
  }

  /* Switches to high speed.*/
  if (HAL_SUCCESS != detect_bus_clk(sdcp, &clk)) {
 8005802:	f10d 0317 	add.w	r3, sp, #23
 8005806:	9803      	ldr	r0, [sp, #12]
 8005808:	4619      	mov	r1, r3
 800580a:	f7ff fe81 	bl	8005510 <detect_bus_clk>
 800580e:	4603      	mov	r3, r0
 8005810:	2b00      	cmp	r3, #0
 8005812:	d000      	beq.n	8005816 <sdcConnect+0xc6>
    goto failed;
 8005814:	e06f      	b.n	80058f6 <sdcConnect+0x1a6>
  }
  sdc_lld_set_data_clk(sdcp, clk);
 8005816:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800581a:	9803      	ldr	r0, [sp, #12]
 800581c:	4619      	mov	r1, r3
 800581e:	f004 f9f7 	bl	8009c10 <sdc_lld_set_data_clk>

  /* Reads extended CSD if needed and possible.*/
  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
 8005822:	9b03      	ldr	r3, [sp, #12]
 8005824:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005826:	f003 030f 	and.w	r3, r3, #15
 800582a:	2b02      	cmp	r3, #2
 800582c:	d12e      	bne.n	800588c <sdcConnect+0x13c>

    /* The card is a MMC, checking if it is a large device.*/
    if (_mmcsd_get_slice(sdcp->csd, MMCSD_CSD_MMC_CSD_STRUCTURE_SLICE) > 1U) {
 800582e:	9b03      	ldr	r3, [sp, #12]
 8005830:	3318      	adds	r3, #24
 8005832:	4618      	mov	r0, r3
 8005834:	217f      	movs	r1, #127	; 0x7f
 8005836:	227e      	movs	r2, #126	; 0x7e
 8005838:	f7fe ff1a 	bl	8004670 <_mmcsd_get_slice>
 800583c:	4603      	mov	r3, r0
 800583e:	2b01      	cmp	r3, #1
 8005840:	d91b      	bls.n	800587a <sdcConnect+0x12a>
      uint8_t *ext_csd = sdcp->config->scratchpad;
 8005842:	9b03      	ldr	r3, [sp, #12]
 8005844:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005846:	681b      	ldr	r3, [r3, #0]
 8005848:	9307      	str	r3, [sp, #28]

      /* Size detection requires the buffer.*/
      if (NULL == ext_csd) {
 800584a:	9b07      	ldr	r3, [sp, #28]
 800584c:	2b00      	cmp	r3, #0
 800584e:	d100      	bne.n	8005852 <sdcConnect+0x102>
        goto failed;
 8005850:	e051      	b.n	80058f6 <sdcConnect+0x1a6>
      }

      if(sdc_lld_read_special(sdcp, ext_csd, 512, MMCSD_CMD_SEND_EXT_CSD, 0)) {
 8005852:	2300      	movs	r3, #0
 8005854:	9300      	str	r3, [sp, #0]
 8005856:	9803      	ldr	r0, [sp, #12]
 8005858:	9907      	ldr	r1, [sp, #28]
 800585a:	f44f 7200 	mov.w	r2, #512	; 0x200
 800585e:	2308      	movs	r3, #8
 8005860:	f004 fb0e 	bl	8009e80 <sdc_lld_read_special>
 8005864:	4603      	mov	r3, r0
 8005866:	2b00      	cmp	r3, #0
 8005868:	d000      	beq.n	800586c <sdcConnect+0x11c>
        goto failed;
 800586a:	e044      	b.n	80058f6 <sdcConnect+0x1a6>
      }

      /* Capacity from the EXT_CSD.*/
      sdcp->capacity = _mmcsd_get_capacity_ext(ext_csd);
 800586c:	9807      	ldr	r0, [sp, #28]
 800586e:	f7fe ff77 	bl	8004760 <_mmcsd_get_capacity_ext>
 8005872:	4602      	mov	r2, r0
 8005874:	9b03      	ldr	r3, [sp, #12]
 8005876:	629a      	str	r2, [r3, #40]	; 0x28
 8005878:	e010      	b.n	800589c <sdcConnect+0x14c>
    }
    else {
      /* Capacity from the normal CSD.*/
      sdcp->capacity = _mmcsd_get_capacity(sdcp->csd);
 800587a:	9b03      	ldr	r3, [sp, #12]
 800587c:	3318      	adds	r3, #24
 800587e:	4618      	mov	r0, r3
 8005880:	f7fe ff36 	bl	80046f0 <_mmcsd_get_capacity>
 8005884:	4602      	mov	r2, r0
 8005886:	9b03      	ldr	r3, [sp, #12]
 8005888:	629a      	str	r2, [r3, #40]	; 0x28
 800588a:	e007      	b.n	800589c <sdcConnect+0x14c>
    }
  }
  else {
    /* The card is an SDC, capacity from the normal CSD.*/
    sdcp->capacity = _mmcsd_get_capacity(sdcp->csd);
 800588c:	9b03      	ldr	r3, [sp, #12]
 800588e:	3318      	adds	r3, #24
 8005890:	4618      	mov	r0, r3
 8005892:	f7fe ff2d 	bl	80046f0 <_mmcsd_get_capacity>
 8005896:	4602      	mov	r2, r0
 8005898:	9b03      	ldr	r3, [sp, #12]
 800589a:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Block length fixed at 512 bytes.*/
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BLOCKLEN,
 800589c:	ab06      	add	r3, sp, #24
 800589e:	9803      	ldr	r0, [sp, #12]
 80058a0:	2110      	movs	r1, #16
 80058a2:	f44f 7200 	mov.w	r2, #512	; 0x200
 80058a6:	f004 fa5b 	bl	8009d60 <sdc_lld_send_cmd_short_crc>
 80058aa:	4603      	mov	r3, r0
 80058ac:	2b00      	cmp	r3, #0
 80058ae:	d122      	bne.n	80058f6 <sdcConnect+0x1a6>
                                 MMCSD_BLOCK_SIZE, resp) ||
      MMCSD_R1_ERROR(resp[0])) {
 80058b0:	9a06      	ldr	r2, [sp, #24]
 80058b2:	4b16      	ldr	r3, [pc, #88]	; (800590c <sdcConnect+0x1bc>)
 80058b4:	4013      	ands	r3, r2
    sdcp->capacity = _mmcsd_get_capacity(sdcp->csd);
  }

  /* Block length fixed at 512 bytes.*/
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BLOCKLEN,
                                 MMCSD_BLOCK_SIZE, resp) ||
 80058b6:	2b00      	cmp	r3, #0
 80058b8:	d11d      	bne.n	80058f6 <sdcConnect+0x1a6>
      MMCSD_R1_ERROR(resp[0])) {
    goto failed;
  }

  /* Switches to wide bus mode.*/
  switch (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK) {
 80058ba:	9b03      	ldr	r3, [sp, #12]
 80058bc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80058be:	f003 030f 	and.w	r3, r3, #15
 80058c2:	2b01      	cmp	r3, #1
 80058c4:	d902      	bls.n	80058cc <sdcConnect+0x17c>
 80058c6:	2b02      	cmp	r3, #2
 80058c8:	d008      	beq.n	80058dc <sdcConnect+0x18c>
      goto failed;
    }
    break;
  default:
    /* Unknown type.*/
    goto failed;
 80058ca:	e014      	b.n	80058f6 <sdcConnect+0x1a6>

  /* Switches to wide bus mode.*/
  switch (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK) {
  case SDC_MODE_CARDTYPE_SDV11:
  case SDC_MODE_CARDTYPE_SDV20:
    if (HAL_FAILED == sdc_set_bus_width(sdcp)) {
 80058cc:	9803      	ldr	r0, [sp, #12]
 80058ce:	f7ff fe3f 	bl	8005550 <sdc_set_bus_width>
 80058d2:	4603      	mov	r3, r0
 80058d4:	2b00      	cmp	r3, #0
 80058d6:	d000      	beq.n	80058da <sdcConnect+0x18a>
      goto failed;
 80058d8:	e00d      	b.n	80058f6 <sdcConnect+0x1a6>
    }
    break;
 80058da:	e007      	b.n	80058ec <sdcConnect+0x19c>
  case SDC_MODE_CARDTYPE_MMC:
    if (HAL_FAILED == mmc_set_bus_width(sdcp)) {
 80058dc:	9803      	ldr	r0, [sp, #12]
 80058de:	f7ff fe77 	bl	80055d0 <mmc_set_bus_width>
 80058e2:	4603      	mov	r3, r0
 80058e4:	2b00      	cmp	r3, #0
 80058e6:	d000      	beq.n	80058ea <sdcConnect+0x19a>
      goto failed;
 80058e8:	e005      	b.n	80058f6 <sdcConnect+0x1a6>
    }
    break;
 80058ea:	bf00      	nop
    /* Unknown type.*/
    goto failed;
  }

  /* Initialization complete.*/
  sdcp->state = BLK_READY;
 80058ec:	9b03      	ldr	r3, [sp, #12]
 80058ee:	2205      	movs	r2, #5
 80058f0:	711a      	strb	r2, [r3, #4]
  return HAL_SUCCESS;
 80058f2:	2300      	movs	r3, #0
 80058f4:	e006      	b.n	8005904 <sdcConnect+0x1b4>

  /* Connection failed, state reset to BLK_ACTIVE.*/
failed:
  sdc_lld_stop_clk(sdcp);
 80058f6:	9803      	ldr	r0, [sp, #12]
 80058f8:	f004 f99a 	bl	8009c30 <sdc_lld_stop_clk>
  sdcp->state = BLK_ACTIVE;
 80058fc:	9b03      	ldr	r3, [sp, #12]
 80058fe:	2202      	movs	r2, #2
 8005900:	711a      	strb	r2, [r3, #4]
  return HAL_FAILED;
 8005902:	2301      	movs	r3, #1
}
 8005904:	4618      	mov	r0, r3
 8005906:	b009      	add	sp, #36	; 0x24
 8005908:	f85d fb04 	ldr.w	pc, [sp], #4
 800590c:	fdffe008 	.word	0xfdffe008

08005910 <sdcDisconnect>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcDisconnect(SDCDriver *sdcp) {
 8005910:	b500      	push	{lr}
 8005912:	b083      	sub	sp, #12
 8005914:	9001      	str	r0, [sp, #4]

  osalDbgCheck(sdcp != NULL);

  osalSysLock();
 8005916:	f7ff fbbb 	bl	8005090 <osalSysLock>
  osalDbgAssert((sdcp->state == BLK_ACTIVE) || (sdcp->state == BLK_READY),
                "invalid state");
  if (sdcp->state == BLK_ACTIVE) {
 800591a:	9b01      	ldr	r3, [sp, #4]
 800591c:	791b      	ldrb	r3, [r3, #4]
 800591e:	2b02      	cmp	r3, #2
 8005920:	d103      	bne.n	800592a <sdcDisconnect+0x1a>
    osalSysUnlock();
 8005922:	f7ff fbbd 	bl	80050a0 <osalSysUnlock>
    return HAL_SUCCESS;
 8005926:	2300      	movs	r3, #0
 8005928:	e019      	b.n	800595e <sdcDisconnect+0x4e>
  }
  sdcp->state = BLK_DISCONNECTING;
 800592a:	9b01      	ldr	r3, [sp, #4]
 800592c:	2204      	movs	r2, #4
 800592e:	711a      	strb	r2, [r3, #4]
  osalSysUnlock();
 8005930:	f7ff fbb6 	bl	80050a0 <osalSysUnlock>

  /* Waits for eventual pending operations completion.*/
  if (_sdc_wait_for_transfer_state(sdcp)) {
 8005934:	9801      	ldr	r0, [sp, #4]
 8005936:	f7ff fe93 	bl	8005660 <_sdc_wait_for_transfer_state>
 800593a:	4603      	mov	r3, r0
 800593c:	2b00      	cmp	r3, #0
 800593e:	d007      	beq.n	8005950 <sdcDisconnect+0x40>
    sdc_lld_stop_clk(sdcp);
 8005940:	9801      	ldr	r0, [sp, #4]
 8005942:	f004 f975 	bl	8009c30 <sdc_lld_stop_clk>
    sdcp->state = BLK_ACTIVE;
 8005946:	9b01      	ldr	r3, [sp, #4]
 8005948:	2202      	movs	r2, #2
 800594a:	711a      	strb	r2, [r3, #4]
    return HAL_FAILED;
 800594c:	2301      	movs	r3, #1
 800594e:	e006      	b.n	800595e <sdcDisconnect+0x4e>
  }

  /* Card clock stopped.*/
  sdc_lld_stop_clk(sdcp);
 8005950:	9801      	ldr	r0, [sp, #4]
 8005952:	f004 f96d 	bl	8009c30 <sdc_lld_stop_clk>
  sdcp->state = BLK_ACTIVE;
 8005956:	9b01      	ldr	r3, [sp, #4]
 8005958:	2202      	movs	r2, #2
 800595a:	711a      	strb	r2, [r3, #4]
  return HAL_SUCCESS;
 800595c:	2300      	movs	r3, #0
}
 800595e:	4618      	mov	r0, r3
 8005960:	b003      	add	sp, #12
 8005962:	f85d fb04 	ldr.w	pc, [sp], #4
 8005966:	bf00      	nop
 8005968:	f3af 8000 	nop.w
 800596c:	f3af 8000 	nop.w

08005970 <sdcRead>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcRead(SDCDriver *sdcp, uint32_t startblk, uint8_t *buf, uint32_t n) {
 8005970:	b500      	push	{lr}
 8005972:	b087      	sub	sp, #28
 8005974:	9003      	str	r0, [sp, #12]
 8005976:	9102      	str	r1, [sp, #8]
 8005978:	9201      	str	r2, [sp, #4]
 800597a:	9300      	str	r3, [sp, #0]
  bool status;

  osalDbgCheck((sdcp != NULL) && (buf != NULL) && (n > 0U));
  osalDbgAssert(sdcp->state == BLK_READY, "invalid state");

  if ((startblk + n - 1U) > sdcp->capacity){
 800597c:	9a02      	ldr	r2, [sp, #8]
 800597e:	9b00      	ldr	r3, [sp, #0]
 8005980:	4413      	add	r3, r2
 8005982:	1e5a      	subs	r2, r3, #1
 8005984:	9b03      	ldr	r3, [sp, #12]
 8005986:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005988:	429a      	cmp	r2, r3
 800598a:	d907      	bls.n	800599c <sdcRead+0x2c>
    sdcp->errors |= SDC_OVERFLOW_ERROR;
 800598c:	9b03      	ldr	r3, [sp, #12]
 800598e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005990:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 8005994:	9b03      	ldr	r3, [sp, #12]
 8005996:	635a      	str	r2, [r3, #52]	; 0x34
    return HAL_FAILED;
 8005998:	2301      	movs	r3, #1
 800599a:	e010      	b.n	80059be <sdcRead+0x4e>
  }

  /* Read operation in progress.*/
  sdcp->state = BLK_READING;
 800599c:	9b03      	ldr	r3, [sp, #12]
 800599e:	2206      	movs	r2, #6
 80059a0:	711a      	strb	r2, [r3, #4]

  status = sdc_lld_read(sdcp, startblk, buf, n);
 80059a2:	9803      	ldr	r0, [sp, #12]
 80059a4:	9902      	ldr	r1, [sp, #8]
 80059a6:	9a01      	ldr	r2, [sp, #4]
 80059a8:	9b00      	ldr	r3, [sp, #0]
 80059aa:	f004 fbb9 	bl	800a120 <sdc_lld_read>
 80059ae:	4603      	mov	r3, r0
 80059b0:	f88d 3017 	strb.w	r3, [sp, #23]

  /* Read operation finished.*/
  sdcp->state = BLK_READY;
 80059b4:	9b03      	ldr	r3, [sp, #12]
 80059b6:	2205      	movs	r2, #5
 80059b8:	711a      	strb	r2, [r3, #4]
  return status;
 80059ba:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
 80059be:	4618      	mov	r0, r3
 80059c0:	b007      	add	sp, #28
 80059c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80059c6:	bf00      	nop
 80059c8:	f3af 8000 	nop.w
 80059cc:	f3af 8000 	nop.w

080059d0 <sdcWrite>:
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcWrite(SDCDriver *sdcp, uint32_t startblk,
              const uint8_t *buf, uint32_t n) {
 80059d0:	b500      	push	{lr}
 80059d2:	b087      	sub	sp, #28
 80059d4:	9003      	str	r0, [sp, #12]
 80059d6:	9102      	str	r1, [sp, #8]
 80059d8:	9201      	str	r2, [sp, #4]
 80059da:	9300      	str	r3, [sp, #0]
  bool status;

  osalDbgCheck((sdcp != NULL) && (buf != NULL) && (n > 0U));
  osalDbgAssert(sdcp->state == BLK_READY, "invalid state");

  if ((startblk + n - 1U) > sdcp->capacity){
 80059dc:	9a02      	ldr	r2, [sp, #8]
 80059de:	9b00      	ldr	r3, [sp, #0]
 80059e0:	4413      	add	r3, r2
 80059e2:	1e5a      	subs	r2, r3, #1
 80059e4:	9b03      	ldr	r3, [sp, #12]
 80059e6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80059e8:	429a      	cmp	r2, r3
 80059ea:	d907      	bls.n	80059fc <sdcWrite+0x2c>
    sdcp->errors |= SDC_OVERFLOW_ERROR;
 80059ec:	9b03      	ldr	r3, [sp, #12]
 80059ee:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80059f0:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 80059f4:	9b03      	ldr	r3, [sp, #12]
 80059f6:	635a      	str	r2, [r3, #52]	; 0x34
    return HAL_FAILED;
 80059f8:	2301      	movs	r3, #1
 80059fa:	e010      	b.n	8005a1e <sdcWrite+0x4e>
  }

  /* Write operation in progress.*/
  sdcp->state = BLK_WRITING;
 80059fc:	9b03      	ldr	r3, [sp, #12]
 80059fe:	2207      	movs	r2, #7
 8005a00:	711a      	strb	r2, [r3, #4]

  status = sdc_lld_write(sdcp, startblk, buf, n);
 8005a02:	9803      	ldr	r0, [sp, #12]
 8005a04:	9902      	ldr	r1, [sp, #8]
 8005a06:	9a01      	ldr	r2, [sp, #4]
 8005a08:	9b00      	ldr	r3, [sp, #0]
 8005a0a:	f004 fbd1 	bl	800a1b0 <sdc_lld_write>
 8005a0e:	4603      	mov	r3, r0
 8005a10:	f88d 3017 	strb.w	r3, [sp, #23]

  /* Write operation finished.*/
  sdcp->state = BLK_READY;
 8005a14:	9b03      	ldr	r3, [sp, #12]
 8005a16:	2205      	movs	r2, #5
 8005a18:	711a      	strb	r2, [r3, #4]
  return status;
 8005a1a:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
 8005a1e:	4618      	mov	r0, r3
 8005a20:	b007      	add	sp, #28
 8005a22:	f85d fb04 	ldr.w	pc, [sp], #4
 8005a26:	bf00      	nop
 8005a28:	f3af 8000 	nop.w
 8005a2c:	f3af 8000 	nop.w

08005a30 <sdcGetAndClearErrors>:
 * @param[in] sdcp      pointer to the @p SDCDriver object
 * @return              The errors mask.
 *
 * @api
 */
sdcflags_t sdcGetAndClearErrors(SDCDriver *sdcp) {
 8005a30:	b500      	push	{lr}
 8005a32:	b085      	sub	sp, #20
 8005a34:	9001      	str	r0, [sp, #4]
  sdcflags_t flags;

  osalDbgCheck(sdcp != NULL);
  osalDbgAssert(sdcp->state == BLK_READY, "invalid state");

  osalSysLock();
 8005a36:	f7ff fb2b 	bl	8005090 <osalSysLock>
  flags = sdcp->errors;
 8005a3a:	9b01      	ldr	r3, [sp, #4]
 8005a3c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005a3e:	9303      	str	r3, [sp, #12]
  sdcp->errors = SDC_NO_ERROR;
 8005a40:	9b01      	ldr	r3, [sp, #4]
 8005a42:	2200      	movs	r2, #0
 8005a44:	635a      	str	r2, [r3, #52]	; 0x34
  osalSysUnlock();
 8005a46:	f7ff fb2b 	bl	80050a0 <osalSysUnlock>
  return flags;
 8005a4a:	9b03      	ldr	r3, [sp, #12]
}
 8005a4c:	4618      	mov	r0, r3
 8005a4e:	b005      	add	sp, #20
 8005a50:	f85d fb04 	ldr.w	pc, [sp], #4
 8005a54:	f3af 8000 	nop.w
 8005a58:	f3af 8000 	nop.w
 8005a5c:	f3af 8000 	nop.w

08005a60 <sdcSync>:
 * @retval HAL_SUCCESS  the operation succeeded.
 * @retval HAL_FAILED   the operation failed.
 *
 * @api
 */
bool sdcSync(SDCDriver *sdcp) {
 8005a60:	b500      	push	{lr}
 8005a62:	b085      	sub	sp, #20
 8005a64:	9001      	str	r0, [sp, #4]
  bool result;

  osalDbgCheck(sdcp != NULL);

  if (sdcp->state != BLK_READY) {
 8005a66:	9b01      	ldr	r3, [sp, #4]
 8005a68:	791b      	ldrb	r3, [r3, #4]
 8005a6a:	2b05      	cmp	r3, #5
 8005a6c:	d001      	beq.n	8005a72 <sdcSync+0x12>
    return HAL_FAILED;
 8005a6e:	2301      	movs	r3, #1
 8005a70:	e00d      	b.n	8005a8e <sdcSync+0x2e>
  }

  /* Synchronization operation in progress.*/
  sdcp->state = BLK_SYNCING;
 8005a72:	9b01      	ldr	r3, [sp, #4]
 8005a74:	2208      	movs	r2, #8
 8005a76:	711a      	strb	r2, [r3, #4]

  result = sdc_lld_sync(sdcp);
 8005a78:	9801      	ldr	r0, [sp, #4]
 8005a7a:	f004 fbe1 	bl	800a240 <sdc_lld_sync>
 8005a7e:	4603      	mov	r3, r0
 8005a80:	f88d 300f 	strb.w	r3, [sp, #15]

  /* Synchronization operation finished.*/
  sdcp->state = BLK_READY;
 8005a84:	9b01      	ldr	r3, [sp, #4]
 8005a86:	2205      	movs	r2, #5
 8005a88:	711a      	strb	r2, [r3, #4]
  return result;
 8005a8a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8005a8e:	4618      	mov	r0, r3
 8005a90:	b005      	add	sp, #20
 8005a92:	f85d fb04 	ldr.w	pc, [sp], #4
 8005a96:	bf00      	nop
 8005a98:	f3af 8000 	nop.w
 8005a9c:	f3af 8000 	nop.w

08005aa0 <sdcGetInfo>:
 * @retval HAL_SUCCESS  the operation succeeded.
 * @retval HAL_FAILED   the operation failed.
 *
 * @api
 */
bool sdcGetInfo(SDCDriver *sdcp, BlockDeviceInfo *bdip) {
 8005aa0:	b082      	sub	sp, #8
 8005aa2:	9001      	str	r0, [sp, #4]
 8005aa4:	9100      	str	r1, [sp, #0]

  osalDbgCheck((sdcp != NULL) && (bdip != NULL));

  if (sdcp->state != BLK_READY) {
 8005aa6:	9b01      	ldr	r3, [sp, #4]
 8005aa8:	791b      	ldrb	r3, [r3, #4]
 8005aaa:	2b05      	cmp	r3, #5
 8005aac:	d001      	beq.n	8005ab2 <sdcGetInfo+0x12>
    return HAL_FAILED;
 8005aae:	2301      	movs	r3, #1
 8005ab0:	e008      	b.n	8005ac4 <sdcGetInfo+0x24>
  }

  bdip->blk_num = sdcp->capacity;
 8005ab2:	9b01      	ldr	r3, [sp, #4]
 8005ab4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8005ab6:	9b00      	ldr	r3, [sp, #0]
 8005ab8:	605a      	str	r2, [r3, #4]
  bdip->blk_size = MMCSD_BLOCK_SIZE;
 8005aba:	9b00      	ldr	r3, [sp, #0]
 8005abc:	f44f 7200 	mov.w	r2, #512	; 0x200
 8005ac0:	601a      	str	r2, [r3, #0]

  return HAL_SUCCESS;
 8005ac2:	2300      	movs	r3, #0
}
 8005ac4:	4618      	mov	r0, r3
 8005ac6:	b002      	add	sp, #8
 8005ac8:	4770      	bx	lr
 8005aca:	bf00      	nop
 8005acc:	f3af 8000 	nop.w

08005ad0 <sdcErase>:
 * @retval HAL_SUCCESS  the operation succeeded.
 * @retval HAL_FAILED   the operation failed.
 *
 * @api
 */
bool sdcErase(SDCDriver *sdcp, uint32_t startblk, uint32_t endblk) {
 8005ad0:	b500      	push	{lr}
 8005ad2:	b087      	sub	sp, #28
 8005ad4:	9003      	str	r0, [sp, #12]
 8005ad6:	9102      	str	r1, [sp, #8]
 8005ad8:	9201      	str	r2, [sp, #4]

  osalDbgCheck((sdcp != NULL));
  osalDbgAssert(sdcp->state == BLK_READY, "invalid state");

  /* Erase operation in progress.*/
  sdcp->state = BLK_WRITING;
 8005ada:	9b03      	ldr	r3, [sp, #12]
 8005adc:	2207      	movs	r2, #7
 8005ade:	711a      	strb	r2, [r3, #4]

  /* Handling command differences between HC and normal cards.*/
  if ((sdcp->cardmode & SDC_MODE_HIGH_CAPACITY) != 0U) {
 8005ae0:	9b03      	ldr	r3, [sp, #12]
 8005ae2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005ae4:	f003 0310 	and.w	r3, r3, #16
 8005ae8:	2b00      	cmp	r3, #0
 8005aea:	d005      	beq.n	8005af8 <sdcErase+0x28>
    startblk *= MMCSD_BLOCK_SIZE;
 8005aec:	9b02      	ldr	r3, [sp, #8]
 8005aee:	025b      	lsls	r3, r3, #9
 8005af0:	9302      	str	r3, [sp, #8]
    endblk *= MMCSD_BLOCK_SIZE;
 8005af2:	9b01      	ldr	r3, [sp, #4]
 8005af4:	025b      	lsls	r3, r3, #9
 8005af6:	9301      	str	r3, [sp, #4]
  }

  if (_sdc_wait_for_transfer_state(sdcp)) {
 8005af8:	9803      	ldr	r0, [sp, #12]
 8005afa:	f7ff fdb1 	bl	8005660 <_sdc_wait_for_transfer_state>
 8005afe:	4603      	mov	r3, r0
 8005b00:	2b00      	cmp	r3, #0
 8005b02:	d000      	beq.n	8005b06 <sdcErase+0x36>
    goto failed;
 8005b04:	e035      	b.n	8005b72 <sdcErase+0xa2>
  }

  if ((sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_ERASE_RW_BLK_START,
 8005b06:	ab05      	add	r3, sp, #20
 8005b08:	9803      	ldr	r0, [sp, #12]
 8005b0a:	2120      	movs	r1, #32
 8005b0c:	9a02      	ldr	r2, [sp, #8]
 8005b0e:	f004 f927 	bl	8009d60 <sdc_lld_send_cmd_short_crc>
 8005b12:	4603      	mov	r3, r0
 8005b14:	2b00      	cmp	r3, #0
 8005b16:	d12c      	bne.n	8005b72 <sdcErase+0xa2>
                                  startblk, resp) != HAL_SUCCESS) ||
      MMCSD_R1_ERROR(resp[0])) {
 8005b18:	9a05      	ldr	r2, [sp, #20]
 8005b1a:	4b1a      	ldr	r3, [pc, #104]	; (8005b84 <sdcErase+0xb4>)
 8005b1c:	4013      	ands	r3, r2
  if (_sdc_wait_for_transfer_state(sdcp)) {
    goto failed;
  }

  if ((sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_ERASE_RW_BLK_START,
                                  startblk, resp) != HAL_SUCCESS) ||
 8005b1e:	2b00      	cmp	r3, #0
 8005b20:	d127      	bne.n	8005b72 <sdcErase+0xa2>
      MMCSD_R1_ERROR(resp[0])) {
    goto failed;
  }

  if ((sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_ERASE_RW_BLK_END,
 8005b22:	ab05      	add	r3, sp, #20
 8005b24:	9803      	ldr	r0, [sp, #12]
 8005b26:	2121      	movs	r1, #33	; 0x21
 8005b28:	9a01      	ldr	r2, [sp, #4]
 8005b2a:	f004 f919 	bl	8009d60 <sdc_lld_send_cmd_short_crc>
 8005b2e:	4603      	mov	r3, r0
 8005b30:	2b00      	cmp	r3, #0
 8005b32:	d11e      	bne.n	8005b72 <sdcErase+0xa2>
                                  endblk, resp) != HAL_SUCCESS) ||
      MMCSD_R1_ERROR(resp[0])) {
 8005b34:	9a05      	ldr	r2, [sp, #20]
 8005b36:	4b13      	ldr	r3, [pc, #76]	; (8005b84 <sdcErase+0xb4>)
 8005b38:	4013      	ands	r3, r2
      MMCSD_R1_ERROR(resp[0])) {
    goto failed;
  }

  if ((sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_ERASE_RW_BLK_END,
                                  endblk, resp) != HAL_SUCCESS) ||
 8005b3a:	2b00      	cmp	r3, #0
 8005b3c:	d119      	bne.n	8005b72 <sdcErase+0xa2>
      MMCSD_R1_ERROR(resp[0])) {
    goto failed;
  }

  if ((sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_ERASE,
 8005b3e:	ab05      	add	r3, sp, #20
 8005b40:	9803      	ldr	r0, [sp, #12]
 8005b42:	2126      	movs	r1, #38	; 0x26
 8005b44:	2200      	movs	r2, #0
 8005b46:	f004 f90b 	bl	8009d60 <sdc_lld_send_cmd_short_crc>
 8005b4a:	4603      	mov	r3, r0
 8005b4c:	2b00      	cmp	r3, #0
 8005b4e:	d110      	bne.n	8005b72 <sdcErase+0xa2>
                                  0, resp) != HAL_SUCCESS) ||
      MMCSD_R1_ERROR(resp[0])) {
 8005b50:	9a05      	ldr	r2, [sp, #20]
 8005b52:	4b0c      	ldr	r3, [pc, #48]	; (8005b84 <sdcErase+0xb4>)
 8005b54:	4013      	ands	r3, r2
      MMCSD_R1_ERROR(resp[0])) {
    goto failed;
  }

  if ((sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_ERASE,
                                  0, resp) != HAL_SUCCESS) ||
 8005b56:	2b00      	cmp	r3, #0
 8005b58:	d10b      	bne.n	8005b72 <sdcErase+0xa2>

  /* Quick sleep to allow it to transition to programming or receiving state */
  /* TODO: ??????????????????????????? */

  /* Wait for it to return to transfer state to indicate it has finished erasing */
  if (_sdc_wait_for_transfer_state(sdcp)) {
 8005b5a:	9803      	ldr	r0, [sp, #12]
 8005b5c:	f7ff fd80 	bl	8005660 <_sdc_wait_for_transfer_state>
 8005b60:	4603      	mov	r3, r0
 8005b62:	2b00      	cmp	r3, #0
 8005b64:	d000      	beq.n	8005b68 <sdcErase+0x98>
    goto failed;
 8005b66:	e004      	b.n	8005b72 <sdcErase+0xa2>
  }

  sdcp->state = BLK_READY;
 8005b68:	9b03      	ldr	r3, [sp, #12]
 8005b6a:	2205      	movs	r2, #5
 8005b6c:	711a      	strb	r2, [r3, #4]
  return HAL_SUCCESS;
 8005b6e:	2300      	movs	r3, #0
 8005b70:	e003      	b.n	8005b7a <sdcErase+0xaa>

failed:
  sdcp->state = BLK_READY;
 8005b72:	9b03      	ldr	r3, [sp, #12]
 8005b74:	2205      	movs	r2, #5
 8005b76:	711a      	strb	r2, [r3, #4]
  return HAL_FAILED;
 8005b78:	2301      	movs	r3, #1
}
 8005b7a:	4618      	mov	r0, r3
 8005b7c:	b007      	add	sp, #28
 8005b7e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005b82:	bf00      	nop
 8005b84:	fdffe008 	.word	0xfdffe008
 8005b88:	f3af 8000 	nop.w
 8005b8c:	f3af 8000 	nop.w

08005b90 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8005b90:	b082      	sub	sp, #8
 8005b92:	2320      	movs	r3, #32
 8005b94:	9301      	str	r3, [sp, #4]
 8005b96:	9b01      	ldr	r3, [sp, #4]
 8005b98:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8005b9c:	b002      	add	sp, #8
 8005b9e:	4770      	bx	lr

08005ba0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8005ba0:	b082      	sub	sp, #8
 8005ba2:	2300      	movs	r3, #0
 8005ba4:	9301      	str	r3, [sp, #4]
 8005ba6:	9b01      	ldr	r3, [sp, #4]
 8005ba8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8005bac:	b002      	add	sp, #8
 8005bae:	4770      	bx	lr

08005bb0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8005bb0:	b508      	push	{r3, lr}

  port_lock();
 8005bb2:	f7ff ffed 	bl	8005b90 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8005bb6:	bd08      	pop	{r3, pc}
 8005bb8:	f3af 8000 	nop.w
 8005bbc:	f3af 8000 	nop.w

08005bc0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8005bc0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8005bc2:	f7ff ffed 	bl	8005ba0 <port_unlock>
}
 8005bc6:	bd08      	pop	{r3, pc}
 8005bc8:	f3af 8000 	nop.w
 8005bcc:	f3af 8000 	nop.w

08005bd0 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 8005bd0:	b082      	sub	sp, #8
 8005bd2:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 8005bd4:	9b01      	ldr	r3, [sp, #4]
 8005bd6:	9a01      	ldr	r2, [sp, #4]
 8005bd8:	601a      	str	r2, [r3, #0]
}
 8005bda:	b002      	add	sp, #8
 8005bdc:	4770      	bx	lr
 8005bde:	bf00      	nop

08005be0 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 8005be0:	b082      	sub	sp, #8
 8005be2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8005be4:	9b01      	ldr	r3, [sp, #4]
 8005be6:	689b      	ldr	r3, [r3, #8]
 8005be8:	2b00      	cmp	r3, #0
 8005bea:	bf14      	ite	ne
 8005bec:	2300      	movne	r3, #0
 8005bee:	2301      	moveq	r3, #1
 8005bf0:	b2db      	uxtb	r3, r3
}
 8005bf2:	4618      	mov	r0, r3
 8005bf4:	b002      	add	sp, #8
 8005bf6:	4770      	bx	lr
 8005bf8:	f3af 8000 	nop.w
 8005bfc:	f3af 8000 	nop.w

08005c00 <chOQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
 8005c00:	b082      	sub	sp, #8
 8005c02:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8005c04:	9b01      	ldr	r3, [sp, #4]
 8005c06:	689b      	ldr	r3, [r3, #8]
 8005c08:	2b00      	cmp	r3, #0
 8005c0a:	bf14      	ite	ne
 8005c0c:	2300      	movne	r3, #0
 8005c0e:	2301      	moveq	r3, #1
 8005c10:	b2db      	uxtb	r3, r3
}
 8005c12:	4618      	mov	r0, r3
 8005c14:	b002      	add	sp, #8
 8005c16:	4770      	bx	lr
 8005c18:	f3af 8000 	nop.w
 8005c1c:	f3af 8000 	nop.w

08005c20 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8005c20:	b508      	push	{r3, lr}

  chSysLock();
 8005c22:	f7ff ffc5 	bl	8005bb0 <chSysLock>
}
 8005c26:	bd08      	pop	{r3, pc}
 8005c28:	f3af 8000 	nop.w
 8005c2c:	f3af 8000 	nop.w

08005c30 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8005c30:	b508      	push	{r3, lr}

  chSysUnlock();
 8005c32:	f7ff ffc5 	bl	8005bc0 <chSysUnlock>
}
 8005c36:	bd08      	pop	{r3, pc}
 8005c38:	f3af 8000 	nop.w
 8005c3c:	f3af 8000 	nop.w

08005c40 <osalOsRescheduleS>:
 *          required in this scenario.
 * @note    Not implemented in this simplified OSAL.
 *
 * @sclass
 */
static inline void osalOsRescheduleS(void) {
 8005c40:	b508      	push	{r3, lr}

  chSchRescheduleS();
 8005c42:	f7fb f89d 	bl	8000d80 <chSchRescheduleS>
}
 8005c46:	bd08      	pop	{r3, pc}
 8005c48:	f3af 8000 	nop.w
 8005c4c:	f3af 8000 	nop.w

08005c50 <osalEventObjectInit>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
 8005c50:	b500      	push	{lr}
 8005c52:	b083      	sub	sp, #12
 8005c54:	9001      	str	r0, [sp, #4]

  chEvtObjectInit(esp);
 8005c56:	9801      	ldr	r0, [sp, #4]
 8005c58:	f7ff ffba 	bl	8005bd0 <chEvtObjectInit>
}
 8005c5c:	b003      	add	sp, #12
 8005c5e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005c62:	bf00      	nop
 8005c64:	f3af 8000 	nop.w
 8005c68:	f3af 8000 	nop.w
 8005c6c:	f3af 8000 	nop.w

08005c70 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 8005c70:	b500      	push	{lr}
 8005c72:	b083      	sub	sp, #12
 8005c74:	9001      	str	r0, [sp, #4]
 8005c76:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 8005c78:	9801      	ldr	r0, [sp, #4]
 8005c7a:	9900      	ldr	r1, [sp, #0]
 8005c7c:	f7fc fd00 	bl	8002680 <chEvtBroadcastFlagsI>
}
 8005c80:	b003      	add	sp, #12
 8005c82:	f85d fb04 	ldr.w	pc, [sp], #4
 8005c86:	bf00      	nop
 8005c88:	f3af 8000 	nop.w
 8005c8c:	f3af 8000 	nop.w

08005c90 <write>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 8005c90:	b500      	push	{lr}
 8005c92:	b085      	sub	sp, #20
 8005c94:	9003      	str	r0, [sp, #12]
 8005c96:	9102      	str	r1, [sp, #8]
 8005c98:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8005c9a:	9b03      	ldr	r3, [sp, #12]
 8005c9c:	3330      	adds	r3, #48	; 0x30
 8005c9e:	4618      	mov	r0, r3
 8005ca0:	9902      	ldr	r1, [sp, #8]
 8005ca2:	9a01      	ldr	r2, [sp, #4]
 8005ca4:	f04f 33ff 	mov.w	r3, #4294967295
 8005ca8:	f7fd fc4a 	bl	8003540 <chOQWriteTimeout>
 8005cac:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
 8005cae:	4618      	mov	r0, r3
 8005cb0:	b005      	add	sp, #20
 8005cb2:	f85d fb04 	ldr.w	pc, [sp], #4
 8005cb6:	bf00      	nop
 8005cb8:	f3af 8000 	nop.w
 8005cbc:	f3af 8000 	nop.w

08005cc0 <read>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
 8005cc0:	b500      	push	{lr}
 8005cc2:	b085      	sub	sp, #20
 8005cc4:	9003      	str	r0, [sp, #12]
 8005cc6:	9102      	str	r1, [sp, #8]
 8005cc8:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8005cca:	9b03      	ldr	r3, [sp, #12]
 8005ccc:	330c      	adds	r3, #12
 8005cce:	4618      	mov	r0, r3
 8005cd0:	9902      	ldr	r1, [sp, #8]
 8005cd2:	9a01      	ldr	r2, [sp, #4]
 8005cd4:	f04f 33ff 	mov.w	r3, #4294967295
 8005cd8:	f7fd fb1a 	bl	8003310 <chIQReadTimeout>
 8005cdc:	4603      	mov	r3, r0
                       n, TIME_INFINITE);
}
 8005cde:	4618      	mov	r0, r3
 8005ce0:	b005      	add	sp, #20
 8005ce2:	f85d fb04 	ldr.w	pc, [sp], #4
 8005ce6:	bf00      	nop
 8005ce8:	f3af 8000 	nop.w
 8005cec:	f3af 8000 	nop.w

08005cf0 <put>:

static msg_t put(void *ip, uint8_t b) {
 8005cf0:	b500      	push	{lr}
 8005cf2:	b083      	sub	sp, #12
 8005cf4:	9001      	str	r0, [sp, #4]
 8005cf6:	460b      	mov	r3, r1
 8005cf8:	f88d 3003 	strb.w	r3, [sp, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8005cfc:	9b01      	ldr	r3, [sp, #4]
 8005cfe:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8005d02:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005d06:	4610      	mov	r0, r2
 8005d08:	4619      	mov	r1, r3
 8005d0a:	f04f 32ff 	mov.w	r2, #4294967295
 8005d0e:	f7fd fb9f 	bl	8003450 <chOQPutTimeout>
 8005d12:	4603      	mov	r3, r0
}
 8005d14:	4618      	mov	r0, r3
 8005d16:	b003      	add	sp, #12
 8005d18:	f85d fb04 	ldr.w	pc, [sp], #4
 8005d1c:	f3af 8000 	nop.w

08005d20 <get>:

static msg_t get(void *ip) {
 8005d20:	b500      	push	{lr}
 8005d22:	b083      	sub	sp, #12
 8005d24:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8005d26:	9b01      	ldr	r3, [sp, #4]
 8005d28:	330c      	adds	r3, #12
 8005d2a:	4618      	mov	r0, r3
 8005d2c:	f04f 31ff 	mov.w	r1, #4294967295
 8005d30:	f7fd faa6 	bl	8003280 <chIQGetTimeout>
 8005d34:	4603      	mov	r3, r0
}
 8005d36:	4618      	mov	r0, r3
 8005d38:	b003      	add	sp, #12
 8005d3a:	f85d fb04 	ldr.w	pc, [sp], #4
 8005d3e:	bf00      	nop

08005d40 <putt>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 8005d40:	b500      	push	{lr}
 8005d42:	b085      	sub	sp, #20
 8005d44:	9003      	str	r0, [sp, #12]
 8005d46:	460b      	mov	r3, r1
 8005d48:	9201      	str	r2, [sp, #4]
 8005d4a:	f88d 300b 	strb.w	r3, [sp, #11]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8005d4e:	9b03      	ldr	r3, [sp, #12]
 8005d50:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8005d54:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8005d58:	4610      	mov	r0, r2
 8005d5a:	4619      	mov	r1, r3
 8005d5c:	9a01      	ldr	r2, [sp, #4]
 8005d5e:	f7fd fb77 	bl	8003450 <chOQPutTimeout>
 8005d62:	4603      	mov	r3, r0
}
 8005d64:	4618      	mov	r0, r3
 8005d66:	b005      	add	sp, #20
 8005d68:	f85d fb04 	ldr.w	pc, [sp], #4
 8005d6c:	f3af 8000 	nop.w

08005d70 <gett>:

static msg_t gett(void *ip, systime_t timeout) {
 8005d70:	b500      	push	{lr}
 8005d72:	b083      	sub	sp, #12
 8005d74:	9001      	str	r0, [sp, #4]
 8005d76:	9100      	str	r1, [sp, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8005d78:	9b01      	ldr	r3, [sp, #4]
 8005d7a:	330c      	adds	r3, #12
 8005d7c:	4618      	mov	r0, r3
 8005d7e:	9900      	ldr	r1, [sp, #0]
 8005d80:	f7fd fa7e 	bl	8003280 <chIQGetTimeout>
 8005d84:	4603      	mov	r3, r0
}
 8005d86:	4618      	mov	r0, r3
 8005d88:	b003      	add	sp, #12
 8005d8a:	f85d fb04 	ldr.w	pc, [sp], #4
 8005d8e:	bf00      	nop

08005d90 <writet>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8005d90:	b500      	push	{lr}
 8005d92:	b085      	sub	sp, #20
 8005d94:	9003      	str	r0, [sp, #12]
 8005d96:	9102      	str	r1, [sp, #8]
 8005d98:	9201      	str	r2, [sp, #4]
 8005d9a:	9300      	str	r3, [sp, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8005d9c:	9b03      	ldr	r3, [sp, #12]
 8005d9e:	3330      	adds	r3, #48	; 0x30
 8005da0:	4618      	mov	r0, r3
 8005da2:	9902      	ldr	r1, [sp, #8]
 8005da4:	9a01      	ldr	r2, [sp, #4]
 8005da6:	9b00      	ldr	r3, [sp, #0]
 8005da8:	f7fd fbca 	bl	8003540 <chOQWriteTimeout>
 8005dac:	4603      	mov	r3, r0
}
 8005dae:	4618      	mov	r0, r3
 8005db0:	b005      	add	sp, #20
 8005db2:	f85d fb04 	ldr.w	pc, [sp], #4
 8005db6:	bf00      	nop
 8005db8:	f3af 8000 	nop.w
 8005dbc:	f3af 8000 	nop.w

08005dc0 <readt>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8005dc0:	b500      	push	{lr}
 8005dc2:	b085      	sub	sp, #20
 8005dc4:	9003      	str	r0, [sp, #12]
 8005dc6:	9102      	str	r1, [sp, #8]
 8005dc8:	9201      	str	r2, [sp, #4]
 8005dca:	9300      	str	r3, [sp, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8005dcc:	9b03      	ldr	r3, [sp, #12]
 8005dce:	330c      	adds	r3, #12
 8005dd0:	4618      	mov	r0, r3
 8005dd2:	9902      	ldr	r1, [sp, #8]
 8005dd4:	9a01      	ldr	r2, [sp, #4]
 8005dd6:	9b00      	ldr	r3, [sp, #0]
 8005dd8:	f7fd fa9a 	bl	8003310 <chIQReadTimeout>
 8005ddc:	4603      	mov	r3, r0
}
 8005dde:	4618      	mov	r0, r3
 8005de0:	b005      	add	sp, #20
 8005de2:	f85d fb04 	ldr.w	pc, [sp], #4
 8005de6:	bf00      	nop
 8005de8:	f3af 8000 	nop.w
 8005dec:	f3af 8000 	nop.w

08005df0 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
 8005df0:	b508      	push	{r3, lr}

  sd_lld_init();
 8005df2:	f005 f845 	bl	800ae80 <sd_lld_init>
}
 8005df6:	bd08      	pop	{r3, pc}
 8005df8:	f3af 8000 	nop.w
 8005dfc:	f3af 8000 	nop.w

08005e00 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8005e00:	b500      	push	{lr}
 8005e02:	b087      	sub	sp, #28
 8005e04:	9005      	str	r0, [sp, #20]
 8005e06:	9104      	str	r1, [sp, #16]
 8005e08:	9203      	str	r2, [sp, #12]

  sdp->vmt = &vmt;
 8005e0a:	9b05      	ldr	r3, [sp, #20]
 8005e0c:	4a13      	ldr	r2, [pc, #76]	; (8005e5c <sdObjectInit+0x5c>)
 8005e0e:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
 8005e10:	9b05      	ldr	r3, [sp, #20]
 8005e12:	3304      	adds	r3, #4
 8005e14:	4618      	mov	r0, r3
 8005e16:	f7ff ff1b 	bl	8005c50 <osalEventObjectInit>
  sdp->state = SD_STOP;
 8005e1a:	9b05      	ldr	r3, [sp, #20]
 8005e1c:	2201      	movs	r2, #1
 8005e1e:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8005e20:	9b05      	ldr	r3, [sp, #20]
 8005e22:	f103 020c 	add.w	r2, r3, #12
 8005e26:	9b05      	ldr	r3, [sp, #20]
 8005e28:	3354      	adds	r3, #84	; 0x54
 8005e2a:	9905      	ldr	r1, [sp, #20]
 8005e2c:	9100      	str	r1, [sp, #0]
 8005e2e:	4610      	mov	r0, r2
 8005e30:	4619      	mov	r1, r3
 8005e32:	2210      	movs	r2, #16
 8005e34:	9b04      	ldr	r3, [sp, #16]
 8005e36:	f7fd f9b3 	bl	80031a0 <chIQObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 8005e3a:	9b05      	ldr	r3, [sp, #20]
 8005e3c:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8005e40:	9b05      	ldr	r3, [sp, #20]
 8005e42:	3364      	adds	r3, #100	; 0x64
 8005e44:	9905      	ldr	r1, [sp, #20]
 8005e46:	9100      	str	r1, [sp, #0]
 8005e48:	4610      	mov	r0, r2
 8005e4a:	4619      	mov	r1, r3
 8005e4c:	2210      	movs	r2, #16
 8005e4e:	9b03      	ldr	r3, [sp, #12]
 8005e50:	f7fd fab6 	bl	80033c0 <chOQObjectInit>
}
 8005e54:	b007      	add	sp, #28
 8005e56:	f85d fb04 	ldr.w	pc, [sp], #4
 8005e5a:	bf00      	nop
 8005e5c:	08015f60 	.word	0x08015f60

08005e60 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8005e60:	b500      	push	{lr}
 8005e62:	b083      	sub	sp, #12
 8005e64:	9001      	str	r0, [sp, #4]
 8005e66:	9100      	str	r1, [sp, #0]

  osalDbgCheck(sdp != NULL);

  osalSysLock();
 8005e68:	f7ff feda 	bl	8005c20 <osalSysLock>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
 8005e6c:	9801      	ldr	r0, [sp, #4]
 8005e6e:	9900      	ldr	r1, [sp, #0]
 8005e70:	f005 f826 	bl	800aec0 <sd_lld_start>
  sdp->state = SD_READY;
 8005e74:	9b01      	ldr	r3, [sp, #4]
 8005e76:	2202      	movs	r2, #2
 8005e78:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
 8005e7a:	f7ff fed9 	bl	8005c30 <osalSysUnlock>
}
 8005e7e:	b003      	add	sp, #12
 8005e80:	f85d fb04 	ldr.w	pc, [sp], #4
 8005e84:	f3af 8000 	nop.w
 8005e88:	f3af 8000 	nop.w
 8005e8c:	f3af 8000 	nop.w

08005e90 <sdStop>:
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 *
 * @api
 */
void sdStop(SerialDriver *sdp) {
 8005e90:	b500      	push	{lr}
 8005e92:	b083      	sub	sp, #12
 8005e94:	9001      	str	r0, [sp, #4]

  osalDbgCheck(sdp != NULL);

  osalSysLock();
 8005e96:	f7ff fec3 	bl	8005c20 <osalSysLock>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_stop(sdp);
 8005e9a:	9801      	ldr	r0, [sp, #4]
 8005e9c:	f005 f838 	bl	800af10 <sd_lld_stop>
  sdp->state = SD_STOP;
 8005ea0:	9b01      	ldr	r3, [sp, #4]
 8005ea2:	2201      	movs	r2, #1
 8005ea4:	721a      	strb	r2, [r3, #8]
  oqResetI(&sdp->oqueue);
 8005ea6:	9b01      	ldr	r3, [sp, #4]
 8005ea8:	3330      	adds	r3, #48	; 0x30
 8005eaa:	4618      	mov	r0, r3
 8005eac:	f7fd fab0 	bl	8003410 <chOQResetI>
  iqResetI(&sdp->iqueue);
 8005eb0:	9b01      	ldr	r3, [sp, #4]
 8005eb2:	330c      	adds	r3, #12
 8005eb4:	4618      	mov	r0, r3
 8005eb6:	f7fd f99b 	bl	80031f0 <chIQResetI>
  osalOsRescheduleS();
 8005eba:	f7ff fec1 	bl	8005c40 <osalOsRescheduleS>
  osalSysUnlock();
 8005ebe:	f7ff feb7 	bl	8005c30 <osalSysUnlock>
}
 8005ec2:	b003      	add	sp, #12
 8005ec4:	f85d fb04 	ldr.w	pc, [sp], #4
 8005ec8:	f3af 8000 	nop.w
 8005ecc:	f3af 8000 	nop.w

08005ed0 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8005ed0:	b500      	push	{lr}
 8005ed2:	b083      	sub	sp, #12
 8005ed4:	9001      	str	r0, [sp, #4]
 8005ed6:	460b      	mov	r3, r1
 8005ed8:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8005edc:	9b01      	ldr	r3, [sp, #4]
 8005ede:	330c      	adds	r3, #12
 8005ee0:	4618      	mov	r0, r3
 8005ee2:	f7ff fe7d 	bl	8005be0 <chIQIsEmptyI>
 8005ee6:	4603      	mov	r3, r0
 8005ee8:	2b00      	cmp	r3, #0
 8005eea:	d005      	beq.n	8005ef8 <sdIncomingDataI+0x28>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 8005eec:	9b01      	ldr	r3, [sp, #4]
 8005eee:	3304      	adds	r3, #4
 8005ef0:	4618      	mov	r0, r3
 8005ef2:	2104      	movs	r1, #4
 8005ef4:	f7ff febc 	bl	8005c70 <osalEventBroadcastFlagsI>
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 8005ef8:	9b01      	ldr	r3, [sp, #4]
 8005efa:	f103 020c 	add.w	r2, r3, #12
 8005efe:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005f02:	4610      	mov	r0, r2
 8005f04:	4619      	mov	r1, r3
 8005f06:	f7fd f98b 	bl	8003220 <chIQPutI>
 8005f0a:	4603      	mov	r3, r0
 8005f0c:	2b00      	cmp	r3, #0
 8005f0e:	da05      	bge.n	8005f1c <sdIncomingDataI+0x4c>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
 8005f10:	9b01      	ldr	r3, [sp, #4]
 8005f12:	3304      	adds	r3, #4
 8005f14:	4618      	mov	r0, r3
 8005f16:	2180      	movs	r1, #128	; 0x80
 8005f18:	f7ff feaa 	bl	8005c70 <osalEventBroadcastFlagsI>
}
 8005f1c:	b003      	add	sp, #12
 8005f1e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005f22:	bf00      	nop
 8005f24:	f3af 8000 	nop.w
 8005f28:	f3af 8000 	nop.w
 8005f2c:	f3af 8000 	nop.w

08005f30 <sdRequestDataI>:
 * @retval Q_EMPTY      if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
 8005f30:	b500      	push	{lr}
 8005f32:	b085      	sub	sp, #20
 8005f34:	9001      	str	r0, [sp, #4]
  msg_t  b;

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  b = oqGetI(&sdp->oqueue);
 8005f36:	9b01      	ldr	r3, [sp, #4]
 8005f38:	3330      	adds	r3, #48	; 0x30
 8005f3a:	4618      	mov	r0, r3
 8005f3c:	f7fd fad0 	bl	80034e0 <chOQGetI>
 8005f40:	9003      	str	r0, [sp, #12]
  if (b < Q_OK)
 8005f42:	9b03      	ldr	r3, [sp, #12]
 8005f44:	2b00      	cmp	r3, #0
 8005f46:	da05      	bge.n	8005f54 <sdRequestDataI+0x24>
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 8005f48:	9b01      	ldr	r3, [sp, #4]
 8005f4a:	3304      	adds	r3, #4
 8005f4c:	4618      	mov	r0, r3
 8005f4e:	2108      	movs	r1, #8
 8005f50:	f7ff fe8e 	bl	8005c70 <osalEventBroadcastFlagsI>
  return b;
 8005f54:	9b03      	ldr	r3, [sp, #12]
}
 8005f56:	4618      	mov	r0, r3
 8005f58:	b005      	add	sp, #20
 8005f5a:	f85d fb04 	ldr.w	pc, [sp], #4
 8005f5e:	bf00      	nop

08005f60 <sdPutWouldBlock>:
 *
 * @deprecated
 *
 * @api
 */
bool sdPutWouldBlock(SerialDriver *sdp) {
 8005f60:	b500      	push	{lr}
 8005f62:	b085      	sub	sp, #20
 8005f64:	9001      	str	r0, [sp, #4]
  bool b;

  osalSysLock();
 8005f66:	f7ff fe5b 	bl	8005c20 <osalSysLock>
  b = oqIsFullI(&sdp->oqueue);
 8005f6a:	9b01      	ldr	r3, [sp, #4]
 8005f6c:	3330      	adds	r3, #48	; 0x30
 8005f6e:	4618      	mov	r0, r3
 8005f70:	f7ff fe46 	bl	8005c00 <chOQIsFullI>
 8005f74:	4603      	mov	r3, r0
 8005f76:	f88d 300f 	strb.w	r3, [sp, #15]
  osalSysUnlock();
 8005f7a:	f7ff fe59 	bl	8005c30 <osalSysUnlock>

  return b;
 8005f7e:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8005f82:	4618      	mov	r0, r3
 8005f84:	b005      	add	sp, #20
 8005f86:	f85d fb04 	ldr.w	pc, [sp], #4
 8005f8a:	bf00      	nop
 8005f8c:	f3af 8000 	nop.w

08005f90 <sdGetWouldBlock>:
 *
 * @deprecated
 *
 * @api
 */
bool sdGetWouldBlock(SerialDriver *sdp) {
 8005f90:	b500      	push	{lr}
 8005f92:	b085      	sub	sp, #20
 8005f94:	9001      	str	r0, [sp, #4]
  bool b;

  osalSysLock();
 8005f96:	f7ff fe43 	bl	8005c20 <osalSysLock>
  b = iqIsEmptyI(&sdp->iqueue);
 8005f9a:	9b01      	ldr	r3, [sp, #4]
 8005f9c:	330c      	adds	r3, #12
 8005f9e:	4618      	mov	r0, r3
 8005fa0:	f7ff fe1e 	bl	8005be0 <chIQIsEmptyI>
 8005fa4:	4603      	mov	r3, r0
 8005fa6:	f88d 300f 	strb.w	r3, [sp, #15]
  osalSysUnlock();
 8005faa:	f7ff fe41 	bl	8005c30 <osalSysUnlock>

  return b;
 8005fae:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8005fb2:	4618      	mov	r0, r3
 8005fb4:	b005      	add	sp, #20
 8005fb6:	f85d fb04 	ldr.w	pc, [sp], #4
 8005fba:	bf00      	nop
 8005fbc:	f3af 8000 	nop.w

08005fc0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8005fc0:	b082      	sub	sp, #8
 8005fc2:	2320      	movs	r3, #32
 8005fc4:	9301      	str	r3, [sp, #4]
 8005fc6:	9b01      	ldr	r3, [sp, #4]
 8005fc8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8005fcc:	b002      	add	sp, #8
 8005fce:	4770      	bx	lr

08005fd0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8005fd0:	b082      	sub	sp, #8
 8005fd2:	2300      	movs	r3, #0
 8005fd4:	9301      	str	r3, [sp, #4]
 8005fd6:	9b01      	ldr	r3, [sp, #4]
 8005fd8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8005fdc:	b002      	add	sp, #8
 8005fde:	4770      	bx	lr

08005fe0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8005fe0:	b508      	push	{r3, lr}

  port_lock();
 8005fe2:	f7ff ffed 	bl	8005fc0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8005fe6:	bd08      	pop	{r3, pc}
 8005fe8:	f3af 8000 	nop.w
 8005fec:	f3af 8000 	nop.w

08005ff0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8005ff0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8005ff2:	f7ff ffed 	bl	8005fd0 <port_unlock>
}
 8005ff6:	bd08      	pop	{r3, pc}
 8005ff8:	f3af 8000 	nop.w
 8005ffc:	f3af 8000 	nop.w

08006000 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8006000:	b508      	push	{r3, lr}

  chSysLock();
 8006002:	f7ff ffed 	bl	8005fe0 <chSysLock>
}
 8006006:	bd08      	pop	{r3, pc}
 8006008:	f3af 8000 	nop.w
 800600c:	f3af 8000 	nop.w

08006010 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8006010:	b508      	push	{r3, lr}

  chSysUnlock();
 8006012:	f7ff ffed 	bl	8005ff0 <chSysUnlock>
}
 8006016:	bd08      	pop	{r3, pc}
 8006018:	f3af 8000 	nop.w
 800601c:	f3af 8000 	nop.w

08006020 <osalThreadSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 8006020:	b500      	push	{lr}
 8006022:	b083      	sub	sp, #12
 8006024:	9001      	str	r0, [sp, #4]

  return chThdSuspendS(trp);
 8006026:	9801      	ldr	r0, [sp, #4]
 8006028:	f7fb fa12 	bl	8001450 <chThdSuspendS>
 800602c:	4603      	mov	r3, r0
}
 800602e:	4618      	mov	r0, r3
 8006030:	b003      	add	sp, #12
 8006032:	f85d fb04 	ldr.w	pc, [sp], #4
 8006036:	bf00      	nop
 8006038:	f3af 8000 	nop.w
 800603c:	f3af 8000 	nop.w

08006040 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
 8006040:	b500      	push	{lr}
 8006042:	b083      	sub	sp, #12
 8006044:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 8006046:	9801      	ldr	r0, [sp, #4]
 8006048:	f7fb ff52 	bl	8001ef0 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
 800604c:	b003      	add	sp, #12
 800604e:	f85d fb04 	ldr.w	pc, [sp], #4
 8006052:	bf00      	nop
 8006054:	f3af 8000 	nop.w
 8006058:	f3af 8000 	nop.w
 800605c:	f3af 8000 	nop.w

08006060 <osalMutexLock>:
 *
 * @param[in,out] mp    pointer to the @p mutex_t object
 *
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {
 8006060:	b500      	push	{lr}
 8006062:	b083      	sub	sp, #12
 8006064:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 8006066:	9801      	ldr	r0, [sp, #4]
 8006068:	f7fb ff52 	bl	8001f10 <chMtxLock>
#elif CH_CFG_USE_SEMAPHORES
  chSemWait((semaphore_t *)mp);
#else
  *mp = 1;
#endif
}
 800606c:	b003      	add	sp, #12
 800606e:	f85d fb04 	ldr.w	pc, [sp], #4
 8006072:	bf00      	nop
 8006074:	f3af 8000 	nop.w
 8006078:	f3af 8000 	nop.w
 800607c:	f3af 8000 	nop.w

08006080 <osalMutexUnlock>:
 *
 * @param[in,out] mp    pointer to the @p mutex_t object
 *
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {
 8006080:	b500      	push	{lr}
 8006082:	b083      	sub	sp, #12
 8006084:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 8006086:	9801      	ldr	r0, [sp, #4]
 8006088:	f7fb ffea 	bl	8002060 <chMtxUnlock>
#elif CH_CFG_USE_SEMAPHORES
  chSemSignal((semaphore_t *)mp);
#else
  *mp = 0;
#endif
}
 800608c:	b003      	add	sp, #12
 800608e:	f85d fb04 	ldr.w	pc, [sp], #4
 8006092:	bf00      	nop
 8006094:	f3af 8000 	nop.w
 8006098:	f3af 8000 	nop.w
 800609c:	f3af 8000 	nop.w

080060a0 <spiInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void spiInit(void) {
 80060a0:	b508      	push	{r3, lr}

  spi_lld_init();
 80060a2:	f004 f9bd 	bl	800a420 <spi_lld_init>
}
 80060a6:	bd08      	pop	{r3, pc}
 80060a8:	f3af 8000 	nop.w
 80060ac:	f3af 8000 	nop.w

080060b0 <spiObjectInit>:
 *
 * @param[out] spip     pointer to the @p SPIDriver object
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {
 80060b0:	b500      	push	{lr}
 80060b2:	b083      	sub	sp, #12
 80060b4:	9001      	str	r0, [sp, #4]

  spip->state = SPI_STOP;
 80060b6:	9b01      	ldr	r3, [sp, #4]
 80060b8:	2201      	movs	r2, #1
 80060ba:	701a      	strb	r2, [r3, #0]
  spip->config = NULL;
 80060bc:	9b01      	ldr	r3, [sp, #4]
 80060be:	2200      	movs	r2, #0
 80060c0:	605a      	str	r2, [r3, #4]
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
 80060c2:	9b01      	ldr	r3, [sp, #4]
 80060c4:	2200      	movs	r2, #0
 80060c6:	609a      	str	r2, [r3, #8]
#endif
#if SPI_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&spip->mutex);
 80060c8:	9b01      	ldr	r3, [sp, #4]
 80060ca:	330c      	adds	r3, #12
 80060cc:	4618      	mov	r0, r3
 80060ce:	f7ff ffb7 	bl	8006040 <osalMutexObjectInit>
#endif
#if defined(SPI_DRIVER_EXT_INIT_HOOK)
  SPI_DRIVER_EXT_INIT_HOOK(spip);
#endif
}
 80060d2:	b003      	add	sp, #12
 80060d4:	f85d fb04 	ldr.w	pc, [sp], #4
 80060d8:	f3af 8000 	nop.w
 80060dc:	f3af 8000 	nop.w

080060e0 <spiStart>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] config    pointer to the @p SPIConfig object
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {
 80060e0:	b500      	push	{lr}
 80060e2:	b083      	sub	sp, #12
 80060e4:	9001      	str	r0, [sp, #4]
 80060e6:	9100      	str	r1, [sp, #0]

  osalDbgCheck((spip != NULL) && (config != NULL));

  osalSysLock();
 80060e8:	f7ff ff8a 	bl	8006000 <osalSysLock>
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");
  spip->config = config;
 80060ec:	9b01      	ldr	r3, [sp, #4]
 80060ee:	9a00      	ldr	r2, [sp, #0]
 80060f0:	605a      	str	r2, [r3, #4]
  spi_lld_start(spip);
 80060f2:	9801      	ldr	r0, [sp, #4]
 80060f4:	f004 f9b4 	bl	800a460 <spi_lld_start>
  spip->state = SPI_READY;
 80060f8:	9b01      	ldr	r3, [sp, #4]
 80060fa:	2202      	movs	r2, #2
 80060fc:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 80060fe:	f7ff ff87 	bl	8006010 <osalSysUnlock>
}
 8006102:	b003      	add	sp, #12
 8006104:	f85d fb04 	ldr.w	pc, [sp], #4
 8006108:	f3af 8000 	nop.w
 800610c:	f3af 8000 	nop.w

08006110 <spiStop>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiStop(SPIDriver *spip) {
 8006110:	b500      	push	{lr}
 8006112:	b083      	sub	sp, #12
 8006114:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalSysLock();
 8006116:	f7ff ff73 	bl	8006000 <osalSysLock>
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");
  spi_lld_stop(spip);
 800611a:	9801      	ldr	r0, [sp, #4]
 800611c:	f004 fa30 	bl	800a580 <spi_lld_stop>
  spip->state = SPI_STOP;
 8006120:	9b01      	ldr	r3, [sp, #4]
 8006122:	2201      	movs	r2, #1
 8006124:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 8006126:	f7ff ff73 	bl	8006010 <osalSysUnlock>
}
 800612a:	b003      	add	sp, #12
 800612c:	f85d fb04 	ldr.w	pc, [sp], #4

08006130 <spiSelect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiSelect(SPIDriver *spip) {
 8006130:	b500      	push	{lr}
 8006132:	b083      	sub	sp, #12
 8006134:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalSysLock();
 8006136:	f7ff ff63 	bl	8006000 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiSelectI(spip);
 800613a:	9801      	ldr	r0, [sp, #4]
 800613c:	f004 fa50 	bl	800a5e0 <spi_lld_select>
  osalSysUnlock();
 8006140:	f7ff ff66 	bl	8006010 <osalSysUnlock>
}
 8006144:	b003      	add	sp, #12
 8006146:	f85d fb04 	ldr.w	pc, [sp], #4
 800614a:	bf00      	nop
 800614c:	f3af 8000 	nop.w

08006150 <spiUnselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiUnselect(SPIDriver *spip) {
 8006150:	b500      	push	{lr}
 8006152:	b083      	sub	sp, #12
 8006154:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalSysLock();
 8006156:	f7ff ff53 	bl	8006000 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiUnselectI(spip);
 800615a:	9801      	ldr	r0, [sp, #4]
 800615c:	f004 fa50 	bl	800a600 <spi_lld_unselect>
  osalSysUnlock();
 8006160:	f7ff ff56 	bl	8006010 <osalSysUnlock>
}
 8006164:	b003      	add	sp, #12
 8006166:	f85d fb04 	ldr.w	pc, [sp], #4
 800616a:	bf00      	nop
 800616c:	f3af 8000 	nop.w

08006170 <spiStartIgnore>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] n         number of words to be ignored
 *
 * @api
 */
void spiStartIgnore(SPIDriver *spip, size_t n) {
 8006170:	b500      	push	{lr}
 8006172:	b083      	sub	sp, #12
 8006174:	9001      	str	r0, [sp, #4]
 8006176:	9100      	str	r1, [sp, #0]

  osalDbgCheck((spip != NULL) && (n > 0U));

  osalSysLock();
 8006178:	f7ff ff42 	bl	8006000 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiStartIgnoreI(spip, n);
 800617c:	9b01      	ldr	r3, [sp, #4]
 800617e:	2203      	movs	r2, #3
 8006180:	701a      	strb	r2, [r3, #0]
 8006182:	9801      	ldr	r0, [sp, #4]
 8006184:	9900      	ldr	r1, [sp, #0]
 8006186:	f004 fa4b 	bl	800a620 <spi_lld_ignore>
  osalSysUnlock();
 800618a:	f7ff ff41 	bl	8006010 <osalSysUnlock>
}
 800618e:	b003      	add	sp, #12
 8006190:	f85d fb04 	ldr.w	pc, [sp], #4
 8006194:	f3af 8000 	nop.w
 8006198:	f3af 8000 	nop.w
 800619c:	f3af 8000 	nop.w

080061a0 <spiStartExchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiStartExchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {
 80061a0:	b500      	push	{lr}
 80061a2:	b085      	sub	sp, #20
 80061a4:	9003      	str	r0, [sp, #12]
 80061a6:	9102      	str	r1, [sp, #8]
 80061a8:	9201      	str	r2, [sp, #4]
 80061aa:	9300      	str	r3, [sp, #0]

  osalDbgCheck((spip != NULL) && (n > 0U) &&
               (rxbuf != NULL) && (txbuf != NULL));

  osalSysLock();
 80061ac:	f7ff ff28 	bl	8006000 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiStartExchangeI(spip, n, txbuf, rxbuf);
 80061b0:	9b03      	ldr	r3, [sp, #12]
 80061b2:	2203      	movs	r2, #3
 80061b4:	701a      	strb	r2, [r3, #0]
 80061b6:	9803      	ldr	r0, [sp, #12]
 80061b8:	9902      	ldr	r1, [sp, #8]
 80061ba:	9a01      	ldr	r2, [sp, #4]
 80061bc:	9b00      	ldr	r3, [sp, #0]
 80061be:	f004 faaf 	bl	800a720 <spi_lld_exchange>
  osalSysUnlock();
 80061c2:	f7ff ff25 	bl	8006010 <osalSysUnlock>
}
 80061c6:	b005      	add	sp, #20
 80061c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80061cc:	f3af 8000 	nop.w

080061d0 <spiStartSend>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @api
 */
void spiStartSend(SPIDriver *spip, size_t n, const void *txbuf) {
 80061d0:	b500      	push	{lr}
 80061d2:	b085      	sub	sp, #20
 80061d4:	9003      	str	r0, [sp, #12]
 80061d6:	9102      	str	r1, [sp, #8]
 80061d8:	9201      	str	r2, [sp, #4]

  osalDbgCheck((spip != NULL) && (n > 0U) && (txbuf != NULL));

  osalSysLock();
 80061da:	f7ff ff11 	bl	8006000 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiStartSendI(spip, n, txbuf);
 80061de:	9b03      	ldr	r3, [sp, #12]
 80061e0:	2203      	movs	r2, #3
 80061e2:	701a      	strb	r2, [r3, #0]
 80061e4:	9803      	ldr	r0, [sp, #12]
 80061e6:	9902      	ldr	r1, [sp, #8]
 80061e8:	9a01      	ldr	r2, [sp, #4]
 80061ea:	f004 fb21 	bl	800a830 <spi_lld_send>
  osalSysUnlock();
 80061ee:	f7ff ff0f 	bl	8006010 <osalSysUnlock>
}
 80061f2:	b005      	add	sp, #20
 80061f4:	f85d fb04 	ldr.w	pc, [sp], #4
 80061f8:	f3af 8000 	nop.w
 80061fc:	f3af 8000 	nop.w

08006200 <spiStartReceive>:
 * @param[in] n         number of words to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiStartReceive(SPIDriver *spip, size_t n, void *rxbuf) {
 8006200:	b500      	push	{lr}
 8006202:	b085      	sub	sp, #20
 8006204:	9003      	str	r0, [sp, #12]
 8006206:	9102      	str	r1, [sp, #8]
 8006208:	9201      	str	r2, [sp, #4]

  osalDbgCheck((spip != NULL) && (n > 0U) && (rxbuf != NULL));

  osalSysLock();
 800620a:	f7ff fef9 	bl	8006000 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiStartReceiveI(spip, n, rxbuf);
 800620e:	9b03      	ldr	r3, [sp, #12]
 8006210:	2203      	movs	r2, #3
 8006212:	701a      	strb	r2, [r3, #0]
 8006214:	9803      	ldr	r0, [sp, #12]
 8006216:	9902      	ldr	r1, [sp, #8]
 8006218:	9a01      	ldr	r2, [sp, #4]
 800621a:	f004 fb89 	bl	800a930 <spi_lld_receive>
  osalSysUnlock();
 800621e:	f7ff fef7 	bl	8006010 <osalSysUnlock>
}
 8006222:	b005      	add	sp, #20
 8006224:	f85d fb04 	ldr.w	pc, [sp], #4
 8006228:	f3af 8000 	nop.w
 800622c:	f3af 8000 	nop.w

08006230 <spiIgnore>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] n         number of words to be ignored
 *
 * @api
 */
void spiIgnore(SPIDriver *spip, size_t n) {
 8006230:	b500      	push	{lr}
 8006232:	b083      	sub	sp, #12
 8006234:	9001      	str	r0, [sp, #4]
 8006236:	9100      	str	r1, [sp, #0]

  osalDbgCheck((spip != NULL) && (n > 0U));

  osalSysLock();
 8006238:	f7ff fee2 	bl	8006000 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartIgnoreI(spip, n);
 800623c:	9b01      	ldr	r3, [sp, #4]
 800623e:	2203      	movs	r2, #3
 8006240:	701a      	strb	r2, [r3, #0]
 8006242:	9801      	ldr	r0, [sp, #4]
 8006244:	9900      	ldr	r1, [sp, #0]
 8006246:	f004 f9eb 	bl	800a620 <spi_lld_ignore>
  (void) osalThreadSuspendS(&spip->thread);
 800624a:	9b01      	ldr	r3, [sp, #4]
 800624c:	3308      	adds	r3, #8
 800624e:	4618      	mov	r0, r3
 8006250:	f7ff fee6 	bl	8006020 <osalThreadSuspendS>
  osalSysUnlock();
 8006254:	f7ff fedc 	bl	8006010 <osalSysUnlock>
}
 8006258:	b003      	add	sp, #12
 800625a:	f85d fb04 	ldr.w	pc, [sp], #4
 800625e:	bf00      	nop

08006260 <spiExchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiExchange(SPIDriver *spip, size_t n,
                 const void *txbuf, void *rxbuf) {
 8006260:	b500      	push	{lr}
 8006262:	b085      	sub	sp, #20
 8006264:	9003      	str	r0, [sp, #12]
 8006266:	9102      	str	r1, [sp, #8]
 8006268:	9201      	str	r2, [sp, #4]
 800626a:	9300      	str	r3, [sp, #0]

  osalDbgCheck((spip != NULL) && (n > 0U) &&
               (rxbuf != NULL) && (txbuf != NULL));

  osalSysLock();
 800626c:	f7ff fec8 	bl	8006000 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartExchangeI(spip, n, txbuf, rxbuf);
 8006270:	9b03      	ldr	r3, [sp, #12]
 8006272:	2203      	movs	r2, #3
 8006274:	701a      	strb	r2, [r3, #0]
 8006276:	9803      	ldr	r0, [sp, #12]
 8006278:	9902      	ldr	r1, [sp, #8]
 800627a:	9a01      	ldr	r2, [sp, #4]
 800627c:	9b00      	ldr	r3, [sp, #0]
 800627e:	f004 fa4f 	bl	800a720 <spi_lld_exchange>
  (void) osalThreadSuspendS(&spip->thread);
 8006282:	9b03      	ldr	r3, [sp, #12]
 8006284:	3308      	adds	r3, #8
 8006286:	4618      	mov	r0, r3
 8006288:	f7ff feca 	bl	8006020 <osalThreadSuspendS>
  osalSysUnlock();
 800628c:	f7ff fec0 	bl	8006010 <osalSysUnlock>
}
 8006290:	b005      	add	sp, #20
 8006292:	f85d fb04 	ldr.w	pc, [sp], #4
 8006296:	bf00      	nop
 8006298:	f3af 8000 	nop.w
 800629c:	f3af 8000 	nop.w

080062a0 <spiSend>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @api
 */
void spiSend(SPIDriver *spip, size_t n, const void *txbuf) {
 80062a0:	b500      	push	{lr}
 80062a2:	b085      	sub	sp, #20
 80062a4:	9003      	str	r0, [sp, #12]
 80062a6:	9102      	str	r1, [sp, #8]
 80062a8:	9201      	str	r2, [sp, #4]

  osalDbgCheck((spip != NULL) && (n > 0U) && (txbuf != NULL));

  osalSysLock();
 80062aa:	f7ff fea9 	bl	8006000 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartSendI(spip, n, txbuf);
 80062ae:	9b03      	ldr	r3, [sp, #12]
 80062b0:	2203      	movs	r2, #3
 80062b2:	701a      	strb	r2, [r3, #0]
 80062b4:	9803      	ldr	r0, [sp, #12]
 80062b6:	9902      	ldr	r1, [sp, #8]
 80062b8:	9a01      	ldr	r2, [sp, #4]
 80062ba:	f004 fab9 	bl	800a830 <spi_lld_send>
  (void) osalThreadSuspendS(&spip->thread);
 80062be:	9b03      	ldr	r3, [sp, #12]
 80062c0:	3308      	adds	r3, #8
 80062c2:	4618      	mov	r0, r3
 80062c4:	f7ff feac 	bl	8006020 <osalThreadSuspendS>
  osalSysUnlock();
 80062c8:	f7ff fea2 	bl	8006010 <osalSysUnlock>
}
 80062cc:	b005      	add	sp, #20
 80062ce:	f85d fb04 	ldr.w	pc, [sp], #4
 80062d2:	bf00      	nop
 80062d4:	f3af 8000 	nop.w
 80062d8:	f3af 8000 	nop.w
 80062dc:	f3af 8000 	nop.w

080062e0 <spiReceive>:
 * @param[in] n         number of words to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiReceive(SPIDriver *spip, size_t n, void *rxbuf) {
 80062e0:	b500      	push	{lr}
 80062e2:	b085      	sub	sp, #20
 80062e4:	9003      	str	r0, [sp, #12]
 80062e6:	9102      	str	r1, [sp, #8]
 80062e8:	9201      	str	r2, [sp, #4]

  osalDbgCheck((spip != NULL) && (n > 0U) && (rxbuf != NULL));

  osalSysLock();
 80062ea:	f7ff fe89 	bl	8006000 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartReceiveI(spip, n, rxbuf);
 80062ee:	9b03      	ldr	r3, [sp, #12]
 80062f0:	2203      	movs	r2, #3
 80062f2:	701a      	strb	r2, [r3, #0]
 80062f4:	9803      	ldr	r0, [sp, #12]
 80062f6:	9902      	ldr	r1, [sp, #8]
 80062f8:	9a01      	ldr	r2, [sp, #4]
 80062fa:	f004 fb19 	bl	800a930 <spi_lld_receive>
  (void) osalThreadSuspendS(&spip->thread);
 80062fe:	9b03      	ldr	r3, [sp, #12]
 8006300:	3308      	adds	r3, #8
 8006302:	4618      	mov	r0, r3
 8006304:	f7ff fe8c 	bl	8006020 <osalThreadSuspendS>
  osalSysUnlock();
 8006308:	f7ff fe82 	bl	8006010 <osalSysUnlock>
}
 800630c:	b005      	add	sp, #20
 800630e:	f85d fb04 	ldr.w	pc, [sp], #4
 8006312:	bf00      	nop
 8006314:	f3af 8000 	nop.w
 8006318:	f3af 8000 	nop.w
 800631c:	f3af 8000 	nop.w

08006320 <spiAcquireBus>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiAcquireBus(SPIDriver *spip) {
 8006320:	b500      	push	{lr}
 8006322:	b083      	sub	sp, #12
 8006324:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalMutexLock(&spip->mutex);
 8006326:	9b01      	ldr	r3, [sp, #4]
 8006328:	330c      	adds	r3, #12
 800632a:	4618      	mov	r0, r3
 800632c:	f7ff fe98 	bl	8006060 <osalMutexLock>
}
 8006330:	b003      	add	sp, #12
 8006332:	f85d fb04 	ldr.w	pc, [sp], #4
 8006336:	bf00      	nop
 8006338:	f3af 8000 	nop.w
 800633c:	f3af 8000 	nop.w

08006340 <spiReleaseBus>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiReleaseBus(SPIDriver *spip) {
 8006340:	b500      	push	{lr}
 8006342:	b083      	sub	sp, #12
 8006344:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalMutexUnlock(&spip->mutex);
 8006346:	9b01      	ldr	r3, [sp, #4]
 8006348:	330c      	adds	r3, #12
 800634a:	4618      	mov	r0, r3
 800634c:	f7ff fe98 	bl	8006080 <osalMutexUnlock>
}
 8006350:	b003      	add	sp, #12
 8006352:	f85d fb04 	ldr.w	pc, [sp], #4
 8006356:	bf00      	nop
 8006358:	f3af 8000 	nop.w
 800635c:	f3af 8000 	nop.w

08006360 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8006360:	b082      	sub	sp, #8
 8006362:	2320      	movs	r3, #32
 8006364:	9301      	str	r3, [sp, #4]
 8006366:	9b01      	ldr	r3, [sp, #4]
 8006368:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800636c:	b002      	add	sp, #8
 800636e:	4770      	bx	lr

08006370 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8006370:	b082      	sub	sp, #8
 8006372:	2300      	movs	r3, #0
 8006374:	9301      	str	r3, [sp, #4]
 8006376:	9b01      	ldr	r3, [sp, #4]
 8006378:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800637c:	b002      	add	sp, #8
 800637e:	4770      	bx	lr

08006380 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8006380:	b508      	push	{r3, lr}

  port_lock();
 8006382:	f7ff ffed 	bl	8006360 <port_lock>
}
 8006386:	bd08      	pop	{r3, pc}
 8006388:	f3af 8000 	nop.w
 800638c:	f3af 8000 	nop.w

08006390 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8006390:	b508      	push	{r3, lr}

  port_unlock();
 8006392:	f7ff ffed 	bl	8006370 <port_unlock>
}
 8006396:	bd08      	pop	{r3, pc}
 8006398:	f3af 8000 	nop.w
 800639c:	f3af 8000 	nop.w

080063a0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80063a0:	b508      	push	{r3, lr}

  port_lock();
 80063a2:	f7ff ffdd 	bl	8006360 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80063a6:	bd08      	pop	{r3, pc}
 80063a8:	f3af 8000 	nop.w
 80063ac:	f3af 8000 	nop.w

080063b0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80063b0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80063b2:	f7ff ffdd 	bl	8006370 <port_unlock>
}
 80063b6:	bd08      	pop	{r3, pc}
 80063b8:	f3af 8000 	nop.w
 80063bc:	f3af 8000 	nop.w

080063c0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 80063c0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 80063c2:	f7ff ffdd 	bl	8006380 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 80063c6:	bd08      	pop	{r3, pc}
 80063c8:	f3af 8000 	nop.w
 80063cc:	f3af 8000 	nop.w

080063d0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80063d0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 80063d2:	f7ff ffdd 	bl	8006390 <port_unlock_from_isr>
}
 80063d6:	bd08      	pop	{r3, pc}
 80063d8:	f3af 8000 	nop.w
 80063dc:	f3af 8000 	nop.w

080063e0 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 80063e0:	b508      	push	{r3, lr}

  chSysLock();
 80063e2:	f7ff ffdd 	bl	80063a0 <chSysLock>
}
 80063e6:	bd08      	pop	{r3, pc}
 80063e8:	f3af 8000 	nop.w
 80063ec:	f3af 8000 	nop.w

080063f0 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 80063f0:	b508      	push	{r3, lr}

  chSysUnlock();
 80063f2:	f7ff ffdd 	bl	80063b0 <chSysUnlock>
}
 80063f6:	bd08      	pop	{r3, pc}
 80063f8:	f3af 8000 	nop.w
 80063fc:	f3af 8000 	nop.w

08006400 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8006400:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8006402:	f7ff ffdd 	bl	80063c0 <chSysLockFromISR>
}
 8006406:	bd08      	pop	{r3, pc}
 8006408:	f3af 8000 	nop.w
 800640c:	f3af 8000 	nop.w

08006410 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8006410:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8006412:	f7ff ffdd 	bl	80063d0 <chSysUnlockFromISR>
}
 8006416:	bd08      	pop	{r3, pc}
 8006418:	f3af 8000 	nop.w
 800641c:	f3af 8000 	nop.w

08006420 <osalOsRescheduleS>:
 *          required in this scenario.
 * @note    Not implemented in this simplified OSAL.
 *
 * @sclass
 */
static inline void osalOsRescheduleS(void) {
 8006420:	b508      	push	{r3, lr}

  chSchRescheduleS();
 8006422:	f7fa fcad 	bl	8000d80 <chSchRescheduleS>
}
 8006426:	bd08      	pop	{r3, pc}
 8006428:	f3af 8000 	nop.w
 800642c:	f3af 8000 	nop.w

08006430 <get_hword>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static uint16_t get_hword(uint8_t *p) {
 8006430:	b084      	sub	sp, #16
 8006432:	9001      	str	r0, [sp, #4]
  uint16_t hw;

  hw  = (uint16_t)*p++;
 8006434:	9b01      	ldr	r3, [sp, #4]
 8006436:	1c5a      	adds	r2, r3, #1
 8006438:	9201      	str	r2, [sp, #4]
 800643a:	781b      	ldrb	r3, [r3, #0]
 800643c:	f8ad 300e 	strh.w	r3, [sp, #14]
  hw |= (uint16_t)*p << 8U;
 8006440:	9b01      	ldr	r3, [sp, #4]
 8006442:	781b      	ldrb	r3, [r3, #0]
 8006444:	021b      	lsls	r3, r3, #8
 8006446:	b29a      	uxth	r2, r3
 8006448:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 800644c:	4313      	orrs	r3, r2
 800644e:	b29b      	uxth	r3, r3
 8006450:	f8ad 300e 	strh.w	r3, [sp, #14]
  return hw;
 8006454:	f8bd 300e 	ldrh.w	r3, [sp, #14]
}
 8006458:	4618      	mov	r0, r3
 800645a:	b004      	add	sp, #16
 800645c:	4770      	bx	lr
 800645e:	bf00      	nop

08006460 <set_address>:
/**
 * @brief  SET ADDRESS transaction callback.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {
 8006460:	b500      	push	{lr}
 8006462:	b083      	sub	sp, #12
 8006464:	9001      	str	r0, [sp, #4]

  usbp->address = usbp->setup[2];
 8006466:	9b01      	ldr	r3, [sp, #4]
 8006468:	f893 205e 	ldrb.w	r2, [r3, #94]	; 0x5e
 800646c:	9b01      	ldr	r3, [sp, #4]
 800646e:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66
  usb_lld_set_address(usbp);
 8006472:	9801      	ldr	r0, [sp, #4]
 8006474:	f002 fca4 	bl	8008dc0 <usb_lld_set_address>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8006478:	9b01      	ldr	r3, [sp, #4]
 800647a:	685b      	ldr	r3, [r3, #4]
 800647c:	681b      	ldr	r3, [r3, #0]
 800647e:	2b00      	cmp	r3, #0
 8006480:	d005      	beq.n	800648e <set_address+0x2e>
 8006482:	9b01      	ldr	r3, [sp, #4]
 8006484:	685b      	ldr	r3, [r3, #4]
 8006486:	681b      	ldr	r3, [r3, #0]
 8006488:	9801      	ldr	r0, [sp, #4]
 800648a:	2101      	movs	r1, #1
 800648c:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 800648e:	9b01      	ldr	r3, [sp, #4]
 8006490:	2203      	movs	r2, #3
 8006492:	701a      	strb	r2, [r3, #0]
}
 8006494:	b003      	add	sp, #12
 8006496:	f85d fb04 	ldr.w	pc, [sp], #4
 800649a:	bf00      	nop
 800649c:	f3af 8000 	nop.w

080064a0 <default_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @return              The request handling exit code.
 * @retval false        Request not recognized by the handler or error.
 * @retval true         Request handled.
 */
static bool default_handler(USBDriver *usbp) {
 80064a0:	b570      	push	{r4, r5, r6, lr}
 80064a2:	b084      	sub	sp, #16
 80064a4:	9001      	str	r0, [sp, #4]
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80064a6:	9b01      	ldr	r3, [sp, #4]
 80064a8:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 80064ac:	f003 027f 	and.w	r2, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
 80064b0:	9b01      	ldr	r3, [sp, #4]
 80064b2:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 80064b6:	021b      	lsls	r3, r3, #8
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
                                        USB_RTYPE_TYPE_MASK)) |
 80064b8:	4313      	orrs	r3, r2
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80064ba:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 80064be:	d05a      	beq.n	8006576 <default_handler+0xd6>
 80064c0:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 80064c4:	d812      	bhi.n	80064ec <default_handler+0x4c>
 80064c6:	2b02      	cmp	r3, #2
 80064c8:	f000 810f 	beq.w	80066ea <default_handler+0x24a>
 80064cc:	2b02      	cmp	r3, #2
 80064ce:	d805      	bhi.n	80064dc <default_handler+0x3c>
 80064d0:	2b00      	cmp	r3, #0
 80064d2:	d028      	beq.n	8006526 <default_handler+0x86>
 80064d4:	2b01      	cmp	r3, #1
 80064d6:	f000 80fd 	beq.w	80066d4 <default_handler+0x234>
 80064da:	e1c7      	b.n	800686c <default_handler+0x3cc>
 80064dc:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80064e0:	d02e      	beq.n	8006540 <default_handler+0xa0>
 80064e2:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
 80064e6:	f000 8157 	beq.w	8006798 <default_handler+0x2f8>
 80064ea:	e1bf      	b.n	800686c <default_handler+0x3cc>
 80064ec:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 80064f0:	d074      	beq.n	80065dc <default_handler+0x13c>
 80064f2:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 80064f6:	d808      	bhi.n	800650a <default_handler+0x6a>
 80064f8:	f240 3202 	movw	r2, #770	; 0x302
 80064fc:	4293      	cmp	r3, r2
 80064fe:	f000 8180 	beq.w	8006802 <default_handler+0x362>
 8006502:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8006506:	d051      	beq.n	80065ac <default_handler+0x10c>
 8006508:	e1b0      	b.n	800686c <default_handler+0x3cc>
 800650a:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
 800650e:	f000 8098 	beq.w	8006642 <default_handler+0x1a2>
 8006512:	f640 4202 	movw	r2, #3074	; 0xc02
 8006516:	4293      	cmp	r3, r2
 8006518:	f000 80dc 	beq.w	80066d4 <default_handler+0x234>
 800651c:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8006520:	f000 8082 	beq.w	8006628 <default_handler+0x188>
 8006524:	e1a2      	b.n	800686c <default_handler+0x3cc>
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Just returns the current status word.*/
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 8006526:	9b01      	ldr	r3, [sp, #4]
 8006528:	f103 0264 	add.w	r2, r3, #100	; 0x64
 800652c:	9b01      	ldr	r3, [sp, #4]
 800652e:	651a      	str	r2, [r3, #80]	; 0x50
 8006530:	9b01      	ldr	r3, [sp, #4]
 8006532:	2202      	movs	r2, #2
 8006534:	655a      	str	r2, [r3, #84]	; 0x54
 8006536:	9b01      	ldr	r3, [sp, #4]
 8006538:	2200      	movs	r2, #0
 800653a:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 800653c:	2301      	movs	r3, #1
 800653e:	e196      	b.n	800686e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8006540:	9b01      	ldr	r3, [sp, #4]
 8006542:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 8006546:	2b01      	cmp	r3, #1
 8006548:	d113      	bne.n	8006572 <default_handler+0xd2>
      usbp->status &= ~2U;
 800654a:	9b01      	ldr	r3, [sp, #4]
 800654c:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
 8006550:	f023 0302 	bic.w	r3, r3, #2
 8006554:	b29a      	uxth	r2, r3
 8006556:	9b01      	ldr	r3, [sp, #4]
 8006558:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800655c:	9b01      	ldr	r3, [sp, #4]
 800655e:	2200      	movs	r2, #0
 8006560:	651a      	str	r2, [r3, #80]	; 0x50
 8006562:	9b01      	ldr	r3, [sp, #4]
 8006564:	2200      	movs	r2, #0
 8006566:	655a      	str	r2, [r3, #84]	; 0x54
 8006568:	9b01      	ldr	r3, [sp, #4]
 800656a:	2200      	movs	r2, #0
 800656c:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 800656e:	2301      	movs	r3, #1
 8006570:	e17d      	b.n	800686e <default_handler+0x3ce>
    }
    return false;
 8006572:	2300      	movs	r3, #0
 8006574:	e17b      	b.n	800686e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8006576:	9b01      	ldr	r3, [sp, #4]
 8006578:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 800657c:	2b01      	cmp	r3, #1
 800657e:	d113      	bne.n	80065a8 <default_handler+0x108>
      usbp->status |= 2U;
 8006580:	9b01      	ldr	r3, [sp, #4]
 8006582:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
 8006586:	f043 0302 	orr.w	r3, r3, #2
 800658a:	b29a      	uxth	r2, r3
 800658c:	9b01      	ldr	r3, [sp, #4]
 800658e:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8006592:	9b01      	ldr	r3, [sp, #4]
 8006594:	2200      	movs	r2, #0
 8006596:	651a      	str	r2, [r3, #80]	; 0x50
 8006598:	9b01      	ldr	r3, [sp, #4]
 800659a:	2200      	movs	r2, #0
 800659c:	655a      	str	r2, [r3, #84]	; 0x54
 800659e:	9b01      	ldr	r3, [sp, #4]
 80065a0:	2200      	movs	r2, #0
 80065a2:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 80065a4:	2301      	movs	r3, #1
 80065a6:	e162      	b.n	800686e <default_handler+0x3ce>
    }
    return false;
 80065a8:	2300      	movs	r3, #0
 80065aa:	e160      	b.n	800686e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 80065ac:	9b01      	ldr	r3, [sp, #4]
 80065ae:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 80065b2:	2b00      	cmp	r3, #0
 80065b4:	d107      	bne.n	80065c6 <default_handler+0x126>
        (usbp->setup[1] == USB_REQ_SET_ADDRESS)) {
 80065b6:	9b01      	ldr	r3, [sp, #4]
 80065b8:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 80065bc:	2b05      	cmp	r3, #5
 80065be:	d102      	bne.n	80065c6 <default_handler+0x126>
        (usbp->setup[1] == USB_REQ_SET_ADDRESS)) {
      set_address(usbp);
 80065c0:	9801      	ldr	r0, [sp, #4]
 80065c2:	f7ff ff4d 	bl	8006460 <set_address>
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 80065c6:	9b01      	ldr	r3, [sp, #4]
 80065c8:	2200      	movs	r2, #0
 80065ca:	651a      	str	r2, [r3, #80]	; 0x50
 80065cc:	9b01      	ldr	r3, [sp, #4]
 80065ce:	2200      	movs	r2, #0
 80065d0:	655a      	str	r2, [r3, #84]	; 0x54
 80065d2:	9b01      	ldr	r3, [sp, #4]
 80065d4:	2200      	movs	r2, #0
 80065d6:	659a      	str	r2, [r3, #88]	; 0x58
#else
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
 80065d8:	2301      	movs	r3, #1
 80065da:	e148      	b.n	800686e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 80065dc:	9b01      	ldr	r3, [sp, #4]
 80065de:	685b      	ldr	r3, [r3, #4]
 80065e0:	685c      	ldr	r4, [r3, #4]
 80065e2:	9b01      	ldr	r3, [sp, #4]
 80065e4:	f893 605f 	ldrb.w	r6, [r3, #95]	; 0x5f
 80065e8:	9b01      	ldr	r3, [sp, #4]
 80065ea:	f893 505e 	ldrb.w	r5, [r3, #94]	; 0x5e
 80065ee:	9b01      	ldr	r3, [sp, #4]
 80065f0:	3360      	adds	r3, #96	; 0x60
 80065f2:	4618      	mov	r0, r3
 80065f4:	f7ff ff1c 	bl	8006430 <get_hword>
 80065f8:	4603      	mov	r3, r0
 80065fa:	9801      	ldr	r0, [sp, #4]
 80065fc:	4631      	mov	r1, r6
 80065fe:	462a      	mov	r2, r5
 8006600:	47a0      	blx	r4
 8006602:	9003      	str	r0, [sp, #12]
                                         usbp->setup[2],
                                         get_hword(&usbp->setup[4]));
    if (dp == NULL) {
 8006604:	9b03      	ldr	r3, [sp, #12]
 8006606:	2b00      	cmp	r3, #0
 8006608:	d101      	bne.n	800660e <default_handler+0x16e>
      return false;
 800660a:	2300      	movs	r3, #0
 800660c:	e12f      	b.n	800686e <default_handler+0x3ce>
    }
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 800660e:	9b03      	ldr	r3, [sp, #12]
 8006610:	685a      	ldr	r2, [r3, #4]
 8006612:	9b01      	ldr	r3, [sp, #4]
 8006614:	651a      	str	r2, [r3, #80]	; 0x50
 8006616:	9b03      	ldr	r3, [sp, #12]
 8006618:	681a      	ldr	r2, [r3, #0]
 800661a:	9b01      	ldr	r3, [sp, #4]
 800661c:	655a      	str	r2, [r3, #84]	; 0x54
 800661e:	9b01      	ldr	r3, [sp, #4]
 8006620:	2200      	movs	r2, #0
 8006622:	659a      	str	r2, [r3, #88]	; 0x58
    /*lint -restore*/
    return true;
 8006624:	2301      	movs	r3, #1
 8006626:	e122      	b.n	800686e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_CONFIGURATION << 8):
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 8006628:	9b01      	ldr	r3, [sp, #4]
 800662a:	f103 0267 	add.w	r2, r3, #103	; 0x67
 800662e:	9b01      	ldr	r3, [sp, #4]
 8006630:	651a      	str	r2, [r3, #80]	; 0x50
 8006632:	9b01      	ldr	r3, [sp, #4]
 8006634:	2201      	movs	r2, #1
 8006636:	655a      	str	r2, [r3, #84]	; 0x54
 8006638:	9b01      	ldr	r3, [sp, #4]
 800663a:	2200      	movs	r2, #0
 800663c:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 800663e:	2301      	movs	r3, #1
 8006640:	e115      	b.n	800686e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_CONFIGURATION << 8):
    /* Handling configuration selection from the host only if it is different
       from the current configuration.*/
    if (usbp->configuration != usbp->setup[2]) {
 8006642:	9b01      	ldr	r3, [sp, #4]
 8006644:	f893 2067 	ldrb.w	r2, [r3, #103]	; 0x67
 8006648:	9b01      	ldr	r3, [sp, #4]
 800664a:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 800664e:	429a      	cmp	r2, r3
 8006650:	d035      	beq.n	80066be <default_handler+0x21e>
      /* If the USB device is already active then we have to perform the clear
         procedure on the current configuration.*/
      if (usbp->state == USB_ACTIVE) {
 8006652:	9b01      	ldr	r3, [sp, #4]
 8006654:	781b      	ldrb	r3, [r3, #0]
 8006656:	2b04      	cmp	r3, #4
 8006658:	d118      	bne.n	800668c <default_handler+0x1ec>
        /* Current configuration cleared.*/
        osalSysLockFromISR ();
 800665a:	f7ff fed1 	bl	8006400 <osalSysLockFromISR>
        usbDisableEndpointsI(usbp);
 800665e:	9801      	ldr	r0, [sp, #4]
 8006660:	f000 f9be 	bl	80069e0 <usbDisableEndpointsI>
        osalSysUnlockFromISR ();
 8006664:	f7ff fed4 	bl	8006410 <osalSysUnlockFromISR>
        usbp->configuration = 0U;
 8006668:	9b01      	ldr	r3, [sp, #4]
 800666a:	2200      	movs	r2, #0
 800666c:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
        usbp->state = USB_SELECTED;
 8006670:	9b01      	ldr	r3, [sp, #4]
 8006672:	2203      	movs	r2, #3
 8006674:	701a      	strb	r2, [r3, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8006676:	9b01      	ldr	r3, [sp, #4]
 8006678:	685b      	ldr	r3, [r3, #4]
 800667a:	681b      	ldr	r3, [r3, #0]
 800667c:	2b00      	cmp	r3, #0
 800667e:	d005      	beq.n	800668c <default_handler+0x1ec>
 8006680:	9b01      	ldr	r3, [sp, #4]
 8006682:	685b      	ldr	r3, [r3, #4]
 8006684:	681b      	ldr	r3, [r3, #0]
 8006686:	9801      	ldr	r0, [sp, #4]
 8006688:	2103      	movs	r1, #3
 800668a:	4798      	blx	r3
      }
      if (usbp->setup[2] != 0U) {
 800668c:	9b01      	ldr	r3, [sp, #4]
 800668e:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 8006692:	2b00      	cmp	r3, #0
 8006694:	d013      	beq.n	80066be <default_handler+0x21e>
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
 8006696:	9b01      	ldr	r3, [sp, #4]
 8006698:	f893 205e 	ldrb.w	r2, [r3, #94]	; 0x5e
 800669c:	9b01      	ldr	r3, [sp, #4]
 800669e:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
        usbp->state = USB_ACTIVE;
 80066a2:	9b01      	ldr	r3, [sp, #4]
 80066a4:	2204      	movs	r2, #4
 80066a6:	701a      	strb	r2, [r3, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 80066a8:	9b01      	ldr	r3, [sp, #4]
 80066aa:	685b      	ldr	r3, [r3, #4]
 80066ac:	681b      	ldr	r3, [r3, #0]
 80066ae:	2b00      	cmp	r3, #0
 80066b0:	d005      	beq.n	80066be <default_handler+0x21e>
 80066b2:	9b01      	ldr	r3, [sp, #4]
 80066b4:	685b      	ldr	r3, [r3, #4]
 80066b6:	681b      	ldr	r3, [r3, #0]
 80066b8:	9801      	ldr	r0, [sp, #4]
 80066ba:	2102      	movs	r1, #2
 80066bc:	4798      	blx	r3
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 80066be:	9b01      	ldr	r3, [sp, #4]
 80066c0:	2200      	movs	r2, #0
 80066c2:	651a      	str	r2, [r3, #80]	; 0x50
 80066c4:	9b01      	ldr	r3, [sp, #4]
 80066c6:	2200      	movs	r2, #0
 80066c8:	655a      	str	r2, [r3, #84]	; 0x54
 80066ca:	9b01      	ldr	r3, [sp, #4]
 80066cc:	2200      	movs	r2, #0
 80066ce:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 80066d0:	2301      	movs	r3, #1
 80066d2:	e0cc      	b.n	800686e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_STATUS << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SYNCH_FRAME << 8):
    /* Just sending two zero bytes, the application can change the behavior
       using a hook..*/
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 80066d4:	9b01      	ldr	r3, [sp, #4]
 80066d6:	4a67      	ldr	r2, [pc, #412]	; (8006874 <default_handler+0x3d4>)
 80066d8:	651a      	str	r2, [r3, #80]	; 0x50
 80066da:	9b01      	ldr	r3, [sp, #4]
 80066dc:	2202      	movs	r2, #2
 80066de:	655a      	str	r2, [r3, #84]	; 0x54
 80066e0:	9b01      	ldr	r3, [sp, #4]
 80066e2:	2200      	movs	r2, #0
 80066e4:	659a      	str	r2, [r3, #88]	; 0x58
    /*lint -restore*/
    return true;
 80066e6:	2301      	movs	r3, #1
 80066e8:	e0c1      	b.n	800686e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 80066ea:	9b01      	ldr	r3, [sp, #4]
 80066ec:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 80066f0:	b2db      	uxtb	r3, r3
 80066f2:	b25b      	sxtb	r3, r3
 80066f4:	2b00      	cmp	r3, #0
 80066f6:	da27      	bge.n	8006748 <default_handler+0x2a8>
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 80066f8:	9b01      	ldr	r3, [sp, #4]
 80066fa:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 80066fe:	f003 030f 	and.w	r3, r3, #15
 8006702:	b2db      	uxtb	r3, r3
 8006704:	9801      	ldr	r0, [sp, #4]
 8006706:	4619      	mov	r1, r3
 8006708:	f002 fcd2 	bl	80090b0 <usb_lld_get_status_in>
 800670c:	4603      	mov	r3, r0
 800670e:	2b01      	cmp	r3, #1
 8006710:	d002      	beq.n	8006718 <default_handler+0x278>
 8006712:	2b02      	cmp	r3, #2
 8006714:	d00b      	beq.n	800672e <default_handler+0x28e>
 8006716:	e015      	b.n	8006744 <default_handler+0x2a4>
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8006718:	9b01      	ldr	r3, [sp, #4]
 800671a:	4a57      	ldr	r2, [pc, #348]	; (8006878 <default_handler+0x3d8>)
 800671c:	651a      	str	r2, [r3, #80]	; 0x50
 800671e:	9b01      	ldr	r3, [sp, #4]
 8006720:	2202      	movs	r2, #2
 8006722:	655a      	str	r2, [r3, #84]	; 0x54
 8006724:	9b01      	ldr	r3, [sp, #4]
 8006726:	2200      	movs	r2, #0
 8006728:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 800672a:	2301      	movs	r3, #1
 800672c:	e09f      	b.n	800686e <default_handler+0x3ce>
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 800672e:	9b01      	ldr	r3, [sp, #4]
 8006730:	4a52      	ldr	r2, [pc, #328]	; (800687c <default_handler+0x3dc>)
 8006732:	651a      	str	r2, [r3, #80]	; 0x50
 8006734:	9b01      	ldr	r3, [sp, #4]
 8006736:	2202      	movs	r2, #2
 8006738:	655a      	str	r2, [r3, #84]	; 0x54
 800673a:	9b01      	ldr	r3, [sp, #4]
 800673c:	2200      	movs	r2, #0
 800673e:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 8006740:	2301      	movs	r3, #1
 8006742:	e094      	b.n	800686e <default_handler+0x3ce>
      case EP_STATUS_DISABLED:
      default:
        return false;
 8006744:	2300      	movs	r3, #0
 8006746:	e092      	b.n	800686e <default_handler+0x3ce>
      }
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
 8006748:	9b01      	ldr	r3, [sp, #4]
 800674a:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 800674e:	f003 030f 	and.w	r3, r3, #15
 8006752:	b2db      	uxtb	r3, r3
 8006754:	9801      	ldr	r0, [sp, #4]
 8006756:	4619      	mov	r1, r3
 8006758:	f002 fc8a 	bl	8009070 <usb_lld_get_status_out>
 800675c:	4603      	mov	r3, r0
 800675e:	2b01      	cmp	r3, #1
 8006760:	d002      	beq.n	8006768 <default_handler+0x2c8>
 8006762:	2b02      	cmp	r3, #2
 8006764:	d00b      	beq.n	800677e <default_handler+0x2de>
 8006766:	e015      	b.n	8006794 <default_handler+0x2f4>
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8006768:	9b01      	ldr	r3, [sp, #4]
 800676a:	4a43      	ldr	r2, [pc, #268]	; (8006878 <default_handler+0x3d8>)
 800676c:	651a      	str	r2, [r3, #80]	; 0x50
 800676e:	9b01      	ldr	r3, [sp, #4]
 8006770:	2202      	movs	r2, #2
 8006772:	655a      	str	r2, [r3, #84]	; 0x54
 8006774:	9b01      	ldr	r3, [sp, #4]
 8006776:	2200      	movs	r2, #0
 8006778:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 800677a:	2301      	movs	r3, #1
 800677c:	e077      	b.n	800686e <default_handler+0x3ce>
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 800677e:	9b01      	ldr	r3, [sp, #4]
 8006780:	4a3e      	ldr	r2, [pc, #248]	; (800687c <default_handler+0x3dc>)
 8006782:	651a      	str	r2, [r3, #80]	; 0x50
 8006784:	9b01      	ldr	r3, [sp, #4]
 8006786:	2202      	movs	r2, #2
 8006788:	655a      	str	r2, [r3, #84]	; 0x54
 800678a:	9b01      	ldr	r3, [sp, #4]
 800678c:	2200      	movs	r2, #0
 800678e:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 8006790:	2301      	movs	r3, #1
 8006792:	e06c      	b.n	800686e <default_handler+0x3ce>
      case EP_STATUS_DISABLED:
      default:
        return false;
 8006794:	2300      	movs	r3, #0
 8006796:	e06a      	b.n	800686e <default_handler+0x3ce>
      }
    }
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8006798:	9b01      	ldr	r3, [sp, #4]
 800679a:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 800679e:	2b00      	cmp	r3, #0
 80067a0:	d001      	beq.n	80067a6 <default_handler+0x306>
      return false;
 80067a2:	2300      	movs	r3, #0
 80067a4:	e063      	b.n	800686e <default_handler+0x3ce>
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 80067a6:	9b01      	ldr	r3, [sp, #4]
 80067a8:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 80067ac:	f003 030f 	and.w	r3, r3, #15
 80067b0:	2b00      	cmp	r3, #0
 80067b2:	d01b      	beq.n	80067ec <default_handler+0x34c>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 80067b4:	9b01      	ldr	r3, [sp, #4]
 80067b6:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 80067ba:	b2db      	uxtb	r3, r3
 80067bc:	b25b      	sxtb	r3, r3
 80067be:	2b00      	cmp	r3, #0
 80067c0:	da0a      	bge.n	80067d8 <default_handler+0x338>
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 80067c2:	9b01      	ldr	r3, [sp, #4]
 80067c4:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 80067c8:	f003 030f 	and.w	r3, r3, #15
 80067cc:	b2db      	uxtb	r3, r3
 80067ce:	9801      	ldr	r0, [sp, #4]
 80067d0:	4619      	mov	r1, r3
 80067d2:	f002 fe55 	bl	8009480 <usb_lld_clear_in>
 80067d6:	e009      	b.n	80067ec <default_handler+0x34c>
      }
      else {
        usb_lld_clear_out(usbp, usbp->setup[4] & 0x0FU);
 80067d8:	9b01      	ldr	r3, [sp, #4]
 80067da:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 80067de:	f003 030f 	and.w	r3, r3, #15
 80067e2:	b2db      	uxtb	r3, r3
 80067e4:	9801      	ldr	r0, [sp, #4]
 80067e6:	4619      	mov	r1, r3
 80067e8:	f002 fe2a 	bl	8009440 <usb_lld_clear_out>
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 80067ec:	9b01      	ldr	r3, [sp, #4]
 80067ee:	2200      	movs	r2, #0
 80067f0:	651a      	str	r2, [r3, #80]	; 0x50
 80067f2:	9b01      	ldr	r3, [sp, #4]
 80067f4:	2200      	movs	r2, #0
 80067f6:	655a      	str	r2, [r3, #84]	; 0x54
 80067f8:	9b01      	ldr	r3, [sp, #4]
 80067fa:	2200      	movs	r2, #0
 80067fc:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 80067fe:	2301      	movs	r3, #1
 8006800:	e035      	b.n	800686e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8006802:	9b01      	ldr	r3, [sp, #4]
 8006804:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 8006808:	2b00      	cmp	r3, #0
 800680a:	d001      	beq.n	8006810 <default_handler+0x370>
      return false;
 800680c:	2300      	movs	r3, #0
 800680e:	e02e      	b.n	800686e <default_handler+0x3ce>
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8006810:	9b01      	ldr	r3, [sp, #4]
 8006812:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006816:	f003 030f 	and.w	r3, r3, #15
 800681a:	2b00      	cmp	r3, #0
 800681c:	d01b      	beq.n	8006856 <default_handler+0x3b6>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 800681e:	9b01      	ldr	r3, [sp, #4]
 8006820:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006824:	b2db      	uxtb	r3, r3
 8006826:	b25b      	sxtb	r3, r3
 8006828:	2b00      	cmp	r3, #0
 800682a:	da0a      	bge.n	8006842 <default_handler+0x3a2>
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 800682c:	9b01      	ldr	r3, [sp, #4]
 800682e:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006832:	f003 030f 	and.w	r3, r3, #15
 8006836:	b2db      	uxtb	r3, r3
 8006838:	9801      	ldr	r0, [sp, #4]
 800683a:	4619      	mov	r1, r3
 800683c:	f002 fde0 	bl	8009400 <usb_lld_stall_in>
 8006840:	e009      	b.n	8006856 <default_handler+0x3b6>
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
 8006842:	9b01      	ldr	r3, [sp, #4]
 8006844:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006848:	f003 030f 	and.w	r3, r3, #15
 800684c:	b2db      	uxtb	r3, r3
 800684e:	9801      	ldr	r0, [sp, #4]
 8006850:	4619      	mov	r1, r3
 8006852:	f002 fdb5 	bl	80093c0 <usb_lld_stall_out>
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8006856:	9b01      	ldr	r3, [sp, #4]
 8006858:	2200      	movs	r2, #0
 800685a:	651a      	str	r2, [r3, #80]	; 0x50
 800685c:	9b01      	ldr	r3, [sp, #4]
 800685e:	2200      	movs	r2, #0
 8006860:	655a      	str	r2, [r3, #84]	; 0x54
 8006862:	9b01      	ldr	r3, [sp, #4]
 8006864:	2200      	movs	r2, #0
 8006866:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 8006868:	2301      	movs	r3, #1
 800686a:	e000      	b.n	800686e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_INTERFACE << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_SET_INTERFACE << 8):
    /* All the above requests are not handled here, if you need them then
       use the hook mechanism and provide handling.*/
  default:
    return false;
 800686c:	2300      	movs	r3, #0
  }
}
 800686e:	4618      	mov	r0, r3
 8006870:	b004      	add	sp, #16
 8006872:	bd70      	pop	{r4, r5, r6, pc}
 8006874:	08015f80 	.word	0x08015f80
 8006878:	08015f88 	.word	0x08015f88
 800687c:	08015f84 	.word	0x08015f84

08006880 <usbInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void usbInit(void) {
 8006880:	b508      	push	{r3, lr}

  usb_lld_init();
 8006882:	f002 f92d 	bl	8008ae0 <usb_lld_init>
}
 8006886:	bd08      	pop	{r3, pc}
 8006888:	f3af 8000 	nop.w
 800688c:	f3af 8000 	nop.w

08006890 <usbObjectInit>:
 *
 * @param[out] usbp     pointer to the @p USBDriver object
 *
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
 8006890:	b084      	sub	sp, #16
 8006892:	9001      	str	r0, [sp, #4]
  unsigned i;

  usbp->state        = USB_STOP;
 8006894:	9b01      	ldr	r3, [sp, #4]
 8006896:	2201      	movs	r2, #1
 8006898:	701a      	strb	r2, [r3, #0]
  usbp->config       = NULL;
 800689a:	9b01      	ldr	r3, [sp, #4]
 800689c:	2200      	movs	r2, #0
 800689e:	605a      	str	r2, [r3, #4]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 80068a0:	2300      	movs	r3, #0
 80068a2:	9303      	str	r3, [sp, #12]
 80068a4:	e00f      	b.n	80068c6 <usbObjectInit+0x36>
    usbp->in_params[i]  = NULL;
 80068a6:	9a01      	ldr	r2, [sp, #4]
 80068a8:	9b03      	ldr	r3, [sp, #12]
 80068aa:	3308      	adds	r3, #8
 80068ac:	009b      	lsls	r3, r3, #2
 80068ae:	4413      	add	r3, r2
 80068b0:	2200      	movs	r2, #0
 80068b2:	605a      	str	r2, [r3, #4]
    usbp->out_params[i] = NULL;
 80068b4:	9b01      	ldr	r3, [sp, #4]
 80068b6:	9a03      	ldr	r2, [sp, #12]
 80068b8:	320e      	adds	r2, #14
 80068ba:	2100      	movs	r1, #0
 80068bc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 80068c0:	9b03      	ldr	r3, [sp, #12]
 80068c2:	3301      	adds	r3, #1
 80068c4:	9303      	str	r3, [sp, #12]
 80068c6:	9b03      	ldr	r3, [sp, #12]
 80068c8:	2b04      	cmp	r3, #4
 80068ca:	d9ec      	bls.n	80068a6 <usbObjectInit+0x16>
    usbp->in_params[i]  = NULL;
    usbp->out_params[i] = NULL;
  }
  usbp->transmitting = 0;
 80068cc:	9b01      	ldr	r3, [sp, #4]
 80068ce:	2200      	movs	r2, #0
 80068d0:	811a      	strh	r2, [r3, #8]
  usbp->receiving    = 0;
 80068d2:	9b01      	ldr	r3, [sp, #4]
 80068d4:	2200      	movs	r2, #0
 80068d6:	815a      	strh	r2, [r3, #10]
}
 80068d8:	b004      	add	sp, #16
 80068da:	4770      	bx	lr
 80068dc:	f3af 8000 	nop.w

080068e0 <usbStart>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] config    pointer to the @p USBConfig object
 *
 * @api
 */
void usbStart(USBDriver *usbp, const USBConfig *config) {
 80068e0:	b500      	push	{lr}
 80068e2:	b085      	sub	sp, #20
 80068e4:	9001      	str	r0, [sp, #4]
 80068e6:	9100      	str	r1, [sp, #0]
  unsigned i;

  osalDbgCheck((usbp != NULL) && (config != NULL));

  osalSysLock();
 80068e8:	f7ff fd7a 	bl	80063e0 <osalSysLock>
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
 80068ec:	9b01      	ldr	r3, [sp, #4]
 80068ee:	9a00      	ldr	r2, [sp, #0]
 80068f0:	605a      	str	r2, [r3, #4]
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 80068f2:	2300      	movs	r3, #0
 80068f4:	9303      	str	r3, [sp, #12]
 80068f6:	e009      	b.n	800690c <usbStart+0x2c>
    usbp->epc[i] = NULL;
 80068f8:	9a01      	ldr	r2, [sp, #4]
 80068fa:	9b03      	ldr	r3, [sp, #12]
 80068fc:	3302      	adds	r3, #2
 80068fe:	009b      	lsls	r3, r3, #2
 8006900:	4413      	add	r3, r2
 8006902:	2200      	movs	r2, #0
 8006904:	605a      	str	r2, [r3, #4]

  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006906:	9b03      	ldr	r3, [sp, #12]
 8006908:	3301      	adds	r3, #1
 800690a:	9303      	str	r3, [sp, #12]
 800690c:	9b03      	ldr	r3, [sp, #12]
 800690e:	2b05      	cmp	r3, #5
 8006910:	d9f2      	bls.n	80068f8 <usbStart+0x18>
    usbp->epc[i] = NULL;
  }
  usb_lld_start(usbp);
 8006912:	9801      	ldr	r0, [sp, #4]
 8006914:	f002 f8fc 	bl	8008b10 <usb_lld_start>
  usbp->state = USB_READY;
 8006918:	9b01      	ldr	r3, [sp, #4]
 800691a:	2202      	movs	r2, #2
 800691c:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 800691e:	f7ff fd67 	bl	80063f0 <osalSysUnlock>
}
 8006922:	b005      	add	sp, #20
 8006924:	f85d fb04 	ldr.w	pc, [sp], #4
 8006928:	f3af 8000 	nop.w
 800692c:	f3af 8000 	nop.w

08006930 <usbStop>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @api
 */
void usbStop(USBDriver *usbp) {
 8006930:	b500      	push	{lr}
 8006932:	b085      	sub	sp, #20
 8006934:	9001      	str	r0, [sp, #4]
  unsigned i;

  osalDbgCheck(usbp != NULL);

  osalSysLock();
 8006936:	f7ff fd53 	bl	80063e0 <osalSysLock>
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY) ||
                (usbp->state == USB_SELECTED) || (usbp->state == USB_ACTIVE) ||
                (usbp->state == USB_SUSPENDED),
                "invalid state");

  usb_lld_stop(usbp);
 800693a:	9801      	ldr	r0, [sp, #4]
 800693c:	f002 f978 	bl	8008c30 <usb_lld_stop>
  usbp->state = USB_STOP;
 8006940:	9b01      	ldr	r3, [sp, #4]
 8006942:	2201      	movs	r2, #1
 8006944:	701a      	strb	r2, [r3, #0]

  /* Resetting all ongoing synchronous operations.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006946:	2300      	movs	r3, #0
 8006948:	9303      	str	r3, [sp, #12]
 800694a:	e009      	b.n	8006960 <usbStop+0x30>
      if (usbp->epc[i]->out_state != NULL) {
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
    }
#endif
    usbp->epc[i] = NULL;
 800694c:	9a01      	ldr	r2, [sp, #4]
 800694e:	9b03      	ldr	r3, [sp, #12]
 8006950:	3302      	adds	r3, #2
 8006952:	009b      	lsls	r3, r3, #2
 8006954:	4413      	add	r3, r2
 8006956:	2200      	movs	r2, #0
 8006958:	605a      	str	r2, [r3, #4]

  usb_lld_stop(usbp);
  usbp->state = USB_STOP;

  /* Resetting all ongoing synchronous operations.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 800695a:	9b03      	ldr	r3, [sp, #12]
 800695c:	3301      	adds	r3, #1
 800695e:	9303      	str	r3, [sp, #12]
 8006960:	9b03      	ldr	r3, [sp, #12]
 8006962:	2b05      	cmp	r3, #5
 8006964:	d9f2      	bls.n	800694c <usbStop+0x1c>
      }
    }
#endif
    usbp->epc[i] = NULL;
  }
  osalOsRescheduleS();
 8006966:	f7ff fd5b 	bl	8006420 <osalOsRescheduleS>

  osalSysUnlock();
 800696a:	f7ff fd41 	bl	80063f0 <osalSysUnlock>
}
 800696e:	b005      	add	sp, #20
 8006970:	f85d fb04 	ldr.w	pc, [sp], #4
 8006974:	f3af 8000 	nop.w
 8006978:	f3af 8000 	nop.w
 800697c:	f3af 8000 	nop.w

08006980 <usbInitEndpointI>:
 * @param[in] epcp      the endpoint configuration
 *
 * @iclass
 */
void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
                      const USBEndpointConfig *epcp) {
 8006980:	b500      	push	{lr}
 8006982:	b085      	sub	sp, #20
 8006984:	9003      	str	r0, [sp, #12]
 8006986:	460b      	mov	r3, r1
 8006988:	9201      	str	r2, [sp, #4]
 800698a:	f88d 300b 	strb.w	r3, [sp, #11]
  osalDbgAssert(usbp->state == USB_ACTIVE,
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");

  /* Logically enabling the endpoint in the USBDriver structure.*/
  usbp->epc[ep] = epcp;
 800698e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006992:	9a03      	ldr	r2, [sp, #12]
 8006994:	3302      	adds	r3, #2
 8006996:	009b      	lsls	r3, r3, #2
 8006998:	4413      	add	r3, r2
 800699a:	9a01      	ldr	r2, [sp, #4]
 800699c:	605a      	str	r2, [r3, #4]

  /* Clearing the state structures, custom fields as well.*/
  if (epcp->in_state != NULL) {
 800699e:	9b01      	ldr	r3, [sp, #4]
 80069a0:	695b      	ldr	r3, [r3, #20]
 80069a2:	2b00      	cmp	r3, #0
 80069a4:	d006      	beq.n	80069b4 <usbInitEndpointI+0x34>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 80069a6:	9b01      	ldr	r3, [sp, #4]
 80069a8:	695b      	ldr	r3, [r3, #20]
 80069aa:	4618      	mov	r0, r3
 80069ac:	2100      	movs	r1, #0
 80069ae:	2210      	movs	r2, #16
 80069b0:	f00f f9d6 	bl	8015d60 <memset>
  }
  if (epcp->out_state != NULL) {
 80069b4:	9b01      	ldr	r3, [sp, #4]
 80069b6:	699b      	ldr	r3, [r3, #24]
 80069b8:	2b00      	cmp	r3, #0
 80069ba:	d006      	beq.n	80069ca <usbInitEndpointI+0x4a>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 80069bc:	9b01      	ldr	r3, [sp, #4]
 80069be:	699b      	ldr	r3, [r3, #24]
 80069c0:	4618      	mov	r0, r3
 80069c2:	2100      	movs	r1, #0
 80069c4:	2210      	movs	r2, #16
 80069c6:	f00f f9cb 	bl	8015d60 <memset>
  }

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
 80069ca:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80069ce:	9803      	ldr	r0, [sp, #12]
 80069d0:	4619      	mov	r1, r3
 80069d2:	f002 fa0d 	bl	8008df0 <usb_lld_init_endpoint>
}
 80069d6:	b005      	add	sp, #20
 80069d8:	f85d fb04 	ldr.w	pc, [sp], #4
 80069dc:	f3af 8000 	nop.w

080069e0 <usbDisableEndpointsI>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @iclass
 */
void usbDisableEndpointsI(USBDriver *usbp) {
 80069e0:	b500      	push	{lr}
 80069e2:	b085      	sub	sp, #20
 80069e4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
 80069e6:	9b01      	ldr	r3, [sp, #4]
 80069e8:	891b      	ldrh	r3, [r3, #8]
 80069ea:	f003 0301 	and.w	r3, r3, #1
 80069ee:	b29a      	uxth	r2, r3
 80069f0:	9b01      	ldr	r3, [sp, #4]
 80069f2:	811a      	strh	r2, [r3, #8]
  usbp->receiving    &= 1U;
 80069f4:	9b01      	ldr	r3, [sp, #4]
 80069f6:	895b      	ldrh	r3, [r3, #10]
 80069f8:	f003 0301 	and.w	r3, r3, #1
 80069fc:	b29a      	uxth	r2, r3
 80069fe:	9b01      	ldr	r3, [sp, #4]
 8006a00:	815a      	strh	r2, [r3, #10]

  for (i = 1; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006a02:	2301      	movs	r3, #1
 8006a04:	9303      	str	r3, [sp, #12]
 8006a06:	e009      	b.n	8006a1c <usbDisableEndpointsI+0x3c>
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 8006a08:	9a01      	ldr	r2, [sp, #4]
 8006a0a:	9b03      	ldr	r3, [sp, #12]
 8006a0c:	3302      	adds	r3, #2
 8006a0e:	009b      	lsls	r3, r3, #2
 8006a10:	4413      	add	r3, r2
 8006a12:	2200      	movs	r2, #0
 8006a14:	605a      	str	r2, [r3, #4]
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
  usbp->receiving    &= 1U;

  for (i = 1; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006a16:	9b03      	ldr	r3, [sp, #12]
 8006a18:	3301      	adds	r3, #1
 8006a1a:	9303      	str	r3, [sp, #12]
 8006a1c:	9b03      	ldr	r3, [sp, #12]
 8006a1e:	2b05      	cmp	r3, #5
 8006a20:	d9f2      	bls.n	8006a08 <usbDisableEndpointsI+0x28>
#endif
    usbp->epc[i] = NULL;
  }

  /* Low level endpoints deactivation.*/
  usb_lld_disable_endpoints(usbp);
 8006a22:	9801      	ldr	r0, [sp, #4]
 8006a24:	f002 fb14 	bl	8009050 <usb_lld_disable_endpoints>
}
 8006a28:	b005      	add	sp, #20
 8006a2a:	f85d fb04 	ldr.w	pc, [sp], #4
 8006a2e:	bf00      	nop

08006a30 <usbStartReceiveI>:
 *                      the packet size because the excess is discarded.
 *
 * @iclass
 */
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
                      uint8_t *buf, size_t n) {
 8006a30:	b500      	push	{lr}
 8006a32:	b087      	sub	sp, #28
 8006a34:	9003      	str	r0, [sp, #12]
 8006a36:	9201      	str	r2, [sp, #4]
 8006a38:	9300      	str	r3, [sp, #0]
 8006a3a:	460b      	mov	r3, r1
 8006a3c:	f88d 300b 	strb.w	r3, [sp, #11]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8006a40:	9b03      	ldr	r3, [sp, #12]
 8006a42:	895a      	ldrh	r2, [r3, #10]
 8006a44:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006a48:	2101      	movs	r1, #1
 8006a4a:	fa01 f303 	lsl.w	r3, r1, r3
 8006a4e:	b29b      	uxth	r3, r3
 8006a50:	4313      	orrs	r3, r2
 8006a52:	b29a      	uxth	r2, r3
 8006a54:	9b03      	ldr	r3, [sp, #12]
 8006a56:	815a      	strh	r2, [r3, #10]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 8006a58:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006a5c:	9a03      	ldr	r2, [sp, #12]
 8006a5e:	3302      	adds	r3, #2
 8006a60:	009b      	lsls	r3, r3, #2
 8006a62:	4413      	add	r3, r2
 8006a64:	685b      	ldr	r3, [r3, #4]
 8006a66:	699b      	ldr	r3, [r3, #24]
 8006a68:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  osp->rxbuf  = buf;
 8006a6a:	9b05      	ldr	r3, [sp, #20]
 8006a6c:	9a01      	ldr	r2, [sp, #4]
 8006a6e:	609a      	str	r2, [r3, #8]
  osp->rxsize = n;
 8006a70:	9b05      	ldr	r3, [sp, #20]
 8006a72:	9a00      	ldr	r2, [sp, #0]
 8006a74:	601a      	str	r2, [r3, #0]
  osp->rxcnt  = 0;
 8006a76:	9b05      	ldr	r3, [sp, #20]
 8006a78:	2200      	movs	r2, #0
 8006a7a:	605a      	str	r2, [r3, #4]
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 8006a7c:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006a80:	9803      	ldr	r0, [sp, #12]
 8006a82:	4619      	mov	r1, r3
 8006a84:	f002 fb4c 	bl	8009120 <usb_lld_start_out>
}
 8006a88:	b007      	add	sp, #28
 8006a8a:	f85d fb04 	ldr.w	pc, [sp], #4
 8006a8e:	bf00      	nop

08006a90 <usbStartTransmitI>:
 * @param[in] n         transaction size
 *
 * @iclass
 */
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
 8006a90:	b500      	push	{lr}
 8006a92:	b087      	sub	sp, #28
 8006a94:	9003      	str	r0, [sp, #12]
 8006a96:	9201      	str	r2, [sp, #4]
 8006a98:	9300      	str	r3, [sp, #0]
 8006a9a:	460b      	mov	r3, r1
 8006a9c:	f88d 300b 	strb.w	r3, [sp, #11]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8006aa0:	9b03      	ldr	r3, [sp, #12]
 8006aa2:	891a      	ldrh	r2, [r3, #8]
 8006aa4:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006aa8:	2101      	movs	r1, #1
 8006aaa:	fa01 f303 	lsl.w	r3, r1, r3
 8006aae:	b29b      	uxth	r3, r3
 8006ab0:	4313      	orrs	r3, r2
 8006ab2:	b29a      	uxth	r2, r3
 8006ab4:	9b03      	ldr	r3, [sp, #12]
 8006ab6:	811a      	strh	r2, [r3, #8]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 8006ab8:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006abc:	9a03      	ldr	r2, [sp, #12]
 8006abe:	3302      	adds	r3, #2
 8006ac0:	009b      	lsls	r3, r3, #2
 8006ac2:	4413      	add	r3, r2
 8006ac4:	685b      	ldr	r3, [r3, #4]
 8006ac6:	695b      	ldr	r3, [r3, #20]
 8006ac8:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  isp->txbuf  = buf;
 8006aca:	9b05      	ldr	r3, [sp, #20]
 8006acc:	9a01      	ldr	r2, [sp, #4]
 8006ace:	609a      	str	r2, [r3, #8]
  isp->txsize = n;
 8006ad0:	9b05      	ldr	r3, [sp, #20]
 8006ad2:	9a00      	ldr	r2, [sp, #0]
 8006ad4:	601a      	str	r2, [r3, #0]
  isp->txcnt  = 0;
 8006ad6:	9b05      	ldr	r3, [sp, #20]
 8006ad8:	2200      	movs	r2, #0
 8006ada:	605a      	str	r2, [r3, #4]
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 8006adc:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006ae0:	9803      	ldr	r0, [sp, #12]
 8006ae2:	4619      	mov	r1, r3
 8006ae4:	f002 fbbc 	bl	8009260 <usb_lld_start_in>
}
 8006ae8:	b007      	add	sp, #28
 8006aea:	f85d fb04 	ldr.w	pc, [sp], #4
 8006aee:	bf00      	nop

08006af0 <usbStallReceiveI>:
 * @retval false        Endpoint stalled.
 * @retval true         Endpoint busy, not stalled.
 *
 * @iclass
 */
bool usbStallReceiveI(USBDriver *usbp, usbep_t ep) {
 8006af0:	b500      	push	{lr}
 8006af2:	b083      	sub	sp, #12
 8006af4:	9001      	str	r0, [sp, #4]
 8006af6:	460b      	mov	r3, r1
 8006af8:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetReceiveStatusI(usbp, ep)) {
 8006afc:	9b01      	ldr	r3, [sp, #4]
 8006afe:	895a      	ldrh	r2, [r3, #10]
 8006b00:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006b04:	2101      	movs	r1, #1
 8006b06:	fa01 f303 	lsl.w	r3, r1, r3
 8006b0a:	b29b      	uxth	r3, r3
 8006b0c:	4013      	ands	r3, r2
 8006b0e:	b29b      	uxth	r3, r3
 8006b10:	2b00      	cmp	r3, #0
 8006b12:	d001      	beq.n	8006b18 <usbStallReceiveI+0x28>
    return true;
 8006b14:	2301      	movs	r3, #1
 8006b16:	e006      	b.n	8006b26 <usbStallReceiveI+0x36>
  }

  usb_lld_stall_out(usbp, ep);
 8006b18:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006b1c:	9801      	ldr	r0, [sp, #4]
 8006b1e:	4619      	mov	r1, r3
 8006b20:	f002 fc4e 	bl	80093c0 <usb_lld_stall_out>
  return false;
 8006b24:	2300      	movs	r3, #0
}
 8006b26:	4618      	mov	r0, r3
 8006b28:	b003      	add	sp, #12
 8006b2a:	f85d fb04 	ldr.w	pc, [sp], #4
 8006b2e:	bf00      	nop

08006b30 <usbStallTransmitI>:
 * @retval false        Endpoint stalled.
 * @retval true         Endpoint busy, not stalled.
 *
 * @iclass
 */
bool usbStallTransmitI(USBDriver *usbp, usbep_t ep) {
 8006b30:	b500      	push	{lr}
 8006b32:	b083      	sub	sp, #12
 8006b34:	9001      	str	r0, [sp, #4]
 8006b36:	460b      	mov	r3, r1
 8006b38:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetTransmitStatusI(usbp, ep)) {
 8006b3c:	9b01      	ldr	r3, [sp, #4]
 8006b3e:	891a      	ldrh	r2, [r3, #8]
 8006b40:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006b44:	2101      	movs	r1, #1
 8006b46:	fa01 f303 	lsl.w	r3, r1, r3
 8006b4a:	b29b      	uxth	r3, r3
 8006b4c:	4013      	ands	r3, r2
 8006b4e:	b29b      	uxth	r3, r3
 8006b50:	2b00      	cmp	r3, #0
 8006b52:	d001      	beq.n	8006b58 <usbStallTransmitI+0x28>
    return true;
 8006b54:	2301      	movs	r3, #1
 8006b56:	e006      	b.n	8006b66 <usbStallTransmitI+0x36>
  }

  usb_lld_stall_in(usbp, ep);
 8006b58:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006b5c:	9801      	ldr	r0, [sp, #4]
 8006b5e:	4619      	mov	r1, r3
 8006b60:	f002 fc4e 	bl	8009400 <usb_lld_stall_in>
  return false;
 8006b64:	2300      	movs	r3, #0
}
 8006b66:	4618      	mov	r0, r3
 8006b68:	b003      	add	sp, #12
 8006b6a:	f85d fb04 	ldr.w	pc, [sp], #4
 8006b6e:	bf00      	nop

08006b70 <_usb_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_reset(USBDriver *usbp) {
 8006b70:	b500      	push	{lr}
 8006b72:	b085      	sub	sp, #20
 8006b74:	9001      	str	r0, [sp, #4]
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 8006b76:	9b01      	ldr	r3, [sp, #4]
 8006b78:	2202      	movs	r2, #2
 8006b7a:	701a      	strb	r2, [r3, #0]

  /* Resetting internal state.*/
  usbp->status        = 0;
 8006b7c:	9b01      	ldr	r3, [sp, #4]
 8006b7e:	2200      	movs	r2, #0
 8006b80:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
  usbp->address       = 0;
 8006b84:	9b01      	ldr	r3, [sp, #4]
 8006b86:	2200      	movs	r2, #0
 8006b88:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66
  usbp->configuration = 0;
 8006b8c:	9b01      	ldr	r3, [sp, #4]
 8006b8e:	2200      	movs	r2, #0
 8006b90:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
  usbp->transmitting  = 0;
 8006b94:	9b01      	ldr	r3, [sp, #4]
 8006b96:	2200      	movs	r2, #0
 8006b98:	811a      	strh	r2, [r3, #8]
  usbp->receiving     = 0;
 8006b9a:	9b01      	ldr	r3, [sp, #4]
 8006b9c:	2200      	movs	r2, #0
 8006b9e:	815a      	strh	r2, [r3, #10]

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006ba0:	2300      	movs	r3, #0
 8006ba2:	9303      	str	r3, [sp, #12]
 8006ba4:	e009      	b.n	8006bba <_usb_reset+0x4a>
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 8006ba6:	9a01      	ldr	r2, [sp, #4]
 8006ba8:	9b03      	ldr	r3, [sp, #12]
 8006baa:	3302      	adds	r3, #2
 8006bac:	009b      	lsls	r3, r3, #2
 8006bae:	4413      	add	r3, r2
 8006bb0:	2200      	movs	r2, #0
 8006bb2:	605a      	str	r2, [r3, #4]
  usbp->configuration = 0;
  usbp->transmitting  = 0;
  usbp->receiving     = 0;

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006bb4:	9b03      	ldr	r3, [sp, #12]
 8006bb6:	3301      	adds	r3, #1
 8006bb8:	9303      	str	r3, [sp, #12]
 8006bba:	9b03      	ldr	r3, [sp, #12]
 8006bbc:	2b05      	cmp	r3, #5
 8006bbe:	d9f2      	bls.n	8006ba6 <_usb_reset+0x36>
#endif
    usbp->epc[i] = NULL;
  }

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8006bc0:	9b01      	ldr	r3, [sp, #4]
 8006bc2:	2200      	movs	r2, #0
 8006bc4:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c

  /* Low level reset.*/
  usb_lld_reset(usbp);
 8006bc8:	9801      	ldr	r0, [sp, #4]
 8006bca:	f002 f861 	bl	8008c90 <usb_lld_reset>

  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8006bce:	9b01      	ldr	r3, [sp, #4]
 8006bd0:	685b      	ldr	r3, [r3, #4]
 8006bd2:	681b      	ldr	r3, [r3, #0]
 8006bd4:	2b00      	cmp	r3, #0
 8006bd6:	d005      	beq.n	8006be4 <_usb_reset+0x74>
 8006bd8:	9b01      	ldr	r3, [sp, #4]
 8006bda:	685b      	ldr	r3, [r3, #4]
 8006bdc:	681b      	ldr	r3, [r3, #0]
 8006bde:	9801      	ldr	r0, [sp, #4]
 8006be0:	2100      	movs	r1, #0
 8006be2:	4798      	blx	r3
}
 8006be4:	b005      	add	sp, #20
 8006be6:	f85d fb04 	ldr.w	pc, [sp], #4
 8006bea:	bf00      	nop
 8006bec:	f3af 8000 	nop.w

08006bf0 <_usb_suspend>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_suspend(USBDriver *usbp) {
 8006bf0:	b500      	push	{lr}
 8006bf2:	b083      	sub	sp, #12
 8006bf4:	9001      	str	r0, [sp, #4]
  /* No state change, suspend always returns to previous state. */

  /* State transition.*/
  usbp->saved_state = usbp->state;
 8006bf6:	9b01      	ldr	r3, [sp, #4]
 8006bf8:	781a      	ldrb	r2, [r3, #0]
 8006bfa:	9b01      	ldr	r3, [sp, #4]
 8006bfc:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
  usbp->state       = USB_SUSPENDED;
 8006c00:	9b01      	ldr	r3, [sp, #4]
 8006c02:	2205      	movs	r2, #5
 8006c04:	701a      	strb	r2, [r3, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8006c06:	9b01      	ldr	r3, [sp, #4]
 8006c08:	685b      	ldr	r3, [r3, #4]
 8006c0a:	681b      	ldr	r3, [r3, #0]
 8006c0c:	2b00      	cmp	r3, #0
 8006c0e:	d005      	beq.n	8006c1c <_usb_suspend+0x2c>
 8006c10:	9b01      	ldr	r3, [sp, #4]
 8006c12:	685b      	ldr	r3, [r3, #4]
 8006c14:	681b      	ldr	r3, [r3, #0]
 8006c16:	9801      	ldr	r0, [sp, #4]
 8006c18:	2104      	movs	r1, #4
 8006c1a:	4798      	blx	r3
        osalSysUnlockFromISR();
      }
    }
  }
#endif
}
 8006c1c:	b003      	add	sp, #12
 8006c1e:	f85d fb04 	ldr.w	pc, [sp], #4
 8006c22:	bf00      	nop
 8006c24:	f3af 8000 	nop.w
 8006c28:	f3af 8000 	nop.w
 8006c2c:	f3af 8000 	nop.w

08006c30 <_usb_wakeup>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {
 8006c30:	b500      	push	{lr}
 8006c32:	b083      	sub	sp, #12
 8006c34:	9001      	str	r0, [sp, #4]

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;
 8006c36:	9b01      	ldr	r3, [sp, #4]
 8006c38:	f893 2068 	ldrb.w	r2, [r3, #104]	; 0x68
 8006c3c:	9b01      	ldr	r3, [sp, #4]
 8006c3e:	701a      	strb	r2, [r3, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8006c40:	9b01      	ldr	r3, [sp, #4]
 8006c42:	685b      	ldr	r3, [r3, #4]
 8006c44:	681b      	ldr	r3, [r3, #0]
 8006c46:	2b00      	cmp	r3, #0
 8006c48:	d005      	beq.n	8006c56 <_usb_wakeup+0x26>
 8006c4a:	9b01      	ldr	r3, [sp, #4]
 8006c4c:	685b      	ldr	r3, [r3, #4]
 8006c4e:	681b      	ldr	r3, [r3, #0]
 8006c50:	9801      	ldr	r0, [sp, #4]
 8006c52:	2105      	movs	r1, #5
 8006c54:	4798      	blx	r3
}
 8006c56:	b003      	add	sp, #12
 8006c58:	f85d fb04 	ldr.w	pc, [sp], #4
 8006c5c:	f3af 8000 	nop.w

08006c60 <_usb_ep0setup>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8006c60:	b500      	push	{lr}
 8006c62:	b085      	sub	sp, #20
 8006c64:	9001      	str	r0, [sp, #4]
 8006c66:	460b      	mov	r3, r1
 8006c68:	f88d 3003 	strb.w	r3, [sp, #3]
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8006c6c:	9b01      	ldr	r3, [sp, #4]
 8006c6e:	2200      	movs	r2, #0
 8006c70:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
  usbReadSetup(usbp, ep, usbp->setup);
 8006c74:	9b01      	ldr	r3, [sp, #4]
 8006c76:	335c      	adds	r3, #92	; 0x5c
 8006c78:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8006c7c:	9801      	ldr	r0, [sp, #4]
 8006c7e:	4611      	mov	r1, r2
 8006c80:	461a      	mov	r2, r3
 8006c82:	f002 fa35 	bl	80090f0 <usb_lld_read_setup>

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8006c86:	9b01      	ldr	r3, [sp, #4]
 8006c88:	685b      	ldr	r3, [r3, #4]
 8006c8a:	689b      	ldr	r3, [r3, #8]
 8006c8c:	2b00      	cmp	r3, #0
 8006c8e:	d00a      	beq.n	8006ca6 <_usb_ep0setup+0x46>
      !(usbp->config->requests_hook_cb(usbp))) {
 8006c90:	9b01      	ldr	r3, [sp, #4]
 8006c92:	685b      	ldr	r3, [r3, #4]
 8006c94:	689b      	ldr	r3, [r3, #8]
 8006c96:	9801      	ldr	r0, [sp, #4]
 8006c98:	4798      	blx	r3
 8006c9a:	4603      	mov	r3, r0
 8006c9c:	f083 0301 	eor.w	r3, r3, #1
 8006ca0:	b2db      	uxtb	r3, r3
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8006ca2:	2b00      	cmp	r3, #0
 8006ca4:	d027      	beq.n	8006cf6 <_usb_ep0setup+0x96>
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8006ca6:	9b01      	ldr	r3, [sp, #4]
 8006ca8:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 8006cac:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8006cb0:	2b00      	cmp	r3, #0
 8006cb2:	d108      	bne.n	8006cc6 <_usb_ep0setup+0x66>
        !default_handler(usbp)) {
 8006cb4:	9801      	ldr	r0, [sp, #4]
 8006cb6:	f7ff fbf3 	bl	80064a0 <default_handler>
 8006cba:	4603      	mov	r3, r0
 8006cbc:	f083 0301 	eor.w	r3, r3, #1
 8006cc0:	b2db      	uxtb	r3, r3
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8006cc2:	2b00      	cmp	r3, #0
 8006cc4:	d017      	beq.n	8006cf6 <_usb_ep0setup+0x96>
        !default_handler(usbp)) {
    /*lint -restore*/
      /* Error response, the state machine goes into an error state, the low
         level layer will have to reset it to USB_EP0_WAITING_SETUP after
         receiving a SETUP packet.*/
      usb_lld_stall_in(usbp, 0);
 8006cc6:	9801      	ldr	r0, [sp, #4]
 8006cc8:	2100      	movs	r1, #0
 8006cca:	f002 fb99 	bl	8009400 <usb_lld_stall_in>
      usb_lld_stall_out(usbp, 0);
 8006cce:	9801      	ldr	r0, [sp, #4]
 8006cd0:	2100      	movs	r1, #0
 8006cd2:	f002 fb75 	bl	80093c0 <usb_lld_stall_out>
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8006cd6:	9b01      	ldr	r3, [sp, #4]
 8006cd8:	685b      	ldr	r3, [r3, #4]
 8006cda:	681b      	ldr	r3, [r3, #0]
 8006cdc:	2b00      	cmp	r3, #0
 8006cde:	d005      	beq.n	8006cec <_usb_ep0setup+0x8c>
 8006ce0:	9b01      	ldr	r3, [sp, #4]
 8006ce2:	685b      	ldr	r3, [r3, #4]
 8006ce4:	681b      	ldr	r3, [r3, #0]
 8006ce6:	9801      	ldr	r0, [sp, #4]
 8006ce8:	2106      	movs	r1, #6
 8006cea:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 8006cec:	9b01      	ldr	r3, [sp, #4]
 8006cee:	2206      	movs	r2, #6
 8006cf0:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      return;
 8006cf4:	e05c      	b.n	8006db0 <_usb_ep0setup+0x150>
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
 8006cf6:	9b01      	ldr	r3, [sp, #4]
 8006cf8:	3362      	adds	r3, #98	; 0x62
 8006cfa:	4618      	mov	r0, r3
 8006cfc:	f7ff fb98 	bl	8006430 <get_hword>
 8006d00:	4603      	mov	r3, r0
 8006d02:	9303      	str	r3, [sp, #12]
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 8006d04:	9b01      	ldr	r3, [sp, #4]
 8006d06:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8006d08:	9b03      	ldr	r3, [sp, #12]
 8006d0a:	429a      	cmp	r2, r3
 8006d0c:	d902      	bls.n	8006d14 <_usb_ep0setup+0xb4>
    usbp->ep0n = max;
 8006d0e:	9b01      	ldr	r3, [sp, #4]
 8006d10:	9a03      	ldr	r2, [sp, #12]
 8006d12:	655a      	str	r2, [r3, #84]	; 0x54
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8006d14:	9b01      	ldr	r3, [sp, #4]
 8006d16:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 8006d1a:	b2db      	uxtb	r3, r3
 8006d1c:	b25b      	sxtb	r3, r3
 8006d1e:	2b00      	cmp	r3, #0
 8006d20:	da23      	bge.n	8006d6a <_usb_ep0setup+0x10a>
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
 8006d22:	9b01      	ldr	r3, [sp, #4]
 8006d24:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8006d26:	2b00      	cmp	r3, #0
 8006d28:	d010      	beq.n	8006d4c <_usb_ep0setup+0xec>
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
 8006d2a:	9b01      	ldr	r3, [sp, #4]
 8006d2c:	2201      	movs	r2, #1
 8006d2e:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      osalSysLockFromISR();
 8006d32:	f7ff fb65 	bl	8006400 <osalSysLockFromISR>
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8006d36:	9b01      	ldr	r3, [sp, #4]
 8006d38:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8006d3a:	9b01      	ldr	r3, [sp, #4]
 8006d3c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8006d3e:	9801      	ldr	r0, [sp, #4]
 8006d40:	2100      	movs	r1, #0
 8006d42:	f7ff fea5 	bl	8006a90 <usbStartTransmitI>
      osalSysUnlockFromISR();
 8006d46:	f7ff fb63 	bl	8006410 <osalSysUnlockFromISR>
 8006d4a:	e031      	b.n	8006db0 <_usb_ep0setup+0x150>
    }
    else {
      /* No transmission phase, directly receiving the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_WAITING_STS;
 8006d4c:	9b01      	ldr	r3, [sp, #4]
 8006d4e:	2203      	movs	r2, #3
 8006d50:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
 8006d54:	f7ff fb54 	bl	8006400 <osalSysLockFromISR>
      usbStartReceiveI(usbp, 0, NULL, 0);
 8006d58:	9801      	ldr	r0, [sp, #4]
 8006d5a:	2100      	movs	r1, #0
 8006d5c:	2200      	movs	r2, #0
 8006d5e:	2300      	movs	r3, #0
 8006d60:	f7ff fe66 	bl	8006a30 <usbStartReceiveI>
      osalSysUnlockFromISR();
 8006d64:	f7ff fb54 	bl	8006410 <osalSysUnlockFromISR>
 8006d68:	e022      	b.n	8006db0 <_usb_ep0setup+0x150>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 8006d6a:	9b01      	ldr	r3, [sp, #4]
 8006d6c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8006d6e:	2b00      	cmp	r3, #0
 8006d70:	d010      	beq.n	8006d94 <_usb_ep0setup+0x134>
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
 8006d72:	9b01      	ldr	r3, [sp, #4]
 8006d74:	2204      	movs	r2, #4
 8006d76:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      osalSysLockFromISR();
 8006d7a:	f7ff fb41 	bl	8006400 <osalSysLockFromISR>
      usbStartReceiveI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8006d7e:	9b01      	ldr	r3, [sp, #4]
 8006d80:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8006d82:	9b01      	ldr	r3, [sp, #4]
 8006d84:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8006d86:	9801      	ldr	r0, [sp, #4]
 8006d88:	2100      	movs	r1, #0
 8006d8a:	f7ff fe51 	bl	8006a30 <usbStartReceiveI>
      osalSysUnlockFromISR();
 8006d8e:	f7ff fb3f 	bl	8006410 <osalSysUnlockFromISR>
 8006d92:	e00d      	b.n	8006db0 <_usb_ep0setup+0x150>
    }
    else {
      /* No receive phase, directly sending the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_SENDING_STS;
 8006d94:	9b01      	ldr	r3, [sp, #4]
 8006d96:	2205      	movs	r2, #5
 8006d98:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
 8006d9c:	f7ff fb30 	bl	8006400 <osalSysLockFromISR>
      usbStartTransmitI(usbp, 0, NULL, 0);
 8006da0:	9801      	ldr	r0, [sp, #4]
 8006da2:	2100      	movs	r1, #0
 8006da4:	2200      	movs	r2, #0
 8006da6:	2300      	movs	r3, #0
 8006da8:	f7ff fe72 	bl	8006a90 <usbStartTransmitI>
      osalSysUnlockFromISR();
 8006dac:	f7ff fb30 	bl	8006410 <osalSysUnlockFromISR>
#else
      usb_lld_end_setup(usbp, ep);
#endif
    }
  }
}
 8006db0:	b005      	add	sp, #20
 8006db2:	f85d fb04 	ldr.w	pc, [sp], #4
 8006db6:	bf00      	nop
 8006db8:	f3af 8000 	nop.w
 8006dbc:	f3af 8000 	nop.w

08006dc0 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8006dc0:	b500      	push	{lr}
 8006dc2:	b085      	sub	sp, #20
 8006dc4:	9001      	str	r0, [sp, #4]
 8006dc6:	460b      	mov	r3, r1
 8006dc8:	f88d 3003 	strb.w	r3, [sp, #3]
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 8006dcc:	9b01      	ldr	r3, [sp, #4]
 8006dce:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 8006dd2:	2b06      	cmp	r3, #6
 8006dd4:	d86b      	bhi.n	8006eae <_usb_ep0in+0xee>
 8006dd6:	a201      	add	r2, pc, #4	; (adr r2, 8006ddc <_usb_ep0in+0x1c>)
 8006dd8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006ddc:	08006e7f 	.word	0x08006e7f
 8006de0:	08006df9 	.word	0x08006df9
 8006de4:	08006e47 	.word	0x08006e47
 8006de8:	08006e7f 	.word	0x08006e7f
 8006dec:	08006e7f 	.word	0x08006e7f
 8006df0:	08006e65 	.word	0x08006e65
 8006df4:	08006e7f 	.word	0x08006e7f
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
 8006df8:	9b01      	ldr	r3, [sp, #4]
 8006dfa:	3362      	adds	r3, #98	; 0x62
 8006dfc:	4618      	mov	r0, r3
 8006dfe:	f7ff fb17 	bl	8006430 <get_hword>
 8006e02:	4603      	mov	r3, r0
 8006e04:	9303      	str	r3, [sp, #12]
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8006e06:	9b01      	ldr	r3, [sp, #4]
 8006e08:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8006e0a:	9b03      	ldr	r3, [sp, #12]
 8006e0c:	429a      	cmp	r2, r3
 8006e0e:	d21a      	bcs.n	8006e46 <_usb_ep0in+0x86>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 8006e10:	9b01      	ldr	r3, [sp, #4]
 8006e12:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8006e14:	9a01      	ldr	r2, [sp, #4]
 8006e16:	68d2      	ldr	r2, [r2, #12]
 8006e18:	8a12      	ldrh	r2, [r2, #16]
 8006e1a:	fbb3 f1f2 	udiv	r1, r3, r2
 8006e1e:	fb02 f201 	mul.w	r2, r2, r1
 8006e22:	1a9b      	subs	r3, r3, r2
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8006e24:	2b00      	cmp	r3, #0
 8006e26:	d10e      	bne.n	8006e46 <_usb_ep0in+0x86>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
      osalSysLockFromISR();
 8006e28:	f7ff faea 	bl	8006400 <osalSysLockFromISR>
      usbStartTransmitI(usbp, 0, NULL, 0);
 8006e2c:	9801      	ldr	r0, [sp, #4]
 8006e2e:	2100      	movs	r1, #0
 8006e30:	2200      	movs	r2, #0
 8006e32:	2300      	movs	r3, #0
 8006e34:	f7ff fe2c 	bl	8006a90 <usbStartTransmitI>
      osalSysUnlockFromISR();
 8006e38:	f7ff faea 	bl	8006410 <osalSysUnlockFromISR>
      usbp->ep0state = USB_EP0_WAITING_TX0;
 8006e3c:	9b01      	ldr	r3, [sp, #4]
 8006e3e:	2202      	movs	r2, #2
 8006e40:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      return;
 8006e44:	e033      	b.n	8006eae <_usb_ep0in+0xee>
    }
    /* Falls into, it is intentional.*/
  case USB_EP0_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_WAITING_STS;
 8006e46:	9b01      	ldr	r3, [sp, #4]
 8006e48:	2203      	movs	r2, #3
 8006e4a:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
 8006e4e:	f7ff fad7 	bl	8006400 <osalSysLockFromISR>
    usbStartReceiveI(usbp, 0, NULL, 0);
 8006e52:	9801      	ldr	r0, [sp, #4]
 8006e54:	2100      	movs	r1, #0
 8006e56:	2200      	movs	r2, #0
 8006e58:	2300      	movs	r3, #0
 8006e5a:	f7ff fde9 	bl	8006a30 <usbStartReceiveI>
    osalSysUnlockFromISR();
 8006e5e:	f7ff fad7 	bl	8006410 <osalSysUnlockFromISR>
#else
    usb_lld_end_setup(usbp, ep);
#endif
    return;
 8006e62:	e024      	b.n	8006eae <_usb_ep0in+0xee>
  case USB_EP0_SENDING_STS:
    /* Status packet sent, invoking the callback if defined.*/
    if (usbp->ep0endcb != NULL) {
 8006e64:	9b01      	ldr	r3, [sp, #4]
 8006e66:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8006e68:	2b00      	cmp	r3, #0
 8006e6a:	d003      	beq.n	8006e74 <_usb_ep0in+0xb4>
      usbp->ep0endcb(usbp);
 8006e6c:	9b01      	ldr	r3, [sp, #4]
 8006e6e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8006e70:	9801      	ldr	r0, [sp, #4]
 8006e72:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8006e74:	9b01      	ldr	r3, [sp, #4]
 8006e76:	2200      	movs	r2, #0
 8006e78:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
    return;
 8006e7c:	e017      	b.n	8006eae <_usb_ep0in+0xee>
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 8006e7e:	9801      	ldr	r0, [sp, #4]
 8006e80:	2100      	movs	r1, #0
 8006e82:	f002 fabd 	bl	8009400 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 8006e86:	9801      	ldr	r0, [sp, #4]
 8006e88:	2100      	movs	r1, #0
 8006e8a:	f002 fa99 	bl	80093c0 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8006e8e:	9b01      	ldr	r3, [sp, #4]
 8006e90:	685b      	ldr	r3, [r3, #4]
 8006e92:	681b      	ldr	r3, [r3, #0]
 8006e94:	2b00      	cmp	r3, #0
 8006e96:	d005      	beq.n	8006ea4 <_usb_ep0in+0xe4>
 8006e98:	9b01      	ldr	r3, [sp, #4]
 8006e9a:	685b      	ldr	r3, [r3, #4]
 8006e9c:	681b      	ldr	r3, [r3, #0]
 8006e9e:	9801      	ldr	r0, [sp, #4]
 8006ea0:	2106      	movs	r1, #6
 8006ea2:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8006ea4:	9b01      	ldr	r3, [sp, #4]
 8006ea6:	2206      	movs	r2, #6
 8006ea8:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
    return;
 8006eac:	bf00      	nop
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 8006eae:	b005      	add	sp, #20
 8006eb0:	f85d fb04 	ldr.w	pc, [sp], #4
 8006eb4:	f3af 8000 	nop.w
 8006eb8:	f3af 8000 	nop.w
 8006ebc:	f3af 8000 	nop.w

08006ec0 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8006ec0:	b500      	push	{lr}
 8006ec2:	b083      	sub	sp, #12
 8006ec4:	9001      	str	r0, [sp, #4]
 8006ec6:	460b      	mov	r3, r1
 8006ec8:	f88d 3003 	strb.w	r3, [sp, #3]

  (void)ep;
  switch (usbp->ep0state) {
 8006ecc:	9b01      	ldr	r3, [sp, #4]
 8006ece:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 8006ed2:	2b06      	cmp	r3, #6
 8006ed4:	d84b      	bhi.n	8006f6e <_usb_ep0out+0xae>
 8006ed6:	a201      	add	r2, pc, #4	; (adr r2, 8006edc <_usb_ep0out+0x1c>)
 8006ed8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006edc:	08006f3f 	.word	0x08006f3f
 8006ee0:	08006f3f 	.word	0x08006f3f
 8006ee4:	08006f3f 	.word	0x08006f3f
 8006ee8:	08006f17 	.word	0x08006f17
 8006eec:	08006ef9 	.word	0x08006ef9
 8006ef0:	08006f3f 	.word	0x08006f3f
 8006ef4:	08006f3f 	.word	0x08006f3f
  case USB_EP0_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_SENDING_STS;
 8006ef8:	9b01      	ldr	r3, [sp, #4]
 8006efa:	2205      	movs	r2, #5
 8006efc:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
 8006f00:	f7ff fa7e 	bl	8006400 <osalSysLockFromISR>
    usbStartTransmitI(usbp, 0, NULL, 0);
 8006f04:	9801      	ldr	r0, [sp, #4]
 8006f06:	2100      	movs	r1, #0
 8006f08:	2200      	movs	r2, #0
 8006f0a:	2300      	movs	r3, #0
 8006f0c:	f7ff fdc0 	bl	8006a90 <usbStartTransmitI>
    osalSysUnlockFromISR();
 8006f10:	f7ff fa7e 	bl	8006410 <osalSysUnlockFromISR>
#else
    usb_lld_end_setup(usbp, ep);
#endif
    return;
 8006f14:	e02b      	b.n	8006f6e <_usb_ep0out+0xae>
  case USB_EP0_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 8006f16:	9b01      	ldr	r3, [sp, #4]
 8006f18:	68db      	ldr	r3, [r3, #12]
 8006f1a:	699b      	ldr	r3, [r3, #24]
 8006f1c:	685b      	ldr	r3, [r3, #4]
 8006f1e:	2b00      	cmp	r3, #0
 8006f20:	d000      	beq.n	8006f24 <_usb_ep0out+0x64>
      break;
 8006f22:	e024      	b.n	8006f6e <_usb_ep0out+0xae>
    }
#endif
    if (usbp->ep0endcb != NULL) {
 8006f24:	9b01      	ldr	r3, [sp, #4]
 8006f26:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8006f28:	2b00      	cmp	r3, #0
 8006f2a:	d003      	beq.n	8006f34 <_usb_ep0out+0x74>
      usbp->ep0endcb(usbp);
 8006f2c:	9b01      	ldr	r3, [sp, #4]
 8006f2e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8006f30:	9801      	ldr	r0, [sp, #4]
 8006f32:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8006f34:	9b01      	ldr	r3, [sp, #4]
 8006f36:	2200      	movs	r2, #0
 8006f38:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
    return;
 8006f3c:	e017      	b.n	8006f6e <_usb_ep0out+0xae>
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 8006f3e:	9801      	ldr	r0, [sp, #4]
 8006f40:	2100      	movs	r1, #0
 8006f42:	f002 fa5d 	bl	8009400 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 8006f46:	9801      	ldr	r0, [sp, #4]
 8006f48:	2100      	movs	r1, #0
 8006f4a:	f002 fa39 	bl	80093c0 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8006f4e:	9b01      	ldr	r3, [sp, #4]
 8006f50:	685b      	ldr	r3, [r3, #4]
 8006f52:	681b      	ldr	r3, [r3, #0]
 8006f54:	2b00      	cmp	r3, #0
 8006f56:	d005      	beq.n	8006f64 <_usb_ep0out+0xa4>
 8006f58:	9b01      	ldr	r3, [sp, #4]
 8006f5a:	685b      	ldr	r3, [r3, #4]
 8006f5c:	681b      	ldr	r3, [r3, #0]
 8006f5e:	9801      	ldr	r0, [sp, #4]
 8006f60:	2106      	movs	r1, #6
 8006f62:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8006f64:	9b01      	ldr	r3, [sp, #4]
 8006f66:	2206      	movs	r2, #6
 8006f68:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
    return;
 8006f6c:	bf00      	nop
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 8006f6e:	b003      	add	sp, #12
 8006f70:	f85d fb04 	ldr.w	pc, [sp], #4
 8006f74:	f3af 8000 	nop.w
 8006f78:	f3af 8000 	nop.w
 8006f7c:	f3af 8000 	nop.w

08006f80 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8006f80:	b082      	sub	sp, #8
 8006f82:	9001      	str	r0, [sp, #4]
 8006f84:	9100      	str	r1, [sp, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8006f86:	4911      	ldr	r1, [pc, #68]	; (8006fcc <nvicEnableVector+0x4c>)
 8006f88:	9b00      	ldr	r3, [sp, #0]
 8006f8a:	b2db      	uxtb	r3, r3
 8006f8c:	011b      	lsls	r3, r3, #4
 8006f8e:	b2da      	uxtb	r2, r3
 8006f90:	9b01      	ldr	r3, [sp, #4]
 8006f92:	440b      	add	r3, r1
 8006f94:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8006f98:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8006f9a:	4b0c      	ldr	r3, [pc, #48]	; (8006fcc <nvicEnableVector+0x4c>)
 8006f9c:	9a01      	ldr	r2, [sp, #4]
 8006f9e:	0952      	lsrs	r2, r2, #5
 8006fa0:	9901      	ldr	r1, [sp, #4]
 8006fa2:	f001 011f 	and.w	r1, r1, #31
 8006fa6:	2001      	movs	r0, #1
 8006fa8:	fa00 f101 	lsl.w	r1, r0, r1
 8006fac:	3260      	adds	r2, #96	; 0x60
 8006fae:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8006fb2:	4b06      	ldr	r3, [pc, #24]	; (8006fcc <nvicEnableVector+0x4c>)
 8006fb4:	9a01      	ldr	r2, [sp, #4]
 8006fb6:	0952      	lsrs	r2, r2, #5
 8006fb8:	9901      	ldr	r1, [sp, #4]
 8006fba:	f001 011f 	and.w	r1, r1, #31
 8006fbe:	2001      	movs	r0, #1
 8006fc0:	fa00 f101 	lsl.w	r1, r0, r1
 8006fc4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8006fc8:	b002      	add	sp, #8
 8006fca:	4770      	bx	lr
 8006fcc:	e000e100 	.word	0xe000e100

08006fd0 <nvicDisableVector>:
/**
 * @brief   Disables an interrupt handler.
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {
 8006fd0:	b082      	sub	sp, #8
 8006fd2:	9001      	str	r0, [sp, #4]

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8006fd4:	4b0a      	ldr	r3, [pc, #40]	; (8007000 <nvicDisableVector+0x30>)
 8006fd6:	9a01      	ldr	r2, [sp, #4]
 8006fd8:	0952      	lsrs	r2, r2, #5
 8006fda:	9901      	ldr	r1, [sp, #4]
 8006fdc:	f001 011f 	and.w	r1, r1, #31
 8006fe0:	2001      	movs	r0, #1
 8006fe2:	fa00 f101 	lsl.w	r1, r0, r1
 8006fe6:	3220      	adds	r2, #32
 8006fe8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 8006fec:	4a04      	ldr	r2, [pc, #16]	; (8007000 <nvicDisableVector+0x30>)
 8006fee:	9b01      	ldr	r3, [sp, #4]
 8006ff0:	4413      	add	r3, r2
 8006ff2:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8006ff6:	2200      	movs	r2, #0
 8006ff8:	701a      	strb	r2, [r3, #0]
#endif
}
 8006ffa:	b002      	add	sp, #8
 8006ffc:	4770      	bx	lr
 8006ffe:	bf00      	nop
 8007000:	e000e100 	.word	0xe000e100
 8007004:	f3af 8000 	nop.w
 8007008:	f3af 8000 	nop.w
 800700c:	f3af 8000 	nop.w

08007010 <nvicSetSystemHandlerPriority>:
 * @brief   Changes the priority of a system handler.
 *
 * @param[in] handler   the system handler number
 * @param[in] prio      the system handler priority
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
 8007010:	b082      	sub	sp, #8
 8007012:	9001      	str	r0, [sp, #4]
 8007014:	9100      	str	r1, [sp, #0]
  SCB->SHP[_SHP_IDX(handler)] = (SCB->SHP[_SHP_IDX(handler)] & ~(0xFFU << _BIT_SHIFT(handler))) |
                                (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(handler));
#elif defined(__CORE_CM7_H_GENERIC)
  SCB->SHPR[handler] = NVIC_PRIORITY_MASK(prio);
#else
  SCB->SHP[handler] = NVIC_PRIORITY_MASK(prio);
 8007016:	4905      	ldr	r1, [pc, #20]	; (800702c <nvicSetSystemHandlerPriority+0x1c>)
 8007018:	9b00      	ldr	r3, [sp, #0]
 800701a:	b2db      	uxtb	r3, r3
 800701c:	011b      	lsls	r3, r3, #4
 800701e:	b2da      	uxtb	r2, r3
 8007020:	9b01      	ldr	r3, [sp, #4]
 8007022:	440b      	add	r3, r1
 8007024:	3318      	adds	r3, #24
 8007026:	701a      	strb	r2, [r3, #0]
#endif
}
 8007028:	b002      	add	sp, #8
 800702a:	4770      	bx	lr
 800702c:	e000ed00 	.word	0xe000ed00

08007030 <nvicClearPending>:
/**
 * @brief   Clears a pending interrupt source.
 *
 * @param[in] n         the interrupt number
 */
void nvicClearPending(uint32_t n) {
 8007030:	b082      	sub	sp, #8
 8007032:	9001      	str	r0, [sp, #4]

  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8007034:	4b06      	ldr	r3, [pc, #24]	; (8007050 <nvicClearPending+0x20>)
 8007036:	9a01      	ldr	r2, [sp, #4]
 8007038:	0952      	lsrs	r2, r2, #5
 800703a:	9901      	ldr	r1, [sp, #4]
 800703c:	f001 011f 	and.w	r1, r1, #31
 8007040:	2001      	movs	r0, #1
 8007042:	fa00 f101 	lsl.w	r1, r0, r1
 8007046:	3260      	adds	r2, #96	; 0x60
 8007048:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 800704c:	b002      	add	sp, #8
 800704e:	4770      	bx	lr
 8007050:	e000e100 	.word	0xe000e100
 8007054:	f3af 8000 	nop.w
 8007058:	f3af 8000 	nop.w
 800705c:	f3af 8000 	nop.w

08007060 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8007060:	4b17      	ldr	r3, [pc, #92]	; (80070c0 <hal_lld_backup_domain_init+0x60>)
 8007062:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8007066:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800706a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800706e:	d008      	beq.n	8007082 <hal_lld_backup_domain_init+0x22>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8007070:	4b13      	ldr	r3, [pc, #76]	; (80070c0 <hal_lld_backup_domain_init+0x60>)
 8007072:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8007076:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    RCC->BDCR = 0;
 800707a:	4b11      	ldr	r3, [pc, #68]	; (80070c0 <hal_lld_backup_domain_init+0x60>)
 800707c:	2200      	movs	r2, #0
 800707e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#if defined(STM32_LSE_BYPASS)
  /* LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON | RCC_BDCR_LSEBYP;
#else
  /* No LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON;
 8007082:	4b0f      	ldr	r3, [pc, #60]	; (80070c0 <hal_lld_backup_domain_init+0x60>)
 8007084:	4a0e      	ldr	r2, [pc, #56]	; (80070c0 <hal_lld_backup_domain_init+0x60>)
 8007086:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 800708a:	f042 0219 	orr.w	r2, r2, #25
 800708e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#endif
  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
 8007092:	bf00      	nop
 8007094:	4b0a      	ldr	r3, [pc, #40]	; (80070c0 <hal_lld_backup_domain_init+0x60>)
 8007096:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800709a:	f003 0302 	and.w	r3, r3, #2
 800709e:	2b00      	cmp	r3, #0
 80070a0:	d0f8      	beq.n	8007094 <hal_lld_backup_domain_init+0x34>
#endif

#if STM32_MSIPLL_ENABLED
  /* MSI PLL activation depends on LSE. Reactivating and checking for
     MSI stability.*/
  RCC->CR |= RCC_CR_MSIPLLEN;
 80070a2:	4b07      	ldr	r3, [pc, #28]	; (80070c0 <hal_lld_backup_domain_init+0x60>)
 80070a4:	4a06      	ldr	r2, [pc, #24]	; (80070c0 <hal_lld_backup_domain_init+0x60>)
 80070a6:	6812      	ldr	r2, [r2, #0]
 80070a8:	f042 0204 	orr.w	r2, r2, #4
 80070ac:	601a      	str	r2, [r3, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0)
 80070ae:	bf00      	nop
 80070b0:	4b03      	ldr	r3, [pc, #12]	; (80070c0 <hal_lld_backup_domain_init+0x60>)
 80070b2:	681b      	ldr	r3, [r3, #0]
 80070b4:	f003 0302 	and.w	r3, r3, #2
 80070b8:	2b00      	cmp	r3, #0
 80070ba:	d0f9      	beq.n	80070b0 <hal_lld_backup_domain_init+0x50>

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
  }
#endif /* HAL_USE_RTC */
}
 80070bc:	4770      	bx	lr
 80070be:	bf00      	nop
 80070c0:	40021000 	.word	0x40021000
 80070c4:	f3af 8000 	nop.w
 80070c8:	f3af 8000 	nop.w
 80070cc:	f3af 8000 	nop.w

080070d0 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 80070d0:	b508      	push	{r3, lr}

  /* Reset of all peripherals.*/
  rccResetAHB1(~0);
 80070d2:	4b28      	ldr	r3, [pc, #160]	; (8007174 <hal_lld_init+0xa4>)
 80070d4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80070d6:	4b27      	ldr	r3, [pc, #156]	; (8007174 <hal_lld_init+0xa4>)
 80070d8:	f04f 32ff 	mov.w	r2, #4294967295
 80070dc:	629a      	str	r2, [r3, #40]	; 0x28
 80070de:	4b25      	ldr	r3, [pc, #148]	; (8007174 <hal_lld_init+0xa4>)
 80070e0:	2200      	movs	r2, #0
 80070e2:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAHB2(~0);
 80070e4:	4b23      	ldr	r3, [pc, #140]	; (8007174 <hal_lld_init+0xa4>)
 80070e6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80070e8:	4b22      	ldr	r3, [pc, #136]	; (8007174 <hal_lld_init+0xa4>)
 80070ea:	f04f 32ff 	mov.w	r2, #4294967295
 80070ee:	62da      	str	r2, [r3, #44]	; 0x2c
 80070f0:	4b20      	ldr	r3, [pc, #128]	; (8007174 <hal_lld_init+0xa4>)
 80070f2:	2200      	movs	r2, #0
 80070f4:	62da      	str	r2, [r3, #44]	; 0x2c
  rccResetAHB3(~0);
 80070f6:	4b1f      	ldr	r3, [pc, #124]	; (8007174 <hal_lld_init+0xa4>)
 80070f8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80070fa:	4b1e      	ldr	r3, [pc, #120]	; (8007174 <hal_lld_init+0xa4>)
 80070fc:	f04f 32ff 	mov.w	r2, #4294967295
 8007100:	631a      	str	r2, [r3, #48]	; 0x30
 8007102:	4b1c      	ldr	r3, [pc, #112]	; (8007174 <hal_lld_init+0xa4>)
 8007104:	2200      	movs	r2, #0
 8007106:	631a      	str	r2, [r3, #48]	; 0x30
  rccResetAPB1R1(~RCC_APB1RSTR1_PWRRST);
 8007108:	4b1a      	ldr	r3, [pc, #104]	; (8007174 <hal_lld_init+0xa4>)
 800710a:	4a1a      	ldr	r2, [pc, #104]	; (8007174 <hal_lld_init+0xa4>)
 800710c:	6b92      	ldr	r2, [r2, #56]	; 0x38
 800710e:	f062 5280 	orn	r2, r2, #268435456	; 0x10000000
 8007112:	639a      	str	r2, [r3, #56]	; 0x38
 8007114:	4b17      	ldr	r3, [pc, #92]	; (8007174 <hal_lld_init+0xa4>)
 8007116:	2200      	movs	r2, #0
 8007118:	639a      	str	r2, [r3, #56]	; 0x38
  rccResetAPB1R2(~0);
 800711a:	4b16      	ldr	r3, [pc, #88]	; (8007174 <hal_lld_init+0xa4>)
 800711c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800711e:	4b15      	ldr	r3, [pc, #84]	; (8007174 <hal_lld_init+0xa4>)
 8007120:	f04f 32ff 	mov.w	r2, #4294967295
 8007124:	63da      	str	r2, [r3, #60]	; 0x3c
 8007126:	4b13      	ldr	r3, [pc, #76]	; (8007174 <hal_lld_init+0xa4>)
 8007128:	2200      	movs	r2, #0
 800712a:	63da      	str	r2, [r3, #60]	; 0x3c
  rccResetAPB2(~0);
 800712c:	4b11      	ldr	r3, [pc, #68]	; (8007174 <hal_lld_init+0xa4>)
 800712e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8007130:	4b10      	ldr	r3, [pc, #64]	; (8007174 <hal_lld_init+0xa4>)
 8007132:	f04f 32ff 	mov.w	r2, #4294967295
 8007136:	641a      	str	r2, [r3, #64]	; 0x40
 8007138:	4b0e      	ldr	r3, [pc, #56]	; (8007174 <hal_lld_init+0xa4>)
 800713a:	2200      	movs	r2, #0
 800713c:	641a      	str	r2, [r3, #64]	; 0x40

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 800713e:	4b0d      	ldr	r3, [pc, #52]	; (8007174 <hal_lld_init+0xa4>)
 8007140:	4a0c      	ldr	r2, [pc, #48]	; (8007174 <hal_lld_init+0xa4>)
 8007142:	6d92      	ldr	r2, [r2, #88]	; 0x58
 8007144:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8007148:	659a      	str	r2, [r3, #88]	; 0x58

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 800714a:	f7ff ff89 	bl	8007060 <hal_lld_backup_domain_init>

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 800714e:	f000 fbf7 	bl	8007940 <dmaInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR2 = PWR_CR2_PVDE | (STM32_PLS & STM32_PLS_MASK);
#else
  PWR->CR2 = 0;
 8007152:	4b09      	ldr	r3, [pc, #36]	; (8007178 <hal_lld_init+0xa8>)
 8007154:	2200      	movs	r2, #0
 8007156:	605a      	str	r2, [r3, #4]
#endif /* STM32_PVD_ENABLE */

  /* Enabling independent VDDUSB.*/
#if HAL_USE_USB
  PWR->CR2 |= PWR_CR2_USV;
 8007158:	4b07      	ldr	r3, [pc, #28]	; (8007178 <hal_lld_init+0xa8>)
 800715a:	4a07      	ldr	r2, [pc, #28]	; (8007178 <hal_lld_init+0xa8>)
 800715c:	6852      	ldr	r2, [r2, #4]
 800715e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8007162:	605a      	str	r2, [r3, #4]
#endif /* HAL_USE_USB */

  /* Enabling independent VDDIO2 required by GPIOG.*/
#if STM32_HAS_GPIOG
  PWR->CR2 |= PWR_CR2_IOSV;
 8007164:	4b04      	ldr	r3, [pc, #16]	; (8007178 <hal_lld_init+0xa8>)
 8007166:	4a04      	ldr	r2, [pc, #16]	; (8007178 <hal_lld_init+0xa8>)
 8007168:	6852      	ldr	r2, [r2, #4]
 800716a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800716e:	605a      	str	r2, [r3, #4]
#endif /* STM32_HAS_GPIOG */
}
 8007170:	bd08      	pop	{r3, pc}
 8007172:	bf00      	nop
 8007174:	40021000 	.word	0x40021000
 8007178:	40007000 	.word	0x40007000
 800717c:	f3af 8000 	nop.w

08007180 <stm32_clock_init>:
 * @note    All the involved constants come from the file @p board.h.
 * @note    This function should be invoked just after the system reset.
 *
 * @special
 */
void stm32_clock_init(void) {
 8007180:	b082      	sub	sp, #8

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR1 |= RCC_APB1ENR1_PWREN;
 8007182:	4b5e      	ldr	r3, [pc, #376]	; (80072fc <stm32_clock_init+0x17c>)
 8007184:	4a5d      	ldr	r2, [pc, #372]	; (80072fc <stm32_clock_init+0x17c>)
 8007186:	6d92      	ldr	r2, [r2, #88]	; 0x58
 8007188:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800718c:	659a      	str	r2, [r3, #88]	; 0x58
  /* Initial clocks setup and wait for MSI stabilization, the MSI clock is
     always enabled because it is the fall back clock when PLL the fails.
     Trim fields are not altered from reset values.*/

  /* MSIRANGE can be set only when MSI is OFF or READY.*/
  RCC->CR = RCC_CR_MSION;
 800718e:	4b5b      	ldr	r3, [pc, #364]	; (80072fc <stm32_clock_init+0x17c>)
 8007190:	2201      	movs	r2, #1
 8007192:	601a      	str	r2, [r3, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0)
 8007194:	bf00      	nop
 8007196:	4b59      	ldr	r3, [pc, #356]	; (80072fc <stm32_clock_init+0x17c>)
 8007198:	681b      	ldr	r3, [r3, #0]
 800719a:	f003 0302 	and.w	r3, r3, #2
 800719e:	2b00      	cmp	r3, #0
 80071a0:	d0f9      	beq.n	8007196 <stm32_clock_init+0x16>
    ;                                       /* Wait until MSI is stable.    */

  /* Clocking from MSI, in case MSI was not the default source.*/
  RCC->CFGR = 0;
 80071a2:	4b56      	ldr	r3, [pc, #344]	; (80072fc <stm32_clock_init+0x17c>)
 80071a4:	2200      	movs	r2, #0
 80071a6:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI)
 80071a8:	bf00      	nop
 80071aa:	4b54      	ldr	r3, [pc, #336]	; (80072fc <stm32_clock_init+0x17c>)
 80071ac:	689b      	ldr	r3, [r3, #8]
 80071ae:	f003 030c 	and.w	r3, r3, #12
 80071b2:	2b00      	cmp	r3, #0
 80071b4:	d1f9      	bne.n	80071aa <stm32_clock_init+0x2a>
    ;                                       /* Wait until MSI is selected.  */

  /* Core voltage setup.*/
  PWR->CR1 = STM32_VOS;
 80071b6:	4b52      	ldr	r3, [pc, #328]	; (8007300 <stm32_clock_init+0x180>)
 80071b8:	f44f 7200 	mov.w	r2, #512	; 0x200
 80071bc:	601a      	str	r2, [r3, #0]
  while ((PWR->SR2 & PWR_SR2_VOSF) != 0)    /* Wait until regulator is      */
 80071be:	bf00      	nop
 80071c0:	4b4f      	ldr	r3, [pc, #316]	; (8007300 <stm32_clock_init+0x180>)
 80071c2:	695b      	ldr	r3, [r3, #20]
 80071c4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80071c8:	2b00      	cmp	r3, #0
 80071ca:	d1f9      	bne.n	80071c0 <stm32_clock_init+0x40>
    ;                                       /* Wait until HSE is stable.    */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 80071cc:	4b4b      	ldr	r3, [pc, #300]	; (80072fc <stm32_clock_init+0x17c>)
 80071ce:	4a4b      	ldr	r2, [pc, #300]	; (80072fc <stm32_clock_init+0x17c>)
 80071d0:	f8d2 2094 	ldr.w	r2, [r2, #148]	; 0x94
 80071d4:	f042 0201 	orr.w	r2, r2, #1
 80071d8:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 80071dc:	bf00      	nop
 80071de:	4b47      	ldr	r3, [pc, #284]	; (80072fc <stm32_clock_init+0x17c>)
 80071e0:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80071e4:	f003 0302 	and.w	r3, r3, #2
 80071e8:	2b00      	cmp	r3, #0
 80071ea:	d0f8      	beq.n	80071de <stm32_clock_init+0x5e>
    ;                                       /* Wait until LSI is stable.    */
#endif

  /* Backup domain access enabled and left open.*/
  PWR->CR1 |= PWR_CR1_DBP;
 80071ec:	4b44      	ldr	r3, [pc, #272]	; (8007300 <stm32_clock_init+0x180>)
 80071ee:	4a44      	ldr	r2, [pc, #272]	; (8007300 <stm32_clock_init+0x180>)
 80071f0:	6812      	ldr	r2, [r2, #0]
 80071f2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80071f6:	601a      	str	r2, [r3, #0]
#if defined(STM32_LSE_BYPASS)
  /* LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON | RCC_BDCR_LSEBYP;
#else
  /* No LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON;
 80071f8:	4b40      	ldr	r3, [pc, #256]	; (80072fc <stm32_clock_init+0x17c>)
 80071fa:	4a40      	ldr	r2, [pc, #256]	; (80072fc <stm32_clock_init+0x17c>)
 80071fc:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 8007200:	f042 0219 	orr.w	r2, r2, #25
 8007204:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#endif
  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
 8007208:	bf00      	nop
 800720a:	4b3c      	ldr	r3, [pc, #240]	; (80072fc <stm32_clock_init+0x17c>)
 800720c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8007210:	f003 0302 	and.w	r3, r3, #2
 8007214:	2b00      	cmp	r3, #0
 8007216:	d0f8      	beq.n	800720a <stm32_clock_init+0x8a>
    ;                                       /* Wait until LSE is stable.    */
#endif

  /* Flash setup for selected MSI speed setting.*/
  FLASH->ACR = FLASH_ACR_DCEN | FLASH_ACR_ICEN | FLASH_ACR_PRFTEN |
 8007218:	4b3a      	ldr	r3, [pc, #232]	; (8007304 <stm32_clock_init+0x184>)
 800721a:	f44f 62e0 	mov.w	r2, #1792	; 0x700
 800721e:	601a      	str	r2, [r3, #0]
               STM32_MSI_FLASHBITS;

  /* Changing MSIRANGE to configured value.*/
  RCC->CR |= STM32_MSIRANGE;
 8007220:	4b36      	ldr	r3, [pc, #216]	; (80072fc <stm32_clock_init+0x17c>)
 8007222:	4a36      	ldr	r2, [pc, #216]	; (80072fc <stm32_clock_init+0x17c>)
 8007224:	6812      	ldr	r2, [r2, #0]
 8007226:	f042 0260 	orr.w	r2, r2, #96	; 0x60
 800722a:	601a      	str	r2, [r3, #0]

  /* Switching from MSISRANGE to MSIRANGE.*/
  RCC->CR |= RCC_CR_MSIRGSEL;
 800722c:	4b33      	ldr	r3, [pc, #204]	; (80072fc <stm32_clock_init+0x17c>)
 800722e:	4a33      	ldr	r2, [pc, #204]	; (80072fc <stm32_clock_init+0x17c>)
 8007230:	6812      	ldr	r2, [r2, #0]
 8007232:	f042 0208 	orr.w	r2, r2, #8
 8007236:	601a      	str	r2, [r3, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0)
 8007238:	bf00      	nop
 800723a:	4b30      	ldr	r3, [pc, #192]	; (80072fc <stm32_clock_init+0x17c>)
 800723c:	681b      	ldr	r3, [r3, #0]
 800723e:	f003 0302 	and.w	r3, r3, #2
 8007242:	2b00      	cmp	r3, #0
 8007244:	d0f9      	beq.n	800723a <stm32_clock_init+0xba>
    ;

  /* MSI is configured SYSCLK source so wait for it to be stable as well.*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI)
 8007246:	bf00      	nop
 8007248:	4b2c      	ldr	r3, [pc, #176]	; (80072fc <stm32_clock_init+0x17c>)
 800724a:	689b      	ldr	r3, [r3, #8]
 800724c:	f003 030c 	and.w	r3, r3, #12
 8007250:	2b00      	cmp	r3, #0
 8007252:	d1f9      	bne.n	8007248 <stm32_clock_init+0xc8>
    ;

#if STM32_MSIPLL_ENABLED
  /* MSI PLL (to LSE) activation */
  RCC->CR |= RCC_CR_MSIPLLEN;
 8007254:	4b29      	ldr	r3, [pc, #164]	; (80072fc <stm32_clock_init+0x17c>)
 8007256:	4a29      	ldr	r2, [pc, #164]	; (80072fc <stm32_clock_init+0x17c>)
 8007258:	6812      	ldr	r2, [r2, #0]
 800725a:	f042 0204 	orr.w	r2, r2, #4
 800725e:	601a      	str	r2, [r3, #0]
#endif

  /* Updating MSISRANGE value. MSISRANGE can be set only when MSIRGSEL is high.
     This range is used exiting the Standby mode until MSIRGSEL is set.*/
  RCC->CSR |= STM32_MSISRANGE;
 8007260:	4b26      	ldr	r3, [pc, #152]	; (80072fc <stm32_clock_init+0x17c>)
 8007262:	4a26      	ldr	r2, [pc, #152]	; (80072fc <stm32_clock_init+0x17c>)
 8007264:	f8d2 2094 	ldr.w	r2, [r2, #148]	; 0x94
 8007268:	f442 62c0 	orr.w	r2, r2, #1536	; 0x600
 800726c:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

#if STM32_ACTIVATE_PLL || STM32_ACTIVATE_PLLSAI1 || STM32_ACTIVATE_PLLSAI2
  /* PLLM and PLLSRC are common to all PLLs.*/
  RCC->PLLCFGR = STM32_PLLR   | STM32_PLLREN |
 8007270:	4b22      	ldr	r3, [pc, #136]	; (80072fc <stm32_clock_init+0x17c>)
 8007272:	4a25      	ldr	r2, [pc, #148]	; (8007308 <stm32_clock_init+0x188>)
 8007274:	60da      	str	r2, [r3, #12]
                 STM32_PLLSRC;
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR |= RCC_CR_PLLON;
 8007276:	4b21      	ldr	r3, [pc, #132]	; (80072fc <stm32_clock_init+0x17c>)
 8007278:	4a20      	ldr	r2, [pc, #128]	; (80072fc <stm32_clock_init+0x17c>)
 800727a:	6812      	ldr	r2, [r2, #0]
 800727c:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8007280:	601a      	str	r2, [r3, #0]

  /* Waiting for PLL lock.*/
  while ((RCC->CR & RCC_CR_PLLRDY) == 0)
 8007282:	bf00      	nop
 8007284:	4b1d      	ldr	r3, [pc, #116]	; (80072fc <stm32_clock_init+0x17c>)
 8007286:	681b      	ldr	r3, [r3, #0]
 8007288:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800728c:	2b00      	cmp	r3, #0
 800728e:	d0f9      	beq.n	8007284 <stm32_clock_init+0x104>
    ;
#endif

#if STM32_ACTIVATE_PLLSAI1
  /* PLLSAI1 activation.*/
  RCC->PLLSAI1CFGR = STM32_PLLSAI1R | STM32_PLLSAI1REN |
 8007290:	4b1a      	ldr	r3, [pc, #104]	; (80072fc <stm32_clock_init+0x17c>)
 8007292:	4a1e      	ldr	r2, [pc, #120]	; (800730c <stm32_clock_init+0x18c>)
 8007294:	611a      	str	r2, [r3, #16]
                     STM32_PLLSAI1Q | STM32_PLLSAI1QEN |
                     STM32_PLLSAI1P | STM32_PLLSAI1PEN |
                     STM32_PLLSAI1N;
  RCC->CR |= RCC_CR_PLLSAI1ON;
 8007296:	4b19      	ldr	r3, [pc, #100]	; (80072fc <stm32_clock_init+0x17c>)
 8007298:	4a18      	ldr	r2, [pc, #96]	; (80072fc <stm32_clock_init+0x17c>)
 800729a:	6812      	ldr	r2, [r2, #0]
 800729c:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 80072a0:	601a      	str	r2, [r3, #0]

  /* Waiting for PLL lock.*/
  while ((RCC->CR & RCC_CR_PLLSAI1RDY) == 0)
 80072a2:	bf00      	nop
 80072a4:	4b15      	ldr	r3, [pc, #84]	; (80072fc <stm32_clock_init+0x17c>)
 80072a6:	681b      	ldr	r3, [r3, #0]
 80072a8:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 80072ac:	2b00      	cmp	r3, #0
 80072ae:	d0f9      	beq.n	80072a4 <stm32_clock_init+0x124>
  while ((RCC->CR & RCC_CR_PLLSAI2RDY) == 0)
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCOPRE | STM32_MCOSEL | STM32_STOPWUCK |
 80072b0:	4b12      	ldr	r3, [pc, #72]	; (80072fc <stm32_clock_init+0x17c>)
 80072b2:	2200      	movs	r2, #0
 80072b4:	609a      	str	r2, [r3, #8]
              STM32_PPRE2  | STM32_PPRE1  | STM32_HPRE;

  /* CCIPR register initialization, note, must take care of the _OFF
     pseudo settings.*/
  {
    uint32_t ccipr = STM32_DFSDMSEL  | STM32_SWPMI1SEL | STM32_ADCSEL    |
 80072b6:	4b16      	ldr	r3, [pc, #88]	; (8007310 <stm32_clock_init+0x190>)
 80072b8:	9301      	str	r3, [sp, #4]
    ccipr |= STM32_SAI2SEL;
#endif
#if STM32_SAI1SEL != STM32_SAI1SEL_OFF
    ccipr |= STM32_SAI1SEL;
#endif
    RCC->CCIPR = ccipr;
 80072ba:	4b10      	ldr	r3, [pc, #64]	; (80072fc <stm32_clock_init+0x17c>)
 80072bc:	9a01      	ldr	r2, [sp, #4]
 80072be:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  }

  /* Set flash WS's for SYSCLK source */
  if (STM32_FLASHBITS > STM32_MSI_FLASHBITS)
    FLASH->ACR = (FLASH->ACR & ~FLASH_ACR_LATENCY_Msk) | STM32_FLASHBITS;
 80072c2:	4b10      	ldr	r3, [pc, #64]	; (8007304 <stm32_clock_init+0x184>)
 80072c4:	4a0f      	ldr	r2, [pc, #60]	; (8007304 <stm32_clock_init+0x184>)
 80072c6:	6812      	ldr	r2, [r2, #0]
 80072c8:	f022 0207 	bic.w	r2, r2, #7
 80072cc:	f042 0204 	orr.w	r2, r2, #4
 80072d0:	601a      	str	r2, [r3, #0]

  /* Switching to the configured SYSCLK source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_MSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 80072d2:	4b0a      	ldr	r3, [pc, #40]	; (80072fc <stm32_clock_init+0x17c>)
 80072d4:	4a09      	ldr	r2, [pc, #36]	; (80072fc <stm32_clock_init+0x17c>)
 80072d6:	6892      	ldr	r2, [r2, #8]
 80072d8:	f042 0203 	orr.w	r2, r2, #3
 80072dc:	609a      	str	r2, [r3, #8]
  /* Wait until SYSCLK is stable.*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80072de:	bf00      	nop
 80072e0:	4b06      	ldr	r3, [pc, #24]	; (80072fc <stm32_clock_init+0x17c>)
 80072e2:	689b      	ldr	r3, [r3, #8]
 80072e4:	f003 030c 	and.w	r3, r3, #12
 80072e8:	2b0c      	cmp	r3, #12
 80072ea:	d1f9      	bne.n	80072e0 <stm32_clock_init+0x160>

#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 80072ec:	4b03      	ldr	r3, [pc, #12]	; (80072fc <stm32_clock_init+0x17c>)
 80072ee:	4a03      	ldr	r2, [pc, #12]	; (80072fc <stm32_clock_init+0x17c>)
 80072f0:	6e12      	ldr	r2, [r2, #96]	; 0x60
 80072f2:	f042 0201 	orr.w	r2, r2, #1
 80072f6:	661a      	str	r2, [r3, #96]	; 0x60
}
 80072f8:	b002      	add	sp, #8
 80072fa:	4770      	bx	lr
 80072fc:	40021000 	.word	0x40021000
 8007300:	40007000 	.word	0x40007000
 8007304:	40022000 	.word	0x40022000
 8007308:	03405001 	.word	0x03405001
 800730c:	04504800 	.word	0x04504800
 8007310:	34015555 	.word	0x34015555
 8007314:	f3af 8000 	nop.w
 8007318:	f3af 8000 	nop.w
 800731c:	f3af 8000 	nop.w

08007320 <Vector6C>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8007320:	b500      	push	{lr}
 8007322:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 8007324:	2300      	movs	r3, #0
 8007326:	9301      	str	r3, [sp, #4]
 8007328:	4b14      	ldr	r3, [pc, #80]	; (800737c <Vector6C+0x5c>)
 800732a:	681a      	ldr	r2, [r3, #0]
 800732c:	2300      	movs	r3, #0
 800732e:	fa22 f303 	lsr.w	r3, r2, r3
 8007332:	f003 030f 	and.w	r3, r3, #15
 8007336:	9300      	str	r3, [sp, #0]
 8007338:	9b00      	ldr	r3, [sp, #0]
 800733a:	f003 030f 	and.w	r3, r3, #15
 800733e:	2b00      	cmp	r3, #0
 8007340:	d017      	beq.n	8007372 <Vector6C+0x52>
 8007342:	4b0e      	ldr	r3, [pc, #56]	; (800737c <Vector6C+0x5c>)
 8007344:	2200      	movs	r2, #0
 8007346:	9900      	ldr	r1, [sp, #0]
 8007348:	fa01 f202 	lsl.w	r2, r1, r2
 800734c:	605a      	str	r2, [r3, #4]
 800734e:	4b0c      	ldr	r3, [pc, #48]	; (8007380 <Vector6C+0x60>)
 8007350:	9a01      	ldr	r2, [sp, #4]
 8007352:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007356:	2b00      	cmp	r3, #0
 8007358:	d00b      	beq.n	8007372 <Vector6C+0x52>
 800735a:	4b09      	ldr	r3, [pc, #36]	; (8007380 <Vector6C+0x60>)
 800735c:	9a01      	ldr	r2, [sp, #4]
 800735e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007362:	4907      	ldr	r1, [pc, #28]	; (8007380 <Vector6C+0x60>)
 8007364:	9b01      	ldr	r3, [sp, #4]
 8007366:	00db      	lsls	r3, r3, #3
 8007368:	440b      	add	r3, r1
 800736a:	685b      	ldr	r3, [r3, #4]
 800736c:	4618      	mov	r0, r3
 800736e:	9900      	ldr	r1, [sp, #0]
 8007370:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007372:	f7fc fbed 	bl	8003b50 <_port_irq_epilogue>
}
 8007376:	b003      	add	sp, #12
 8007378:	f85d fb04 	ldr.w	pc, [sp], #4
 800737c:	40020000 	.word	0x40020000
 8007380:	20000ee8 	.word	0x20000ee8
 8007384:	f3af 8000 	nop.w
 8007388:	f3af 8000 	nop.w
 800738c:	f3af 8000 	nop.w

08007390 <Vector70>:
/**
 * @brief   DMA1 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8007390:	b500      	push	{lr}
 8007392:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 8007394:	2301      	movs	r3, #1
 8007396:	9301      	str	r3, [sp, #4]
 8007398:	4b14      	ldr	r3, [pc, #80]	; (80073ec <Vector70+0x5c>)
 800739a:	681a      	ldr	r2, [r3, #0]
 800739c:	2304      	movs	r3, #4
 800739e:	fa22 f303 	lsr.w	r3, r2, r3
 80073a2:	f003 030f 	and.w	r3, r3, #15
 80073a6:	9300      	str	r3, [sp, #0]
 80073a8:	9b00      	ldr	r3, [sp, #0]
 80073aa:	f003 030f 	and.w	r3, r3, #15
 80073ae:	2b00      	cmp	r3, #0
 80073b0:	d017      	beq.n	80073e2 <Vector70+0x52>
 80073b2:	4b0e      	ldr	r3, [pc, #56]	; (80073ec <Vector70+0x5c>)
 80073b4:	2204      	movs	r2, #4
 80073b6:	9900      	ldr	r1, [sp, #0]
 80073b8:	fa01 f202 	lsl.w	r2, r1, r2
 80073bc:	605a      	str	r2, [r3, #4]
 80073be:	4b0c      	ldr	r3, [pc, #48]	; (80073f0 <Vector70+0x60>)
 80073c0:	9a01      	ldr	r2, [sp, #4]
 80073c2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 80073c6:	2b00      	cmp	r3, #0
 80073c8:	d00b      	beq.n	80073e2 <Vector70+0x52>
 80073ca:	4b09      	ldr	r3, [pc, #36]	; (80073f0 <Vector70+0x60>)
 80073cc:	9a01      	ldr	r2, [sp, #4]
 80073ce:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 80073d2:	4907      	ldr	r1, [pc, #28]	; (80073f0 <Vector70+0x60>)
 80073d4:	9b01      	ldr	r3, [sp, #4]
 80073d6:	00db      	lsls	r3, r3, #3
 80073d8:	440b      	add	r3, r1
 80073da:	685b      	ldr	r3, [r3, #4]
 80073dc:	4618      	mov	r0, r3
 80073de:	9900      	ldr	r1, [sp, #0]
 80073e0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80073e2:	f7fc fbb5 	bl	8003b50 <_port_irq_epilogue>
}
 80073e6:	b003      	add	sp, #12
 80073e8:	f85d fb04 	ldr.w	pc, [sp], #4
 80073ec:	40020000 	.word	0x40020000
 80073f0:	20000ee8 	.word	0x20000ee8
 80073f4:	f3af 8000 	nop.w
 80073f8:	f3af 8000 	nop.w
 80073fc:	f3af 8000 	nop.w

08007400 <Vector74>:
/**
 * @brief   DMA1 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8007400:	b500      	push	{lr}
 8007402:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 8007404:	2302      	movs	r3, #2
 8007406:	9301      	str	r3, [sp, #4]
 8007408:	4b14      	ldr	r3, [pc, #80]	; (800745c <Vector74+0x5c>)
 800740a:	681a      	ldr	r2, [r3, #0]
 800740c:	2308      	movs	r3, #8
 800740e:	fa22 f303 	lsr.w	r3, r2, r3
 8007412:	f003 030f 	and.w	r3, r3, #15
 8007416:	9300      	str	r3, [sp, #0]
 8007418:	9b00      	ldr	r3, [sp, #0]
 800741a:	f003 030f 	and.w	r3, r3, #15
 800741e:	2b00      	cmp	r3, #0
 8007420:	d017      	beq.n	8007452 <Vector74+0x52>
 8007422:	4b0e      	ldr	r3, [pc, #56]	; (800745c <Vector74+0x5c>)
 8007424:	2208      	movs	r2, #8
 8007426:	9900      	ldr	r1, [sp, #0]
 8007428:	fa01 f202 	lsl.w	r2, r1, r2
 800742c:	605a      	str	r2, [r3, #4]
 800742e:	4b0c      	ldr	r3, [pc, #48]	; (8007460 <Vector74+0x60>)
 8007430:	9a01      	ldr	r2, [sp, #4]
 8007432:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007436:	2b00      	cmp	r3, #0
 8007438:	d00b      	beq.n	8007452 <Vector74+0x52>
 800743a:	4b09      	ldr	r3, [pc, #36]	; (8007460 <Vector74+0x60>)
 800743c:	9a01      	ldr	r2, [sp, #4]
 800743e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007442:	4907      	ldr	r1, [pc, #28]	; (8007460 <Vector74+0x60>)
 8007444:	9b01      	ldr	r3, [sp, #4]
 8007446:	00db      	lsls	r3, r3, #3
 8007448:	440b      	add	r3, r1
 800744a:	685b      	ldr	r3, [r3, #4]
 800744c:	4618      	mov	r0, r3
 800744e:	9900      	ldr	r1, [sp, #0]
 8007450:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007452:	f7fc fb7d 	bl	8003b50 <_port_irq_epilogue>
}
 8007456:	b003      	add	sp, #12
 8007458:	f85d fb04 	ldr.w	pc, [sp], #4
 800745c:	40020000 	.word	0x40020000
 8007460:	20000ee8 	.word	0x20000ee8
 8007464:	f3af 8000 	nop.w
 8007468:	f3af 8000 	nop.w
 800746c:	f3af 8000 	nop.w

08007470 <Vector78>:
/**
 * @brief   DMA1 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8007470:	b500      	push	{lr}
 8007472:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 8007474:	2303      	movs	r3, #3
 8007476:	9301      	str	r3, [sp, #4]
 8007478:	4b14      	ldr	r3, [pc, #80]	; (80074cc <Vector78+0x5c>)
 800747a:	681a      	ldr	r2, [r3, #0]
 800747c:	230c      	movs	r3, #12
 800747e:	fa22 f303 	lsr.w	r3, r2, r3
 8007482:	f003 030f 	and.w	r3, r3, #15
 8007486:	9300      	str	r3, [sp, #0]
 8007488:	9b00      	ldr	r3, [sp, #0]
 800748a:	f003 030f 	and.w	r3, r3, #15
 800748e:	2b00      	cmp	r3, #0
 8007490:	d017      	beq.n	80074c2 <Vector78+0x52>
 8007492:	4b0e      	ldr	r3, [pc, #56]	; (80074cc <Vector78+0x5c>)
 8007494:	220c      	movs	r2, #12
 8007496:	9900      	ldr	r1, [sp, #0]
 8007498:	fa01 f202 	lsl.w	r2, r1, r2
 800749c:	605a      	str	r2, [r3, #4]
 800749e:	4b0c      	ldr	r3, [pc, #48]	; (80074d0 <Vector78+0x60>)
 80074a0:	9a01      	ldr	r2, [sp, #4]
 80074a2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 80074a6:	2b00      	cmp	r3, #0
 80074a8:	d00b      	beq.n	80074c2 <Vector78+0x52>
 80074aa:	4b09      	ldr	r3, [pc, #36]	; (80074d0 <Vector78+0x60>)
 80074ac:	9a01      	ldr	r2, [sp, #4]
 80074ae:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 80074b2:	4907      	ldr	r1, [pc, #28]	; (80074d0 <Vector78+0x60>)
 80074b4:	9b01      	ldr	r3, [sp, #4]
 80074b6:	00db      	lsls	r3, r3, #3
 80074b8:	440b      	add	r3, r1
 80074ba:	685b      	ldr	r3, [r3, #4]
 80074bc:	4618      	mov	r0, r3
 80074be:	9900      	ldr	r1, [sp, #0]
 80074c0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80074c2:	f7fc fb45 	bl	8003b50 <_port_irq_epilogue>
}
 80074c6:	b003      	add	sp, #12
 80074c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80074cc:	40020000 	.word	0x40020000
 80074d0:	20000ee8 	.word	0x20000ee8
 80074d4:	f3af 8000 	nop.w
 80074d8:	f3af 8000 	nop.w
 80074dc:	f3af 8000 	nop.w

080074e0 <Vector7C>:
/**
 * @brief   DMA1 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 80074e0:	b500      	push	{lr}
 80074e2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 80074e4:	2304      	movs	r3, #4
 80074e6:	9301      	str	r3, [sp, #4]
 80074e8:	4b14      	ldr	r3, [pc, #80]	; (800753c <Vector7C+0x5c>)
 80074ea:	681a      	ldr	r2, [r3, #0]
 80074ec:	2310      	movs	r3, #16
 80074ee:	fa22 f303 	lsr.w	r3, r2, r3
 80074f2:	f003 030f 	and.w	r3, r3, #15
 80074f6:	9300      	str	r3, [sp, #0]
 80074f8:	9b00      	ldr	r3, [sp, #0]
 80074fa:	f003 030f 	and.w	r3, r3, #15
 80074fe:	2b00      	cmp	r3, #0
 8007500:	d017      	beq.n	8007532 <Vector7C+0x52>
 8007502:	4b0e      	ldr	r3, [pc, #56]	; (800753c <Vector7C+0x5c>)
 8007504:	2210      	movs	r2, #16
 8007506:	9900      	ldr	r1, [sp, #0]
 8007508:	fa01 f202 	lsl.w	r2, r1, r2
 800750c:	605a      	str	r2, [r3, #4]
 800750e:	4b0c      	ldr	r3, [pc, #48]	; (8007540 <Vector7C+0x60>)
 8007510:	9a01      	ldr	r2, [sp, #4]
 8007512:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007516:	2b00      	cmp	r3, #0
 8007518:	d00b      	beq.n	8007532 <Vector7C+0x52>
 800751a:	4b09      	ldr	r3, [pc, #36]	; (8007540 <Vector7C+0x60>)
 800751c:	9a01      	ldr	r2, [sp, #4]
 800751e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007522:	4907      	ldr	r1, [pc, #28]	; (8007540 <Vector7C+0x60>)
 8007524:	9b01      	ldr	r3, [sp, #4]
 8007526:	00db      	lsls	r3, r3, #3
 8007528:	440b      	add	r3, r1
 800752a:	685b      	ldr	r3, [r3, #4]
 800752c:	4618      	mov	r0, r3
 800752e:	9900      	ldr	r1, [sp, #0]
 8007530:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007532:	f7fc fb0d 	bl	8003b50 <_port_irq_epilogue>
}
 8007536:	b003      	add	sp, #12
 8007538:	f85d fb04 	ldr.w	pc, [sp], #4
 800753c:	40020000 	.word	0x40020000
 8007540:	20000ee8 	.word	0x20000ee8
 8007544:	f3af 8000 	nop.w
 8007548:	f3af 8000 	nop.w
 800754c:	f3af 8000 	nop.w

08007550 <Vector80>:
/**
 * @brief   DMA1 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8007550:	b500      	push	{lr}
 8007552:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 8007554:	2305      	movs	r3, #5
 8007556:	9301      	str	r3, [sp, #4]
 8007558:	4b14      	ldr	r3, [pc, #80]	; (80075ac <Vector80+0x5c>)
 800755a:	681a      	ldr	r2, [r3, #0]
 800755c:	2314      	movs	r3, #20
 800755e:	fa22 f303 	lsr.w	r3, r2, r3
 8007562:	f003 030f 	and.w	r3, r3, #15
 8007566:	9300      	str	r3, [sp, #0]
 8007568:	9b00      	ldr	r3, [sp, #0]
 800756a:	f003 030f 	and.w	r3, r3, #15
 800756e:	2b00      	cmp	r3, #0
 8007570:	d017      	beq.n	80075a2 <Vector80+0x52>
 8007572:	4b0e      	ldr	r3, [pc, #56]	; (80075ac <Vector80+0x5c>)
 8007574:	2214      	movs	r2, #20
 8007576:	9900      	ldr	r1, [sp, #0]
 8007578:	fa01 f202 	lsl.w	r2, r1, r2
 800757c:	605a      	str	r2, [r3, #4]
 800757e:	4b0c      	ldr	r3, [pc, #48]	; (80075b0 <Vector80+0x60>)
 8007580:	9a01      	ldr	r2, [sp, #4]
 8007582:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007586:	2b00      	cmp	r3, #0
 8007588:	d00b      	beq.n	80075a2 <Vector80+0x52>
 800758a:	4b09      	ldr	r3, [pc, #36]	; (80075b0 <Vector80+0x60>)
 800758c:	9a01      	ldr	r2, [sp, #4]
 800758e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007592:	4907      	ldr	r1, [pc, #28]	; (80075b0 <Vector80+0x60>)
 8007594:	9b01      	ldr	r3, [sp, #4]
 8007596:	00db      	lsls	r3, r3, #3
 8007598:	440b      	add	r3, r1
 800759a:	685b      	ldr	r3, [r3, #4]
 800759c:	4618      	mov	r0, r3
 800759e:	9900      	ldr	r1, [sp, #0]
 80075a0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80075a2:	f7fc fad5 	bl	8003b50 <_port_irq_epilogue>
}
 80075a6:	b003      	add	sp, #12
 80075a8:	f85d fb04 	ldr.w	pc, [sp], #4
 80075ac:	40020000 	.word	0x40020000
 80075b0:	20000ee8 	.word	0x20000ee8
 80075b4:	f3af 8000 	nop.w
 80075b8:	f3af 8000 	nop.w
 80075bc:	f3af 8000 	nop.w

080075c0 <Vector84>:
/**
 * @brief   DMA1 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 80075c0:	b500      	push	{lr}
 80075c2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 80075c4:	2306      	movs	r3, #6
 80075c6:	9301      	str	r3, [sp, #4]
 80075c8:	4b14      	ldr	r3, [pc, #80]	; (800761c <Vector84+0x5c>)
 80075ca:	681a      	ldr	r2, [r3, #0]
 80075cc:	2318      	movs	r3, #24
 80075ce:	fa22 f303 	lsr.w	r3, r2, r3
 80075d2:	f003 030f 	and.w	r3, r3, #15
 80075d6:	9300      	str	r3, [sp, #0]
 80075d8:	9b00      	ldr	r3, [sp, #0]
 80075da:	f003 030f 	and.w	r3, r3, #15
 80075de:	2b00      	cmp	r3, #0
 80075e0:	d017      	beq.n	8007612 <Vector84+0x52>
 80075e2:	4b0e      	ldr	r3, [pc, #56]	; (800761c <Vector84+0x5c>)
 80075e4:	2218      	movs	r2, #24
 80075e6:	9900      	ldr	r1, [sp, #0]
 80075e8:	fa01 f202 	lsl.w	r2, r1, r2
 80075ec:	605a      	str	r2, [r3, #4]
 80075ee:	4b0c      	ldr	r3, [pc, #48]	; (8007620 <Vector84+0x60>)
 80075f0:	9a01      	ldr	r2, [sp, #4]
 80075f2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 80075f6:	2b00      	cmp	r3, #0
 80075f8:	d00b      	beq.n	8007612 <Vector84+0x52>
 80075fa:	4b09      	ldr	r3, [pc, #36]	; (8007620 <Vector84+0x60>)
 80075fc:	9a01      	ldr	r2, [sp, #4]
 80075fe:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007602:	4907      	ldr	r1, [pc, #28]	; (8007620 <Vector84+0x60>)
 8007604:	9b01      	ldr	r3, [sp, #4]
 8007606:	00db      	lsls	r3, r3, #3
 8007608:	440b      	add	r3, r1
 800760a:	685b      	ldr	r3, [r3, #4]
 800760c:	4618      	mov	r0, r3
 800760e:	9900      	ldr	r1, [sp, #0]
 8007610:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007612:	f7fc fa9d 	bl	8003b50 <_port_irq_epilogue>
}
 8007616:	b003      	add	sp, #12
 8007618:	f85d fb04 	ldr.w	pc, [sp], #4
 800761c:	40020000 	.word	0x40020000
 8007620:	20000ee8 	.word	0x20000ee8
 8007624:	f3af 8000 	nop.w
 8007628:	f3af 8000 	nop.w
 800762c:	f3af 8000 	nop.w

08007630 <Vector120>:
/**
 * @brief   DMA2 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8007630:	b500      	push	{lr}
 8007632:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM1);
 8007634:	2307      	movs	r3, #7
 8007636:	9301      	str	r3, [sp, #4]
 8007638:	4b14      	ldr	r3, [pc, #80]	; (800768c <Vector120+0x5c>)
 800763a:	681a      	ldr	r2, [r3, #0]
 800763c:	2300      	movs	r3, #0
 800763e:	fa22 f303 	lsr.w	r3, r2, r3
 8007642:	f003 030f 	and.w	r3, r3, #15
 8007646:	9300      	str	r3, [sp, #0]
 8007648:	9b00      	ldr	r3, [sp, #0]
 800764a:	f003 030f 	and.w	r3, r3, #15
 800764e:	2b00      	cmp	r3, #0
 8007650:	d017      	beq.n	8007682 <Vector120+0x52>
 8007652:	4b0e      	ldr	r3, [pc, #56]	; (800768c <Vector120+0x5c>)
 8007654:	2200      	movs	r2, #0
 8007656:	9900      	ldr	r1, [sp, #0]
 8007658:	fa01 f202 	lsl.w	r2, r1, r2
 800765c:	605a      	str	r2, [r3, #4]
 800765e:	4b0c      	ldr	r3, [pc, #48]	; (8007690 <Vector120+0x60>)
 8007660:	9a01      	ldr	r2, [sp, #4]
 8007662:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007666:	2b00      	cmp	r3, #0
 8007668:	d00b      	beq.n	8007682 <Vector120+0x52>
 800766a:	4b09      	ldr	r3, [pc, #36]	; (8007690 <Vector120+0x60>)
 800766c:	9a01      	ldr	r2, [sp, #4]
 800766e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007672:	4907      	ldr	r1, [pc, #28]	; (8007690 <Vector120+0x60>)
 8007674:	9b01      	ldr	r3, [sp, #4]
 8007676:	00db      	lsls	r3, r3, #3
 8007678:	440b      	add	r3, r1
 800767a:	685b      	ldr	r3, [r3, #4]
 800767c:	4618      	mov	r0, r3
 800767e:	9900      	ldr	r1, [sp, #0]
 8007680:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007682:	f7fc fa65 	bl	8003b50 <_port_irq_epilogue>
}
 8007686:	b003      	add	sp, #12
 8007688:	f85d fb04 	ldr.w	pc, [sp], #4
 800768c:	40020400 	.word	0x40020400
 8007690:	20000ee8 	.word	0x20000ee8
 8007694:	f3af 8000 	nop.w
 8007698:	f3af 8000 	nop.w
 800769c:	f3af 8000 	nop.w

080076a0 <Vector124>:
/**
 * @brief   DMA2 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 80076a0:	b500      	push	{lr}
 80076a2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM2);
 80076a4:	2308      	movs	r3, #8
 80076a6:	9301      	str	r3, [sp, #4]
 80076a8:	4b14      	ldr	r3, [pc, #80]	; (80076fc <Vector124+0x5c>)
 80076aa:	681a      	ldr	r2, [r3, #0]
 80076ac:	2304      	movs	r3, #4
 80076ae:	fa22 f303 	lsr.w	r3, r2, r3
 80076b2:	f003 030f 	and.w	r3, r3, #15
 80076b6:	9300      	str	r3, [sp, #0]
 80076b8:	9b00      	ldr	r3, [sp, #0]
 80076ba:	f003 030f 	and.w	r3, r3, #15
 80076be:	2b00      	cmp	r3, #0
 80076c0:	d017      	beq.n	80076f2 <Vector124+0x52>
 80076c2:	4b0e      	ldr	r3, [pc, #56]	; (80076fc <Vector124+0x5c>)
 80076c4:	2204      	movs	r2, #4
 80076c6:	9900      	ldr	r1, [sp, #0]
 80076c8:	fa01 f202 	lsl.w	r2, r1, r2
 80076cc:	605a      	str	r2, [r3, #4]
 80076ce:	4b0c      	ldr	r3, [pc, #48]	; (8007700 <Vector124+0x60>)
 80076d0:	9a01      	ldr	r2, [sp, #4]
 80076d2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 80076d6:	2b00      	cmp	r3, #0
 80076d8:	d00b      	beq.n	80076f2 <Vector124+0x52>
 80076da:	4b09      	ldr	r3, [pc, #36]	; (8007700 <Vector124+0x60>)
 80076dc:	9a01      	ldr	r2, [sp, #4]
 80076de:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 80076e2:	4907      	ldr	r1, [pc, #28]	; (8007700 <Vector124+0x60>)
 80076e4:	9b01      	ldr	r3, [sp, #4]
 80076e6:	00db      	lsls	r3, r3, #3
 80076e8:	440b      	add	r3, r1
 80076ea:	685b      	ldr	r3, [r3, #4]
 80076ec:	4618      	mov	r0, r3
 80076ee:	9900      	ldr	r1, [sp, #0]
 80076f0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80076f2:	f7fc fa2d 	bl	8003b50 <_port_irq_epilogue>
}
 80076f6:	b003      	add	sp, #12
 80076f8:	f85d fb04 	ldr.w	pc, [sp], #4
 80076fc:	40020400 	.word	0x40020400
 8007700:	20000ee8 	.word	0x20000ee8
 8007704:	f3af 8000 	nop.w
 8007708:	f3af 8000 	nop.w
 800770c:	f3af 8000 	nop.w

08007710 <Vector128>:
/**
 * @brief   DMA2 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8007710:	b500      	push	{lr}
 8007712:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM3);
 8007714:	2309      	movs	r3, #9
 8007716:	9301      	str	r3, [sp, #4]
 8007718:	4b14      	ldr	r3, [pc, #80]	; (800776c <Vector128+0x5c>)
 800771a:	681a      	ldr	r2, [r3, #0]
 800771c:	2308      	movs	r3, #8
 800771e:	fa22 f303 	lsr.w	r3, r2, r3
 8007722:	f003 030f 	and.w	r3, r3, #15
 8007726:	9300      	str	r3, [sp, #0]
 8007728:	9b00      	ldr	r3, [sp, #0]
 800772a:	f003 030f 	and.w	r3, r3, #15
 800772e:	2b00      	cmp	r3, #0
 8007730:	d017      	beq.n	8007762 <Vector128+0x52>
 8007732:	4b0e      	ldr	r3, [pc, #56]	; (800776c <Vector128+0x5c>)
 8007734:	2208      	movs	r2, #8
 8007736:	9900      	ldr	r1, [sp, #0]
 8007738:	fa01 f202 	lsl.w	r2, r1, r2
 800773c:	605a      	str	r2, [r3, #4]
 800773e:	4b0c      	ldr	r3, [pc, #48]	; (8007770 <Vector128+0x60>)
 8007740:	9a01      	ldr	r2, [sp, #4]
 8007742:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007746:	2b00      	cmp	r3, #0
 8007748:	d00b      	beq.n	8007762 <Vector128+0x52>
 800774a:	4b09      	ldr	r3, [pc, #36]	; (8007770 <Vector128+0x60>)
 800774c:	9a01      	ldr	r2, [sp, #4]
 800774e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007752:	4907      	ldr	r1, [pc, #28]	; (8007770 <Vector128+0x60>)
 8007754:	9b01      	ldr	r3, [sp, #4]
 8007756:	00db      	lsls	r3, r3, #3
 8007758:	440b      	add	r3, r1
 800775a:	685b      	ldr	r3, [r3, #4]
 800775c:	4618      	mov	r0, r3
 800775e:	9900      	ldr	r1, [sp, #0]
 8007760:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007762:	f7fc f9f5 	bl	8003b50 <_port_irq_epilogue>
}
 8007766:	b003      	add	sp, #12
 8007768:	f85d fb04 	ldr.w	pc, [sp], #4
 800776c:	40020400 	.word	0x40020400
 8007770:	20000ee8 	.word	0x20000ee8
 8007774:	f3af 8000 	nop.w
 8007778:	f3af 8000 	nop.w
 800777c:	f3af 8000 	nop.w

08007780 <Vector12C>:
/**
 * @brief   DMA2 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8007780:	b500      	push	{lr}
 8007782:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM4);
 8007784:	230a      	movs	r3, #10
 8007786:	9301      	str	r3, [sp, #4]
 8007788:	4b14      	ldr	r3, [pc, #80]	; (80077dc <Vector12C+0x5c>)
 800778a:	681a      	ldr	r2, [r3, #0]
 800778c:	230c      	movs	r3, #12
 800778e:	fa22 f303 	lsr.w	r3, r2, r3
 8007792:	f003 030f 	and.w	r3, r3, #15
 8007796:	9300      	str	r3, [sp, #0]
 8007798:	9b00      	ldr	r3, [sp, #0]
 800779a:	f003 030f 	and.w	r3, r3, #15
 800779e:	2b00      	cmp	r3, #0
 80077a0:	d017      	beq.n	80077d2 <Vector12C+0x52>
 80077a2:	4b0e      	ldr	r3, [pc, #56]	; (80077dc <Vector12C+0x5c>)
 80077a4:	220c      	movs	r2, #12
 80077a6:	9900      	ldr	r1, [sp, #0]
 80077a8:	fa01 f202 	lsl.w	r2, r1, r2
 80077ac:	605a      	str	r2, [r3, #4]
 80077ae:	4b0c      	ldr	r3, [pc, #48]	; (80077e0 <Vector12C+0x60>)
 80077b0:	9a01      	ldr	r2, [sp, #4]
 80077b2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 80077b6:	2b00      	cmp	r3, #0
 80077b8:	d00b      	beq.n	80077d2 <Vector12C+0x52>
 80077ba:	4b09      	ldr	r3, [pc, #36]	; (80077e0 <Vector12C+0x60>)
 80077bc:	9a01      	ldr	r2, [sp, #4]
 80077be:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 80077c2:	4907      	ldr	r1, [pc, #28]	; (80077e0 <Vector12C+0x60>)
 80077c4:	9b01      	ldr	r3, [sp, #4]
 80077c6:	00db      	lsls	r3, r3, #3
 80077c8:	440b      	add	r3, r1
 80077ca:	685b      	ldr	r3, [r3, #4]
 80077cc:	4618      	mov	r0, r3
 80077ce:	9900      	ldr	r1, [sp, #0]
 80077d0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80077d2:	f7fc f9bd 	bl	8003b50 <_port_irq_epilogue>
}
 80077d6:	b003      	add	sp, #12
 80077d8:	f85d fb04 	ldr.w	pc, [sp], #4
 80077dc:	40020400 	.word	0x40020400
 80077e0:	20000ee8 	.word	0x20000ee8
 80077e4:	f3af 8000 	nop.w
 80077e8:	f3af 8000 	nop.w
 80077ec:	f3af 8000 	nop.w

080077f0 <Vector130>:
/**
 * @brief   DMA2 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 80077f0:	b500      	push	{lr}
 80077f2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM5);
 80077f4:	230b      	movs	r3, #11
 80077f6:	9301      	str	r3, [sp, #4]
 80077f8:	4b14      	ldr	r3, [pc, #80]	; (800784c <Vector130+0x5c>)
 80077fa:	681a      	ldr	r2, [r3, #0]
 80077fc:	2310      	movs	r3, #16
 80077fe:	fa22 f303 	lsr.w	r3, r2, r3
 8007802:	f003 030f 	and.w	r3, r3, #15
 8007806:	9300      	str	r3, [sp, #0]
 8007808:	9b00      	ldr	r3, [sp, #0]
 800780a:	f003 030f 	and.w	r3, r3, #15
 800780e:	2b00      	cmp	r3, #0
 8007810:	d017      	beq.n	8007842 <Vector130+0x52>
 8007812:	4b0e      	ldr	r3, [pc, #56]	; (800784c <Vector130+0x5c>)
 8007814:	2210      	movs	r2, #16
 8007816:	9900      	ldr	r1, [sp, #0]
 8007818:	fa01 f202 	lsl.w	r2, r1, r2
 800781c:	605a      	str	r2, [r3, #4]
 800781e:	4b0c      	ldr	r3, [pc, #48]	; (8007850 <Vector130+0x60>)
 8007820:	9a01      	ldr	r2, [sp, #4]
 8007822:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007826:	2b00      	cmp	r3, #0
 8007828:	d00b      	beq.n	8007842 <Vector130+0x52>
 800782a:	4b09      	ldr	r3, [pc, #36]	; (8007850 <Vector130+0x60>)
 800782c:	9a01      	ldr	r2, [sp, #4]
 800782e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007832:	4907      	ldr	r1, [pc, #28]	; (8007850 <Vector130+0x60>)
 8007834:	9b01      	ldr	r3, [sp, #4]
 8007836:	00db      	lsls	r3, r3, #3
 8007838:	440b      	add	r3, r1
 800783a:	685b      	ldr	r3, [r3, #4]
 800783c:	4618      	mov	r0, r3
 800783e:	9900      	ldr	r1, [sp, #0]
 8007840:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007842:	f7fc f985 	bl	8003b50 <_port_irq_epilogue>
}
 8007846:	b003      	add	sp, #12
 8007848:	f85d fb04 	ldr.w	pc, [sp], #4
 800784c:	40020400 	.word	0x40020400
 8007850:	20000ee8 	.word	0x20000ee8
 8007854:	f3af 8000 	nop.w
 8007858:	f3af 8000 	nop.w
 800785c:	f3af 8000 	nop.w

08007860 <Vector150>:
/**
 * @brief   DMA2 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8007860:	b500      	push	{lr}
 8007862:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM6);
 8007864:	230c      	movs	r3, #12
 8007866:	9301      	str	r3, [sp, #4]
 8007868:	4b14      	ldr	r3, [pc, #80]	; (80078bc <Vector150+0x5c>)
 800786a:	681a      	ldr	r2, [r3, #0]
 800786c:	2314      	movs	r3, #20
 800786e:	fa22 f303 	lsr.w	r3, r2, r3
 8007872:	f003 030f 	and.w	r3, r3, #15
 8007876:	9300      	str	r3, [sp, #0]
 8007878:	9b00      	ldr	r3, [sp, #0]
 800787a:	f003 030f 	and.w	r3, r3, #15
 800787e:	2b00      	cmp	r3, #0
 8007880:	d017      	beq.n	80078b2 <Vector150+0x52>
 8007882:	4b0e      	ldr	r3, [pc, #56]	; (80078bc <Vector150+0x5c>)
 8007884:	2214      	movs	r2, #20
 8007886:	9900      	ldr	r1, [sp, #0]
 8007888:	fa01 f202 	lsl.w	r2, r1, r2
 800788c:	605a      	str	r2, [r3, #4]
 800788e:	4b0c      	ldr	r3, [pc, #48]	; (80078c0 <Vector150+0x60>)
 8007890:	9a01      	ldr	r2, [sp, #4]
 8007892:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007896:	2b00      	cmp	r3, #0
 8007898:	d00b      	beq.n	80078b2 <Vector150+0x52>
 800789a:	4b09      	ldr	r3, [pc, #36]	; (80078c0 <Vector150+0x60>)
 800789c:	9a01      	ldr	r2, [sp, #4]
 800789e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 80078a2:	4907      	ldr	r1, [pc, #28]	; (80078c0 <Vector150+0x60>)
 80078a4:	9b01      	ldr	r3, [sp, #4]
 80078a6:	00db      	lsls	r3, r3, #3
 80078a8:	440b      	add	r3, r1
 80078aa:	685b      	ldr	r3, [r3, #4]
 80078ac:	4618      	mov	r0, r3
 80078ae:	9900      	ldr	r1, [sp, #0]
 80078b0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80078b2:	f7fc f94d 	bl	8003b50 <_port_irq_epilogue>
}
 80078b6:	b003      	add	sp, #12
 80078b8:	f85d fb04 	ldr.w	pc, [sp], #4
 80078bc:	40020400 	.word	0x40020400
 80078c0:	20000ee8 	.word	0x20000ee8
 80078c4:	f3af 8000 	nop.w
 80078c8:	f3af 8000 	nop.w
 80078cc:	f3af 8000 	nop.w

080078d0 <Vector154>:
/**
 * @brief   DMA2 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 80078d0:	b500      	push	{lr}
 80078d2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM7);
 80078d4:	230d      	movs	r3, #13
 80078d6:	9301      	str	r3, [sp, #4]
 80078d8:	4b14      	ldr	r3, [pc, #80]	; (800792c <Vector154+0x5c>)
 80078da:	681a      	ldr	r2, [r3, #0]
 80078dc:	2318      	movs	r3, #24
 80078de:	fa22 f303 	lsr.w	r3, r2, r3
 80078e2:	f003 030f 	and.w	r3, r3, #15
 80078e6:	9300      	str	r3, [sp, #0]
 80078e8:	9b00      	ldr	r3, [sp, #0]
 80078ea:	f003 030f 	and.w	r3, r3, #15
 80078ee:	2b00      	cmp	r3, #0
 80078f0:	d017      	beq.n	8007922 <Vector154+0x52>
 80078f2:	4b0e      	ldr	r3, [pc, #56]	; (800792c <Vector154+0x5c>)
 80078f4:	2218      	movs	r2, #24
 80078f6:	9900      	ldr	r1, [sp, #0]
 80078f8:	fa01 f202 	lsl.w	r2, r1, r2
 80078fc:	605a      	str	r2, [r3, #4]
 80078fe:	4b0c      	ldr	r3, [pc, #48]	; (8007930 <Vector154+0x60>)
 8007900:	9a01      	ldr	r2, [sp, #4]
 8007902:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007906:	2b00      	cmp	r3, #0
 8007908:	d00b      	beq.n	8007922 <Vector154+0x52>
 800790a:	4b09      	ldr	r3, [pc, #36]	; (8007930 <Vector154+0x60>)
 800790c:	9a01      	ldr	r2, [sp, #4]
 800790e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007912:	4907      	ldr	r1, [pc, #28]	; (8007930 <Vector154+0x60>)
 8007914:	9b01      	ldr	r3, [sp, #4]
 8007916:	00db      	lsls	r3, r3, #3
 8007918:	440b      	add	r3, r1
 800791a:	685b      	ldr	r3, [r3, #4]
 800791c:	4618      	mov	r0, r3
 800791e:	9900      	ldr	r1, [sp, #0]
 8007920:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007922:	f7fc f915 	bl	8003b50 <_port_irq_epilogue>
}
 8007926:	b003      	add	sp, #12
 8007928:	f85d fb04 	ldr.w	pc, [sp], #4
 800792c:	40020400 	.word	0x40020400
 8007930:	20000ee8 	.word	0x20000ee8
 8007934:	f3af 8000 	nop.w
 8007938:	f3af 8000 	nop.w
 800793c:	f3af 8000 	nop.w

08007940 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8007940:	b082      	sub	sp, #8
  int i;

  dma_streams_mask = 0U;
 8007942:	4b12      	ldr	r3, [pc, #72]	; (800798c <dmaInit+0x4c>)
 8007944:	2200      	movs	r2, #0
 8007946:	601a      	str	r2, [r3, #0]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8007948:	2300      	movs	r3, #0
 800794a:	9301      	str	r3, [sp, #4]
 800794c:	e011      	b.n	8007972 <dmaInit+0x32>
    _stm32_dma_streams[i].channel->CCR = 0U;
 800794e:	4910      	ldr	r1, [pc, #64]	; (8007990 <dmaInit+0x50>)
 8007950:	9a01      	ldr	r2, [sp, #4]
 8007952:	4613      	mov	r3, r2
 8007954:	009b      	lsls	r3, r3, #2
 8007956:	4413      	add	r3, r2
 8007958:	009b      	lsls	r3, r3, #2
 800795a:	440b      	add	r3, r1
 800795c:	685b      	ldr	r3, [r3, #4]
 800795e:	2200      	movs	r2, #0
 8007960:	601a      	str	r2, [r3, #0]
    _stm32_dma_isr_redir[i].dma_func = NULL;
 8007962:	4b0c      	ldr	r3, [pc, #48]	; (8007994 <dmaInit+0x54>)
 8007964:	9a01      	ldr	r2, [sp, #4]
 8007966:	2100      	movs	r1, #0
 8007968:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 800796c:	9b01      	ldr	r3, [sp, #4]
 800796e:	3301      	adds	r3, #1
 8007970:	9301      	str	r3, [sp, #4]
 8007972:	9b01      	ldr	r3, [sp, #4]
 8007974:	2b0d      	cmp	r3, #13
 8007976:	ddea      	ble.n	800794e <dmaInit+0xe>
    _stm32_dma_streams[i].channel->CCR = 0U;
    _stm32_dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 8007978:	4b07      	ldr	r3, [pc, #28]	; (8007998 <dmaInit+0x58>)
 800797a:	f04f 32ff 	mov.w	r2, #4294967295
 800797e:	605a      	str	r2, [r3, #4]
#if STM32_DMA2_NUM_CHANNELS > 0
  DMA2->IFCR = 0xFFFFFFFFU;
 8007980:	4b06      	ldr	r3, [pc, #24]	; (800799c <dmaInit+0x5c>)
 8007982:	f04f 32ff 	mov.w	r2, #4294967295
 8007986:	605a      	str	r2, [r3, #4]
#endif
}
 8007988:	b002      	add	sp, #8
 800798a:	4770      	bx	lr
 800798c:	20000928 	.word	0x20000928
 8007990:	08015f90 	.word	0x08015f90
 8007994:	20000ee8 	.word	0x20000ee8
 8007998:	40020000 	.word	0x40020000
 800799c:	40020400 	.word	0x40020400

080079a0 <dmaStreamAllocate>:
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {
 80079a0:	b500      	push	{lr}
 80079a2:	b085      	sub	sp, #20
 80079a4:	9003      	str	r0, [sp, #12]
 80079a6:	9102      	str	r1, [sp, #8]
 80079a8:	9201      	str	r2, [sp, #4]
 80079aa:	9300      	str	r3, [sp, #0]

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 80079ac:	9b03      	ldr	r3, [sp, #12]
 80079ae:	7c5b      	ldrb	r3, [r3, #17]
 80079b0:	2201      	movs	r2, #1
 80079b2:	409a      	lsls	r2, r3
 80079b4:	4b2f      	ldr	r3, [pc, #188]	; (8007a74 <dmaStreamAllocate+0xd4>)
 80079b6:	681b      	ldr	r3, [r3, #0]
 80079b8:	4013      	ands	r3, r2
 80079ba:	2b00      	cmp	r3, #0
 80079bc:	d001      	beq.n	80079c2 <dmaStreamAllocate+0x22>
    return true;
 80079be:	2301      	movs	r3, #1
 80079c0:	e053      	b.n	8007a6a <dmaStreamAllocate+0xca>

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
 80079c2:	9b03      	ldr	r3, [sp, #12]
 80079c4:	7c5b      	ldrb	r3, [r3, #17]
 80079c6:	461a      	mov	r2, r3
 80079c8:	4b2b      	ldr	r3, [pc, #172]	; (8007a78 <dmaStreamAllocate+0xd8>)
 80079ca:	9901      	ldr	r1, [sp, #4]
 80079cc:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 80079d0:	9b03      	ldr	r3, [sp, #12]
 80079d2:	7c5b      	ldrb	r3, [r3, #17]
 80079d4:	4a28      	ldr	r2, [pc, #160]	; (8007a78 <dmaStreamAllocate+0xd8>)
 80079d6:	00db      	lsls	r3, r3, #3
 80079d8:	4413      	add	r3, r2
 80079da:	9a00      	ldr	r2, [sp, #0]
 80079dc:	605a      	str	r2, [r3, #4]

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 80079de:	4b25      	ldr	r3, [pc, #148]	; (8007a74 <dmaStreamAllocate+0xd4>)
 80079e0:	681b      	ldr	r3, [r3, #0]
 80079e2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80079e6:	2b00      	cmp	r3, #0
 80079e8:	d105      	bne.n	80079f6 <dmaStreamAllocate+0x56>
    rccEnableDMA1(false);
 80079ea:	4b24      	ldr	r3, [pc, #144]	; (8007a7c <dmaStreamAllocate+0xdc>)
 80079ec:	4a23      	ldr	r2, [pc, #140]	; (8007a7c <dmaStreamAllocate+0xdc>)
 80079ee:	6c92      	ldr	r2, [r2, #72]	; 0x48
 80079f0:	f042 0201 	orr.w	r2, r2, #1
 80079f4:	649a      	str	r2, [r3, #72]	; 0x48
  }
#if STM32_DMA2_NUM_CHANNELS > 0
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
 80079f6:	4b1f      	ldr	r3, [pc, #124]	; (8007a74 <dmaStreamAllocate+0xd4>)
 80079f8:	681b      	ldr	r3, [r3, #0]
 80079fa:	f403 537e 	and.w	r3, r3, #16256	; 0x3f80
 80079fe:	2b00      	cmp	r3, #0
 8007a00:	d105      	bne.n	8007a0e <dmaStreamAllocate+0x6e>
    rccEnableDMA2(false);
 8007a02:	4b1e      	ldr	r3, [pc, #120]	; (8007a7c <dmaStreamAllocate+0xdc>)
 8007a04:	4a1d      	ldr	r2, [pc, #116]	; (8007a7c <dmaStreamAllocate+0xdc>)
 8007a06:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8007a08:	f042 0202 	orr.w	r2, r2, #2
 8007a0c:	649a      	str	r2, [r3, #72]	; 0x48
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8007a0e:	9b03      	ldr	r3, [sp, #12]
 8007a10:	685b      	ldr	r3, [r3, #4]
 8007a12:	9a03      	ldr	r2, [sp, #12]
 8007a14:	6852      	ldr	r2, [r2, #4]
 8007a16:	6812      	ldr	r2, [r2, #0]
 8007a18:	f022 020f 	bic.w	r2, r2, #15
 8007a1c:	601a      	str	r2, [r3, #0]
 8007a1e:	9b03      	ldr	r3, [sp, #12]
 8007a20:	681b      	ldr	r3, [r3, #0]
 8007a22:	9a03      	ldr	r2, [sp, #12]
 8007a24:	7c12      	ldrb	r2, [r2, #16]
 8007a26:	210f      	movs	r1, #15
 8007a28:	fa01 f202 	lsl.w	r2, r1, r2
 8007a2c:	605a      	str	r2, [r3, #4]
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8007a2e:	9b03      	ldr	r3, [sp, #12]
 8007a30:	685b      	ldr	r3, [r3, #4]
 8007a32:	2200      	movs	r2, #0
 8007a34:	601a      	str	r2, [r3, #0]

  /* Enables the associated IRQ vector if not alread enabled and if a
     callback is defined.*/
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 8007a36:	9b03      	ldr	r3, [sp, #12]
 8007a38:	689a      	ldr	r2, [r3, #8]
 8007a3a:	4b0e      	ldr	r3, [pc, #56]	; (8007a74 <dmaStreamAllocate+0xd4>)
 8007a3c:	681b      	ldr	r3, [r3, #0]
 8007a3e:	4013      	ands	r3, r2
 8007a40:	2b00      	cmp	r3, #0
 8007a42:	d108      	bne.n	8007a56 <dmaStreamAllocate+0xb6>
 8007a44:	9b01      	ldr	r3, [sp, #4]
 8007a46:	2b00      	cmp	r3, #0
 8007a48:	d005      	beq.n	8007a56 <dmaStreamAllocate+0xb6>
      (func != NULL)) {
    nvicEnableVector(dmastp->vector, priority);
 8007a4a:	9b03      	ldr	r3, [sp, #12]
 8007a4c:	7c9b      	ldrb	r3, [r3, #18]
 8007a4e:	4618      	mov	r0, r3
 8007a50:	9902      	ldr	r1, [sp, #8]
 8007a52:	f7ff fa95 	bl	8006f80 <nvicEnableVector>
  }

  /* Marks the stream as allocated.*/
  dma_streams_mask |= (1U << dmastp->selfindex);
 8007a56:	9b03      	ldr	r3, [sp, #12]
 8007a58:	7c5b      	ldrb	r3, [r3, #17]
 8007a5a:	2201      	movs	r2, #1
 8007a5c:	409a      	lsls	r2, r3
 8007a5e:	4b05      	ldr	r3, [pc, #20]	; (8007a74 <dmaStreamAllocate+0xd4>)
 8007a60:	681b      	ldr	r3, [r3, #0]
 8007a62:	431a      	orrs	r2, r3
 8007a64:	4b03      	ldr	r3, [pc, #12]	; (8007a74 <dmaStreamAllocate+0xd4>)
 8007a66:	601a      	str	r2, [r3, #0]

  return false;
 8007a68:	2300      	movs	r3, #0
}
 8007a6a:	4618      	mov	r0, r3
 8007a6c:	b005      	add	sp, #20
 8007a6e:	f85d fb04 	ldr.w	pc, [sp], #4
 8007a72:	bf00      	nop
 8007a74:	20000928 	.word	0x20000928
 8007a78:	20000ee8 	.word	0x20000ee8
 8007a7c:	40021000 	.word	0x40021000

08007a80 <dmaStreamRelease>:
 *
 * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
 *
 * @special
 */
void dmaStreamRelease(const stm32_dma_stream_t *dmastp) {
 8007a80:	b500      	push	{lr}
 8007a82:	b083      	sub	sp, #12
 8007a84:	9001      	str	r0, [sp, #4]
  /* Check if the streams is not taken.*/
  osalDbgAssert((dma_streams_mask & (1 << dmastp->selfindex)) != 0U,
                "not allocated");

  /* Marks the stream as not allocated.*/
  dma_streams_mask &= ~(1U << dmastp->selfindex);
 8007a86:	9b01      	ldr	r3, [sp, #4]
 8007a88:	7c5b      	ldrb	r3, [r3, #17]
 8007a8a:	2201      	movs	r2, #1
 8007a8c:	fa02 f303 	lsl.w	r3, r2, r3
 8007a90:	43da      	mvns	r2, r3
 8007a92:	4b1d      	ldr	r3, [pc, #116]	; (8007b08 <dmaStreamRelease+0x88>)
 8007a94:	681b      	ldr	r3, [r3, #0]
 8007a96:	401a      	ands	r2, r3
 8007a98:	4b1b      	ldr	r3, [pc, #108]	; (8007b08 <dmaStreamRelease+0x88>)
 8007a9a:	601a      	str	r2, [r3, #0]

  /* Disables the associated IRQ vector if it is no more in use.*/
  if ((dma_streams_mask & dmastp->cmask) == 0U) {
 8007a9c:	9b01      	ldr	r3, [sp, #4]
 8007a9e:	689a      	ldr	r2, [r3, #8]
 8007aa0:	4b19      	ldr	r3, [pc, #100]	; (8007b08 <dmaStreamRelease+0x88>)
 8007aa2:	681b      	ldr	r3, [r3, #0]
 8007aa4:	4013      	ands	r3, r2
 8007aa6:	2b00      	cmp	r3, #0
 8007aa8:	d104      	bne.n	8007ab4 <dmaStreamRelease+0x34>
    nvicDisableVector(dmastp->vector);
 8007aaa:	9b01      	ldr	r3, [sp, #4]
 8007aac:	7c9b      	ldrb	r3, [r3, #18]
 8007aae:	4618      	mov	r0, r3
 8007ab0:	f7ff fa8e 	bl	8006fd0 <nvicDisableVector>
  }

  /* Removes the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = NULL;
 8007ab4:	9b01      	ldr	r3, [sp, #4]
 8007ab6:	7c5b      	ldrb	r3, [r3, #17]
 8007ab8:	461a      	mov	r2, r3
 8007aba:	4b14      	ldr	r3, [pc, #80]	; (8007b0c <dmaStreamRelease+0x8c>)
 8007abc:	2100      	movs	r1, #0
 8007abe:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = NULL;
 8007ac2:	9b01      	ldr	r3, [sp, #4]
 8007ac4:	7c5b      	ldrb	r3, [r3, #17]
 8007ac6:	4a11      	ldr	r2, [pc, #68]	; (8007b0c <dmaStreamRelease+0x8c>)
 8007ac8:	00db      	lsls	r3, r3, #3
 8007aca:	4413      	add	r3, r2
 8007acc:	2200      	movs	r2, #0
 8007ace:	605a      	str	r2, [r3, #4]

  /* Shutting down clocks that are no more required, if any.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8007ad0:	4b0d      	ldr	r3, [pc, #52]	; (8007b08 <dmaStreamRelease+0x88>)
 8007ad2:	681b      	ldr	r3, [r3, #0]
 8007ad4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8007ad8:	2b00      	cmp	r3, #0
 8007ada:	d105      	bne.n	8007ae8 <dmaStreamRelease+0x68>
    rccDisableDMA1(false);
 8007adc:	4b0c      	ldr	r3, [pc, #48]	; (8007b10 <dmaStreamRelease+0x90>)
 8007ade:	4a0c      	ldr	r2, [pc, #48]	; (8007b10 <dmaStreamRelease+0x90>)
 8007ae0:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8007ae2:	f022 0201 	bic.w	r2, r2, #1
 8007ae6:	649a      	str	r2, [r3, #72]	; 0x48
  }
#if STM32_DMA2_NUM_CHANNELS > 0
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
 8007ae8:	4b07      	ldr	r3, [pc, #28]	; (8007b08 <dmaStreamRelease+0x88>)
 8007aea:	681b      	ldr	r3, [r3, #0]
 8007aec:	f403 537e 	and.w	r3, r3, #16256	; 0x3f80
 8007af0:	2b00      	cmp	r3, #0
 8007af2:	d105      	bne.n	8007b00 <dmaStreamRelease+0x80>
    rccDisableDMA2(false);
 8007af4:	4b06      	ldr	r3, [pc, #24]	; (8007b10 <dmaStreamRelease+0x90>)
 8007af6:	4a06      	ldr	r2, [pc, #24]	; (8007b10 <dmaStreamRelease+0x90>)
 8007af8:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8007afa:	f022 0202 	bic.w	r2, r2, #2
 8007afe:	649a      	str	r2, [r3, #72]	; 0x48
  }
#endif
}
 8007b00:	b003      	add	sp, #12
 8007b02:	f85d fb04 	ldr.w	pc, [sp], #4
 8007b06:	bf00      	nop
 8007b08:	20000928 	.word	0x20000928
 8007b0c:	20000ee8 	.word	0x20000ee8
 8007b10:	40021000 	.word	0x40021000
 8007b14:	f3af 8000 	nop.w
 8007b18:	f3af 8000 	nop.w
 8007b1c:	f3af 8000 	nop.w

08007b20 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8007b20:	b082      	sub	sp, #8
 8007b22:	2320      	movs	r3, #32
 8007b24:	9301      	str	r3, [sp, #4]
 8007b26:	9b01      	ldr	r3, [sp, #4]
 8007b28:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8007b2c:	b002      	add	sp, #8
 8007b2e:	4770      	bx	lr

08007b30 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8007b30:	b082      	sub	sp, #8
 8007b32:	2300      	movs	r3, #0
 8007b34:	9301      	str	r3, [sp, #4]
 8007b36:	9b01      	ldr	r3, [sp, #4]
 8007b38:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8007b3c:	b002      	add	sp, #8
 8007b3e:	4770      	bx	lr

08007b40 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8007b40:	b508      	push	{r3, lr}

  port_lock();
 8007b42:	f7ff ffed 	bl	8007b20 <port_lock>
}
 8007b46:	bd08      	pop	{r3, pc}
 8007b48:	f3af 8000 	nop.w
 8007b4c:	f3af 8000 	nop.w

08007b50 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8007b50:	b508      	push	{r3, lr}

  port_unlock();
 8007b52:	f7ff ffed 	bl	8007b30 <port_unlock>
}
 8007b56:	bd08      	pop	{r3, pc}
 8007b58:	f3af 8000 	nop.w
 8007b5c:	f3af 8000 	nop.w

08007b60 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8007b60:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8007b62:	f7ff ffed 	bl	8007b40 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8007b66:	bd08      	pop	{r3, pc}
 8007b68:	f3af 8000 	nop.w
 8007b6c:	f3af 8000 	nop.w

08007b70 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8007b70:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8007b72:	f7ff ffed 	bl	8007b50 <port_unlock_from_isr>
}
 8007b76:	bd08      	pop	{r3, pc}
 8007b78:	f3af 8000 	nop.w
 8007b7c:	f3af 8000 	nop.w

08007b80 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8007b80:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8007b82:	f7ff ffed 	bl	8007b60 <chSysLockFromISR>
}
 8007b86:	bd08      	pop	{r3, pc}
 8007b88:	f3af 8000 	nop.w
 8007b8c:	f3af 8000 	nop.w

08007b90 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8007b90:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8007b92:	f7ff ffed 	bl	8007b70 <chSysUnlockFromISR>
}
 8007b96:	bd08      	pop	{r3, pc}
 8007b98:	f3af 8000 	nop.w
 8007b9c:	f3af 8000 	nop.w

08007ba0 <osalOsTimerHandlerI>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
 8007ba0:	b508      	push	{r3, lr}

  chSysTimerHandlerI();
 8007ba2:	f7f8 fe55 	bl	8000850 <chSysTimerHandlerI>
}
 8007ba6:	bd08      	pop	{r3, pc}
 8007ba8:	f3af 8000 	nop.w
 8007bac:	f3af 8000 	nop.w

08007bb0 <SysTick_Handler>:
 * @brief   System Timer vector.
 * @details This interrupt is used for system tick in periodic mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(SysTick_Handler) {
 8007bb0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  osalSysLockFromISR();
 8007bb2:	f7ff ffe5 	bl	8007b80 <osalSysLockFromISR>
  osalOsTimerHandlerI();
 8007bb6:	f7ff fff3 	bl	8007ba0 <osalOsTimerHandlerI>
  osalSysUnlockFromISR();
 8007bba:	f7ff ffe9 	bl	8007b90 <osalSysUnlockFromISR>

  OSAL_IRQ_EPILOGUE();
 8007bbe:	f7fb ffc7 	bl	8003b50 <_port_irq_epilogue>
}
 8007bc2:	bd08      	pop	{r3, pc}
 8007bc4:	f3af 8000 	nop.w
 8007bc8:	f3af 8000 	nop.w
 8007bcc:	f3af 8000 	nop.w

08007bd0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 8007bd0:	b508      	push	{r3, lr}
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */

#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
 8007bd2:	4b07      	ldr	r3, [pc, #28]	; (8007bf0 <st_lld_init+0x20>)
 8007bd4:	4a07      	ldr	r2, [pc, #28]	; (8007bf4 <st_lld_init+0x24>)
 8007bd6:	605a      	str	r2, [r3, #4]
  SysTick->VAL = 0;
 8007bd8:	4b05      	ldr	r3, [pc, #20]	; (8007bf0 <st_lld_init+0x20>)
 8007bda:	2200      	movs	r2, #0
 8007bdc:	609a      	str	r2, [r3, #8]
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
 8007bde:	4b04      	ldr	r3, [pc, #16]	; (8007bf0 <st_lld_init+0x20>)
 8007be0:	2207      	movs	r2, #7
 8007be2:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
 8007be4:	200b      	movs	r0, #11
 8007be6:	2108      	movs	r1, #8
 8007be8:	f7ff fa12 	bl	8007010 <nvicSetSystemHandlerPriority>
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8007bec:	bd08      	pop	{r3, pc}
 8007bee:	bf00      	nop
 8007bf0:	e000e010 	.word	0xe000e010
 8007bf4:	0001387f 	.word	0x0001387f
 8007bf8:	f3af 8000 	nop.w
 8007bfc:	f3af 8000 	nop.w

08007c00 <initgpio>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
 8007c00:	b082      	sub	sp, #8
 8007c02:	9001      	str	r0, [sp, #4]
 8007c04:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8007c06:	9b00      	ldr	r3, [sp, #0]
 8007c08:	685a      	ldr	r2, [r3, #4]
 8007c0a:	9b01      	ldr	r3, [sp, #4]
 8007c0c:	605a      	str	r2, [r3, #4]
  gpiop->ASCR    = config->ascr;
 8007c0e:	9b00      	ldr	r3, [sp, #0]
 8007c10:	69da      	ldr	r2, [r3, #28]
 8007c12:	9b01      	ldr	r3, [sp, #4]
 8007c14:	62da      	str	r2, [r3, #44]	; 0x2c
  gpiop->OSPEEDR = config->ospeedr;
 8007c16:	9b00      	ldr	r3, [sp, #0]
 8007c18:	689a      	ldr	r2, [r3, #8]
 8007c1a:	9b01      	ldr	r3, [sp, #4]
 8007c1c:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8007c1e:	9b00      	ldr	r3, [sp, #0]
 8007c20:	68da      	ldr	r2, [r3, #12]
 8007c22:	9b01      	ldr	r3, [sp, #4]
 8007c24:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 8007c26:	9b00      	ldr	r3, [sp, #0]
 8007c28:	691a      	ldr	r2, [r3, #16]
 8007c2a:	9b01      	ldr	r3, [sp, #4]
 8007c2c:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8007c2e:	9b00      	ldr	r3, [sp, #0]
 8007c30:	695a      	ldr	r2, [r3, #20]
 8007c32:	9b01      	ldr	r3, [sp, #4]
 8007c34:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8007c36:	9b00      	ldr	r3, [sp, #0]
 8007c38:	699a      	ldr	r2, [r3, #24]
 8007c3a:	9b01      	ldr	r3, [sp, #4]
 8007c3c:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8007c3e:	9b00      	ldr	r3, [sp, #0]
 8007c40:	681a      	ldr	r2, [r3, #0]
 8007c42:	9b01      	ldr	r3, [sp, #4]
 8007c44:	601a      	str	r2, [r3, #0]
  gpiop->LOCKR   = config->lockr;
 8007c46:	9b00      	ldr	r3, [sp, #0]
 8007c48:	6a1a      	ldr	r2, [r3, #32]
 8007c4a:	9b01      	ldr	r3, [sp, #4]
 8007c4c:	61da      	str	r2, [r3, #28]
}
 8007c4e:	b002      	add	sp, #8
 8007c50:	4770      	bx	lr
 8007c52:	bf00      	nop
 8007c54:	f3af 8000 	nop.w
 8007c58:	f3af 8000 	nop.w
 8007c5c:	f3af 8000 	nop.w

08007c60 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 8007c60:	b500      	push	{lr}
 8007c62:	b083      	sub	sp, #12
 8007c64:	9001      	str	r0, [sp, #4]

  /*
   * Enables the GPIO related clocks.
   */
#if defined(STM32L4XX)
  RCC->AHB2ENR   |= AHB1_EN_MASK;
 8007c66:	4b1c      	ldr	r3, [pc, #112]	; (8007cd8 <_pal_lld_init+0x78>)
 8007c68:	4a1b      	ldr	r2, [pc, #108]	; (8007cd8 <_pal_lld_init+0x78>)
 8007c6a:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 8007c6c:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
 8007c70:	64da      	str	r2, [r3, #76]	; 0x4c

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
 8007c72:	9b01      	ldr	r3, [sp, #4]
 8007c74:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8007c78:	4619      	mov	r1, r3
 8007c7a:	f7ff ffc1 	bl	8007c00 <initgpio>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
 8007c7e:	9b01      	ldr	r3, [sp, #4]
 8007c80:	3324      	adds	r3, #36	; 0x24
 8007c82:	4816      	ldr	r0, [pc, #88]	; (8007cdc <_pal_lld_init+0x7c>)
 8007c84:	4619      	mov	r1, r3
 8007c86:	f7ff ffbb 	bl	8007c00 <initgpio>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
 8007c8a:	9b01      	ldr	r3, [sp, #4]
 8007c8c:	3348      	adds	r3, #72	; 0x48
 8007c8e:	4814      	ldr	r0, [pc, #80]	; (8007ce0 <_pal_lld_init+0x80>)
 8007c90:	4619      	mov	r1, r3
 8007c92:	f7ff ffb5 	bl	8007c00 <initgpio>
#endif
#if STM32_HAS_GPIOD
  initgpio(GPIOD, &config->PDData);
 8007c96:	9b01      	ldr	r3, [sp, #4]
 8007c98:	336c      	adds	r3, #108	; 0x6c
 8007c9a:	4812      	ldr	r0, [pc, #72]	; (8007ce4 <_pal_lld_init+0x84>)
 8007c9c:	4619      	mov	r1, r3
 8007c9e:	f7ff ffaf 	bl	8007c00 <initgpio>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
 8007ca2:	9b01      	ldr	r3, [sp, #4]
 8007ca4:	3390      	adds	r3, #144	; 0x90
 8007ca6:	4810      	ldr	r0, [pc, #64]	; (8007ce8 <_pal_lld_init+0x88>)
 8007ca8:	4619      	mov	r1, r3
 8007caa:	f7ff ffa9 	bl	8007c00 <initgpio>
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
 8007cae:	9b01      	ldr	r3, [sp, #4]
 8007cb0:	33b4      	adds	r3, #180	; 0xb4
 8007cb2:	480e      	ldr	r0, [pc, #56]	; (8007cec <_pal_lld_init+0x8c>)
 8007cb4:	4619      	mov	r1, r3
 8007cb6:	f7ff ffa3 	bl	8007c00 <initgpio>
#endif
#if STM32_HAS_GPIOG
  initgpio(GPIOG, &config->PGData);
 8007cba:	9b01      	ldr	r3, [sp, #4]
 8007cbc:	33d8      	adds	r3, #216	; 0xd8
 8007cbe:	480c      	ldr	r0, [pc, #48]	; (8007cf0 <_pal_lld_init+0x90>)
 8007cc0:	4619      	mov	r1, r3
 8007cc2:	f7ff ff9d 	bl	8007c00 <initgpio>
#endif
#if STM32_HAS_GPIOH
  initgpio(GPIOH, &config->PHData);
 8007cc6:	9b01      	ldr	r3, [sp, #4]
 8007cc8:	33fc      	adds	r3, #252	; 0xfc
 8007cca:	480a      	ldr	r0, [pc, #40]	; (8007cf4 <_pal_lld_init+0x94>)
 8007ccc:	4619      	mov	r1, r3
 8007cce:	f7ff ff97 	bl	8007c00 <initgpio>
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
 8007cd2:	b003      	add	sp, #12
 8007cd4:	f85d fb04 	ldr.w	pc, [sp], #4
 8007cd8:	40021000 	.word	0x40021000
 8007cdc:	48000400 	.word	0x48000400
 8007ce0:	48000800 	.word	0x48000800
 8007ce4:	48000c00 	.word	0x48000c00
 8007ce8:	48001000 	.word	0x48001000
 8007cec:	48001400 	.word	0x48001400
 8007cf0:	48001800 	.word	0x48001800
 8007cf4:	48001c00 	.word	0x48001c00
 8007cf8:	f3af 8000 	nop.w
 8007cfc:	f3af 8000 	nop.w

08007d00 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8007d00:	b090      	sub	sp, #64	; 0x40
 8007d02:	9003      	str	r0, [sp, #12]
 8007d04:	9102      	str	r1, [sp, #8]
 8007d06:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8007d08:	9b01      	ldr	r3, [sp, #4]
 8007d0a:	f003 0303 	and.w	r3, r3, #3
 8007d0e:	930f      	str	r3, [sp, #60]	; 0x3c
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8007d10:	9b01      	ldr	r3, [sp, #4]
 8007d12:	f003 0304 	and.w	r3, r3, #4
 8007d16:	089b      	lsrs	r3, r3, #2
 8007d18:	930e      	str	r3, [sp, #56]	; 0x38
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 8007d1a:	9b01      	ldr	r3, [sp, #4]
 8007d1c:	f003 0318 	and.w	r3, r3, #24
 8007d20:	08db      	lsrs	r3, r3, #3
 8007d22:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8007d24:	9b01      	ldr	r3, [sp, #4]
 8007d26:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8007d2a:	095b      	lsrs	r3, r3, #5
 8007d2c:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8007d2e:	9b01      	ldr	r3, [sp, #4]
 8007d30:	f403 63f0 	and.w	r3, r3, #1920	; 0x780
 8007d34:	09db      	lsrs	r3, r3, #7
 8007d36:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t ascr    = (mode & PAL_STM32_ASCR_MASK) >> 11;
 8007d38:	9b01      	ldr	r3, [sp, #4]
 8007d3a:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8007d3e:	0adb      	lsrs	r3, r3, #11
 8007d40:	9309      	str	r3, [sp, #36]	; 0x24
  uint32_t lockr   = (mode & PAL_STM32_LOCKR_MASK) >> 12;
 8007d42:	9b01      	ldr	r3, [sp, #4]
 8007d44:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8007d48:	0b1b      	lsrs	r3, r3, #12
 8007d4a:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 8007d4c:	2300      	movs	r3, #0
 8007d4e:	930b      	str	r3, [sp, #44]	; 0x2c
  while (true) {
    if ((mask & 1) != 0) {
 8007d50:	9b02      	ldr	r3, [sp, #8]
 8007d52:	f003 0301 	and.w	r3, r3, #1
 8007d56:	2b00      	cmp	r3, #0
 8007d58:	f000 808a 	beq.w	8007e70 <_pal_lld_setgroupmode+0x170>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8007d5c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8007d5e:	f003 0307 	and.w	r3, r3, #7
 8007d62:	009b      	lsls	r3, r3, #2
 8007d64:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8007d66:	fa02 f303 	lsl.w	r3, r2, r3
 8007d6a:	9307      	str	r3, [sp, #28]
      m1 = 1 << bit;
 8007d6c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8007d6e:	2201      	movs	r2, #1
 8007d70:	fa02 f303 	lsl.w	r3, r2, r3
 8007d74:	9306      	str	r3, [sp, #24]
      m2 = 3 << (bit * 2);
 8007d76:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8007d78:	005b      	lsls	r3, r3, #1
 8007d7a:	2203      	movs	r2, #3
 8007d7c:	fa02 f303 	lsl.w	r3, r2, r3
 8007d80:	9305      	str	r3, [sp, #20]
      m4 = 15 << ((bit & 7) * 4);
 8007d82:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8007d84:	f003 0307 	and.w	r3, r3, #7
 8007d88:	009b      	lsls	r3, r3, #2
 8007d8a:	220f      	movs	r2, #15
 8007d8c:	fa02 f303 	lsl.w	r3, r2, r3
 8007d90:	9304      	str	r3, [sp, #16]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8007d92:	9b03      	ldr	r3, [sp, #12]
 8007d94:	685a      	ldr	r2, [r3, #4]
 8007d96:	9b06      	ldr	r3, [sp, #24]
 8007d98:	43db      	mvns	r3, r3
 8007d9a:	401a      	ands	r2, r3
 8007d9c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8007d9e:	431a      	orrs	r2, r3
 8007da0:	9b03      	ldr	r3, [sp, #12]
 8007da2:	605a      	str	r2, [r3, #4]
      port->ASCR    = (port->ASCR & ~m1) | ascr;
 8007da4:	9b03      	ldr	r3, [sp, #12]
 8007da6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8007da8:	9b06      	ldr	r3, [sp, #24]
 8007daa:	43db      	mvns	r3, r3
 8007dac:	401a      	ands	r2, r3
 8007dae:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8007db0:	431a      	orrs	r2, r3
 8007db2:	9b03      	ldr	r3, [sp, #12]
 8007db4:	62da      	str	r2, [r3, #44]	; 0x2c
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8007db6:	9b03      	ldr	r3, [sp, #12]
 8007db8:	689a      	ldr	r2, [r3, #8]
 8007dba:	9b05      	ldr	r3, [sp, #20]
 8007dbc:	43db      	mvns	r3, r3
 8007dbe:	401a      	ands	r2, r3
 8007dc0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007dc2:	431a      	orrs	r2, r3
 8007dc4:	9b03      	ldr	r3, [sp, #12]
 8007dc6:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8007dc8:	9b03      	ldr	r3, [sp, #12]
 8007dca:	68da      	ldr	r2, [r3, #12]
 8007dcc:	9b05      	ldr	r3, [sp, #20]
 8007dce:	43db      	mvns	r3, r3
 8007dd0:	401a      	ands	r2, r3
 8007dd2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8007dd4:	431a      	orrs	r2, r3
 8007dd6:	9b03      	ldr	r3, [sp, #12]
 8007dd8:	60da      	str	r2, [r3, #12]
       if (moder == PAL_STM32_MODE_ALTERNATE) {
 8007dda:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8007ddc:	2b02      	cmp	r3, #2
 8007dde:	d11f      	bne.n	8007e20 <_pal_lld_setgroupmode+0x120>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 8007de0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8007de2:	2b07      	cmp	r3, #7
 8007de4:	d809      	bhi.n	8007dfa <_pal_lld_setgroupmode+0xfa>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8007de6:	9b03      	ldr	r3, [sp, #12]
 8007de8:	6a1a      	ldr	r2, [r3, #32]
 8007dea:	9b04      	ldr	r3, [sp, #16]
 8007dec:	43db      	mvns	r3, r3
 8007dee:	401a      	ands	r2, r3
 8007df0:	9b07      	ldr	r3, [sp, #28]
 8007df2:	431a      	orrs	r2, r3
 8007df4:	9b03      	ldr	r3, [sp, #12]
 8007df6:	621a      	str	r2, [r3, #32]
 8007df8:	e008      	b.n	8007e0c <_pal_lld_setgroupmode+0x10c>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8007dfa:	9b03      	ldr	r3, [sp, #12]
 8007dfc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8007dfe:	9b04      	ldr	r3, [sp, #16]
 8007e00:	43db      	mvns	r3, r3
 8007e02:	401a      	ands	r2, r3
 8007e04:	9b07      	ldr	r3, [sp, #28]
 8007e06:	431a      	orrs	r2, r3
 8007e08:	9b03      	ldr	r3, [sp, #12]
 8007e0a:	625a      	str	r2, [r3, #36]	; 0x24
        port->MODER   = (port->MODER & ~m2) | moder;
 8007e0c:	9b03      	ldr	r3, [sp, #12]
 8007e0e:	681a      	ldr	r2, [r3, #0]
 8007e10:	9b05      	ldr	r3, [sp, #20]
 8007e12:	43db      	mvns	r3, r3
 8007e14:	401a      	ands	r2, r3
 8007e16:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8007e18:	431a      	orrs	r2, r3
 8007e1a:	9b03      	ldr	r3, [sp, #12]
 8007e1c:	601a      	str	r2, [r3, #0]
 8007e1e:	e01e      	b.n	8007e5e <_pal_lld_setgroupmode+0x15e>
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 8007e20:	9b03      	ldr	r3, [sp, #12]
 8007e22:	681a      	ldr	r2, [r3, #0]
 8007e24:	9b05      	ldr	r3, [sp, #20]
 8007e26:	43db      	mvns	r3, r3
 8007e28:	401a      	ands	r2, r3
 8007e2a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8007e2c:	431a      	orrs	r2, r3
 8007e2e:	9b03      	ldr	r3, [sp, #12]
 8007e30:	601a      	str	r2, [r3, #0]
        if (bit < 8)
 8007e32:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8007e34:	2b07      	cmp	r3, #7
 8007e36:	d809      	bhi.n	8007e4c <_pal_lld_setgroupmode+0x14c>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8007e38:	9b03      	ldr	r3, [sp, #12]
 8007e3a:	6a1a      	ldr	r2, [r3, #32]
 8007e3c:	9b04      	ldr	r3, [sp, #16]
 8007e3e:	43db      	mvns	r3, r3
 8007e40:	401a      	ands	r2, r3
 8007e42:	9b07      	ldr	r3, [sp, #28]
 8007e44:	431a      	orrs	r2, r3
 8007e46:	9b03      	ldr	r3, [sp, #12]
 8007e48:	621a      	str	r2, [r3, #32]
 8007e4a:	e008      	b.n	8007e5e <_pal_lld_setgroupmode+0x15e>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8007e4c:	9b03      	ldr	r3, [sp, #12]
 8007e4e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8007e50:	9b04      	ldr	r3, [sp, #16]
 8007e52:	43db      	mvns	r3, r3
 8007e54:	401a      	ands	r2, r3
 8007e56:	9b07      	ldr	r3, [sp, #28]
 8007e58:	431a      	orrs	r2, r3
 8007e5a:	9b03      	ldr	r3, [sp, #12]
 8007e5c:	625a      	str	r2, [r3, #36]	; 0x24
      }
      port->LOCKR   = (port->LOCKR & ~m1) | lockr;
 8007e5e:	9b03      	ldr	r3, [sp, #12]
 8007e60:	69da      	ldr	r2, [r3, #28]
 8007e62:	9b06      	ldr	r3, [sp, #24]
 8007e64:	43db      	mvns	r3, r3
 8007e66:	401a      	ands	r2, r3
 8007e68:	9b08      	ldr	r3, [sp, #32]
 8007e6a:	431a      	orrs	r2, r3
 8007e6c:	9b03      	ldr	r3, [sp, #12]
 8007e6e:	61da      	str	r2, [r3, #28]
    }
    mask >>= 1;
 8007e70:	9b02      	ldr	r3, [sp, #8]
 8007e72:	085b      	lsrs	r3, r3, #1
 8007e74:	9302      	str	r3, [sp, #8]
    if (!mask)
 8007e76:	9b02      	ldr	r3, [sp, #8]
 8007e78:	2b00      	cmp	r3, #0
 8007e7a:	d100      	bne.n	8007e7e <_pal_lld_setgroupmode+0x17e>
      return;
 8007e7c:	e00f      	b.n	8007e9e <_pal_lld_setgroupmode+0x19e>
    otyper <<= 1;
 8007e7e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8007e80:	005b      	lsls	r3, r3, #1
 8007e82:	930e      	str	r3, [sp, #56]	; 0x38
    ospeedr <<= 2;
 8007e84:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007e86:	009b      	lsls	r3, r3, #2
 8007e88:	930d      	str	r3, [sp, #52]	; 0x34
    pupdr <<= 2;
 8007e8a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8007e8c:	009b      	lsls	r3, r3, #2
 8007e8e:	930c      	str	r3, [sp, #48]	; 0x30
    moder <<= 2;
 8007e90:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8007e92:	009b      	lsls	r3, r3, #2
 8007e94:	930f      	str	r3, [sp, #60]	; 0x3c
    bit++;
 8007e96:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8007e98:	3301      	adds	r3, #1
 8007e9a:	930b      	str	r3, [sp, #44]	; 0x2c
  }
 8007e9c:	e758      	b.n	8007d50 <_pal_lld_setgroupmode+0x50>
}
 8007e9e:	b010      	add	sp, #64	; 0x40
 8007ea0:	4770      	bx	lr
 8007ea2:	bf00      	nop
 8007ea4:	f3af 8000 	nop.w
 8007ea8:	f3af 8000 	nop.w
 8007eac:	f3af 8000 	nop.w

08007eb0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8007eb0:	b082      	sub	sp, #8
 8007eb2:	2320      	movs	r3, #32
 8007eb4:	9301      	str	r3, [sp, #4]
 8007eb6:	9b01      	ldr	r3, [sp, #4]
 8007eb8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8007ebc:	b002      	add	sp, #8
 8007ebe:	4770      	bx	lr

08007ec0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8007ec0:	b082      	sub	sp, #8
 8007ec2:	2300      	movs	r3, #0
 8007ec4:	9301      	str	r3, [sp, #4]
 8007ec6:	9b01      	ldr	r3, [sp, #4]
 8007ec8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8007ecc:	b002      	add	sp, #8
 8007ece:	4770      	bx	lr

08007ed0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8007ed0:	b508      	push	{r3, lr}

  port_lock();
 8007ed2:	f7ff ffed 	bl	8007eb0 <port_lock>
}
 8007ed6:	bd08      	pop	{r3, pc}
 8007ed8:	f3af 8000 	nop.w
 8007edc:	f3af 8000 	nop.w

08007ee0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8007ee0:	b508      	push	{r3, lr}

  port_unlock();
 8007ee2:	f7ff ffed 	bl	8007ec0 <port_unlock>
}
 8007ee6:	bd08      	pop	{r3, pc}
 8007ee8:	f3af 8000 	nop.w
 8007eec:	f3af 8000 	nop.w

08007ef0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8007ef0:	b508      	push	{r3, lr}

  port_lock();
 8007ef2:	f7ff ffdd 	bl	8007eb0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8007ef6:	bd08      	pop	{r3, pc}
 8007ef8:	f3af 8000 	nop.w
 8007efc:	f3af 8000 	nop.w

08007f00 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8007f00:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8007f02:	f7ff ffdd 	bl	8007ec0 <port_unlock>
}
 8007f06:	bd08      	pop	{r3, pc}
 8007f08:	f3af 8000 	nop.w
 8007f0c:	f3af 8000 	nop.w

08007f10 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8007f10:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8007f12:	f7ff ffdd 	bl	8007ed0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8007f16:	bd08      	pop	{r3, pc}
 8007f18:	f3af 8000 	nop.w
 8007f1c:	f3af 8000 	nop.w

08007f20 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8007f20:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8007f22:	f7ff ffdd 	bl	8007ee0 <port_unlock_from_isr>
}
 8007f26:	bd08      	pop	{r3, pc}
 8007f28:	f3af 8000 	nop.w
 8007f2c:	f3af 8000 	nop.w

08007f30 <chThdStartI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
static inline thread_t *chThdStartI(thread_t *tp) {
 8007f30:	b500      	push	{lr}
 8007f32:	b083      	sub	sp, #12
 8007f34:	9001      	str	r0, [sp, #4]

  chDbgAssert(tp->p_state == CH_STATE_WTSTART, "wrong state");

  return chSchReadyI(tp);
 8007f36:	9801      	ldr	r0, [sp, #4]
 8007f38:	f7f8 fe32 	bl	8000ba0 <chSchReadyI>
 8007f3c:	4603      	mov	r3, r0
}
 8007f3e:	4618      	mov	r0, r3
 8007f40:	b003      	add	sp, #12
 8007f42:	f85d fb04 	ldr.w	pc, [sp], #4
 8007f46:	bf00      	nop
 8007f48:	f3af 8000 	nop.w
 8007f4c:	f3af 8000 	nop.w

08007f50 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8007f50:	b082      	sub	sp, #8
 8007f52:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8007f54:	4b02      	ldr	r3, [pc, #8]	; (8007f60 <chRegSetThreadName+0x10>)
 8007f56:	699b      	ldr	r3, [r3, #24]
 8007f58:	9a01      	ldr	r2, [sp, #4]
 8007f5a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 8007f5c:	b002      	add	sp, #8
 8007f5e:	4770      	bx	lr
 8007f60:	20000d98 	.word	0x20000d98
 8007f64:	f3af 8000 	nop.w
 8007f68:	f3af 8000 	nop.w
 8007f6c:	f3af 8000 	nop.w

08007f70 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8007f70:	b508      	push	{r3, lr}

  chSysLock();
 8007f72:	f7ff ffbd 	bl	8007ef0 <chSysLock>
}
 8007f76:	bd08      	pop	{r3, pc}
 8007f78:	f3af 8000 	nop.w
 8007f7c:	f3af 8000 	nop.w

08007f80 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8007f80:	b508      	push	{r3, lr}

  chSysUnlock();
 8007f82:	f7ff ffbd 	bl	8007f00 <chSysUnlock>
}
 8007f86:	bd08      	pop	{r3, pc}
 8007f88:	f3af 8000 	nop.w
 8007f8c:	f3af 8000 	nop.w

08007f90 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8007f90:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8007f92:	f7ff ffbd 	bl	8007f10 <chSysLockFromISR>
}
 8007f96:	bd08      	pop	{r3, pc}
 8007f98:	f3af 8000 	nop.w
 8007f9c:	f3af 8000 	nop.w

08007fa0 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8007fa0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8007fa2:	f7ff ffbd 	bl	8007f20 <chSysUnlockFromISR>
}
 8007fa6:	bd08      	pop	{r3, pc}
 8007fa8:	f3af 8000 	nop.w
 8007fac:	f3af 8000 	nop.w

08007fb0 <osalSysPolledDelayX>:
 * @param[in] cycles    number of cycles
 *
 * @xclass
 */
#if PORT_SUPPORTS_RT || defined(__DOXYGEN__)
static inline void osalSysPolledDelayX(rtcnt_t cycles) {
 8007fb0:	b500      	push	{lr}
 8007fb2:	b083      	sub	sp, #12
 8007fb4:	9001      	str	r0, [sp, #4]

  chSysPolledDelayX(cycles);
 8007fb6:	9801      	ldr	r0, [sp, #4]
 8007fb8:	f7f8 fcb2 	bl	8000920 <chSysPolledDelayX>
}
 8007fbc:	b003      	add	sp, #12
 8007fbe:	f85d fb04 	ldr.w	pc, [sp], #4
 8007fc2:	bf00      	nop
 8007fc4:	f3af 8000 	nop.w
 8007fc8:	f3af 8000 	nop.w
 8007fcc:	f3af 8000 	nop.w

08007fd0 <osalThreadSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 8007fd0:	b500      	push	{lr}
 8007fd2:	b083      	sub	sp, #12
 8007fd4:	9001      	str	r0, [sp, #4]

  return chThdSuspendS(trp);
 8007fd6:	9801      	ldr	r0, [sp, #4]
 8007fd8:	f7f9 fa3a 	bl	8001450 <chThdSuspendS>
 8007fdc:	4603      	mov	r3, r0
}
 8007fde:	4618      	mov	r0, r3
 8007fe0:	b003      	add	sp, #12
 8007fe2:	f85d fb04 	ldr.w	pc, [sp], #4
 8007fe6:	bf00      	nop
 8007fe8:	f3af 8000 	nop.w
 8007fec:	f3af 8000 	nop.w

08007ff0 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 8007ff0:	b500      	push	{lr}
 8007ff2:	b083      	sub	sp, #12
 8007ff4:	9001      	str	r0, [sp, #4]
 8007ff6:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
 8007ff8:	9801      	ldr	r0, [sp, #4]
 8007ffa:	9900      	ldr	r1, [sp, #0]
 8007ffc:	f7f9 fa60 	bl	80014c0 <chThdResumeI>
}
 8008000:	b003      	add	sp, #12
 8008002:	f85d fb04 	ldr.w	pc, [sp], #4
 8008006:	bf00      	nop
 8008008:	f3af 8000 	nop.w
 800800c:	f3af 8000 	nop.w

08008010 <otg_core_reset>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void otg_core_reset(USBDriver *usbp) {
 8008010:	b500      	push	{lr}
 8008012:	b085      	sub	sp, #20
 8008014:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8008016:	9b01      	ldr	r3, [sp, #4]
 8008018:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800801a:	9303      	str	r3, [sp, #12]

  osalSysPolledDelayX(32);
 800801c:	2020      	movs	r0, #32
 800801e:	f7ff ffc7 	bl	8007fb0 <osalSysPolledDelayX>

  /* Core reset and delay of at least 3 PHY cycles.*/
  otgp->GRSTCTL = GRSTCTL_CSRST;
 8008022:	9b03      	ldr	r3, [sp, #12]
 8008024:	2201      	movs	r2, #1
 8008026:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
 8008028:	bf00      	nop
 800802a:	9b03      	ldr	r3, [sp, #12]
 800802c:	691b      	ldr	r3, [r3, #16]
 800802e:	f003 0301 	and.w	r3, r3, #1
 8008032:	2b00      	cmp	r3, #0
 8008034:	d1f9      	bne.n	800802a <otg_core_reset+0x1a>
    ;

  osalSysPolledDelayX(18);
 8008036:	2012      	movs	r0, #18
 8008038:	f7ff ffba 	bl	8007fb0 <osalSysPolledDelayX>

  /* Wait AHB idle condition.*/
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 800803c:	bf00      	nop
 800803e:	9b03      	ldr	r3, [sp, #12]
 8008040:	691b      	ldr	r3, [r3, #16]
 8008042:	2b00      	cmp	r3, #0
 8008044:	dafb      	bge.n	800803e <otg_core_reset+0x2e>
    ;
}
 8008046:	b005      	add	sp, #20
 8008048:	f85d fb04 	ldr.w	pc, [sp], #4
 800804c:	f3af 8000 	nop.w

08008050 <otg_disable_ep>:

static void otg_disable_ep(USBDriver *usbp) {
 8008050:	b084      	sub	sp, #16
 8008052:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8008054:	9b01      	ldr	r3, [sp, #4]
 8008056:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008058:	9302      	str	r3, [sp, #8]
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800805a:	2300      	movs	r3, #0
 800805c:	9303      	str	r3, [sp, #12]
 800805e:	e032      	b.n	80080c6 <otg_disable_ep+0x76>
    otgp->ie[i].DIEPCTL = 0;
 8008060:	9a02      	ldr	r2, [sp, #8]
 8008062:	9b03      	ldr	r3, [sp, #12]
 8008064:	3348      	adds	r3, #72	; 0x48
 8008066:	015b      	lsls	r3, r3, #5
 8008068:	4413      	add	r3, r2
 800806a:	2200      	movs	r2, #0
 800806c:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPTSIZ = 0;
 800806e:	9a02      	ldr	r2, [sp, #8]
 8008070:	9b03      	ldr	r3, [sp, #12]
 8008072:	015b      	lsls	r3, r3, #5
 8008074:	4413      	add	r3, r2
 8008076:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 800807a:	2200      	movs	r2, #0
 800807c:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800807e:	9a02      	ldr	r2, [sp, #8]
 8008080:	9b03      	ldr	r3, [sp, #12]
 8008082:	015b      	lsls	r3, r3, #5
 8008084:	4413      	add	r3, r2
 8008086:	f603 1308 	addw	r3, r3, #2312	; 0x908
 800808a:	f04f 32ff 	mov.w	r2, #4294967295
 800808e:	601a      	str	r2, [r3, #0]

    otgp->oe[i].DOEPCTL = 0;
 8008090:	9a02      	ldr	r2, [sp, #8]
 8008092:	9b03      	ldr	r3, [sp, #12]
 8008094:	3358      	adds	r3, #88	; 0x58
 8008096:	015b      	lsls	r3, r3, #5
 8008098:	4413      	add	r3, r2
 800809a:	2200      	movs	r2, #0
 800809c:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPTSIZ = 0;
 800809e:	9a02      	ldr	r2, [sp, #8]
 80080a0:	9b03      	ldr	r3, [sp, #12]
 80080a2:	015b      	lsls	r3, r3, #5
 80080a4:	4413      	add	r3, r2
 80080a6:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 80080aa:	2200      	movs	r2, #0
 80080ac:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 80080ae:	9a02      	ldr	r2, [sp, #8]
 80080b0:	9b03      	ldr	r3, [sp, #12]
 80080b2:	015b      	lsls	r3, r3, #5
 80080b4:	4413      	add	r3, r2
 80080b6:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 80080ba:	f04f 32ff 	mov.w	r2, #4294967295
 80080be:	601a      	str	r2, [r3, #0]

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80080c0:	9b03      	ldr	r3, [sp, #12]
 80080c2:	3301      	adds	r3, #1
 80080c4:	9303      	str	r3, [sp, #12]
 80080c6:	9b01      	ldr	r3, [sp, #4]
 80080c8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80080ca:	689a      	ldr	r2, [r3, #8]
 80080cc:	9b03      	ldr	r3, [sp, #12]
 80080ce:	429a      	cmp	r2, r3
 80080d0:	d2c6      	bcs.n	8008060 <otg_disable_ep+0x10>

    otgp->oe[i].DOEPCTL = 0;
    otgp->oe[i].DOEPTSIZ = 0;
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  }
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 80080d2:	9b02      	ldr	r3, [sp, #8]
 80080d4:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 80080d8:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
}
 80080dc:	b004      	add	sp, #16
 80080de:	4770      	bx	lr

080080e0 <otg_rxfifo_flush>:

static void otg_rxfifo_flush(USBDriver *usbp) {
 80080e0:	b500      	push	{lr}
 80080e2:	b085      	sub	sp, #20
 80080e4:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 80080e6:	9b01      	ldr	r3, [sp, #4]
 80080e8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80080ea:	9303      	str	r3, [sp, #12]

  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 80080ec:	9b03      	ldr	r3, [sp, #12]
 80080ee:	2210      	movs	r2, #16
 80080f0:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 80080f2:	bf00      	nop
 80080f4:	9b03      	ldr	r3, [sp, #12]
 80080f6:	691b      	ldr	r3, [r3, #16]
 80080f8:	f003 0310 	and.w	r3, r3, #16
 80080fc:	2b00      	cmp	r3, #0
 80080fe:	d1f9      	bne.n	80080f4 <otg_rxfifo_flush+0x14>
    ;
  /* Wait for 3 PHY Clocks.*/
  osalSysPolledDelayX(18);
 8008100:	2012      	movs	r0, #18
 8008102:	f7ff ff55 	bl	8007fb0 <osalSysPolledDelayX>
}
 8008106:	b005      	add	sp, #20
 8008108:	f85d fb04 	ldr.w	pc, [sp], #4
 800810c:	f3af 8000 	nop.w

08008110 <otg_txfifo_flush>:

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
 8008110:	b500      	push	{lr}
 8008112:	b085      	sub	sp, #20
 8008114:	9001      	str	r0, [sp, #4]
 8008116:	9100      	str	r1, [sp, #0]
  stm32_otg_t *otgp = usbp->otg;
 8008118:	9b01      	ldr	r3, [sp, #4]
 800811a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800811c:	9303      	str	r3, [sp, #12]

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800811e:	9b00      	ldr	r3, [sp, #0]
 8008120:	019b      	lsls	r3, r3, #6
 8008122:	f043 0220 	orr.w	r2, r3, #32
 8008126:	9b03      	ldr	r3, [sp, #12]
 8008128:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 800812a:	bf00      	nop
 800812c:	9b03      	ldr	r3, [sp, #12]
 800812e:	691b      	ldr	r3, [r3, #16]
 8008130:	f003 0320 	and.w	r3, r3, #32
 8008134:	2b00      	cmp	r3, #0
 8008136:	d1f9      	bne.n	800812c <otg_txfifo_flush+0x1c>
    ;
  /* Wait for 3 PHY Clocks.*/
  osalSysPolledDelayX(18);
 8008138:	2012      	movs	r0, #18
 800813a:	f7ff ff39 	bl	8007fb0 <osalSysPolledDelayX>
}
 800813e:	b005      	add	sp, #20
 8008140:	f85d fb04 	ldr.w	pc, [sp], #4
 8008144:	f3af 8000 	nop.w
 8008148:	f3af 8000 	nop.w
 800814c:	f3af 8000 	nop.w

08008150 <otg_ram_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_ram_reset(USBDriver *usbp) {
 8008150:	b082      	sub	sp, #8
 8008152:	9001      	str	r0, [sp, #4]

  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8008154:	9b01      	ldr	r3, [sp, #4]
 8008156:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008158:	681a      	ldr	r2, [r3, #0]
 800815a:	9b01      	ldr	r3, [sp, #4]
 800815c:	675a      	str	r2, [r3, #116]	; 0x74
}
 800815e:	b002      	add	sp, #8
 8008160:	4770      	bx	lr
 8008162:	bf00      	nop
 8008164:	f3af 8000 	nop.w
 8008168:	f3af 8000 	nop.w
 800816c:	f3af 8000 	nop.w

08008170 <otg_ram_alloc>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] size      size of the packet buffer to allocate in words
 *
 * @notapi
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
 8008170:	b084      	sub	sp, #16
 8008172:	9001      	str	r0, [sp, #4]
 8008174:	9100      	str	r1, [sp, #0]
  uint32_t next;

  next = usbp->pmnext;
 8008176:	9b01      	ldr	r3, [sp, #4]
 8008178:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800817a:	9303      	str	r3, [sp, #12]
  usbp->pmnext += size;
 800817c:	9b01      	ldr	r3, [sp, #4]
 800817e:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8008180:	9b00      	ldr	r3, [sp, #0]
 8008182:	441a      	add	r2, r3
 8008184:	9b01      	ldr	r3, [sp, #4]
 8008186:	675a      	str	r2, [r3, #116]	; 0x74
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
                "OTG FIFO memory overflow");
  return next;
 8008188:	9b03      	ldr	r3, [sp, #12]
}
 800818a:	4618      	mov	r0, r3
 800818c:	b004      	add	sp, #16
 800818e:	4770      	bx	lr

08008190 <otg_fifo_write_from_buffer>:
 *
 * @notapi
 */
static void otg_fifo_write_from_buffer(volatile uint32_t *fifop,
                                       const uint8_t *buf,
                                       size_t n) {
 8008190:	b084      	sub	sp, #16
 8008192:	9003      	str	r0, [sp, #12]
 8008194:	9102      	str	r1, [sp, #8]
 8008196:	9201      	str	r2, [sp, #4]

  osalDbgAssert(n > 0, "is zero");

  while (true) {
    *fifop = *((uint32_t *)buf);
 8008198:	9b02      	ldr	r3, [sp, #8]
 800819a:	681a      	ldr	r2, [r3, #0]
 800819c:	9b03      	ldr	r3, [sp, #12]
 800819e:	601a      	str	r2, [r3, #0]
    if (n <= 4) {
 80081a0:	9b01      	ldr	r3, [sp, #4]
 80081a2:	2b04      	cmp	r3, #4
 80081a4:	d800      	bhi.n	80081a8 <otg_fifo_write_from_buffer+0x18>
      break;
 80081a6:	e006      	b.n	80081b6 <otg_fifo_write_from_buffer+0x26>
    }
    n -= 4;
 80081a8:	9b01      	ldr	r3, [sp, #4]
 80081aa:	3b04      	subs	r3, #4
 80081ac:	9301      	str	r3, [sp, #4]
    buf += 4;
 80081ae:	9b02      	ldr	r3, [sp, #8]
 80081b0:	3304      	adds	r3, #4
 80081b2:	9302      	str	r3, [sp, #8]
  }
 80081b4:	e7f0      	b.n	8008198 <otg_fifo_write_from_buffer+0x8>
}
 80081b6:	b004      	add	sp, #16
 80081b8:	4770      	bx	lr
 80081ba:	bf00      	nop
 80081bc:	f3af 8000 	nop.w

080081c0 <otg_fifo_read_to_buffer>:
 * @notapi
 */
static void otg_fifo_read_to_buffer(volatile uint32_t *fifop,
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {
 80081c0:	b086      	sub	sp, #24
 80081c2:	9003      	str	r0, [sp, #12]
 80081c4:	9102      	str	r1, [sp, #8]
 80081c6:	9201      	str	r2, [sp, #4]
 80081c8:	9300      	str	r3, [sp, #0]
  uint32_t w = 0;
 80081ca:	2300      	movs	r3, #0
 80081cc:	9305      	str	r3, [sp, #20]
  size_t i = 0;
 80081ce:	2300      	movs	r3, #0
 80081d0:	9304      	str	r3, [sp, #16]

  while (i < n) {
 80081d2:	e017      	b.n	8008204 <otg_fifo_read_to_buffer+0x44>
    if ((i & 3) == 0){
 80081d4:	9b04      	ldr	r3, [sp, #16]
 80081d6:	f003 0303 	and.w	r3, r3, #3
 80081da:	2b00      	cmp	r3, #0
 80081dc:	d102      	bne.n	80081e4 <otg_fifo_read_to_buffer+0x24>
      w = *fifop;
 80081de:	9b03      	ldr	r3, [sp, #12]
 80081e0:	681b      	ldr	r3, [r3, #0]
 80081e2:	9305      	str	r3, [sp, #20]
    }
    if (i < max) {
 80081e4:	9a04      	ldr	r2, [sp, #16]
 80081e6:	9b00      	ldr	r3, [sp, #0]
 80081e8:	429a      	cmp	r2, r3
 80081ea:	d208      	bcs.n	80081fe <otg_fifo_read_to_buffer+0x3e>
      *buf++ = (uint8_t)w;
 80081ec:	9b02      	ldr	r3, [sp, #8]
 80081ee:	1c5a      	adds	r2, r3, #1
 80081f0:	9202      	str	r2, [sp, #8]
 80081f2:	9a05      	ldr	r2, [sp, #20]
 80081f4:	b2d2      	uxtb	r2, r2
 80081f6:	701a      	strb	r2, [r3, #0]
      w >>= 8;
 80081f8:	9b05      	ldr	r3, [sp, #20]
 80081fa:	0a1b      	lsrs	r3, r3, #8
 80081fc:	9305      	str	r3, [sp, #20]
    }
    i++;
 80081fe:	9b04      	ldr	r3, [sp, #16]
 8008200:	3301      	adds	r3, #1
 8008202:	9304      	str	r3, [sp, #16]
                                    size_t n,
                                    size_t max) {
  uint32_t w = 0;
  size_t i = 0;

  while (i < n) {
 8008204:	9a04      	ldr	r2, [sp, #16]
 8008206:	9b01      	ldr	r3, [sp, #4]
 8008208:	429a      	cmp	r2, r3
 800820a:	d3e3      	bcc.n	80081d4 <otg_fifo_read_to_buffer+0x14>
      *buf++ = (uint8_t)w;
      w >>= 8;
    }
    i++;
  }
}
 800820c:	b006      	add	sp, #24
 800820e:	4770      	bx	lr

08008210 <otg_rxfifo_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_rxfifo_handler(USBDriver *usbp) {
 8008210:	b510      	push	{r4, lr}
 8008212:	b086      	sub	sp, #24
 8008214:	9001      	str	r0, [sp, #4]
  uint32_t sts, cnt, ep;

  sts = usbp->otg->GRXSTSP;
 8008216:	9b01      	ldr	r3, [sp, #4]
 8008218:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800821a:	6a1b      	ldr	r3, [r3, #32]
 800821c:	9305      	str	r3, [sp, #20]
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 800821e:	9b05      	ldr	r3, [sp, #20]
 8008220:	f403 13f0 	and.w	r3, r3, #1966080	; 0x1e0000
 8008224:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 8008228:	d074      	beq.n	8008314 <otg_rxfifo_handler+0x104>
 800822a:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
 800822e:	d003      	beq.n	8008238 <otg_rxfifo_handler+0x28>
 8008230:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8008234:	d01c      	beq.n	8008270 <otg_rxfifo_handler+0x60>
 8008236:	e06e      	b.n	8008316 <otg_rxfifo_handler+0x106>
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_SETUP_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8008238:	9a05      	ldr	r2, [sp, #20]
 800823a:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 800823e:	4013      	ands	r3, r2
 8008240:	091b      	lsrs	r3, r3, #4
 8008242:	9304      	str	r3, [sp, #16]
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 8008244:	9b05      	ldr	r3, [sp, #20]
 8008246:	f003 030f 	and.w	r3, r3, #15
 800824a:	9303      	str	r3, [sp, #12]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 800824c:	9b01      	ldr	r3, [sp, #4]
 800824e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008250:	f503 5280 	add.w	r2, r3, #4096	; 0x1000
 8008254:	9901      	ldr	r1, [sp, #4]
 8008256:	9b03      	ldr	r3, [sp, #12]
 8008258:	3302      	adds	r3, #2
 800825a:	009b      	lsls	r3, r3, #2
 800825c:	440b      	add	r3, r1
 800825e:	685b      	ldr	r3, [r3, #4]
 8008260:	6a1b      	ldr	r3, [r3, #32]
 8008262:	4610      	mov	r0, r2
 8008264:	4619      	mov	r1, r3
 8008266:	9a04      	ldr	r2, [sp, #16]
 8008268:	2308      	movs	r3, #8
 800826a:	f7ff ffa9 	bl	80081c0 <otg_fifo_read_to_buffer>
                            cnt, 8);
    break;
 800826e:	e052      	b.n	8008316 <otg_rxfifo_handler+0x106>
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8008270:	9a05      	ldr	r2, [sp, #20]
 8008272:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 8008276:	4013      	ands	r3, r2
 8008278:	091b      	lsrs	r3, r3, #4
 800827a:	9304      	str	r3, [sp, #16]
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 800827c:	9b05      	ldr	r3, [sp, #20]
 800827e:	f003 030f 	and.w	r3, r3, #15
 8008282:	9303      	str	r3, [sp, #12]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 8008284:	9b01      	ldr	r3, [sp, #4]
 8008286:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008288:	f503 5180 	add.w	r1, r3, #4096	; 0x1000
                            usbp->epc[ep]->out_state->rxbuf,
 800828c:	9a01      	ldr	r2, [sp, #4]
 800828e:	9b03      	ldr	r3, [sp, #12]
 8008290:	3302      	adds	r3, #2
 8008292:	009b      	lsls	r3, r3, #2
 8008294:	4413      	add	r3, r2
 8008296:	685b      	ldr	r3, [r3, #4]
 8008298:	699b      	ldr	r3, [r3, #24]
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 800829a:	689a      	ldr	r2, [r3, #8]
                            usbp->epc[ep]->out_state->rxbuf,
                            cnt,
                            usbp->epc[ep]->out_state->rxsize -
 800829c:	9801      	ldr	r0, [sp, #4]
 800829e:	9b03      	ldr	r3, [sp, #12]
 80082a0:	3302      	adds	r3, #2
 80082a2:	009b      	lsls	r3, r3, #2
 80082a4:	4403      	add	r3, r0
 80082a6:	685b      	ldr	r3, [r3, #4]
 80082a8:	699b      	ldr	r3, [r3, #24]
 80082aa:	6818      	ldr	r0, [r3, #0]
                            usbp->epc[ep]->out_state->rxcnt);
 80082ac:	9c01      	ldr	r4, [sp, #4]
 80082ae:	9b03      	ldr	r3, [sp, #12]
 80082b0:	3302      	adds	r3, #2
 80082b2:	009b      	lsls	r3, r3, #2
 80082b4:	4423      	add	r3, r4
 80082b6:	685b      	ldr	r3, [r3, #4]
 80082b8:	699b      	ldr	r3, [r3, #24]
 80082ba:	685b      	ldr	r3, [r3, #4]
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 80082bc:	1ac3      	subs	r3, r0, r3
 80082be:	4608      	mov	r0, r1
 80082c0:	4611      	mov	r1, r2
 80082c2:	9a04      	ldr	r2, [sp, #16]
 80082c4:	f7ff ff7c 	bl	80081c0 <otg_fifo_read_to_buffer>
                            usbp->epc[ep]->out_state->rxbuf,
                            cnt,
                            usbp->epc[ep]->out_state->rxsize -
                            usbp->epc[ep]->out_state->rxcnt);
    usbp->epc[ep]->out_state->rxbuf += cnt;
 80082c8:	9a01      	ldr	r2, [sp, #4]
 80082ca:	9b03      	ldr	r3, [sp, #12]
 80082cc:	3302      	adds	r3, #2
 80082ce:	009b      	lsls	r3, r3, #2
 80082d0:	4413      	add	r3, r2
 80082d2:	685b      	ldr	r3, [r3, #4]
 80082d4:	699a      	ldr	r2, [r3, #24]
 80082d6:	9901      	ldr	r1, [sp, #4]
 80082d8:	9b03      	ldr	r3, [sp, #12]
 80082da:	3302      	adds	r3, #2
 80082dc:	009b      	lsls	r3, r3, #2
 80082de:	440b      	add	r3, r1
 80082e0:	685b      	ldr	r3, [r3, #4]
 80082e2:	699b      	ldr	r3, [r3, #24]
 80082e4:	6899      	ldr	r1, [r3, #8]
 80082e6:	9b04      	ldr	r3, [sp, #16]
 80082e8:	440b      	add	r3, r1
 80082ea:	6093      	str	r3, [r2, #8]
    usbp->epc[ep]->out_state->rxcnt += cnt;
 80082ec:	9a01      	ldr	r2, [sp, #4]
 80082ee:	9b03      	ldr	r3, [sp, #12]
 80082f0:	3302      	adds	r3, #2
 80082f2:	009b      	lsls	r3, r3, #2
 80082f4:	4413      	add	r3, r2
 80082f6:	685b      	ldr	r3, [r3, #4]
 80082f8:	699a      	ldr	r2, [r3, #24]
 80082fa:	9901      	ldr	r1, [sp, #4]
 80082fc:	9b03      	ldr	r3, [sp, #12]
 80082fe:	3302      	adds	r3, #2
 8008300:	009b      	lsls	r3, r3, #2
 8008302:	440b      	add	r3, r1
 8008304:	685b      	ldr	r3, [r3, #4]
 8008306:	699b      	ldr	r3, [r3, #24]
 8008308:	6859      	ldr	r1, [r3, #4]
 800830a:	9b04      	ldr	r3, [sp, #16]
 800830c:	440b      	add	r3, r1
 800830e:	6053      	str	r3, [r2, #4]
    break;
 8008310:	bf00      	nop
 8008312:	e000      	b.n	8008316 <otg_rxfifo_handler+0x106>
  uint32_t sts, cnt, ep;

  sts = usbp->otg->GRXSTSP;
  switch (sts & GRXSTSP_PKTSTS_MASK) {
  case GRXSTSP_SETUP_COMP:
    break;
 8008314:	bf00      	nop
  case GRXSTSP_OUT_GLOBAL_NAK:
  case GRXSTSP_OUT_COMP:
  default:
    ;
  }
}
 8008316:	b006      	add	sp, #24
 8008318:	bd10      	pop	{r4, pc}
 800831a:	bf00      	nop
 800831c:	f3af 8000 	nop.w

08008320 <otg_txfifo_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static bool otg_txfifo_handler(USBDriver *usbp, usbep_t ep) {
 8008320:	b500      	push	{lr}
 8008322:	b085      	sub	sp, #20
 8008324:	9001      	str	r0, [sp, #4]
 8008326:	460b      	mov	r3, r1
 8008328:	f88d 3003 	strb.w	r3, [sp, #3]
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (true) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 800832c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008330:	9a01      	ldr	r2, [sp, #4]
 8008332:	3302      	adds	r3, #2
 8008334:	009b      	lsls	r3, r3, #2
 8008336:	4413      	add	r3, r2
 8008338:	685b      	ldr	r3, [r3, #4]
 800833a:	695b      	ldr	r3, [r3, #20]
 800833c:	685a      	ldr	r2, [r3, #4]
 800833e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008342:	9901      	ldr	r1, [sp, #4]
 8008344:	3302      	adds	r3, #2
 8008346:	009b      	lsls	r3, r3, #2
 8008348:	440b      	add	r3, r1
 800834a:	685b      	ldr	r3, [r3, #4]
 800834c:	695b      	ldr	r3, [r3, #20]
 800834e:	681b      	ldr	r3, [r3, #0]
 8008350:	429a      	cmp	r2, r3
 8008352:	d301      	bcc.n	8008358 <otg_txfifo_handler+0x38>
      return true;
 8008354:	2301      	movs	r3, #1
 8008356:	e076      	b.n	8008446 <otg_txfifo_handler+0x126>

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 8008358:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800835c:	9a01      	ldr	r2, [sp, #4]
 800835e:	3302      	adds	r3, #2
 8008360:	009b      	lsls	r3, r3, #2
 8008362:	4413      	add	r3, r2
 8008364:	685b      	ldr	r3, [r3, #4]
 8008366:	695b      	ldr	r3, [r3, #20]
 8008368:	681a      	ldr	r2, [r3, #0]
 800836a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800836e:	9901      	ldr	r1, [sp, #4]
 8008370:	3302      	adds	r3, #2
 8008372:	009b      	lsls	r3, r3, #2
 8008374:	440b      	add	r3, r1
 8008376:	685b      	ldr	r3, [r3, #4]
 8008378:	695b      	ldr	r3, [r3, #20]
 800837a:	685b      	ldr	r3, [r3, #4]
 800837c:	1ad3      	subs	r3, r2, r3
 800837e:	9303      	str	r3, [sp, #12]
    if (n > usbp->epc[ep]->in_maxsize)
 8008380:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008384:	9a01      	ldr	r2, [sp, #4]
 8008386:	3302      	adds	r3, #2
 8008388:	009b      	lsls	r3, r3, #2
 800838a:	4413      	add	r3, r2
 800838c:	685b      	ldr	r3, [r3, #4]
 800838e:	8a1b      	ldrh	r3, [r3, #16]
 8008390:	461a      	mov	r2, r3
 8008392:	9b03      	ldr	r3, [sp, #12]
 8008394:	429a      	cmp	r2, r3
 8008396:	d208      	bcs.n	80083aa <otg_txfifo_handler+0x8a>
      n = usbp->epc[ep]->in_maxsize;
 8008398:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800839c:	9a01      	ldr	r2, [sp, #4]
 800839e:	3302      	adds	r3, #2
 80083a0:	009b      	lsls	r3, r3, #2
 80083a2:	4413      	add	r3, r2
 80083a4:	685b      	ldr	r3, [r3, #4]
 80083a6:	8a1b      	ldrh	r3, [r3, #16]
 80083a8:	9303      	str	r3, [sp, #12]

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 80083aa:	9b01      	ldr	r3, [sp, #4]
 80083ac:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 80083ae:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80083b2:	015b      	lsls	r3, r3, #5
 80083b4:	4413      	add	r3, r2
 80083b6:	f603 1318 	addw	r3, r3, #2328	; 0x918
 80083ba:	681b      	ldr	r3, [r3, #0]
 80083bc:	b29b      	uxth	r3, r3
 80083be:	009a      	lsls	r2, r3, #2
 80083c0:	9b03      	ldr	r3, [sp, #12]
 80083c2:	429a      	cmp	r2, r3
 80083c4:	d201      	bcs.n	80083ca <otg_txfifo_handler+0xaa>
      return false;
 80083c6:	2300      	movs	r3, #0
 80083c8:	e03d      	b.n	8008446 <otg_txfifo_handler+0x126>

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 80083ca:	9b01      	ldr	r3, [sp, #4]
 80083cc:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 80083ce:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80083d2:	3301      	adds	r3, #1
 80083d4:	031b      	lsls	r3, r3, #12
 80083d6:	441a      	add	r2, r3
                               usbp->epc[ep]->in_state->txbuf,
 80083d8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80083dc:	9901      	ldr	r1, [sp, #4]
 80083de:	3302      	adds	r3, #2
 80083e0:	009b      	lsls	r3, r3, #2
 80083e2:	440b      	add	r3, r1
 80083e4:	685b      	ldr	r3, [r3, #4]
 80083e6:	695b      	ldr	r3, [r3, #20]
      return false;

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 80083e8:	689b      	ldr	r3, [r3, #8]
 80083ea:	4610      	mov	r0, r2
 80083ec:	4619      	mov	r1, r3
 80083ee:	9a03      	ldr	r2, [sp, #12]
 80083f0:	f7ff fece 	bl	8008190 <otg_fifo_write_from_buffer>
                               usbp->epc[ep]->in_state->txbuf,
                               n);
    usbp->epc[ep]->in_state->txbuf += n;
 80083f4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80083f8:	9a01      	ldr	r2, [sp, #4]
 80083fa:	3302      	adds	r3, #2
 80083fc:	009b      	lsls	r3, r3, #2
 80083fe:	4413      	add	r3, r2
 8008400:	685b      	ldr	r3, [r3, #4]
 8008402:	695a      	ldr	r2, [r3, #20]
 8008404:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008408:	9901      	ldr	r1, [sp, #4]
 800840a:	3302      	adds	r3, #2
 800840c:	009b      	lsls	r3, r3, #2
 800840e:	440b      	add	r3, r1
 8008410:	685b      	ldr	r3, [r3, #4]
 8008412:	695b      	ldr	r3, [r3, #20]
 8008414:	6899      	ldr	r1, [r3, #8]
 8008416:	9b03      	ldr	r3, [sp, #12]
 8008418:	440b      	add	r3, r1
 800841a:	6093      	str	r3, [r2, #8]
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
    usbp->epc[ep]->in_state->txcnt += n;
 800841c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008420:	9a01      	ldr	r2, [sp, #4]
 8008422:	3302      	adds	r3, #2
 8008424:	009b      	lsls	r3, r3, #2
 8008426:	4413      	add	r3, r2
 8008428:	685b      	ldr	r3, [r3, #4]
 800842a:	695a      	ldr	r2, [r3, #20]
 800842c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008430:	9901      	ldr	r1, [sp, #4]
 8008432:	3302      	adds	r3, #2
 8008434:	009b      	lsls	r3, r3, #2
 8008436:	440b      	add	r3, r1
 8008438:	685b      	ldr	r3, [r3, #4]
 800843a:	695b      	ldr	r3, [r3, #20]
 800843c:	6859      	ldr	r1, [r3, #4]
 800843e:	9b03      	ldr	r3, [sp, #12]
 8008440:	440b      	add	r3, r1
 8008442:	6053      	str	r3, [r2, #4]
  }
 8008444:	e772      	b.n	800832c <otg_txfifo_handler+0xc>
}
 8008446:	4618      	mov	r0, r3
 8008448:	b005      	add	sp, #20
 800844a:	f85d fb04 	ldr.w	pc, [sp], #4
 800844e:	bf00      	nop

08008450 <otg_epin_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8008450:	b500      	push	{lr}
 8008452:	b087      	sub	sp, #28
 8008454:	9001      	str	r0, [sp, #4]
 8008456:	460b      	mov	r3, r1
 8008458:	f88d 3003 	strb.w	r3, [sp, #3]
  stm32_otg_t *otgp = usbp->otg;
 800845c:	9b01      	ldr	r3, [sp, #4]
 800845e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008460:	9305      	str	r3, [sp, #20]
  uint32_t epint = otgp->ie[ep].DIEPINT;
 8008462:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008466:	9a05      	ldr	r2, [sp, #20]
 8008468:	015b      	lsls	r3, r3, #5
 800846a:	4413      	add	r3, r2
 800846c:	f603 1308 	addw	r3, r3, #2312	; 0x908
 8008470:	681b      	ldr	r3, [r3, #0]
 8008472:	9304      	str	r3, [sp, #16]

  otgp->ie[ep].DIEPINT = epint;
 8008474:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008478:	9a05      	ldr	r2, [sp, #20]
 800847a:	015b      	lsls	r3, r3, #5
 800847c:	4413      	add	r3, r2
 800847e:	f603 1308 	addw	r3, r3, #2312	; 0x908
 8008482:	9a04      	ldr	r2, [sp, #16]
 8008484:	601a      	str	r2, [r3, #0]

  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8008486:	9b04      	ldr	r3, [sp, #16]
 8008488:	f003 0301 	and.w	r3, r3, #1
 800848c:	2b00      	cmp	r3, #0
 800848e:	d051      	beq.n	8008534 <otg_epin_handler+0xe4>
 8008490:	9b05      	ldr	r3, [sp, #20]
 8008492:	f8d3 3810 	ldr.w	r3, [r3, #2064]	; 0x810
 8008496:	f003 0301 	and.w	r3, r3, #1
 800849a:	2b00      	cmp	r3, #0
 800849c:	d04a      	beq.n	8008534 <otg_epin_handler+0xe4>
    /* Transmit transfer complete.*/
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800849e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80084a2:	9a01      	ldr	r2, [sp, #4]
 80084a4:	3302      	adds	r3, #2
 80084a6:	009b      	lsls	r3, r3, #2
 80084a8:	4413      	add	r3, r2
 80084aa:	685b      	ldr	r3, [r3, #4]
 80084ac:	695b      	ldr	r3, [r3, #20]
 80084ae:	9303      	str	r3, [sp, #12]

    if (isp->txsize < isp->totsize) {
 80084b0:	9b03      	ldr	r3, [sp, #12]
 80084b2:	681a      	ldr	r2, [r3, #0]
 80084b4:	9b03      	ldr	r3, [sp, #12]
 80084b6:	68db      	ldr	r3, [r3, #12]
 80084b8:	429a      	cmp	r2, r3
 80084ba:	d214      	bcs.n	80084e6 <otg_epin_handler+0x96>
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      isp->txsize = isp->totsize - isp->txsize;
 80084bc:	9b03      	ldr	r3, [sp, #12]
 80084be:	68da      	ldr	r2, [r3, #12]
 80084c0:	9b03      	ldr	r3, [sp, #12]
 80084c2:	681b      	ldr	r3, [r3, #0]
 80084c4:	1ad2      	subs	r2, r2, r3
 80084c6:	9b03      	ldr	r3, [sp, #12]
 80084c8:	601a      	str	r2, [r3, #0]
      isp->txcnt  = 0;
 80084ca:	9b03      	ldr	r3, [sp, #12]
 80084cc:	2200      	movs	r2, #0
 80084ce:	605a      	str	r2, [r3, #4]
      osalSysLockFromISR();
 80084d0:	f7ff fd5e 	bl	8007f90 <osalSysLockFromISR>
      usb_lld_start_in(usbp, ep);
 80084d4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80084d8:	9801      	ldr	r0, [sp, #4]
 80084da:	4619      	mov	r1, r3
 80084dc:	f000 fec0 	bl	8009260 <usb_lld_start_in>
      osalSysUnlockFromISR();
 80084e0:	f7ff fd5e 	bl	8007fa0 <osalSysUnlockFromISR>
 80084e4:	e026      	b.n	8008534 <otg_epin_handler+0xe4>
    }
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
 80084e6:	9b01      	ldr	r3, [sp, #4]
 80084e8:	891b      	ldrh	r3, [r3, #8]
 80084ea:	b29a      	uxth	r2, r3
 80084ec:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80084f0:	2101      	movs	r1, #1
 80084f2:	fa01 f303 	lsl.w	r3, r1, r3
 80084f6:	b29b      	uxth	r3, r3
 80084f8:	43db      	mvns	r3, r3
 80084fa:	b29b      	uxth	r3, r3
 80084fc:	4013      	ands	r3, r2
 80084fe:	b29b      	uxth	r3, r3
 8008500:	b29a      	uxth	r2, r3
 8008502:	9b01      	ldr	r3, [sp, #4]
 8008504:	811a      	strh	r2, [r3, #8]
 8008506:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800850a:	9a01      	ldr	r2, [sp, #4]
 800850c:	3302      	adds	r3, #2
 800850e:	009b      	lsls	r3, r3, #2
 8008510:	4413      	add	r3, r2
 8008512:	685b      	ldr	r3, [r3, #4]
 8008514:	689b      	ldr	r3, [r3, #8]
 8008516:	2b00      	cmp	r3, #0
 8008518:	d00c      	beq.n	8008534 <otg_epin_handler+0xe4>
 800851a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800851e:	9a01      	ldr	r2, [sp, #4]
 8008520:	3302      	adds	r3, #2
 8008522:	009b      	lsls	r3, r3, #2
 8008524:	4413      	add	r3, r2
 8008526:	685b      	ldr	r3, [r3, #4]
 8008528:	689b      	ldr	r3, [r3, #8]
 800852a:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800852e:	9801      	ldr	r0, [sp, #4]
 8008530:	4611      	mov	r1, r2
 8008532:	4798      	blx	r3
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 8008534:	9b04      	ldr	r3, [sp, #16]
 8008536:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800853a:	2b00      	cmp	r3, #0
 800853c:	d02b      	beq.n	8008596 <otg_epin_handler+0x146>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 800853e:	9b05      	ldr	r3, [sp, #20]
 8008540:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 8008544:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008548:	2101      	movs	r1, #1
 800854a:	fa01 f303 	lsl.w	r3, r1, r3
 800854e:	4013      	ands	r3, r2
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 8008550:	2b00      	cmp	r3, #0
 8008552:	d020      	beq.n	8008596 <otg_epin_handler+0x146>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
 8008554:	f7ff fd1c 	bl	8007f90 <osalSysLockFromISR>
    usbp->txpending |= (1 << ep);
 8008558:	9b01      	ldr	r3, [sp, #4]
 800855a:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800855c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008560:	2101      	movs	r1, #1
 8008562:	fa01 f303 	lsl.w	r3, r1, r3
 8008566:	431a      	orrs	r2, r3
 8008568:	9b01      	ldr	r3, [sp, #4]
 800856a:	679a      	str	r2, [r3, #120]	; 0x78
    otgp->DIEPEMPMSK &= ~(1 << ep);
 800856c:	9b05      	ldr	r3, [sp, #20]
 800856e:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 8008572:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008576:	2101      	movs	r1, #1
 8008578:	fa01 f303 	lsl.w	r3, r1, r3
 800857c:	43db      	mvns	r3, r3
 800857e:	401a      	ands	r2, r3
 8008580:	9b05      	ldr	r3, [sp, #20]
 8008582:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
    osalThreadResumeI(&usbp->wait, MSG_OK);
 8008586:	9b01      	ldr	r3, [sp, #4]
 8008588:	337c      	adds	r3, #124	; 0x7c
 800858a:	4618      	mov	r0, r3
 800858c:	2100      	movs	r1, #0
 800858e:	f7ff fd2f 	bl	8007ff0 <osalThreadResumeI>
    osalSysUnlockFromISR();
 8008592:	f7ff fd05 	bl	8007fa0 <osalSysUnlockFromISR>
  }
}
 8008596:	b007      	add	sp, #28
 8008598:	f85d fb04 	ldr.w	pc, [sp], #4
 800859c:	f3af 8000 	nop.w

080085a0 <otg_epout_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 80085a0:	b500      	push	{lr}
 80085a2:	b087      	sub	sp, #28
 80085a4:	9001      	str	r0, [sp, #4]
 80085a6:	460b      	mov	r3, r1
 80085a8:	f88d 3003 	strb.w	r3, [sp, #3]
  stm32_otg_t *otgp = usbp->otg;
 80085ac:	9b01      	ldr	r3, [sp, #4]
 80085ae:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80085b0:	9305      	str	r3, [sp, #20]
  uint32_t epint = otgp->oe[ep].DOEPINT;
 80085b2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80085b6:	9a05      	ldr	r2, [sp, #20]
 80085b8:	015b      	lsls	r3, r3, #5
 80085ba:	4413      	add	r3, r2
 80085bc:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 80085c0:	681b      	ldr	r3, [r3, #0]
 80085c2:	9304      	str	r3, [sp, #16]

  /* Resets all EP IRQ sources.*/
  otgp->oe[ep].DOEPINT = epint;
 80085c4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80085c8:	9a05      	ldr	r2, [sp, #20]
 80085ca:	015b      	lsls	r3, r3, #5
 80085cc:	4413      	add	r3, r2
 80085ce:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 80085d2:	9a04      	ldr	r2, [sp, #16]
 80085d4:	601a      	str	r2, [r3, #0]

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 80085d6:	9b04      	ldr	r3, [sp, #16]
 80085d8:	f003 0308 	and.w	r3, r3, #8
 80085dc:	2b00      	cmp	r3, #0
 80085de:	d013      	beq.n	8008608 <otg_epout_handler+0x68>
 80085e0:	9b05      	ldr	r3, [sp, #20]
 80085e2:	f8d3 3814 	ldr.w	r3, [r3, #2068]	; 0x814
 80085e6:	f003 0308 	and.w	r3, r3, #8
 80085ea:	2b00      	cmp	r3, #0
 80085ec:	d00c      	beq.n	8008608 <otg_epout_handler+0x68>
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);
 80085ee:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80085f2:	9a01      	ldr	r2, [sp, #4]
 80085f4:	3302      	adds	r3, #2
 80085f6:	009b      	lsls	r3, r3, #2
 80085f8:	4413      	add	r3, r2
 80085fa:	685b      	ldr	r3, [r3, #4]
 80085fc:	685b      	ldr	r3, [r3, #4]
 80085fe:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8008602:	9801      	ldr	r0, [sp, #4]
 8008604:	4611      	mov	r1, r2
 8008606:	4798      	blx	r3
  }
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 8008608:	9b04      	ldr	r3, [sp, #16]
 800860a:	f003 0301 	and.w	r3, r3, #1
 800860e:	2b00      	cmp	r3, #0
 8008610:	d06c      	beq.n	80086ec <otg_epout_handler+0x14c>
 8008612:	9b05      	ldr	r3, [sp, #20]
 8008614:	f8d3 3814 	ldr.w	r3, [r3, #2068]	; 0x814
 8008618:	f003 0301 	and.w	r3, r3, #1
 800861c:	2b00      	cmp	r3, #0
 800861e:	d065      	beq.n	80086ec <otg_epout_handler+0x14c>
    USBOutEndpointState *osp;

    /* Receive transfer complete, checking if it is a SETUP transfer on EP0,
       that it must be ignored, the STUPM handler will take care of it.*/
    if ((ep == 0) && (usbp->ep0state == USB_EP0_WAITING_SETUP))
 8008620:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008624:	2b00      	cmp	r3, #0
 8008626:	d105      	bne.n	8008634 <otg_epout_handler+0x94>
 8008628:	9b01      	ldr	r3, [sp, #4]
 800862a:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 800862e:	2b00      	cmp	r3, #0
 8008630:	d100      	bne.n	8008634 <otg_epout_handler+0x94>
      return;
 8008632:	e05b      	b.n	80086ec <otg_epout_handler+0x14c>

    /* OUT state structure pointer for this endpoint.*/
    osp = usbp->epc[ep]->out_state;
 8008634:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008638:	9a01      	ldr	r2, [sp, #4]
 800863a:	3302      	adds	r3, #2
 800863c:	009b      	lsls	r3, r3, #2
 800863e:	4413      	add	r3, r2
 8008640:	685b      	ldr	r3, [r3, #4]
 8008642:	699b      	ldr	r3, [r3, #24]
 8008644:	9303      	str	r3, [sp, #12]

    /* A short packet always terminates a transaction.*/
    if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 8008646:	9b03      	ldr	r3, [sp, #12]
 8008648:	685a      	ldr	r2, [r3, #4]
 800864a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800864e:	9901      	ldr	r1, [sp, #4]
 8008650:	3302      	adds	r3, #2
 8008652:	009b      	lsls	r3, r3, #2
 8008654:	440b      	add	r3, r1
 8008656:	685b      	ldr	r3, [r3, #4]
 8008658:	8a5b      	ldrh	r3, [r3, #18]
 800865a:	fbb2 f1f3 	udiv	r1, r2, r3
 800865e:	fb03 f301 	mul.w	r3, r3, r1
 8008662:	1ad3      	subs	r3, r2, r3
 8008664:	2b00      	cmp	r3, #0
 8008666:	d11a      	bne.n	800869e <otg_epout_handler+0xfe>
        (osp->rxsize < osp->totsize)) {
 8008668:	9b03      	ldr	r3, [sp, #12]
 800866a:	681a      	ldr	r2, [r3, #0]
 800866c:	9b03      	ldr	r3, [sp, #12]
 800866e:	68db      	ldr	r3, [r3, #12]

    /* OUT state structure pointer for this endpoint.*/
    osp = usbp->epc[ep]->out_state;

    /* A short packet always terminates a transaction.*/
    if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 8008670:	429a      	cmp	r2, r3
 8008672:	d214      	bcs.n	800869e <otg_epout_handler+0xfe>
        (osp->rxsize < osp->totsize)) {
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      osp->rxsize = osp->totsize - osp->rxsize;
 8008674:	9b03      	ldr	r3, [sp, #12]
 8008676:	68da      	ldr	r2, [r3, #12]
 8008678:	9b03      	ldr	r3, [sp, #12]
 800867a:	681b      	ldr	r3, [r3, #0]
 800867c:	1ad2      	subs	r2, r2, r3
 800867e:	9b03      	ldr	r3, [sp, #12]
 8008680:	601a      	str	r2, [r3, #0]
      osp->rxcnt  = 0;
 8008682:	9b03      	ldr	r3, [sp, #12]
 8008684:	2200      	movs	r2, #0
 8008686:	605a      	str	r2, [r3, #4]
      osalSysLockFromISR();
 8008688:	f7ff fc82 	bl	8007f90 <osalSysLockFromISR>
      usb_lld_start_out(usbp, ep);
 800868c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008690:	9801      	ldr	r0, [sp, #4]
 8008692:	4619      	mov	r1, r3
 8008694:	f000 fd44 	bl	8009120 <usb_lld_start_out>
      osalSysUnlockFromISR();
 8008698:	f7ff fc82 	bl	8007fa0 <osalSysUnlockFromISR>
 800869c:	e026      	b.n	80086ec <otg_epout_handler+0x14c>
    }
    else {
      /* End on OUT transfer.*/
      _usb_isr_invoke_out_cb(usbp, ep);
 800869e:	9b01      	ldr	r3, [sp, #4]
 80086a0:	895b      	ldrh	r3, [r3, #10]
 80086a2:	b29a      	uxth	r2, r3
 80086a4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80086a8:	2101      	movs	r1, #1
 80086aa:	fa01 f303 	lsl.w	r3, r1, r3
 80086ae:	b29b      	uxth	r3, r3
 80086b0:	43db      	mvns	r3, r3
 80086b2:	b29b      	uxth	r3, r3
 80086b4:	4013      	ands	r3, r2
 80086b6:	b29b      	uxth	r3, r3
 80086b8:	b29a      	uxth	r2, r3
 80086ba:	9b01      	ldr	r3, [sp, #4]
 80086bc:	815a      	strh	r2, [r3, #10]
 80086be:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80086c2:	9a01      	ldr	r2, [sp, #4]
 80086c4:	3302      	adds	r3, #2
 80086c6:	009b      	lsls	r3, r3, #2
 80086c8:	4413      	add	r3, r2
 80086ca:	685b      	ldr	r3, [r3, #4]
 80086cc:	68db      	ldr	r3, [r3, #12]
 80086ce:	2b00      	cmp	r3, #0
 80086d0:	d00c      	beq.n	80086ec <otg_epout_handler+0x14c>
 80086d2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80086d6:	9a01      	ldr	r2, [sp, #4]
 80086d8:	3302      	adds	r3, #2
 80086da:	009b      	lsls	r3, r3, #2
 80086dc:	4413      	add	r3, r2
 80086de:	685b      	ldr	r3, [r3, #4]
 80086e0:	68db      	ldr	r3, [r3, #12]
 80086e2:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80086e6:	9801      	ldr	r0, [sp, #4]
 80086e8:	4611      	mov	r1, r2
 80086ea:	4798      	blx	r3
    }
  }
}
 80086ec:	b007      	add	sp, #28
 80086ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80086f2:	bf00      	nop
 80086f4:	f3af 8000 	nop.w
 80086f8:	f3af 8000 	nop.w
 80086fc:	f3af 8000 	nop.w

08008700 <otg_isoc_in_failed_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
 8008700:	b500      	push	{lr}
 8008702:	b085      	sub	sp, #20
 8008704:	9001      	str	r0, [sp, #4]
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 8008706:	9b01      	ldr	r3, [sp, #4]
 8008708:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800870a:	9302      	str	r3, [sp, #8]

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 800870c:	2300      	movs	r3, #0
 800870e:	f88d 300f 	strb.w	r3, [sp, #15]
 8008712:	e081      	b.n	8008818 <otg_isoc_in_failed_handler+0x118>
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8008714:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008718:	9a02      	ldr	r2, [sp, #8]
 800871a:	3348      	adds	r3, #72	; 0x48
 800871c:	015b      	lsls	r3, r3, #5
 800871e:	4413      	add	r3, r2
 8008720:	681b      	ldr	r3, [r3, #0]
 8008722:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8008726:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800872a:	d170      	bne.n	800880e <otg_isoc_in_failed_handler+0x10e>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
 800872c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008730:	9a02      	ldr	r2, [sp, #8]
 8008732:	3348      	adds	r3, #72	; 0x48
 8008734:	015b      	lsls	r3, r3, #5
 8008736:	4413      	add	r3, r2
 8008738:	681b      	ldr	r3, [r3, #0]
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 800873a:	2b00      	cmp	r3, #0
 800873c:	da67      	bge.n	800880e <otg_isoc_in_failed_handler+0x10e>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
      /* Endpoint enabled -> ISOC IN transfer failed */
      /* Disable endpoint */
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
 800873e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008742:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8008746:	9902      	ldr	r1, [sp, #8]
 8008748:	3248      	adds	r2, #72	; 0x48
 800874a:	0152      	lsls	r2, r2, #5
 800874c:	440a      	add	r2, r1
 800874e:	6812      	ldr	r2, [r2, #0]
 8008750:	f042 4290 	orr.w	r2, r2, #1207959552	; 0x48000000
 8008754:	9902      	ldr	r1, [sp, #8]
 8008756:	3348      	adds	r3, #72	; 0x48
 8008758:	015b      	lsls	r3, r3, #5
 800875a:	440b      	add	r3, r1
 800875c:	601a      	str	r2, [r3, #0]
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
 800875e:	bf00      	nop
 8008760:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008764:	9a02      	ldr	r2, [sp, #8]
 8008766:	3348      	adds	r3, #72	; 0x48
 8008768:	015b      	lsls	r3, r3, #5
 800876a:	4413      	add	r3, r2
 800876c:	681b      	ldr	r3, [r3, #0]
 800876e:	2b00      	cmp	r3, #0
 8008770:	dbf6      	blt.n	8008760 <otg_isoc_in_failed_handler+0x60>
        ;

      /* Flush FIFO */
      otg_txfifo_flush(usbp, ep);
 8008772:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008776:	9801      	ldr	r0, [sp, #4]
 8008778:	4619      	mov	r1, r3
 800877a:	f7ff fcc9 	bl	8008110 <otg_txfifo_flush>

      /* Prepare data for next frame */
      _usb_isr_invoke_in_cb(usbp, ep);
 800877e:	9b01      	ldr	r3, [sp, #4]
 8008780:	891b      	ldrh	r3, [r3, #8]
 8008782:	b29a      	uxth	r2, r3
 8008784:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008788:	2101      	movs	r1, #1
 800878a:	fa01 f303 	lsl.w	r3, r1, r3
 800878e:	b29b      	uxth	r3, r3
 8008790:	43db      	mvns	r3, r3
 8008792:	b29b      	uxth	r3, r3
 8008794:	4013      	ands	r3, r2
 8008796:	b29b      	uxth	r3, r3
 8008798:	b29a      	uxth	r2, r3
 800879a:	9b01      	ldr	r3, [sp, #4]
 800879c:	811a      	strh	r2, [r3, #8]
 800879e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80087a2:	9a01      	ldr	r2, [sp, #4]
 80087a4:	3302      	adds	r3, #2
 80087a6:	009b      	lsls	r3, r3, #2
 80087a8:	4413      	add	r3, r2
 80087aa:	685b      	ldr	r3, [r3, #4]
 80087ac:	689b      	ldr	r3, [r3, #8]
 80087ae:	2b00      	cmp	r3, #0
 80087b0:	d00c      	beq.n	80087cc <otg_isoc_in_failed_handler+0xcc>
 80087b2:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80087b6:	9a01      	ldr	r2, [sp, #4]
 80087b8:	3302      	adds	r3, #2
 80087ba:	009b      	lsls	r3, r3, #2
 80087bc:	4413      	add	r3, r2
 80087be:	685b      	ldr	r3, [r3, #4]
 80087c0:	689b      	ldr	r3, [r3, #8]
 80087c2:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80087c6:	9801      	ldr	r0, [sp, #4]
 80087c8:	4611      	mov	r1, r2
 80087ca:	4798      	blx	r3

      /* Pump out data for next frame */
      osalSysLockFromISR();
 80087cc:	f7ff fbe0 	bl	8007f90 <osalSysLockFromISR>
      otgp->DIEPEMPMSK &= ~(1 << ep);
 80087d0:	9b02      	ldr	r3, [sp, #8]
 80087d2:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 80087d6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80087da:	2101      	movs	r1, #1
 80087dc:	fa01 f303 	lsl.w	r3, r1, r3
 80087e0:	43db      	mvns	r3, r3
 80087e2:	401a      	ands	r2, r3
 80087e4:	9b02      	ldr	r3, [sp, #8]
 80087e6:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
      usbp->txpending |= (1 << ep);
 80087ea:	9b01      	ldr	r3, [sp, #4]
 80087ec:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 80087ee:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80087f2:	2101      	movs	r1, #1
 80087f4:	fa01 f303 	lsl.w	r3, r1, r3
 80087f8:	431a      	orrs	r2, r3
 80087fa:	9b01      	ldr	r3, [sp, #4]
 80087fc:	679a      	str	r2, [r3, #120]	; 0x78
      osalThreadResumeI(&usbp->wait, MSG_OK);
 80087fe:	9b01      	ldr	r3, [sp, #4]
 8008800:	337c      	adds	r3, #124	; 0x7c
 8008802:	4618      	mov	r0, r3
 8008804:	2100      	movs	r1, #0
 8008806:	f7ff fbf3 	bl	8007ff0 <osalThreadResumeI>
      osalSysUnlockFromISR();
 800880a:	f7ff fbc9 	bl	8007fa0 <osalSysUnlockFromISR>
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 800880e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008812:	3301      	adds	r3, #1
 8008814:	f88d 300f 	strb.w	r3, [sp, #15]
 8008818:	f89d 200f 	ldrb.w	r2, [sp, #15]
 800881c:	9b01      	ldr	r3, [sp, #4]
 800881e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008820:	689b      	ldr	r3, [r3, #8]
 8008822:	429a      	cmp	r2, r3
 8008824:	f67f af76 	bls.w	8008714 <otg_isoc_in_failed_handler+0x14>
      usbp->txpending |= (1 << ep);
      osalThreadResumeI(&usbp->wait, MSG_OK);
      osalSysUnlockFromISR();
    }
  }
}
 8008828:	b005      	add	sp, #20
 800882a:	f85d fb04 	ldr.w	pc, [sp], #4
 800882e:	bf00      	nop

08008830 <otg_isoc_out_failed_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
 8008830:	b500      	push	{lr}
 8008832:	b085      	sub	sp, #20
 8008834:	9001      	str	r0, [sp, #4]
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 8008836:	9b01      	ldr	r3, [sp, #4]
 8008838:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800883a:	9302      	str	r3, [sp, #8]

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 800883c:	2300      	movs	r3, #0
 800883e:	f88d 300f 	strb.w	r3, [sp, #15]
 8008842:	e040      	b.n	80088c6 <otg_isoc_out_failed_handler+0x96>
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8008844:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008848:	9a02      	ldr	r2, [sp, #8]
 800884a:	3358      	adds	r3, #88	; 0x58
 800884c:	015b      	lsls	r3, r3, #5
 800884e:	4413      	add	r3, r2
 8008850:	681b      	ldr	r3, [r3, #0]
 8008852:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8008856:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800885a:	d12f      	bne.n	80088bc <otg_isoc_out_failed_handler+0x8c>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
 800885c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008860:	9a02      	ldr	r2, [sp, #8]
 8008862:	3358      	adds	r3, #88	; 0x58
 8008864:	015b      	lsls	r3, r3, #5
 8008866:	4413      	add	r3, r2
 8008868:	681b      	ldr	r3, [r3, #0]
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 800886a:	2b00      	cmp	r3, #0
 800886c:	da26      	bge.n	80088bc <otg_isoc_out_failed_handler+0x8c>
      /* FIXME: Core stucks here */
      /*otgp->oe[ep].DOEPCTL |= (DOEPCTL_EPDIS | DOEPCTL_SNAK);
      while (otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA)
        ;*/
      /* Prepare transfer for next frame */
      _usb_isr_invoke_out_cb(usbp, ep);
 800886e:	9b01      	ldr	r3, [sp, #4]
 8008870:	895b      	ldrh	r3, [r3, #10]
 8008872:	b29a      	uxth	r2, r3
 8008874:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008878:	2101      	movs	r1, #1
 800887a:	fa01 f303 	lsl.w	r3, r1, r3
 800887e:	b29b      	uxth	r3, r3
 8008880:	43db      	mvns	r3, r3
 8008882:	b29b      	uxth	r3, r3
 8008884:	4013      	ands	r3, r2
 8008886:	b29b      	uxth	r3, r3
 8008888:	b29a      	uxth	r2, r3
 800888a:	9b01      	ldr	r3, [sp, #4]
 800888c:	815a      	strh	r2, [r3, #10]
 800888e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008892:	9a01      	ldr	r2, [sp, #4]
 8008894:	3302      	adds	r3, #2
 8008896:	009b      	lsls	r3, r3, #2
 8008898:	4413      	add	r3, r2
 800889a:	685b      	ldr	r3, [r3, #4]
 800889c:	68db      	ldr	r3, [r3, #12]
 800889e:	2b00      	cmp	r3, #0
 80088a0:	d00c      	beq.n	80088bc <otg_isoc_out_failed_handler+0x8c>
 80088a2:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80088a6:	9a01      	ldr	r2, [sp, #4]
 80088a8:	3302      	adds	r3, #2
 80088aa:	009b      	lsls	r3, r3, #2
 80088ac:	4413      	add	r3, r2
 80088ae:	685b      	ldr	r3, [r3, #4]
 80088b0:	68db      	ldr	r3, [r3, #12]
 80088b2:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80088b6:	9801      	ldr	r0, [sp, #4]
 80088b8:	4611      	mov	r1, r2
 80088ba:	4798      	blx	r3
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80088bc:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80088c0:	3301      	adds	r3, #1
 80088c2:	f88d 300f 	strb.w	r3, [sp, #15]
 80088c6:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80088ca:	9b01      	ldr	r3, [sp, #4]
 80088cc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80088ce:	689b      	ldr	r3, [r3, #8]
 80088d0:	429a      	cmp	r2, r3
 80088d2:	d9b7      	bls.n	8008844 <otg_isoc_out_failed_handler+0x14>
        ;*/
      /* Prepare transfer for next frame */
      _usb_isr_invoke_out_cb(usbp, ep);
    }
  }
}
 80088d4:	b005      	add	sp, #20
 80088d6:	f85d fb04 	ldr.w	pc, [sp], #4
 80088da:	bf00      	nop
 80088dc:	f3af 8000 	nop.w

080088e0 <usb_lld_serve_interrupt>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void usb_lld_serve_interrupt(USBDriver *usbp) {
 80088e0:	b500      	push	{lr}
 80088e2:	b087      	sub	sp, #28
 80088e4:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 80088e6:	9b01      	ldr	r3, [sp, #4]
 80088e8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80088ea:	9305      	str	r3, [sp, #20]
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
 80088ec:	9b05      	ldr	r3, [sp, #20]
 80088ee:	695b      	ldr	r3, [r3, #20]
 80088f0:	9304      	str	r3, [sp, #16]
  sts &= otgp->GINTMSK;
 80088f2:	9b05      	ldr	r3, [sp, #20]
 80088f4:	699b      	ldr	r3, [r3, #24]
 80088f6:	9a04      	ldr	r2, [sp, #16]
 80088f8:	4013      	ands	r3, r2
 80088fa:	9304      	str	r3, [sp, #16]
  otgp->GINTSTS = sts;
 80088fc:	9b05      	ldr	r3, [sp, #20]
 80088fe:	9a04      	ldr	r2, [sp, #16]
 8008900:	615a      	str	r2, [r3, #20]

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 8008902:	9b04      	ldr	r3, [sp, #16]
 8008904:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8008908:	2b00      	cmp	r3, #0
 800890a:	d006      	beq.n	800891a <usb_lld_serve_interrupt+0x3a>

    /* Resetting pending operations.*/
    usbp->txpending = 0;
 800890c:	9b01      	ldr	r3, [sp, #4]
 800890e:	2200      	movs	r2, #0
 8008910:	679a      	str	r2, [r3, #120]	; 0x78

    /* Default reset action.*/
    _usb_reset(usbp);
 8008912:	9801      	ldr	r0, [sp, #4]
 8008914:	f7fe f92c 	bl	8006b70 <_usb_reset>

    /* Preventing execution of more handlers, the core has been reset.*/
    return;
 8008918:	e0ce      	b.n	8008ab8 <usb_lld_serve_interrupt+0x1d8>
  }

  /* Wake-up handling.*/
  if (sts & GINTSTS_WKUPINT) {
 800891a:	9b04      	ldr	r3, [sp, #16]
 800891c:	2b00      	cmp	r3, #0
 800891e:	da19      	bge.n	8008954 <usb_lld_serve_interrupt+0x74>
    /* If clocks are gated off, turn them back on (may be the case if
       coming out of suspend mode).*/
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
 8008920:	9b05      	ldr	r3, [sp, #20]
 8008922:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
 8008926:	f003 0303 	and.w	r3, r3, #3
 800892a:	2b00      	cmp	r3, #0
 800892c:	d007      	beq.n	800893e <usb_lld_serve_interrupt+0x5e>
      /* Set to zero to un-gate the USB core clocks.*/
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 800892e:	9b05      	ldr	r3, [sp, #20]
 8008930:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
 8008934:	f023 0203 	bic.w	r2, r3, #3
 8008938:	9b05      	ldr	r3, [sp, #20]
 800893a:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00
    }

    /* Clear the Remote Wake-up Signaling.*/
    otgp->DCTL |= DCTL_RWUSIG;
 800893e:	9b05      	ldr	r3, [sp, #20]
 8008940:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
 8008944:	f043 0201 	orr.w	r2, r3, #1
 8008948:	9b05      	ldr	r3, [sp, #20]
 800894a:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804

    _usb_wakeup(usbp);
 800894e:	9801      	ldr	r0, [sp, #4]
 8008950:	f7fe f96e 	bl	8006c30 <_usb_wakeup>
  }

  /* Suspend handling.*/
  if (sts & GINTSTS_USBSUSP) {
 8008954:	9b04      	ldr	r3, [sp, #16]
 8008956:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800895a:	2b00      	cmp	r3, #0
 800895c:	d005      	beq.n	800896a <usb_lld_serve_interrupt+0x8a>

    /* Resetting pending operations.*/
    usbp->txpending = 0;
 800895e:	9b01      	ldr	r3, [sp, #4]
 8008960:	2200      	movs	r2, #0
 8008962:	679a      	str	r2, [r3, #120]	; 0x78

    /* Default suspend action.*/
    _usb_suspend(usbp);
 8008964:	9801      	ldr	r0, [sp, #4]
 8008966:	f7fe f943 	bl	8006bf0 <_usb_suspend>
  }

  /* Enumeration done.*/
  if (sts & GINTSTS_ENUMDNE) {
 800896a:	9b04      	ldr	r3, [sp, #16]
 800896c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8008970:	2b00      	cmp	r3, #0
 8008972:	d017      	beq.n	80089a4 <usb_lld_serve_interrupt+0xc4>
    /* Full or High speed timing selection.*/
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
 8008974:	9b05      	ldr	r3, [sp, #20]
 8008976:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 800897a:	f003 0306 	and.w	r3, r3, #6
 800897e:	2b00      	cmp	r3, #0
 8008980:	d108      	bne.n	8008994 <usb_lld_serve_interrupt+0xb4>
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8008982:	9b05      	ldr	r3, [sp, #20]
 8008984:	68db      	ldr	r3, [r3, #12]
 8008986:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 800898a:	f443 5210 	orr.w	r2, r3, #9216	; 0x2400
 800898e:	9b05      	ldr	r3, [sp, #20]
 8008990:	60da      	str	r2, [r3, #12]
 8008992:	e007      	b.n	80089a4 <usb_lld_serve_interrupt+0xc4>
                      GUSBCFG_TRDT(TRDT_VALUE_HS);
    }
    else {
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8008994:	9b05      	ldr	r3, [sp, #20]
 8008996:	68db      	ldr	r3, [r3, #12]
 8008998:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 800899c:	f443 52a0 	orr.w	r2, r3, #5120	; 0x1400
 80089a0:	9b05      	ldr	r3, [sp, #20]
 80089a2:	60da      	str	r2, [r3, #12]
                      GUSBCFG_TRDT(TRDT_VALUE_FS);
    }
  }

  /* SOF interrupt handling.*/
  if (sts & GINTSTS_SOF) {
 80089a4:	9b04      	ldr	r3, [sp, #16]
 80089a6:	f003 0308 	and.w	r3, r3, #8
 80089aa:	2b00      	cmp	r3, #0
 80089ac:	d009      	beq.n	80089c2 <usb_lld_serve_interrupt+0xe2>
    _usb_isr_invoke_sof_cb(usbp);
 80089ae:	9b01      	ldr	r3, [sp, #4]
 80089b0:	685b      	ldr	r3, [r3, #4]
 80089b2:	68db      	ldr	r3, [r3, #12]
 80089b4:	2b00      	cmp	r3, #0
 80089b6:	d004      	beq.n	80089c2 <usb_lld_serve_interrupt+0xe2>
 80089b8:	9b01      	ldr	r3, [sp, #4]
 80089ba:	685b      	ldr	r3, [r3, #4]
 80089bc:	68db      	ldr	r3, [r3, #12]
 80089be:	9801      	ldr	r0, [sp, #4]
 80089c0:	4798      	blx	r3
  }

  /* Isochronous IN failed handling */
  if (sts & GINTSTS_IISOIXFR) {
 80089c2:	9b04      	ldr	r3, [sp, #16]
 80089c4:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 80089c8:	2b00      	cmp	r3, #0
 80089ca:	d002      	beq.n	80089d2 <usb_lld_serve_interrupt+0xf2>
    otg_isoc_in_failed_handler(usbp);
 80089cc:	9801      	ldr	r0, [sp, #4]
 80089ce:	f7ff fe97 	bl	8008700 <otg_isoc_in_failed_handler>
  }

  /* Isochronous OUT failed handling */
  if (sts & GINTSTS_IISOOXFR) {
 80089d2:	9b04      	ldr	r3, [sp, #16]
 80089d4:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80089d8:	2b00      	cmp	r3, #0
 80089da:	d002      	beq.n	80089e2 <usb_lld_serve_interrupt+0x102>
    otg_isoc_out_failed_handler(usbp);
 80089dc:	9801      	ldr	r0, [sp, #4]
 80089de:	f7ff ff27 	bl	8008830 <otg_isoc_out_failed_handler>
  }

  /* RX FIFO not empty handling.*/
  if (sts & GINTSTS_RXFLVL) {
 80089e2:	9b04      	ldr	r3, [sp, #16]
 80089e4:	f003 0310 	and.w	r3, r3, #16
 80089e8:	2b00      	cmp	r3, #0
 80089ea:	d00f      	beq.n	8008a0c <usb_lld_serve_interrupt+0x12c>
    /* The interrupt is masked while the thread has control or it would
       be triggered again.*/
    osalSysLockFromISR();
 80089ec:	f7ff fad0 	bl	8007f90 <osalSysLockFromISR>
    otgp->GINTMSK &= ~GINTMSK_RXFLVLM;
 80089f0:	9b05      	ldr	r3, [sp, #20]
 80089f2:	699b      	ldr	r3, [r3, #24]
 80089f4:	f023 0210 	bic.w	r2, r3, #16
 80089f8:	9b05      	ldr	r3, [sp, #20]
 80089fa:	619a      	str	r2, [r3, #24]
    osalThreadResumeI(&usbp->wait, MSG_OK);
 80089fc:	9b01      	ldr	r3, [sp, #4]
 80089fe:	337c      	adds	r3, #124	; 0x7c
 8008a00:	4618      	mov	r0, r3
 8008a02:	2100      	movs	r1, #0
 8008a04:	f7ff faf4 	bl	8007ff0 <osalThreadResumeI>
    osalSysUnlockFromISR();
 8008a08:	f7ff faca 	bl	8007fa0 <osalSysUnlockFromISR>
  }

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
 8008a0c:	9b05      	ldr	r3, [sp, #20]
 8008a0e:	f8d3 3818 	ldr.w	r3, [r3, #2072]	; 0x818
 8008a12:	9303      	str	r3, [sp, #12]
  if (sts & GINTSTS_IEPINT) {
 8008a14:	9b04      	ldr	r3, [sp, #16]
 8008a16:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8008a1a:	2b00      	cmp	r3, #0
 8008a1c:	d023      	beq.n	8008a66 <usb_lld_serve_interrupt+0x186>
    if (src & (1 << 0))
 8008a1e:	9b03      	ldr	r3, [sp, #12]
 8008a20:	f003 0301 	and.w	r3, r3, #1
 8008a24:	2b00      	cmp	r3, #0
 8008a26:	d003      	beq.n	8008a30 <usb_lld_serve_interrupt+0x150>
      otg_epin_handler(usbp, 0);
 8008a28:	9801      	ldr	r0, [sp, #4]
 8008a2a:	2100      	movs	r1, #0
 8008a2c:	f7ff fd10 	bl	8008450 <otg_epin_handler>
    if (src & (1 << 1))
 8008a30:	9b03      	ldr	r3, [sp, #12]
 8008a32:	f003 0302 	and.w	r3, r3, #2
 8008a36:	2b00      	cmp	r3, #0
 8008a38:	d003      	beq.n	8008a42 <usb_lld_serve_interrupt+0x162>
      otg_epin_handler(usbp, 1);
 8008a3a:	9801      	ldr	r0, [sp, #4]
 8008a3c:	2101      	movs	r1, #1
 8008a3e:	f7ff fd07 	bl	8008450 <otg_epin_handler>
    if (src & (1 << 2))
 8008a42:	9b03      	ldr	r3, [sp, #12]
 8008a44:	f003 0304 	and.w	r3, r3, #4
 8008a48:	2b00      	cmp	r3, #0
 8008a4a:	d003      	beq.n	8008a54 <usb_lld_serve_interrupt+0x174>
      otg_epin_handler(usbp, 2);
 8008a4c:	9801      	ldr	r0, [sp, #4]
 8008a4e:	2102      	movs	r1, #2
 8008a50:	f7ff fcfe 	bl	8008450 <otg_epin_handler>
    if (src & (1 << 3))
 8008a54:	9b03      	ldr	r3, [sp, #12]
 8008a56:	f003 0308 	and.w	r3, r3, #8
 8008a5a:	2b00      	cmp	r3, #0
 8008a5c:	d003      	beq.n	8008a66 <usb_lld_serve_interrupt+0x186>
      otg_epin_handler(usbp, 3);
 8008a5e:	9801      	ldr	r0, [sp, #4]
 8008a60:	2103      	movs	r1, #3
 8008a62:	f7ff fcf5 	bl	8008450 <otg_epin_handler>
      otg_epin_handler(usbp, 4);
    if (src & (1 << 5))
      otg_epin_handler(usbp, 5);
#endif
  }
  if (sts & GINTSTS_OEPINT) {
 8008a66:	9b04      	ldr	r3, [sp, #16]
 8008a68:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8008a6c:	2b00      	cmp	r3, #0
 8008a6e:	d023      	beq.n	8008ab8 <usb_lld_serve_interrupt+0x1d8>
    if (src & (1 << 16))
 8008a70:	9b03      	ldr	r3, [sp, #12]
 8008a72:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8008a76:	2b00      	cmp	r3, #0
 8008a78:	d003      	beq.n	8008a82 <usb_lld_serve_interrupt+0x1a2>
      otg_epout_handler(usbp, 0);
 8008a7a:	9801      	ldr	r0, [sp, #4]
 8008a7c:	2100      	movs	r1, #0
 8008a7e:	f7ff fd8f 	bl	80085a0 <otg_epout_handler>
    if (src & (1 << 17))
 8008a82:	9b03      	ldr	r3, [sp, #12]
 8008a84:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8008a88:	2b00      	cmp	r3, #0
 8008a8a:	d003      	beq.n	8008a94 <usb_lld_serve_interrupt+0x1b4>
      otg_epout_handler(usbp, 1);
 8008a8c:	9801      	ldr	r0, [sp, #4]
 8008a8e:	2101      	movs	r1, #1
 8008a90:	f7ff fd86 	bl	80085a0 <otg_epout_handler>
    if (src & (1 << 18))
 8008a94:	9b03      	ldr	r3, [sp, #12]
 8008a96:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8008a9a:	2b00      	cmp	r3, #0
 8008a9c:	d003      	beq.n	8008aa6 <usb_lld_serve_interrupt+0x1c6>
      otg_epout_handler(usbp, 2);
 8008a9e:	9801      	ldr	r0, [sp, #4]
 8008aa0:	2102      	movs	r1, #2
 8008aa2:	f7ff fd7d 	bl	80085a0 <otg_epout_handler>
    if (src & (1 << 19))
 8008aa6:	9b03      	ldr	r3, [sp, #12]
 8008aa8:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8008aac:	2b00      	cmp	r3, #0
 8008aae:	d003      	beq.n	8008ab8 <usb_lld_serve_interrupt+0x1d8>
      otg_epout_handler(usbp, 3);
 8008ab0:	9801      	ldr	r0, [sp, #4]
 8008ab2:	2103      	movs	r1, #3
 8008ab4:	f7ff fd74 	bl	80085a0 <otg_epout_handler>
      otg_epout_handler(usbp, 4);
    if (src & (1 << 21))
      otg_epout_handler(usbp, 5);
#endif
  }
}
 8008ab8:	b007      	add	sp, #28
 8008aba:	f85d fb04 	ldr.w	pc, [sp], #4
 8008abe:	bf00      	nop

08008ac0 <Vector14C>:
/**
 * @brief   OTG1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 8008ac0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);
 8008ac2:	4803      	ldr	r0, [pc, #12]	; (8008ad0 <Vector14C+0x10>)
 8008ac4:	f7ff ff0c 	bl	80088e0 <usb_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8008ac8:	f7fb f842 	bl	8003b50 <_port_irq_epilogue>
}
 8008acc:	bd08      	pop	{r3, pc}
 8008ace:	bf00      	nop
 8008ad0:	20000f58 	.word	0x20000f58
 8008ad4:	f3af 8000 	nop.w
 8008ad8:	f3af 8000 	nop.w
 8008adc:	f3af 8000 	nop.w

08008ae0 <usb_lld_init>:
/**
 * @brief   Low level USB driver initialization.
 *
 * @notapi
 */
void usb_lld_init(void) {
 8008ae0:	b508      	push	{r3, lr}

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
 8008ae2:	4809      	ldr	r0, [pc, #36]	; (8008b08 <usb_lld_init+0x28>)
 8008ae4:	f7fd fed4 	bl	8006890 <usbObjectInit>
  USBD1.wait      = NULL;
 8008ae8:	4b07      	ldr	r3, [pc, #28]	; (8008b08 <usb_lld_init+0x28>)
 8008aea:	2200      	movs	r2, #0
 8008aec:	67da      	str	r2, [r3, #124]	; 0x7c
  USBD1.otg       = OTG_FS;
 8008aee:	4b06      	ldr	r3, [pc, #24]	; (8008b08 <usb_lld_init+0x28>)
 8008af0:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
 8008af4:	66da      	str	r2, [r3, #108]	; 0x6c
  USBD1.otgparams = &fsparams;
 8008af6:	4b04      	ldr	r3, [pc, #16]	; (8008b08 <usb_lld_init+0x28>)
 8008af8:	4a04      	ldr	r2, [pc, #16]	; (8008b0c <usb_lld_init+0x2c>)
 8008afa:	671a      	str	r2, [r3, #112]	; 0x70

#if defined(_CHIBIOS_RT_)
  USBD1.tr = NULL;
 8008afc:	4b02      	ldr	r3, [pc, #8]	; (8008b08 <usb_lld_init+0x28>)
 8008afe:	2200      	movs	r2, #0
 8008b00:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
                    CH_DBG_STACK_FILL_VALUE);
  }
#endif /* CH_DBG_FILL_THREADS */
#endif /* defined(_CHIBIOS_RT_) */
#endif
}
 8008b04:	bd08      	pop	{r3, pc}
 8008b06:	bf00      	nop
 8008b08:	20000f58 	.word	0x20000f58
 8008b0c:	080160d4 	.word	0x080160d4

08008b10 <usb_lld_start>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
 8008b10:	b500      	push	{lr}
 8008b12:	b087      	sub	sp, #28
 8008b14:	9003      	str	r0, [sp, #12]
  stm32_otg_t *otgp = usbp->otg;
 8008b16:	9b03      	ldr	r3, [sp, #12]
 8008b18:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008b1a:	9305      	str	r3, [sp, #20]

  if (usbp->state == USB_STOP) {
 8008b1c:	9b03      	ldr	r3, [sp, #12]
 8008b1e:	781b      	ldrb	r3, [r3, #0]
 8008b20:	2b01      	cmp	r3, #1
 8008b22:	d172      	bne.n	8008c0a <usb_lld_start+0xfa>
    /* Clock activation.*/

#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
 8008b24:	9a03      	ldr	r2, [sp, #12]
 8008b26:	4b3a      	ldr	r3, [pc, #232]	; (8008c10 <usb_lld_start+0x100>)
 8008b28:	429a      	cmp	r2, r3
 8008b2a:	d119      	bne.n	8008b60 <usb_lld_start+0x50>
      /* OTG FS clock enable and reset.*/
      rccEnableOTG_FS(false);
 8008b2c:	4b39      	ldr	r3, [pc, #228]	; (8008c14 <usb_lld_start+0x104>)
 8008b2e:	4a39      	ldr	r2, [pc, #228]	; (8008c14 <usb_lld_start+0x104>)
 8008b30:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 8008b32:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8008b36:	64da      	str	r2, [r3, #76]	; 0x4c
      rccResetOTG_FS();
 8008b38:	4b36      	ldr	r3, [pc, #216]	; (8008c14 <usb_lld_start+0x104>)
 8008b3a:	4a36      	ldr	r2, [pc, #216]	; (8008c14 <usb_lld_start+0x104>)
 8008b3c:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8008b3e:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8008b42:	62da      	str	r2, [r3, #44]	; 0x2c
 8008b44:	4b33      	ldr	r3, [pc, #204]	; (8008c14 <usb_lld_start+0x104>)
 8008b46:	2200      	movs	r2, #0
 8008b48:	62da      	str	r2, [r3, #44]	; 0x2c

      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG1_NUMBER, STM32_USB_OTG1_IRQ_PRIORITY);
 8008b4a:	2043      	movs	r0, #67	; 0x43
 8008b4c:	210e      	movs	r1, #14
 8008b4e:	f7fe fa17 	bl	8006f80 <nvicEnableVector>

      /* - Forced device mode.
         - USB turn-around time = TRDT_VALUE_FS.
         - Full Speed 1.1 PHY.*/
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 8008b52:	9b05      	ldr	r3, [sp, #20]
 8008b54:	4a30      	ldr	r2, [pc, #192]	; (8008c18 <usb_lld_start+0x108>)
 8008b56:	60da      	str	r2, [r3, #12]
                      GUSBCFG_PHYSEL;

      /* 48MHz 1.1 PHY.*/
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 8008b58:	9b05      	ldr	r3, [sp, #20]
 8008b5a:	4a30      	ldr	r2, [pc, #192]	; (8008c1c <usb_lld_start+0x10c>)
 8008b5c:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
#endif
    }
#endif

    /* Clearing mask of TXFIFOs to be filled.*/
    usbp->txpending = 0;
 8008b60:	9b03      	ldr	r3, [sp, #12]
 8008b62:	2200      	movs	r2, #0
 8008b64:	679a      	str	r2, [r3, #120]	; 0x78

    /* PHY enabled.*/
    otgp->PCGCCTL = 0;
 8008b66:	9b05      	ldr	r3, [sp, #20]
 8008b68:	2200      	movs	r2, #0
 8008b6a:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00

    /* VBUS sensing and transceiver enabled.*/
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 8008b6e:	9b05      	ldr	r3, [sp, #20]
 8008b70:	22c0      	movs	r2, #192	; 0xc0
 8008b72:	601a      	str	r2, [r3, #0]
    if (&USBD2 == usbp) {
      otgp->GCCFG = 0;
    }
#endif
#else
    otgp->GCCFG = GCCFG_INIT_VALUE;
 8008b74:	9b05      	ldr	r3, [sp, #20]
 8008b76:	f44f 1204 	mov.w	r2, #2162688	; 0x210000
 8008b7a:	639a      	str	r2, [r3, #56]	; 0x38
#endif

    /* Soft core reset.*/
    otg_core_reset(usbp);
 8008b7c:	9803      	ldr	r0, [sp, #12]
 8008b7e:	f7ff fa47 	bl	8008010 <otg_core_reset>

    /* Interrupts on TXFIFOs half empty.*/
    otgp->GAHBCFG = 0;
 8008b82:	9b05      	ldr	r3, [sp, #20]
 8008b84:	2200      	movs	r2, #0
 8008b86:	609a      	str	r2, [r3, #8]

    /* Endpoints re-initialization.*/
    otg_disable_ep(usbp);
 8008b88:	9803      	ldr	r0, [sp, #12]
 8008b8a:	f7ff fa61 	bl	8008050 <otg_disable_ep>

    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
 8008b8e:	9b05      	ldr	r3, [sp, #20]
 8008b90:	2200      	movs	r2, #0
 8008b92:	f8c3 2810 	str.w	r2, [r3, #2064]	; 0x810
    otgp->DOEPMSK  = 0;
 8008b96:	9b05      	ldr	r3, [sp, #20]
 8008b98:	2200      	movs	r2, #0
 8008b9a:	f8c3 2814 	str.w	r2, [r3, #2068]	; 0x814
    otgp->DAINTMSK = 0;
 8008b9e:	9b05      	ldr	r3, [sp, #20]
 8008ba0:	2200      	movs	r2, #0
 8008ba2:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
 8008ba6:	9b03      	ldr	r3, [sp, #12]
 8008ba8:	685b      	ldr	r3, [r3, #4]
 8008baa:	68db      	ldr	r3, [r3, #12]
 8008bac:	2b00      	cmp	r3, #0
 8008bae:	d103      	bne.n	8008bb8 <usb_lld_start+0xa8>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8008bb0:	9b05      	ldr	r3, [sp, #20]
 8008bb2:	4a1b      	ldr	r2, [pc, #108]	; (8008c20 <usb_lld_start+0x110>)
 8008bb4:	619a      	str	r2, [r3, #24]
 8008bb6:	e002      	b.n	8008bbe <usb_lld_start+0xae>
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM;
    else
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8008bb8:	9b05      	ldr	r3, [sp, #20]
 8008bba:	4a1a      	ldr	r2, [pc, #104]	; (8008c24 <usb_lld_start+0x114>)
 8008bbc:	619a      	str	r2, [r3, #24]
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM |
                       GINTMSK_SOFM;

    /* Clears all pending IRQs, if any. */
    otgp->GINTSTS  = 0xFFFFFFFF;
 8008bbe:	9b05      	ldr	r3, [sp, #20]
 8008bc0:	f04f 32ff 	mov.w	r2, #4294967295
 8008bc4:	615a      	str	r2, [r3, #20]

#if defined(_CHIBIOS_RT_)
    /* Creates the data pump thread. Note, it is created only once.*/
    if (usbp->tr == NULL) {
 8008bc6:	9b03      	ldr	r3, [sp, #12]
 8008bc8:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8008bcc:	2b00      	cmp	r3, #0
 8008bce:	d116      	bne.n	8008bfe <usb_lld_start+0xee>
      usbp->tr = chThdCreateI(usbp->wa_pump, sizeof usbp->wa_pump,
 8008bd0:	9b03      	ldr	r3, [sp, #12]
 8008bd2:	3388      	adds	r3, #136	; 0x88
 8008bd4:	9a03      	ldr	r2, [sp, #12]
 8008bd6:	9200      	str	r2, [sp, #0]
 8008bd8:	4618      	mov	r0, r3
 8008bda:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008bde:	2202      	movs	r2, #2
 8008be0:	4b11      	ldr	r3, [pc, #68]	; (8008c28 <usb_lld_start+0x118>)
 8008be2:	f7f8 fad5 	bl	8001190 <chThdCreateI>
 8008be6:	4602      	mov	r2, r0
 8008be8:	9b03      	ldr	r3, [sp, #12]
 8008bea:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
                              STM32_USB_OTG_THREAD_PRIO,
                              usb_lld_pump, usbp);
      chThdStartI(usbp->tr);
 8008bee:	9b03      	ldr	r3, [sp, #12]
 8008bf0:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8008bf4:	4618      	mov	r0, r3
 8008bf6:	f7ff f99b 	bl	8007f30 <chThdStartI>
      chSchRescheduleS();
 8008bfa:	f7f8 f8c1 	bl	8000d80 <chSchRescheduleS>
  }
#endif

    /* Global interrupts enable.*/
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 8008bfe:	9b05      	ldr	r3, [sp, #20]
 8008c00:	689b      	ldr	r3, [r3, #8]
 8008c02:	f043 0201 	orr.w	r2, r3, #1
 8008c06:	9b05      	ldr	r3, [sp, #20]
 8008c08:	609a      	str	r2, [r3, #8]
  }
}
 8008c0a:	b007      	add	sp, #28
 8008c0c:	f85d fb04 	ldr.w	pc, [sp], #4
 8008c10:	20000f58 	.word	0x20000f58
 8008c14:	40021000 	.word	0x40021000
 8008c18:	40001440 	.word	0x40001440
 8008c1c:	02200003 	.word	0x02200003
 8008c20:	c0303c00 	.word	0xc0303c00
 8008c24:	c0303c08 	.word	0xc0303c08
 8008c28:	080094c1 	.word	0x080094c1
 8008c2c:	f3af 8000 	nop.w

08008c30 <usb_lld_stop>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_stop(USBDriver *usbp) {
 8008c30:	b500      	push	{lr}
 8008c32:	b085      	sub	sp, #20
 8008c34:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8008c36:	9b01      	ldr	r3, [sp, #4]
 8008c38:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008c3a:	9303      	str	r3, [sp, #12]

  /* If in ready state then disables the USB clock.*/
  if (usbp->state != USB_STOP) {
 8008c3c:	9b01      	ldr	r3, [sp, #4]
 8008c3e:	781b      	ldrb	r3, [r3, #0]
 8008c40:	2b01      	cmp	r3, #1
 8008c42:	d01c      	beq.n	8008c7e <usb_lld_stop+0x4e>

    /* Disabling all endpoints in case the driver has been stopped while
       active.*/
    otg_disable_ep(usbp);
 8008c44:	9801      	ldr	r0, [sp, #4]
 8008c46:	f7ff fa03 	bl	8008050 <otg_disable_ep>

    usbp->txpending = 0;
 8008c4a:	9b01      	ldr	r3, [sp, #4]
 8008c4c:	2200      	movs	r2, #0
 8008c4e:	679a      	str	r2, [r3, #120]	; 0x78

    otgp->DAINTMSK   = 0;
 8008c50:	9b03      	ldr	r3, [sp, #12]
 8008c52:	2200      	movs	r2, #0
 8008c54:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
    otgp->GAHBCFG    = 0;
 8008c58:	9b03      	ldr	r3, [sp, #12]
 8008c5a:	2200      	movs	r2, #0
 8008c5c:	609a      	str	r2, [r3, #8]
    otgp->GCCFG      = 0;
 8008c5e:	9b03      	ldr	r3, [sp, #12]
 8008c60:	2200      	movs	r2, #0
 8008c62:	639a      	str	r2, [r3, #56]	; 0x38

#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
 8008c64:	9a01      	ldr	r2, [sp, #4]
 8008c66:	4b07      	ldr	r3, [pc, #28]	; (8008c84 <usb_lld_stop+0x54>)
 8008c68:	429a      	cmp	r2, r3
 8008c6a:	d108      	bne.n	8008c7e <usb_lld_stop+0x4e>
      nvicDisableVector(STM32_OTG1_NUMBER);
 8008c6c:	2043      	movs	r0, #67	; 0x43
 8008c6e:	f7fe f9af 	bl	8006fd0 <nvicDisableVector>
      rccDisableOTG_FS(false);
 8008c72:	4b05      	ldr	r3, [pc, #20]	; (8008c88 <usb_lld_stop+0x58>)
 8008c74:	4a04      	ldr	r2, [pc, #16]	; (8008c88 <usb_lld_stop+0x58>)
 8008c76:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 8008c78:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8008c7c:	64da      	str	r2, [r3, #76]	; 0x4c
      rccDisableOTG_HSULPI(true)
#endif
    }
#endif
  }
}
 8008c7e:	b005      	add	sp, #20
 8008c80:	f85d fb04 	ldr.w	pc, [sp], #4
 8008c84:	20000f58 	.word	0x20000f58
 8008c88:	40021000 	.word	0x40021000
 8008c8c:	f3af 8000 	nop.w

08008c90 <usb_lld_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_reset(USBDriver *usbp) {
 8008c90:	b510      	push	{r4, lr}
 8008c92:	b084      	sub	sp, #16
 8008c94:	9001      	str	r0, [sp, #4]
  unsigned i;
  stm32_otg_t *otgp = usbp->otg;
 8008c96:	9b01      	ldr	r3, [sp, #4]
 8008c98:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008c9a:	9302      	str	r3, [sp, #8]

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);
 8008c9c:	9801      	ldr	r0, [sp, #4]
 8008c9e:	2100      	movs	r1, #0
 8008ca0:	f7ff fa36 	bl	8008110 <otg_txfifo_flush>

  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
 8008ca4:	9b02      	ldr	r3, [sp, #8]
 8008ca6:	2200      	movs	r2, #0
 8008ca8:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8008cac:	9b02      	ldr	r3, [sp, #8]
 8008cae:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 8008cb2:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8008cb6:	2300      	movs	r3, #0
 8008cb8:	9303      	str	r3, [sp, #12]
 8008cba:	e024      	b.n	8008d06 <usb_lld_reset+0x76>
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8008cbc:	9a02      	ldr	r2, [sp, #8]
 8008cbe:	9b03      	ldr	r3, [sp, #12]
 8008cc0:	3348      	adds	r3, #72	; 0x48
 8008cc2:	015b      	lsls	r3, r3, #5
 8008cc4:	4413      	add	r3, r2
 8008cc6:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8008cca:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 8008ccc:	9a02      	ldr	r2, [sp, #8]
 8008cce:	9b03      	ldr	r3, [sp, #12]
 8008cd0:	3358      	adds	r3, #88	; 0x58
 8008cd2:	015b      	lsls	r3, r3, #5
 8008cd4:	4413      	add	r3, r2
 8008cd6:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8008cda:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8008cdc:	9a02      	ldr	r2, [sp, #8]
 8008cde:	9b03      	ldr	r3, [sp, #12]
 8008ce0:	015b      	lsls	r3, r3, #5
 8008ce2:	4413      	add	r3, r2
 8008ce4:	f603 1308 	addw	r3, r3, #2312	; 0x908
 8008ce8:	f04f 32ff 	mov.w	r2, #4294967295
 8008cec:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 8008cee:	9a02      	ldr	r2, [sp, #8]
 8008cf0:	9b03      	ldr	r3, [sp, #12]
 8008cf2:	015b      	lsls	r3, r3, #5
 8008cf4:	4413      	add	r3, r2
 8008cf6:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 8008cfa:	f04f 32ff 	mov.w	r2, #4294967295
 8008cfe:	601a      	str	r2, [r3, #0]
  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8008d00:	9b03      	ldr	r3, [sp, #12]
 8008d02:	3301      	adds	r3, #1
 8008d04:	9303      	str	r3, [sp, #12]
 8008d06:	9b01      	ldr	r3, [sp, #4]
 8008d08:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008d0a:	689a      	ldr	r2, [r3, #8]
 8008d0c:	9b03      	ldr	r3, [sp, #12]
 8008d0e:	429a      	cmp	r2, r3
 8008d10:	d2d4      	bcs.n	8008cbc <usb_lld_reset+0x2c>
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  }

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);
 8008d12:	9801      	ldr	r0, [sp, #4]
 8008d14:	f7ff fa1c 	bl	8008150 <otg_ram_reset>

  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 8008d18:	9b01      	ldr	r3, [sp, #4]
 8008d1a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008d1c:	681a      	ldr	r2, [r3, #0]
 8008d1e:	9b02      	ldr	r3, [sp, #8]
 8008d20:	625a      	str	r2, [r3, #36]	; 0x24
  otg_rxfifo_flush(usbp);
 8008d22:	9801      	ldr	r0, [sp, #4]
 8008d24:	f7ff f9dc 	bl	80080e0 <otg_rxfifo_flush>

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 8008d28:	9b02      	ldr	r3, [sp, #8]
 8008d2a:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
 8008d2e:	f423 62fe 	bic.w	r2, r3, #2032	; 0x7f0
 8008d32:	9b02      	ldr	r3, [sp, #8]
 8008d34:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8008d38:	9b02      	ldr	r3, [sp, #8]
 8008d3a:	699b      	ldr	r3, [r3, #24]
 8008d3c:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 8008d40:	f043 0310 	orr.w	r3, r3, #16
 8008d44:	9a02      	ldr	r2, [sp, #8]
 8008d46:	6193      	str	r3, [r2, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8008d48:	9b02      	ldr	r3, [sp, #8]
 8008d4a:	2209      	movs	r2, #9
 8008d4c:	f8c3 2810 	str.w	r2, [r3, #2064]	; 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 8008d50:	9b02      	ldr	r3, [sp, #8]
 8008d52:	2209      	movs	r2, #9
 8008d54:	f8c3 2814 	str.w	r2, [r3, #2068]	; 0x814

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 8008d58:	9b01      	ldr	r3, [sp, #4]
 8008d5a:	4a16      	ldr	r2, [pc, #88]	; (8008db4 <usb_lld_reset+0x124>)
 8008d5c:	60da      	str	r2, [r3, #12]
  otgp->oe[0].DOEPTSIZ = 0;
 8008d5e:	9b02      	ldr	r3, [sp, #8]
 8008d60:	2200      	movs	r2, #0
 8008d62:	f8c3 2b10 	str.w	r2, [r3, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
 8008d66:	2340      	movs	r3, #64	; 0x40
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
  otgp->oe[0].DOEPTSIZ = 0;
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 8008d68:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8008d6c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8008d70:	9a02      	ldr	r2, [sp, #8]
 8008d72:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
 8008d76:	9b02      	ldr	r3, [sp, #8]
 8008d78:	2200      	movs	r2, #0
 8008d7a:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
 8008d7e:	2340      	movs	r3, #64	; 0x40
 8008d80:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8008d84:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  usbp->epc[0] = &ep0config;
  otgp->oe[0].DOEPTSIZ = 0;
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 8008d88:	9a02      	ldr	r2, [sp, #8]
 8008d8a:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8008d8e:	2340      	movs	r3, #64	; 0x40
 8008d90:	089b      	lsrs	r3, r3, #2
 8008d92:	b29b      	uxth	r3, r3
 8008d94:	041b      	lsls	r3, r3, #16
 8008d96:	461c      	mov	r4, r3
                   DIEPTXF_INEPTXSA(otg_ram_alloc(usbp,
 8008d98:	2340      	movs	r3, #64	; 0x40
 8008d9a:	089b      	lsrs	r3, r3, #2
 8008d9c:	b29b      	uxth	r3, r3
 8008d9e:	9801      	ldr	r0, [sp, #4]
 8008da0:	4619      	mov	r1, r3
 8008da2:	f7ff f9e5 	bl	8008170 <otg_ram_alloc>
 8008da6:	4603      	mov	r3, r0
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8008da8:	ea44 0203 	orr.w	r2, r4, r3
 8008dac:	9b02      	ldr	r3, [sp, #8]
 8008dae:	629a      	str	r2, [r3, #40]	; 0x28
                   DIEPTXF_INEPTXSA(otg_ram_alloc(usbp,
                                                  ep0config.in_maxsize / 4));
}
 8008db0:	b004      	add	sp, #16
 8008db2:	bd10      	pop	{r4, pc}
 8008db4:	080160b0 	.word	0x080160b0
 8008db8:	f3af 8000 	nop.w
 8008dbc:	f3af 8000 	nop.w

08008dc0 <usb_lld_set_address>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {
 8008dc0:	b084      	sub	sp, #16
 8008dc2:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8008dc4:	9b01      	ldr	r3, [sp, #4]
 8008dc6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008dc8:	9303      	str	r3, [sp, #12]

  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 8008dca:	9b03      	ldr	r3, [sp, #12]
 8008dcc:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
 8008dd0:	f423 62fe 	bic.w	r2, r3, #2032	; 0x7f0
 8008dd4:	9b01      	ldr	r3, [sp, #4]
 8008dd6:	f893 3066 	ldrb.w	r3, [r3, #102]	; 0x66
 8008dda:	011b      	lsls	r3, r3, #4
 8008ddc:	431a      	orrs	r2, r3
 8008dde:	9b03      	ldr	r3, [sp, #12]
 8008de0:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
}
 8008de4:	b004      	add	sp, #16
 8008de6:	4770      	bx	lr
 8008de8:	f3af 8000 	nop.w
 8008dec:	f3af 8000 	nop.w

08008df0 <usb_lld_init_endpoint>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 8008df0:	b530      	push	{r4, r5, lr}
 8008df2:	b087      	sub	sp, #28
 8008df4:	9001      	str	r0, [sp, #4]
 8008df6:	460b      	mov	r3, r1
 8008df8:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl, fsize;
  stm32_otg_t *otgp = usbp->otg;
 8008dfc:	9b01      	ldr	r3, [sp, #4]
 8008dfe:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008e00:	9303      	str	r3, [sp, #12]

  /* IN and OUT common parameters.*/
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 8008e02:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008e06:	9a01      	ldr	r2, [sp, #4]
 8008e08:	3302      	adds	r3, #2
 8008e0a:	009b      	lsls	r3, r3, #2
 8008e0c:	4413      	add	r3, r2
 8008e0e:	685b      	ldr	r3, [r3, #4]
 8008e10:	681b      	ldr	r3, [r3, #0]
 8008e12:	f003 0303 	and.w	r3, r3, #3
 8008e16:	2b03      	cmp	r3, #3
 8008e18:	f200 8108 	bhi.w	800902c <usb_lld_init_endpoint+0x23c>
 8008e1c:	a201      	add	r2, pc, #4	; (adr r2, 8008e24 <usb_lld_init_endpoint+0x34>)
 8008e1e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8008e22:	bf00      	nop
 8008e24:	08008e35 	.word	0x08008e35
 8008e28:	08008e3b 	.word	0x08008e3b
 8008e2c:	08008e41 	.word	0x08008e41
 8008e30:	08008e47 	.word	0x08008e47
  case USB_EP_MODE_TYPE_CTRL:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL;
 8008e34:	4b7f      	ldr	r3, [pc, #508]	; (8009034 <usb_lld_init_endpoint+0x244>)
 8008e36:	9305      	str	r3, [sp, #20]
    break;
 8008e38:	e008      	b.n	8008e4c <usb_lld_init_endpoint+0x5c>
  case USB_EP_MODE_TYPE_ISOC:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_ISO;
 8008e3a:	4b7f      	ldr	r3, [pc, #508]	; (8009038 <usb_lld_init_endpoint+0x248>)
 8008e3c:	9305      	str	r3, [sp, #20]
    break;
 8008e3e:	e005      	b.n	8008e4c <usb_lld_init_endpoint+0x5c>
  case USB_EP_MODE_TYPE_BULK:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_BULK;
 8008e40:	4b7e      	ldr	r3, [pc, #504]	; (800903c <usb_lld_init_endpoint+0x24c>)
 8008e42:	9305      	str	r3, [sp, #20]
    break;
 8008e44:	e002      	b.n	8008e4c <usb_lld_init_endpoint+0x5c>
  case USB_EP_MODE_TYPE_INTR:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
 8008e46:	4b7e      	ldr	r3, [pc, #504]	; (8009040 <usb_lld_init_endpoint+0x250>)
 8008e48:	9305      	str	r3, [sp, #20]
    break;
 8008e4a:	bf00      	nop
  default:
    return;
  }

  /* OUT endpoint activation or deactivation.*/
  otgp->oe[ep].DOEPTSIZ = 0;
 8008e4c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008e50:	9a03      	ldr	r2, [sp, #12]
 8008e52:	015b      	lsls	r3, r3, #5
 8008e54:	4413      	add	r3, r2
 8008e56:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 8008e5a:	2200      	movs	r2, #0
 8008e5c:	601a      	str	r2, [r3, #0]
  if (usbp->epc[ep]->out_state != NULL) {
 8008e5e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008e62:	9a01      	ldr	r2, [sp, #4]
 8008e64:	3302      	adds	r3, #2
 8008e66:	009b      	lsls	r3, r3, #2
 8008e68:	4413      	add	r3, r2
 8008e6a:	685b      	ldr	r3, [r3, #4]
 8008e6c:	699b      	ldr	r3, [r3, #24]
 8008e6e:	2b00      	cmp	r3, #0
 8008e70:	d020      	beq.n	8008eb4 <usb_lld_init_endpoint+0xc4>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 8008e72:	f89d 0003 	ldrb.w	r0, [sp, #3]
 8008e76:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008e7a:	9a01      	ldr	r2, [sp, #4]
 8008e7c:	3302      	adds	r3, #2
 8008e7e:	009b      	lsls	r3, r3, #2
 8008e80:	4413      	add	r3, r2
 8008e82:	685b      	ldr	r3, [r3, #4]
 8008e84:	8a5b      	ldrh	r3, [r3, #18]
 8008e86:	461a      	mov	r2, r3
 8008e88:	9b05      	ldr	r3, [sp, #20]
 8008e8a:	431a      	orrs	r2, r3
 8008e8c:	9903      	ldr	r1, [sp, #12]
 8008e8e:	f100 0358 	add.w	r3, r0, #88	; 0x58
 8008e92:	015b      	lsls	r3, r3, #5
 8008e94:	440b      	add	r3, r1
 8008e96:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 8008e98:	9b03      	ldr	r3, [sp, #12]
 8008e9a:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 8008e9e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008ea2:	3310      	adds	r3, #16
 8008ea4:	2101      	movs	r1, #1
 8008ea6:	fa01 f303 	lsl.w	r3, r1, r3
 8008eaa:	431a      	orrs	r2, r3
 8008eac:	9b03      	ldr	r3, [sp, #12]
 8008eae:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 8008eb2:	e01d      	b.n	8008ef0 <usb_lld_init_endpoint+0x100>
  }
  else {
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 8008eb4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008eb8:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8008ebc:	9903      	ldr	r1, [sp, #12]
 8008ebe:	3258      	adds	r2, #88	; 0x58
 8008ec0:	0152      	lsls	r2, r2, #5
 8008ec2:	440a      	add	r2, r1
 8008ec4:	6812      	ldr	r2, [r2, #0]
 8008ec6:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8008eca:	9903      	ldr	r1, [sp, #12]
 8008ecc:	3358      	adds	r3, #88	; 0x58
 8008ece:	015b      	lsls	r3, r3, #5
 8008ed0:	440b      	add	r3, r1
 8008ed2:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 8008ed4:	9b03      	ldr	r3, [sp, #12]
 8008ed6:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 8008eda:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008ede:	3310      	adds	r3, #16
 8008ee0:	2101      	movs	r1, #1
 8008ee2:	fa01 f303 	lsl.w	r3, r1, r3
 8008ee6:	43db      	mvns	r3, r3
 8008ee8:	401a      	ands	r2, r3
 8008eea:	9b03      	ldr	r3, [sp, #12]
 8008eec:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
  }

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
 8008ef0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008ef4:	9a03      	ldr	r2, [sp, #12]
 8008ef6:	015b      	lsls	r3, r3, #5
 8008ef8:	4413      	add	r3, r2
 8008efa:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 8008efe:	2200      	movs	r2, #0
 8008f00:	601a      	str	r2, [r3, #0]
  if (usbp->epc[ep]->in_state != NULL) {
 8008f02:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008f06:	9a01      	ldr	r2, [sp, #4]
 8008f08:	3302      	adds	r3, #2
 8008f0a:	009b      	lsls	r3, r3, #2
 8008f0c:	4413      	add	r3, r2
 8008f0e:	685b      	ldr	r3, [r3, #4]
 8008f10:	695b      	ldr	r3, [r3, #20]
 8008f12:	2b00      	cmp	r3, #0
 8008f14:	d05d      	beq.n	8008fd2 <usb_lld_init_endpoint+0x1e2>
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
 8008f16:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008f1a:	9a01      	ldr	r2, [sp, #4]
 8008f1c:	3302      	adds	r3, #2
 8008f1e:	009b      	lsls	r3, r3, #2
 8008f20:	4413      	add	r3, r2
 8008f22:	685b      	ldr	r3, [r3, #4]
 8008f24:	8a1b      	ldrh	r3, [r3, #16]
 8008f26:	089b      	lsrs	r3, r3, #2
 8008f28:	b29b      	uxth	r3, r3
 8008f2a:	9304      	str	r3, [sp, #16]
    if (usbp->epc[ep]->in_multiplier > 1)
 8008f2c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008f30:	9a01      	ldr	r2, [sp, #4]
 8008f32:	3302      	adds	r3, #2
 8008f34:	009b      	lsls	r3, r3, #2
 8008f36:	4413      	add	r3, r2
 8008f38:	685b      	ldr	r3, [r3, #4]
 8008f3a:	8b9b      	ldrh	r3, [r3, #28]
 8008f3c:	2b01      	cmp	r3, #1
 8008f3e:	d90c      	bls.n	8008f5a <usb_lld_init_endpoint+0x16a>
      fsize *= usbp->epc[ep]->in_multiplier;
 8008f40:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008f44:	9a01      	ldr	r2, [sp, #4]
 8008f46:	3302      	adds	r3, #2
 8008f48:	009b      	lsls	r3, r3, #2
 8008f4a:	4413      	add	r3, r2
 8008f4c:	685b      	ldr	r3, [r3, #4]
 8008f4e:	8b9b      	ldrh	r3, [r3, #28]
 8008f50:	461a      	mov	r2, r3
 8008f52:	9b04      	ldr	r3, [sp, #16]
 8008f54:	fb02 f303 	mul.w	r3, r2, r3
 8008f58:	9304      	str	r3, [sp, #16]
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8008f5a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008f5e:	1e5c      	subs	r4, r3, #1
 8008f60:	9b04      	ldr	r3, [sp, #16]
 8008f62:	041d      	lsls	r5, r3, #16
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
 8008f64:	9801      	ldr	r0, [sp, #4]
 8008f66:	9904      	ldr	r1, [sp, #16]
 8008f68:	f7ff f902 	bl	8008170 <otg_ram_alloc>
 8008f6c:	4603      	mov	r3, r0
  if (usbp->epc[ep]->in_state != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8008f6e:	ea45 0203 	orr.w	r2, r5, r3
 8008f72:	9903      	ldr	r1, [sp, #12]
 8008f74:	f104 0340 	add.w	r3, r4, #64	; 0x40
 8008f78:	009b      	lsls	r3, r3, #2
 8008f7a:	440b      	add	r3, r1
 8008f7c:	605a      	str	r2, [r3, #4]
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);
 8008f7e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008f82:	9801      	ldr	r0, [sp, #4]
 8008f84:	4619      	mov	r1, r3
 8008f86:	f7ff f8c3 	bl	8008110 <otg_txfifo_flush>

    otgp->ie[ep].DIEPCTL = ctl |
 8008f8a:	f89d 0003 	ldrb.w	r0, [sp, #3]
                           DIEPCTL_TXFNUM(ep) |
 8008f8e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008f92:	059b      	lsls	r3, r3, #22
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 8008f94:	461a      	mov	r2, r3
 8008f96:	9b05      	ldr	r3, [sp, #20]
 8008f98:	431a      	orrs	r2, r3
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
 8008f9a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008f9e:	9901      	ldr	r1, [sp, #4]
 8008fa0:	3302      	adds	r3, #2
 8008fa2:	009b      	lsls	r3, r3, #2
 8008fa4:	440b      	add	r3, r1
 8008fa6:	685b      	ldr	r3, [r3, #4]
 8008fa8:	8a1b      	ldrh	r3, [r3, #16]
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
                           DIEPCTL_TXFNUM(ep) |
 8008faa:	431a      	orrs	r2, r3
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 8008fac:	9903      	ldr	r1, [sp, #12]
 8008fae:	f100 0348 	add.w	r3, r0, #72	; 0x48
 8008fb2:	015b      	lsls	r3, r3, #5
 8008fb4:	440b      	add	r3, r1
 8008fb6:	601a      	str	r2, [r3, #0]
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 8008fb8:	9b03      	ldr	r3, [sp, #12]
 8008fba:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 8008fbe:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008fc2:	2101      	movs	r1, #1
 8008fc4:	fa01 f303 	lsl.w	r3, r1, r3
 8008fc8:	431a      	orrs	r2, r3
 8008fca:	9b03      	ldr	r3, [sp, #12]
 8008fcc:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 8008fd0:	e02d      	b.n	800902e <usb_lld_init_endpoint+0x23e>
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 8008fd2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008fd6:	3b01      	subs	r3, #1
 8008fd8:	9a03      	ldr	r2, [sp, #12]
 8008fda:	3340      	adds	r3, #64	; 0x40
 8008fdc:	009b      	lsls	r3, r3, #2
 8008fde:	4413      	add	r3, r2
 8008fe0:	4a18      	ldr	r2, [pc, #96]	; (8009044 <usb_lld_init_endpoint+0x254>)
 8008fe2:	605a      	str	r2, [r3, #4]
    otg_txfifo_flush(usbp, ep);
 8008fe4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008fe8:	9801      	ldr	r0, [sp, #4]
 8008fea:	4619      	mov	r1, r3
 8008fec:	f7ff f890 	bl	8008110 <otg_txfifo_flush>
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 8008ff0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008ff4:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8008ff8:	9903      	ldr	r1, [sp, #12]
 8008ffa:	3248      	adds	r2, #72	; 0x48
 8008ffc:	0152      	lsls	r2, r2, #5
 8008ffe:	440a      	add	r2, r1
 8009000:	6812      	ldr	r2, [r2, #0]
 8009002:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8009006:	9903      	ldr	r1, [sp, #12]
 8009008:	3348      	adds	r3, #72	; 0x48
 800900a:	015b      	lsls	r3, r3, #5
 800900c:	440b      	add	r3, r1
 800900e:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 8009010:	9b03      	ldr	r3, [sp, #12]
 8009012:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 8009016:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800901a:	2101      	movs	r1, #1
 800901c:	fa01 f303 	lsl.w	r3, r1, r3
 8009020:	43db      	mvns	r3, r3
 8009022:	401a      	ands	r2, r3
 8009024:	9b03      	ldr	r3, [sp, #12]
 8009026:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 800902a:	e000      	b.n	800902e <usb_lld_init_endpoint+0x23e>
    break;
  case USB_EP_MODE_TYPE_INTR:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
    break;
  default:
    return;
 800902c:	bf00      	nop
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
    otg_txfifo_flush(usbp, ep);
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
  }
}
 800902e:	b007      	add	sp, #28
 8009030:	bd30      	pop	{r4, r5, pc}
 8009032:	bf00      	nop
 8009034:	10008000 	.word	0x10008000
 8009038:	10048000 	.word	0x10048000
 800903c:	10088000 	.word	0x10088000
 8009040:	100c8000 	.word	0x100c8000
 8009044:	02000400 	.word	0x02000400
 8009048:	f3af 8000 	nop.w
 800904c:	f3af 8000 	nop.w

08009050 <usb_lld_disable_endpoints>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_disable_endpoints(USBDriver *usbp) {
 8009050:	b500      	push	{lr}
 8009052:	b083      	sub	sp, #12
 8009054:	9001      	str	r0, [sp, #4]

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);
 8009056:	9801      	ldr	r0, [sp, #4]
 8009058:	f7ff f87a 	bl	8008150 <otg_ram_reset>

  /* Disabling all endpoints.*/
  otg_disable_ep(usbp);
 800905c:	9801      	ldr	r0, [sp, #4]
 800905e:	f7fe fff7 	bl	8008050 <otg_disable_ep>
}
 8009062:	b003      	add	sp, #12
 8009064:	f85d fb04 	ldr.w	pc, [sp], #4
 8009068:	f3af 8000 	nop.w
 800906c:	f3af 8000 	nop.w

08009070 <usb_lld_get_status_out>:
 * @retval EP_STATUS_STALLED  The endpoint is stalled.
 * @retval EP_STATUS_ACTIVE   The endpoint is active.
 *
 * @notapi
 */
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {
 8009070:	b084      	sub	sp, #16
 8009072:	9001      	str	r0, [sp, #4]
 8009074:	460b      	mov	r3, r1
 8009076:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->oe[ep].DOEPCTL;
 800907a:	9b01      	ldr	r3, [sp, #4]
 800907c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800907e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009082:	3358      	adds	r3, #88	; 0x58
 8009084:	015b      	lsls	r3, r3, #5
 8009086:	4413      	add	r3, r2
 8009088:	681b      	ldr	r3, [r3, #0]
 800908a:	9303      	str	r3, [sp, #12]
  if (!(ctl & DOEPCTL_USBAEP))
 800908c:	9b03      	ldr	r3, [sp, #12]
 800908e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8009092:	2b00      	cmp	r3, #0
 8009094:	d101      	bne.n	800909a <usb_lld_get_status_out+0x2a>
    return EP_STATUS_DISABLED;
 8009096:	2300      	movs	r3, #0
 8009098:	e007      	b.n	80090aa <usb_lld_get_status_out+0x3a>
  if (ctl & DOEPCTL_STALL)
 800909a:	9b03      	ldr	r3, [sp, #12]
 800909c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80090a0:	2b00      	cmp	r3, #0
 80090a2:	d001      	beq.n	80090a8 <usb_lld_get_status_out+0x38>
    return EP_STATUS_STALLED;
 80090a4:	2301      	movs	r3, #1
 80090a6:	e000      	b.n	80090aa <usb_lld_get_status_out+0x3a>
  return EP_STATUS_ACTIVE;
 80090a8:	2302      	movs	r3, #2
}
 80090aa:	4618      	mov	r0, r3
 80090ac:	b004      	add	sp, #16
 80090ae:	4770      	bx	lr

080090b0 <usb_lld_get_status_in>:
 * @retval EP_STATUS_STALLED  The endpoint is stalled.
 * @retval EP_STATUS_ACTIVE   The endpoint is active.
 *
 * @notapi
 */
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {
 80090b0:	b084      	sub	sp, #16
 80090b2:	9001      	str	r0, [sp, #4]
 80090b4:	460b      	mov	r3, r1
 80090b6:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->ie[ep].DIEPCTL;
 80090ba:	9b01      	ldr	r3, [sp, #4]
 80090bc:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 80090be:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80090c2:	3348      	adds	r3, #72	; 0x48
 80090c4:	015b      	lsls	r3, r3, #5
 80090c6:	4413      	add	r3, r2
 80090c8:	681b      	ldr	r3, [r3, #0]
 80090ca:	9303      	str	r3, [sp, #12]
  if (!(ctl & DIEPCTL_USBAEP))
 80090cc:	9b03      	ldr	r3, [sp, #12]
 80090ce:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 80090d2:	2b00      	cmp	r3, #0
 80090d4:	d101      	bne.n	80090da <usb_lld_get_status_in+0x2a>
    return EP_STATUS_DISABLED;
 80090d6:	2300      	movs	r3, #0
 80090d8:	e007      	b.n	80090ea <usb_lld_get_status_in+0x3a>
  if (ctl & DIEPCTL_STALL)
 80090da:	9b03      	ldr	r3, [sp, #12]
 80090dc:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80090e0:	2b00      	cmp	r3, #0
 80090e2:	d001      	beq.n	80090e8 <usb_lld_get_status_in+0x38>
    return EP_STATUS_STALLED;
 80090e4:	2301      	movs	r3, #1
 80090e6:	e000      	b.n	80090ea <usb_lld_get_status_in+0x3a>
  return EP_STATUS_ACTIVE;
 80090e8:	2302      	movs	r3, #2
}
 80090ea:	4618      	mov	r0, r3
 80090ec:	b004      	add	sp, #16
 80090ee:	4770      	bx	lr

080090f0 <usb_lld_read_setup>:
 * @param[in] ep        endpoint number
 * @param[out] buf      buffer where to copy the packet data
 *
 * @notapi
 */
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {
 80090f0:	b500      	push	{lr}
 80090f2:	b085      	sub	sp, #20
 80090f4:	9003      	str	r0, [sp, #12]
 80090f6:	460b      	mov	r3, r1
 80090f8:	9201      	str	r2, [sp, #4]
 80090fa:	f88d 300b 	strb.w	r3, [sp, #11]

  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 80090fe:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8009102:	9a03      	ldr	r2, [sp, #12]
 8009104:	3302      	adds	r3, #2
 8009106:	009b      	lsls	r3, r3, #2
 8009108:	4413      	add	r3, r2
 800910a:	685b      	ldr	r3, [r3, #4]
 800910c:	6a1b      	ldr	r3, [r3, #32]
 800910e:	9801      	ldr	r0, [sp, #4]
 8009110:	4619      	mov	r1, r3
 8009112:	2208      	movs	r2, #8
 8009114:	f00c fc74 	bl	8015a00 <memcpy>
}
 8009118:	b005      	add	sp, #20
 800911a:	f85d fb04 	ldr.w	pc, [sp], #4
 800911e:	bf00      	nop

08009120 <usb_lld_start_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 8009120:	b086      	sub	sp, #24
 8009122:	9001      	str	r0, [sp, #4]
 8009124:	460b      	mov	r3, r1
 8009126:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t pcnt, rxsize;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800912a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800912e:	9a01      	ldr	r2, [sp, #4]
 8009130:	3302      	adds	r3, #2
 8009132:	009b      	lsls	r3, r3, #2
 8009134:	4413      	add	r3, r2
 8009136:	685b      	ldr	r3, [r3, #4]
 8009138:	699b      	ldr	r3, [r3, #24]
 800913a:	9305      	str	r3, [sp, #20]

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
 800913c:	9b05      	ldr	r3, [sp, #20]
 800913e:	681a      	ldr	r2, [r3, #0]
 8009140:	9b05      	ldr	r3, [sp, #20]
 8009142:	60da      	str	r2, [r3, #12]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
 8009144:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009148:	2b00      	cmp	r3, #0
 800914a:	d106      	bne.n	800915a <usb_lld_start_out+0x3a>
 800914c:	9b05      	ldr	r3, [sp, #20]
 800914e:	681b      	ldr	r3, [r3, #0]
 8009150:	2b40      	cmp	r3, #64	; 0x40
 8009152:	d902      	bls.n	800915a <usb_lld_start_out+0x3a>
      osp->rxsize = EP0_MAX_OUTSIZE;
 8009154:	9b05      	ldr	r3, [sp, #20]
 8009156:	2240      	movs	r2, #64	; 0x40
 8009158:	601a      	str	r2, [r3, #0]
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 800915a:	9b05      	ldr	r3, [sp, #20]
 800915c:	681a      	ldr	r2, [r3, #0]
 800915e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009162:	9901      	ldr	r1, [sp, #4]
 8009164:	3302      	adds	r3, #2
 8009166:	009b      	lsls	r3, r3, #2
 8009168:	440b      	add	r3, r1
 800916a:	685b      	ldr	r3, [r3, #4]
 800916c:	8a5b      	ldrh	r3, [r3, #18]
 800916e:	4413      	add	r3, r2
 8009170:	1e5a      	subs	r2, r3, #1
           usbp->epc[ep]->out_maxsize;
 8009172:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009176:	9901      	ldr	r1, [sp, #4]
 8009178:	3302      	adds	r3, #2
 800917a:	009b      	lsls	r3, r3, #2
 800917c:	440b      	add	r3, r1
 800917e:	685b      	ldr	r3, [r3, #4]
 8009180:	8a5b      	ldrh	r3, [r3, #18]
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8009182:	fbb2 f3f3 	udiv	r3, r2, r3
 8009186:	9304      	str	r3, [sp, #16]
           usbp->epc[ep]->out_maxsize;
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
 8009188:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800918c:	9a01      	ldr	r2, [sp, #4]
 800918e:	3302      	adds	r3, #2
 8009190:	009b      	lsls	r3, r3, #2
 8009192:	4413      	add	r3, r2
 8009194:	685b      	ldr	r3, [r3, #4]
 8009196:	8a5b      	ldrh	r3, [r3, #18]
 8009198:	9a04      	ldr	r2, [sp, #16]
 800919a:	fb02 f303 	mul.w	r3, r2, r3
 800919e:	3303      	adds	r3, #3
 80091a0:	f023 0303 	bic.w	r3, r3, #3
 80091a4:	9303      	str	r3, [sp, #12]

  /*Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 80091a6:	9b01      	ldr	r3, [sp, #4]
 80091a8:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 80091aa:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80091ae:	9a04      	ldr	r2, [sp, #16]
 80091b0:	04d0      	lsls	r0, r2, #19
 80091b2:	9a03      	ldr	r2, [sp, #12]
 80091b4:	4302      	orrs	r2, r0
 80091b6:	f042 42c0 	orr.w	r2, r2, #1610612736	; 0x60000000
 80091ba:	015b      	lsls	r3, r3, #5
 80091bc:	440b      	add	r3, r1
 80091be:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 80091c2:	601a      	str	r2, [r3, #0]
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 80091c4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80091c8:	9a01      	ldr	r2, [sp, #4]
 80091ca:	3302      	adds	r3, #2
 80091cc:	009b      	lsls	r3, r3, #2
 80091ce:	4413      	add	r3, r2
 80091d0:	685b      	ldr	r3, [r3, #4]
 80091d2:	681b      	ldr	r3, [r3, #0]
 80091d4:	f003 0303 	and.w	r3, r3, #3
 80091d8:	2b01      	cmp	r3, #1
 80091da:	d12c      	bne.n	8009236 <usb_lld_start_out+0x116>
    /* Odd/even bit toggling for isochronous endpoint.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 80091dc:	9b01      	ldr	r3, [sp, #4]
 80091de:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80091e0:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 80091e4:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80091e8:	2b00      	cmp	r3, #0
 80091ea:	d012      	beq.n	8009212 <usb_lld_start_out+0xf2>
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
 80091ec:	9b01      	ldr	r3, [sp, #4]
 80091ee:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 80091f0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80091f4:	9a01      	ldr	r2, [sp, #4]
 80091f6:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 80091f8:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80091fc:	3258      	adds	r2, #88	; 0x58
 80091fe:	0152      	lsls	r2, r2, #5
 8009200:	4402      	add	r2, r0
 8009202:	6812      	ldr	r2, [r2, #0]
 8009204:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8009208:	3358      	adds	r3, #88	; 0x58
 800920a:	015b      	lsls	r3, r3, #5
 800920c:	440b      	add	r3, r1
 800920e:	601a      	str	r2, [r3, #0]
 8009210:	e011      	b.n	8009236 <usb_lld_start_out+0x116>
    else
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
 8009212:	9b01      	ldr	r3, [sp, #4]
 8009214:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 8009216:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800921a:	9a01      	ldr	r2, [sp, #4]
 800921c:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 800921e:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8009222:	3258      	adds	r2, #88	; 0x58
 8009224:	0152      	lsls	r2, r2, #5
 8009226:	4402      	add	r2, r0
 8009228:	6812      	ldr	r2, [r2, #0]
 800922a:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 800922e:	3358      	adds	r3, #88	; 0x58
 8009230:	015b      	lsls	r3, r3, #5
 8009232:	440b      	add	r3, r1
 8009234:	601a      	str	r2, [r3, #0]
  }

  /* Starting operation.*/
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 8009236:	9b01      	ldr	r3, [sp, #4]
 8009238:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800923a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800923e:	9a01      	ldr	r2, [sp, #4]
 8009240:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8009242:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8009246:	3258      	adds	r2, #88	; 0x58
 8009248:	0152      	lsls	r2, r2, #5
 800924a:	4402      	add	r2, r0
 800924c:	6812      	ldr	r2, [r2, #0]
 800924e:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8009252:	3358      	adds	r3, #88	; 0x58
 8009254:	015b      	lsls	r3, r3, #5
 8009256:	440b      	add	r3, r1
 8009258:	601a      	str	r2, [r3, #0]
}
 800925a:	b006      	add	sp, #24
 800925c:	4770      	bx	lr
 800925e:	bf00      	nop

08009260 <usb_lld_start_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8009260:	b084      	sub	sp, #16
 8009262:	9001      	str	r0, [sp, #4]
 8009264:	460b      	mov	r3, r1
 8009266:	f88d 3003 	strb.w	r3, [sp, #3]
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800926a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800926e:	9a01      	ldr	r2, [sp, #4]
 8009270:	3302      	adds	r3, #2
 8009272:	009b      	lsls	r3, r3, #2
 8009274:	4413      	add	r3, r2
 8009276:	685b      	ldr	r3, [r3, #4]
 8009278:	695b      	ldr	r3, [r3, #20]
 800927a:	9303      	str	r3, [sp, #12]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
 800927c:	9b03      	ldr	r3, [sp, #12]
 800927e:	681a      	ldr	r2, [r3, #0]
 8009280:	9b03      	ldr	r3, [sp, #12]
 8009282:	60da      	str	r2, [r3, #12]
  if (isp->txsize == 0) {
 8009284:	9b03      	ldr	r3, [sp, #12]
 8009286:	681b      	ldr	r3, [r3, #0]
 8009288:	2b00      	cmp	r3, #0
 800928a:	d10b      	bne.n	80092a4 <usb_lld_start_in+0x44>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 800928c:	9b01      	ldr	r3, [sp, #4]
 800928e:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8009290:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009294:	015b      	lsls	r3, r3, #5
 8009296:	4413      	add	r3, r2
 8009298:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 800929c:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 80092a0:	601a      	str	r2, [r3, #0]
 80092a2:	e031      	b.n	8009308 <usb_lld_start_in+0xa8>
  }
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 80092a4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80092a8:	2b00      	cmp	r3, #0
 80092aa:	d106      	bne.n	80092ba <usb_lld_start_in+0x5a>
 80092ac:	9b03      	ldr	r3, [sp, #12]
 80092ae:	681b      	ldr	r3, [r3, #0]
 80092b0:	2b40      	cmp	r3, #64	; 0x40
 80092b2:	d902      	bls.n	80092ba <usb_lld_start_in+0x5a>
      isp->txsize = EP0_MAX_INSIZE;
 80092b4:	9b03      	ldr	r3, [sp, #12]
 80092b6:	2240      	movs	r2, #64	; 0x40
 80092b8:	601a      	str	r2, [r3, #0]

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 80092ba:	9b03      	ldr	r3, [sp, #12]
 80092bc:	681a      	ldr	r2, [r3, #0]
 80092be:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80092c2:	9901      	ldr	r1, [sp, #4]
 80092c4:	3302      	adds	r3, #2
 80092c6:	009b      	lsls	r3, r3, #2
 80092c8:	440b      	add	r3, r1
 80092ca:	685b      	ldr	r3, [r3, #4]
 80092cc:	8a1b      	ldrh	r3, [r3, #16]
 80092ce:	4413      	add	r3, r2
 80092d0:	1e5a      	subs	r2, r3, #1
                    usbp->epc[ep]->in_maxsize;
 80092d2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80092d6:	9901      	ldr	r1, [sp, #4]
 80092d8:	3302      	adds	r3, #2
 80092da:	009b      	lsls	r3, r3, #2
 80092dc:	440b      	add	r3, r1
 80092de:	685b      	ldr	r3, [r3, #4]
 80092e0:	8a1b      	ldrh	r3, [r3, #16]
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
      isp->txsize = EP0_MAX_INSIZE;

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 80092e2:	fbb2 f3f3 	udiv	r3, r2, r3
 80092e6:	9302      	str	r3, [sp, #8]
                    usbp->epc[ep]->in_maxsize;
    /* TODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 80092e8:	9b01      	ldr	r3, [sp, #4]
 80092ea:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 80092ec:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80092f0:	9a02      	ldr	r2, [sp, #8]
 80092f2:	04d0      	lsls	r0, r2, #19
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
 80092f4:	9a03      	ldr	r2, [sp, #12]
 80092f6:	6812      	ldr	r2, [r2, #0]

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
                    usbp->epc[ep]->in_maxsize;
    /* TODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 80092f8:	4302      	orrs	r2, r0
 80092fa:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 80092fe:	015b      	lsls	r3, r3, #5
 8009300:	440b      	add	r3, r1
 8009302:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 8009306:	601a      	str	r2, [r3, #0]
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8009308:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800930c:	9a01      	ldr	r2, [sp, #4]
 800930e:	3302      	adds	r3, #2
 8009310:	009b      	lsls	r3, r3, #2
 8009312:	4413      	add	r3, r2
 8009314:	685b      	ldr	r3, [r3, #4]
 8009316:	681b      	ldr	r3, [r3, #0]
 8009318:	f003 0303 	and.w	r3, r3, #3
 800931c:	2b01      	cmp	r3, #1
 800931e:	d12c      	bne.n	800937a <usb_lld_start_in+0x11a>
    /* Odd/even bit toggling.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 8009320:	9b01      	ldr	r3, [sp, #4]
 8009322:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8009324:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 8009328:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800932c:	2b00      	cmp	r3, #0
 800932e:	d012      	beq.n	8009356 <usb_lld_start_in+0xf6>
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
 8009330:	9b01      	ldr	r3, [sp, #4]
 8009332:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 8009334:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009338:	9a01      	ldr	r2, [sp, #4]
 800933a:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 800933c:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8009340:	3248      	adds	r2, #72	; 0x48
 8009342:	0152      	lsls	r2, r2, #5
 8009344:	4402      	add	r2, r0
 8009346:	6812      	ldr	r2, [r2, #0]
 8009348:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800934c:	3348      	adds	r3, #72	; 0x48
 800934e:	015b      	lsls	r3, r3, #5
 8009350:	440b      	add	r3, r1
 8009352:	601a      	str	r2, [r3, #0]
 8009354:	e011      	b.n	800937a <usb_lld_start_in+0x11a>
    else
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
 8009356:	9b01      	ldr	r3, [sp, #4]
 8009358:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800935a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800935e:	9a01      	ldr	r2, [sp, #4]
 8009360:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8009362:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8009366:	3248      	adds	r2, #72	; 0x48
 8009368:	0152      	lsls	r2, r2, #5
 800936a:	4402      	add	r2, r0
 800936c:	6812      	ldr	r2, [r2, #0]
 800936e:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8009372:	3348      	adds	r3, #72	; 0x48
 8009374:	015b      	lsls	r3, r3, #5
 8009376:	440b      	add	r3, r1
 8009378:	601a      	str	r2, [r3, #0]
  }

  /* Starting operation.*/
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 800937a:	9b01      	ldr	r3, [sp, #4]
 800937c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800937e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009382:	9a01      	ldr	r2, [sp, #4]
 8009384:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8009386:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800938a:	3248      	adds	r2, #72	; 0x48
 800938c:	0152      	lsls	r2, r2, #5
 800938e:	4402      	add	r2, r0
 8009390:	6812      	ldr	r2, [r2, #0]
 8009392:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8009396:	3348      	adds	r3, #72	; 0x48
 8009398:	015b      	lsls	r3, r3, #5
 800939a:	440b      	add	r3, r1
 800939c:	601a      	str	r2, [r3, #0]
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 800939e:	9b01      	ldr	r3, [sp, #4]
 80093a0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80093a2:	9a01      	ldr	r2, [sp, #4]
 80093a4:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
 80093a6:	f8d2 1834 	ldr.w	r1, [r2, #2100]	; 0x834
 80093aa:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80093ae:	2001      	movs	r0, #1
 80093b0:	fa00 f202 	lsl.w	r2, r0, r2
 80093b4:	430a      	orrs	r2, r1
 80093b6:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
}
 80093ba:	b004      	add	sp, #16
 80093bc:	4770      	bx	lr
 80093be:	bf00      	nop

080093c0 <usb_lld_stall_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {
 80093c0:	b082      	sub	sp, #8
 80093c2:	9001      	str	r0, [sp, #4]
 80093c4:	460b      	mov	r3, r1
 80093c6:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 80093ca:	9b01      	ldr	r3, [sp, #4]
 80093cc:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 80093ce:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80093d2:	9a01      	ldr	r2, [sp, #4]
 80093d4:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 80093d6:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80093da:	3258      	adds	r2, #88	; 0x58
 80093dc:	0152      	lsls	r2, r2, #5
 80093de:	4402      	add	r2, r0
 80093e0:	6812      	ldr	r2, [r2, #0]
 80093e2:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80093e6:	3358      	adds	r3, #88	; 0x58
 80093e8:	015b      	lsls	r3, r3, #5
 80093ea:	440b      	add	r3, r1
 80093ec:	601a      	str	r2, [r3, #0]
}
 80093ee:	b002      	add	sp, #8
 80093f0:	4770      	bx	lr
 80093f2:	bf00      	nop
 80093f4:	f3af 8000 	nop.w
 80093f8:	f3af 8000 	nop.w
 80093fc:	f3af 8000 	nop.w

08009400 <usb_lld_stall_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {
 8009400:	b082      	sub	sp, #8
 8009402:	9001      	str	r0, [sp, #4]
 8009404:	460b      	mov	r3, r1
 8009406:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 800940a:	9b01      	ldr	r3, [sp, #4]
 800940c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800940e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009412:	9a01      	ldr	r2, [sp, #4]
 8009414:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8009416:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800941a:	3248      	adds	r2, #72	; 0x48
 800941c:	0152      	lsls	r2, r2, #5
 800941e:	4402      	add	r2, r0
 8009420:	6812      	ldr	r2, [r2, #0]
 8009422:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8009426:	3348      	adds	r3, #72	; 0x48
 8009428:	015b      	lsls	r3, r3, #5
 800942a:	440b      	add	r3, r1
 800942c:	601a      	str	r2, [r3, #0]
}
 800942e:	b002      	add	sp, #8
 8009430:	4770      	bx	lr
 8009432:	bf00      	nop
 8009434:	f3af 8000 	nop.w
 8009438:	f3af 8000 	nop.w
 800943c:	f3af 8000 	nop.w

08009440 <usb_lld_clear_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {
 8009440:	b082      	sub	sp, #8
 8009442:	9001      	str	r0, [sp, #4]
 8009444:	460b      	mov	r3, r1
 8009446:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 800944a:	9b01      	ldr	r3, [sp, #4]
 800944c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800944e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009452:	9a01      	ldr	r2, [sp, #4]
 8009454:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8009456:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800945a:	3258      	adds	r2, #88	; 0x58
 800945c:	0152      	lsls	r2, r2, #5
 800945e:	4402      	add	r2, r0
 8009460:	6812      	ldr	r2, [r2, #0]
 8009462:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8009466:	3358      	adds	r3, #88	; 0x58
 8009468:	015b      	lsls	r3, r3, #5
 800946a:	440b      	add	r3, r1
 800946c:	601a      	str	r2, [r3, #0]
}
 800946e:	b002      	add	sp, #8
 8009470:	4770      	bx	lr
 8009472:	bf00      	nop
 8009474:	f3af 8000 	nop.w
 8009478:	f3af 8000 	nop.w
 800947c:	f3af 8000 	nop.w

08009480 <usb_lld_clear_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {
 8009480:	b082      	sub	sp, #8
 8009482:	9001      	str	r0, [sp, #4]
 8009484:	460b      	mov	r3, r1
 8009486:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 800948a:	9b01      	ldr	r3, [sp, #4]
 800948c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800948e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009492:	9a01      	ldr	r2, [sp, #4]
 8009494:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8009496:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800949a:	3248      	adds	r2, #72	; 0x48
 800949c:	0152      	lsls	r2, r2, #5
 800949e:	4402      	add	r2, r0
 80094a0:	6812      	ldr	r2, [r2, #0]
 80094a2:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 80094a6:	3348      	adds	r3, #72	; 0x48
 80094a8:	015b      	lsls	r3, r3, #5
 80094aa:	440b      	add	r3, r1
 80094ac:	601a      	str	r2, [r3, #0]
}
 80094ae:	b002      	add	sp, #8
 80094b0:	4770      	bx	lr
 80094b2:	bf00      	nop
 80094b4:	f3af 8000 	nop.w
 80094b8:	f3af 8000 	nop.w
 80094bc:	f3af 8000 	nop.w

080094c0 <usb_lld_pump>:
 *
 * @param[in] p         pointer to the @p USBDriver object
 *
 * @special
 */
void usb_lld_pump(void *p) {
 80094c0:	b500      	push	{lr}
 80094c2:	b089      	sub	sp, #36	; 0x24
 80094c4:	9001      	str	r0, [sp, #4]
  USBDriver *usbp = (USBDriver *)p;
 80094c6:	9b01      	ldr	r3, [sp, #4]
 80094c8:	9306      	str	r3, [sp, #24]
  stm32_otg_t *otgp = usbp->otg;
 80094ca:	9b06      	ldr	r3, [sp, #24]
 80094cc:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80094ce:	9305      	str	r3, [sp, #20]

#if defined(_CHIBIOS_RT_)
  chRegSetThreadName("usb_lld_pump");
 80094d0:	483d      	ldr	r0, [pc, #244]	; (80095c8 <usb_lld_pump+0x108>)
 80094d2:	f7fe fd3d 	bl	8007f50 <chRegSetThreadName>
#endif
  osalSysLock();
 80094d6:	f7fe fd4b 	bl	8007f70 <osalSysLock>
  while (true) {
    usbep_t ep;
    uint32_t epmask;

    /* Nothing to do, going to sleep.*/
    if ((usbp->state == USB_STOP) ||
 80094da:	9b06      	ldr	r3, [sp, #24]
 80094dc:	781b      	ldrb	r3, [r3, #0]
 80094de:	2b01      	cmp	r3, #1
 80094e0:	d009      	beq.n	80094f6 <usb_lld_pump+0x36>
        ((usbp->txpending == 0) && !(otgp->GINTSTS & GINTSTS_RXFLVL))) {
 80094e2:	9b06      	ldr	r3, [sp, #24]
 80094e4:	6f9b      	ldr	r3, [r3, #120]	; 0x78
  while (true) {
    usbep_t ep;
    uint32_t epmask;

    /* Nothing to do, going to sleep.*/
    if ((usbp->state == USB_STOP) ||
 80094e6:	2b00      	cmp	r3, #0
 80094e8:	d110      	bne.n	800950c <usb_lld_pump+0x4c>
        ((usbp->txpending == 0) && !(otgp->GINTSTS & GINTSTS_RXFLVL))) {
 80094ea:	9b05      	ldr	r3, [sp, #20]
 80094ec:	695b      	ldr	r3, [r3, #20]
 80094ee:	f003 0310 	and.w	r3, r3, #16
 80094f2:	2b00      	cmp	r3, #0
 80094f4:	d10a      	bne.n	800950c <usb_lld_pump+0x4c>
      otgp->GINTMSK |= GINTMSK_RXFLVLM;
 80094f6:	9b05      	ldr	r3, [sp, #20]
 80094f8:	699b      	ldr	r3, [r3, #24]
 80094fa:	f043 0210 	orr.w	r2, r3, #16
 80094fe:	9b05      	ldr	r3, [sp, #20]
 8009500:	619a      	str	r2, [r3, #24]
      osalThreadSuspendS(&usbp->wait);
 8009502:	9b06      	ldr	r3, [sp, #24]
 8009504:	337c      	adds	r3, #124	; 0x7c
 8009506:	4618      	mov	r0, r3
 8009508:	f7fe fd62 	bl	8007fd0 <osalThreadSuspendS>
    }
    osalSysUnlock();
 800950c:	f7fe fd38 	bl	8007f80 <osalSysUnlock>

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8009510:	2300      	movs	r3, #0
 8009512:	f88d 301f 	strb.w	r3, [sp, #31]
 8009516:	e04d      	b.n	80095b4 <usb_lld_pump+0xf4>

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 8009518:	e002      	b.n	8009520 <usb_lld_pump+0x60>
        otg_rxfifo_handler(usbp);
 800951a:	9806      	ldr	r0, [sp, #24]
 800951c:	f7fe fe78 	bl	8008210 <otg_rxfifo_handler>

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 8009520:	9b05      	ldr	r3, [sp, #20]
 8009522:	695b      	ldr	r3, [r3, #20]
 8009524:	f003 0310 	and.w	r3, r3, #16
 8009528:	2b00      	cmp	r3, #0
 800952a:	d1f6      	bne.n	800951a <usb_lld_pump+0x5a>
        otg_rxfifo_handler(usbp);
      }

      epmask = (1 << ep);
 800952c:	f89d 301f 	ldrb.w	r3, [sp, #31]
 8009530:	2201      	movs	r2, #1
 8009532:	fa02 f303 	lsl.w	r3, r2, r3
 8009536:	9304      	str	r3, [sp, #16]
      if (usbp->txpending & epmask) {
 8009538:	9b06      	ldr	r3, [sp, #24]
 800953a:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800953c:	9b04      	ldr	r3, [sp, #16]
 800953e:	4013      	ands	r3, r2
 8009540:	2b00      	cmp	r3, #0
 8009542:	d032      	beq.n	80095aa <usb_lld_pump+0xea>
        bool done;

        osalSysLock();
 8009544:	f7fe fd14 	bl	8007f70 <osalSysLock>
           operation.
           Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
             "The application has to finish writing one complete packet before
              switching to a different channel/endpoint FIFO. Violating this
              rule results in an error.".*/
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 8009548:	9b05      	ldr	r3, [sp, #20]
 800954a:	689b      	ldr	r3, [r3, #8]
 800954c:	f023 0201 	bic.w	r2, r3, #1
 8009550:	9b05      	ldr	r3, [sp, #20]
 8009552:	609a      	str	r2, [r3, #8]
        usbp->txpending &= ~epmask;
 8009554:	9b06      	ldr	r3, [sp, #24]
 8009556:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 8009558:	9b04      	ldr	r3, [sp, #16]
 800955a:	43db      	mvns	r3, r3
 800955c:	401a      	ands	r2, r3
 800955e:	9b06      	ldr	r3, [sp, #24]
 8009560:	679a      	str	r2, [r3, #120]	; 0x78
        osalSysUnlock();
 8009562:	f7fe fd0d 	bl	8007f80 <osalSysUnlock>

        done = otg_txfifo_handler(usbp, ep);
 8009566:	f89d 301f 	ldrb.w	r3, [sp, #31]
 800956a:	9806      	ldr	r0, [sp, #24]
 800956c:	4619      	mov	r1, r3
 800956e:	f7fe fed7 	bl	8008320 <otg_txfifo_handler>
 8009572:	4603      	mov	r3, r0
 8009574:	f88d 300f 	strb.w	r3, [sp, #15]

        osalSysLock();
 8009578:	f7fe fcfa 	bl	8007f70 <osalSysLock>
        otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 800957c:	9b05      	ldr	r3, [sp, #20]
 800957e:	689b      	ldr	r3, [r3, #8]
 8009580:	f043 0201 	orr.w	r2, r3, #1
 8009584:	9b05      	ldr	r3, [sp, #20]
 8009586:	609a      	str	r2, [r3, #8]
        if (!done)
 8009588:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800958c:	f083 0301 	eor.w	r3, r3, #1
 8009590:	b2db      	uxtb	r3, r3
 8009592:	2b00      	cmp	r3, #0
 8009594:	d007      	beq.n	80095a6 <usb_lld_pump+0xe6>
          otgp->DIEPEMPMSK |= epmask;
 8009596:	9b05      	ldr	r3, [sp, #20]
 8009598:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 800959c:	9b04      	ldr	r3, [sp, #16]
 800959e:	431a      	orrs	r2, r3
 80095a0:	9b05      	ldr	r3, [sp, #20]
 80095a2:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
        osalSysUnlock();
 80095a6:	f7fe fceb 	bl	8007f80 <osalSysUnlock>
      osalThreadSuspendS(&usbp->wait);
    }
    osalSysUnlock();

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80095aa:	f89d 301f 	ldrb.w	r3, [sp, #31]
 80095ae:	3301      	adds	r3, #1
 80095b0:	f88d 301f 	strb.w	r3, [sp, #31]
 80095b4:	f89d 201f 	ldrb.w	r2, [sp, #31]
 80095b8:	9b06      	ldr	r3, [sp, #24]
 80095ba:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80095bc:	689b      	ldr	r3, [r3, #8]
 80095be:	429a      	cmp	r2, r3
 80095c0:	d9aa      	bls.n	8009518 <usb_lld_pump+0x58>
        if (!done)
          otgp->DIEPEMPMSK |= epmask;
        osalSysUnlock();
      }
    }
    osalSysLock();
 80095c2:	f7fe fcd5 	bl	8007f70 <osalSysLock>
  }
 80095c6:	e788      	b.n	80094da <usb_lld_pump+0x1a>
 80095c8:	080160e0 	.word	0x080160e0
 80095cc:	f3af 8000 	nop.w

080095d0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80095d0:	b082      	sub	sp, #8
 80095d2:	2320      	movs	r3, #32
 80095d4:	9301      	str	r3, [sp, #4]
 80095d6:	9b01      	ldr	r3, [sp, #4]
 80095d8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80095dc:	b002      	add	sp, #8
 80095de:	4770      	bx	lr

080095e0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80095e0:	b082      	sub	sp, #8
 80095e2:	2300      	movs	r3, #0
 80095e4:	9301      	str	r3, [sp, #4]
 80095e6:	9b01      	ldr	r3, [sp, #4]
 80095e8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80095ec:	b002      	add	sp, #8
 80095ee:	4770      	bx	lr

080095f0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80095f0:	b508      	push	{r3, lr}

  port_lock();
 80095f2:	f7ff ffed 	bl	80095d0 <port_lock>
}
 80095f6:	bd08      	pop	{r3, pc}
 80095f8:	f3af 8000 	nop.w
 80095fc:	f3af 8000 	nop.w

08009600 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8009600:	b508      	push	{r3, lr}

  port_unlock();
 8009602:	f7ff ffed 	bl	80095e0 <port_unlock>
}
 8009606:	bd08      	pop	{r3, pc}
 8009608:	f3af 8000 	nop.w
 800960c:	f3af 8000 	nop.w

08009610 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8009610:	b508      	push	{r3, lr}

  port_lock();
 8009612:	f7ff ffdd 	bl	80095d0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8009616:	bd08      	pop	{r3, pc}
 8009618:	f3af 8000 	nop.w
 800961c:	f3af 8000 	nop.w

08009620 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8009620:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8009622:	f7ff ffdd 	bl	80095e0 <port_unlock>
}
 8009626:	bd08      	pop	{r3, pc}
 8009628:	f3af 8000 	nop.w
 800962c:	f3af 8000 	nop.w

08009630 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8009630:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8009632:	f7ff ffdd 	bl	80095f0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8009636:	bd08      	pop	{r3, pc}
 8009638:	f3af 8000 	nop.w
 800963c:	f3af 8000 	nop.w

08009640 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8009640:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8009642:	f7ff ffdd 	bl	8009600 <port_unlock_from_isr>
}
 8009646:	bd08      	pop	{r3, pc}
 8009648:	f3af 8000 	nop.w
 800964c:	f3af 8000 	nop.w

08009650 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8009650:	b508      	push	{r3, lr}

  chSysLock();
 8009652:	f7ff ffdd 	bl	8009610 <chSysLock>
}
 8009656:	bd08      	pop	{r3, pc}
 8009658:	f3af 8000 	nop.w
 800965c:	f3af 8000 	nop.w

08009660 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8009660:	b508      	push	{r3, lr}

  chSysUnlock();
 8009662:	f7ff ffdd 	bl	8009620 <chSysUnlock>
}
 8009666:	bd08      	pop	{r3, pc}
 8009668:	f3af 8000 	nop.w
 800966c:	f3af 8000 	nop.w

08009670 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8009670:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8009672:	f7ff ffdd 	bl	8009630 <chSysLockFromISR>
}
 8009676:	bd08      	pop	{r3, pc}
 8009678:	f3af 8000 	nop.w
 800967c:	f3af 8000 	nop.w

08009680 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8009680:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8009682:	f7ff ffdd 	bl	8009640 <chSysUnlockFromISR>
}
 8009686:	bd08      	pop	{r3, pc}
 8009688:	f3af 8000 	nop.w
 800968c:	f3af 8000 	nop.w

08009690 <osalThreadSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
static inline void osalThreadSleep(systime_t time) {
 8009690:	b500      	push	{lr}
 8009692:	b083      	sub	sp, #12
 8009694:	9001      	str	r0, [sp, #4]

  chThdSleep(time);
 8009696:	9801      	ldr	r0, [sp, #4]
 8009698:	f7f7 fe1a 	bl	80012d0 <chThdSleep>
}
 800969c:	b003      	add	sp, #12
 800969e:	f85d fb04 	ldr.w	pc, [sp], #4
 80096a2:	bf00      	nop
 80096a4:	f3af 8000 	nop.w
 80096a8:	f3af 8000 	nop.w
 80096ac:	f3af 8000 	nop.w

080096b0 <osalThreadSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 80096b0:	b500      	push	{lr}
 80096b2:	b083      	sub	sp, #12
 80096b4:	9001      	str	r0, [sp, #4]

  return chThdSuspendS(trp);
 80096b6:	9801      	ldr	r0, [sp, #4]
 80096b8:	f7f7 feca 	bl	8001450 <chThdSuspendS>
 80096bc:	4603      	mov	r3, r0
}
 80096be:	4618      	mov	r0, r3
 80096c0:	b003      	add	sp, #12
 80096c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80096c6:	bf00      	nop
 80096c8:	f3af 8000 	nop.w
 80096cc:	f3af 8000 	nop.w

080096d0 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 80096d0:	b500      	push	{lr}
 80096d2:	b083      	sub	sp, #12
 80096d4:	9001      	str	r0, [sp, #4]
 80096d6:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
 80096d8:	9801      	ldr	r0, [sp, #4]
 80096da:	9900      	ldr	r1, [sp, #0]
 80096dc:	f7f7 fef0 	bl	80014c0 <chThdResumeI>
}
 80096e0:	b003      	add	sp, #12
 80096e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80096e6:	bf00      	nop
 80096e8:	f3af 8000 	nop.w
 80096ec:	f3af 8000 	nop.w

080096f0 <sdc_lld_prepare_read_bytes>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_lld_prepare_read_bytes(SDCDriver *sdcp,
                                       uint8_t *buf, uint32_t bytes) {
 80096f0:	b500      	push	{lr}
 80096f2:	b087      	sub	sp, #28
 80096f4:	9003      	str	r0, [sp, #12]
 80096f6:	9102      	str	r1, [sp, #8]
 80096f8:	9201      	str	r2, [sp, #4]
  osalDbgCheck(bytes < 0x1000000);

  sdcp->sdmmc->DTIMER = SDMMC_READ_TIMEOUT;
 80096fa:	9b03      	ldr	r3, [sp, #12]
 80096fc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80096fe:	4a2d      	ldr	r2, [pc, #180]	; (80097b4 <sdc_lld_prepare_read_bytes+0xc4>)
 8009700:	625a      	str	r2, [r3, #36]	; 0x24

  /* Checks for errors and waits for the card to be ready for reading.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 8009702:	9803      	ldr	r0, [sp, #12]
 8009704:	f7fb ffac 	bl	8005660 <_sdc_wait_for_transfer_state>
 8009708:	4603      	mov	r3, r0
 800970a:	2b00      	cmp	r3, #0
 800970c:	d001      	beq.n	8009712 <sdc_lld_prepare_read_bytes+0x22>
    return HAL_FAILED;
 800970e:	2301      	movs	r3, #1
 8009710:	e04b      	b.n	80097aa <sdc_lld_prepare_read_bytes+0xba>

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 8009712:	9b03      	ldr	r3, [sp, #12]
 8009714:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009716:	685b      	ldr	r3, [r3, #4]
 8009718:	9a02      	ldr	r2, [sp, #8]
 800971a:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(sdcp->dma, bytes / sizeof (uint32_t));
 800971c:	9b03      	ldr	r3, [sp, #12]
 800971e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009720:	685b      	ldr	r3, [r3, #4]
 8009722:	9a01      	ldr	r2, [sp, #4]
 8009724:	0892      	lsrs	r2, r2, #2
 8009726:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
 8009728:	9b03      	ldr	r3, [sp, #12]
 800972a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800972c:	68db      	ldr	r3, [r3, #12]
 800972e:	681b      	ldr	r3, [r3, #0]
 8009730:	9305      	str	r3, [sp, #20]
 8009732:	9b03      	ldr	r3, [sp, #12]
 8009734:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009736:	7c1b      	ldrb	r3, [r3, #16]
 8009738:	220f      	movs	r2, #15
 800973a:	fa02 f303 	lsl.w	r3, r2, r3
 800973e:	43db      	mvns	r3, r3
 8009740:	9a05      	ldr	r2, [sp, #20]
 8009742:	4013      	ands	r3, r2
 8009744:	9305      	str	r3, [sp, #20]
 8009746:	9b03      	ldr	r3, [sp, #12]
 8009748:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800974a:	0c1a      	lsrs	r2, r3, #16
 800974c:	9b03      	ldr	r3, [sp, #12]
 800974e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009750:	7c1b      	ldrb	r3, [r3, #16]
 8009752:	fa02 f303 	lsl.w	r3, r2, r3
 8009756:	9a05      	ldr	r2, [sp, #20]
 8009758:	4313      	orrs	r3, r2
 800975a:	9305      	str	r3, [sp, #20]
 800975c:	9b03      	ldr	r3, [sp, #12]
 800975e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009760:	68db      	ldr	r3, [r3, #12]
 8009762:	9a05      	ldr	r2, [sp, #20]
 8009764:	601a      	str	r2, [r3, #0]
 8009766:	9b03      	ldr	r3, [sp, #12]
 8009768:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800976a:	685b      	ldr	r3, [r3, #4]
 800976c:	9a03      	ldr	r2, [sp, #12]
 800976e:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8009770:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(sdcp->dma);
 8009772:	9b03      	ldr	r3, [sp, #12]
 8009774:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009776:	685b      	ldr	r3, [r3, #4]
 8009778:	9a03      	ldr	r2, [sp, #12]
 800977a:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800977c:	6852      	ldr	r2, [r2, #4]
 800977e:	6812      	ldr	r2, [r2, #0]
 8009780:	f042 0201 	orr.w	r2, r2, #1
 8009784:	601a      	str	r2, [r3, #0]

  /* Setting up data transfer.*/
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 8009786:	9b03      	ldr	r3, [sp, #12]
 8009788:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800978a:	4a0b      	ldr	r2, [pc, #44]	; (80097b8 <sdc_lld_prepare_read_bytes+0xc8>)
 800978c:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdmmc->MASK  = SDMMC_MASK_DCRCFAILIE |
 800978e:	9b03      	ldr	r3, [sp, #12]
 8009790:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009792:	f44f 7295 	mov.w	r2, #298	; 0x12a
 8009796:	63da      	str	r2, [r3, #60]	; 0x3c
                       SDMMC_MASK_DTIMEOUTIE |
                       SDMMC_MASK_RXOVERRIE |
                       SDMMC_MASK_DATAENDIE;
  sdcp->sdmmc->DLEN  = bytes;
 8009798:	9b03      	ldr	r3, [sp, #12]
 800979a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800979c:	9a01      	ldr	r2, [sp, #4]
 800979e:	629a      	str	r2, [r3, #40]	; 0x28

  /* Transaction starts just after DTEN bit setting.*/
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DTDIR |
 80097a0:	9b03      	ldr	r3, [sp, #12]
 80097a2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80097a4:	220f      	movs	r2, #15
 80097a6:	62da      	str	r2, [r3, #44]	; 0x2c
                       SDMMC_DCTRL_DTMODE |   /* multibyte data transfer */
                       SDMMC_DCTRL_DMAEN |
                       SDMMC_DCTRL_DTEN;

  return HAL_SUCCESS;
 80097a8:	2300      	movs	r3, #0
}
 80097aa:	4618      	mov	r0, r3
 80097ac:	b007      	add	sp, #28
 80097ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80097b2:	bf00      	nop
 80097b4:	000927c0 	.word	0x000927c0
 80097b8:	004005ff 	.word	0x004005ff
 80097bc:	f3af 8000 	nop.w

080097c0 <sdc_lld_prepare_read>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_lld_prepare_read(SDCDriver *sdcp, uint32_t startblk,
                                 uint32_t n, uint32_t *resp) {
 80097c0:	b500      	push	{lr}
 80097c2:	b085      	sub	sp, #20
 80097c4:	9003      	str	r0, [sp, #12]
 80097c6:	9102      	str	r1, [sp, #8]
 80097c8:	9201      	str	r2, [sp, #4]
 80097ca:	9300      	str	r3, [sp, #0]

  /* Driver handles data in 512 bytes blocks (just like HC cards). But if we
     have not HC card than we must convert address from blocks to bytes.*/
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
 80097cc:	9b03      	ldr	r3, [sp, #12]
 80097ce:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80097d0:	f003 0310 	and.w	r3, r3, #16
 80097d4:	2b00      	cmp	r3, #0
 80097d6:	d102      	bne.n	80097de <sdc_lld_prepare_read+0x1e>
    startblk *= MMCSD_BLOCK_SIZE;
 80097d8:	9b02      	ldr	r3, [sp, #8]
 80097da:	025b      	lsls	r3, r3, #9
 80097dc:	9302      	str	r3, [sp, #8]

  if (n > 1) {
 80097de:	9b01      	ldr	r3, [sp, #4]
 80097e0:	2b01      	cmp	r3, #1
 80097e2:	d910      	bls.n	8009806 <sdc_lld_prepare_read+0x46>
    /* Send read multiple blocks command to card.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_MULTIPLE_BLOCK,
 80097e4:	9803      	ldr	r0, [sp, #12]
 80097e6:	2112      	movs	r1, #18
 80097e8:	9a02      	ldr	r2, [sp, #8]
 80097ea:	9b00      	ldr	r3, [sp, #0]
 80097ec:	f000 fab8 	bl	8009d60 <sdc_lld_send_cmd_short_crc>
 80097f0:	4603      	mov	r3, r0
 80097f2:	2b00      	cmp	r3, #0
 80097f4:	d105      	bne.n	8009802 <sdc_lld_prepare_read+0x42>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 80097f6:	9b00      	ldr	r3, [sp, #0]
 80097f8:	681a      	ldr	r2, [r3, #0]
 80097fa:	4b0e      	ldr	r3, [pc, #56]	; (8009834 <sdc_lld_prepare_read+0x74>)
 80097fc:	4013      	ands	r3, r2
 80097fe:	2b00      	cmp	r3, #0
 8009800:	d012      	beq.n	8009828 <sdc_lld_prepare_read+0x68>
      return HAL_FAILED;
 8009802:	2301      	movs	r3, #1
 8009804:	e011      	b.n	800982a <sdc_lld_prepare_read+0x6a>
  }
  else{
    /* Send read single block command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_SINGLE_BLOCK,
 8009806:	9803      	ldr	r0, [sp, #12]
 8009808:	2111      	movs	r1, #17
 800980a:	9a02      	ldr	r2, [sp, #8]
 800980c:	9b00      	ldr	r3, [sp, #0]
 800980e:	f000 faa7 	bl	8009d60 <sdc_lld_send_cmd_short_crc>
 8009812:	4603      	mov	r3, r0
 8009814:	2b00      	cmp	r3, #0
 8009816:	d105      	bne.n	8009824 <sdc_lld_prepare_read+0x64>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 8009818:	9b00      	ldr	r3, [sp, #0]
 800981a:	681a      	ldr	r2, [r3, #0]
 800981c:	4b05      	ldr	r3, [pc, #20]	; (8009834 <sdc_lld_prepare_read+0x74>)
 800981e:	4013      	ands	r3, r2
 8009820:	2b00      	cmp	r3, #0
 8009822:	d001      	beq.n	8009828 <sdc_lld_prepare_read+0x68>
      return HAL_FAILED;
 8009824:	2301      	movs	r3, #1
 8009826:	e000      	b.n	800982a <sdc_lld_prepare_read+0x6a>
  }

  return HAL_SUCCESS;
 8009828:	2300      	movs	r3, #0
}
 800982a:	4618      	mov	r0, r3
 800982c:	b005      	add	sp, #20
 800982e:	f85d fb04 	ldr.w	pc, [sp], #4
 8009832:	bf00      	nop
 8009834:	fdffe008 	.word	0xfdffe008
 8009838:	f3af 8000 	nop.w
 800983c:	f3af 8000 	nop.w

08009840 <sdc_lld_prepare_write>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_lld_prepare_write(SDCDriver *sdcp, uint32_t startblk,
                                  uint32_t n, uint32_t *resp) {
 8009840:	b500      	push	{lr}
 8009842:	b085      	sub	sp, #20
 8009844:	9003      	str	r0, [sp, #12]
 8009846:	9102      	str	r1, [sp, #8]
 8009848:	9201      	str	r2, [sp, #4]
 800984a:	9300      	str	r3, [sp, #0]

  /* Driver handles data in 512 bytes blocks (just like HC cards). But if we
     have not HC card than we must convert address from blocks to bytes.*/
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
 800984c:	9b03      	ldr	r3, [sp, #12]
 800984e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009850:	f003 0310 	and.w	r3, r3, #16
 8009854:	2b00      	cmp	r3, #0
 8009856:	d102      	bne.n	800985e <sdc_lld_prepare_write+0x1e>
    startblk *= MMCSD_BLOCK_SIZE;
 8009858:	9b02      	ldr	r3, [sp, #8]
 800985a:	025b      	lsls	r3, r3, #9
 800985c:	9302      	str	r3, [sp, #8]

  if (n > 1) {
 800985e:	9b01      	ldr	r3, [sp, #4]
 8009860:	2b01      	cmp	r3, #1
 8009862:	d910      	bls.n	8009886 <sdc_lld_prepare_write+0x46>
    /* Write multiple blocks command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_MULTIPLE_BLOCK,
 8009864:	9803      	ldr	r0, [sp, #12]
 8009866:	2119      	movs	r1, #25
 8009868:	9a02      	ldr	r2, [sp, #8]
 800986a:	9b00      	ldr	r3, [sp, #0]
 800986c:	f000 fa78 	bl	8009d60 <sdc_lld_send_cmd_short_crc>
 8009870:	4603      	mov	r3, r0
 8009872:	2b00      	cmp	r3, #0
 8009874:	d105      	bne.n	8009882 <sdc_lld_prepare_write+0x42>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 8009876:	9b00      	ldr	r3, [sp, #0]
 8009878:	681a      	ldr	r2, [r3, #0]
 800987a:	4b0e      	ldr	r3, [pc, #56]	; (80098b4 <sdc_lld_prepare_write+0x74>)
 800987c:	4013      	ands	r3, r2
 800987e:	2b00      	cmp	r3, #0
 8009880:	d012      	beq.n	80098a8 <sdc_lld_prepare_write+0x68>
      return HAL_FAILED;
 8009882:	2301      	movs	r3, #1
 8009884:	e011      	b.n	80098aa <sdc_lld_prepare_write+0x6a>
  }
  else{
    /* Write single block command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_BLOCK,
 8009886:	9803      	ldr	r0, [sp, #12]
 8009888:	2118      	movs	r1, #24
 800988a:	9a02      	ldr	r2, [sp, #8]
 800988c:	9b00      	ldr	r3, [sp, #0]
 800988e:	f000 fa67 	bl	8009d60 <sdc_lld_send_cmd_short_crc>
 8009892:	4603      	mov	r3, r0
 8009894:	2b00      	cmp	r3, #0
 8009896:	d105      	bne.n	80098a4 <sdc_lld_prepare_write+0x64>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 8009898:	9b00      	ldr	r3, [sp, #0]
 800989a:	681a      	ldr	r2, [r3, #0]
 800989c:	4b05      	ldr	r3, [pc, #20]	; (80098b4 <sdc_lld_prepare_write+0x74>)
 800989e:	4013      	ands	r3, r2
 80098a0:	2b00      	cmp	r3, #0
 80098a2:	d001      	beq.n	80098a8 <sdc_lld_prepare_write+0x68>
      return HAL_FAILED;
 80098a4:	2301      	movs	r3, #1
 80098a6:	e000      	b.n	80098aa <sdc_lld_prepare_write+0x6a>
  }

  return HAL_SUCCESS;
 80098a8:	2300      	movs	r3, #0
}
 80098aa:	4618      	mov	r0, r3
 80098ac:	b005      	add	sp, #20
 80098ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80098b2:	bf00      	nop
 80098b4:	fdffe008 	.word	0xfdffe008
 80098b8:	f3af 8000 	nop.w
 80098bc:	f3af 8000 	nop.w

080098c0 <sdc_lld_wait_transaction_end>:
 * @return              The operation status.
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 */
static bool sdc_lld_wait_transaction_end(SDCDriver *sdcp, uint32_t n,
                                         uint32_t *resp) {
 80098c0:	b500      	push	{lr}
 80098c2:	b085      	sub	sp, #20
 80098c4:	9003      	str	r0, [sp, #12]
 80098c6:	9102      	str	r1, [sp, #8]
 80098c8:	9201      	str	r2, [sp, #4]

  /* Note the mask is checked before going to sleep because the interrupt
     may have occurred before reaching the critical zone.*/
  osalSysLock();
 80098ca:	f7ff fec1 	bl	8009650 <osalSysLock>
  if (sdcp->sdmmc->MASK != 0)
 80098ce:	9b03      	ldr	r3, [sp, #12]
 80098d0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80098d2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80098d4:	2b00      	cmp	r3, #0
 80098d6:	d004      	beq.n	80098e2 <sdc_lld_wait_transaction_end+0x22>
    osalThreadSuspendS(&sdcp->thread);
 80098d8:	9b03      	ldr	r3, [sp, #12]
 80098da:	333c      	adds	r3, #60	; 0x3c
 80098dc:	4618      	mov	r0, r3
 80098de:	f7ff fee7 	bl	80096b0 <osalThreadSuspendS>
  if ((sdcp->sdmmc->STA & SDMMC_STA_DATAEND) == 0) {
 80098e2:	9b03      	ldr	r3, [sp, #12]
 80098e4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80098e6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80098e8:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80098ec:	2b00      	cmp	r3, #0
 80098ee:	d103      	bne.n	80098f8 <sdc_lld_wait_transaction_end+0x38>
    osalSysUnlock();
 80098f0:	f7ff feb6 	bl	8009660 <osalSysUnlock>
    return HAL_FAILED;
 80098f4:	2301      	movs	r3, #1
 80098f6:	e030      	b.n	800995a <sdc_lld_wait_transaction_end+0x9a>
  }

  /* Waits for transfer completion at DMA level, then the stream is
     disabled and cleared.*/
  dmaWaitCompletion(sdcp->dma);
 80098f8:	bf00      	nop
 80098fa:	9b03      	ldr	r3, [sp, #12]
 80098fc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80098fe:	685b      	ldr	r3, [r3, #4]
 8009900:	685b      	ldr	r3, [r3, #4]
 8009902:	2b00      	cmp	r3, #0
 8009904:	d1f9      	bne.n	80098fa <sdc_lld_wait_transaction_end+0x3a>
 8009906:	9b03      	ldr	r3, [sp, #12]
 8009908:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800990a:	685b      	ldr	r3, [r3, #4]
 800990c:	9a03      	ldr	r2, [sp, #12]
 800990e:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8009910:	6852      	ldr	r2, [r2, #4]
 8009912:	6812      	ldr	r2, [r2, #0]
 8009914:	f022 020f 	bic.w	r2, r2, #15
 8009918:	601a      	str	r2, [r3, #0]
 800991a:	9b03      	ldr	r3, [sp, #12]
 800991c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800991e:	681b      	ldr	r3, [r3, #0]
 8009920:	9a03      	ldr	r2, [sp, #12]
 8009922:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8009924:	7c12      	ldrb	r2, [r2, #16]
 8009926:	210f      	movs	r1, #15
 8009928:	fa01 f202 	lsl.w	r2, r1, r2
 800992c:	605a      	str	r2, [r3, #4]

  sdcp->sdmmc->ICR = SDMMC_ICR_ALL_FLAGS;
 800992e:	9b03      	ldr	r3, [sp, #12]
 8009930:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009932:	4a0c      	ldr	r2, [pc, #48]	; (8009964 <sdc_lld_wait_transaction_end+0xa4>)
 8009934:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdmmc->DCTRL = 0;
 8009936:	9b03      	ldr	r3, [sp, #12]
 8009938:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800993a:	2200      	movs	r2, #0
 800993c:	62da      	str	r2, [r3, #44]	; 0x2c
  osalSysUnlock();
 800993e:	f7ff fe8f 	bl	8009660 <osalSysUnlock>

  /* Finalize transaction.*/
  if (n > 1)
 8009942:	9b02      	ldr	r3, [sp, #8]
 8009944:	2b01      	cmp	r3, #1
 8009946:	d907      	bls.n	8009958 <sdc_lld_wait_transaction_end+0x98>
    return sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_STOP_TRANSMISSION, 0, resp);
 8009948:	9803      	ldr	r0, [sp, #12]
 800994a:	210c      	movs	r1, #12
 800994c:	2200      	movs	r2, #0
 800994e:	9b01      	ldr	r3, [sp, #4]
 8009950:	f000 fa06 	bl	8009d60 <sdc_lld_send_cmd_short_crc>
 8009954:	4603      	mov	r3, r0
 8009956:	e000      	b.n	800995a <sdc_lld_wait_transaction_end+0x9a>

  return HAL_SUCCESS;
 8009958:	2300      	movs	r3, #0
}
 800995a:	4618      	mov	r0, r3
 800995c:	b005      	add	sp, #20
 800995e:	f85d fb04 	ldr.w	pc, [sp], #4
 8009962:	bf00      	nop
 8009964:	004005ff 	.word	0x004005ff
 8009968:	f3af 8000 	nop.w
 800996c:	f3af 8000 	nop.w

08009970 <sdc_lld_collect_errors>:
 * @param[in] sdcp      pointer to the @p SDCDriver object
 * @param[in] sta       value of the STA register
 *
 * @notapi
 */
static void sdc_lld_collect_errors(SDCDriver *sdcp, uint32_t sta) {
 8009970:	b084      	sub	sp, #16
 8009972:	9001      	str	r0, [sp, #4]
 8009974:	9100      	str	r1, [sp, #0]
  uint32_t errors = SDC_NO_ERROR;
 8009976:	2300      	movs	r3, #0
 8009978:	9303      	str	r3, [sp, #12]

  if (sta & SDMMC_STA_CCRCFAIL)
 800997a:	9b00      	ldr	r3, [sp, #0]
 800997c:	f003 0301 	and.w	r3, r3, #1
 8009980:	2b00      	cmp	r3, #0
 8009982:	d003      	beq.n	800998c <sdc_lld_collect_errors+0x1c>
    errors |= SDC_CMD_CRC_ERROR;
 8009984:	9b03      	ldr	r3, [sp, #12]
 8009986:	f043 0301 	orr.w	r3, r3, #1
 800998a:	9303      	str	r3, [sp, #12]
  if (sta & SDMMC_STA_DCRCFAIL)
 800998c:	9b00      	ldr	r3, [sp, #0]
 800998e:	f003 0302 	and.w	r3, r3, #2
 8009992:	2b00      	cmp	r3, #0
 8009994:	d003      	beq.n	800999e <sdc_lld_collect_errors+0x2e>
    errors |= SDC_DATA_CRC_ERROR;
 8009996:	9b03      	ldr	r3, [sp, #12]
 8009998:	f043 0302 	orr.w	r3, r3, #2
 800999c:	9303      	str	r3, [sp, #12]
  if (sta & SDMMC_STA_CTIMEOUT)
 800999e:	9b00      	ldr	r3, [sp, #0]
 80099a0:	f003 0304 	and.w	r3, r3, #4
 80099a4:	2b00      	cmp	r3, #0
 80099a6:	d003      	beq.n	80099b0 <sdc_lld_collect_errors+0x40>
    errors |= SDC_COMMAND_TIMEOUT;
 80099a8:	9b03      	ldr	r3, [sp, #12]
 80099aa:	f043 0308 	orr.w	r3, r3, #8
 80099ae:	9303      	str	r3, [sp, #12]
  if (sta & SDMMC_STA_DTIMEOUT)
 80099b0:	9b00      	ldr	r3, [sp, #0]
 80099b2:	f003 0308 	and.w	r3, r3, #8
 80099b6:	2b00      	cmp	r3, #0
 80099b8:	d003      	beq.n	80099c2 <sdc_lld_collect_errors+0x52>
    errors |= SDC_DATA_TIMEOUT;
 80099ba:	9b03      	ldr	r3, [sp, #12]
 80099bc:	f043 0304 	orr.w	r3, r3, #4
 80099c0:	9303      	str	r3, [sp, #12]
  if (sta & SDMMC_STA_TXUNDERR)
 80099c2:	9b00      	ldr	r3, [sp, #0]
 80099c4:	f003 0310 	and.w	r3, r3, #16
 80099c8:	2b00      	cmp	r3, #0
 80099ca:	d003      	beq.n	80099d4 <sdc_lld_collect_errors+0x64>
    errors |= SDC_TX_UNDERRUN;
 80099cc:	9b03      	ldr	r3, [sp, #12]
 80099ce:	f043 0310 	orr.w	r3, r3, #16
 80099d2:	9303      	str	r3, [sp, #12]
  if (sta & SDMMC_STA_RXOVERR)
 80099d4:	9b00      	ldr	r3, [sp, #0]
 80099d6:	f003 0320 	and.w	r3, r3, #32
 80099da:	2b00      	cmp	r3, #0
 80099dc:	d003      	beq.n	80099e6 <sdc_lld_collect_errors+0x76>
    errors |= SDC_RX_OVERRUN;
 80099de:	9b03      	ldr	r3, [sp, #12]
 80099e0:	f043 0320 	orr.w	r3, r3, #32
 80099e4:	9303      	str	r3, [sp, #12]
/*  if (sta & SDMMC_STA_STBITERR)
    errors |= SDC_STARTBIT_ERROR;*/

  sdcp->errors |= errors;
 80099e6:	9b01      	ldr	r3, [sp, #4]
 80099e8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80099ea:	9b03      	ldr	r3, [sp, #12]
 80099ec:	431a      	orrs	r2, r3
 80099ee:	9b01      	ldr	r3, [sp, #4]
 80099f0:	635a      	str	r2, [r3, #52]	; 0x34
}
 80099f2:	b004      	add	sp, #16
 80099f4:	4770      	bx	lr
 80099f6:	bf00      	nop
 80099f8:	f3af 8000 	nop.w
 80099fc:	f3af 8000 	nop.w

08009a00 <sdc_lld_error_cleanup>:
 *
 * @notapi
 */
static void sdc_lld_error_cleanup(SDCDriver *sdcp,
                                  uint32_t n,
                                  uint32_t *resp) {
 8009a00:	b500      	push	{lr}
 8009a02:	b087      	sub	sp, #28
 8009a04:	9003      	str	r0, [sp, #12]
 8009a06:	9102      	str	r1, [sp, #8]
 8009a08:	9201      	str	r2, [sp, #4]
  uint32_t sta = sdcp->sdmmc->STA;
 8009a0a:	9b03      	ldr	r3, [sp, #12]
 8009a0c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009a0e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8009a10:	9305      	str	r3, [sp, #20]

  dmaStreamDisable(sdcp->dma);
 8009a12:	9b03      	ldr	r3, [sp, #12]
 8009a14:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009a16:	685b      	ldr	r3, [r3, #4]
 8009a18:	9a03      	ldr	r2, [sp, #12]
 8009a1a:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8009a1c:	6852      	ldr	r2, [r2, #4]
 8009a1e:	6812      	ldr	r2, [r2, #0]
 8009a20:	f022 020f 	bic.w	r2, r2, #15
 8009a24:	601a      	str	r2, [r3, #0]
 8009a26:	9b03      	ldr	r3, [sp, #12]
 8009a28:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009a2a:	681b      	ldr	r3, [r3, #0]
 8009a2c:	9a03      	ldr	r2, [sp, #12]
 8009a2e:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8009a30:	7c12      	ldrb	r2, [r2, #16]
 8009a32:	210f      	movs	r1, #15
 8009a34:	fa01 f202 	lsl.w	r2, r1, r2
 8009a38:	605a      	str	r2, [r3, #4]
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 8009a3a:	9b03      	ldr	r3, [sp, #12]
 8009a3c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009a3e:	4a0d      	ldr	r2, [pc, #52]	; (8009a74 <sdc_lld_error_cleanup+0x74>)
 8009a40:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdmmc->MASK  = 0;
 8009a42:	9b03      	ldr	r3, [sp, #12]
 8009a44:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009a46:	2200      	movs	r2, #0
 8009a48:	63da      	str	r2, [r3, #60]	; 0x3c
  sdcp->sdmmc->DCTRL = 0;
 8009a4a:	9b03      	ldr	r3, [sp, #12]
 8009a4c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009a4e:	2200      	movs	r2, #0
 8009a50:	62da      	str	r2, [r3, #44]	; 0x2c
  sdc_lld_collect_errors(sdcp, sta);
 8009a52:	9803      	ldr	r0, [sp, #12]
 8009a54:	9905      	ldr	r1, [sp, #20]
 8009a56:	f7ff ff8b 	bl	8009970 <sdc_lld_collect_errors>

  if (n > 1)
 8009a5a:	9b02      	ldr	r3, [sp, #8]
 8009a5c:	2b01      	cmp	r3, #1
 8009a5e:	d905      	bls.n	8009a6c <sdc_lld_error_cleanup+0x6c>
    sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_STOP_TRANSMISSION, 0, resp);
 8009a60:	9803      	ldr	r0, [sp, #12]
 8009a62:	210c      	movs	r1, #12
 8009a64:	2200      	movs	r2, #0
 8009a66:	9b01      	ldr	r3, [sp, #4]
 8009a68:	f000 f97a 	bl	8009d60 <sdc_lld_send_cmd_short_crc>
}
 8009a6c:	b007      	add	sp, #28
 8009a6e:	f85d fb04 	ldr.w	pc, [sp], #4
 8009a72:	bf00      	nop
 8009a74:	004005ff 	.word	0x004005ff
 8009a78:	f3af 8000 	nop.w
 8009a7c:	f3af 8000 	nop.w

08009a80 <Vector104>:
 * @details It just wakes transaction thread. All error  handling performs in
 *          that thread.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SDMMC1_HANDLER) {
 8009a80:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  osalSysLockFromISR();
 8009a82:	f7ff fdf5 	bl	8009670 <osalSysLockFromISR>

  /* Disables the source but the status flags are not reset because the
     read/write functions needs to check them.*/
  SDMMC1->MASK = 0;
 8009a86:	4b06      	ldr	r3, [pc, #24]	; (8009aa0 <Vector104+0x20>)
 8009a88:	2200      	movs	r2, #0
 8009a8a:	63da      	str	r2, [r3, #60]	; 0x3c

  osalThreadResumeI(&SDCD1.thread, MSG_OK);
 8009a8c:	4805      	ldr	r0, [pc, #20]	; (8009aa4 <Vector104+0x24>)
 8009a8e:	2100      	movs	r1, #0
 8009a90:	f7ff fe1e 	bl	80096d0 <osalThreadResumeI>

  osalSysUnlockFromISR();
 8009a94:	f7ff fdf4 	bl	8009680 <osalSysUnlockFromISR>

  OSAL_IRQ_EPILOGUE();
 8009a98:	f7fa f85a 	bl	8003b50 <_port_irq_epilogue>
}
 8009a9c:	bd08      	pop	{r3, pc}
 8009a9e:	bf00      	nop
 8009aa0:	40012800 	.word	0x40012800
 8009aa4:	20001164 	.word	0x20001164
 8009aa8:	f3af 8000 	nop.w
 8009aac:	f3af 8000 	nop.w

08009ab0 <sdc_lld_init>:
/**
 * @brief   Low level SDC driver initialization.
 *
 * @notapi
 */
void sdc_lld_init(void) {
 8009ab0:	b508      	push	{r3, lr}

  sdcObjectInit(&SDCD1);
 8009ab2:	4806      	ldr	r0, [pc, #24]	; (8009acc <sdc_lld_init+0x1c>)
 8009ab4:	f7fb fe0c 	bl	80056d0 <sdcObjectInit>
  SDCD1.thread = NULL;
 8009ab8:	4b04      	ldr	r3, [pc, #16]	; (8009acc <sdc_lld_init+0x1c>)
 8009aba:	2200      	movs	r2, #0
 8009abc:	63da      	str	r2, [r3, #60]	; 0x3c
  SDCD1.dma    = STM32_DMA_STREAM(STM32_SDC_SDMMC1_DMA_STREAM);
 8009abe:	4b03      	ldr	r3, [pc, #12]	; (8009acc <sdc_lld_init+0x1c>)
 8009ac0:	4a03      	ldr	r2, [pc, #12]	; (8009ad0 <sdc_lld_init+0x20>)
 8009ac2:	645a      	str	r2, [r3, #68]	; 0x44
  SDCD1.sdmmc  = SDMMC1;
 8009ac4:	4b01      	ldr	r3, [pc, #4]	; (8009acc <sdc_lld_init+0x1c>)
 8009ac6:	4a03      	ldr	r2, [pc, #12]	; (8009ad4 <sdc_lld_init+0x24>)
 8009ac8:	649a      	str	r2, [r3, #72]	; 0x48
}
 8009aca:	bd08      	pop	{r3, pc}
 8009acc:	20001128 	.word	0x20001128
 8009ad0:	08016058 	.word	0x08016058
 8009ad4:	40012800 	.word	0x40012800
 8009ad8:	f3af 8000 	nop.w
 8009adc:	f3af 8000 	nop.w

08009ae0 <sdc_lld_start>:
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 *
 * @notapi
 */
void sdc_lld_start(SDCDriver *sdcp) {
 8009ae0:	b500      	push	{lr}
 8009ae2:	b085      	sub	sp, #20
 8009ae4:	9001      	str	r0, [sp, #4]

  /* Checking configuration, using a default if NULL has been passed.*/
  if (sdcp->config == NULL) {
 8009ae6:	9b01      	ldr	r3, [sp, #4]
 8009ae8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009aea:	2b00      	cmp	r3, #0
 8009aec:	d102      	bne.n	8009af4 <sdc_lld_start+0x14>
    sdcp->config = &sdc_default_cfg;
 8009aee:	9b01      	ldr	r3, [sp, #4]
 8009af0:	4a1b      	ldr	r2, [pc, #108]	; (8009b60 <sdc_lld_start+0x80>)
 8009af2:	62da      	str	r2, [r3, #44]	; 0x2c
  }

  sdcp->dmamode = STM32_DMA_CR_CHSEL(DMA_CHANNEL) |
 8009af4:	9b01      	ldr	r3, [sp, #4]
 8009af6:	4a1b      	ldr	r2, [pc, #108]	; (8009b64 <sdc_lld_start+0x84>)
 8009af8:	641a      	str	r2, [r3, #64]	; 0x40
  sdcp->dmamode |= STM32_DMA_CR_PFCTRL |
                   STM32_DMA_CR_PBURST_INCR4 |
                   STM32_DMA_CR_MBURST_INCR4;
#endif

  if (sdcp->state == BLK_STOP) {
 8009afa:	9b01      	ldr	r3, [sp, #4]
 8009afc:	791b      	ldrb	r3, [r3, #4]
 8009afe:	2b01      	cmp	r3, #1
 8009b00:	d11b      	bne.n	8009b3a <sdc_lld_start+0x5a>
    /* Note, the DMA must be enabled before the IRQs.*/
    bool b;
    b = dmaStreamAllocate(sdcp->dma, STM32_SDC_SDMMC1_IRQ_PRIORITY, NULL, NULL);
 8009b02:	9b01      	ldr	r3, [sp, #4]
 8009b04:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009b06:	4618      	mov	r0, r3
 8009b08:	2109      	movs	r1, #9
 8009b0a:	2200      	movs	r2, #0
 8009b0c:	2300      	movs	r3, #0
 8009b0e:	f7fd ff47 	bl	80079a0 <dmaStreamAllocate>
 8009b12:	4603      	mov	r3, r0
 8009b14:	f88d 300f 	strb.w	r3, [sp, #15]
    osalDbgAssert(!b, "stream already allocated");
    dmaStreamSetPeripheral(sdcp->dma, &sdcp->sdmmc->FIFO);
 8009b18:	9b01      	ldr	r3, [sp, #4]
 8009b1a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009b1c:	685b      	ldr	r3, [r3, #4]
 8009b1e:	9a01      	ldr	r2, [sp, #4]
 8009b20:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8009b22:	3280      	adds	r2, #128	; 0x80
 8009b24:	609a      	str	r2, [r3, #8]
#if STM32_DMA_ADVANCED
    dmaStreamSetFIFO(sdcp->dma, STM32_DMA_FCR_DMDIS | STM32_DMA_FCR_FTH_FULL);
#endif
    nvicEnableVector(STM32_SDMMC1_NUMBER, STM32_SDC_SDMMC1_IRQ_PRIORITY);
 8009b26:	2031      	movs	r0, #49	; 0x31
 8009b28:	2109      	movs	r1, #9
 8009b2a:	f7fd fa29 	bl	8006f80 <nvicEnableVector>
    rccEnableSDMMC1(FALSE);
 8009b2e:	4b0e      	ldr	r3, [pc, #56]	; (8009b68 <sdc_lld_start+0x88>)
 8009b30:	4a0d      	ldr	r2, [pc, #52]	; (8009b68 <sdc_lld_start+0x88>)
 8009b32:	6e12      	ldr	r2, [r2, #96]	; 0x60
 8009b34:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8009b38:	661a      	str	r2, [r3, #96]	; 0x60
  }

  /* Configuration, card clock is initially stopped.*/
  sdcp->sdmmc->POWER  = 0;
 8009b3a:	9b01      	ldr	r3, [sp, #4]
 8009b3c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009b3e:	2200      	movs	r2, #0
 8009b40:	601a      	str	r2, [r3, #0]
  sdcp->sdmmc->CLKCR  = 0;
 8009b42:	9b01      	ldr	r3, [sp, #4]
 8009b44:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009b46:	2200      	movs	r2, #0
 8009b48:	605a      	str	r2, [r3, #4]
  sdcp->sdmmc->DCTRL  = 0;
 8009b4a:	9b01      	ldr	r3, [sp, #4]
 8009b4c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009b4e:	2200      	movs	r2, #0
 8009b50:	62da      	str	r2, [r3, #44]	; 0x2c
  sdcp->sdmmc->DTIMER = 0;
 8009b52:	9b01      	ldr	r3, [sp, #4]
 8009b54:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009b56:	2200      	movs	r2, #0
 8009b58:	625a      	str	r2, [r3, #36]	; 0x24
}
 8009b5a:	b005      	add	sp, #20
 8009b5c:	f85d fb04 	ldr.w	pc, [sp], #4
 8009b60:	080160f0 	.word	0x080160f0
 8009b64:	00073a80 	.word	0x00073a80
 8009b68:	40021000 	.word	0x40021000
 8009b6c:	f3af 8000 	nop.w

08009b70 <sdc_lld_stop>:
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 *
 * @notapi
 */
void sdc_lld_stop(SDCDriver *sdcp) {
 8009b70:	b500      	push	{lr}
 8009b72:	b083      	sub	sp, #12
 8009b74:	9001      	str	r0, [sp, #4]

  if (sdcp->state != BLK_STOP) {
 8009b76:	9b01      	ldr	r3, [sp, #4]
 8009b78:	791b      	ldrb	r3, [r3, #4]
 8009b7a:	2b01      	cmp	r3, #1
 8009b7c:	d01d      	beq.n	8009bba <sdc_lld_stop+0x4a>

    /* SDIO deactivation.*/
    sdcp->sdmmc->POWER  = 0;
 8009b7e:	9b01      	ldr	r3, [sp, #4]
 8009b80:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009b82:	2200      	movs	r2, #0
 8009b84:	601a      	str	r2, [r3, #0]
    sdcp->sdmmc->CLKCR  = 0;
 8009b86:	9b01      	ldr	r3, [sp, #4]
 8009b88:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009b8a:	2200      	movs	r2, #0
 8009b8c:	605a      	str	r2, [r3, #4]
    sdcp->sdmmc->DCTRL  = 0;
 8009b8e:	9b01      	ldr	r3, [sp, #4]
 8009b90:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009b92:	2200      	movs	r2, #0
 8009b94:	62da      	str	r2, [r3, #44]	; 0x2c
    sdcp->sdmmc->DTIMER = 0;
 8009b96:	9b01      	ldr	r3, [sp, #4]
 8009b98:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009b9a:	2200      	movs	r2, #0
 8009b9c:	625a      	str	r2, [r3, #36]	; 0x24

    /* Clock deactivation.*/
    nvicDisableVector(STM32_SDMMC1_NUMBER);
 8009b9e:	2031      	movs	r0, #49	; 0x31
 8009ba0:	f7fd fa16 	bl	8006fd0 <nvicDisableVector>
    dmaStreamRelease(sdcp->dma);
 8009ba4:	9b01      	ldr	r3, [sp, #4]
 8009ba6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009ba8:	4618      	mov	r0, r3
 8009baa:	f7fd ff69 	bl	8007a80 <dmaStreamRelease>
    rccDisableSDMMC1(FALSE);
 8009bae:	4b04      	ldr	r3, [pc, #16]	; (8009bc0 <sdc_lld_stop+0x50>)
 8009bb0:	4a03      	ldr	r2, [pc, #12]	; (8009bc0 <sdc_lld_stop+0x50>)
 8009bb2:	6e12      	ldr	r2, [r2, #96]	; 0x60
 8009bb4:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8009bb8:	661a      	str	r2, [r3, #96]	; 0x60
  }
}
 8009bba:	b003      	add	sp, #12
 8009bbc:	f85d fb04 	ldr.w	pc, [sp], #4
 8009bc0:	40021000 	.word	0x40021000
 8009bc4:	f3af 8000 	nop.w
 8009bc8:	f3af 8000 	nop.w
 8009bcc:	f3af 8000 	nop.w

08009bd0 <sdc_lld_start_clk>:
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 *
 * @notapi
 */
void sdc_lld_start_clk(SDCDriver *sdcp) {
 8009bd0:	b500      	push	{lr}
 8009bd2:	b083      	sub	sp, #12
 8009bd4:	9001      	str	r0, [sp, #4]

  /* Initial clock setting: 400kHz, 1bit mode.*/
  sdcp->sdmmc->CLKCR  = SDMMC_CLKDIV_LS;
 8009bd6:	9b01      	ldr	r3, [sp, #4]
 8009bd8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009bda:	2276      	movs	r2, #118	; 0x76
 8009bdc:	605a      	str	r2, [r3, #4]
  sdcp->sdmmc->POWER |= SDMMC_POWER_PWRCTRL_0 | SDMMC_POWER_PWRCTRL_1;
 8009bde:	9b01      	ldr	r3, [sp, #4]
 8009be0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009be2:	9a01      	ldr	r2, [sp, #4]
 8009be4:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8009be6:	6812      	ldr	r2, [r2, #0]
 8009be8:	f042 0203 	orr.w	r2, r2, #3
 8009bec:	601a      	str	r2, [r3, #0]
  sdcp->sdmmc->CLKCR |= SDMMC_CLKCR_CLKEN;
 8009bee:	9b01      	ldr	r3, [sp, #4]
 8009bf0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009bf2:	9a01      	ldr	r2, [sp, #4]
 8009bf4:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8009bf6:	6852      	ldr	r2, [r2, #4]
 8009bf8:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8009bfc:	605a      	str	r2, [r3, #4]

  /* Clock activation delay.*/
  osalThreadSleep(OSAL_MS2ST(STM32_SDC_SDMMC_CLOCK_DELAY));
 8009bfe:	200a      	movs	r0, #10
 8009c00:	f7ff fd46 	bl	8009690 <osalThreadSleep>
}
 8009c04:	b003      	add	sp, #12
 8009c06:	f85d fb04 	ldr.w	pc, [sp], #4
 8009c0a:	bf00      	nop
 8009c0c:	f3af 8000 	nop.w

08009c10 <sdc_lld_set_data_clk>:
 * @param[in] sdcp      pointer to the @p SDCDriver object
 * @param[in] clk       the clock mode
 *
 * @notapi
 */
void sdc_lld_set_data_clk(SDCDriver *sdcp, sdcbusclk_t clk) {
 8009c10:	b082      	sub	sp, #8
 8009c12:	9001      	str	r0, [sp, #4]
 8009c14:	460b      	mov	r3, r1
 8009c16:	f88d 3003 	strb.w	r3, [sp, #3]
  else
    sdcp->sdmmc->CLKCR = (sdcp->sdmmc->CLKCR & 0xFFFFFF00U) | SDMMC_CLKDIV_HS;
#else
  (void)clk;

  sdcp->sdmmc->CLKCR = (sdcp->sdmmc->CLKCR & 0xFFFFFF00U) | SDMMC_CLKDIV_HS;
 8009c1a:	9b01      	ldr	r3, [sp, #4]
 8009c1c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009c1e:	9a01      	ldr	r2, [sp, #4]
 8009c20:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8009c22:	6852      	ldr	r2, [r2, #4]
 8009c24:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 8009c28:	605a      	str	r2, [r3, #4]
#endif
}
 8009c2a:	b002      	add	sp, #8
 8009c2c:	4770      	bx	lr
 8009c2e:	bf00      	nop

08009c30 <sdc_lld_stop_clk>:
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 *
 * @notapi
 */
void sdc_lld_stop_clk(SDCDriver *sdcp) {
 8009c30:	b082      	sub	sp, #8
 8009c32:	9001      	str	r0, [sp, #4]

  sdcp->sdmmc->CLKCR = 0;
 8009c34:	9b01      	ldr	r3, [sp, #4]
 8009c36:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009c38:	2200      	movs	r2, #0
 8009c3a:	605a      	str	r2, [r3, #4]
  sdcp->sdmmc->POWER = 0;
 8009c3c:	9b01      	ldr	r3, [sp, #4]
 8009c3e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009c40:	2200      	movs	r2, #0
 8009c42:	601a      	str	r2, [r3, #0]
}
 8009c44:	b002      	add	sp, #8
 8009c46:	4770      	bx	lr
 8009c48:	f3af 8000 	nop.w
 8009c4c:	f3af 8000 	nop.w

08009c50 <sdc_lld_set_bus_mode>:
 * @param[in] sdcp      pointer to the @p SDCDriver object
 * @param[in] mode      bus mode
 *
 * @notapi
 */
void sdc_lld_set_bus_mode(SDCDriver *sdcp, sdcbusmode_t mode) {
 8009c50:	b084      	sub	sp, #16
 8009c52:	9001      	str	r0, [sp, #4]
 8009c54:	460b      	mov	r3, r1
 8009c56:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t clk = sdcp->sdmmc->CLKCR & ~SDMMC_CLKCR_WIDBUS;
 8009c5a:	9b01      	ldr	r3, [sp, #4]
 8009c5c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009c5e:	685b      	ldr	r3, [r3, #4]
 8009c60:	f423 53c0 	bic.w	r3, r3, #6144	; 0x1800
 8009c64:	9303      	str	r3, [sp, #12]

  switch (mode) {
 8009c66:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009c6a:	2b01      	cmp	r3, #1
 8009c6c:	d008      	beq.n	8009c80 <sdc_lld_set_bus_mode+0x30>
 8009c6e:	2b02      	cmp	r3, #2
 8009c70:	d00d      	beq.n	8009c8e <sdc_lld_set_bus_mode+0x3e>
 8009c72:	2b00      	cmp	r3, #0
 8009c74:	d112      	bne.n	8009c9c <sdc_lld_set_bus_mode+0x4c>
  case SDC_MODE_1BIT:
    sdcp->sdmmc->CLKCR = clk;
 8009c76:	9b01      	ldr	r3, [sp, #4]
 8009c78:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009c7a:	9a03      	ldr	r2, [sp, #12]
 8009c7c:	605a      	str	r2, [r3, #4]
    break;
 8009c7e:	e00d      	b.n	8009c9c <sdc_lld_set_bus_mode+0x4c>
  case SDC_MODE_4BIT:
    sdcp->sdmmc->CLKCR = clk | SDMMC_CLKCR_WIDBUS_0;
 8009c80:	9b01      	ldr	r3, [sp, #4]
 8009c82:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009c84:	9a03      	ldr	r2, [sp, #12]
 8009c86:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8009c8a:	605a      	str	r2, [r3, #4]
    break;
 8009c8c:	e006      	b.n	8009c9c <sdc_lld_set_bus_mode+0x4c>
  case SDC_MODE_8BIT:
    sdcp->sdmmc->CLKCR = clk | SDMMC_CLKCR_WIDBUS_1;
 8009c8e:	9b01      	ldr	r3, [sp, #4]
 8009c90:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009c92:	9a03      	ldr	r2, [sp, #12]
 8009c94:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8009c98:	605a      	str	r2, [r3, #4]
    break;
 8009c9a:	bf00      	nop
  }
}
 8009c9c:	b004      	add	sp, #16
 8009c9e:	4770      	bx	lr

08009ca0 <sdc_lld_send_cmd_none>:
 * @param[in] cmd       card command
 * @param[in] arg       command argument
 *
 * @notapi
 */
void sdc_lld_send_cmd_none(SDCDriver *sdcp, uint8_t cmd, uint32_t arg) {
 8009ca0:	b084      	sub	sp, #16
 8009ca2:	9003      	str	r0, [sp, #12]
 8009ca4:	460b      	mov	r3, r1
 8009ca6:	9201      	str	r2, [sp, #4]
 8009ca8:	f88d 300b 	strb.w	r3, [sp, #11]

  sdcp->sdmmc->ARG = arg;
 8009cac:	9b03      	ldr	r3, [sp, #12]
 8009cae:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009cb0:	9a01      	ldr	r2, [sp, #4]
 8009cb2:	609a      	str	r2, [r3, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_CPSMEN;
 8009cb4:	9b03      	ldr	r3, [sp, #12]
 8009cb6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009cb8:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8009cbc:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8009cc0:	60da      	str	r2, [r3, #12]
  while ((sdcp->sdmmc->STA & SDMMC_STA_CMDSENT) == 0)
 8009cc2:	bf00      	nop
 8009cc4:	9b03      	ldr	r3, [sp, #12]
 8009cc6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009cc8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8009cca:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8009cce:	2b00      	cmp	r3, #0
 8009cd0:	d0f8      	beq.n	8009cc4 <sdc_lld_send_cmd_none+0x24>
    ;
  sdcp->sdmmc->ICR = SDMMC_ICR_CMDSENTC;
 8009cd2:	9b03      	ldr	r3, [sp, #12]
 8009cd4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009cd6:	2280      	movs	r2, #128	; 0x80
 8009cd8:	639a      	str	r2, [r3, #56]	; 0x38
}
 8009cda:	b004      	add	sp, #16
 8009cdc:	4770      	bx	lr
 8009cde:	bf00      	nop

08009ce0 <sdc_lld_send_cmd_short>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_send_cmd_short(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                            uint32_t *resp) {
 8009ce0:	b500      	push	{lr}
 8009ce2:	b087      	sub	sp, #28
 8009ce4:	9003      	str	r0, [sp, #12]
 8009ce6:	9201      	str	r2, [sp, #4]
 8009ce8:	9300      	str	r3, [sp, #0]
 8009cea:	460b      	mov	r3, r1
 8009cec:	f88d 300b 	strb.w	r3, [sp, #11]
  uint32_t sta;

  sdcp->sdmmc->ARG = arg;
 8009cf0:	9b03      	ldr	r3, [sp, #12]
 8009cf2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009cf4:	9a01      	ldr	r2, [sp, #4]
 8009cf6:	609a      	str	r2, [r3, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 8009cf8:	9b03      	ldr	r3, [sp, #12]
 8009cfa:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009cfc:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8009d00:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8009d04:	b2d2      	uxtb	r2, r2
 8009d06:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8009d0a:	60da      	str	r2, [r3, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8009d0c:	bf00      	nop
 8009d0e:	9b03      	ldr	r3, [sp, #12]
 8009d10:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009d12:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8009d14:	9305      	str	r3, [sp, #20]
 8009d16:	9b05      	ldr	r3, [sp, #20]
 8009d18:	f003 0345 	and.w	r3, r3, #69	; 0x45
 8009d1c:	2b00      	cmp	r3, #0
 8009d1e:	d0f6      	beq.n	8009d0e <sdc_lld_send_cmd_short+0x2e>
                                     SDMMC_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8009d20:	9b03      	ldr	r3, [sp, #12]
 8009d22:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009d24:	9a05      	ldr	r2, [sp, #20]
 8009d26:	f002 0245 	and.w	r2, r2, #69	; 0x45
 8009d2a:	639a      	str	r2, [r3, #56]	; 0x38
                           SDMMC_STA_CCRCFAIL);
  if ((sta & (SDMMC_STA_CTIMEOUT)) != 0) {
 8009d2c:	9b05      	ldr	r3, [sp, #20]
 8009d2e:	f003 0304 	and.w	r3, r3, #4
 8009d32:	2b00      	cmp	r3, #0
 8009d34:	d005      	beq.n	8009d42 <sdc_lld_send_cmd_short+0x62>
    sdc_lld_collect_errors(sdcp, sta);
 8009d36:	9803      	ldr	r0, [sp, #12]
 8009d38:	9905      	ldr	r1, [sp, #20]
 8009d3a:	f7ff fe19 	bl	8009970 <sdc_lld_collect_errors>
    return HAL_FAILED;
 8009d3e:	2301      	movs	r3, #1
 8009d40:	e005      	b.n	8009d4e <sdc_lld_send_cmd_short+0x6e>
  }
  *resp = sdcp->sdmmc->RESP1;
 8009d42:	9b03      	ldr	r3, [sp, #12]
 8009d44:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009d46:	695a      	ldr	r2, [r3, #20]
 8009d48:	9b00      	ldr	r3, [sp, #0]
 8009d4a:	601a      	str	r2, [r3, #0]
  return HAL_SUCCESS;
 8009d4c:	2300      	movs	r3, #0
}
 8009d4e:	4618      	mov	r0, r3
 8009d50:	b007      	add	sp, #28
 8009d52:	f85d fb04 	ldr.w	pc, [sp], #4
 8009d56:	bf00      	nop
 8009d58:	f3af 8000 	nop.w
 8009d5c:	f3af 8000 	nop.w

08009d60 <sdc_lld_send_cmd_short_crc>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_send_cmd_short_crc(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                                uint32_t *resp) {
 8009d60:	b500      	push	{lr}
 8009d62:	b087      	sub	sp, #28
 8009d64:	9003      	str	r0, [sp, #12]
 8009d66:	9201      	str	r2, [sp, #4]
 8009d68:	9300      	str	r3, [sp, #0]
 8009d6a:	460b      	mov	r3, r1
 8009d6c:	f88d 300b 	strb.w	r3, [sp, #11]
  uint32_t sta;

  sdcp->sdmmc->ARG = arg;
 8009d70:	9b03      	ldr	r3, [sp, #12]
 8009d72:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009d74:	9a01      	ldr	r2, [sp, #4]
 8009d76:	609a      	str	r2, [r3, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 8009d78:	9b03      	ldr	r3, [sp, #12]
 8009d7a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009d7c:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8009d80:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8009d84:	b2d2      	uxtb	r2, r2
 8009d86:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8009d8a:	60da      	str	r2, [r3, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8009d8c:	bf00      	nop
 8009d8e:	9b03      	ldr	r3, [sp, #12]
 8009d90:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009d92:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8009d94:	9305      	str	r3, [sp, #20]
 8009d96:	9b05      	ldr	r3, [sp, #20]
 8009d98:	f003 0345 	and.w	r3, r3, #69	; 0x45
 8009d9c:	2b00      	cmp	r3, #0
 8009d9e:	d0f6      	beq.n	8009d8e <sdc_lld_send_cmd_short_crc+0x2e>
                                     SDMMC_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL);
 8009da0:	9b03      	ldr	r3, [sp, #12]
 8009da2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009da4:	9a05      	ldr	r2, [sp, #20]
 8009da6:	f002 0245 	and.w	r2, r2, #69	; 0x45
 8009daa:	639a      	str	r2, [r3, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 8009dac:	9b05      	ldr	r3, [sp, #20]
 8009dae:	f003 0305 	and.w	r3, r3, #5
 8009db2:	2b00      	cmp	r3, #0
 8009db4:	d005      	beq.n	8009dc2 <sdc_lld_send_cmd_short_crc+0x62>
    sdc_lld_collect_errors(sdcp, sta);
 8009db6:	9803      	ldr	r0, [sp, #12]
 8009db8:	9905      	ldr	r1, [sp, #20]
 8009dba:	f7ff fdd9 	bl	8009970 <sdc_lld_collect_errors>
    return HAL_FAILED;
 8009dbe:	2301      	movs	r3, #1
 8009dc0:	e005      	b.n	8009dce <sdc_lld_send_cmd_short_crc+0x6e>
  }
  *resp = sdcp->sdmmc->RESP1;
 8009dc2:	9b03      	ldr	r3, [sp, #12]
 8009dc4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009dc6:	695a      	ldr	r2, [r3, #20]
 8009dc8:	9b00      	ldr	r3, [sp, #0]
 8009dca:	601a      	str	r2, [r3, #0]
  return HAL_SUCCESS;
 8009dcc:	2300      	movs	r3, #0
}
 8009dce:	4618      	mov	r0, r3
 8009dd0:	b007      	add	sp, #28
 8009dd2:	f85d fb04 	ldr.w	pc, [sp], #4
 8009dd6:	bf00      	nop
 8009dd8:	f3af 8000 	nop.w
 8009ddc:	f3af 8000 	nop.w

08009de0 <sdc_lld_send_cmd_long_crc>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_send_cmd_long_crc(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                               uint32_t *resp) {
 8009de0:	b500      	push	{lr}
 8009de2:	b087      	sub	sp, #28
 8009de4:	9003      	str	r0, [sp, #12]
 8009de6:	9201      	str	r2, [sp, #4]
 8009de8:	9300      	str	r3, [sp, #0]
 8009dea:	460b      	mov	r3, r1
 8009dec:	f88d 300b 	strb.w	r3, [sp, #11]
  uint32_t sta;

  (void)sdcp;

  sdcp->sdmmc->ARG = arg;
 8009df0:	9b03      	ldr	r3, [sp, #12]
 8009df2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009df4:	9a01      	ldr	r2, [sp, #4]
 8009df6:	609a      	str	r2, [r3, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_WAITRESP_1 |
 8009df8:	9b03      	ldr	r3, [sp, #12]
 8009dfa:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009dfc:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8009e00:	f062 023f 	orn	r2, r2, #63	; 0x3f
 8009e04:	b2d2      	uxtb	r2, r2
 8009e06:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8009e0a:	60da      	str	r2, [r3, #12]
                                    SDMMC_CMD_CPSMEN;
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8009e0c:	bf00      	nop
 8009e0e:	9b03      	ldr	r3, [sp, #12]
 8009e10:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009e12:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8009e14:	9305      	str	r3, [sp, #20]
 8009e16:	9b05      	ldr	r3, [sp, #20]
 8009e18:	f003 0345 	and.w	r3, r3, #69	; 0x45
 8009e1c:	2b00      	cmp	r3, #0
 8009e1e:	d0f6      	beq.n	8009e0e <sdc_lld_send_cmd_long_crc+0x2e>
                                     SDMMC_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8009e20:	9b03      	ldr	r3, [sp, #12]
 8009e22:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009e24:	9a05      	ldr	r2, [sp, #20]
 8009e26:	f002 0245 	and.w	r2, r2, #69	; 0x45
 8009e2a:	639a      	str	r2, [r3, #56]	; 0x38
                           SDMMC_STA_CCRCFAIL);
  if ((sta & (SDMMC_STA_ERROR_MASK)) != 0) {
 8009e2c:	9b05      	ldr	r3, [sp, #20]
 8009e2e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8009e32:	2b00      	cmp	r3, #0
 8009e34:	d005      	beq.n	8009e42 <sdc_lld_send_cmd_long_crc+0x62>
    sdc_lld_collect_errors(sdcp, sta);
 8009e36:	9803      	ldr	r0, [sp, #12]
 8009e38:	9905      	ldr	r1, [sp, #20]
 8009e3a:	f7ff fd99 	bl	8009970 <sdc_lld_collect_errors>
    return HAL_FAILED;
 8009e3e:	2301      	movs	r3, #1
 8009e40:	e01a      	b.n	8009e78 <sdc_lld_send_cmd_long_crc+0x98>
  }
  /* Save bytes in reverse order because MSB in response comes first.*/
  *resp++ = sdcp->sdmmc->RESP4;
 8009e42:	9b00      	ldr	r3, [sp, #0]
 8009e44:	1d1a      	adds	r2, r3, #4
 8009e46:	9200      	str	r2, [sp, #0]
 8009e48:	9a03      	ldr	r2, [sp, #12]
 8009e4a:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8009e4c:	6a12      	ldr	r2, [r2, #32]
 8009e4e:	601a      	str	r2, [r3, #0]
  *resp++ = sdcp->sdmmc->RESP3;
 8009e50:	9b00      	ldr	r3, [sp, #0]
 8009e52:	1d1a      	adds	r2, r3, #4
 8009e54:	9200      	str	r2, [sp, #0]
 8009e56:	9a03      	ldr	r2, [sp, #12]
 8009e58:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8009e5a:	69d2      	ldr	r2, [r2, #28]
 8009e5c:	601a      	str	r2, [r3, #0]
  *resp++ = sdcp->sdmmc->RESP2;
 8009e5e:	9b00      	ldr	r3, [sp, #0]
 8009e60:	1d1a      	adds	r2, r3, #4
 8009e62:	9200      	str	r2, [sp, #0]
 8009e64:	9a03      	ldr	r2, [sp, #12]
 8009e66:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8009e68:	6992      	ldr	r2, [r2, #24]
 8009e6a:	601a      	str	r2, [r3, #0]
  *resp   = sdcp->sdmmc->RESP1;
 8009e6c:	9b03      	ldr	r3, [sp, #12]
 8009e6e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009e70:	695a      	ldr	r2, [r3, #20]
 8009e72:	9b00      	ldr	r3, [sp, #0]
 8009e74:	601a      	str	r2, [r3, #0]
  return HAL_SUCCESS;
 8009e76:	2300      	movs	r3, #0
}
 8009e78:	4618      	mov	r0, r3
 8009e7a:	b007      	add	sp, #28
 8009e7c:	f85d fb04 	ldr.w	pc, [sp], #4

08009e80 <sdc_lld_read_special>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_read_special(SDCDriver *sdcp, uint8_t *buf, size_t bytes,
                          uint8_t cmd, uint32_t arg) {
 8009e80:	b500      	push	{lr}
 8009e82:	b087      	sub	sp, #28
 8009e84:	9003      	str	r0, [sp, #12]
 8009e86:	9102      	str	r1, [sp, #8]
 8009e88:	9201      	str	r2, [sp, #4]
 8009e8a:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t resp[1];

  if(sdc_lld_prepare_read_bytes(sdcp, buf, bytes))
 8009e8e:	9803      	ldr	r0, [sp, #12]
 8009e90:	9902      	ldr	r1, [sp, #8]
 8009e92:	9a01      	ldr	r2, [sp, #4]
 8009e94:	f7ff fc2c 	bl	80096f0 <sdc_lld_prepare_read_bytes>
 8009e98:	4603      	mov	r3, r0
 8009e9a:	2b00      	cmp	r3, #0
 8009e9c:	d000      	beq.n	8009ea0 <sdc_lld_read_special+0x20>
    goto error;
 8009e9e:	e01b      	b.n	8009ed8 <sdc_lld_read_special+0x58>

  if (sdc_lld_send_cmd_short_crc(sdcp, cmd, arg, resp)
 8009ea0:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8009ea4:	ab05      	add	r3, sp, #20
 8009ea6:	9803      	ldr	r0, [sp, #12]
 8009ea8:	4611      	mov	r1, r2
 8009eaa:	9a08      	ldr	r2, [sp, #32]
 8009eac:	f7ff ff58 	bl	8009d60 <sdc_lld_send_cmd_short_crc>
 8009eb0:	4603      	mov	r3, r0
 8009eb2:	2b00      	cmp	r3, #0
 8009eb4:	d110      	bne.n	8009ed8 <sdc_lld_read_special+0x58>
                                 || MMCSD_R1_ERROR(resp[0]))
 8009eb6:	9a05      	ldr	r2, [sp, #20]
 8009eb8:	4b0d      	ldr	r3, [pc, #52]	; (8009ef0 <sdc_lld_read_special+0x70>)
 8009eba:	4013      	ands	r3, r2
 8009ebc:	2b00      	cmp	r3, #0
 8009ebe:	d10b      	bne.n	8009ed8 <sdc_lld_read_special+0x58>
    goto error;

  if (sdc_lld_wait_transaction_end(sdcp, 1, resp))
 8009ec0:	ab05      	add	r3, sp, #20
 8009ec2:	9803      	ldr	r0, [sp, #12]
 8009ec4:	2101      	movs	r1, #1
 8009ec6:	461a      	mov	r2, r3
 8009ec8:	f7ff fcfa 	bl	80098c0 <sdc_lld_wait_transaction_end>
 8009ecc:	4603      	mov	r3, r0
 8009ece:	2b00      	cmp	r3, #0
 8009ed0:	d000      	beq.n	8009ed4 <sdc_lld_read_special+0x54>
    goto error;
 8009ed2:	e001      	b.n	8009ed8 <sdc_lld_read_special+0x58>

  return HAL_SUCCESS;
 8009ed4:	2300      	movs	r3, #0
 8009ed6:	e006      	b.n	8009ee6 <sdc_lld_read_special+0x66>

error:
  sdc_lld_error_cleanup(sdcp, 1, resp);
 8009ed8:	ab05      	add	r3, sp, #20
 8009eda:	9803      	ldr	r0, [sp, #12]
 8009edc:	2101      	movs	r1, #1
 8009ede:	461a      	mov	r2, r3
 8009ee0:	f7ff fd8e 	bl	8009a00 <sdc_lld_error_cleanup>
  return HAL_FAILED;
 8009ee4:	2301      	movs	r3, #1
}
 8009ee6:	4618      	mov	r0, r3
 8009ee8:	b007      	add	sp, #28
 8009eea:	f85d fb04 	ldr.w	pc, [sp], #4
 8009eee:	bf00      	nop
 8009ef0:	fdffe008 	.word	0xfdffe008
 8009ef4:	f3af 8000 	nop.w
 8009ef8:	f3af 8000 	nop.w
 8009efc:	f3af 8000 	nop.w

08009f00 <sdc_lld_read_aligned>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_read_aligned(SDCDriver *sdcp, uint32_t startblk,
                          uint8_t *buf, uint32_t blocks) {
 8009f00:	b500      	push	{lr}
 8009f02:	b087      	sub	sp, #28
 8009f04:	9003      	str	r0, [sp, #12]
 8009f06:	9102      	str	r1, [sp, #8]
 8009f08:	9201      	str	r2, [sp, #4]
 8009f0a:	9300      	str	r3, [sp, #0]
  uint32_t resp[1];

  osalDbgCheck(blocks < 0x1000000 / MMCSD_BLOCK_SIZE);

  sdcp->sdmmc->DTIMER = SDMMC_READ_TIMEOUT;
 8009f0c:	9b03      	ldr	r3, [sp, #12]
 8009f0e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009f10:	4a3b      	ldr	r2, [pc, #236]	; (800a000 <sdc_lld_read_aligned+0x100>)
 8009f12:	625a      	str	r2, [r3, #36]	; 0x24

  /* Checks for errors and waits for the card to be ready for reading.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 8009f14:	9803      	ldr	r0, [sp, #12]
 8009f16:	f7fb fba3 	bl	8005660 <_sdc_wait_for_transfer_state>
 8009f1a:	4603      	mov	r3, r0
 8009f1c:	2b00      	cmp	r3, #0
 8009f1e:	d001      	beq.n	8009f24 <sdc_lld_read_aligned+0x24>
    return HAL_FAILED;
 8009f20:	2301      	movs	r3, #1
 8009f22:	e069      	b.n	8009ff8 <sdc_lld_read_aligned+0xf8>

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 8009f24:	9b03      	ldr	r3, [sp, #12]
 8009f26:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009f28:	685b      	ldr	r3, [r3, #4]
 8009f2a:	9a01      	ldr	r2, [sp, #4]
 8009f2c:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(sdcp->dma,
 8009f2e:	9b03      	ldr	r3, [sp, #12]
 8009f30:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009f32:	685b      	ldr	r3, [r3, #4]
 8009f34:	9a00      	ldr	r2, [sp, #0]
 8009f36:	0252      	lsls	r2, r2, #9
 8009f38:	0892      	lsrs	r2, r2, #2
 8009f3a:	605a      	str	r2, [r3, #4]
                              (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
 8009f3c:	9b03      	ldr	r3, [sp, #12]
 8009f3e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009f40:	68db      	ldr	r3, [r3, #12]
 8009f42:	681b      	ldr	r3, [r3, #0]
 8009f44:	9305      	str	r3, [sp, #20]
 8009f46:	9b03      	ldr	r3, [sp, #12]
 8009f48:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009f4a:	7c1b      	ldrb	r3, [r3, #16]
 8009f4c:	220f      	movs	r2, #15
 8009f4e:	fa02 f303 	lsl.w	r3, r2, r3
 8009f52:	43db      	mvns	r3, r3
 8009f54:	9a05      	ldr	r2, [sp, #20]
 8009f56:	4013      	ands	r3, r2
 8009f58:	9305      	str	r3, [sp, #20]
 8009f5a:	9b03      	ldr	r3, [sp, #12]
 8009f5c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009f5e:	0c1a      	lsrs	r2, r3, #16
 8009f60:	9b03      	ldr	r3, [sp, #12]
 8009f62:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009f64:	7c1b      	ldrb	r3, [r3, #16]
 8009f66:	fa02 f303 	lsl.w	r3, r2, r3
 8009f6a:	9a05      	ldr	r2, [sp, #20]
 8009f6c:	4313      	orrs	r3, r2
 8009f6e:	9305      	str	r3, [sp, #20]
 8009f70:	9b03      	ldr	r3, [sp, #12]
 8009f72:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009f74:	68db      	ldr	r3, [r3, #12]
 8009f76:	9a05      	ldr	r2, [sp, #20]
 8009f78:	601a      	str	r2, [r3, #0]
 8009f7a:	9b03      	ldr	r3, [sp, #12]
 8009f7c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009f7e:	685b      	ldr	r3, [r3, #4]
 8009f80:	9a03      	ldr	r2, [sp, #12]
 8009f82:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8009f84:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(sdcp->dma);
 8009f86:	9b03      	ldr	r3, [sp, #12]
 8009f88:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009f8a:	685b      	ldr	r3, [r3, #4]
 8009f8c:	9a03      	ldr	r2, [sp, #12]
 8009f8e:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8009f90:	6852      	ldr	r2, [r2, #4]
 8009f92:	6812      	ldr	r2, [r2, #0]
 8009f94:	f042 0201 	orr.w	r2, r2, #1
 8009f98:	601a      	str	r2, [r3, #0]

  /* Setting up data transfer.*/
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 8009f9a:	9b03      	ldr	r3, [sp, #12]
 8009f9c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009f9e:	4a19      	ldr	r2, [pc, #100]	; (800a004 <sdc_lld_read_aligned+0x104>)
 8009fa0:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdmmc->MASK  = SDMMC_MASK_DCRCFAILIE |
 8009fa2:	9b03      	ldr	r3, [sp, #12]
 8009fa4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009fa6:	f44f 7295 	mov.w	r2, #298	; 0x12a
 8009faa:	63da      	str	r2, [r3, #60]	; 0x3c
                       SDMMC_MASK_DTIMEOUTIE |
                       SDMMC_MASK_RXOVERRIE |
                       SDMMC_MASK_DATAENDIE;
  sdcp->sdmmc->DLEN  = blocks * MMCSD_BLOCK_SIZE;
 8009fac:	9b03      	ldr	r3, [sp, #12]
 8009fae:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009fb0:	9a00      	ldr	r2, [sp, #0]
 8009fb2:	0252      	lsls	r2, r2, #9
 8009fb4:	629a      	str	r2, [r3, #40]	; 0x28

  /* Transaction starts just after DTEN bit setting.*/
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DTDIR |
 8009fb6:	9b03      	ldr	r3, [sp, #12]
 8009fb8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009fba:	229b      	movs	r2, #155	; 0x9b
 8009fbc:	62da      	str	r2, [r3, #44]	; 0x2c
                       SDMMC_DCTRL_DBLOCKSIZE_3 |
                       SDMMC_DCTRL_DBLOCKSIZE_0 |
                       SDMMC_DCTRL_DMAEN |
                       SDMMC_DCTRL_DTEN;

  if (sdc_lld_prepare_read(sdcp, startblk, blocks, resp) == TRUE)
 8009fbe:	ab04      	add	r3, sp, #16
 8009fc0:	9803      	ldr	r0, [sp, #12]
 8009fc2:	9902      	ldr	r1, [sp, #8]
 8009fc4:	9a00      	ldr	r2, [sp, #0]
 8009fc6:	f7ff fbfb 	bl	80097c0 <sdc_lld_prepare_read>
 8009fca:	4603      	mov	r3, r0
 8009fcc:	2b00      	cmp	r3, #0
 8009fce:	d000      	beq.n	8009fd2 <sdc_lld_read_aligned+0xd2>
    goto error;
 8009fd0:	e00b      	b.n	8009fea <sdc_lld_read_aligned+0xea>

  if (sdc_lld_wait_transaction_end(sdcp, blocks, resp) == TRUE)
 8009fd2:	ab04      	add	r3, sp, #16
 8009fd4:	9803      	ldr	r0, [sp, #12]
 8009fd6:	9900      	ldr	r1, [sp, #0]
 8009fd8:	461a      	mov	r2, r3
 8009fda:	f7ff fc71 	bl	80098c0 <sdc_lld_wait_transaction_end>
 8009fde:	4603      	mov	r3, r0
 8009fe0:	2b00      	cmp	r3, #0
 8009fe2:	d000      	beq.n	8009fe6 <sdc_lld_read_aligned+0xe6>
    goto error;
 8009fe4:	e001      	b.n	8009fea <sdc_lld_read_aligned+0xea>

  return HAL_SUCCESS;
 8009fe6:	2300      	movs	r3, #0
 8009fe8:	e006      	b.n	8009ff8 <sdc_lld_read_aligned+0xf8>

error:
  sdc_lld_error_cleanup(sdcp, blocks, resp);
 8009fea:	ab04      	add	r3, sp, #16
 8009fec:	9803      	ldr	r0, [sp, #12]
 8009fee:	9900      	ldr	r1, [sp, #0]
 8009ff0:	461a      	mov	r2, r3
 8009ff2:	f7ff fd05 	bl	8009a00 <sdc_lld_error_cleanup>
  return HAL_FAILED;
 8009ff6:	2301      	movs	r3, #1
}
 8009ff8:	4618      	mov	r0, r3
 8009ffa:	b007      	add	sp, #28
 8009ffc:	f85d fb04 	ldr.w	pc, [sp], #4
 800a000:	000927c0 	.word	0x000927c0
 800a004:	004005ff 	.word	0x004005ff
 800a008:	f3af 8000 	nop.w
 800a00c:	f3af 8000 	nop.w

0800a010 <sdc_lld_write_aligned>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_write_aligned(SDCDriver *sdcp, uint32_t startblk,
                           const uint8_t *buf, uint32_t blocks) {
 800a010:	b500      	push	{lr}
 800a012:	b087      	sub	sp, #28
 800a014:	9003      	str	r0, [sp, #12]
 800a016:	9102      	str	r1, [sp, #8]
 800a018:	9201      	str	r2, [sp, #4]
 800a01a:	9300      	str	r3, [sp, #0]
  uint32_t resp[1];

  osalDbgCheck(blocks < 0x1000000 / MMCSD_BLOCK_SIZE);

  sdcp->sdmmc->DTIMER = SDMMC_WRITE_TIMEOUT;
 800a01c:	9b03      	ldr	r3, [sp, #12]
 800a01e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a020:	4a3d      	ldr	r2, [pc, #244]	; (800a118 <sdc_lld_write_aligned+0x108>)
 800a022:	625a      	str	r2, [r3, #36]	; 0x24

  /* Checks for errors and waits for the card to be ready for writing.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 800a024:	9803      	ldr	r0, [sp, #12]
 800a026:	f7fb fb1b 	bl	8005660 <_sdc_wait_for_transfer_state>
 800a02a:	4603      	mov	r3, r0
 800a02c:	2b00      	cmp	r3, #0
 800a02e:	d001      	beq.n	800a034 <sdc_lld_write_aligned+0x24>
    return HAL_FAILED;
 800a030:	2301      	movs	r3, #1
 800a032:	e06d      	b.n	800a110 <sdc_lld_write_aligned+0x100>

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 800a034:	9b03      	ldr	r3, [sp, #12]
 800a036:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a038:	685b      	ldr	r3, [r3, #4]
 800a03a:	9a01      	ldr	r2, [sp, #4]
 800a03c:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(sdcp->dma,
 800a03e:	9b03      	ldr	r3, [sp, #12]
 800a040:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a042:	685b      	ldr	r3, [r3, #4]
 800a044:	9a00      	ldr	r2, [sp, #0]
 800a046:	0252      	lsls	r2, r2, #9
 800a048:	0892      	lsrs	r2, r2, #2
 800a04a:	605a      	str	r2, [r3, #4]
                             (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_M2P);
 800a04c:	9b03      	ldr	r3, [sp, #12]
 800a04e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a050:	68db      	ldr	r3, [r3, #12]
 800a052:	681b      	ldr	r3, [r3, #0]
 800a054:	9305      	str	r3, [sp, #20]
 800a056:	9b03      	ldr	r3, [sp, #12]
 800a058:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a05a:	7c1b      	ldrb	r3, [r3, #16]
 800a05c:	220f      	movs	r2, #15
 800a05e:	fa02 f303 	lsl.w	r3, r2, r3
 800a062:	43db      	mvns	r3, r3
 800a064:	9a05      	ldr	r2, [sp, #20]
 800a066:	4013      	ands	r3, r2
 800a068:	9305      	str	r3, [sp, #20]
 800a06a:	9b03      	ldr	r3, [sp, #12]
 800a06c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800a06e:	f043 0310 	orr.w	r3, r3, #16
 800a072:	0c1a      	lsrs	r2, r3, #16
 800a074:	9b03      	ldr	r3, [sp, #12]
 800a076:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a078:	7c1b      	ldrb	r3, [r3, #16]
 800a07a:	fa02 f303 	lsl.w	r3, r2, r3
 800a07e:	9a05      	ldr	r2, [sp, #20]
 800a080:	4313      	orrs	r3, r2
 800a082:	9305      	str	r3, [sp, #20]
 800a084:	9b03      	ldr	r3, [sp, #12]
 800a086:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a088:	68db      	ldr	r3, [r3, #12]
 800a08a:	9a05      	ldr	r2, [sp, #20]
 800a08c:	601a      	str	r2, [r3, #0]
 800a08e:	9b03      	ldr	r3, [sp, #12]
 800a090:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a092:	685b      	ldr	r3, [r3, #4]
 800a094:	9a03      	ldr	r2, [sp, #12]
 800a096:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800a098:	f042 0210 	orr.w	r2, r2, #16
 800a09c:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(sdcp->dma);
 800a09e:	9b03      	ldr	r3, [sp, #12]
 800a0a0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a0a2:	685b      	ldr	r3, [r3, #4]
 800a0a4:	9a03      	ldr	r2, [sp, #12]
 800a0a6:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800a0a8:	6852      	ldr	r2, [r2, #4]
 800a0aa:	6812      	ldr	r2, [r2, #0]
 800a0ac:	f042 0201 	orr.w	r2, r2, #1
 800a0b0:	601a      	str	r2, [r3, #0]

  /* Setting up data transfer.*/
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 800a0b2:	9b03      	ldr	r3, [sp, #12]
 800a0b4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a0b6:	4a19      	ldr	r2, [pc, #100]	; (800a11c <sdc_lld_write_aligned+0x10c>)
 800a0b8:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdmmc->MASK  = SDMMC_MASK_DCRCFAILIE |
 800a0ba:	9b03      	ldr	r3, [sp, #12]
 800a0bc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a0be:	f44f 728d 	mov.w	r2, #282	; 0x11a
 800a0c2:	63da      	str	r2, [r3, #60]	; 0x3c
                       SDMMC_MASK_DTIMEOUTIE |
                       SDMMC_MASK_TXUNDERRIE |
                       SDMMC_MASK_DATAENDIE;
  sdcp->sdmmc->DLEN  = blocks * MMCSD_BLOCK_SIZE;
 800a0c4:	9b03      	ldr	r3, [sp, #12]
 800a0c6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a0c8:	9a00      	ldr	r2, [sp, #0]
 800a0ca:	0252      	lsls	r2, r2, #9
 800a0cc:	629a      	str	r2, [r3, #40]	; 0x28

  /* Talk to card what we want from it.*/
  if (sdc_lld_prepare_write(sdcp, startblk, blocks, resp) == TRUE)
 800a0ce:	ab04      	add	r3, sp, #16
 800a0d0:	9803      	ldr	r0, [sp, #12]
 800a0d2:	9902      	ldr	r1, [sp, #8]
 800a0d4:	9a00      	ldr	r2, [sp, #0]
 800a0d6:	f7ff fbb3 	bl	8009840 <sdc_lld_prepare_write>
 800a0da:	4603      	mov	r3, r0
 800a0dc:	2b00      	cmp	r3, #0
 800a0de:	d000      	beq.n	800a0e2 <sdc_lld_write_aligned+0xd2>
    goto error;
 800a0e0:	e00f      	b.n	800a102 <sdc_lld_write_aligned+0xf2>

  /* Transaction starts just after DTEN bit setting.*/
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DBLOCKSIZE_3 |
 800a0e2:	9b03      	ldr	r3, [sp, #12]
 800a0e4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a0e6:	2299      	movs	r2, #153	; 0x99
 800a0e8:	62da      	str	r2, [r3, #44]	; 0x2c
                       SDMMC_DCTRL_DBLOCKSIZE_0 |
                       SDMMC_DCTRL_DMAEN |
                       SDMMC_DCTRL_DTEN;

  if (sdc_lld_wait_transaction_end(sdcp, blocks, resp) == TRUE)
 800a0ea:	ab04      	add	r3, sp, #16
 800a0ec:	9803      	ldr	r0, [sp, #12]
 800a0ee:	9900      	ldr	r1, [sp, #0]
 800a0f0:	461a      	mov	r2, r3
 800a0f2:	f7ff fbe5 	bl	80098c0 <sdc_lld_wait_transaction_end>
 800a0f6:	4603      	mov	r3, r0
 800a0f8:	2b00      	cmp	r3, #0
 800a0fa:	d000      	beq.n	800a0fe <sdc_lld_write_aligned+0xee>
    goto error;
 800a0fc:	e001      	b.n	800a102 <sdc_lld_write_aligned+0xf2>

  return HAL_SUCCESS;
 800a0fe:	2300      	movs	r3, #0
 800a100:	e006      	b.n	800a110 <sdc_lld_write_aligned+0x100>

error:
  sdc_lld_error_cleanup(sdcp, blocks, resp);
 800a102:	ab04      	add	r3, sp, #16
 800a104:	9803      	ldr	r0, [sp, #12]
 800a106:	9900      	ldr	r1, [sp, #0]
 800a108:	461a      	mov	r2, r3
 800a10a:	f7ff fc79 	bl	8009a00 <sdc_lld_error_cleanup>
  return HAL_FAILED;
 800a10e:	2301      	movs	r3, #1
}
 800a110:	4618      	mov	r0, r3
 800a112:	b007      	add	sp, #28
 800a114:	f85d fb04 	ldr.w	pc, [sp], #4
 800a118:	005b8d80 	.word	0x005b8d80
 800a11c:	004005ff 	.word	0x004005ff

0800a120 <sdc_lld_read>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_read(SDCDriver *sdcp, uint32_t startblk,
                  uint8_t *buf, uint32_t blocks) {
 800a120:	b500      	push	{lr}
 800a122:	b087      	sub	sp, #28
 800a124:	9003      	str	r0, [sp, #12]
 800a126:	9102      	str	r1, [sp, #8]
 800a128:	9201      	str	r2, [sp, #4]
 800a12a:	9300      	str	r3, [sp, #0]

#if STM32_SDC_SDMMC_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
 800a12c:	9b01      	ldr	r3, [sp, #4]
 800a12e:	f003 0303 	and.w	r3, r3, #3
 800a132:	2b00      	cmp	r3, #0
 800a134:	d028      	beq.n	800a188 <sdc_lld_read+0x68>
    uint32_t i;
    for (i = 0; i < blocks; i++) {
 800a136:	2300      	movs	r3, #0
 800a138:	9305      	str	r3, [sp, #20]
 800a13a:	e01f      	b.n	800a17c <sdc_lld_read+0x5c>
      if (sdc_lld_read_aligned(sdcp, startblk, u.buf, 1))
 800a13c:	9803      	ldr	r0, [sp, #12]
 800a13e:	9902      	ldr	r1, [sp, #8]
 800a140:	4a17      	ldr	r2, [pc, #92]	; (800a1a0 <sdc_lld_read+0x80>)
 800a142:	2301      	movs	r3, #1
 800a144:	f7ff fedc 	bl	8009f00 <sdc_lld_read_aligned>
 800a148:	4603      	mov	r3, r0
 800a14a:	2b00      	cmp	r3, #0
 800a14c:	d001      	beq.n	800a152 <sdc_lld_read+0x32>
        return HAL_FAILED;
 800a14e:	2301      	movs	r3, #1
 800a150:	e021      	b.n	800a196 <sdc_lld_read+0x76>
      memcpy(buf, u.buf, MMCSD_BLOCK_SIZE);
 800a152:	9a01      	ldr	r2, [sp, #4]
 800a154:	4b12      	ldr	r3, [pc, #72]	; (800a1a0 <sdc_lld_read+0x80>)
 800a156:	4611      	mov	r1, r2
 800a158:	461a      	mov	r2, r3
 800a15a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a15e:	4608      	mov	r0, r1
 800a160:	4611      	mov	r1, r2
 800a162:	461a      	mov	r2, r3
 800a164:	f00b fc4c 	bl	8015a00 <memcpy>
      buf += MMCSD_BLOCK_SIZE;
 800a168:	9b01      	ldr	r3, [sp, #4]
 800a16a:	f503 7300 	add.w	r3, r3, #512	; 0x200
 800a16e:	9301      	str	r3, [sp, #4]
      startblk++;
 800a170:	9b02      	ldr	r3, [sp, #8]
 800a172:	3301      	adds	r3, #1
 800a174:	9302      	str	r3, [sp, #8]
                  uint8_t *buf, uint32_t blocks) {

#if STM32_SDC_SDMMC_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
    uint32_t i;
    for (i = 0; i < blocks; i++) {
 800a176:	9b05      	ldr	r3, [sp, #20]
 800a178:	3301      	adds	r3, #1
 800a17a:	9305      	str	r3, [sp, #20]
 800a17c:	9a05      	ldr	r2, [sp, #20]
 800a17e:	9b00      	ldr	r3, [sp, #0]
 800a180:	429a      	cmp	r2, r3
 800a182:	d3db      	bcc.n	800a13c <sdc_lld_read+0x1c>
        return HAL_FAILED;
      memcpy(buf, u.buf, MMCSD_BLOCK_SIZE);
      buf += MMCSD_BLOCK_SIZE;
      startblk++;
    }
    return HAL_SUCCESS;
 800a184:	2300      	movs	r3, #0
 800a186:	e006      	b.n	800a196 <sdc_lld_read+0x76>
  }
#endif /* STM32_SDC_SDMMC_UNALIGNED_SUPPORT */
  return sdc_lld_read_aligned(sdcp, startblk, buf, blocks);
 800a188:	9803      	ldr	r0, [sp, #12]
 800a18a:	9902      	ldr	r1, [sp, #8]
 800a18c:	9a01      	ldr	r2, [sp, #4]
 800a18e:	9b00      	ldr	r3, [sp, #0]
 800a190:	f7ff feb6 	bl	8009f00 <sdc_lld_read_aligned>
 800a194:	4603      	mov	r3, r0
}
 800a196:	4618      	mov	r0, r3
 800a198:	b007      	add	sp, #28
 800a19a:	f85d fb04 	ldr.w	pc, [sp], #4
 800a19e:	bf00      	nop
 800a1a0:	20000944 	.word	0x20000944
 800a1a4:	f3af 8000 	nop.w
 800a1a8:	f3af 8000 	nop.w
 800a1ac:	f3af 8000 	nop.w

0800a1b0 <sdc_lld_write>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_write(SDCDriver *sdcp, uint32_t startblk,
                   const uint8_t *buf, uint32_t blocks) {
 800a1b0:	b500      	push	{lr}
 800a1b2:	b087      	sub	sp, #28
 800a1b4:	9003      	str	r0, [sp, #12]
 800a1b6:	9102      	str	r1, [sp, #8]
 800a1b8:	9201      	str	r2, [sp, #4]
 800a1ba:	9300      	str	r3, [sp, #0]

#if STM32_SDC_SDMMC_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
 800a1bc:	9b01      	ldr	r3, [sp, #4]
 800a1be:	f003 0303 	and.w	r3, r3, #3
 800a1c2:	2b00      	cmp	r3, #0
 800a1c4:	d028      	beq.n	800a218 <sdc_lld_write+0x68>
    uint32_t i;
    for (i = 0; i < blocks; i++) {
 800a1c6:	2300      	movs	r3, #0
 800a1c8:	9305      	str	r3, [sp, #20]
 800a1ca:	e01f      	b.n	800a20c <sdc_lld_write+0x5c>
      memcpy(u.buf, buf, MMCSD_BLOCK_SIZE);
 800a1cc:	4a18      	ldr	r2, [pc, #96]	; (800a230 <sdc_lld_write+0x80>)
 800a1ce:	9b01      	ldr	r3, [sp, #4]
 800a1d0:	4611      	mov	r1, r2
 800a1d2:	461a      	mov	r2, r3
 800a1d4:	f44f 7300 	mov.w	r3, #512	; 0x200
 800a1d8:	4608      	mov	r0, r1
 800a1da:	4611      	mov	r1, r2
 800a1dc:	461a      	mov	r2, r3
 800a1de:	f00b fc0f 	bl	8015a00 <memcpy>
      buf += MMCSD_BLOCK_SIZE;
 800a1e2:	9b01      	ldr	r3, [sp, #4]
 800a1e4:	f503 7300 	add.w	r3, r3, #512	; 0x200
 800a1e8:	9301      	str	r3, [sp, #4]
      if (sdc_lld_write_aligned(sdcp, startblk, u.buf, 1))
 800a1ea:	9803      	ldr	r0, [sp, #12]
 800a1ec:	9902      	ldr	r1, [sp, #8]
 800a1ee:	4a10      	ldr	r2, [pc, #64]	; (800a230 <sdc_lld_write+0x80>)
 800a1f0:	2301      	movs	r3, #1
 800a1f2:	f7ff ff0d 	bl	800a010 <sdc_lld_write_aligned>
 800a1f6:	4603      	mov	r3, r0
 800a1f8:	2b00      	cmp	r3, #0
 800a1fa:	d001      	beq.n	800a200 <sdc_lld_write+0x50>
        return HAL_FAILED;
 800a1fc:	2301      	movs	r3, #1
 800a1fe:	e012      	b.n	800a226 <sdc_lld_write+0x76>
      startblk++;
 800a200:	9b02      	ldr	r3, [sp, #8]
 800a202:	3301      	adds	r3, #1
 800a204:	9302      	str	r3, [sp, #8]
                   const uint8_t *buf, uint32_t blocks) {

#if STM32_SDC_SDMMC_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
    uint32_t i;
    for (i = 0; i < blocks; i++) {
 800a206:	9b05      	ldr	r3, [sp, #20]
 800a208:	3301      	adds	r3, #1
 800a20a:	9305      	str	r3, [sp, #20]
 800a20c:	9a05      	ldr	r2, [sp, #20]
 800a20e:	9b00      	ldr	r3, [sp, #0]
 800a210:	429a      	cmp	r2, r3
 800a212:	d3db      	bcc.n	800a1cc <sdc_lld_write+0x1c>
      buf += MMCSD_BLOCK_SIZE;
      if (sdc_lld_write_aligned(sdcp, startblk, u.buf, 1))
        return HAL_FAILED;
      startblk++;
    }
    return HAL_SUCCESS;
 800a214:	2300      	movs	r3, #0
 800a216:	e006      	b.n	800a226 <sdc_lld_write+0x76>
  }
#endif /* STM32_SDC_SDMMC_UNALIGNED_SUPPORT */
  return sdc_lld_write_aligned(sdcp, startblk, buf, blocks);
 800a218:	9803      	ldr	r0, [sp, #12]
 800a21a:	9902      	ldr	r1, [sp, #8]
 800a21c:	9a01      	ldr	r2, [sp, #4]
 800a21e:	9b00      	ldr	r3, [sp, #0]
 800a220:	f7ff fef6 	bl	800a010 <sdc_lld_write_aligned>
 800a224:	4603      	mov	r3, r0
}
 800a226:	4618      	mov	r0, r3
 800a228:	b007      	add	sp, #28
 800a22a:	f85d fb04 	ldr.w	pc, [sp], #4
 800a22e:	bf00      	nop
 800a230:	20000944 	.word	0x20000944
 800a234:	f3af 8000 	nop.w
 800a238:	f3af 8000 	nop.w
 800a23c:	f3af 8000 	nop.w

0800a240 <sdc_lld_sync>:
 * @retval HAL_SUCCESS  the operation succeeded.
 * @retval HAL_FAILED   the operation failed.
 *
 * @api
 */
bool sdc_lld_sync(SDCDriver *sdcp) {
 800a240:	b082      	sub	sp, #8
 800a242:	9001      	str	r0, [sp, #4]

  /* TODO: Implement.*/
  (void)sdcp;
  return HAL_SUCCESS;
 800a244:	2300      	movs	r3, #0
}
 800a246:	4618      	mov	r0, r3
 800a248:	b002      	add	sp, #8
 800a24a:	4770      	bx	lr
 800a24c:	f3af 8000 	nop.w

0800a250 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800a250:	b082      	sub	sp, #8
 800a252:	2320      	movs	r3, #32
 800a254:	9301      	str	r3, [sp, #4]
 800a256:	9b01      	ldr	r3, [sp, #4]
 800a258:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a25c:	b002      	add	sp, #8
 800a25e:	4770      	bx	lr

0800a260 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800a260:	b082      	sub	sp, #8
 800a262:	2300      	movs	r3, #0
 800a264:	9301      	str	r3, [sp, #4]
 800a266:	9b01      	ldr	r3, [sp, #4]
 800a268:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a26c:	b002      	add	sp, #8
 800a26e:	4770      	bx	lr

0800a270 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800a270:	b508      	push	{r3, lr}

  port_lock();
 800a272:	f7ff ffed 	bl	800a250 <port_lock>
}
 800a276:	bd08      	pop	{r3, pc}
 800a278:	f3af 8000 	nop.w
 800a27c:	f3af 8000 	nop.w

0800a280 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800a280:	b508      	push	{r3, lr}

  port_unlock();
 800a282:	f7ff ffed 	bl	800a260 <port_unlock>
}
 800a286:	bd08      	pop	{r3, pc}
 800a288:	f3af 8000 	nop.w
 800a28c:	f3af 8000 	nop.w

0800a290 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800a290:	b508      	push	{r3, lr}

  port_lock();
 800a292:	f7ff ffdd 	bl	800a250 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800a296:	bd08      	pop	{r3, pc}
 800a298:	f3af 8000 	nop.w
 800a29c:	f3af 8000 	nop.w

0800a2a0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800a2a0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800a2a2:	f7ff ffdd 	bl	800a260 <port_unlock>
}
 800a2a6:	bd08      	pop	{r3, pc}
 800a2a8:	f3af 8000 	nop.w
 800a2ac:	f3af 8000 	nop.w

0800a2b0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 800a2b0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800a2b2:	f7ff ffdd 	bl	800a270 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 800a2b6:	bd08      	pop	{r3, pc}
 800a2b8:	f3af 8000 	nop.w
 800a2bc:	f3af 8000 	nop.w

0800a2c0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 800a2c0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 800a2c2:	f7ff ffdd 	bl	800a280 <port_unlock_from_isr>
}
 800a2c6:	bd08      	pop	{r3, pc}
 800a2c8:	f3af 8000 	nop.w
 800a2cc:	f3af 8000 	nop.w

0800a2d0 <osalSysHalt>:
 *
 * @param[in] reason    the halt message pointer
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {
 800a2d0:	b500      	push	{lr}
 800a2d2:	b083      	sub	sp, #12
 800a2d4:	9001      	str	r0, [sp, #4]

  chSysHalt(reason);
 800a2d6:	9801      	ldr	r0, [sp, #4]
 800a2d8:	f7f6 fa22 	bl	8000720 <chSysHalt>
}
 800a2dc:	b003      	add	sp, #12
 800a2de:	f85d fb04 	ldr.w	pc, [sp], #4
 800a2e2:	bf00      	nop
 800a2e4:	f3af 8000 	nop.w
 800a2e8:	f3af 8000 	nop.w
 800a2ec:	f3af 8000 	nop.w

0800a2f0 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 800a2f0:	b508      	push	{r3, lr}

  chSysLockFromISR();
 800a2f2:	f7ff ffdd 	bl	800a2b0 <chSysLockFromISR>
}
 800a2f6:	bd08      	pop	{r3, pc}
 800a2f8:	f3af 8000 	nop.w
 800a2fc:	f3af 8000 	nop.w

0800a300 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 800a300:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 800a302:	f7ff ffdd 	bl	800a2c0 <chSysUnlockFromISR>
}
 800a306:	bd08      	pop	{r3, pc}
 800a308:	f3af 8000 	nop.w
 800a30c:	f3af 8000 	nop.w

0800a310 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 800a310:	b500      	push	{lr}
 800a312:	b083      	sub	sp, #12
 800a314:	9001      	str	r0, [sp, #4]
 800a316:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
 800a318:	9801      	ldr	r0, [sp, #4]
 800a31a:	9900      	ldr	r1, [sp, #0]
 800a31c:	f7f7 f8d0 	bl	80014c0 <chThdResumeI>
}
 800a320:	b003      	add	sp, #12
 800a322:	f85d fb04 	ldr.w	pc, [sp], #4
 800a326:	bf00      	nop
 800a328:	f3af 8000 	nop.w
 800a32c:	f3af 8000 	nop.w

0800a330 <spi_lld_serve_rx_interrupt>:
 * @brief   Shared end-of-rx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {
 800a330:	b500      	push	{lr}
 800a332:	b083      	sub	sp, #12
 800a334:	9001      	str	r0, [sp, #4]
 800a336:	9100      	str	r1, [sp, #0]

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800a338:	9b00      	ldr	r3, [sp, #0]
 800a33a:	f003 0308 	and.w	r3, r3, #8
 800a33e:	2b00      	cmp	r3, #0
 800a340:	d002      	beq.n	800a348 <spi_lld_serve_rx_interrupt+0x18>
    STM32_SPI_DMA_ERROR_HOOK(spip);
 800a342:	4828      	ldr	r0, [pc, #160]	; (800a3e4 <spi_lld_serve_rx_interrupt+0xb4>)
 800a344:	f7ff ffc4 	bl	800a2d0 <osalSysHalt>
#else
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
 800a348:	9b01      	ldr	r3, [sp, #4]
 800a34a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a34c:	685b      	ldr	r3, [r3, #4]
 800a34e:	9a01      	ldr	r2, [sp, #4]
 800a350:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800a352:	6852      	ldr	r2, [r2, #4]
 800a354:	6812      	ldr	r2, [r2, #0]
 800a356:	f022 020f 	bic.w	r2, r2, #15
 800a35a:	601a      	str	r2, [r3, #0]
 800a35c:	9b01      	ldr	r3, [sp, #4]
 800a35e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a360:	681b      	ldr	r3, [r3, #0]
 800a362:	9a01      	ldr	r2, [sp, #4]
 800a364:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800a366:	7c12      	ldrb	r2, [r2, #16]
 800a368:	210f      	movs	r1, #15
 800a36a:	fa01 f202 	lsl.w	r2, r1, r2
 800a36e:	605a      	str	r2, [r3, #4]
  dmaStreamDisable(spip->dmarx);
 800a370:	9b01      	ldr	r3, [sp, #4]
 800a372:	6a1b      	ldr	r3, [r3, #32]
 800a374:	685b      	ldr	r3, [r3, #4]
 800a376:	9a01      	ldr	r2, [sp, #4]
 800a378:	6a12      	ldr	r2, [r2, #32]
 800a37a:	6852      	ldr	r2, [r2, #4]
 800a37c:	6812      	ldr	r2, [r2, #0]
 800a37e:	f022 020f 	bic.w	r2, r2, #15
 800a382:	601a      	str	r2, [r3, #0]
 800a384:	9b01      	ldr	r3, [sp, #4]
 800a386:	6a1b      	ldr	r3, [r3, #32]
 800a388:	681b      	ldr	r3, [r3, #0]
 800a38a:	9a01      	ldr	r2, [sp, #4]
 800a38c:	6a12      	ldr	r2, [r2, #32]
 800a38e:	7c12      	ldrb	r2, [r2, #16]
 800a390:	210f      	movs	r1, #15
 800a392:	fa01 f202 	lsl.w	r2, r1, r2
 800a396:	605a      	str	r2, [r3, #4]

  /* Portable SPI ISR code defined in the high level driver, note, it is
     a macro.*/
  _spi_isr_code(spip);
 800a398:	9b01      	ldr	r3, [sp, #4]
 800a39a:	685b      	ldr	r3, [r3, #4]
 800a39c:	681b      	ldr	r3, [r3, #0]
 800a39e:	2b00      	cmp	r3, #0
 800a3a0:	d00f      	beq.n	800a3c2 <spi_lld_serve_rx_interrupt+0x92>
 800a3a2:	9b01      	ldr	r3, [sp, #4]
 800a3a4:	2204      	movs	r2, #4
 800a3a6:	701a      	strb	r2, [r3, #0]
 800a3a8:	9b01      	ldr	r3, [sp, #4]
 800a3aa:	685b      	ldr	r3, [r3, #4]
 800a3ac:	681b      	ldr	r3, [r3, #0]
 800a3ae:	9801      	ldr	r0, [sp, #4]
 800a3b0:	4798      	blx	r3
 800a3b2:	9b01      	ldr	r3, [sp, #4]
 800a3b4:	781b      	ldrb	r3, [r3, #0]
 800a3b6:	2b04      	cmp	r3, #4
 800a3b8:	d106      	bne.n	800a3c8 <spi_lld_serve_rx_interrupt+0x98>
 800a3ba:	9b01      	ldr	r3, [sp, #4]
 800a3bc:	2202      	movs	r2, #2
 800a3be:	701a      	strb	r2, [r3, #0]
 800a3c0:	e002      	b.n	800a3c8 <spi_lld_serve_rx_interrupt+0x98>
 800a3c2:	9b01      	ldr	r3, [sp, #4]
 800a3c4:	2202      	movs	r2, #2
 800a3c6:	701a      	strb	r2, [r3, #0]
 800a3c8:	f7ff ff92 	bl	800a2f0 <osalSysLockFromISR>
 800a3cc:	9b01      	ldr	r3, [sp, #4]
 800a3ce:	3308      	adds	r3, #8
 800a3d0:	4618      	mov	r0, r3
 800a3d2:	2100      	movs	r1, #0
 800a3d4:	f7ff ff9c 	bl	800a310 <osalThreadResumeI>
 800a3d8:	f7ff ff92 	bl	800a300 <osalSysUnlockFromISR>
}
 800a3dc:	b003      	add	sp, #12
 800a3de:	f85d fb04 	ldr.w	pc, [sp], #4
 800a3e2:	bf00      	nop
 800a3e4:	08016104 	.word	0x08016104
 800a3e8:	f3af 8000 	nop.w
 800a3ec:	f3af 8000 	nop.w

0800a3f0 <spi_lld_serve_tx_interrupt>:
 * @brief   Shared end-of-tx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {
 800a3f0:	b500      	push	{lr}
 800a3f2:	b083      	sub	sp, #12
 800a3f4:	9001      	str	r0, [sp, #4]
 800a3f6:	9100      	str	r1, [sp, #0]

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  (void)spip;
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800a3f8:	9b00      	ldr	r3, [sp, #0]
 800a3fa:	f003 0308 	and.w	r3, r3, #8
 800a3fe:	2b00      	cmp	r3, #0
 800a400:	d002      	beq.n	800a408 <spi_lld_serve_tx_interrupt+0x18>
    STM32_SPI_DMA_ERROR_HOOK(spip);
 800a402:	4803      	ldr	r0, [pc, #12]	; (800a410 <spi_lld_serve_tx_interrupt+0x20>)
 800a404:	f7ff ff64 	bl	800a2d0 <osalSysHalt>
  }
#else
  (void)spip;
  (void)flags;
#endif
}
 800a408:	b003      	add	sp, #12
 800a40a:	f85d fb04 	ldr.w	pc, [sp], #4
 800a40e:	bf00      	nop
 800a410:	08016104 	.word	0x08016104
 800a414:	f3af 8000 	nop.w
 800a418:	f3af 8000 	nop.w
 800a41c:	f3af 8000 	nop.w

0800a420 <spi_lld_init>:
/**
 * @brief   Low level SPI driver initialization.
 *
 * @notapi
 */
void spi_lld_init(void) {
 800a420:	b508      	push	{r3, lr}
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
 800a422:	4809      	ldr	r0, [pc, #36]	; (800a448 <spi_lld_init+0x28>)
 800a424:	f7fb fe44 	bl	80060b0 <spiObjectInit>
  SPID2.spi       = SPI2;
 800a428:	4b07      	ldr	r3, [pc, #28]	; (800a448 <spi_lld_init+0x28>)
 800a42a:	4a08      	ldr	r2, [pc, #32]	; (800a44c <spi_lld_init+0x2c>)
 800a42c:	61da      	str	r2, [r3, #28]
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
 800a42e:	4b06      	ldr	r3, [pc, #24]	; (800a448 <spi_lld_init+0x28>)
 800a430:	4a07      	ldr	r2, [pc, #28]	; (800a450 <spi_lld_init+0x30>)
 800a432:	621a      	str	r2, [r3, #32]
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
 800a434:	4b04      	ldr	r3, [pc, #16]	; (800a448 <spi_lld_init+0x28>)
 800a436:	4a07      	ldr	r2, [pc, #28]	; (800a454 <spi_lld_init+0x34>)
 800a438:	625a      	str	r2, [r3, #36]	; 0x24
  SPID2.rxdmamode = STM32_DMA_CR_CHSEL(SPI2_RX_DMA_CHANNEL) |
 800a43a:	4b03      	ldr	r3, [pc, #12]	; (800a448 <spi_lld_init+0x28>)
 800a43c:	4a06      	ldr	r2, [pc, #24]	; (800a458 <spi_lld_init+0x38>)
 800a43e:	629a      	str	r2, [r3, #40]	; 0x28
                    STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_CHANNEL) |
 800a440:	4b01      	ldr	r3, [pc, #4]	; (800a448 <spi_lld_init+0x28>)
 800a442:	4a06      	ldr	r2, [pc, #24]	; (800a45c <spi_lld_init+0x3c>)
 800a444:	62da      	str	r2, [r3, #44]	; 0x2c
                    STM32_DMA_CR_PL(STM32_SPI_SPI6_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_M2P |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif
}
 800a446:	bd08      	pop	{r3, pc}
 800a448:	20001174 	.word	0x20001174
 800a44c:	40003800 	.word	0x40003800
 800a450:	08015fcc 	.word	0x08015fcc
 800a454:	08015fe0 	.word	0x08015fe0
 800a458:	0001100a 	.word	0x0001100a
 800a45c:	00011018 	.word	0x00011018

0800a460 <spi_lld_start>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_start(SPIDriver *spip) {
 800a460:	b500      	push	{lr}
 800a462:	b085      	sub	sp, #20
 800a464:	9001      	str	r0, [sp, #4]
  uint32_t ds;

  /* If in stopped state then enables the SPI and DMA clocks.*/
  if (spip->state == SPI_STOP) {
 800a466:	9b01      	ldr	r3, [sp, #4]
 800a468:	781b      	ldrb	r3, [r3, #0]
 800a46a:	2b01      	cmp	r3, #1
 800a46c:	d12d      	bne.n	800a4ca <spi_lld_start+0x6a>
      osalDbgAssert(!b, "stream already allocated");
      rccEnableSPI1(FALSE);
    }
#endif
#if STM32_SPI_USE_SPI2
    if (&SPID2 == spip) {
 800a46e:	9a01      	ldr	r2, [sp, #4]
 800a470:	4b3c      	ldr	r3, [pc, #240]	; (800a564 <spi_lld_start+0x104>)
 800a472:	429a      	cmp	r2, r3
 800a474:	d11b      	bne.n	800a4ae <spi_lld_start+0x4e>
      bool b;
      b = dmaStreamAllocate(spip->dmarx,
 800a476:	9b01      	ldr	r3, [sp, #4]
 800a478:	6a1b      	ldr	r3, [r3, #32]
 800a47a:	4618      	mov	r0, r3
 800a47c:	210a      	movs	r1, #10
 800a47e:	4a3a      	ldr	r2, [pc, #232]	; (800a568 <spi_lld_start+0x108>)
 800a480:	9b01      	ldr	r3, [sp, #4]
 800a482:	f7fd fa8d 	bl	80079a0 <dmaStreamAllocate>
 800a486:	4603      	mov	r3, r0
 800a488:	f88d 300f 	strb.w	r3, [sp, #15]
                            STM32_SPI_SPI2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_rx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      b = dmaStreamAllocate(spip->dmatx,
 800a48c:	9b01      	ldr	r3, [sp, #4]
 800a48e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a490:	4618      	mov	r0, r3
 800a492:	210a      	movs	r1, #10
 800a494:	4a35      	ldr	r2, [pc, #212]	; (800a56c <spi_lld_start+0x10c>)
 800a496:	9b01      	ldr	r3, [sp, #4]
 800a498:	f7fd fa82 	bl	80079a0 <dmaStreamAllocate>
 800a49c:	4603      	mov	r3, r0
 800a49e:	f88d 300f 	strb.w	r3, [sp, #15]
                            STM32_SPI_SPI2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableSPI2(FALSE);
 800a4a2:	4b33      	ldr	r3, [pc, #204]	; (800a570 <spi_lld_start+0x110>)
 800a4a4:	4a32      	ldr	r2, [pc, #200]	; (800a570 <spi_lld_start+0x110>)
 800a4a6:	6d92      	ldr	r2, [r2, #88]	; 0x58
 800a4a8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800a4ac:	659a      	str	r2, [r3, #88]	; 0x58
      rccEnableSPI6(FALSE);
    }
#endif

    /* DMA setup.*/
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 800a4ae:	9b01      	ldr	r3, [sp, #4]
 800a4b0:	6a1b      	ldr	r3, [r3, #32]
 800a4b2:	685b      	ldr	r3, [r3, #4]
 800a4b4:	9a01      	ldr	r2, [sp, #4]
 800a4b6:	69d2      	ldr	r2, [r2, #28]
 800a4b8:	320c      	adds	r2, #12
 800a4ba:	609a      	str	r2, [r3, #8]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 800a4bc:	9b01      	ldr	r3, [sp, #4]
 800a4be:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a4c0:	685b      	ldr	r3, [r3, #4]
 800a4c2:	9a01      	ldr	r2, [sp, #4]
 800a4c4:	69d2      	ldr	r2, [r2, #28]
 800a4c6:	320c      	adds	r2, #12
 800a4c8:	609a      	str	r2, [r3, #8]
  }

  /* Configuration-specific DMA setup.*/
  ds = spip->config->cr2 & SPI_CR2_DS;
 800a4ca:	9b01      	ldr	r3, [sp, #4]
 800a4cc:	685b      	ldr	r3, [r3, #4]
 800a4ce:	899b      	ldrh	r3, [r3, #12]
 800a4d0:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 800a4d4:	9302      	str	r3, [sp, #8]
  if (!ds || (ds <= (SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0))) {
 800a4d6:	9b02      	ldr	r3, [sp, #8]
 800a4d8:	2b00      	cmp	r3, #0
 800a4da:	d003      	beq.n	800a4e4 <spi_lld_start+0x84>
 800a4dc:	9b02      	ldr	r3, [sp, #8]
 800a4de:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 800a4e2:	d80c      	bhi.n	800a4fe <spi_lld_start+0x9e>
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800a4e4:	9b01      	ldr	r3, [sp, #4]
 800a4e6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 800a4e8:	f423 6270 	bic.w	r2, r3, #3840	; 0xf00

  /* Configuration-specific DMA setup.*/
  ds = spip->config->cr2 & SPI_CR2_DS;
  if (!ds || (ds <= (SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0))) {
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800a4ec:	9b01      	ldr	r3, [sp, #4]
 800a4ee:	629a      	str	r2, [r3, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800a4f0:	9b01      	ldr	r3, [sp, #4]
 800a4f2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 800a4f4:	f423 6270 	bic.w	r2, r3, #3840	; 0xf00
  ds = spip->config->cr2 & SPI_CR2_DS;
  if (!ds || (ds <= (SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0))) {
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800a4f8:	9b01      	ldr	r3, [sp, #4]
 800a4fa:	62da      	str	r2, [r3, #44]	; 0x2c
 800a4fc:	e00f      	b.n	800a51e <spi_lld_start+0xbe>
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800a4fe:	9b01      	ldr	r3, [sp, #4]
 800a500:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a502:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 800a506:	f443 62a0 	orr.w	r2, r3, #1280	; 0x500
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800a50a:	9b01      	ldr	r3, [sp, #4]
 800a50c:	629a      	str	r2, [r3, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800a50e:	9b01      	ldr	r3, [sp, #4]
 800a510:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a512:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 800a516:	f443 62a0 	orr.w	r2, r3, #1280	; 0x500
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800a51a:	9b01      	ldr	r3, [sp, #4]
 800a51c:	62da      	str	r2, [r3, #44]	; 0x2c
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
  }

  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
 800a51e:	9b01      	ldr	r3, [sp, #4]
 800a520:	69db      	ldr	r3, [r3, #28]
 800a522:	2200      	movs	r2, #0
 800a524:	601a      	str	r2, [r3, #0]
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR;
 800a526:	9b01      	ldr	r3, [sp, #4]
 800a528:	69db      	ldr	r3, [r3, #28]
 800a52a:	9a01      	ldr	r2, [sp, #4]
 800a52c:	6852      	ldr	r2, [r2, #4]
 800a52e:	8952      	ldrh	r2, [r2, #10]
 800a530:	f042 0204 	orr.w	r2, r2, #4
 800a534:	b292      	uxth	r2, r2
 800a536:	601a      	str	r2, [r3, #0]
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_FRXTH | SPI_CR2_SSOE |
 800a538:	9b01      	ldr	r3, [sp, #4]
 800a53a:	69da      	ldr	r2, [r3, #28]
 800a53c:	9b01      	ldr	r3, [sp, #4]
 800a53e:	685b      	ldr	r3, [r3, #4]
 800a540:	899b      	ldrh	r3, [r3, #12]
 800a542:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800a546:	f043 0307 	orr.w	r3, r3, #7
 800a54a:	b29b      	uxth	r3, r3
 800a54c:	6053      	str	r3, [r2, #4]
                    SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN;
  spip->spi->CR1 |= SPI_CR1_SPE;
 800a54e:	9b01      	ldr	r3, [sp, #4]
 800a550:	69db      	ldr	r3, [r3, #28]
 800a552:	9a01      	ldr	r2, [sp, #4]
 800a554:	69d2      	ldr	r2, [r2, #28]
 800a556:	6812      	ldr	r2, [r2, #0]
 800a558:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800a55c:	601a      	str	r2, [r3, #0]
}
 800a55e:	b005      	add	sp, #20
 800a560:	f85d fb04 	ldr.w	pc, [sp], #4
 800a564:	20001174 	.word	0x20001174
 800a568:	0800a331 	.word	0x0800a331
 800a56c:	0800a3f1 	.word	0x0800a3f1
 800a570:	40021000 	.word	0x40021000
 800a574:	f3af 8000 	nop.w
 800a578:	f3af 8000 	nop.w
 800a57c:	f3af 8000 	nop.w

0800a580 <spi_lld_stop>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_stop(SPIDriver *spip) {
 800a580:	b500      	push	{lr}
 800a582:	b083      	sub	sp, #12
 800a584:	9001      	str	r0, [sp, #4]

  /* If in ready state then disables the SPI clock.*/
  if (spip->state == SPI_READY) {
 800a586:	9b01      	ldr	r3, [sp, #4]
 800a588:	781b      	ldrb	r3, [r3, #0]
 800a58a:	2b02      	cmp	r3, #2
 800a58c:	d11b      	bne.n	800a5c6 <spi_lld_stop+0x46>

    /* SPI disable.*/
    spip->spi->CR1 = 0;
 800a58e:	9b01      	ldr	r3, [sp, #4]
 800a590:	69db      	ldr	r3, [r3, #28]
 800a592:	2200      	movs	r2, #0
 800a594:	601a      	str	r2, [r3, #0]
    spip->spi->CR2 = 0;
 800a596:	9b01      	ldr	r3, [sp, #4]
 800a598:	69db      	ldr	r3, [r3, #28]
 800a59a:	2200      	movs	r2, #0
 800a59c:	605a      	str	r2, [r3, #4]
    dmaStreamRelease(spip->dmarx);
 800a59e:	9b01      	ldr	r3, [sp, #4]
 800a5a0:	6a1b      	ldr	r3, [r3, #32]
 800a5a2:	4618      	mov	r0, r3
 800a5a4:	f7fd fa6c 	bl	8007a80 <dmaStreamRelease>
    dmaStreamRelease(spip->dmatx);
 800a5a8:	9b01      	ldr	r3, [sp, #4]
 800a5aa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a5ac:	4618      	mov	r0, r3
 800a5ae:	f7fd fa67 	bl	8007a80 <dmaStreamRelease>
#if STM32_SPI_USE_SPI1
    if (&SPID1 == spip)
      rccDisableSPI1(FALSE);
#endif
#if STM32_SPI_USE_SPI2
    if (&SPID2 == spip)
 800a5b2:	9a01      	ldr	r2, [sp, #4]
 800a5b4:	4b05      	ldr	r3, [pc, #20]	; (800a5cc <spi_lld_stop+0x4c>)
 800a5b6:	429a      	cmp	r2, r3
 800a5b8:	d105      	bne.n	800a5c6 <spi_lld_stop+0x46>
      rccDisableSPI2(FALSE);
 800a5ba:	4b05      	ldr	r3, [pc, #20]	; (800a5d0 <spi_lld_stop+0x50>)
 800a5bc:	4a04      	ldr	r2, [pc, #16]	; (800a5d0 <spi_lld_stop+0x50>)
 800a5be:	6d92      	ldr	r2, [r2, #88]	; 0x58
 800a5c0:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 800a5c4:	659a      	str	r2, [r3, #88]	; 0x58
#if STM32_SPI_USE_SPI6
    if (&SPID6 == spip)
      rccDisableSPI6(FALSE);
#endif
  }
}
 800a5c6:	b003      	add	sp, #12
 800a5c8:	f85d fb04 	ldr.w	pc, [sp], #4
 800a5cc:	20001174 	.word	0x20001174
 800a5d0:	40021000 	.word	0x40021000
 800a5d4:	f3af 8000 	nop.w
 800a5d8:	f3af 8000 	nop.w
 800a5dc:	f3af 8000 	nop.w

0800a5e0 <spi_lld_select>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_select(SPIDriver *spip) {
 800a5e0:	b082      	sub	sp, #8
 800a5e2:	9001      	str	r0, [sp, #4]

  palClearPad(spip->config->ssport, spip->config->sspad);
 800a5e4:	9b01      	ldr	r3, [sp, #4]
 800a5e6:	685b      	ldr	r3, [r3, #4]
 800a5e8:	685b      	ldr	r3, [r3, #4]
 800a5ea:	9a01      	ldr	r2, [sp, #4]
 800a5ec:	6852      	ldr	r2, [r2, #4]
 800a5ee:	8912      	ldrh	r2, [r2, #8]
 800a5f0:	2101      	movs	r1, #1
 800a5f2:	fa01 f202 	lsl.w	r2, r1, r2
 800a5f6:	b292      	uxth	r2, r2
 800a5f8:	835a      	strh	r2, [r3, #26]
}
 800a5fa:	b002      	add	sp, #8
 800a5fc:	4770      	bx	lr
 800a5fe:	bf00      	nop

0800a600 <spi_lld_unselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_unselect(SPIDriver *spip) {
 800a600:	b082      	sub	sp, #8
 800a602:	9001      	str	r0, [sp, #4]

  palSetPad(spip->config->ssport, spip->config->sspad);
 800a604:	9b01      	ldr	r3, [sp, #4]
 800a606:	685b      	ldr	r3, [r3, #4]
 800a608:	685b      	ldr	r3, [r3, #4]
 800a60a:	9a01      	ldr	r2, [sp, #4]
 800a60c:	6852      	ldr	r2, [r2, #4]
 800a60e:	8912      	ldrh	r2, [r2, #8]
 800a610:	2101      	movs	r1, #1
 800a612:	fa01 f202 	lsl.w	r2, r1, r2
 800a616:	b292      	uxth	r2, r2
 800a618:	831a      	strh	r2, [r3, #24]
}
 800a61a:	b002      	add	sp, #8
 800a61c:	4770      	bx	lr
 800a61e:	bf00      	nop

0800a620 <spi_lld_ignore>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] n         number of words to be ignored
 *
 * @notapi
 */
void spi_lld_ignore(SPIDriver *spip, size_t n) {
 800a620:	b084      	sub	sp, #16
 800a622:	9001      	str	r0, [sp, #4]
 800a624:	9100      	str	r1, [sp, #0]

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 800a626:	9b01      	ldr	r3, [sp, #4]
 800a628:	6a1b      	ldr	r3, [r3, #32]
 800a62a:	685b      	ldr	r3, [r3, #4]
 800a62c:	4a38      	ldr	r2, [pc, #224]	; (800a710 <spi_lld_ignore+0xf0>)
 800a62e:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800a630:	9b01      	ldr	r3, [sp, #4]
 800a632:	6a1b      	ldr	r3, [r3, #32]
 800a634:	685b      	ldr	r3, [r3, #4]
 800a636:	9a00      	ldr	r2, [sp, #0]
 800a638:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 800a63a:	9b01      	ldr	r3, [sp, #4]
 800a63c:	6a1b      	ldr	r3, [r3, #32]
 800a63e:	68db      	ldr	r3, [r3, #12]
 800a640:	681b      	ldr	r3, [r3, #0]
 800a642:	9303      	str	r3, [sp, #12]
 800a644:	9b01      	ldr	r3, [sp, #4]
 800a646:	6a1b      	ldr	r3, [r3, #32]
 800a648:	7c1b      	ldrb	r3, [r3, #16]
 800a64a:	220f      	movs	r2, #15
 800a64c:	fa02 f303 	lsl.w	r3, r2, r3
 800a650:	43db      	mvns	r3, r3
 800a652:	9a03      	ldr	r2, [sp, #12]
 800a654:	4013      	ands	r3, r2
 800a656:	9303      	str	r3, [sp, #12]
 800a658:	9b01      	ldr	r3, [sp, #4]
 800a65a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a65c:	0c1a      	lsrs	r2, r3, #16
 800a65e:	9b01      	ldr	r3, [sp, #4]
 800a660:	6a1b      	ldr	r3, [r3, #32]
 800a662:	7c1b      	ldrb	r3, [r3, #16]
 800a664:	fa02 f303 	lsl.w	r3, r2, r3
 800a668:	9a03      	ldr	r2, [sp, #12]
 800a66a:	4313      	orrs	r3, r2
 800a66c:	9303      	str	r3, [sp, #12]
 800a66e:	9b01      	ldr	r3, [sp, #4]
 800a670:	6a1b      	ldr	r3, [r3, #32]
 800a672:	68db      	ldr	r3, [r3, #12]
 800a674:	9a03      	ldr	r2, [sp, #12]
 800a676:	601a      	str	r2, [r3, #0]
 800a678:	9b01      	ldr	r3, [sp, #4]
 800a67a:	6a1b      	ldr	r3, [r3, #32]
 800a67c:	685b      	ldr	r3, [r3, #4]
 800a67e:	9a01      	ldr	r2, [sp, #4]
 800a680:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800a682:	601a      	str	r2, [r3, #0]

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800a684:	9b01      	ldr	r3, [sp, #4]
 800a686:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a688:	685b      	ldr	r3, [r3, #4]
 800a68a:	4a22      	ldr	r2, [pc, #136]	; (800a714 <spi_lld_ignore+0xf4>)
 800a68c:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800a68e:	9b01      	ldr	r3, [sp, #4]
 800a690:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a692:	685b      	ldr	r3, [r3, #4]
 800a694:	9a00      	ldr	r2, [sp, #0]
 800a696:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 800a698:	9b01      	ldr	r3, [sp, #4]
 800a69a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a69c:	68db      	ldr	r3, [r3, #12]
 800a69e:	681b      	ldr	r3, [r3, #0]
 800a6a0:	9302      	str	r3, [sp, #8]
 800a6a2:	9b01      	ldr	r3, [sp, #4]
 800a6a4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a6a6:	7c1b      	ldrb	r3, [r3, #16]
 800a6a8:	220f      	movs	r2, #15
 800a6aa:	fa02 f303 	lsl.w	r3, r2, r3
 800a6ae:	43db      	mvns	r3, r3
 800a6b0:	9a02      	ldr	r2, [sp, #8]
 800a6b2:	4013      	ands	r3, r2
 800a6b4:	9302      	str	r3, [sp, #8]
 800a6b6:	9b01      	ldr	r3, [sp, #4]
 800a6b8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a6ba:	0c1a      	lsrs	r2, r3, #16
 800a6bc:	9b01      	ldr	r3, [sp, #4]
 800a6be:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a6c0:	7c1b      	ldrb	r3, [r3, #16]
 800a6c2:	fa02 f303 	lsl.w	r3, r2, r3
 800a6c6:	9a02      	ldr	r2, [sp, #8]
 800a6c8:	4313      	orrs	r3, r2
 800a6ca:	9302      	str	r3, [sp, #8]
 800a6cc:	9b01      	ldr	r3, [sp, #4]
 800a6ce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a6d0:	68db      	ldr	r3, [r3, #12]
 800a6d2:	9a02      	ldr	r2, [sp, #8]
 800a6d4:	601a      	str	r2, [r3, #0]
 800a6d6:	9b01      	ldr	r3, [sp, #4]
 800a6d8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a6da:	685b      	ldr	r3, [r3, #4]
 800a6dc:	9a01      	ldr	r2, [sp, #4]
 800a6de:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800a6e0:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800a6e2:	9b01      	ldr	r3, [sp, #4]
 800a6e4:	6a1b      	ldr	r3, [r3, #32]
 800a6e6:	685b      	ldr	r3, [r3, #4]
 800a6e8:	9a01      	ldr	r2, [sp, #4]
 800a6ea:	6a12      	ldr	r2, [r2, #32]
 800a6ec:	6852      	ldr	r2, [r2, #4]
 800a6ee:	6812      	ldr	r2, [r2, #0]
 800a6f0:	f042 0201 	orr.w	r2, r2, #1
 800a6f4:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(spip->dmatx);
 800a6f6:	9b01      	ldr	r3, [sp, #4]
 800a6f8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a6fa:	685b      	ldr	r3, [r3, #4]
 800a6fc:	9a01      	ldr	r2, [sp, #4]
 800a6fe:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800a700:	6852      	ldr	r2, [r2, #4]
 800a702:	6812      	ldr	r2, [r2, #0]
 800a704:	f042 0201 	orr.w	r2, r2, #1
 800a708:	601a      	str	r2, [r3, #0]
}
 800a70a:	b004      	add	sp, #16
 800a70c:	4770      	bx	lr
 800a70e:	bf00      	nop
 800a710:	20000b44 	.word	0x20000b44
 800a714:	08016100 	.word	0x08016100
 800a718:	f3af 8000 	nop.w
 800a71c:	f3af 8000 	nop.w

0800a720 <spi_lld_exchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {
 800a720:	b086      	sub	sp, #24
 800a722:	9003      	str	r0, [sp, #12]
 800a724:	9102      	str	r1, [sp, #8]
 800a726:	9201      	str	r2, [sp, #4]
 800a728:	9300      	str	r3, [sp, #0]

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 800a72a:	9b03      	ldr	r3, [sp, #12]
 800a72c:	6a1b      	ldr	r3, [r3, #32]
 800a72e:	685b      	ldr	r3, [r3, #4]
 800a730:	9a00      	ldr	r2, [sp, #0]
 800a732:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800a734:	9b03      	ldr	r3, [sp, #12]
 800a736:	6a1b      	ldr	r3, [r3, #32]
 800a738:	685b      	ldr	r3, [r3, #4]
 800a73a:	9a02      	ldr	r2, [sp, #8]
 800a73c:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 800a73e:	9b03      	ldr	r3, [sp, #12]
 800a740:	6a1b      	ldr	r3, [r3, #32]
 800a742:	68db      	ldr	r3, [r3, #12]
 800a744:	681b      	ldr	r3, [r3, #0]
 800a746:	9305      	str	r3, [sp, #20]
 800a748:	9b03      	ldr	r3, [sp, #12]
 800a74a:	6a1b      	ldr	r3, [r3, #32]
 800a74c:	7c1b      	ldrb	r3, [r3, #16]
 800a74e:	220f      	movs	r2, #15
 800a750:	fa02 f303 	lsl.w	r3, r2, r3
 800a754:	43db      	mvns	r3, r3
 800a756:	9a05      	ldr	r2, [sp, #20]
 800a758:	4013      	ands	r3, r2
 800a75a:	9305      	str	r3, [sp, #20]
 800a75c:	9b03      	ldr	r3, [sp, #12]
 800a75e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a760:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a764:	0c1a      	lsrs	r2, r3, #16
 800a766:	9b03      	ldr	r3, [sp, #12]
 800a768:	6a1b      	ldr	r3, [r3, #32]
 800a76a:	7c1b      	ldrb	r3, [r3, #16]
 800a76c:	fa02 f303 	lsl.w	r3, r2, r3
 800a770:	9a05      	ldr	r2, [sp, #20]
 800a772:	4313      	orrs	r3, r2
 800a774:	9305      	str	r3, [sp, #20]
 800a776:	9b03      	ldr	r3, [sp, #12]
 800a778:	6a1b      	ldr	r3, [r3, #32]
 800a77a:	68db      	ldr	r3, [r3, #12]
 800a77c:	9a05      	ldr	r2, [sp, #20]
 800a77e:	601a      	str	r2, [r3, #0]
 800a780:	9b03      	ldr	r3, [sp, #12]
 800a782:	6a1b      	ldr	r3, [r3, #32]
 800a784:	685b      	ldr	r3, [r3, #4]
 800a786:	9a03      	ldr	r2, [sp, #12]
 800a788:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800a78a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800a78e:	601a      	str	r2, [r3, #0]

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 800a790:	9b03      	ldr	r3, [sp, #12]
 800a792:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a794:	685b      	ldr	r3, [r3, #4]
 800a796:	9a01      	ldr	r2, [sp, #4]
 800a798:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800a79a:	9b03      	ldr	r3, [sp, #12]
 800a79c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a79e:	685b      	ldr	r3, [r3, #4]
 800a7a0:	9a02      	ldr	r2, [sp, #8]
 800a7a2:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 800a7a4:	9b03      	ldr	r3, [sp, #12]
 800a7a6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a7a8:	68db      	ldr	r3, [r3, #12]
 800a7aa:	681b      	ldr	r3, [r3, #0]
 800a7ac:	9304      	str	r3, [sp, #16]
 800a7ae:	9b03      	ldr	r3, [sp, #12]
 800a7b0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a7b2:	7c1b      	ldrb	r3, [r3, #16]
 800a7b4:	220f      	movs	r2, #15
 800a7b6:	fa02 f303 	lsl.w	r3, r2, r3
 800a7ba:	43db      	mvns	r3, r3
 800a7bc:	9a04      	ldr	r2, [sp, #16]
 800a7be:	4013      	ands	r3, r2
 800a7c0:	9304      	str	r3, [sp, #16]
 800a7c2:	9b03      	ldr	r3, [sp, #12]
 800a7c4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a7c6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a7ca:	0c1a      	lsrs	r2, r3, #16
 800a7cc:	9b03      	ldr	r3, [sp, #12]
 800a7ce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a7d0:	7c1b      	ldrb	r3, [r3, #16]
 800a7d2:	fa02 f303 	lsl.w	r3, r2, r3
 800a7d6:	9a04      	ldr	r2, [sp, #16]
 800a7d8:	4313      	orrs	r3, r2
 800a7da:	9304      	str	r3, [sp, #16]
 800a7dc:	9b03      	ldr	r3, [sp, #12]
 800a7de:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a7e0:	68db      	ldr	r3, [r3, #12]
 800a7e2:	9a04      	ldr	r2, [sp, #16]
 800a7e4:	601a      	str	r2, [r3, #0]
 800a7e6:	9b03      	ldr	r3, [sp, #12]
 800a7e8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a7ea:	685b      	ldr	r3, [r3, #4]
 800a7ec:	9a03      	ldr	r2, [sp, #12]
 800a7ee:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800a7f0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800a7f4:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800a7f6:	9b03      	ldr	r3, [sp, #12]
 800a7f8:	6a1b      	ldr	r3, [r3, #32]
 800a7fa:	685b      	ldr	r3, [r3, #4]
 800a7fc:	9a03      	ldr	r2, [sp, #12]
 800a7fe:	6a12      	ldr	r2, [r2, #32]
 800a800:	6852      	ldr	r2, [r2, #4]
 800a802:	6812      	ldr	r2, [r2, #0]
 800a804:	f042 0201 	orr.w	r2, r2, #1
 800a808:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(spip->dmatx);
 800a80a:	9b03      	ldr	r3, [sp, #12]
 800a80c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a80e:	685b      	ldr	r3, [r3, #4]
 800a810:	9a03      	ldr	r2, [sp, #12]
 800a812:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800a814:	6852      	ldr	r2, [r2, #4]
 800a816:	6812      	ldr	r2, [r2, #0]
 800a818:	f042 0201 	orr.w	r2, r2, #1
 800a81c:	601a      	str	r2, [r3, #0]
}
 800a81e:	b006      	add	sp, #24
 800a820:	4770      	bx	lr
 800a822:	bf00      	nop
 800a824:	f3af 8000 	nop.w
 800a828:	f3af 8000 	nop.w
 800a82c:	f3af 8000 	nop.w

0800a830 <spi_lld_send>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {
 800a830:	b086      	sub	sp, #24
 800a832:	9003      	str	r0, [sp, #12]
 800a834:	9102      	str	r1, [sp, #8]
 800a836:	9201      	str	r2, [sp, #4]

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 800a838:	9b03      	ldr	r3, [sp, #12]
 800a83a:	6a1b      	ldr	r3, [r3, #32]
 800a83c:	685b      	ldr	r3, [r3, #4]
 800a83e:	4a3a      	ldr	r2, [pc, #232]	; (800a928 <spi_lld_send+0xf8>)
 800a840:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800a842:	9b03      	ldr	r3, [sp, #12]
 800a844:	6a1b      	ldr	r3, [r3, #32]
 800a846:	685b      	ldr	r3, [r3, #4]
 800a848:	9a02      	ldr	r2, [sp, #8]
 800a84a:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 800a84c:	9b03      	ldr	r3, [sp, #12]
 800a84e:	6a1b      	ldr	r3, [r3, #32]
 800a850:	68db      	ldr	r3, [r3, #12]
 800a852:	681b      	ldr	r3, [r3, #0]
 800a854:	9305      	str	r3, [sp, #20]
 800a856:	9b03      	ldr	r3, [sp, #12]
 800a858:	6a1b      	ldr	r3, [r3, #32]
 800a85a:	7c1b      	ldrb	r3, [r3, #16]
 800a85c:	220f      	movs	r2, #15
 800a85e:	fa02 f303 	lsl.w	r3, r2, r3
 800a862:	43db      	mvns	r3, r3
 800a864:	9a05      	ldr	r2, [sp, #20]
 800a866:	4013      	ands	r3, r2
 800a868:	9305      	str	r3, [sp, #20]
 800a86a:	9b03      	ldr	r3, [sp, #12]
 800a86c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a86e:	0c1a      	lsrs	r2, r3, #16
 800a870:	9b03      	ldr	r3, [sp, #12]
 800a872:	6a1b      	ldr	r3, [r3, #32]
 800a874:	7c1b      	ldrb	r3, [r3, #16]
 800a876:	fa02 f303 	lsl.w	r3, r2, r3
 800a87a:	9a05      	ldr	r2, [sp, #20]
 800a87c:	4313      	orrs	r3, r2
 800a87e:	9305      	str	r3, [sp, #20]
 800a880:	9b03      	ldr	r3, [sp, #12]
 800a882:	6a1b      	ldr	r3, [r3, #32]
 800a884:	68db      	ldr	r3, [r3, #12]
 800a886:	9a05      	ldr	r2, [sp, #20]
 800a888:	601a      	str	r2, [r3, #0]
 800a88a:	9b03      	ldr	r3, [sp, #12]
 800a88c:	6a1b      	ldr	r3, [r3, #32]
 800a88e:	685b      	ldr	r3, [r3, #4]
 800a890:	9a03      	ldr	r2, [sp, #12]
 800a892:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800a894:	601a      	str	r2, [r3, #0]

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 800a896:	9b03      	ldr	r3, [sp, #12]
 800a898:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a89a:	685b      	ldr	r3, [r3, #4]
 800a89c:	9a01      	ldr	r2, [sp, #4]
 800a89e:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800a8a0:	9b03      	ldr	r3, [sp, #12]
 800a8a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a8a4:	685b      	ldr	r3, [r3, #4]
 800a8a6:	9a02      	ldr	r2, [sp, #8]
 800a8a8:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 800a8aa:	9b03      	ldr	r3, [sp, #12]
 800a8ac:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a8ae:	68db      	ldr	r3, [r3, #12]
 800a8b0:	681b      	ldr	r3, [r3, #0]
 800a8b2:	9304      	str	r3, [sp, #16]
 800a8b4:	9b03      	ldr	r3, [sp, #12]
 800a8b6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a8b8:	7c1b      	ldrb	r3, [r3, #16]
 800a8ba:	220f      	movs	r2, #15
 800a8bc:	fa02 f303 	lsl.w	r3, r2, r3
 800a8c0:	43db      	mvns	r3, r3
 800a8c2:	9a04      	ldr	r2, [sp, #16]
 800a8c4:	4013      	ands	r3, r2
 800a8c6:	9304      	str	r3, [sp, #16]
 800a8c8:	9b03      	ldr	r3, [sp, #12]
 800a8ca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a8cc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a8d0:	0c1a      	lsrs	r2, r3, #16
 800a8d2:	9b03      	ldr	r3, [sp, #12]
 800a8d4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a8d6:	7c1b      	ldrb	r3, [r3, #16]
 800a8d8:	fa02 f303 	lsl.w	r3, r2, r3
 800a8dc:	9a04      	ldr	r2, [sp, #16]
 800a8de:	4313      	orrs	r3, r2
 800a8e0:	9304      	str	r3, [sp, #16]
 800a8e2:	9b03      	ldr	r3, [sp, #12]
 800a8e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a8e6:	68db      	ldr	r3, [r3, #12]
 800a8e8:	9a04      	ldr	r2, [sp, #16]
 800a8ea:	601a      	str	r2, [r3, #0]
 800a8ec:	9b03      	ldr	r3, [sp, #12]
 800a8ee:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a8f0:	685b      	ldr	r3, [r3, #4]
 800a8f2:	9a03      	ldr	r2, [sp, #12]
 800a8f4:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800a8f6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800a8fa:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800a8fc:	9b03      	ldr	r3, [sp, #12]
 800a8fe:	6a1b      	ldr	r3, [r3, #32]
 800a900:	685b      	ldr	r3, [r3, #4]
 800a902:	9a03      	ldr	r2, [sp, #12]
 800a904:	6a12      	ldr	r2, [r2, #32]
 800a906:	6852      	ldr	r2, [r2, #4]
 800a908:	6812      	ldr	r2, [r2, #0]
 800a90a:	f042 0201 	orr.w	r2, r2, #1
 800a90e:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(spip->dmatx);
 800a910:	9b03      	ldr	r3, [sp, #12]
 800a912:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a914:	685b      	ldr	r3, [r3, #4]
 800a916:	9a03      	ldr	r2, [sp, #12]
 800a918:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800a91a:	6852      	ldr	r2, [r2, #4]
 800a91c:	6812      	ldr	r2, [r2, #0]
 800a91e:	f042 0201 	orr.w	r2, r2, #1
 800a922:	601a      	str	r2, [r3, #0]
}
 800a924:	b006      	add	sp, #24
 800a926:	4770      	bx	lr
 800a928:	20000b44 	.word	0x20000b44
 800a92c:	f3af 8000 	nop.w

0800a930 <spi_lld_receive>:
 * @param[in] n         number of words to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void spi_lld_receive(SPIDriver *spip, size_t n, void *rxbuf) {
 800a930:	b086      	sub	sp, #24
 800a932:	9003      	str	r0, [sp, #12]
 800a934:	9102      	str	r1, [sp, #8]
 800a936:	9201      	str	r2, [sp, #4]

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 800a938:	9b03      	ldr	r3, [sp, #12]
 800a93a:	6a1b      	ldr	r3, [r3, #32]
 800a93c:	685b      	ldr	r3, [r3, #4]
 800a93e:	9a01      	ldr	r2, [sp, #4]
 800a940:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800a942:	9b03      	ldr	r3, [sp, #12]
 800a944:	6a1b      	ldr	r3, [r3, #32]
 800a946:	685b      	ldr	r3, [r3, #4]
 800a948:	9a02      	ldr	r2, [sp, #8]
 800a94a:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 800a94c:	9b03      	ldr	r3, [sp, #12]
 800a94e:	6a1b      	ldr	r3, [r3, #32]
 800a950:	68db      	ldr	r3, [r3, #12]
 800a952:	681b      	ldr	r3, [r3, #0]
 800a954:	9305      	str	r3, [sp, #20]
 800a956:	9b03      	ldr	r3, [sp, #12]
 800a958:	6a1b      	ldr	r3, [r3, #32]
 800a95a:	7c1b      	ldrb	r3, [r3, #16]
 800a95c:	220f      	movs	r2, #15
 800a95e:	fa02 f303 	lsl.w	r3, r2, r3
 800a962:	43db      	mvns	r3, r3
 800a964:	9a05      	ldr	r2, [sp, #20]
 800a966:	4013      	ands	r3, r2
 800a968:	9305      	str	r3, [sp, #20]
 800a96a:	9b03      	ldr	r3, [sp, #12]
 800a96c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a96e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a972:	0c1a      	lsrs	r2, r3, #16
 800a974:	9b03      	ldr	r3, [sp, #12]
 800a976:	6a1b      	ldr	r3, [r3, #32]
 800a978:	7c1b      	ldrb	r3, [r3, #16]
 800a97a:	fa02 f303 	lsl.w	r3, r2, r3
 800a97e:	9a05      	ldr	r2, [sp, #20]
 800a980:	4313      	orrs	r3, r2
 800a982:	9305      	str	r3, [sp, #20]
 800a984:	9b03      	ldr	r3, [sp, #12]
 800a986:	6a1b      	ldr	r3, [r3, #32]
 800a988:	68db      	ldr	r3, [r3, #12]
 800a98a:	9a05      	ldr	r2, [sp, #20]
 800a98c:	601a      	str	r2, [r3, #0]
 800a98e:	9b03      	ldr	r3, [sp, #12]
 800a990:	6a1b      	ldr	r3, [r3, #32]
 800a992:	685b      	ldr	r3, [r3, #4]
 800a994:	9a03      	ldr	r2, [sp, #12]
 800a996:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800a998:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800a99c:	601a      	str	r2, [r3, #0]

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800a99e:	9b03      	ldr	r3, [sp, #12]
 800a9a0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a9a2:	685b      	ldr	r3, [r3, #4]
 800a9a4:	4a20      	ldr	r2, [pc, #128]	; (800aa28 <spi_lld_receive+0xf8>)
 800a9a6:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800a9a8:	9b03      	ldr	r3, [sp, #12]
 800a9aa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a9ac:	685b      	ldr	r3, [r3, #4]
 800a9ae:	9a02      	ldr	r2, [sp, #8]
 800a9b0:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 800a9b2:	9b03      	ldr	r3, [sp, #12]
 800a9b4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a9b6:	68db      	ldr	r3, [r3, #12]
 800a9b8:	681b      	ldr	r3, [r3, #0]
 800a9ba:	9304      	str	r3, [sp, #16]
 800a9bc:	9b03      	ldr	r3, [sp, #12]
 800a9be:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a9c0:	7c1b      	ldrb	r3, [r3, #16]
 800a9c2:	220f      	movs	r2, #15
 800a9c4:	fa02 f303 	lsl.w	r3, r2, r3
 800a9c8:	43db      	mvns	r3, r3
 800a9ca:	9a04      	ldr	r2, [sp, #16]
 800a9cc:	4013      	ands	r3, r2
 800a9ce:	9304      	str	r3, [sp, #16]
 800a9d0:	9b03      	ldr	r3, [sp, #12]
 800a9d2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a9d4:	0c1a      	lsrs	r2, r3, #16
 800a9d6:	9b03      	ldr	r3, [sp, #12]
 800a9d8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a9da:	7c1b      	ldrb	r3, [r3, #16]
 800a9dc:	fa02 f303 	lsl.w	r3, r2, r3
 800a9e0:	9a04      	ldr	r2, [sp, #16]
 800a9e2:	4313      	orrs	r3, r2
 800a9e4:	9304      	str	r3, [sp, #16]
 800a9e6:	9b03      	ldr	r3, [sp, #12]
 800a9e8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a9ea:	68db      	ldr	r3, [r3, #12]
 800a9ec:	9a04      	ldr	r2, [sp, #16]
 800a9ee:	601a      	str	r2, [r3, #0]
 800a9f0:	9b03      	ldr	r3, [sp, #12]
 800a9f2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a9f4:	685b      	ldr	r3, [r3, #4]
 800a9f6:	9a03      	ldr	r2, [sp, #12]
 800a9f8:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800a9fa:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800a9fc:	9b03      	ldr	r3, [sp, #12]
 800a9fe:	6a1b      	ldr	r3, [r3, #32]
 800aa00:	685b      	ldr	r3, [r3, #4]
 800aa02:	9a03      	ldr	r2, [sp, #12]
 800aa04:	6a12      	ldr	r2, [r2, #32]
 800aa06:	6852      	ldr	r2, [r2, #4]
 800aa08:	6812      	ldr	r2, [r2, #0]
 800aa0a:	f042 0201 	orr.w	r2, r2, #1
 800aa0e:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(spip->dmatx);
 800aa10:	9b03      	ldr	r3, [sp, #12]
 800aa12:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800aa14:	685b      	ldr	r3, [r3, #4]
 800aa16:	9a03      	ldr	r2, [sp, #12]
 800aa18:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800aa1a:	6852      	ldr	r2, [r2, #4]
 800aa1c:	6812      	ldr	r2, [r2, #0]
 800aa1e:	f042 0201 	orr.w	r2, r2, #1
 800aa22:	601a      	str	r2, [r3, #0]
}
 800aa24:	b006      	add	sp, #24
 800aa26:	4770      	bx	lr
 800aa28:	08016100 	.word	0x08016100
 800aa2c:	f3af 8000 	nop.w

0800aa30 <spi_lld_polled_exchange>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] frame     the data frame to send over the SPI bus
 * @return              The received data frame from the SPI bus.
 */
uint16_t spi_lld_polled_exchange(SPIDriver *spip, uint16_t frame) {
 800aa30:	b084      	sub	sp, #16
 800aa32:	9001      	str	r0, [sp, #4]
 800aa34:	460b      	mov	r3, r1
 800aa36:	f8ad 3002 	strh.w	r3, [sp, #2]
  /*
   * Data register must be accessed with the appropriate data size.
   * Byte size access (uint8_t *) for transactions that are <= 8-bit.
   * Halfword size access (uint16_t) for transactions that are <= 8-bit.
   */
  if ((spip->config->cr2 & SPI_CR2_DS) <= (SPI_CR2_DS_2 |
 800aa3a:	9b01      	ldr	r3, [sp, #4]
 800aa3c:	685b      	ldr	r3, [r3, #4]
 800aa3e:	899b      	ldrh	r3, [r3, #12]
 800aa40:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 800aa44:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 800aa48:	d814      	bhi.n	800aa74 <spi_lld_polled_exchange+0x44>
                                           SPI_CR2_DS_1 |
                                           SPI_CR2_DS_0)) {
    volatile uint8_t *spidr = (volatile uint8_t *)&spip->spi->DR;
 800aa4a:	9b01      	ldr	r3, [sp, #4]
 800aa4c:	69db      	ldr	r3, [r3, #28]
 800aa4e:	330c      	adds	r3, #12
 800aa50:	9303      	str	r3, [sp, #12]
    *spidr = (uint8_t)frame;
 800aa52:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 800aa56:	b2da      	uxtb	r2, r3
 800aa58:	9b03      	ldr	r3, [sp, #12]
 800aa5a:	701a      	strb	r2, [r3, #0]
    while ((spip->spi->SR & SPI_SR_RXNE) == 0)
 800aa5c:	bf00      	nop
 800aa5e:	9b01      	ldr	r3, [sp, #4]
 800aa60:	69db      	ldr	r3, [r3, #28]
 800aa62:	689b      	ldr	r3, [r3, #8]
 800aa64:	f003 0301 	and.w	r3, r3, #1
 800aa68:	2b00      	cmp	r3, #0
 800aa6a:	d0f8      	beq.n	800aa5e <spi_lld_polled_exchange+0x2e>
      ;
    return (uint16_t)*spidr;
 800aa6c:	9b03      	ldr	r3, [sp, #12]
 800aa6e:	781b      	ldrb	r3, [r3, #0]
 800aa70:	b2db      	uxtb	r3, r3
 800aa72:	e010      	b.n	800aa96 <spi_lld_polled_exchange+0x66>
  }
  else {
    spip->spi->DR = frame;
 800aa74:	9b01      	ldr	r3, [sp, #4]
 800aa76:	69db      	ldr	r3, [r3, #28]
 800aa78:	f8bd 2002 	ldrh.w	r2, [sp, #2]
 800aa7c:	60da      	str	r2, [r3, #12]
    while ((spip->spi->SR & SPI_SR_RXNE) == 0)
 800aa7e:	bf00      	nop
 800aa80:	9b01      	ldr	r3, [sp, #4]
 800aa82:	69db      	ldr	r3, [r3, #28]
 800aa84:	689b      	ldr	r3, [r3, #8]
 800aa86:	f003 0301 	and.w	r3, r3, #1
 800aa8a:	2b00      	cmp	r3, #0
 800aa8c:	d0f8      	beq.n	800aa80 <spi_lld_polled_exchange+0x50>
      ;
    return spip->spi->DR;
 800aa8e:	9b01      	ldr	r3, [sp, #4]
 800aa90:	69db      	ldr	r3, [r3, #28]
 800aa92:	68db      	ldr	r3, [r3, #12]
 800aa94:	b29b      	uxth	r3, r3
  }
}
 800aa96:	4618      	mov	r0, r3
 800aa98:	b004      	add	sp, #16
 800aa9a:	4770      	bx	lr
 800aa9c:	f3af 8000 	nop.w

0800aaa0 <spi_lld_polled_tx>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] frame     the data frame to send over the SPI bus
 * @return              The received data frame from the SPI bus.
 */

int spi_lld_polled_tx(SPIDriver *spip, uint8_t val) {
 800aaa0:	b084      	sub	sp, #16
 800aaa2:	9001      	str	r0, [sp, #4]
 800aaa4:	460b      	mov	r3, r1
 800aaa6:	f88d 3003 	strb.w	r3, [sp, #3]

  /* check TXE flag */
  while ((spip->spi->SR & SPI_SR_TXE) != SPI_SR_TXE);
 800aaaa:	bf00      	nop
 800aaac:	9b01      	ldr	r3, [sp, #4]
 800aaae:	69db      	ldr	r3, [r3, #28]
 800aab0:	689b      	ldr	r3, [r3, #8]
 800aab2:	f003 0302 	and.w	r3, r3, #2
 800aab6:	2b00      	cmp	r3, #0
 800aab8:	d0f8      	beq.n	800aaac <spi_lld_polled_tx+0xc>

  /* Write the data */
  volatile uint8_t *spidr = (volatile uint8_t *)&spip->spi->DR;
 800aaba:	9b01      	ldr	r3, [sp, #4]
 800aabc:	69db      	ldr	r3, [r3, #28]
 800aabe:	330c      	adds	r3, #12
 800aac0:	9303      	str	r3, [sp, #12]
  *spidr = val;
 800aac2:	9b03      	ldr	r3, [sp, #12]
 800aac4:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800aac8:	701a      	strb	r2, [r3, #0]

  /* Check to see that the Transmitter is empty */
  while (spip->spi->SR & SPI_SR_FTLVL);
 800aaca:	bf00      	nop
 800aacc:	9b01      	ldr	r3, [sp, #4]
 800aace:	69db      	ldr	r3, [r3, #28]
 800aad0:	689b      	ldr	r3, [r3, #8]
 800aad2:	f403 53c0 	and.w	r3, r3, #6144	; 0x1800
 800aad6:	2b00      	cmp	r3, #0
 800aad8:	d1f8      	bne.n	800aacc <spi_lld_polled_tx+0x2c>
  while ((spip->spi->SR & SPI_SR_BSY) == SPI_SR_BSY);
 800aada:	bf00      	nop
 800aadc:	9b01      	ldr	r3, [sp, #4]
 800aade:	69db      	ldr	r3, [r3, #28]
 800aae0:	689b      	ldr	r3, [r3, #8]
 800aae2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800aae6:	2b00      	cmp	r3, #0
 800aae8:	d1f8      	bne.n	800aadc <spi_lld_polled_tx+0x3c>

  return (0);
 800aaea:	2300      	movs	r3, #0
}
 800aaec:	4618      	mov	r0, r3
 800aaee:	b004      	add	sp, #16
 800aaf0:	4770      	bx	lr
 800aaf2:	bf00      	nop
 800aaf4:	f3af 8000 	nop.w
 800aaf8:	f3af 8000 	nop.w
 800aafc:	f3af 8000 	nop.w

0800ab00 <spi_lld_polled_rx>:

int spi_lld_polled_rx(SPIDriver *spip) {
 800ab00:	b500      	push	{lr}
 800ab02:	b085      	sub	sp, #20
 800ab04:	9001      	str	r0, [sp, #4]
  /* In master RX mode the clock is automaticaly generated on the SPI enable.
  So to guarantee the clock generation for only one data, the clock must be
  disabled after the first bit and before the latest bit */
  /* Interrupts should be disabled during this operation */

  chSysLock();
 800ab06:	f7ff fbc3 	bl	800a290 <chSysLock>
  spip->spi->CR1 |= SPI_CR1_SPE;   // Turn on the SPI 
 800ab0a:	9b01      	ldr	r3, [sp, #4]
 800ab0c:	69db      	ldr	r3, [r3, #28]
 800ab0e:	9a01      	ldr	r2, [sp, #4]
 800ab10:	69d2      	ldr	r2, [r2, #28]
 800ab12:	6812      	ldr	r2, [r2, #0]
 800ab14:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800ab18:	601a      	str	r2, [r3, #0]
  __asm("dsb\n");
 800ab1a:	f3bf 8f4f 	dsb	sy
  __asm("dsb\n");
 800ab1e:	f3bf 8f4f 	dsb	sy
  spip->spi->CR1 &= ~SPI_CR1_SPE;   // Turn off the SPI
 800ab22:	9b01      	ldr	r3, [sp, #4]
 800ab24:	69db      	ldr	r3, [r3, #28]
 800ab26:	9a01      	ldr	r2, [sp, #4]
 800ab28:	69d2      	ldr	r2, [r2, #28]
 800ab2a:	6812      	ldr	r2, [r2, #0]
 800ab2c:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800ab30:	601a      	str	r2, [r3, #0]
  chSysUnlock();
 800ab32:	f7ff fbb5 	bl	800a2a0 <chSysUnlock>
  
  while ((spip->spi->SR & SPI_SR_RXNE) != SPI_SR_RXNE);
 800ab36:	bf00      	nop
 800ab38:	9b01      	ldr	r3, [sp, #4]
 800ab3a:	69db      	ldr	r3, [r3, #28]
 800ab3c:	689b      	ldr	r3, [r3, #8]
 800ab3e:	f003 0301 	and.w	r3, r3, #1
 800ab42:	2b00      	cmp	r3, #0
 800ab44:	d0f8      	beq.n	800ab38 <spi_lld_polled_rx+0x38>
  /* read the received data */
  volatile uint8_t *spidr = (volatile uint8_t *)&spip->spi->DR;
 800ab46:	9b01      	ldr	r3, [sp, #4]
 800ab48:	69db      	ldr	r3, [r3, #28]
 800ab4a:	330c      	adds	r3, #12
 800ab4c:	9303      	str	r3, [sp, #12]
  val = *spidr;
 800ab4e:	9b03      	ldr	r3, [sp, #12]
 800ab50:	781b      	ldrb	r3, [r3, #0]
 800ab52:	f88d 300b 	strb.w	r3, [sp, #11]
  while ((spip->spi->SR & SPI_SR_BSY) == SPI_SR_BSY);
 800ab56:	bf00      	nop
 800ab58:	9b01      	ldr	r3, [sp, #4]
 800ab5a:	69db      	ldr	r3, [r3, #28]
 800ab5c:	689b      	ldr	r3, [r3, #8]
 800ab5e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800ab62:	2b00      	cmp	r3, #0
 800ab64:	d1f8      	bne.n	800ab58 <spi_lld_polled_rx+0x58>
  return (val);
 800ab66:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 800ab6a:	4618      	mov	r0, r3
 800ab6c:	b005      	add	sp, #20
 800ab6e:	f85d fb04 	ldr.w	pc, [sp], #4
 800ab72:	bf00      	nop
 800ab74:	f3af 8000 	nop.w
 800ab78:	f3af 8000 	nop.w
 800ab7c:	f3af 8000 	nop.w

0800ab80 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800ab80:	b082      	sub	sp, #8
 800ab82:	2320      	movs	r3, #32
 800ab84:	9301      	str	r3, [sp, #4]
 800ab86:	9b01      	ldr	r3, [sp, #4]
 800ab88:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800ab8c:	b002      	add	sp, #8
 800ab8e:	4770      	bx	lr

0800ab90 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800ab90:	b082      	sub	sp, #8
 800ab92:	2300      	movs	r3, #0
 800ab94:	9301      	str	r3, [sp, #4]
 800ab96:	9b01      	ldr	r3, [sp, #4]
 800ab98:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800ab9c:	b002      	add	sp, #8
 800ab9e:	4770      	bx	lr

0800aba0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800aba0:	b508      	push	{r3, lr}

  port_lock();
 800aba2:	f7ff ffed 	bl	800ab80 <port_lock>
}
 800aba6:	bd08      	pop	{r3, pc}
 800aba8:	f3af 8000 	nop.w
 800abac:	f3af 8000 	nop.w

0800abb0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800abb0:	b508      	push	{r3, lr}

  port_unlock();
 800abb2:	f7ff ffed 	bl	800ab90 <port_unlock>
}
 800abb6:	bd08      	pop	{r3, pc}
 800abb8:	f3af 8000 	nop.w
 800abbc:	f3af 8000 	nop.w

0800abc0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 800abc0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800abc2:	f7ff ffed 	bl	800aba0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 800abc6:	bd08      	pop	{r3, pc}
 800abc8:	f3af 8000 	nop.w
 800abcc:	f3af 8000 	nop.w

0800abd0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 800abd0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 800abd2:	f7ff ffed 	bl	800abb0 <port_unlock_from_isr>
}
 800abd6:	bd08      	pop	{r3, pc}
 800abd8:	f3af 8000 	nop.w
 800abdc:	f3af 8000 	nop.w

0800abe0 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 800abe0:	b082      	sub	sp, #8
 800abe2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 800abe4:	9b01      	ldr	r3, [sp, #4]
 800abe6:	695a      	ldr	r2, [r3, #20]
 800abe8:	9b01      	ldr	r3, [sp, #4]
 800abea:	699b      	ldr	r3, [r3, #24]
 800abec:	429a      	cmp	r2, r3
 800abee:	d105      	bne.n	800abfc <chOQIsEmptyI+0x1c>
 800abf0:	9b01      	ldr	r3, [sp, #4]
 800abf2:	689b      	ldr	r3, [r3, #8]
 800abf4:	2b00      	cmp	r3, #0
 800abf6:	d001      	beq.n	800abfc <chOQIsEmptyI+0x1c>
 800abf8:	2301      	movs	r3, #1
 800abfa:	e000      	b.n	800abfe <chOQIsEmptyI+0x1e>
 800abfc:	2300      	movs	r3, #0
 800abfe:	f003 0301 	and.w	r3, r3, #1
 800ac02:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 800ac04:	4618      	mov	r0, r3
 800ac06:	b002      	add	sp, #8
 800ac08:	4770      	bx	lr
 800ac0a:	bf00      	nop
 800ac0c:	f3af 8000 	nop.w

0800ac10 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 800ac10:	b508      	push	{r3, lr}

  chSysLockFromISR();
 800ac12:	f7ff ffd5 	bl	800abc0 <chSysLockFromISR>
}
 800ac16:	bd08      	pop	{r3, pc}
 800ac18:	f3af 8000 	nop.w
 800ac1c:	f3af 8000 	nop.w

0800ac20 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 800ac20:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 800ac22:	f7ff ffd5 	bl	800abd0 <chSysUnlockFromISR>
}
 800ac26:	bd08      	pop	{r3, pc}
 800ac28:	f3af 8000 	nop.w
 800ac2c:	f3af 8000 	nop.w

0800ac30 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 800ac30:	b500      	push	{lr}
 800ac32:	b083      	sub	sp, #12
 800ac34:	9001      	str	r0, [sp, #4]
 800ac36:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 800ac38:	9801      	ldr	r0, [sp, #4]
 800ac3a:	9900      	ldr	r1, [sp, #0]
 800ac3c:	f7f7 fd20 	bl	8002680 <chEvtBroadcastFlagsI>
}
 800ac40:	b003      	add	sp, #12
 800ac42:	f85d fb04 	ldr.w	pc, [sp], #4
 800ac46:	bf00      	nop
 800ac48:	f3af 8000 	nop.w
 800ac4c:	f3af 8000 	nop.w

0800ac50 <usart_init>:
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
 800ac50:	b084      	sub	sp, #16
 800ac52:	9001      	str	r0, [sp, #4]
 800ac54:	9100      	str	r1, [sp, #0]
  USART_TypeDef *u = sdp->usart;
 800ac56:	9b01      	ldr	r3, [sp, #4]
 800ac58:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800ac5a:	9303      	str	r3, [sp, #12]
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 800ac5c:	9b01      	ldr	r3, [sp, #4]
 800ac5e:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800ac60:	9b00      	ldr	r3, [sp, #0]
 800ac62:	681b      	ldr	r3, [r3, #0]
 800ac64:	fbb2 f2f3 	udiv	r2, r2, r3
 800ac68:	9b03      	ldr	r3, [sp, #12]
 800ac6a:	60da      	str	r2, [r3, #12]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800ac6c:	9b00      	ldr	r3, [sp, #0]
 800ac6e:	689b      	ldr	r3, [r3, #8]
 800ac70:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 800ac74:	9b03      	ldr	r3, [sp, #12]
 800ac76:	605a      	str	r2, [r3, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800ac78:	9b00      	ldr	r3, [sp, #0]
 800ac7a:	68db      	ldr	r3, [r3, #12]
 800ac7c:	f043 0201 	orr.w	r2, r3, #1
 800ac80:	9b03      	ldr	r3, [sp, #12]
 800ac82:	609a      	str	r2, [r3, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800ac84:	9b00      	ldr	r3, [sp, #0]
 800ac86:	685b      	ldr	r3, [r3, #4]
                         USART_CR1_RXNEIE | USART_CR1_TE |
 800ac88:	f443 7396 	orr.w	r3, r3, #300	; 0x12c
 800ac8c:	f043 0301 	orr.w	r3, r3, #1
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800ac90:	9a03      	ldr	r2, [sp, #12]
 800ac92:	6013      	str	r3, [r2, #0]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 800ac94:	9b03      	ldr	r3, [sp, #12]
 800ac96:	f04f 32ff 	mov.w	r2, #4294967295
 800ac9a:	621a      	str	r2, [r3, #32]
}
 800ac9c:	b004      	add	sp, #16
 800ac9e:	4770      	bx	lr

0800aca0 <usart_deinit>:
 * @brief   USART de-initialization.
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] u         pointer to an USART I/O block
 */
static void usart_deinit(USART_TypeDef *u) {
 800aca0:	b082      	sub	sp, #8
 800aca2:	9001      	str	r0, [sp, #4]

  u->CR1 = 0;
 800aca4:	9b01      	ldr	r3, [sp, #4]
 800aca6:	2200      	movs	r2, #0
 800aca8:	601a      	str	r2, [r3, #0]
  u->CR2 = 0;
 800acaa:	9b01      	ldr	r3, [sp, #4]
 800acac:	2200      	movs	r2, #0
 800acae:	605a      	str	r2, [r3, #4]
  u->CR3 = 0;
 800acb0:	9b01      	ldr	r3, [sp, #4]
 800acb2:	2200      	movs	r2, #0
 800acb4:	609a      	str	r2, [r3, #8]
}
 800acb6:	b002      	add	sp, #8
 800acb8:	4770      	bx	lr
 800acba:	bf00      	nop
 800acbc:	f3af 8000 	nop.w

0800acc0 <set_error>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
 800acc0:	b500      	push	{lr}
 800acc2:	b085      	sub	sp, #20
 800acc4:	9001      	str	r0, [sp, #4]
 800acc6:	9100      	str	r1, [sp, #0]
  eventflags_t sts = 0;
 800acc8:	2300      	movs	r3, #0
 800acca:	9303      	str	r3, [sp, #12]

  if (isr & USART_ISR_ORE)
 800accc:	9b00      	ldr	r3, [sp, #0]
 800acce:	f003 0308 	and.w	r3, r3, #8
 800acd2:	2b00      	cmp	r3, #0
 800acd4:	d003      	beq.n	800acde <set_error+0x1e>
    sts |= SD_OVERRUN_ERROR;
 800acd6:	9b03      	ldr	r3, [sp, #12]
 800acd8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800acdc:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_PE)
 800acde:	9b00      	ldr	r3, [sp, #0]
 800ace0:	f003 0301 	and.w	r3, r3, #1
 800ace4:	2b00      	cmp	r3, #0
 800ace6:	d003      	beq.n	800acf0 <set_error+0x30>
    sts |= SD_PARITY_ERROR;
 800ace8:	9b03      	ldr	r3, [sp, #12]
 800acea:	f043 0320 	orr.w	r3, r3, #32
 800acee:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_FE)
 800acf0:	9b00      	ldr	r3, [sp, #0]
 800acf2:	f003 0302 	and.w	r3, r3, #2
 800acf6:	2b00      	cmp	r3, #0
 800acf8:	d003      	beq.n	800ad02 <set_error+0x42>
    sts |= SD_FRAMING_ERROR;
 800acfa:	9b03      	ldr	r3, [sp, #12]
 800acfc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800ad00:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_NE)
 800ad02:	9b00      	ldr	r3, [sp, #0]
 800ad04:	f003 0304 	and.w	r3, r3, #4
 800ad08:	2b00      	cmp	r3, #0
 800ad0a:	d003      	beq.n	800ad14 <set_error+0x54>
    sts |= SD_NOISE_ERROR;
 800ad0c:	9b03      	ldr	r3, [sp, #12]
 800ad0e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800ad12:	9303      	str	r3, [sp, #12]
  osalSysLockFromISR();
 800ad14:	f7ff ff7c 	bl	800ac10 <osalSysLockFromISR>
  chnAddFlagsI(sdp, sts);
 800ad18:	9b01      	ldr	r3, [sp, #4]
 800ad1a:	3304      	adds	r3, #4
 800ad1c:	4618      	mov	r0, r3
 800ad1e:	9903      	ldr	r1, [sp, #12]
 800ad20:	f7ff ff86 	bl	800ac30 <osalEventBroadcastFlagsI>
  osalSysUnlockFromISR();
 800ad24:	f7ff ff7c 	bl	800ac20 <osalSysUnlockFromISR>
}
 800ad28:	b005      	add	sp, #20
 800ad2a:	f85d fb04 	ldr.w	pc, [sp], #4
 800ad2e:	bf00      	nop

0800ad30 <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 800ad30:	b500      	push	{lr}
 800ad32:	b087      	sub	sp, #28
 800ad34:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
 800ad36:	9b01      	ldr	r3, [sp, #4]
 800ad38:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800ad3a:	9305      	str	r3, [sp, #20]
  uint32_t cr1 = u->CR1;
 800ad3c:	9b05      	ldr	r3, [sp, #20]
 800ad3e:	681b      	ldr	r3, [r3, #0]
 800ad40:	9304      	str	r3, [sp, #16]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 800ad42:	9b05      	ldr	r3, [sp, #20]
 800ad44:	69db      	ldr	r3, [r3, #28]
 800ad46:	9303      	str	r3, [sp, #12]
  u->ICR = isr;
 800ad48:	9b05      	ldr	r3, [sp, #20]
 800ad4a:	9a03      	ldr	r2, [sp, #12]
 800ad4c:	621a      	str	r2, [r3, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 800ad4e:	9b03      	ldr	r3, [sp, #12]
 800ad50:	f003 030f 	and.w	r3, r3, #15
 800ad54:	2b00      	cmp	r3, #0
 800ad56:	d003      	beq.n	800ad60 <serve_interrupt+0x30>
    set_error(sdp, isr);
 800ad58:	9801      	ldr	r0, [sp, #4]
 800ad5a:	9903      	ldr	r1, [sp, #12]
 800ad5c:	f7ff ffb0 	bl	800acc0 <set_error>

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 800ad60:	9b03      	ldr	r3, [sp, #12]
 800ad62:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800ad66:	2b00      	cmp	r3, #0
 800ad68:	d00a      	beq.n	800ad80 <serve_interrupt+0x50>
    osalSysLockFromISR();
 800ad6a:	f7ff ff51 	bl	800ac10 <osalSysLockFromISR>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 800ad6e:	9b01      	ldr	r3, [sp, #4]
 800ad70:	3304      	adds	r3, #4
 800ad72:	4618      	mov	r0, r3
 800ad74:	f44f 7100 	mov.w	r1, #512	; 0x200
 800ad78:	f7ff ff5a 	bl	800ac30 <osalEventBroadcastFlagsI>
    osalSysUnlockFromISR();
 800ad7c:	f7ff ff50 	bl	800ac20 <osalSysUnlockFromISR>
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 800ad80:	9b03      	ldr	r3, [sp, #12]
 800ad82:	f003 0320 	and.w	r3, r3, #32
 800ad86:	2b00      	cmp	r3, #0
 800ad88:	d00b      	beq.n	800ada2 <serve_interrupt+0x72>
    osalSysLockFromISR();
 800ad8a:	f7ff ff41 	bl	800ac10 <osalSysLockFromISR>
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
 800ad8e:	9b05      	ldr	r3, [sp, #20]
 800ad90:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 800ad92:	b29b      	uxth	r3, r3
 800ad94:	b2db      	uxtb	r3, r3
 800ad96:	9801      	ldr	r0, [sp, #4]
 800ad98:	4619      	mov	r1, r3
 800ad9a:	f7fb f899 	bl	8005ed0 <sdIncomingDataI>
    osalSysUnlockFromISR();
 800ad9e:	f7ff ff3f 	bl	800ac20 <osalSysUnlockFromISR>
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 800ada2:	9b04      	ldr	r3, [sp, #16]
 800ada4:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800ada8:	2b00      	cmp	r3, #0
 800adaa:	d023      	beq.n	800adf4 <serve_interrupt+0xc4>
 800adac:	9b03      	ldr	r3, [sp, #12]
 800adae:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800adb2:	2b00      	cmp	r3, #0
 800adb4:	d01e      	beq.n	800adf4 <serve_interrupt+0xc4>
    msg_t b;
    osalSysLockFromISR();
 800adb6:	f7ff ff2b 	bl	800ac10 <osalSysLockFromISR>
    b = oqGetI(&sdp->oqueue);
 800adba:	9b01      	ldr	r3, [sp, #4]
 800adbc:	3330      	adds	r3, #48	; 0x30
 800adbe:	4618      	mov	r0, r3
 800adc0:	f7f8 fb8e 	bl	80034e0 <chOQGetI>
 800adc4:	9002      	str	r0, [sp, #8]
    if (b < Q_OK) {
 800adc6:	9b02      	ldr	r3, [sp, #8]
 800adc8:	2b00      	cmp	r3, #0
 800adca:	da0d      	bge.n	800ade8 <serve_interrupt+0xb8>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 800adcc:	9b01      	ldr	r3, [sp, #4]
 800adce:	3304      	adds	r3, #4
 800add0:	4618      	mov	r0, r3
 800add2:	2108      	movs	r1, #8
 800add4:	f7ff ff2c 	bl	800ac30 <osalEventBroadcastFlagsI>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 800add8:	9b04      	ldr	r3, [sp, #16]
 800adda:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 800adde:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 800ade2:	9b05      	ldr	r3, [sp, #20]
 800ade4:	601a      	str	r2, [r3, #0]
 800ade6:	e003      	b.n	800adf0 <serve_interrupt+0xc0>
    }
    else
      u->TDR = b;
 800ade8:	9b02      	ldr	r3, [sp, #8]
 800adea:	b29a      	uxth	r2, r3
 800adec:	9b05      	ldr	r3, [sp, #20]
 800adee:	851a      	strh	r2, [r3, #40]	; 0x28
    osalSysUnlockFromISR();
 800adf0:	f7ff ff16 	bl	800ac20 <osalSysUnlockFromISR>
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 800adf4:	9b03      	ldr	r3, [sp, #12]
 800adf6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800adfa:	2b00      	cmp	r3, #0
 800adfc:	d016      	beq.n	800ae2c <serve_interrupt+0xfc>
    osalSysLockFromISR();
 800adfe:	f7ff ff07 	bl	800ac10 <osalSysLockFromISR>
    if (oqIsEmptyI(&sdp->oqueue))
 800ae02:	9b01      	ldr	r3, [sp, #4]
 800ae04:	3330      	adds	r3, #48	; 0x30
 800ae06:	4618      	mov	r0, r3
 800ae08:	f7ff feea 	bl	800abe0 <chOQIsEmptyI>
 800ae0c:	4603      	mov	r3, r0
 800ae0e:	2b00      	cmp	r3, #0
 800ae10:	d005      	beq.n	800ae1e <serve_interrupt+0xee>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 800ae12:	9b01      	ldr	r3, [sp, #4]
 800ae14:	3304      	adds	r3, #4
 800ae16:	4618      	mov	r0, r3
 800ae18:	2110      	movs	r1, #16
 800ae1a:	f7ff ff09 	bl	800ac30 <osalEventBroadcastFlagsI>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 800ae1e:	9b04      	ldr	r3, [sp, #16]
 800ae20:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 800ae24:	9b05      	ldr	r3, [sp, #20]
 800ae26:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 800ae28:	f7ff fefa 	bl	800ac20 <osalSysUnlockFromISR>
  }
}
 800ae2c:	b007      	add	sp, #28
 800ae2e:	f85d fb04 	ldr.w	pc, [sp], #4
 800ae32:	bf00      	nop
 800ae34:	f3af 8000 	nop.w
 800ae38:	f3af 8000 	nop.w
 800ae3c:	f3af 8000 	nop.w

0800ae40 <notify5>:
  UART4->CR1 |= USART_CR1_TXEIE;
}
#endif

#if STM32_SERIAL_USE_UART5 || defined(__DOXYGEN__)
static void notify5(io_queue_t *qp) {
 800ae40:	b082      	sub	sp, #8
 800ae42:	9001      	str	r0, [sp, #4]

  (void)qp;
  UART5->CR1 |= USART_CR1_TXEIE;
 800ae44:	4b03      	ldr	r3, [pc, #12]	; (800ae54 <notify5+0x14>)
 800ae46:	4a03      	ldr	r2, [pc, #12]	; (800ae54 <notify5+0x14>)
 800ae48:	6812      	ldr	r2, [r2, #0]
 800ae4a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800ae4e:	601a      	str	r2, [r3, #0]
}
 800ae50:	b002      	add	sp, #8
 800ae52:	4770      	bx	lr
 800ae54:	40005000 	.word	0x40005000
 800ae58:	f3af 8000 	nop.w
 800ae5c:	f3af 8000 	nop.w

0800ae60 <Vector114>:
/**
 * @brief   UART5 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_UART5_HANDLER) {
 800ae60:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD5);
 800ae62:	4803      	ldr	r0, [pc, #12]	; (800ae70 <Vector114+0x10>)
 800ae64:	f7ff ff64 	bl	800ad30 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 800ae68:	f7f8 fe72 	bl	8003b50 <_port_irq_epilogue>
}
 800ae6c:	bd08      	pop	{r3, pc}
 800ae6e:	bf00      	nop
 800ae70:	200011a4 	.word	0x200011a4
 800ae74:	f3af 8000 	nop.w
 800ae78:	f3af 8000 	nop.w
 800ae7c:	f3af 8000 	nop.w

0800ae80 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 800ae80:	b508      	push	{r3, lr}
  nvicEnableVector(STM32_UART4_NUMBER, STM32_SERIAL_UART4_PRIORITY);
#endif
#endif

#if STM32_SERIAL_USE_UART5
  sdObjectInit(&SD5, NULL, notify5);
 800ae82:	4808      	ldr	r0, [pc, #32]	; (800aea4 <sd_lld_init+0x24>)
 800ae84:	2100      	movs	r1, #0
 800ae86:	4a08      	ldr	r2, [pc, #32]	; (800aea8 <sd_lld_init+0x28>)
 800ae88:	f7fa ffba 	bl	8005e00 <sdObjectInit>
  SD5.usart = UART5;
 800ae8c:	4b05      	ldr	r3, [pc, #20]	; (800aea4 <sd_lld_init+0x24>)
 800ae8e:	4a07      	ldr	r2, [pc, #28]	; (800aeac <sd_lld_init+0x2c>)
 800ae90:	675a      	str	r2, [r3, #116]	; 0x74
  SD5.clock = STM32_UART5CLK;
 800ae92:	4b04      	ldr	r3, [pc, #16]	; (800aea4 <sd_lld_init+0x24>)
 800ae94:	4a06      	ldr	r2, [pc, #24]	; (800aeb0 <sd_lld_init+0x30>)
 800ae96:	679a      	str	r2, [r3, #120]	; 0x78
#if defined(STM32_UART5_NUMBER)
  nvicEnableVector(STM32_UART5_NUMBER, STM32_SERIAL_UART5_PRIORITY);
 800ae98:	2035      	movs	r0, #53	; 0x35
 800ae9a:	210c      	movs	r1, #12
 800ae9c:	f7fc f870 	bl	8006f80 <nvicEnableVector>
    STM32_SERIAL_USE_UART7  ||  STM32_SERIAL_USE_UART8 || defined(__DOXYGEN__)
#if defined(STM32_USART3_8_HANDLER)
  nvicEnableVector(STM32_USART3_8_NUMBER, STM32_SERIAL_USART3_8_PRIORITY);
#endif
#endif
}
 800aea0:	bd08      	pop	{r3, pc}
 800aea2:	bf00      	nop
 800aea4:	200011a4 	.word	0x200011a4
 800aea8:	0800ae41 	.word	0x0800ae41
 800aeac:	40005000 	.word	0x40005000
 800aeb0:	04c4b400 	.word	0x04c4b400
 800aeb4:	f3af 8000 	nop.w
 800aeb8:	f3af 8000 	nop.w
 800aebc:	f3af 8000 	nop.w

0800aec0 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 800aec0:	b500      	push	{lr}
 800aec2:	b083      	sub	sp, #12
 800aec4:	9001      	str	r0, [sp, #4]
 800aec6:	9100      	str	r1, [sp, #0]

  if (config == NULL)
 800aec8:	9b00      	ldr	r3, [sp, #0]
 800aeca:	2b00      	cmp	r3, #0
 800aecc:	d101      	bne.n	800aed2 <sd_lld_start+0x12>
    config = &default_config;
 800aece:	4b0b      	ldr	r3, [pc, #44]	; (800aefc <sd_lld_start+0x3c>)
 800aed0:	9300      	str	r3, [sp, #0]

  if (sdp->state == SD_STOP) {
 800aed2:	9b01      	ldr	r3, [sp, #4]
 800aed4:	7a1b      	ldrb	r3, [r3, #8]
 800aed6:	2b01      	cmp	r3, #1
 800aed8:	d109      	bne.n	800aeee <sd_lld_start+0x2e>
    if (&SD4 == sdp) {
      rccEnableUART4(FALSE);
    }
#endif
#if STM32_SERIAL_USE_UART5
    if (&SD5 == sdp) {
 800aeda:	9a01      	ldr	r2, [sp, #4]
 800aedc:	4b08      	ldr	r3, [pc, #32]	; (800af00 <sd_lld_start+0x40>)
 800aede:	429a      	cmp	r2, r3
 800aee0:	d105      	bne.n	800aeee <sd_lld_start+0x2e>
      rccEnableUART5(FALSE);
 800aee2:	4b08      	ldr	r3, [pc, #32]	; (800af04 <sd_lld_start+0x44>)
 800aee4:	4a07      	ldr	r2, [pc, #28]	; (800af04 <sd_lld_start+0x44>)
 800aee6:	6d92      	ldr	r2, [r2, #88]	; 0x58
 800aee8:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 800aeec:	659a      	str	r2, [r3, #88]	; 0x58
    if (&LPSD1 == sdp) {
      rccEnableLPUART1(FALSE);
    }
#endif
  }
  usart_init(sdp, config);
 800aeee:	9801      	ldr	r0, [sp, #4]
 800aef0:	9900      	ldr	r1, [sp, #0]
 800aef2:	f7ff fead 	bl	800ac50 <usart_init>
}
 800aef6:	b003      	add	sp, #12
 800aef8:	f85d fb04 	ldr.w	pc, [sp], #4
 800aefc:	08016110 	.word	0x08016110
 800af00:	200011a4 	.word	0x200011a4
 800af04:	40021000 	.word	0x40021000
 800af08:	f3af 8000 	nop.w
 800af0c:	f3af 8000 	nop.w

0800af10 <sd_lld_stop>:
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 *
 * @notapi
 */
void sd_lld_stop(SerialDriver *sdp) {
 800af10:	b500      	push	{lr}
 800af12:	b083      	sub	sp, #12
 800af14:	9001      	str	r0, [sp, #4]

  if (sdp->state == SD_READY) {
 800af16:	9b01      	ldr	r3, [sp, #4]
 800af18:	7a1b      	ldrb	r3, [r3, #8]
 800af1a:	2b02      	cmp	r3, #2
 800af1c:	d10f      	bne.n	800af3e <sd_lld_stop+0x2e>
    /* UART is de-initialized then clocks are disabled.*/
    usart_deinit(sdp->usart);
 800af1e:	9b01      	ldr	r3, [sp, #4]
 800af20:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800af22:	4618      	mov	r0, r3
 800af24:	f7ff febc 	bl	800aca0 <usart_deinit>
      rccDisableUART4(FALSE);
      return;
    }
#endif
#if STM32_SERIAL_USE_UART5
    if (&SD5 == sdp) {
 800af28:	9a01      	ldr	r2, [sp, #4]
 800af2a:	4b06      	ldr	r3, [pc, #24]	; (800af44 <sd_lld_stop+0x34>)
 800af2c:	429a      	cmp	r2, r3
 800af2e:	d106      	bne.n	800af3e <sd_lld_stop+0x2e>
      rccDisableUART5(FALSE);
 800af30:	4b05      	ldr	r3, [pc, #20]	; (800af48 <sd_lld_stop+0x38>)
 800af32:	4a05      	ldr	r2, [pc, #20]	; (800af48 <sd_lld_stop+0x38>)
 800af34:	6d92      	ldr	r2, [r2, #88]	; 0x58
 800af36:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 800af3a:	659a      	str	r2, [r3, #88]	; 0x58
      return;
 800af3c:	bf00      	nop
      rccDisableLPUART1(FALSE);
      return;
    }
#endif
  }
}
 800af3e:	b003      	add	sp, #12
 800af40:	f85d fb04 	ldr.w	pc, [sp], #4
 800af44:	200011a4 	.word	0x200011a4
 800af48:	40021000 	.word	0x40021000
 800af4c:	f3af 8000 	nop.w

0800af50 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 800af50:	b508      	push	{r3, lr}

  stm32_clock_init();
 800af52:	f7fc f915 	bl	8007180 <stm32_clock_init>
}
 800af56:	bd08      	pop	{r3, pc}
 800af58:	f3af 8000 	nop.w
 800af5c:	f3af 8000 	nop.w

0800af60 <sdc_lld_is_card_inserted>:

#if HAL_USE_SDC || defined(__DOXYGEN__)
/**
 * @brief   SDC card detection.
 */
bool sdc_lld_is_card_inserted(SDCDriver *sdcp) {
 800af60:	b082      	sub	sp, #8
 800af62:	9001      	str	r0, [sp, #4]

  (void)sdcp;
  /* TODO: Fill the implementation.*/
  return true;
 800af64:	2301      	movs	r3, #1
}
 800af66:	4618      	mov	r0, r3
 800af68:	b002      	add	sp, #8
 800af6a:	4770      	bx	lr
 800af6c:	f3af 8000 	nop.w

0800af70 <sdc_lld_is_write_protected>:

/**
 * @brief   SDC card write protection detection.
 */
bool sdc_lld_is_write_protected(SDCDriver *sdcp) {
 800af70:	b082      	sub	sp, #8
 800af72:	9001      	str	r0, [sp, #4]

  (void)sdcp;
  /* TODO: Fill the implementation.*/
  return false;
 800af74:	2300      	movs	r3, #0
}
 800af76:	4618      	mov	r0, r3
 800af78:	b002      	add	sp, #8
 800af7a:	4770      	bx	lr
 800af7c:	f3af 8000 	nop.w

0800af80 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
 800af80:	4770      	bx	lr
 800af82:	bf00      	nop
 800af84:	f3af 8000 	nop.w
 800af88:	f3af 8000 	nop.w
 800af8c:	f3af 8000 	nop.w

0800af90 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800af90:	b082      	sub	sp, #8
 800af92:	2320      	movs	r3, #32
 800af94:	9301      	str	r3, [sp, #4]
 800af96:	9b01      	ldr	r3, [sp, #4]
 800af98:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800af9c:	b002      	add	sp, #8
 800af9e:	4770      	bx	lr

0800afa0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800afa0:	b082      	sub	sp, #8
 800afa2:	2300      	movs	r3, #0
 800afa4:	9301      	str	r3, [sp, #4]
 800afa6:	9b01      	ldr	r3, [sp, #4]
 800afa8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800afac:	b002      	add	sp, #8
 800afae:	4770      	bx	lr

0800afb0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800afb0:	b508      	push	{r3, lr}

  port_lock();
 800afb2:	f7ff ffed 	bl	800af90 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800afb6:	bd08      	pop	{r3, pc}
 800afb8:	f3af 8000 	nop.w
 800afbc:	f3af 8000 	nop.w

0800afc0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800afc0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800afc2:	f7ff ffed 	bl	800afa0 <port_unlock>
}
 800afc6:	bd08      	pop	{r3, pc}
 800afc8:	f3af 8000 	nop.w
 800afcc:	f3af 8000 	nop.w

0800afd0 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 800afd0:	4b01      	ldr	r3, [pc, #4]	; (800afd8 <chVTGetSystemTimeX+0x8>)
 800afd2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800afd4:	4618      	mov	r0, r3
 800afd6:	4770      	bx	lr
 800afd8:	20000d98 	.word	0x20000d98
 800afdc:	f3af 8000 	nop.w

0800afe0 <chVTGetSystemTime>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 800afe0:	b500      	push	{lr}
 800afe2:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 800afe4:	f7ff ffe4 	bl	800afb0 <chSysLock>
  systime = chVTGetSystemTimeX();
 800afe8:	f7ff fff2 	bl	800afd0 <chVTGetSystemTimeX>
 800afec:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 800afee:	f7ff ffe7 	bl	800afc0 <chSysUnlock>

  return systime;
 800aff2:	9b01      	ldr	r3, [sp, #4]
}
 800aff4:	4618      	mov	r0, r3
 800aff6:	b003      	add	sp, #12
 800aff8:	f85d fb04 	ldr.w	pc, [sp], #4
 800affc:	f3af 8000 	nop.w

0800b000 <chVTIsTimeWithinX>:
 *
 * @xclass
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {
 800b000:	b084      	sub	sp, #16
 800b002:	9003      	str	r0, [sp, #12]
 800b004:	9102      	str	r1, [sp, #8]
 800b006:	9201      	str	r2, [sp, #4]

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 800b008:	9a03      	ldr	r2, [sp, #12]
 800b00a:	9b02      	ldr	r3, [sp, #8]
 800b00c:	1ad2      	subs	r2, r2, r3
 800b00e:	9901      	ldr	r1, [sp, #4]
 800b010:	9b02      	ldr	r3, [sp, #8]
 800b012:	1acb      	subs	r3, r1, r3
 800b014:	429a      	cmp	r2, r3
 800b016:	bf2c      	ite	cs
 800b018:	2300      	movcs	r3, #0
 800b01a:	2301      	movcc	r3, #1
 800b01c:	b2db      	uxtb	r3, r3
}
 800b01e:	4618      	mov	r0, r3
 800b020:	b004      	add	sp, #16
 800b022:	4770      	bx	lr
 800b024:	f3af 8000 	nop.w
 800b028:	f3af 8000 	nop.w
 800b02c:	f3af 8000 	nop.w

0800b030 <chVTIsSystemTimeWithin>:
 * @retval true         current time within the specified time window.
 * @retval false        current time not within the specified time window.
 *
 * @api
 */
static inline bool chVTIsSystemTimeWithin(systime_t start, systime_t end) {
 800b030:	b500      	push	{lr}
 800b032:	b083      	sub	sp, #12
 800b034:	9001      	str	r0, [sp, #4]
 800b036:	9100      	str	r1, [sp, #0]

  return chVTIsTimeWithinX(chVTGetSystemTime(), start, end);
 800b038:	f7ff ffd2 	bl	800afe0 <chVTGetSystemTime>
 800b03c:	4603      	mov	r3, r0
 800b03e:	4618      	mov	r0, r3
 800b040:	9901      	ldr	r1, [sp, #4]
 800b042:	9a00      	ldr	r2, [sp, #0]
 800b044:	f7ff ffdc 	bl	800b000 <chVTIsTimeWithinX>
 800b048:	4603      	mov	r3, r0
}
 800b04a:	4618      	mov	r0, r3
 800b04c:	b003      	add	sp, #12
 800b04e:	f85d fb04 	ldr.w	pc, [sp], #4
 800b052:	bf00      	nop
 800b054:	f3af 8000 	nop.w
 800b058:	f3af 8000 	nop.w
 800b05c:	f3af 8000 	nop.w

0800b060 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 800b060:	b082      	sub	sp, #8
 800b062:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->vt_func != NULL);
 800b064:	9b01      	ldr	r3, [sp, #4]
 800b066:	68db      	ldr	r3, [r3, #12]
 800b068:	2b00      	cmp	r3, #0
 800b06a:	bf0c      	ite	eq
 800b06c:	2300      	moveq	r3, #0
 800b06e:	2301      	movne	r3, #1
 800b070:	b2db      	uxtb	r3, r3
}
 800b072:	4618      	mov	r0, r3
 800b074:	b002      	add	sp, #8
 800b076:	4770      	bx	lr
 800b078:	f3af 8000 	nop.w
 800b07c:	f3af 8000 	nop.w

0800b080 <chVTResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {
 800b080:	b500      	push	{lr}
 800b082:	b083      	sub	sp, #12
 800b084:	9001      	str	r0, [sp, #4]

  if (chVTIsArmedI(vtp)) {
 800b086:	9801      	ldr	r0, [sp, #4]
 800b088:	f7ff ffea 	bl	800b060 <chVTIsArmedI>
 800b08c:	4603      	mov	r3, r0
 800b08e:	2b00      	cmp	r3, #0
 800b090:	d002      	beq.n	800b098 <chVTResetI+0x18>
    chVTDoResetI(vtp);
 800b092:	9801      	ldr	r0, [sp, #4]
 800b094:	f7f5 fcbc 	bl	8000a10 <chVTDoResetI>
  }
}
 800b098:	b003      	add	sp, #12
 800b09a:	f85d fb04 	ldr.w	pc, [sp], #4
 800b09e:	bf00      	nop

0800b0a0 <chVTSetI>:
 *                      function
 *
 * @iclass
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {
 800b0a0:	b500      	push	{lr}
 800b0a2:	b085      	sub	sp, #20
 800b0a4:	9003      	str	r0, [sp, #12]
 800b0a6:	9102      	str	r1, [sp, #8]
 800b0a8:	9201      	str	r2, [sp, #4]
 800b0aa:	9300      	str	r3, [sp, #0]

  chVTResetI(vtp);
 800b0ac:	9803      	ldr	r0, [sp, #12]
 800b0ae:	f7ff ffe7 	bl	800b080 <chVTResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
 800b0b2:	9803      	ldr	r0, [sp, #12]
 800b0b4:	9902      	ldr	r1, [sp, #8]
 800b0b6:	9a01      	ldr	r2, [sp, #4]
 800b0b8:	9b00      	ldr	r3, [sp, #0]
 800b0ba:	f7f5 fc69 	bl	8000990 <chVTDoSetI>
}
 800b0be:	b005      	add	sp, #20
 800b0c0:	f85d fb04 	ldr.w	pc, [sp], #4
 800b0c4:	f3af 8000 	nop.w
 800b0c8:	f3af 8000 	nop.w
 800b0cc:	f3af 8000 	nop.w

0800b0d0 <chVTSet>:
 *                      function
 *
 * @api
 */
static inline void chVTSet(virtual_timer_t *vtp, systime_t delay,
                           vtfunc_t vtfunc, void *par) {
 800b0d0:	b500      	push	{lr}
 800b0d2:	b085      	sub	sp, #20
 800b0d4:	9003      	str	r0, [sp, #12]
 800b0d6:	9102      	str	r1, [sp, #8]
 800b0d8:	9201      	str	r2, [sp, #4]
 800b0da:	9300      	str	r3, [sp, #0]

  chSysLock();
 800b0dc:	f7ff ff68 	bl	800afb0 <chSysLock>
  chVTSetI(vtp, delay, vtfunc, par);
 800b0e0:	9803      	ldr	r0, [sp, #12]
 800b0e2:	9902      	ldr	r1, [sp, #8]
 800b0e4:	9a01      	ldr	r2, [sp, #4]
 800b0e6:	9b00      	ldr	r3, [sp, #0]
 800b0e8:	f7ff ffda 	bl	800b0a0 <chVTSetI>
  chSysUnlock();
 800b0ec:	f7ff ff68 	bl	800afc0 <chSysUnlock>
}
 800b0f0:	b005      	add	sp, #20
 800b0f2:	f85d fb04 	ldr.w	pc, [sp], #4
 800b0f6:	bf00      	nop
 800b0f8:	f3af 8000 	nop.w
 800b0fc:	f3af 8000 	nop.w

0800b100 <test_printn>:
/**
 * @brief   Prints a decimal unsigned number.
 *
 * @param[in] n         the number to be printed
 */
void test_printn(uint32_t n) {
 800b100:	b500      	push	{lr}
 800b102:	b089      	sub	sp, #36	; 0x24
 800b104:	9001      	str	r0, [sp, #4]
  char buf[16], *p;

  if (!n)
 800b106:	9b01      	ldr	r3, [sp, #4]
 800b108:	2b00      	cmp	r3, #0
 800b10a:	d109      	bne.n	800b120 <test_printn+0x20>
    chSequentialStreamPut(chp, '0');
 800b10c:	4b1e      	ldr	r3, [pc, #120]	; (800b188 <test_printn+0x88>)
 800b10e:	681b      	ldr	r3, [r3, #0]
 800b110:	681b      	ldr	r3, [r3, #0]
 800b112:	689b      	ldr	r3, [r3, #8]
 800b114:	4a1c      	ldr	r2, [pc, #112]	; (800b188 <test_printn+0x88>)
 800b116:	6812      	ldr	r2, [r2, #0]
 800b118:	4610      	mov	r0, r2
 800b11a:	2130      	movs	r1, #48	; 0x30
 800b11c:	4798      	blx	r3
 800b11e:	e02f      	b.n	800b180 <test_printn+0x80>
  else {
    p = buf;
 800b120:	ab03      	add	r3, sp, #12
 800b122:	9307      	str	r3, [sp, #28]
    while (n)
 800b124:	e016      	b.n	800b154 <test_printn+0x54>
      *p++ = (n % 10) + '0', n /= 10;
 800b126:	9907      	ldr	r1, [sp, #28]
 800b128:	1c4b      	adds	r3, r1, #1
 800b12a:	9307      	str	r3, [sp, #28]
 800b12c:	9801      	ldr	r0, [sp, #4]
 800b12e:	4b17      	ldr	r3, [pc, #92]	; (800b18c <test_printn+0x8c>)
 800b130:	fba3 2300 	umull	r2, r3, r3, r0
 800b134:	08da      	lsrs	r2, r3, #3
 800b136:	4613      	mov	r3, r2
 800b138:	009b      	lsls	r3, r3, #2
 800b13a:	4413      	add	r3, r2
 800b13c:	005b      	lsls	r3, r3, #1
 800b13e:	1ac2      	subs	r2, r0, r3
 800b140:	b2d3      	uxtb	r3, r2
 800b142:	3330      	adds	r3, #48	; 0x30
 800b144:	b2db      	uxtb	r3, r3
 800b146:	700b      	strb	r3, [r1, #0]
 800b148:	9a01      	ldr	r2, [sp, #4]
 800b14a:	4b10      	ldr	r3, [pc, #64]	; (800b18c <test_printn+0x8c>)
 800b14c:	fba3 1302 	umull	r1, r3, r3, r2
 800b150:	08db      	lsrs	r3, r3, #3
 800b152:	9301      	str	r3, [sp, #4]

  if (!n)
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
 800b154:	9b01      	ldr	r3, [sp, #4]
 800b156:	2b00      	cmp	r3, #0
 800b158:	d1e5      	bne.n	800b126 <test_printn+0x26>
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 800b15a:	e00d      	b.n	800b178 <test_printn+0x78>
      chSequentialStreamPut(chp, *--p);
 800b15c:	4b0a      	ldr	r3, [pc, #40]	; (800b188 <test_printn+0x88>)
 800b15e:	681b      	ldr	r3, [r3, #0]
 800b160:	681b      	ldr	r3, [r3, #0]
 800b162:	689b      	ldr	r3, [r3, #8]
 800b164:	4a08      	ldr	r2, [pc, #32]	; (800b188 <test_printn+0x88>)
 800b166:	6811      	ldr	r1, [r2, #0]
 800b168:	9a07      	ldr	r2, [sp, #28]
 800b16a:	3a01      	subs	r2, #1
 800b16c:	9207      	str	r2, [sp, #28]
 800b16e:	9a07      	ldr	r2, [sp, #28]
 800b170:	7812      	ldrb	r2, [r2, #0]
 800b172:	4608      	mov	r0, r1
 800b174:	4611      	mov	r1, r2
 800b176:	4798      	blx	r3
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 800b178:	ab03      	add	r3, sp, #12
 800b17a:	9a07      	ldr	r2, [sp, #28]
 800b17c:	429a      	cmp	r2, r3
 800b17e:	d8ed      	bhi.n	800b15c <test_printn+0x5c>
      chSequentialStreamPut(chp, *--p);
  }
}
 800b180:	b009      	add	sp, #36	; 0x24
 800b182:	f85d fb04 	ldr.w	pc, [sp], #4
 800b186:	bf00      	nop
 800b188:	20000b64 	.word	0x20000b64
 800b18c:	cccccccd 	.word	0xcccccccd

0800b190 <test_print>:
/**
 * @brief   Prints a line without final end-of-line.
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {
 800b190:	b500      	push	{lr}
 800b192:	b083      	sub	sp, #12
 800b194:	9001      	str	r0, [sp, #4]

  while (*msgp)
 800b196:	e00c      	b.n	800b1b2 <test_print+0x22>
    chSequentialStreamPut(chp, *msgp++);
 800b198:	4b09      	ldr	r3, [pc, #36]	; (800b1c0 <test_print+0x30>)
 800b19a:	681b      	ldr	r3, [r3, #0]
 800b19c:	681b      	ldr	r3, [r3, #0]
 800b19e:	689a      	ldr	r2, [r3, #8]
 800b1a0:	4b07      	ldr	r3, [pc, #28]	; (800b1c0 <test_print+0x30>)
 800b1a2:	6819      	ldr	r1, [r3, #0]
 800b1a4:	9b01      	ldr	r3, [sp, #4]
 800b1a6:	1c58      	adds	r0, r3, #1
 800b1a8:	9001      	str	r0, [sp, #4]
 800b1aa:	781b      	ldrb	r3, [r3, #0]
 800b1ac:	4608      	mov	r0, r1
 800b1ae:	4619      	mov	r1, r3
 800b1b0:	4790      	blx	r2
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 800b1b2:	9b01      	ldr	r3, [sp, #4]
 800b1b4:	781b      	ldrb	r3, [r3, #0]
 800b1b6:	2b00      	cmp	r3, #0
 800b1b8:	d1ee      	bne.n	800b198 <test_print+0x8>
    chSequentialStreamPut(chp, *msgp++);
}
 800b1ba:	b003      	add	sp, #12
 800b1bc:	f85d fb04 	ldr.w	pc, [sp], #4
 800b1c0:	20000b64 	.word	0x20000b64
 800b1c4:	f3af 8000 	nop.w
 800b1c8:	f3af 8000 	nop.w
 800b1cc:	f3af 8000 	nop.w

0800b1d0 <test_println>:
/**
 * @brief   Prints a line.
 *
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {
 800b1d0:	b500      	push	{lr}
 800b1d2:	b083      	sub	sp, #12
 800b1d4:	9001      	str	r0, [sp, #4]

  test_print(msgp);
 800b1d6:	9801      	ldr	r0, [sp, #4]
 800b1d8:	f7ff ffda 	bl	800b190 <test_print>
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 800b1dc:	4b06      	ldr	r3, [pc, #24]	; (800b1f8 <test_println+0x28>)
 800b1de:	681b      	ldr	r3, [r3, #0]
 800b1e0:	681b      	ldr	r3, [r3, #0]
 800b1e2:	681b      	ldr	r3, [r3, #0]
 800b1e4:	4a04      	ldr	r2, [pc, #16]	; (800b1f8 <test_println+0x28>)
 800b1e6:	6812      	ldr	r2, [r2, #0]
 800b1e8:	4610      	mov	r0, r2
 800b1ea:	4904      	ldr	r1, [pc, #16]	; (800b1fc <test_println+0x2c>)
 800b1ec:	2202      	movs	r2, #2
 800b1ee:	4798      	blx	r3
}
 800b1f0:	b003      	add	sp, #12
 800b1f2:	f85d fb04 	ldr.w	pc, [sp], #4
 800b1f6:	bf00      	nop
 800b1f8:	20000b64 	.word	0x20000b64
 800b1fc:	08016254 	.word	0x08016254

0800b200 <clear_tokens>:
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 800b200:	4b01      	ldr	r3, [pc, #4]	; (800b208 <clear_tokens+0x8>)
 800b202:	4a02      	ldr	r2, [pc, #8]	; (800b20c <clear_tokens+0xc>)
 800b204:	601a      	str	r2, [r3, #0]
}
 800b206:	4770      	bx	lr
 800b208:	20000b60 	.word	0x20000b60
 800b20c:	20000b50 	.word	0x20000b50

0800b210 <print_tokens>:

static void print_tokens(void) {
 800b210:	b500      	push	{lr}
 800b212:	b083      	sub	sp, #12
  char *cp = tokens_buffer;
 800b214:	4b0b      	ldr	r3, [pc, #44]	; (800b244 <print_tokens+0x34>)
 800b216:	9301      	str	r3, [sp, #4]

  while (cp < tokp)
 800b218:	e00c      	b.n	800b234 <print_tokens+0x24>
    chSequentialStreamPut(chp, *cp++);
 800b21a:	4b0b      	ldr	r3, [pc, #44]	; (800b248 <print_tokens+0x38>)
 800b21c:	681b      	ldr	r3, [r3, #0]
 800b21e:	681b      	ldr	r3, [r3, #0]
 800b220:	689a      	ldr	r2, [r3, #8]
 800b222:	4b09      	ldr	r3, [pc, #36]	; (800b248 <print_tokens+0x38>)
 800b224:	6819      	ldr	r1, [r3, #0]
 800b226:	9b01      	ldr	r3, [sp, #4]
 800b228:	1c58      	adds	r0, r3, #1
 800b22a:	9001      	str	r0, [sp, #4]
 800b22c:	781b      	ldrb	r3, [r3, #0]
 800b22e:	4608      	mov	r0, r1
 800b230:	4619      	mov	r1, r3
 800b232:	4790      	blx	r2
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 800b234:	4b05      	ldr	r3, [pc, #20]	; (800b24c <print_tokens+0x3c>)
 800b236:	681b      	ldr	r3, [r3, #0]
 800b238:	9a01      	ldr	r2, [sp, #4]
 800b23a:	429a      	cmp	r2, r3
 800b23c:	d3ed      	bcc.n	800b21a <print_tokens+0xa>
    chSequentialStreamPut(chp, *cp++);
}
 800b23e:	b003      	add	sp, #12
 800b240:	f85d fb04 	ldr.w	pc, [sp], #4
 800b244:	20000b50 	.word	0x20000b50
 800b248:	20000b64 	.word	0x20000b64
 800b24c:	20000b60 	.word	0x20000b60

0800b250 <test_emit_token>:
/**
 * @brief   Emits a token into the tokens buffer.
 *
 * @param[in] token     the token as a char
 */
void test_emit_token(char token) {
 800b250:	b500      	push	{lr}
 800b252:	b083      	sub	sp, #12
 800b254:	4603      	mov	r3, r0
 800b256:	f88d 3007 	strb.w	r3, [sp, #7]

  chSysLock();
 800b25a:	f7ff fea9 	bl	800afb0 <chSysLock>
  *tokp++ = token;
 800b25e:	4b06      	ldr	r3, [pc, #24]	; (800b278 <test_emit_token+0x28>)
 800b260:	681b      	ldr	r3, [r3, #0]
 800b262:	1c59      	adds	r1, r3, #1
 800b264:	4a04      	ldr	r2, [pc, #16]	; (800b278 <test_emit_token+0x28>)
 800b266:	6011      	str	r1, [r2, #0]
 800b268:	f89d 2007 	ldrb.w	r2, [sp, #7]
 800b26c:	701a      	strb	r2, [r3, #0]
  chSysUnlock();
 800b26e:	f7ff fea7 	bl	800afc0 <chSysUnlock>
}
 800b272:	b003      	add	sp, #12
 800b274:	f85d fb04 	ldr.w	pc, [sp], #4
 800b278:	20000b60 	.word	0x20000b60
 800b27c:	f3af 8000 	nop.w

0800b280 <_test_fail>:

/*
 * Assertions.
 */
bool _test_fail(unsigned point) {
 800b280:	b082      	sub	sp, #8
 800b282:	9001      	str	r0, [sp, #4]

  test_global_fail = TRUE;
 800b284:	4b06      	ldr	r3, [pc, #24]	; (800b2a0 <_test_fail+0x20>)
 800b286:	2201      	movs	r2, #1
 800b288:	701a      	strb	r2, [r3, #0]
  local_fail = TRUE;
 800b28a:	4b06      	ldr	r3, [pc, #24]	; (800b2a4 <_test_fail+0x24>)
 800b28c:	2201      	movs	r2, #1
 800b28e:	701a      	strb	r2, [r3, #0]
  failpoint = point;
 800b290:	4b05      	ldr	r3, [pc, #20]	; (800b2a8 <_test_fail+0x28>)
 800b292:	9a01      	ldr	r2, [sp, #4]
 800b294:	601a      	str	r2, [r3, #0]
  return TRUE;
 800b296:	2301      	movs	r3, #1
}
 800b298:	4618      	mov	r0, r3
 800b29a:	b002      	add	sp, #8
 800b29c:	4770      	bx	lr
 800b29e:	bf00      	nop
 800b2a0:	20001220 	.word	0x20001220
 800b2a4:	20000b48 	.word	0x20000b48
 800b2a8:	20000b4c 	.word	0x20000b4c
 800b2ac:	f3af 8000 	nop.w

0800b2b0 <_test_assert>:

bool _test_assert(unsigned point, bool condition) {
 800b2b0:	b500      	push	{lr}
 800b2b2:	b083      	sub	sp, #12
 800b2b4:	9001      	str	r0, [sp, #4]
 800b2b6:	460b      	mov	r3, r1
 800b2b8:	f88d 3003 	strb.w	r3, [sp, #3]

  if (!condition)
 800b2bc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800b2c0:	f083 0301 	eor.w	r3, r3, #1
 800b2c4:	b2db      	uxtb	r3, r3
 800b2c6:	2b00      	cmp	r3, #0
 800b2c8:	d004      	beq.n	800b2d4 <_test_assert+0x24>
    return _test_fail(point);
 800b2ca:	9801      	ldr	r0, [sp, #4]
 800b2cc:	f7ff ffd8 	bl	800b280 <_test_fail>
 800b2d0:	4603      	mov	r3, r0
 800b2d2:	e000      	b.n	800b2d6 <_test_assert+0x26>
  return FALSE;
 800b2d4:	2300      	movs	r3, #0
}
 800b2d6:	4618      	mov	r0, r3
 800b2d8:	b003      	add	sp, #12
 800b2da:	f85d fb04 	ldr.w	pc, [sp], #4
 800b2de:	bf00      	nop

0800b2e0 <_test_assert_sequence>:

bool _test_assert_sequence(unsigned point, char *expected) {
 800b2e0:	b500      	push	{lr}
 800b2e2:	b085      	sub	sp, #20
 800b2e4:	9001      	str	r0, [sp, #4]
 800b2e6:	9100      	str	r1, [sp, #0]
  char *cp = tokens_buffer;
 800b2e8:	4b13      	ldr	r3, [pc, #76]	; (800b338 <_test_assert_sequence+0x58>)
 800b2ea:	9303      	str	r3, [sp, #12]
  while (cp < tokp) {
 800b2ec:	e00e      	b.n	800b30c <_test_assert_sequence+0x2c>
    if (*cp++ != *expected++)
 800b2ee:	9b03      	ldr	r3, [sp, #12]
 800b2f0:	1c5a      	adds	r2, r3, #1
 800b2f2:	9203      	str	r2, [sp, #12]
 800b2f4:	781a      	ldrb	r2, [r3, #0]
 800b2f6:	9b00      	ldr	r3, [sp, #0]
 800b2f8:	1c59      	adds	r1, r3, #1
 800b2fa:	9100      	str	r1, [sp, #0]
 800b2fc:	781b      	ldrb	r3, [r3, #0]
 800b2fe:	429a      	cmp	r2, r3
 800b300:	d004      	beq.n	800b30c <_test_assert_sequence+0x2c>
     return _test_fail(point);
 800b302:	9801      	ldr	r0, [sp, #4]
 800b304:	f7ff ffbc 	bl	800b280 <_test_fail>
 800b308:	4603      	mov	r3, r0
 800b30a:	e010      	b.n	800b32e <_test_assert_sequence+0x4e>
  return FALSE;
}

bool _test_assert_sequence(unsigned point, char *expected) {
  char *cp = tokens_buffer;
  while (cp < tokp) {
 800b30c:	4b0b      	ldr	r3, [pc, #44]	; (800b33c <_test_assert_sequence+0x5c>)
 800b30e:	681b      	ldr	r3, [r3, #0]
 800b310:	9a03      	ldr	r2, [sp, #12]
 800b312:	429a      	cmp	r2, r3
 800b314:	d3eb      	bcc.n	800b2ee <_test_assert_sequence+0xe>
    if (*cp++ != *expected++)
     return _test_fail(point);
  }
  if (*expected)
 800b316:	9b00      	ldr	r3, [sp, #0]
 800b318:	781b      	ldrb	r3, [r3, #0]
 800b31a:	2b00      	cmp	r3, #0
 800b31c:	d004      	beq.n	800b328 <_test_assert_sequence+0x48>
    return _test_fail(point);
 800b31e:	9801      	ldr	r0, [sp, #4]
 800b320:	f7ff ffae 	bl	800b280 <_test_fail>
 800b324:	4603      	mov	r3, r0
 800b326:	e002      	b.n	800b32e <_test_assert_sequence+0x4e>
  clear_tokens();
 800b328:	f7ff ff6a 	bl	800b200 <clear_tokens>
  return FALSE;
 800b32c:	2300      	movs	r3, #0
}
 800b32e:	4618      	mov	r0, r3
 800b330:	b005      	add	sp, #20
 800b332:	f85d fb04 	ldr.w	pc, [sp], #4
 800b336:	bf00      	nop
 800b338:	20000b50 	.word	0x20000b50
 800b33c:	20000b60 	.word	0x20000b60

0800b340 <_test_assert_time_window>:

bool _test_assert_time_window(unsigned point, systime_t start, systime_t end) {
 800b340:	b500      	push	{lr}
 800b342:	b085      	sub	sp, #20
 800b344:	9003      	str	r0, [sp, #12]
 800b346:	9102      	str	r1, [sp, #8]
 800b348:	9201      	str	r2, [sp, #4]

  return _test_assert(point, chVTIsSystemTimeWithin(start, end));
 800b34a:	9802      	ldr	r0, [sp, #8]
 800b34c:	9901      	ldr	r1, [sp, #4]
 800b34e:	f7ff fe6f 	bl	800b030 <chVTIsSystemTimeWithin>
 800b352:	4603      	mov	r3, r0
 800b354:	9803      	ldr	r0, [sp, #12]
 800b356:	4619      	mov	r1, r3
 800b358:	f7ff ffaa 	bl	800b2b0 <_test_assert>
 800b35c:	4603      	mov	r3, r0
}
 800b35e:	4618      	mov	r0, r3
 800b360:	b005      	add	sp, #20
 800b362:	f85d fb04 	ldr.w	pc, [sp], #4
 800b366:	bf00      	nop
 800b368:	f3af 8000 	nop.w
 800b36c:	f3af 8000 	nop.w

0800b370 <test_terminate_threads>:
 */

/**
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
 800b370:	b500      	push	{lr}
 800b372:	b083      	sub	sp, #12
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 800b374:	2300      	movs	r3, #0
 800b376:	9301      	str	r3, [sp, #4]
 800b378:	e00f      	b.n	800b39a <test_terminate_threads+0x2a>
    if (threads[i])
 800b37a:	4b0b      	ldr	r3, [pc, #44]	; (800b3a8 <test_terminate_threads+0x38>)
 800b37c:	9a01      	ldr	r2, [sp, #4]
 800b37e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800b382:	2b00      	cmp	r3, #0
 800b384:	d006      	beq.n	800b394 <test_terminate_threads+0x24>
      chThdTerminate(threads[i]);
 800b386:	4b08      	ldr	r3, [pc, #32]	; (800b3a8 <test_terminate_threads+0x38>)
 800b388:	9a01      	ldr	r2, [sp, #4]
 800b38a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800b38e:	4618      	mov	r0, r3
 800b390:	f7f5 ff86 	bl	80012a0 <chThdTerminate>
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 800b394:	9b01      	ldr	r3, [sp, #4]
 800b396:	3301      	adds	r3, #1
 800b398:	9301      	str	r3, [sp, #4]
 800b39a:	9b01      	ldr	r3, [sp, #4]
 800b39c:	2b04      	cmp	r3, #4
 800b39e:	ddec      	ble.n	800b37a <test_terminate_threads+0xa>
    if (threads[i])
      chThdTerminate(threads[i]);
}
 800b3a0:	b003      	add	sp, #12
 800b3a2:	f85d fb04 	ldr.w	pc, [sp], #4
 800b3a6:	bf00      	nop
 800b3a8:	20001224 	.word	0x20001224
 800b3ac:	f3af 8000 	nop.w

0800b3b0 <test_wait_threads>:

/**
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
 800b3b0:	b500      	push	{lr}
 800b3b2:	b083      	sub	sp, #12
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 800b3b4:	2300      	movs	r3, #0
 800b3b6:	9301      	str	r3, [sp, #4]
 800b3b8:	e014      	b.n	800b3e4 <test_wait_threads+0x34>
    if (threads[i] != NULL) {
 800b3ba:	4b0d      	ldr	r3, [pc, #52]	; (800b3f0 <test_wait_threads+0x40>)
 800b3bc:	9a01      	ldr	r2, [sp, #4]
 800b3be:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800b3c2:	2b00      	cmp	r3, #0
 800b3c4:	d00b      	beq.n	800b3de <test_wait_threads+0x2e>
      chThdWait(threads[i]);
 800b3c6:	4b0a      	ldr	r3, [pc, #40]	; (800b3f0 <test_wait_threads+0x40>)
 800b3c8:	9a01      	ldr	r2, [sp, #4]
 800b3ca:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800b3ce:	4618      	mov	r0, r3
 800b3d0:	f7f6 f816 	bl	8001400 <chThdWait>
      threads[i] = NULL;
 800b3d4:	4b06      	ldr	r3, [pc, #24]	; (800b3f0 <test_wait_threads+0x40>)
 800b3d6:	9a01      	ldr	r2, [sp, #4]
 800b3d8:	2100      	movs	r1, #0
 800b3da:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 800b3de:	9b01      	ldr	r3, [sp, #4]
 800b3e0:	3301      	adds	r3, #1
 800b3e2:	9301      	str	r3, [sp, #4]
 800b3e4:	9b01      	ldr	r3, [sp, #4]
 800b3e6:	2b04      	cmp	r3, #4
 800b3e8:	dde7      	ble.n	800b3ba <test_wait_threads+0xa>
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
    }
}
 800b3ea:	b003      	add	sp, #12
 800b3ec:	f85d fb04 	ldr.w	pc, [sp], #4
 800b3f0:	20001224 	.word	0x20001224
 800b3f4:	f3af 8000 	nop.w
 800b3f8:	f3af 8000 	nop.w
 800b3fc:	f3af 8000 	nop.w

0800b400 <test_wait_tick>:
/**
 * @brief   Delays execution until next system time tick.
 *
 * @return              The system time.
 */
systime_t test_wait_tick(void) {
 800b400:	b508      	push	{r3, lr}

  chThdSleep(1);
 800b402:	2001      	movs	r0, #1
 800b404:	f7f5 ff64 	bl	80012d0 <chThdSleep>
  return chVTGetSystemTime();
 800b408:	f7ff fdea 	bl	800afe0 <chVTGetSystemTime>
 800b40c:	4603      	mov	r3, r0
}
 800b40e:	4618      	mov	r0, r3
 800b410:	bd08      	pop	{r3, pc}
 800b412:	bf00      	nop
 800b414:	f3af 8000 	nop.w
 800b418:	f3af 8000 	nop.w
 800b41c:	f3af 8000 	nop.w

0800b420 <tmr>:
 * @brief   Set to @p TRUE when the test timer reaches its deadline.
 */
bool test_timer_done;

static virtual_timer_t vt;
static void tmr(void *p) {
 800b420:	b082      	sub	sp, #8
 800b422:	9001      	str	r0, [sp, #4]
  (void)p;

  test_timer_done = TRUE;
 800b424:	4b02      	ldr	r3, [pc, #8]	; (800b430 <tmr+0x10>)
 800b426:	2201      	movs	r2, #1
 800b428:	701a      	strb	r2, [r3, #0]
}
 800b42a:	b002      	add	sp, #8
 800b42c:	4770      	bx	lr
 800b42e:	bf00      	nop
 800b430:	20001221 	.word	0x20001221
 800b434:	f3af 8000 	nop.w
 800b438:	f3af 8000 	nop.w
 800b43c:	f3af 8000 	nop.w

0800b440 <test_start_timer>:
/**
 * @brief   Starts the test timer.
 *
 * @param[in] ms        time in milliseconds
 */
void test_start_timer(unsigned ms) {
 800b440:	b500      	push	{lr}
 800b442:	b085      	sub	sp, #20
 800b444:	9001      	str	r0, [sp, #4]

  systime_t duration = MS2ST(ms);
 800b446:	9b01      	ldr	r3, [sp, #4]
 800b448:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800b44c:	fb02 f303 	mul.w	r3, r2, r3
 800b450:	f203 32e7 	addw	r2, r3, #999	; 0x3e7
 800b454:	4b08      	ldr	r3, [pc, #32]	; (800b478 <test_start_timer+0x38>)
 800b456:	fba3 1302 	umull	r1, r3, r3, r2
 800b45a:	099b      	lsrs	r3, r3, #6
 800b45c:	9303      	str	r3, [sp, #12]
  test_timer_done = FALSE;
 800b45e:	4b07      	ldr	r3, [pc, #28]	; (800b47c <test_start_timer+0x3c>)
 800b460:	2200      	movs	r2, #0
 800b462:	701a      	strb	r2, [r3, #0]
  chVTSet(&vt, duration, tmr, NULL);
 800b464:	4806      	ldr	r0, [pc, #24]	; (800b480 <test_start_timer+0x40>)
 800b466:	9903      	ldr	r1, [sp, #12]
 800b468:	4a06      	ldr	r2, [pc, #24]	; (800b484 <test_start_timer+0x44>)
 800b46a:	2300      	movs	r3, #0
 800b46c:	f7ff fe30 	bl	800b0d0 <chVTSet>
}
 800b470:	b005      	add	sp, #20
 800b472:	f85d fb04 	ldr.w	pc, [sp], #4
 800b476:	bf00      	nop
 800b478:	10624dd3 	.word	0x10624dd3
 800b47c:	20001221 	.word	0x20001221
 800b480:	20000b68 	.word	0x20000b68
 800b484:	0800b421 	.word	0x0800b421
 800b488:	f3af 8000 	nop.w
 800b48c:	f3af 8000 	nop.w

0800b490 <execute_test>:

/*
 * Test suite execution.
 */
static void execute_test(const struct testcase *tcp) {
 800b490:	b500      	push	{lr}
 800b492:	b085      	sub	sp, #20
 800b494:	9001      	str	r0, [sp, #4]
  int i;

  /* Initialization */
  clear_tokens();
 800b496:	f7ff feb3 	bl	800b200 <clear_tokens>
  local_fail = FALSE;
 800b49a:	4b13      	ldr	r3, [pc, #76]	; (800b4e8 <execute_test+0x58>)
 800b49c:	2200      	movs	r2, #0
 800b49e:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < MAX_THREADS; i++)
 800b4a0:	2300      	movs	r3, #0
 800b4a2:	9303      	str	r3, [sp, #12]
 800b4a4:	e007      	b.n	800b4b6 <execute_test+0x26>
    threads[i] = NULL;
 800b4a6:	4b11      	ldr	r3, [pc, #68]	; (800b4ec <execute_test+0x5c>)
 800b4a8:	9a03      	ldr	r2, [sp, #12]
 800b4aa:	2100      	movs	r1, #0
 800b4ac:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  int i;

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
  for (i = 0; i < MAX_THREADS; i++)
 800b4b0:	9b03      	ldr	r3, [sp, #12]
 800b4b2:	3301      	adds	r3, #1
 800b4b4:	9303      	str	r3, [sp, #12]
 800b4b6:	9b03      	ldr	r3, [sp, #12]
 800b4b8:	2b04      	cmp	r3, #4
 800b4ba:	ddf4      	ble.n	800b4a6 <execute_test+0x16>
    threads[i] = NULL;

  if (tcp->setup != NULL)
 800b4bc:	9b01      	ldr	r3, [sp, #4]
 800b4be:	685b      	ldr	r3, [r3, #4]
 800b4c0:	2b00      	cmp	r3, #0
 800b4c2:	d002      	beq.n	800b4ca <execute_test+0x3a>
    tcp->setup();
 800b4c4:	9b01      	ldr	r3, [sp, #4]
 800b4c6:	685b      	ldr	r3, [r3, #4]
 800b4c8:	4798      	blx	r3
  tcp->execute();
 800b4ca:	9b01      	ldr	r3, [sp, #4]
 800b4cc:	68db      	ldr	r3, [r3, #12]
 800b4ce:	4798      	blx	r3
  if (tcp->teardown != NULL)
 800b4d0:	9b01      	ldr	r3, [sp, #4]
 800b4d2:	689b      	ldr	r3, [r3, #8]
 800b4d4:	2b00      	cmp	r3, #0
 800b4d6:	d002      	beq.n	800b4de <execute_test+0x4e>
    tcp->teardown();
 800b4d8:	9b01      	ldr	r3, [sp, #4]
 800b4da:	689b      	ldr	r3, [r3, #8]
 800b4dc:	4798      	blx	r3

  test_wait_threads();
 800b4de:	f7ff ff67 	bl	800b3b0 <test_wait_threads>
}
 800b4e2:	b005      	add	sp, #20
 800b4e4:	f85d fb04 	ldr.w	pc, [sp], #4
 800b4e8:	20000b48 	.word	0x20000b48
 800b4ec:	20001224 	.word	0x20001224

0800b4f0 <print_line>:

static void print_line(void) {
 800b4f0:	b500      	push	{lr}
 800b4f2:	b083      	sub	sp, #12
  unsigned i;

  for (i = 0; i < 76; i++)
 800b4f4:	2300      	movs	r3, #0
 800b4f6:	9301      	str	r3, [sp, #4]
 800b4f8:	e00b      	b.n	800b512 <print_line+0x22>
    chSequentialStreamPut(chp, '-');
 800b4fa:	4b0e      	ldr	r3, [pc, #56]	; (800b534 <print_line+0x44>)
 800b4fc:	681b      	ldr	r3, [r3, #0]
 800b4fe:	681b      	ldr	r3, [r3, #0]
 800b500:	689b      	ldr	r3, [r3, #8]
 800b502:	4a0c      	ldr	r2, [pc, #48]	; (800b534 <print_line+0x44>)
 800b504:	6812      	ldr	r2, [r2, #0]
 800b506:	4610      	mov	r0, r2
 800b508:	212d      	movs	r1, #45	; 0x2d
 800b50a:	4798      	blx	r3
}

static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
 800b50c:	9b01      	ldr	r3, [sp, #4]
 800b50e:	3301      	adds	r3, #1
 800b510:	9301      	str	r3, [sp, #4]
 800b512:	9b01      	ldr	r3, [sp, #4]
 800b514:	2b4b      	cmp	r3, #75	; 0x4b
 800b516:	d9f0      	bls.n	800b4fa <print_line+0xa>
    chSequentialStreamPut(chp, '-');
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 800b518:	4b06      	ldr	r3, [pc, #24]	; (800b534 <print_line+0x44>)
 800b51a:	681b      	ldr	r3, [r3, #0]
 800b51c:	681b      	ldr	r3, [r3, #0]
 800b51e:	681b      	ldr	r3, [r3, #0]
 800b520:	4a04      	ldr	r2, [pc, #16]	; (800b534 <print_line+0x44>)
 800b522:	6812      	ldr	r2, [r2, #0]
 800b524:	4610      	mov	r0, r2
 800b526:	4904      	ldr	r1, [pc, #16]	; (800b538 <print_line+0x48>)
 800b528:	2202      	movs	r2, #2
 800b52a:	4798      	blx	r3
}
 800b52c:	b003      	add	sp, #12
 800b52e:	f85d fb04 	ldr.w	pc, [sp], #4
 800b532:	bf00      	nop
 800b534:	20000b64 	.word	0x20000b64
 800b538:	08016254 	.word	0x08016254
 800b53c:	f3af 8000 	nop.w

0800b540 <TestThread>:
/**
 * @brief   Test execution thread function.
 *
 * @param[in] p         pointer to a @p BaseChannel object for test output
 */
void TestThread(void *p) {
 800b540:	b500      	push	{lr}
 800b542:	b085      	sub	sp, #20
 800b544:	9001      	str	r0, [sp, #4]
  int i, j;

  chp = p;
 800b546:	4b5f      	ldr	r3, [pc, #380]	; (800b6c4 <TestThread+0x184>)
 800b548:	9a01      	ldr	r2, [sp, #4]
 800b54a:	601a      	str	r2, [r3, #0]
  test_println("");
 800b54c:	485e      	ldr	r0, [pc, #376]	; (800b6c8 <TestThread+0x188>)
 800b54e:	f7ff fe3f 	bl	800b1d0 <test_println>
  test_println("*** ChibiOS/RT test suite");
 800b552:	485e      	ldr	r0, [pc, #376]	; (800b6cc <TestThread+0x18c>)
 800b554:	f7ff fe3c 	bl	800b1d0 <test_println>
  test_println("***");
 800b558:	485d      	ldr	r0, [pc, #372]	; (800b6d0 <TestThread+0x190>)
 800b55a:	f7ff fe39 	bl	800b1d0 <test_println>
  test_print("*** Kernel:       ");
 800b55e:	485d      	ldr	r0, [pc, #372]	; (800b6d4 <TestThread+0x194>)
 800b560:	f7ff fe16 	bl	800b190 <test_print>
  test_println(CH_KERNEL_VERSION);
 800b564:	485c      	ldr	r0, [pc, #368]	; (800b6d8 <TestThread+0x198>)
 800b566:	f7ff fe33 	bl	800b1d0 <test_println>
  test_print("*** Compiled:     ");
 800b56a:	485c      	ldr	r0, [pc, #368]	; (800b6dc <TestThread+0x19c>)
 800b56c:	f7ff fe10 	bl	800b190 <test_print>
  test_println(__DATE__ " - " __TIME__);
 800b570:	485b      	ldr	r0, [pc, #364]	; (800b6e0 <TestThread+0x1a0>)
 800b572:	f7ff fe2d 	bl	800b1d0 <test_println>
#ifdef PORT_COMPILER_NAME
  test_print("*** Compiler:     ");
 800b576:	485b      	ldr	r0, [pc, #364]	; (800b6e4 <TestThread+0x1a4>)
 800b578:	f7ff fe0a 	bl	800b190 <test_print>
  test_println(PORT_COMPILER_NAME);
 800b57c:	485a      	ldr	r0, [pc, #360]	; (800b6e8 <TestThread+0x1a8>)
 800b57e:	f7ff fe27 	bl	800b1d0 <test_println>
#endif
  test_print("*** Architecture: ");
 800b582:	485a      	ldr	r0, [pc, #360]	; (800b6ec <TestThread+0x1ac>)
 800b584:	f7ff fe04 	bl	800b190 <test_print>
  test_println(PORT_ARCHITECTURE_NAME);
 800b588:	4859      	ldr	r0, [pc, #356]	; (800b6f0 <TestThread+0x1b0>)
 800b58a:	f7ff fe21 	bl	800b1d0 <test_println>
#ifdef PORT_CORE_VARIANT_NAME
  test_print("*** Core Variant: ");
 800b58e:	4859      	ldr	r0, [pc, #356]	; (800b6f4 <TestThread+0x1b4>)
 800b590:	f7ff fdfe 	bl	800b190 <test_print>
  test_println(PORT_CORE_VARIANT_NAME);
 800b594:	4858      	ldr	r0, [pc, #352]	; (800b6f8 <TestThread+0x1b8>)
 800b596:	f7ff fe1b 	bl	800b1d0 <test_println>
#endif
#ifdef PORT_INFO
  test_print("*** Port Info:    ");
 800b59a:	4858      	ldr	r0, [pc, #352]	; (800b6fc <TestThread+0x1bc>)
 800b59c:	f7ff fdf8 	bl	800b190 <test_print>
  test_println(PORT_INFO);
 800b5a0:	4857      	ldr	r0, [pc, #348]	; (800b700 <TestThread+0x1c0>)
 800b5a2:	f7ff fe15 	bl	800b1d0 <test_println>
#endif
#ifdef PLATFORM_NAME
  test_print("*** Platform:     ");
 800b5a6:	4857      	ldr	r0, [pc, #348]	; (800b704 <TestThread+0x1c4>)
 800b5a8:	f7ff fdf2 	bl	800b190 <test_print>
  test_println(PLATFORM_NAME);
 800b5ac:	4856      	ldr	r0, [pc, #344]	; (800b708 <TestThread+0x1c8>)
 800b5ae:	f7ff fe0f 	bl	800b1d0 <test_println>
#endif
#ifdef BOARD_NAME
  test_print("*** Test Board:   ");
 800b5b2:	4856      	ldr	r0, [pc, #344]	; (800b70c <TestThread+0x1cc>)
 800b5b4:	f7ff fdec 	bl	800b190 <test_print>
  test_println(BOARD_NAME);
 800b5b8:	4855      	ldr	r0, [pc, #340]	; (800b710 <TestThread+0x1d0>)
 800b5ba:	f7ff fe09 	bl	800b1d0 <test_println>
#endif
  test_println("");
 800b5be:	4842      	ldr	r0, [pc, #264]	; (800b6c8 <TestThread+0x188>)
 800b5c0:	f7ff fe06 	bl	800b1d0 <test_println>

  test_global_fail = FALSE;
 800b5c4:	4b53      	ldr	r3, [pc, #332]	; (800b714 <TestThread+0x1d4>)
 800b5c6:	2200      	movs	r2, #0
 800b5c8:	701a      	strb	r2, [r3, #0]
  i = 0;
 800b5ca:	2300      	movs	r3, #0
 800b5cc:	9303      	str	r3, [sp, #12]
  while (patterns[i]) {
 800b5ce:	e05c      	b.n	800b68a <TestThread+0x14a>
    j = 0;
 800b5d0:	2300      	movs	r3, #0
 800b5d2:	9302      	str	r3, [sp, #8]
    while (patterns[i][j]) {
 800b5d4:	e04c      	b.n	800b670 <TestThread+0x130>
      print_line();
 800b5d6:	f7ff ff8b 	bl	800b4f0 <print_line>
      test_print("--- Test Case ");
 800b5da:	484f      	ldr	r0, [pc, #316]	; (800b718 <TestThread+0x1d8>)
 800b5dc:	f7ff fdd8 	bl	800b190 <test_print>
      test_printn(i + 1);
 800b5e0:	9b03      	ldr	r3, [sp, #12]
 800b5e2:	3301      	adds	r3, #1
 800b5e4:	4618      	mov	r0, r3
 800b5e6:	f7ff fd8b 	bl	800b100 <test_printn>
      test_print(".");
 800b5ea:	484c      	ldr	r0, [pc, #304]	; (800b71c <TestThread+0x1dc>)
 800b5ec:	f7ff fdd0 	bl	800b190 <test_print>
      test_printn(j + 1);
 800b5f0:	9b02      	ldr	r3, [sp, #8]
 800b5f2:	3301      	adds	r3, #1
 800b5f4:	4618      	mov	r0, r3
 800b5f6:	f7ff fd83 	bl	800b100 <test_printn>
      test_print(" (");
 800b5fa:	4849      	ldr	r0, [pc, #292]	; (800b720 <TestThread+0x1e0>)
 800b5fc:	f7ff fdc8 	bl	800b190 <test_print>
      test_print(patterns[i][j]->name);
 800b600:	4b48      	ldr	r3, [pc, #288]	; (800b724 <TestThread+0x1e4>)
 800b602:	9a03      	ldr	r2, [sp, #12]
 800b604:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800b608:	9b02      	ldr	r3, [sp, #8]
 800b60a:	009b      	lsls	r3, r3, #2
 800b60c:	4413      	add	r3, r2
 800b60e:	681b      	ldr	r3, [r3, #0]
 800b610:	681b      	ldr	r3, [r3, #0]
 800b612:	4618      	mov	r0, r3
 800b614:	f7ff fdbc 	bl	800b190 <test_print>
      test_println(")");
 800b618:	4843      	ldr	r0, [pc, #268]	; (800b728 <TestThread+0x1e8>)
 800b61a:	f7ff fdd9 	bl	800b1d0 <test_println>
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
 800b61e:	20c8      	movs	r0, #200	; 0xc8
 800b620:	f7f5 fe56 	bl	80012d0 <chThdSleep>
#endif
      execute_test(patterns[i][j]);
 800b624:	4b3f      	ldr	r3, [pc, #252]	; (800b724 <TestThread+0x1e4>)
 800b626:	9a03      	ldr	r2, [sp, #12]
 800b628:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800b62c:	9b02      	ldr	r3, [sp, #8]
 800b62e:	009b      	lsls	r3, r3, #2
 800b630:	4413      	add	r3, r2
 800b632:	681b      	ldr	r3, [r3, #0]
 800b634:	4618      	mov	r0, r3
 800b636:	f7ff ff2b 	bl	800b490 <execute_test>
      if (local_fail) {
 800b63a:	4b3c      	ldr	r3, [pc, #240]	; (800b72c <TestThread+0x1ec>)
 800b63c:	781b      	ldrb	r3, [r3, #0]
 800b63e:	2b00      	cmp	r3, #0
 800b640:	d010      	beq.n	800b664 <TestThread+0x124>
        test_print("--- Result: FAILURE (#");
 800b642:	483b      	ldr	r0, [pc, #236]	; (800b730 <TestThread+0x1f0>)
 800b644:	f7ff fda4 	bl	800b190 <test_print>
        test_printn(failpoint);
 800b648:	4b3a      	ldr	r3, [pc, #232]	; (800b734 <TestThread+0x1f4>)
 800b64a:	681b      	ldr	r3, [r3, #0]
 800b64c:	4618      	mov	r0, r3
 800b64e:	f7ff fd57 	bl	800b100 <test_printn>
        test_print(" [");
 800b652:	4839      	ldr	r0, [pc, #228]	; (800b738 <TestThread+0x1f8>)
 800b654:	f7ff fd9c 	bl	800b190 <test_print>
        print_tokens();
 800b658:	f7ff fdda 	bl	800b210 <print_tokens>
        test_println("])");
 800b65c:	4837      	ldr	r0, [pc, #220]	; (800b73c <TestThread+0x1fc>)
 800b65e:	f7ff fdb7 	bl	800b1d0 <test_println>
 800b662:	e002      	b.n	800b66a <TestThread+0x12a>
      }
      else
        test_println("--- Result: SUCCESS");
 800b664:	4836      	ldr	r0, [pc, #216]	; (800b740 <TestThread+0x200>)
 800b666:	f7ff fdb3 	bl	800b1d0 <test_println>
      j++;
 800b66a:	9b02      	ldr	r3, [sp, #8]
 800b66c:	3301      	adds	r3, #1
 800b66e:	9302      	str	r3, [sp, #8]

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
 800b670:	4b2c      	ldr	r3, [pc, #176]	; (800b724 <TestThread+0x1e4>)
 800b672:	9a03      	ldr	r2, [sp, #12]
 800b674:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800b678:	9b02      	ldr	r3, [sp, #8]
 800b67a:	009b      	lsls	r3, r3, #2
 800b67c:	4413      	add	r3, r2
 800b67e:	681b      	ldr	r3, [r3, #0]
 800b680:	2b00      	cmp	r3, #0
 800b682:	d1a8      	bne.n	800b5d6 <TestThread+0x96>
      }
      else
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
 800b684:	9b03      	ldr	r3, [sp, #12]
 800b686:	3301      	adds	r3, #1
 800b688:	9303      	str	r3, [sp, #12]
#endif
  test_println("");

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
 800b68a:	4b26      	ldr	r3, [pc, #152]	; (800b724 <TestThread+0x1e4>)
 800b68c:	9a03      	ldr	r2, [sp, #12]
 800b68e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800b692:	2b00      	cmp	r3, #0
 800b694:	d19c      	bne.n	800b5d0 <TestThread+0x90>
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
  }
  print_line();
 800b696:	f7ff ff2b 	bl	800b4f0 <print_line>
  test_println("");
 800b69a:	480b      	ldr	r0, [pc, #44]	; (800b6c8 <TestThread+0x188>)
 800b69c:	f7ff fd98 	bl	800b1d0 <test_println>
  test_print("Final result: ");
 800b6a0:	4828      	ldr	r0, [pc, #160]	; (800b744 <TestThread+0x204>)
 800b6a2:	f7ff fd75 	bl	800b190 <test_print>
  if (test_global_fail)
 800b6a6:	4b1b      	ldr	r3, [pc, #108]	; (800b714 <TestThread+0x1d4>)
 800b6a8:	781b      	ldrb	r3, [r3, #0]
 800b6aa:	2b00      	cmp	r3, #0
 800b6ac:	d003      	beq.n	800b6b6 <TestThread+0x176>
    test_println("FAILURE");
 800b6ae:	4826      	ldr	r0, [pc, #152]	; (800b748 <TestThread+0x208>)
 800b6b0:	f7ff fd8e 	bl	800b1d0 <test_println>
 800b6b4:	e002      	b.n	800b6bc <TestThread+0x17c>
  else
    test_println("SUCCESS");
 800b6b6:	4825      	ldr	r0, [pc, #148]	; (800b74c <TestThread+0x20c>)
 800b6b8:	f7ff fd8a 	bl	800b1d0 <test_println>
}
 800b6bc:	b005      	add	sp, #20
 800b6be:	f85d fb04 	ldr.w	pc, [sp], #4
 800b6c2:	bf00      	nop
 800b6c4:	20000b64 	.word	0x20000b64
 800b6c8:	08016258 	.word	0x08016258
 800b6cc:	0801625c 	.word	0x0801625c
 800b6d0:	08016278 	.word	0x08016278
 800b6d4:	0801627c 	.word	0x0801627c
 800b6d8:	08016290 	.word	0x08016290
 800b6dc:	08016298 	.word	0x08016298
 800b6e0:	080162ac 	.word	0x080162ac
 800b6e4:	080162c4 	.word	0x080162c4
 800b6e8:	080162d8 	.word	0x080162d8
 800b6ec:	08016320 	.word	0x08016320
 800b6f0:	08016334 	.word	0x08016334
 800b6f4:	08016340 	.word	0x08016340
 800b6f8:	08016354 	.word	0x08016354
 800b6fc:	08016360 	.word	0x08016360
 800b700:	08016374 	.word	0x08016374
 800b704:	0801638c 	.word	0x0801638c
 800b708:	080163a0 	.word	0x080163a0
 800b70c:	080163bc 	.word	0x080163bc
 800b710:	080163d0 	.word	0x080163d0
 800b714:	20001220 	.word	0x20001220
 800b718:	080163e0 	.word	0x080163e0
 800b71c:	080163f0 	.word	0x080163f0
 800b720:	080163f4 	.word	0x080163f4
 800b724:	20000804 	.word	0x20000804
 800b728:	080163f8 	.word	0x080163f8
 800b72c:	20000b48 	.word	0x20000b48
 800b730:	080163fc 	.word	0x080163fc
 800b734:	20000b4c 	.word	0x20000b4c
 800b738:	08016414 	.word	0x08016414
 800b73c:	08016418 	.word	0x08016418
 800b740:	0801641c 	.word	0x0801641c
 800b744:	08016430 	.word	0x08016430
 800b748:	08016440 	.word	0x08016440
 800b74c:	08016448 	.word	0x08016448

0800b750 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800b750:	b082      	sub	sp, #8
 800b752:	2320      	movs	r3, #32
 800b754:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800b756:	9b01      	ldr	r3, [sp, #4]
 800b758:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800b75c:	b002      	add	sp, #8
 800b75e:	4770      	bx	lr

0800b760 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800b760:	b082      	sub	sp, #8
 800b762:	2300      	movs	r3, #0
 800b764:	9301      	str	r3, [sp, #4]
 800b766:	9b01      	ldr	r3, [sp, #4]
 800b768:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800b76c:	b002      	add	sp, #8
 800b76e:	4770      	bx	lr

0800b770 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800b770:	b508      	push	{r3, lr}

  port_lock();
 800b772:	f7ff ffed 	bl	800b750 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800b776:	bd08      	pop	{r3, pc}
 800b778:	f3af 8000 	nop.w
 800b77c:	f3af 8000 	nop.w

0800b780 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800b780:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800b782:	f7ff ffed 	bl	800b760 <port_unlock>
}
 800b786:	bd08      	pop	{r3, pc}
 800b788:	f3af 8000 	nop.w
 800b78c:	f3af 8000 	nop.w

0800b790 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 800b790:	4b01      	ldr	r3, [pc, #4]	; (800b798 <chVTGetSystemTimeX+0x8>)
 800b792:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800b794:	4618      	mov	r0, r3
 800b796:	4770      	bx	lr
 800b798:	20000d98 	.word	0x20000d98
 800b79c:	f3af 8000 	nop.w

0800b7a0 <chVTGetSystemTime>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 800b7a0:	b500      	push	{lr}
 800b7a2:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 800b7a4:	f7ff ffe4 	bl	800b770 <chSysLock>
  systime = chVTGetSystemTimeX();
 800b7a8:	f7ff fff2 	bl	800b790 <chVTGetSystemTimeX>
 800b7ac:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 800b7ae:	f7ff ffe7 	bl	800b780 <chSysUnlock>

  return systime;
 800b7b2:	9b01      	ldr	r3, [sp, #4]
}
 800b7b4:	4618      	mov	r0, r3
 800b7b6:	b003      	add	sp, #12
 800b7b8:	f85d fb04 	ldr.w	pc, [sp], #4
 800b7bc:	f3af 8000 	nop.w

0800b7c0 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800b7c0:	4b01      	ldr	r3, [pc, #4]	; (800b7c8 <chThdGetSelfX+0x8>)
 800b7c2:	699b      	ldr	r3, [r3, #24]
}
 800b7c4:	4618      	mov	r0, r3
 800b7c6:	4770      	bx	lr
 800b7c8:	20000d98 	.word	0x20000d98
 800b7cc:	f3af 8000 	nop.w

0800b7d0 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800b7d0:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800b7d2:	f7ff fff5 	bl	800b7c0 <chThdGetSelfX>
 800b7d6:	4603      	mov	r3, r0
 800b7d8:	689b      	ldr	r3, [r3, #8]
}
 800b7da:	4618      	mov	r0, r3
 800b7dc:	bd08      	pop	{r3, pc}
 800b7de:	bf00      	nop

0800b7e0 <thread>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static THD_FUNCTION(thread, p) {
 800b7e0:	b500      	push	{lr}
 800b7e2:	b083      	sub	sp, #12
 800b7e4:	9001      	str	r0, [sp, #4]

  test_emit_token(*(char *)p);
 800b7e6:	9b01      	ldr	r3, [sp, #4]
 800b7e8:	781b      	ldrb	r3, [r3, #0]
 800b7ea:	4618      	mov	r0, r3
 800b7ec:	f7ff fd30 	bl	800b250 <test_emit_token>
}
 800b7f0:	b003      	add	sp, #12
 800b7f2:	f85d fb04 	ldr.w	pc, [sp], #4
 800b7f6:	bf00      	nop
 800b7f8:	f3af 8000 	nop.w
 800b7fc:	f3af 8000 	nop.w

0800b800 <thd1_execute>:

static void thd1_execute(void) {
 800b800:	b510      	push	{r4, lr}
 800b802:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 800b804:	4b32      	ldr	r3, [pc, #200]	; (800b8d0 <thd1_execute+0xd0>)
 800b806:	681c      	ldr	r4, [r3, #0]
 800b808:	f7ff ffe2 	bl	800b7d0 <chThdGetPriorityX>
 800b80c:	4603      	mov	r3, r0
 800b80e:	3b05      	subs	r3, #5
 800b810:	4a30      	ldr	r2, [pc, #192]	; (800b8d4 <thd1_execute+0xd4>)
 800b812:	9200      	str	r2, [sp, #0]
 800b814:	4620      	mov	r0, r4
 800b816:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800b81a:	461a      	mov	r2, r3
 800b81c:	4b2e      	ldr	r3, [pc, #184]	; (800b8d8 <thd1_execute+0xd8>)
 800b81e:	f7f5 fcdf 	bl	80011e0 <chThdCreateStatic>
 800b822:	4602      	mov	r2, r0
 800b824:	4b2d      	ldr	r3, [pc, #180]	; (800b8dc <thd1_execute+0xdc>)
 800b826:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 800b828:	4b29      	ldr	r3, [pc, #164]	; (800b8d0 <thd1_execute+0xd0>)
 800b82a:	685c      	ldr	r4, [r3, #4]
 800b82c:	f7ff ffd0 	bl	800b7d0 <chThdGetPriorityX>
 800b830:	4603      	mov	r3, r0
 800b832:	3b04      	subs	r3, #4
 800b834:	4a2a      	ldr	r2, [pc, #168]	; (800b8e0 <thd1_execute+0xe0>)
 800b836:	9200      	str	r2, [sp, #0]
 800b838:	4620      	mov	r0, r4
 800b83a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800b83e:	461a      	mov	r2, r3
 800b840:	4b25      	ldr	r3, [pc, #148]	; (800b8d8 <thd1_execute+0xd8>)
 800b842:	f7f5 fccd 	bl	80011e0 <chThdCreateStatic>
 800b846:	4602      	mov	r2, r0
 800b848:	4b24      	ldr	r3, [pc, #144]	; (800b8dc <thd1_execute+0xdc>)
 800b84a:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 800b84c:	4b20      	ldr	r3, [pc, #128]	; (800b8d0 <thd1_execute+0xd0>)
 800b84e:	689c      	ldr	r4, [r3, #8]
 800b850:	f7ff ffbe 	bl	800b7d0 <chThdGetPriorityX>
 800b854:	4603      	mov	r3, r0
 800b856:	3b03      	subs	r3, #3
 800b858:	4a22      	ldr	r2, [pc, #136]	; (800b8e4 <thd1_execute+0xe4>)
 800b85a:	9200      	str	r2, [sp, #0]
 800b85c:	4620      	mov	r0, r4
 800b85e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800b862:	461a      	mov	r2, r3
 800b864:	4b1c      	ldr	r3, [pc, #112]	; (800b8d8 <thd1_execute+0xd8>)
 800b866:	f7f5 fcbb 	bl	80011e0 <chThdCreateStatic>
 800b86a:	4602      	mov	r2, r0
 800b86c:	4b1b      	ldr	r3, [pc, #108]	; (800b8dc <thd1_execute+0xdc>)
 800b86e:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800b870:	4b17      	ldr	r3, [pc, #92]	; (800b8d0 <thd1_execute+0xd0>)
 800b872:	68dc      	ldr	r4, [r3, #12]
 800b874:	f7ff ffac 	bl	800b7d0 <chThdGetPriorityX>
 800b878:	4603      	mov	r3, r0
 800b87a:	3b02      	subs	r3, #2
 800b87c:	4a1a      	ldr	r2, [pc, #104]	; (800b8e8 <thd1_execute+0xe8>)
 800b87e:	9200      	str	r2, [sp, #0]
 800b880:	4620      	mov	r0, r4
 800b882:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800b886:	461a      	mov	r2, r3
 800b888:	4b13      	ldr	r3, [pc, #76]	; (800b8d8 <thd1_execute+0xd8>)
 800b88a:	f7f5 fca9 	bl	80011e0 <chThdCreateStatic>
 800b88e:	4602      	mov	r2, r0
 800b890:	4b12      	ldr	r3, [pc, #72]	; (800b8dc <thd1_execute+0xdc>)
 800b892:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800b894:	4b0e      	ldr	r3, [pc, #56]	; (800b8d0 <thd1_execute+0xd0>)
 800b896:	691c      	ldr	r4, [r3, #16]
 800b898:	f7ff ff9a 	bl	800b7d0 <chThdGetPriorityX>
 800b89c:	4603      	mov	r3, r0
 800b89e:	3b01      	subs	r3, #1
 800b8a0:	4a12      	ldr	r2, [pc, #72]	; (800b8ec <thd1_execute+0xec>)
 800b8a2:	9200      	str	r2, [sp, #0]
 800b8a4:	4620      	mov	r0, r4
 800b8a6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800b8aa:	461a      	mov	r2, r3
 800b8ac:	4b0a      	ldr	r3, [pc, #40]	; (800b8d8 <thd1_execute+0xd8>)
 800b8ae:	f7f5 fc97 	bl	80011e0 <chThdCreateStatic>
 800b8b2:	4602      	mov	r2, r0
 800b8b4:	4b09      	ldr	r3, [pc, #36]	; (800b8dc <thd1_execute+0xdc>)
 800b8b6:	611a      	str	r2, [r3, #16]
  test_wait_threads();
 800b8b8:	f7ff fd7a 	bl	800b3b0 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 800b8bc:	2001      	movs	r0, #1
 800b8be:	490c      	ldr	r1, [pc, #48]	; (800b8f0 <thd1_execute+0xf0>)
 800b8c0:	f7ff fd0e 	bl	800b2e0 <_test_assert_sequence>
 800b8c4:	4603      	mov	r3, r0
 800b8c6:	2b00      	cmp	r3, #0
 800b8c8:	d000      	beq.n	800b8cc <thd1_execute+0xcc>
 800b8ca:	bf00      	nop
}
 800b8cc:	b002      	add	sp, #8
 800b8ce:	bd10      	pop	{r4, pc}
 800b8d0:	08016240 	.word	0x08016240
 800b8d4:	08016450 	.word	0x08016450
 800b8d8:	0800b7e1 	.word	0x0800b7e1
 800b8dc:	20001224 	.word	0x20001224
 800b8e0:	08016454 	.word	0x08016454
 800b8e4:	08016458 	.word	0x08016458
 800b8e8:	0801645c 	.word	0x0801645c
 800b8ec:	08016460 	.word	0x08016460
 800b8f0:	08016464 	.word	0x08016464
 800b8f4:	f3af 8000 	nop.w
 800b8f8:	f3af 8000 	nop.w
 800b8fc:	f3af 8000 	nop.w

0800b900 <thd2_execute>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {
 800b900:	b510      	push	{r4, lr}
 800b902:	b082      	sub	sp, #8

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 800b904:	4b37      	ldr	r3, [pc, #220]	; (800b9e4 <thd2_execute+0xe4>)
 800b906:	685c      	ldr	r4, [r3, #4]
 800b908:	f7ff ff62 	bl	800b7d0 <chThdGetPriorityX>
 800b90c:	4603      	mov	r3, r0
 800b90e:	3b04      	subs	r3, #4
 800b910:	4a35      	ldr	r2, [pc, #212]	; (800b9e8 <thd2_execute+0xe8>)
 800b912:	9200      	str	r2, [sp, #0]
 800b914:	4620      	mov	r0, r4
 800b916:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800b91a:	461a      	mov	r2, r3
 800b91c:	4b33      	ldr	r3, [pc, #204]	; (800b9ec <thd2_execute+0xec>)
 800b91e:	f7f5 fc5f 	bl	80011e0 <chThdCreateStatic>
 800b922:	4602      	mov	r2, r0
 800b924:	4b32      	ldr	r3, [pc, #200]	; (800b9f0 <thd2_execute+0xf0>)
 800b926:	605a      	str	r2, [r3, #4]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 800b928:	4b2e      	ldr	r3, [pc, #184]	; (800b9e4 <thd2_execute+0xe4>)
 800b92a:	681c      	ldr	r4, [r3, #0]
 800b92c:	f7ff ff50 	bl	800b7d0 <chThdGetPriorityX>
 800b930:	4603      	mov	r3, r0
 800b932:	3b05      	subs	r3, #5
 800b934:	4a2f      	ldr	r2, [pc, #188]	; (800b9f4 <thd2_execute+0xf4>)
 800b936:	9200      	str	r2, [sp, #0]
 800b938:	4620      	mov	r0, r4
 800b93a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800b93e:	461a      	mov	r2, r3
 800b940:	4b2a      	ldr	r3, [pc, #168]	; (800b9ec <thd2_execute+0xec>)
 800b942:	f7f5 fc4d 	bl	80011e0 <chThdCreateStatic>
 800b946:	4602      	mov	r2, r0
 800b948:	4b29      	ldr	r3, [pc, #164]	; (800b9f0 <thd2_execute+0xf0>)
 800b94a:	601a      	str	r2, [r3, #0]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800b94c:	4b25      	ldr	r3, [pc, #148]	; (800b9e4 <thd2_execute+0xe4>)
 800b94e:	691c      	ldr	r4, [r3, #16]
 800b950:	f7ff ff3e 	bl	800b7d0 <chThdGetPriorityX>
 800b954:	4603      	mov	r3, r0
 800b956:	3b01      	subs	r3, #1
 800b958:	4a27      	ldr	r2, [pc, #156]	; (800b9f8 <thd2_execute+0xf8>)
 800b95a:	9200      	str	r2, [sp, #0]
 800b95c:	4620      	mov	r0, r4
 800b95e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800b962:	461a      	mov	r2, r3
 800b964:	4b21      	ldr	r3, [pc, #132]	; (800b9ec <thd2_execute+0xec>)
 800b966:	f7f5 fc3b 	bl	80011e0 <chThdCreateStatic>
 800b96a:	4602      	mov	r2, r0
 800b96c:	4b20      	ldr	r3, [pc, #128]	; (800b9f0 <thd2_execute+0xf0>)
 800b96e:	611a      	str	r2, [r3, #16]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800b970:	4b1c      	ldr	r3, [pc, #112]	; (800b9e4 <thd2_execute+0xe4>)
 800b972:	68dc      	ldr	r4, [r3, #12]
 800b974:	f7ff ff2c 	bl	800b7d0 <chThdGetPriorityX>
 800b978:	4603      	mov	r3, r0
 800b97a:	3b02      	subs	r3, #2
 800b97c:	4a1f      	ldr	r2, [pc, #124]	; (800b9fc <thd2_execute+0xfc>)
 800b97e:	9200      	str	r2, [sp, #0]
 800b980:	4620      	mov	r0, r4
 800b982:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800b986:	461a      	mov	r2, r3
 800b988:	4b18      	ldr	r3, [pc, #96]	; (800b9ec <thd2_execute+0xec>)
 800b98a:	f7f5 fc29 	bl	80011e0 <chThdCreateStatic>
 800b98e:	4602      	mov	r2, r0
 800b990:	4b17      	ldr	r3, [pc, #92]	; (800b9f0 <thd2_execute+0xf0>)
 800b992:	60da      	str	r2, [r3, #12]
  /* Done this way for coverage of chThdCreateI() and chThdStart().*/
  chSysLock();
 800b994:	f7ff feec 	bl	800b770 <chSysLock>
  threads[2] = chThdCreateI(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 800b998:	4b12      	ldr	r3, [pc, #72]	; (800b9e4 <thd2_execute+0xe4>)
 800b99a:	689c      	ldr	r4, [r3, #8]
 800b99c:	f7ff ff18 	bl	800b7d0 <chThdGetPriorityX>
 800b9a0:	4603      	mov	r3, r0
 800b9a2:	3b03      	subs	r3, #3
 800b9a4:	4a16      	ldr	r2, [pc, #88]	; (800ba00 <thd2_execute+0x100>)
 800b9a6:	9200      	str	r2, [sp, #0]
 800b9a8:	4620      	mov	r0, r4
 800b9aa:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800b9ae:	461a      	mov	r2, r3
 800b9b0:	4b0e      	ldr	r3, [pc, #56]	; (800b9ec <thd2_execute+0xec>)
 800b9b2:	f7f5 fbed 	bl	8001190 <chThdCreateI>
 800b9b6:	4602      	mov	r2, r0
 800b9b8:	4b0d      	ldr	r3, [pc, #52]	; (800b9f0 <thd2_execute+0xf0>)
 800b9ba:	609a      	str	r2, [r3, #8]
  chSysUnlock();
 800b9bc:	f7ff fee0 	bl	800b780 <chSysUnlock>
  chThdStart(threads[2]);
 800b9c0:	4b0b      	ldr	r3, [pc, #44]	; (800b9f0 <thd2_execute+0xf0>)
 800b9c2:	689b      	ldr	r3, [r3, #8]
 800b9c4:	4618      	mov	r0, r3
 800b9c6:	f7f5 fc2b 	bl	8001220 <chThdStart>
  test_wait_threads();
 800b9ca:	f7ff fcf1 	bl	800b3b0 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 800b9ce:	2001      	movs	r0, #1
 800b9d0:	490c      	ldr	r1, [pc, #48]	; (800ba04 <thd2_execute+0x104>)
 800b9d2:	f7ff fc85 	bl	800b2e0 <_test_assert_sequence>
 800b9d6:	4603      	mov	r3, r0
 800b9d8:	2b00      	cmp	r3, #0
 800b9da:	d000      	beq.n	800b9de <thd2_execute+0xde>
 800b9dc:	bf00      	nop
}
 800b9de:	b002      	add	sp, #8
 800b9e0:	bd10      	pop	{r4, pc}
 800b9e2:	bf00      	nop
 800b9e4:	08016240 	.word	0x08016240
 800b9e8:	08016454 	.word	0x08016454
 800b9ec:	0800b7e1 	.word	0x0800b7e1
 800b9f0:	20001224 	.word	0x20001224
 800b9f4:	08016450 	.word	0x08016450
 800b9f8:	08016460 	.word	0x08016460
 800b9fc:	0801645c 	.word	0x0801645c
 800ba00:	08016458 	.word	0x08016458
 800ba04:	08016464 	.word	0x08016464
 800ba08:	f3af 8000 	nop.w
 800ba0c:	f3af 8000 	nop.w

0800ba10 <thd3_execute>:
 * to verify that the priority change happens as expected.<br>
 * If the @p CH_CFG_USE_MUTEXES option is enabled then the priority changes are
 * also tested under priority inheritance boosted priority state.
 */

static void thd3_execute(void) {
 800ba10:	b500      	push	{lr}
 800ba12:	b083      	sub	sp, #12
  tprio_t prio, p1;

  prio = chThdGetPriorityX();
 800ba14:	f7ff fedc 	bl	800b7d0 <chThdGetPriorityX>
 800ba18:	9001      	str	r0, [sp, #4]
  p1 = chThdSetPriority(prio + 1);
 800ba1a:	9b01      	ldr	r3, [sp, #4]
 800ba1c:	3301      	adds	r3, #1
 800ba1e:	4618      	mov	r0, r3
 800ba20:	f7f5 fc0e 	bl	8001240 <chThdSetPriority>
 800ba24:	9000      	str	r0, [sp, #0]
  test_assert(1, p1 == prio,
 800ba26:	9a00      	ldr	r2, [sp, #0]
 800ba28:	9b01      	ldr	r3, [sp, #4]
 800ba2a:	429a      	cmp	r2, r3
 800ba2c:	bf14      	ite	ne
 800ba2e:	2300      	movne	r3, #0
 800ba30:	2301      	moveq	r3, #1
 800ba32:	b2db      	uxtb	r3, r3
 800ba34:	2001      	movs	r0, #1
 800ba36:	4619      	mov	r1, r3
 800ba38:	f7ff fc3a 	bl	800b2b0 <_test_assert>
 800ba3c:	4603      	mov	r3, r0
 800ba3e:	2b00      	cmp	r3, #0
 800ba40:	d000      	beq.n	800ba44 <thd3_execute+0x34>
 800ba42:	e0d7      	b.n	800bbf4 <thd3_execute+0x1e4>
              "unexpected returned priority level");
  test_assert(2, chThdGetPriorityX() == prio + 1,
 800ba44:	f7ff fec4 	bl	800b7d0 <chThdGetPriorityX>
 800ba48:	4602      	mov	r2, r0
 800ba4a:	9b01      	ldr	r3, [sp, #4]
 800ba4c:	3301      	adds	r3, #1
 800ba4e:	429a      	cmp	r2, r3
 800ba50:	bf14      	ite	ne
 800ba52:	2300      	movne	r3, #0
 800ba54:	2301      	moveq	r3, #1
 800ba56:	b2db      	uxtb	r3, r3
 800ba58:	2002      	movs	r0, #2
 800ba5a:	4619      	mov	r1, r3
 800ba5c:	f7ff fc28 	bl	800b2b0 <_test_assert>
 800ba60:	4603      	mov	r3, r0
 800ba62:	2b00      	cmp	r3, #0
 800ba64:	d000      	beq.n	800ba68 <thd3_execute+0x58>
 800ba66:	e0c5      	b.n	800bbf4 <thd3_execute+0x1e4>
              "unexpected priority level");
  p1 = chThdSetPriority(p1);
 800ba68:	9800      	ldr	r0, [sp, #0]
 800ba6a:	f7f5 fbe9 	bl	8001240 <chThdSetPriority>
 800ba6e:	9000      	str	r0, [sp, #0]
  test_assert(3, p1 == prio + 1,
 800ba70:	9b01      	ldr	r3, [sp, #4]
 800ba72:	1c5a      	adds	r2, r3, #1
 800ba74:	9b00      	ldr	r3, [sp, #0]
 800ba76:	429a      	cmp	r2, r3
 800ba78:	bf14      	ite	ne
 800ba7a:	2300      	movne	r3, #0
 800ba7c:	2301      	moveq	r3, #1
 800ba7e:	b2db      	uxtb	r3, r3
 800ba80:	2003      	movs	r0, #3
 800ba82:	4619      	mov	r1, r3
 800ba84:	f7ff fc14 	bl	800b2b0 <_test_assert>
 800ba88:	4603      	mov	r3, r0
 800ba8a:	2b00      	cmp	r3, #0
 800ba8c:	d000      	beq.n	800ba90 <thd3_execute+0x80>
 800ba8e:	e0b1      	b.n	800bbf4 <thd3_execute+0x1e4>
              "unexpected returned priority level");
  test_assert(4, chThdGetPriorityX() == prio,
 800ba90:	f7ff fe9e 	bl	800b7d0 <chThdGetPriorityX>
 800ba94:	4602      	mov	r2, r0
 800ba96:	9b01      	ldr	r3, [sp, #4]
 800ba98:	429a      	cmp	r2, r3
 800ba9a:	bf14      	ite	ne
 800ba9c:	2300      	movne	r3, #0
 800ba9e:	2301      	moveq	r3, #1
 800baa0:	b2db      	uxtb	r3, r3
 800baa2:	2004      	movs	r0, #4
 800baa4:	4619      	mov	r1, r3
 800baa6:	f7ff fc03 	bl	800b2b0 <_test_assert>
 800baaa:	4603      	mov	r3, r0
 800baac:	2b00      	cmp	r3, #0
 800baae:	d000      	beq.n	800bab2 <thd3_execute+0xa2>
 800bab0:	e0a0      	b.n	800bbf4 <thd3_execute+0x1e4>
              "unexpected priority level");

#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  /* Simulates a priority boost situation (p_prio > p_realprio).*/
  chSysLock();
 800bab2:	f7ff fe5d 	bl	800b770 <chSysLock>
  chThdGetSelfX()->p_prio += 2;
 800bab6:	f7ff fe83 	bl	800b7c0 <chThdGetSelfX>
 800baba:	4603      	mov	r3, r0
 800babc:	689a      	ldr	r2, [r3, #8]
 800babe:	3202      	adds	r2, #2
 800bac0:	609a      	str	r2, [r3, #8]
  chSysUnlock();
 800bac2:	f7ff fe5d 	bl	800b780 <chSysUnlock>
  test_assert(5, chThdGetPriorityX() == prio + 2,
 800bac6:	f7ff fe83 	bl	800b7d0 <chThdGetPriorityX>
 800baca:	4602      	mov	r2, r0
 800bacc:	9b01      	ldr	r3, [sp, #4]
 800bace:	3302      	adds	r3, #2
 800bad0:	429a      	cmp	r2, r3
 800bad2:	bf14      	ite	ne
 800bad4:	2300      	movne	r3, #0
 800bad6:	2301      	moveq	r3, #1
 800bad8:	b2db      	uxtb	r3, r3
 800bada:	2005      	movs	r0, #5
 800badc:	4619      	mov	r1, r3
 800bade:	f7ff fbe7 	bl	800b2b0 <_test_assert>
 800bae2:	4603      	mov	r3, r0
 800bae4:	2b00      	cmp	r3, #0
 800bae6:	d000      	beq.n	800baea <thd3_execute+0xda>
 800bae8:	e084      	b.n	800bbf4 <thd3_execute+0x1e4>
              "unexpected priority level");

  /* Tries to raise but below the boost level. */
  p1 = chThdSetPriority(prio + 1);
 800baea:	9b01      	ldr	r3, [sp, #4]
 800baec:	3301      	adds	r3, #1
 800baee:	4618      	mov	r0, r3
 800baf0:	f7f5 fba6 	bl	8001240 <chThdSetPriority>
 800baf4:	9000      	str	r0, [sp, #0]
  test_assert(6, p1 == prio,
 800baf6:	9a00      	ldr	r2, [sp, #0]
 800baf8:	9b01      	ldr	r3, [sp, #4]
 800bafa:	429a      	cmp	r2, r3
 800bafc:	bf14      	ite	ne
 800bafe:	2300      	movne	r3, #0
 800bb00:	2301      	moveq	r3, #1
 800bb02:	b2db      	uxtb	r3, r3
 800bb04:	2006      	movs	r0, #6
 800bb06:	4619      	mov	r1, r3
 800bb08:	f7ff fbd2 	bl	800b2b0 <_test_assert>
 800bb0c:	4603      	mov	r3, r0
 800bb0e:	2b00      	cmp	r3, #0
 800bb10:	d000      	beq.n	800bb14 <thd3_execute+0x104>
 800bb12:	e06f      	b.n	800bbf4 <thd3_execute+0x1e4>
              "unexpected returned priority level");
  test_assert(7, chThdGetSelfX()->p_prio == prio + 2,
 800bb14:	f7ff fe54 	bl	800b7c0 <chThdGetSelfX>
 800bb18:	4603      	mov	r3, r0
 800bb1a:	689a      	ldr	r2, [r3, #8]
 800bb1c:	9b01      	ldr	r3, [sp, #4]
 800bb1e:	3302      	adds	r3, #2
 800bb20:	429a      	cmp	r2, r3
 800bb22:	bf14      	ite	ne
 800bb24:	2300      	movne	r3, #0
 800bb26:	2301      	moveq	r3, #1
 800bb28:	b2db      	uxtb	r3, r3
 800bb2a:	2007      	movs	r0, #7
 800bb2c:	4619      	mov	r1, r3
 800bb2e:	f7ff fbbf 	bl	800b2b0 <_test_assert>
 800bb32:	4603      	mov	r3, r0
 800bb34:	2b00      	cmp	r3, #0
 800bb36:	d000      	beq.n	800bb3a <thd3_execute+0x12a>
 800bb38:	e05c      	b.n	800bbf4 <thd3_execute+0x1e4>
              "unexpected priority level");
  test_assert(8, chThdGetSelfX()->p_realprio == prio + 1,
 800bb3a:	f7ff fe41 	bl	800b7c0 <chThdGetSelfX>
 800bb3e:	4603      	mov	r3, r0
 800bb40:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800bb42:	9b01      	ldr	r3, [sp, #4]
 800bb44:	3301      	adds	r3, #1
 800bb46:	429a      	cmp	r2, r3
 800bb48:	bf14      	ite	ne
 800bb4a:	2300      	movne	r3, #0
 800bb4c:	2301      	moveq	r3, #1
 800bb4e:	b2db      	uxtb	r3, r3
 800bb50:	2008      	movs	r0, #8
 800bb52:	4619      	mov	r1, r3
 800bb54:	f7ff fbac 	bl	800b2b0 <_test_assert>
 800bb58:	4603      	mov	r3, r0
 800bb5a:	2b00      	cmp	r3, #0
 800bb5c:	d000      	beq.n	800bb60 <thd3_execute+0x150>
 800bb5e:	e049      	b.n	800bbf4 <thd3_execute+0x1e4>
              "unexpected returned real priority level");

  /* Tries to raise above the boost level. */
  p1 = chThdSetPriority(prio + 3);
 800bb60:	9b01      	ldr	r3, [sp, #4]
 800bb62:	3303      	adds	r3, #3
 800bb64:	4618      	mov	r0, r3
 800bb66:	f7f5 fb6b 	bl	8001240 <chThdSetPriority>
 800bb6a:	9000      	str	r0, [sp, #0]
  test_assert(9, p1 == prio + 1,
 800bb6c:	9b01      	ldr	r3, [sp, #4]
 800bb6e:	1c5a      	adds	r2, r3, #1
 800bb70:	9b00      	ldr	r3, [sp, #0]
 800bb72:	429a      	cmp	r2, r3
 800bb74:	bf14      	ite	ne
 800bb76:	2300      	movne	r3, #0
 800bb78:	2301      	moveq	r3, #1
 800bb7a:	b2db      	uxtb	r3, r3
 800bb7c:	2009      	movs	r0, #9
 800bb7e:	4619      	mov	r1, r3
 800bb80:	f7ff fb96 	bl	800b2b0 <_test_assert>
 800bb84:	4603      	mov	r3, r0
 800bb86:	2b00      	cmp	r3, #0
 800bb88:	d000      	beq.n	800bb8c <thd3_execute+0x17c>
 800bb8a:	e033      	b.n	800bbf4 <thd3_execute+0x1e4>
              "unexpected returned priority level");
  test_assert(10, chThdGetSelfX()->p_prio == prio + 3,
 800bb8c:	f7ff fe18 	bl	800b7c0 <chThdGetSelfX>
 800bb90:	4603      	mov	r3, r0
 800bb92:	689a      	ldr	r2, [r3, #8]
 800bb94:	9b01      	ldr	r3, [sp, #4]
 800bb96:	3303      	adds	r3, #3
 800bb98:	429a      	cmp	r2, r3
 800bb9a:	bf14      	ite	ne
 800bb9c:	2300      	movne	r3, #0
 800bb9e:	2301      	moveq	r3, #1
 800bba0:	b2db      	uxtb	r3, r3
 800bba2:	200a      	movs	r0, #10
 800bba4:	4619      	mov	r1, r3
 800bba6:	f7ff fb83 	bl	800b2b0 <_test_assert>
 800bbaa:	4603      	mov	r3, r0
 800bbac:	2b00      	cmp	r3, #0
 800bbae:	d000      	beq.n	800bbb2 <thd3_execute+0x1a2>
 800bbb0:	e020      	b.n	800bbf4 <thd3_execute+0x1e4>
              "unexpected priority level");
  test_assert(11, chThdGetSelfX()->p_realprio == prio + 3,
 800bbb2:	f7ff fe05 	bl	800b7c0 <chThdGetSelfX>
 800bbb6:	4603      	mov	r3, r0
 800bbb8:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800bbba:	9b01      	ldr	r3, [sp, #4]
 800bbbc:	3303      	adds	r3, #3
 800bbbe:	429a      	cmp	r2, r3
 800bbc0:	bf14      	ite	ne
 800bbc2:	2300      	movne	r3, #0
 800bbc4:	2301      	moveq	r3, #1
 800bbc6:	b2db      	uxtb	r3, r3
 800bbc8:	200b      	movs	r0, #11
 800bbca:	4619      	mov	r1, r3
 800bbcc:	f7ff fb70 	bl	800b2b0 <_test_assert>
 800bbd0:	4603      	mov	r3, r0
 800bbd2:	2b00      	cmp	r3, #0
 800bbd4:	d000      	beq.n	800bbd8 <thd3_execute+0x1c8>
 800bbd6:	e00d      	b.n	800bbf4 <thd3_execute+0x1e4>
              "unexpected real priority level");

  chSysLock();
 800bbd8:	f7ff fdca 	bl	800b770 <chSysLock>
  chThdGetSelfX()->p_prio = prio;
 800bbdc:	f7ff fdf0 	bl	800b7c0 <chThdGetSelfX>
 800bbe0:	4603      	mov	r3, r0
 800bbe2:	9a01      	ldr	r2, [sp, #4]
 800bbe4:	609a      	str	r2, [r3, #8]
  chThdGetSelfX()->p_realprio = prio;
 800bbe6:	f7ff fdeb 	bl	800b7c0 <chThdGetSelfX>
 800bbea:	4603      	mov	r3, r0
 800bbec:	9a01      	ldr	r2, [sp, #4]
 800bbee:	63da      	str	r2, [r3, #60]	; 0x3c
  chSysUnlock();
 800bbf0:	f7ff fdc6 	bl	800b780 <chSysUnlock>
#endif
}
 800bbf4:	b003      	add	sp, #12
 800bbf6:	f85d fb04 	ldr.w	pc, [sp], #4
 800bbfa:	bf00      	nop
 800bbfc:	f3af 8000 	nop.w

0800bc00 <thd4_execute>:
 * <h2>Description</h2>
 * Delay APIs and associated macros are tested, the invoking thread is verified
 * to wake up at the exact expected time.
 */

static void thd4_execute(void) {
 800bc00:	b500      	push	{lr}
 800bc02:	b083      	sub	sp, #12
  systime_t time;

  test_wait_tick();
 800bc04:	f7ff fbfc 	bl	800b400 <test_wait_tick>

  /* Timeouts in microseconds.*/
  time = chVTGetSystemTime();
 800bc08:	f7ff fdca 	bl	800b7a0 <chVTGetSystemTime>
 800bc0c:	9001      	str	r0, [sp, #4]
  chThdSleepMicroseconds(100000);
 800bc0e:	2064      	movs	r0, #100	; 0x64
 800bc10:	f7f5 fb5e 	bl	80012d0 <chThdSleep>
  test_assert_time_window(1,
 800bc14:	9b01      	ldr	r3, [sp, #4]
 800bc16:	f103 0264 	add.w	r2, r3, #100	; 0x64
 800bc1a:	9b01      	ldr	r3, [sp, #4]
 800bc1c:	3365      	adds	r3, #101	; 0x65
 800bc1e:	2001      	movs	r0, #1
 800bc20:	4611      	mov	r1, r2
 800bc22:	461a      	mov	r2, r3
 800bc24:	f7ff fb8c 	bl	800b340 <_test_assert_time_window>
 800bc28:	4603      	mov	r3, r0
 800bc2a:	2b00      	cmp	r3, #0
 800bc2c:	d000      	beq.n	800bc30 <thd4_execute+0x30>
 800bc2e:	e03c      	b.n	800bcaa <thd4_execute+0xaa>
                          time + US2ST(100000),
                          time + US2ST(100000) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in milliseconds.*/
  time = chVTGetSystemTime();
 800bc30:	f7ff fdb6 	bl	800b7a0 <chVTGetSystemTime>
 800bc34:	9001      	str	r0, [sp, #4]
  chThdSleepMilliseconds(100);
 800bc36:	2064      	movs	r0, #100	; 0x64
 800bc38:	f7f5 fb4a 	bl	80012d0 <chThdSleep>
  test_assert_time_window(2,
 800bc3c:	9b01      	ldr	r3, [sp, #4]
 800bc3e:	f103 0264 	add.w	r2, r3, #100	; 0x64
 800bc42:	9b01      	ldr	r3, [sp, #4]
 800bc44:	3365      	adds	r3, #101	; 0x65
 800bc46:	2002      	movs	r0, #2
 800bc48:	4611      	mov	r1, r2
 800bc4a:	461a      	mov	r2, r3
 800bc4c:	f7ff fb78 	bl	800b340 <_test_assert_time_window>
 800bc50:	4603      	mov	r3, r0
 800bc52:	2b00      	cmp	r3, #0
 800bc54:	d000      	beq.n	800bc58 <thd4_execute+0x58>
 800bc56:	e028      	b.n	800bcaa <thd4_execute+0xaa>
                          time + MS2ST(100),
                          time + MS2ST(100) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in seconds.*/
  time = chVTGetSystemTime();
 800bc58:	f7ff fda2 	bl	800b7a0 <chVTGetSystemTime>
 800bc5c:	9001      	str	r0, [sp, #4]
  chThdSleepSeconds(1);
 800bc5e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800bc62:	f7f5 fb35 	bl	80012d0 <chThdSleep>
  test_assert_time_window(3,
 800bc66:	9b01      	ldr	r3, [sp, #4]
 800bc68:	f503 727a 	add.w	r2, r3, #1000	; 0x3e8
 800bc6c:	9b01      	ldr	r3, [sp, #4]
 800bc6e:	f203 33e9 	addw	r3, r3, #1001	; 0x3e9
 800bc72:	2003      	movs	r0, #3
 800bc74:	4611      	mov	r1, r2
 800bc76:	461a      	mov	r2, r3
 800bc78:	f7ff fb62 	bl	800b340 <_test_assert_time_window>
 800bc7c:	4603      	mov	r3, r0
 800bc7e:	2b00      	cmp	r3, #0
 800bc80:	d000      	beq.n	800bc84 <thd4_execute+0x84>
 800bc82:	e012      	b.n	800bcaa <thd4_execute+0xaa>
                          time + S2ST(1),
                          time + S2ST(1) + CH_CFG_ST_TIMEDELTA + 1);

  /* Absolute timelines.*/
  time = chVTGetSystemTime() + MS2ST(100);
 800bc84:	f7ff fd8c 	bl	800b7a0 <chVTGetSystemTime>
 800bc88:	4603      	mov	r3, r0
 800bc8a:	3364      	adds	r3, #100	; 0x64
 800bc8c:	9301      	str	r3, [sp, #4]
  chThdSleepUntil(time);
 800bc8e:	9801      	ldr	r0, [sp, #4]
 800bc90:	f7f5 fb2e 	bl	80012f0 <chThdSleepUntil>
  test_assert_time_window(4,
 800bc94:	9b01      	ldr	r3, [sp, #4]
 800bc96:	3301      	adds	r3, #1
 800bc98:	2004      	movs	r0, #4
 800bc9a:	9901      	ldr	r1, [sp, #4]
 800bc9c:	461a      	mov	r2, r3
 800bc9e:	f7ff fb4f 	bl	800b340 <_test_assert_time_window>
 800bca2:	4603      	mov	r3, r0
 800bca4:	2b00      	cmp	r3, #0
 800bca6:	d000      	beq.n	800bcaa <thd4_execute+0xaa>
 800bca8:	bf00      	nop
                          time,
                          time + CH_CFG_ST_TIMEDELTA + 1);
}
 800bcaa:	b003      	add	sp, #12
 800bcac:	f85d fb04 	ldr.w	pc, [sp], #4

0800bcb0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800bcb0:	b082      	sub	sp, #8
 800bcb2:	2320      	movs	r3, #32
 800bcb4:	9301      	str	r3, [sp, #4]
 800bcb6:	9b01      	ldr	r3, [sp, #4]
 800bcb8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800bcbc:	b002      	add	sp, #8
 800bcbe:	4770      	bx	lr

0800bcc0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800bcc0:	b082      	sub	sp, #8
 800bcc2:	2300      	movs	r3, #0
 800bcc4:	9301      	str	r3, [sp, #4]
 800bcc6:	9b01      	ldr	r3, [sp, #4]
 800bcc8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800bccc:	b002      	add	sp, #8
 800bcce:	4770      	bx	lr

0800bcd0 <queue_isempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {
 800bcd0:	b082      	sub	sp, #8
 800bcd2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next == (const thread_t *)tqp);
 800bcd4:	9b01      	ldr	r3, [sp, #4]
 800bcd6:	681a      	ldr	r2, [r3, #0]
 800bcd8:	9b01      	ldr	r3, [sp, #4]
 800bcda:	429a      	cmp	r2, r3
 800bcdc:	bf14      	ite	ne
 800bcde:	2300      	movne	r3, #0
 800bce0:	2301      	moveq	r3, #1
 800bce2:	b2db      	uxtb	r3, r3
}
 800bce4:	4618      	mov	r0, r3
 800bce6:	b002      	add	sp, #8
 800bce8:	4770      	bx	lr
 800bcea:	bf00      	nop
 800bcec:	f3af 8000 	nop.w

0800bcf0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800bcf0:	b508      	push	{r3, lr}

  port_lock();
 800bcf2:	f7ff ffdd 	bl	800bcb0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800bcf6:	bd08      	pop	{r3, pc}
 800bcf8:	f3af 8000 	nop.w
 800bcfc:	f3af 8000 	nop.w

0800bd00 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800bd00:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800bd02:	f7ff ffdd 	bl	800bcc0 <port_unlock>
}
 800bd06:	bd08      	pop	{r3, pc}
 800bd08:	f3af 8000 	nop.w
 800bd0c:	f3af 8000 	nop.w

0800bd10 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 800bd10:	4b01      	ldr	r3, [pc, #4]	; (800bd18 <chVTGetSystemTimeX+0x8>)
 800bd12:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800bd14:	4618      	mov	r0, r3
 800bd16:	4770      	bx	lr
 800bd18:	20000d98 	.word	0x20000d98
 800bd1c:	f3af 8000 	nop.w

0800bd20 <chVTGetSystemTime>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 800bd20:	b500      	push	{lr}
 800bd22:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 800bd24:	f7ff ffe4 	bl	800bcf0 <chSysLock>
  systime = chVTGetSystemTimeX();
 800bd28:	f7ff fff2 	bl	800bd10 <chVTGetSystemTimeX>
 800bd2c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 800bd2e:	f7ff ffe7 	bl	800bd00 <chSysUnlock>

  return systime;
 800bd32:	9b01      	ldr	r3, [sp, #4]
}
 800bd34:	4618      	mov	r0, r3
 800bd36:	b003      	add	sp, #12
 800bd38:	f85d fb04 	ldr.w	pc, [sp], #4
 800bd3c:	f3af 8000 	nop.w

0800bd40 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800bd40:	4b01      	ldr	r3, [pc, #4]	; (800bd48 <chThdGetSelfX+0x8>)
 800bd42:	699b      	ldr	r3, [r3, #24]
}
 800bd44:	4618      	mov	r0, r3
 800bd46:	4770      	bx	lr
 800bd48:	20000d98 	.word	0x20000d98
 800bd4c:	f3af 8000 	nop.w

0800bd50 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800bd50:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800bd52:	f7ff fff5 	bl	800bd40 <chThdGetSelfX>
 800bd56:	4603      	mov	r3, r0
 800bd58:	689b      	ldr	r3, [r3, #8]
}
 800bd5a:	4618      	mov	r0, r3
 800bd5c:	bd08      	pop	{r3, pc}
 800bd5e:	bf00      	nop

0800bd60 <chSemGetCounterI>:
 * @param[in] sp        pointer to a @p semaphore_t structure
 * @return              The semaphore counter value.
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {
 800bd60:	b082      	sub	sp, #8
 800bd62:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return sp->s_cnt;
 800bd64:	9b01      	ldr	r3, [sp, #4]
 800bd66:	689b      	ldr	r3, [r3, #8]
}
 800bd68:	4618      	mov	r0, r3
 800bd6a:	b002      	add	sp, #8
 800bd6c:	4770      	bx	lr
 800bd6e:	bf00      	nop

0800bd70 <chBSemObjectInit>:
 *                      - @a true, the initial state is taken.
 *                      .
 *
 * @init
 */
static inline void chBSemObjectInit(binary_semaphore_t *bsp, bool taken) {
 800bd70:	b500      	push	{lr}
 800bd72:	b083      	sub	sp, #12
 800bd74:	9001      	str	r0, [sp, #4]
 800bd76:	460b      	mov	r3, r1
 800bd78:	f88d 3003 	strb.w	r3, [sp, #3]

  chSemObjectInit(&bsp->bs_sem, taken ? (cnt_t)0 : (cnt_t)1);
 800bd7c:	9a01      	ldr	r2, [sp, #4]
 800bd7e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800bd82:	2b00      	cmp	r3, #0
 800bd84:	d001      	beq.n	800bd8a <chBSemObjectInit+0x1a>
 800bd86:	2300      	movs	r3, #0
 800bd88:	e000      	b.n	800bd8c <chBSemObjectInit+0x1c>
 800bd8a:	2301      	movs	r3, #1
 800bd8c:	4610      	mov	r0, r2
 800bd8e:	4619      	mov	r1, r3
 800bd90:	f7f5 fe96 	bl	8001ac0 <chSemObjectInit>
}
 800bd94:	b003      	add	sp, #12
 800bd96:	f85d fb04 	ldr.w	pc, [sp], #4
 800bd9a:	bf00      	nop
 800bd9c:	f3af 8000 	nop.w

0800bda0 <chBSemWait>:
 * @retval MSG_RESET    if the binary semaphore has been reset using
 *                      @p bsemReset().
 *
 * @api
 */
static inline msg_t chBSemWait(binary_semaphore_t *bsp) {
 800bda0:	b500      	push	{lr}
 800bda2:	b083      	sub	sp, #12
 800bda4:	9001      	str	r0, [sp, #4]

  return chSemWait(&bsp->bs_sem);
 800bda6:	9b01      	ldr	r3, [sp, #4]
 800bda8:	4618      	mov	r0, r3
 800bdaa:	f7f5 fed1 	bl	8001b50 <chSemWait>
 800bdae:	4603      	mov	r3, r0
}
 800bdb0:	4618      	mov	r0, r3
 800bdb2:	b003      	add	sp, #12
 800bdb4:	f85d fb04 	ldr.w	pc, [sp], #4
 800bdb8:	f3af 8000 	nop.w
 800bdbc:	f3af 8000 	nop.w

0800bdc0 <chBSemReset>:
 *                      - @a true, the new state is taken.
 *                      .
 *
 * @api
 */
static inline void chBSemReset(binary_semaphore_t *bsp, bool taken) {
 800bdc0:	b500      	push	{lr}
 800bdc2:	b083      	sub	sp, #12
 800bdc4:	9001      	str	r0, [sp, #4]
 800bdc6:	460b      	mov	r3, r1
 800bdc8:	f88d 3003 	strb.w	r3, [sp, #3]

  chSemReset(&bsp->bs_sem, taken ? (cnt_t)0 : (cnt_t)1);
 800bdcc:	9a01      	ldr	r2, [sp, #4]
 800bdce:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800bdd2:	2b00      	cmp	r3, #0
 800bdd4:	d001      	beq.n	800bdda <chBSemReset+0x1a>
 800bdd6:	2300      	movs	r3, #0
 800bdd8:	e000      	b.n	800bddc <chBSemReset+0x1c>
 800bdda:	2301      	movs	r3, #1
 800bddc:	4610      	mov	r0, r2
 800bdde:	4619      	mov	r1, r3
 800bde0:	f7f5 fe7e 	bl	8001ae0 <chSemReset>
}
 800bde4:	b003      	add	sp, #12
 800bde6:	f85d fb04 	ldr.w	pc, [sp], #4
 800bdea:	bf00      	nop
 800bdec:	f3af 8000 	nop.w

0800bdf0 <chBSemSignalI>:
 *
 * @param[in] bsp       pointer to a @p binary_semaphore_t structure
 *
 * @iclass
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {
 800bdf0:	b500      	push	{lr}
 800bdf2:	b083      	sub	sp, #12
 800bdf4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 800bdf6:	9b01      	ldr	r3, [sp, #4]
 800bdf8:	689b      	ldr	r3, [r3, #8]
 800bdfa:	2b00      	cmp	r3, #0
 800bdfc:	dc03      	bgt.n	800be06 <chBSemSignalI+0x16>
    chSemSignalI(&bsp->bs_sem);
 800bdfe:	9b01      	ldr	r3, [sp, #4]
 800be00:	4618      	mov	r0, r3
 800be02:	f7f5 ff45 	bl	8001c90 <chSemSignalI>
  }
}
 800be06:	b003      	add	sp, #12
 800be08:	f85d fb04 	ldr.w	pc, [sp], #4
 800be0c:	f3af 8000 	nop.w

0800be10 <chBSemSignal>:
 *
 * @param[in] bsp       pointer to a @p binary_semaphore_t structure
 *
 * @api
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {
 800be10:	b500      	push	{lr}
 800be12:	b083      	sub	sp, #12
 800be14:	9001      	str	r0, [sp, #4]

  chSysLock();
 800be16:	f7ff ff6b 	bl	800bcf0 <chSysLock>
  chBSemSignalI(bsp);
 800be1a:	9801      	ldr	r0, [sp, #4]
 800be1c:	f7ff ffe8 	bl	800bdf0 <chBSemSignalI>
  chSchRescheduleS();
 800be20:	f7f4 ffae 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 800be24:	f7ff ff6c 	bl	800bd00 <chSysUnlock>
}
 800be28:	b003      	add	sp, #12
 800be2a:	f85d fb04 	ldr.w	pc, [sp], #4
 800be2e:	bf00      	nop

0800be30 <chBSemGetStateI>:
 * @retval false        if the binary semaphore is not taken.
 * @retval true         if the binary semaphore is taken.
 *
 * @iclass
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {
 800be30:	b082      	sub	sp, #8
 800be32:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bsp->bs_sem.s_cnt > (cnt_t)0) ? false : true;
 800be34:	9b01      	ldr	r3, [sp, #4]
 800be36:	689b      	ldr	r3, [r3, #8]
 800be38:	2b00      	cmp	r3, #0
 800be3a:	bfcc      	ite	gt
 800be3c:	2300      	movgt	r3, #0
 800be3e:	2301      	movle	r3, #1
 800be40:	b2db      	uxtb	r3, r3
}
 800be42:	4618      	mov	r0, r3
 800be44:	b002      	add	sp, #8
 800be46:	4770      	bx	lr
 800be48:	f3af 8000 	nop.w
 800be4c:	f3af 8000 	nop.w

0800be50 <sem1_setup>:
 * The test expects that the threads reach their goal in FIFO order or
 * priority order depending on the CH_CFG_USE_SEMAPHORES_PRIORITY configuration
 * setting.
 */

static void sem1_setup(void) {
 800be50:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 0);
 800be52:	4802      	ldr	r0, [pc, #8]	; (800be5c <sem1_setup+0xc>)
 800be54:	2100      	movs	r1, #0
 800be56:	f7f5 fe33 	bl	8001ac0 <chSemObjectInit>
}
 800be5a:	bd08      	pop	{r3, pc}
 800be5c:	20000838 	.word	0x20000838

0800be60 <thread1>:

static THD_FUNCTION(thread1, p) {
 800be60:	b500      	push	{lr}
 800be62:	b083      	sub	sp, #12
 800be64:	9001      	str	r0, [sp, #4]

  chSemWait(&sem1);
 800be66:	4805      	ldr	r0, [pc, #20]	; (800be7c <thread1+0x1c>)
 800be68:	f7f5 fe72 	bl	8001b50 <chSemWait>
  test_emit_token(*(char *)p);
 800be6c:	9b01      	ldr	r3, [sp, #4]
 800be6e:	781b      	ldrb	r3, [r3, #0]
 800be70:	4618      	mov	r0, r3
 800be72:	f7ff f9ed 	bl	800b250 <test_emit_token>
}
 800be76:	b003      	add	sp, #12
 800be78:	f85d fb04 	ldr.w	pc, [sp], #4
 800be7c:	20000838 	.word	0x20000838

0800be80 <sem1_execute>:

static void sem1_execute(void) {
 800be80:	b510      	push	{r4, lr}
 800be82:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 800be84:	4b54      	ldr	r3, [pc, #336]	; (800bfd8 <sem1_execute+0x158>)
 800be86:	681c      	ldr	r4, [r3, #0]
 800be88:	f7ff ff62 	bl	800bd50 <chThdGetPriorityX>
 800be8c:	4603      	mov	r3, r0
 800be8e:	3305      	adds	r3, #5
 800be90:	4a52      	ldr	r2, [pc, #328]	; (800bfdc <sem1_execute+0x15c>)
 800be92:	9200      	str	r2, [sp, #0]
 800be94:	4620      	mov	r0, r4
 800be96:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800be9a:	461a      	mov	r2, r3
 800be9c:	4b50      	ldr	r3, [pc, #320]	; (800bfe0 <sem1_execute+0x160>)
 800be9e:	f7f5 f99f 	bl	80011e0 <chThdCreateStatic>
 800bea2:	4602      	mov	r2, r0
 800bea4:	4b4f      	ldr	r3, [pc, #316]	; (800bfe4 <sem1_execute+0x164>)
 800bea6:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 800bea8:	4b4b      	ldr	r3, [pc, #300]	; (800bfd8 <sem1_execute+0x158>)
 800beaa:	685c      	ldr	r4, [r3, #4]
 800beac:	f7ff ff50 	bl	800bd50 <chThdGetPriorityX>
 800beb0:	4603      	mov	r3, r0
 800beb2:	3301      	adds	r3, #1
 800beb4:	4a4c      	ldr	r2, [pc, #304]	; (800bfe8 <sem1_execute+0x168>)
 800beb6:	9200      	str	r2, [sp, #0]
 800beb8:	4620      	mov	r0, r4
 800beba:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800bebe:	461a      	mov	r2, r3
 800bec0:	4b47      	ldr	r3, [pc, #284]	; (800bfe0 <sem1_execute+0x160>)
 800bec2:	f7f5 f98d 	bl	80011e0 <chThdCreateStatic>
 800bec6:	4602      	mov	r2, r0
 800bec8:	4b46      	ldr	r3, [pc, #280]	; (800bfe4 <sem1_execute+0x164>)
 800beca:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 800becc:	4b42      	ldr	r3, [pc, #264]	; (800bfd8 <sem1_execute+0x158>)
 800bece:	689c      	ldr	r4, [r3, #8]
 800bed0:	f7ff ff3e 	bl	800bd50 <chThdGetPriorityX>
 800bed4:	4603      	mov	r3, r0
 800bed6:	3303      	adds	r3, #3
 800bed8:	4a44      	ldr	r2, [pc, #272]	; (800bfec <sem1_execute+0x16c>)
 800beda:	9200      	str	r2, [sp, #0]
 800bedc:	4620      	mov	r0, r4
 800bede:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800bee2:	461a      	mov	r2, r3
 800bee4:	4b3e      	ldr	r3, [pc, #248]	; (800bfe0 <sem1_execute+0x160>)
 800bee6:	f7f5 f97b 	bl	80011e0 <chThdCreateStatic>
 800beea:	4602      	mov	r2, r0
 800beec:	4b3d      	ldr	r3, [pc, #244]	; (800bfe4 <sem1_execute+0x164>)
 800beee:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 800bef0:	4b39      	ldr	r3, [pc, #228]	; (800bfd8 <sem1_execute+0x158>)
 800bef2:	68dc      	ldr	r4, [r3, #12]
 800bef4:	f7ff ff2c 	bl	800bd50 <chThdGetPriorityX>
 800bef8:	4603      	mov	r3, r0
 800befa:	3304      	adds	r3, #4
 800befc:	4a3c      	ldr	r2, [pc, #240]	; (800bff0 <sem1_execute+0x170>)
 800befe:	9200      	str	r2, [sp, #0]
 800bf00:	4620      	mov	r0, r4
 800bf02:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800bf06:	461a      	mov	r2, r3
 800bf08:	4b35      	ldr	r3, [pc, #212]	; (800bfe0 <sem1_execute+0x160>)
 800bf0a:	f7f5 f969 	bl	80011e0 <chThdCreateStatic>
 800bf0e:	4602      	mov	r2, r0
 800bf10:	4b34      	ldr	r3, [pc, #208]	; (800bfe4 <sem1_execute+0x164>)
 800bf12:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 800bf14:	4b30      	ldr	r3, [pc, #192]	; (800bfd8 <sem1_execute+0x158>)
 800bf16:	691c      	ldr	r4, [r3, #16]
 800bf18:	f7ff ff1a 	bl	800bd50 <chThdGetPriorityX>
 800bf1c:	4603      	mov	r3, r0
 800bf1e:	3302      	adds	r3, #2
 800bf20:	4a34      	ldr	r2, [pc, #208]	; (800bff4 <sem1_execute+0x174>)
 800bf22:	9200      	str	r2, [sp, #0]
 800bf24:	4620      	mov	r0, r4
 800bf26:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800bf2a:	461a      	mov	r2, r3
 800bf2c:	4b2c      	ldr	r3, [pc, #176]	; (800bfe0 <sem1_execute+0x160>)
 800bf2e:	f7f5 f957 	bl	80011e0 <chThdCreateStatic>
 800bf32:	4602      	mov	r2, r0
 800bf34:	4b2b      	ldr	r3, [pc, #172]	; (800bfe4 <sem1_execute+0x164>)
 800bf36:	611a      	str	r2, [r3, #16]
  chSemSignal(&sem1);
 800bf38:	482f      	ldr	r0, [pc, #188]	; (800bff8 <sem1_execute+0x178>)
 800bf3a:	f7f5 fe89 	bl	8001c50 <chSemSignal>
  chSemSignal(&sem1);
 800bf3e:	482e      	ldr	r0, [pc, #184]	; (800bff8 <sem1_execute+0x178>)
 800bf40:	f7f5 fe86 	bl	8001c50 <chSemSignal>
  chSemSignal(&sem1);
 800bf44:	482c      	ldr	r0, [pc, #176]	; (800bff8 <sem1_execute+0x178>)
 800bf46:	f7f5 fe83 	bl	8001c50 <chSemSignal>
  chSemSignal(&sem1);
 800bf4a:	482b      	ldr	r0, [pc, #172]	; (800bff8 <sem1_execute+0x178>)
 800bf4c:	f7f5 fe80 	bl	8001c50 <chSemSignal>
  chSemSignal(&sem1);
 800bf50:	4829      	ldr	r0, [pc, #164]	; (800bff8 <sem1_execute+0x178>)
 800bf52:	f7f5 fe7d 	bl	8001c50 <chSemSignal>
  test_wait_threads();
 800bf56:	f7ff fa2b 	bl	800b3b0 <test_wait_threads>
#if CH_CFG_USE_SEMAPHORES_PRIORITY
  test_assert_sequence(1, "ADCEB");
#else
  test_assert_sequence(1, "ABCDE");
 800bf5a:	2001      	movs	r0, #1
 800bf5c:	4927      	ldr	r1, [pc, #156]	; (800bffc <sem1_execute+0x17c>)
 800bf5e:	f7ff f9bf 	bl	800b2e0 <_test_assert_sequence>
 800bf62:	4603      	mov	r3, r0
 800bf64:	2b00      	cmp	r3, #0
 800bf66:	d000      	beq.n	800bf6a <sem1_execute+0xea>
 800bf68:	e034      	b.n	800bfd4 <sem1_execute+0x154>
#endif
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 800bf6a:	4b1b      	ldr	r3, [pc, #108]	; (800bfd8 <sem1_execute+0x158>)
 800bf6c:	681c      	ldr	r4, [r3, #0]
 800bf6e:	f7ff feef 	bl	800bd50 <chThdGetPriorityX>
 800bf72:	4603      	mov	r3, r0
 800bf74:	3305      	adds	r3, #5
 800bf76:	4a19      	ldr	r2, [pc, #100]	; (800bfdc <sem1_execute+0x15c>)
 800bf78:	9200      	str	r2, [sp, #0]
 800bf7a:	4620      	mov	r0, r4
 800bf7c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800bf80:	461a      	mov	r2, r3
 800bf82:	4b17      	ldr	r3, [pc, #92]	; (800bfe0 <sem1_execute+0x160>)
 800bf84:	f7f5 f92c 	bl	80011e0 <chThdCreateStatic>
 800bf88:	4602      	mov	r2, r0
 800bf8a:	4b16      	ldr	r3, [pc, #88]	; (800bfe4 <sem1_execute+0x164>)
 800bf8c:	601a      	str	r2, [r3, #0]
  chSysLock();
 800bf8e:	f7ff feaf 	bl	800bcf0 <chSysLock>
  chSemAddCounterI(&sem1, 2);
 800bf92:	4819      	ldr	r0, [pc, #100]	; (800bff8 <sem1_execute+0x178>)
 800bf94:	2102      	movs	r1, #2
 800bf96:	f7f5 fe9b 	bl	8001cd0 <chSemAddCounterI>
  chSchRescheduleS();
 800bf9a:	f7f4 fef1 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 800bf9e:	f7ff feaf 	bl	800bd00 <chSysUnlock>
  test_wait_threads();
 800bfa2:	f7ff fa05 	bl	800b3b0 <test_wait_threads>
  test_assert_lock(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
 800bfa6:	f7ff fea3 	bl	800bcf0 <chSysLock>
 800bfaa:	4813      	ldr	r0, [pc, #76]	; (800bff8 <sem1_execute+0x178>)
 800bfac:	f7ff fed8 	bl	800bd60 <chSemGetCounterI>
 800bfb0:	4603      	mov	r3, r0
 800bfb2:	2b01      	cmp	r3, #1
 800bfb4:	bf14      	ite	ne
 800bfb6:	2300      	movne	r3, #0
 800bfb8:	2301      	moveq	r3, #1
 800bfba:	b2db      	uxtb	r3, r3
 800bfbc:	2002      	movs	r0, #2
 800bfbe:	4619      	mov	r1, r3
 800bfc0:	f7ff f976 	bl	800b2b0 <_test_assert>
 800bfc4:	4603      	mov	r3, r0
 800bfc6:	2b00      	cmp	r3, #0
 800bfc8:	d002      	beq.n	800bfd0 <sem1_execute+0x150>
 800bfca:	f7ff fe99 	bl	800bd00 <chSysUnlock>
 800bfce:	e001      	b.n	800bfd4 <sem1_execute+0x154>
 800bfd0:	f7ff fe96 	bl	800bd00 <chSysUnlock>
}
 800bfd4:	b002      	add	sp, #8
 800bfd6:	bd10      	pop	{r4, pc}
 800bfd8:	08016240 	.word	0x08016240
 800bfdc:	08016530 	.word	0x08016530
 800bfe0:	0800be61 	.word	0x0800be61
 800bfe4:	20001224 	.word	0x20001224
 800bfe8:	08016534 	.word	0x08016534
 800bfec:	08016538 	.word	0x08016538
 800bff0:	0801653c 	.word	0x0801653c
 800bff4:	08016540 	.word	0x08016540
 800bff8:	20000838 	.word	0x20000838
 800bffc:	08016544 	.word	0x08016544

0800c000 <sem2_setup>:
 * The test expects that the semaphore wait function returns the correct value
 * in each of the above scenario and that the semaphore structure status is
 * correct after each operation.
 */

static void sem2_setup(void) {
 800c000:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 0);
 800c002:	4802      	ldr	r0, [pc, #8]	; (800c00c <sem2_setup+0xc>)
 800c004:	2100      	movs	r1, #0
 800c006:	f7f5 fd5b 	bl	8001ac0 <chSemObjectInit>
}
 800c00a:	bd08      	pop	{r3, pc}
 800c00c:	20000838 	.word	0x20000838

0800c010 <thread2>:

static THD_FUNCTION(thread2, p) {
 800c010:	b500      	push	{lr}
 800c012:	b083      	sub	sp, #12
 800c014:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(50);
 800c016:	2032      	movs	r0, #50	; 0x32
 800c018:	f7f5 f95a 	bl	80012d0 <chThdSleep>
  chSysLock();
 800c01c:	f7ff fe68 	bl	800bcf0 <chSysLock>
  chSemSignalI(&sem1); /* For coverage reasons */
 800c020:	4804      	ldr	r0, [pc, #16]	; (800c034 <thread2+0x24>)
 800c022:	f7f5 fe35 	bl	8001c90 <chSemSignalI>
  chSchRescheduleS();
 800c026:	f7f4 feab 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 800c02a:	f7ff fe69 	bl	800bd00 <chSysUnlock>
}
 800c02e:	b003      	add	sp, #12
 800c030:	f85d fb04 	ldr.w	pc, [sp], #4
 800c034:	20000838 	.word	0x20000838
 800c038:	f3af 8000 	nop.w
 800c03c:	f3af 8000 	nop.w

0800c040 <sem2_execute>:

static void sem2_execute(void) {
 800c040:	b510      	push	{r4, lr}
 800c042:	b086      	sub	sp, #24
  msg_t msg;

  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
 800c044:	4866      	ldr	r0, [pc, #408]	; (800c1e0 <sem2_execute+0x1a0>)
 800c046:	2100      	movs	r1, #0
 800c048:	f7f5 fdba 	bl	8001bc0 <chSemWaitTimeout>
 800c04c:	9004      	str	r0, [sp, #16]
  test_assert(1, msg == MSG_TIMEOUT, "wrong wake-up message");
 800c04e:	9b04      	ldr	r3, [sp, #16]
 800c050:	f1b3 3fff 	cmp.w	r3, #4294967295
 800c054:	bf14      	ite	ne
 800c056:	2300      	movne	r3, #0
 800c058:	2301      	moveq	r3, #1
 800c05a:	b2db      	uxtb	r3, r3
 800c05c:	2001      	movs	r0, #1
 800c05e:	4619      	mov	r1, r3
 800c060:	f7ff f926 	bl	800b2b0 <_test_assert>
 800c064:	4603      	mov	r3, r0
 800c066:	2b00      	cmp	r3, #0
 800c068:	d000      	beq.n	800c06c <sem2_execute+0x2c>
 800c06a:	e0b6      	b.n	800c1da <sem2_execute+0x19a>
  test_assert(2, queue_isempty(&sem1.s_queue), "queue not empty");
 800c06c:	485c      	ldr	r0, [pc, #368]	; (800c1e0 <sem2_execute+0x1a0>)
 800c06e:	f7ff fe2f 	bl	800bcd0 <queue_isempty>
 800c072:	4603      	mov	r3, r0
 800c074:	2002      	movs	r0, #2
 800c076:	4619      	mov	r1, r3
 800c078:	f7ff f91a 	bl	800b2b0 <_test_assert>
 800c07c:	4603      	mov	r3, r0
 800c07e:	2b00      	cmp	r3, #0
 800c080:	d000      	beq.n	800c084 <sem2_execute+0x44>
 800c082:	e0aa      	b.n	800c1da <sem2_execute+0x19a>
  test_assert(3, sem1.s_cnt == 0, "counter not zero");
 800c084:	4b56      	ldr	r3, [pc, #344]	; (800c1e0 <sem2_execute+0x1a0>)
 800c086:	689b      	ldr	r3, [r3, #8]
 800c088:	2b00      	cmp	r3, #0
 800c08a:	bf14      	ite	ne
 800c08c:	2300      	movne	r3, #0
 800c08e:	2301      	moveq	r3, #1
 800c090:	b2db      	uxtb	r3, r3
 800c092:	2003      	movs	r0, #3
 800c094:	4619      	mov	r1, r3
 800c096:	f7ff f90b 	bl	800b2b0 <_test_assert>
 800c09a:	4603      	mov	r3, r0
 800c09c:	2b00      	cmp	r3, #0
 800c09e:	d000      	beq.n	800c0a2 <sem2_execute+0x62>
 800c0a0:	e09b      	b.n	800c1da <sem2_execute+0x19a>

  /*
   * Testing not timeout condition.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800c0a2:	4b50      	ldr	r3, [pc, #320]	; (800c1e4 <sem2_execute+0x1a4>)
 800c0a4:	681c      	ldr	r4, [r3, #0]
 800c0a6:	f7ff fe53 	bl	800bd50 <chThdGetPriorityX>
 800c0aa:	4603      	mov	r3, r0
 800c0ac:	3b01      	subs	r3, #1
 800c0ae:	2200      	movs	r2, #0
 800c0b0:	9200      	str	r2, [sp, #0]
 800c0b2:	4620      	mov	r0, r4
 800c0b4:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c0b8:	461a      	mov	r2, r3
 800c0ba:	4b4b      	ldr	r3, [pc, #300]	; (800c1e8 <sem2_execute+0x1a8>)
 800c0bc:	f7f5 f890 	bl	80011e0 <chThdCreateStatic>
 800c0c0:	4602      	mov	r2, r0
 800c0c2:	4b4a      	ldr	r3, [pc, #296]	; (800c1ec <sem2_execute+0x1ac>)
 800c0c4:	601a      	str	r2, [r3, #0]
                                 thread2, 0);
  msg = chSemWaitTimeout(&sem1, MS2ST(500));
 800c0c6:	4846      	ldr	r0, [pc, #280]	; (800c1e0 <sem2_execute+0x1a0>)
 800c0c8:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 800c0cc:	f7f5 fd78 	bl	8001bc0 <chSemWaitTimeout>
 800c0d0:	9004      	str	r0, [sp, #16]
  test_wait_threads();
 800c0d2:	f7ff f96d 	bl	800b3b0 <test_wait_threads>
  test_assert(4, msg == MSG_OK, "wrong wake-up message");
 800c0d6:	9b04      	ldr	r3, [sp, #16]
 800c0d8:	2b00      	cmp	r3, #0
 800c0da:	bf14      	ite	ne
 800c0dc:	2300      	movne	r3, #0
 800c0de:	2301      	moveq	r3, #1
 800c0e0:	b2db      	uxtb	r3, r3
 800c0e2:	2004      	movs	r0, #4
 800c0e4:	4619      	mov	r1, r3
 800c0e6:	f7ff f8e3 	bl	800b2b0 <_test_assert>
 800c0ea:	4603      	mov	r3, r0
 800c0ec:	2b00      	cmp	r3, #0
 800c0ee:	d000      	beq.n	800c0f2 <sem2_execute+0xb2>
 800c0f0:	e073      	b.n	800c1da <sem2_execute+0x19a>
  test_assert(5, queue_isempty(&sem1.s_queue), "queue not empty");
 800c0f2:	483b      	ldr	r0, [pc, #236]	; (800c1e0 <sem2_execute+0x1a0>)
 800c0f4:	f7ff fdec 	bl	800bcd0 <queue_isempty>
 800c0f8:	4603      	mov	r3, r0
 800c0fa:	2005      	movs	r0, #5
 800c0fc:	4619      	mov	r1, r3
 800c0fe:	f7ff f8d7 	bl	800b2b0 <_test_assert>
 800c102:	4603      	mov	r3, r0
 800c104:	2b00      	cmp	r3, #0
 800c106:	d000      	beq.n	800c10a <sem2_execute+0xca>
 800c108:	e067      	b.n	800c1da <sem2_execute+0x19a>
  test_assert(6, sem1.s_cnt == 0, "counter not zero");
 800c10a:	4b35      	ldr	r3, [pc, #212]	; (800c1e0 <sem2_execute+0x1a0>)
 800c10c:	689b      	ldr	r3, [r3, #8]
 800c10e:	2b00      	cmp	r3, #0
 800c110:	bf14      	ite	ne
 800c112:	2300      	movne	r3, #0
 800c114:	2301      	moveq	r3, #1
 800c116:	b2db      	uxtb	r3, r3
 800c118:	2006      	movs	r0, #6
 800c11a:	4619      	mov	r1, r3
 800c11c:	f7ff f8c8 	bl	800b2b0 <_test_assert>
 800c120:	4603      	mov	r3, r0
 800c122:	2b00      	cmp	r3, #0
 800c124:	d000      	beq.n	800c128 <sem2_execute+0xe8>
 800c126:	e058      	b.n	800c1da <sem2_execute+0x19a>

  /*
   * Testing timeout condition.
   */
  test_wait_tick();
 800c128:	f7ff f96a 	bl	800b400 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
 800c12c:	f7ff fdf8 	bl	800bd20 <chVTGetSystemTime>
 800c130:	4603      	mov	r3, r0
 800c132:	33fa      	adds	r3, #250	; 0xfa
 800c134:	9303      	str	r3, [sp, #12]
  for (i = 0; i < 5; i++) {
 800c136:	2300      	movs	r3, #0
 800c138:	9305      	str	r3, [sp, #20]
 800c13a:	e038      	b.n	800c1ae <sem2_execute+0x16e>
    test_emit_token('A' + i);
 800c13c:	9b05      	ldr	r3, [sp, #20]
 800c13e:	b2db      	uxtb	r3, r3
 800c140:	3341      	adds	r3, #65	; 0x41
 800c142:	b2db      	uxtb	r3, r3
 800c144:	4618      	mov	r0, r3
 800c146:	f7ff f883 	bl	800b250 <test_emit_token>
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
 800c14a:	4825      	ldr	r0, [pc, #148]	; (800c1e0 <sem2_execute+0x1a0>)
 800c14c:	2132      	movs	r1, #50	; 0x32
 800c14e:	f7f5 fd37 	bl	8001bc0 <chSemWaitTimeout>
 800c152:	9004      	str	r0, [sp, #16]
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
 800c154:	9b04      	ldr	r3, [sp, #16]
 800c156:	f1b3 3fff 	cmp.w	r3, #4294967295
 800c15a:	bf14      	ite	ne
 800c15c:	2300      	movne	r3, #0
 800c15e:	2301      	moveq	r3, #1
 800c160:	b2db      	uxtb	r3, r3
 800c162:	2007      	movs	r0, #7
 800c164:	4619      	mov	r1, r3
 800c166:	f7ff f8a3 	bl	800b2b0 <_test_assert>
 800c16a:	4603      	mov	r3, r0
 800c16c:	2b00      	cmp	r3, #0
 800c16e:	d000      	beq.n	800c172 <sem2_execute+0x132>
 800c170:	e033      	b.n	800c1da <sem2_execute+0x19a>
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
 800c172:	481b      	ldr	r0, [pc, #108]	; (800c1e0 <sem2_execute+0x1a0>)
 800c174:	f7ff fdac 	bl	800bcd0 <queue_isempty>
 800c178:	4603      	mov	r3, r0
 800c17a:	2008      	movs	r0, #8
 800c17c:	4619      	mov	r1, r3
 800c17e:	f7ff f897 	bl	800b2b0 <_test_assert>
 800c182:	4603      	mov	r3, r0
 800c184:	2b00      	cmp	r3, #0
 800c186:	d000      	beq.n	800c18a <sem2_execute+0x14a>
 800c188:	e027      	b.n	800c1da <sem2_execute+0x19a>
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
 800c18a:	4b15      	ldr	r3, [pc, #84]	; (800c1e0 <sem2_execute+0x1a0>)
 800c18c:	689b      	ldr	r3, [r3, #8]
 800c18e:	2b00      	cmp	r3, #0
 800c190:	bf14      	ite	ne
 800c192:	2300      	movne	r3, #0
 800c194:	2301      	moveq	r3, #1
 800c196:	b2db      	uxtb	r3, r3
 800c198:	2009      	movs	r0, #9
 800c19a:	4619      	mov	r1, r3
 800c19c:	f7ff f888 	bl	800b2b0 <_test_assert>
 800c1a0:	4603      	mov	r3, r0
 800c1a2:	2b00      	cmp	r3, #0
 800c1a4:	d000      	beq.n	800c1a8 <sem2_execute+0x168>
 800c1a6:	e018      	b.n	800c1da <sem2_execute+0x19a>
  /*
   * Testing timeout condition.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
  for (i = 0; i < 5; i++) {
 800c1a8:	9b05      	ldr	r3, [sp, #20]
 800c1aa:	3301      	adds	r3, #1
 800c1ac:	9305      	str	r3, [sp, #20]
 800c1ae:	9b05      	ldr	r3, [sp, #20]
 800c1b0:	2b04      	cmp	r3, #4
 800c1b2:	ddc3      	ble.n	800c13c <sem2_execute+0xfc>
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
 800c1b4:	200a      	movs	r0, #10
 800c1b6:	490e      	ldr	r1, [pc, #56]	; (800c1f0 <sem2_execute+0x1b0>)
 800c1b8:	f7ff f892 	bl	800b2e0 <_test_assert_sequence>
 800c1bc:	4603      	mov	r3, r0
 800c1be:	2b00      	cmp	r3, #0
 800c1c0:	d000      	beq.n	800c1c4 <sem2_execute+0x184>
 800c1c2:	e00a      	b.n	800c1da <sem2_execute+0x19a>
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
 800c1c4:	9b03      	ldr	r3, [sp, #12]
 800c1c6:	3302      	adds	r3, #2
 800c1c8:	200b      	movs	r0, #11
 800c1ca:	9903      	ldr	r1, [sp, #12]
 800c1cc:	461a      	mov	r2, r3
 800c1ce:	f7ff f8b7 	bl	800b340 <_test_assert_time_window>
 800c1d2:	4603      	mov	r3, r0
 800c1d4:	2b00      	cmp	r3, #0
 800c1d6:	d000      	beq.n	800c1da <sem2_execute+0x19a>
 800c1d8:	bf00      	nop
}
 800c1da:	b006      	add	sp, #24
 800c1dc:	bd10      	pop	{r4, pc}
 800c1de:	bf00      	nop
 800c1e0:	20000838 	.word	0x20000838
 800c1e4:	08016240 	.word	0x08016240
 800c1e8:	0800c011 	.word	0x0800c011
 800c1ec:	20001224 	.word	0x20001224
 800c1f0:	08016544 	.word	0x08016544
 800c1f4:	f3af 8000 	nop.w
 800c1f8:	f3af 8000 	nop.w
 800c1fc:	f3af 8000 	nop.w

0800c200 <sem3_setup>:
 * The test expects that the semaphore wait function returns the correct value
 * in each of the above scenario and that the semaphore structure status is
 * correct after each operation.
 */

static void sem3_setup(void) {
 800c200:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 0);
 800c202:	4802      	ldr	r0, [pc, #8]	; (800c20c <sem3_setup+0xc>)
 800c204:	2100      	movs	r1, #0
 800c206:	f7f5 fc5b 	bl	8001ac0 <chSemObjectInit>
}
 800c20a:	bd08      	pop	{r3, pc}
 800c20c:	20000838 	.word	0x20000838

0800c210 <thread3>:

static THD_FUNCTION(thread3, p) {
 800c210:	b500      	push	{lr}
 800c212:	b083      	sub	sp, #12
 800c214:	9001      	str	r0, [sp, #4]

  (void)p;
  chSemWait(&sem1);
 800c216:	4804      	ldr	r0, [pc, #16]	; (800c228 <thread3+0x18>)
 800c218:	f7f5 fc9a 	bl	8001b50 <chSemWait>
  chSemSignal(&sem1);
 800c21c:	4802      	ldr	r0, [pc, #8]	; (800c228 <thread3+0x18>)
 800c21e:	f7f5 fd17 	bl	8001c50 <chSemSignal>
}
 800c222:	b003      	add	sp, #12
 800c224:	f85d fb04 	ldr.w	pc, [sp], #4
 800c228:	20000838 	.word	0x20000838
 800c22c:	f3af 8000 	nop.w

0800c230 <sem3_execute>:

static void sem3_execute(void) {
 800c230:	b510      	push	{r4, lr}
 800c232:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 800c234:	4b28      	ldr	r3, [pc, #160]	; (800c2d8 <sem3_execute+0xa8>)
 800c236:	681c      	ldr	r4, [r3, #0]
 800c238:	f7ff fd8a 	bl	800bd50 <chThdGetPriorityX>
 800c23c:	4603      	mov	r3, r0
 800c23e:	3301      	adds	r3, #1
 800c240:	2200      	movs	r2, #0
 800c242:	9200      	str	r2, [sp, #0]
 800c244:	4620      	mov	r0, r4
 800c246:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c24a:	461a      	mov	r2, r3
 800c24c:	4b23      	ldr	r3, [pc, #140]	; (800c2dc <sem3_execute+0xac>)
 800c24e:	f7f4 ffc7 	bl	80011e0 <chThdCreateStatic>
 800c252:	4602      	mov	r2, r0
 800c254:	4b22      	ldr	r3, [pc, #136]	; (800c2e0 <sem3_execute+0xb0>)
 800c256:	601a      	str	r2, [r3, #0]
  chSemSignalWait(&sem1, &sem1);
 800c258:	4822      	ldr	r0, [pc, #136]	; (800c2e4 <sem3_execute+0xb4>)
 800c25a:	4922      	ldr	r1, [pc, #136]	; (800c2e4 <sem3_execute+0xb4>)
 800c25c:	f7f5 fd60 	bl	8001d20 <chSemSignalWait>
  test_assert(1, queue_isempty(&sem1.s_queue), "queue not empty");
 800c260:	4820      	ldr	r0, [pc, #128]	; (800c2e4 <sem3_execute+0xb4>)
 800c262:	f7ff fd35 	bl	800bcd0 <queue_isempty>
 800c266:	4603      	mov	r3, r0
 800c268:	2001      	movs	r0, #1
 800c26a:	4619      	mov	r1, r3
 800c26c:	f7ff f820 	bl	800b2b0 <_test_assert>
 800c270:	4603      	mov	r3, r0
 800c272:	2b00      	cmp	r3, #0
 800c274:	d000      	beq.n	800c278 <sem3_execute+0x48>
 800c276:	e02d      	b.n	800c2d4 <sem3_execute+0xa4>
  test_assert(2, sem1.s_cnt == 0, "counter not zero");
 800c278:	4b1a      	ldr	r3, [pc, #104]	; (800c2e4 <sem3_execute+0xb4>)
 800c27a:	689b      	ldr	r3, [r3, #8]
 800c27c:	2b00      	cmp	r3, #0
 800c27e:	bf14      	ite	ne
 800c280:	2300      	movne	r3, #0
 800c282:	2301      	moveq	r3, #1
 800c284:	b2db      	uxtb	r3, r3
 800c286:	2002      	movs	r0, #2
 800c288:	4619      	mov	r1, r3
 800c28a:	f7ff f811 	bl	800b2b0 <_test_assert>
 800c28e:	4603      	mov	r3, r0
 800c290:	2b00      	cmp	r3, #0
 800c292:	d000      	beq.n	800c296 <sem3_execute+0x66>
 800c294:	e01e      	b.n	800c2d4 <sem3_execute+0xa4>

  chSemSignalWait(&sem1, &sem1);
 800c296:	4813      	ldr	r0, [pc, #76]	; (800c2e4 <sem3_execute+0xb4>)
 800c298:	4912      	ldr	r1, [pc, #72]	; (800c2e4 <sem3_execute+0xb4>)
 800c29a:	f7f5 fd41 	bl	8001d20 <chSemSignalWait>
  test_assert(3, queue_isempty(&sem1.s_queue), "queue not empty");
 800c29e:	4811      	ldr	r0, [pc, #68]	; (800c2e4 <sem3_execute+0xb4>)
 800c2a0:	f7ff fd16 	bl	800bcd0 <queue_isempty>
 800c2a4:	4603      	mov	r3, r0
 800c2a6:	2003      	movs	r0, #3
 800c2a8:	4619      	mov	r1, r3
 800c2aa:	f7ff f801 	bl	800b2b0 <_test_assert>
 800c2ae:	4603      	mov	r3, r0
 800c2b0:	2b00      	cmp	r3, #0
 800c2b2:	d000      	beq.n	800c2b6 <sem3_execute+0x86>
 800c2b4:	e00e      	b.n	800c2d4 <sem3_execute+0xa4>
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
 800c2b6:	4b0b      	ldr	r3, [pc, #44]	; (800c2e4 <sem3_execute+0xb4>)
 800c2b8:	689b      	ldr	r3, [r3, #8]
 800c2ba:	2b00      	cmp	r3, #0
 800c2bc:	bf14      	ite	ne
 800c2be:	2300      	movne	r3, #0
 800c2c0:	2301      	moveq	r3, #1
 800c2c2:	b2db      	uxtb	r3, r3
 800c2c4:	2004      	movs	r0, #4
 800c2c6:	4619      	mov	r1, r3
 800c2c8:	f7fe fff2 	bl	800b2b0 <_test_assert>
 800c2cc:	4603      	mov	r3, r0
 800c2ce:	2b00      	cmp	r3, #0
 800c2d0:	d000      	beq.n	800c2d4 <sem3_execute+0xa4>
 800c2d2:	bf00      	nop
}
 800c2d4:	b002      	add	sp, #8
 800c2d6:	bd10      	pop	{r4, pc}
 800c2d8:	08016240 	.word	0x08016240
 800c2dc:	0800c211 	.word	0x0800c211
 800c2e0:	20001224 	.word	0x20001224
 800c2e4:	20000838 	.word	0x20000838
 800c2e8:	f3af 8000 	nop.w
 800c2ec:	f3af 8000 	nop.w

0800c2f0 <thread4>:
 * <h2>Description</h2>
 * This test case tests the binary semaphores functionality. The test both
 * checks the binary semaphore status and the expected status of the underlying
 * counting semaphore.
 */
static THD_FUNCTION(thread4, p) {
 800c2f0:	b500      	push	{lr}
 800c2f2:	b083      	sub	sp, #12
 800c2f4:	9001      	str	r0, [sp, #4]

  chBSemSignal((binary_semaphore_t *)p);
 800c2f6:	9801      	ldr	r0, [sp, #4]
 800c2f8:	f7ff fd8a 	bl	800be10 <chBSemSignal>
}
 800c2fc:	b003      	add	sp, #12
 800c2fe:	f85d fb04 	ldr.w	pc, [sp], #4
 800c302:	bf00      	nop
 800c304:	f3af 8000 	nop.w
 800c308:	f3af 8000 	nop.w
 800c30c:	f3af 8000 	nop.w

0800c310 <sem4_execute>:

static void sem4_execute(void) {
 800c310:	b510      	push	{r4, lr}
 800c312:	b086      	sub	sp, #24
  binary_semaphore_t bsem;
  
  /* Creates a taken binary semaphore.*/
  chBSemObjectInit(&bsem, TRUE);
 800c314:	ab03      	add	r3, sp, #12
 800c316:	4618      	mov	r0, r3
 800c318:	2101      	movs	r1, #1
 800c31a:	f7ff fd29 	bl	800bd70 <chBSemObjectInit>
  chBSemReset(&bsem, TRUE);
 800c31e:	ab03      	add	r3, sp, #12
 800c320:	4618      	mov	r0, r3
 800c322:	2101      	movs	r1, #1
 800c324:	f7ff fd4c 	bl	800bdc0 <chBSemReset>
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");
 800c328:	f7ff fce2 	bl	800bcf0 <chSysLock>
 800c32c:	ab03      	add	r3, sp, #12
 800c32e:	4618      	mov	r0, r3
 800c330:	f7ff fd7e 	bl	800be30 <chBSemGetStateI>
 800c334:	4603      	mov	r3, r0
 800c336:	2b00      	cmp	r3, #0
 800c338:	bf0c      	ite	eq
 800c33a:	2300      	moveq	r3, #0
 800c33c:	2301      	movne	r3, #1
 800c33e:	b2db      	uxtb	r3, r3
 800c340:	2001      	movs	r0, #1
 800c342:	4619      	mov	r1, r3
 800c344:	f7fe ffb4 	bl	800b2b0 <_test_assert>
 800c348:	4603      	mov	r3, r0
 800c34a:	2b00      	cmp	r3, #0
 800c34c:	d002      	beq.n	800c354 <sem4_execute+0x44>
 800c34e:	f7ff fcd7 	bl	800bd00 <chSysUnlock>
 800c352:	e0a3      	b.n	800c49c <sem4_execute+0x18c>
 800c354:	f7ff fcd4 	bl	800bd00 <chSysUnlock>

  /* Starts a signaler thread at a lower priority.*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 800c358:	4b51      	ldr	r3, [pc, #324]	; (800c4a0 <sem4_execute+0x190>)
 800c35a:	681c      	ldr	r4, [r3, #0]
                                 chThdGetPriorityX()-1, thread4, &bsem);
 800c35c:	f7ff fcf8 	bl	800bd50 <chThdGetPriorityX>
 800c360:	4603      	mov	r3, r0
  chBSemObjectInit(&bsem, TRUE);
  chBSemReset(&bsem, TRUE);
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");

  /* Starts a signaler thread at a lower priority.*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 800c362:	3b01      	subs	r3, #1
 800c364:	aa03      	add	r2, sp, #12
 800c366:	9200      	str	r2, [sp, #0]
 800c368:	4620      	mov	r0, r4
 800c36a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c36e:	461a      	mov	r2, r3
 800c370:	4b4c      	ldr	r3, [pc, #304]	; (800c4a4 <sem4_execute+0x194>)
 800c372:	f7f4 ff35 	bl	80011e0 <chThdCreateStatic>
 800c376:	4602      	mov	r2, r0
 800c378:	4b4b      	ldr	r3, [pc, #300]	; (800c4a8 <sem4_execute+0x198>)
 800c37a:	601a      	str	r2, [r3, #0]
                                 chThdGetPriorityX()-1, thread4, &bsem);
                                 
  /* Waits to be signaled.*/
  chBSemWait(&bsem);
 800c37c:	ab03      	add	r3, sp, #12
 800c37e:	4618      	mov	r0, r3
 800c380:	f7ff fd0e 	bl	800bda0 <chBSemWait>
  
  /* The binary semaphore is expected to be taken.*/
  test_assert_lock(2, chBSemGetStateI(&bsem) == TRUE, "not taken");
 800c384:	f7ff fcb4 	bl	800bcf0 <chSysLock>
 800c388:	ab03      	add	r3, sp, #12
 800c38a:	4618      	mov	r0, r3
 800c38c:	f7ff fd50 	bl	800be30 <chBSemGetStateI>
 800c390:	4603      	mov	r3, r0
 800c392:	2b00      	cmp	r3, #0
 800c394:	bf0c      	ite	eq
 800c396:	2300      	moveq	r3, #0
 800c398:	2301      	movne	r3, #1
 800c39a:	b2db      	uxtb	r3, r3
 800c39c:	2002      	movs	r0, #2
 800c39e:	4619      	mov	r1, r3
 800c3a0:	f7fe ff86 	bl	800b2b0 <_test_assert>
 800c3a4:	4603      	mov	r3, r0
 800c3a6:	2b00      	cmp	r3, #0
 800c3a8:	d002      	beq.n	800c3b0 <sem4_execute+0xa0>
 800c3aa:	f7ff fca9 	bl	800bd00 <chSysUnlock>
 800c3ae:	e075      	b.n	800c49c <sem4_execute+0x18c>
 800c3b0:	f7ff fca6 	bl	800bd00 <chSysUnlock>

  /* Releasing it, check both the binary semaphore state and the underlying
     counter semaphore state..*/
  chBSemSignal(&bsem);
 800c3b4:	ab03      	add	r3, sp, #12
 800c3b6:	4618      	mov	r0, r3
 800c3b8:	f7ff fd2a 	bl	800be10 <chBSemSignal>
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "still taken");
 800c3bc:	f7ff fc98 	bl	800bcf0 <chSysLock>
 800c3c0:	ab03      	add	r3, sp, #12
 800c3c2:	4618      	mov	r0, r3
 800c3c4:	f7ff fd34 	bl	800be30 <chBSemGetStateI>
 800c3c8:	4603      	mov	r3, r0
 800c3ca:	2b00      	cmp	r3, #0
 800c3cc:	bf0c      	ite	eq
 800c3ce:	2300      	moveq	r3, #0
 800c3d0:	2301      	movne	r3, #1
 800c3d2:	b2db      	uxtb	r3, r3
 800c3d4:	f083 0301 	eor.w	r3, r3, #1
 800c3d8:	b2db      	uxtb	r3, r3
 800c3da:	f003 0301 	and.w	r3, r3, #1
 800c3de:	b2db      	uxtb	r3, r3
 800c3e0:	2003      	movs	r0, #3
 800c3e2:	4619      	mov	r1, r3
 800c3e4:	f7fe ff64 	bl	800b2b0 <_test_assert>
 800c3e8:	4603      	mov	r3, r0
 800c3ea:	2b00      	cmp	r3, #0
 800c3ec:	d002      	beq.n	800c3f4 <sem4_execute+0xe4>
 800c3ee:	f7ff fc87 	bl	800bd00 <chSysUnlock>
 800c3f2:	e053      	b.n	800c49c <sem4_execute+0x18c>
 800c3f4:	f7ff fc84 	bl	800bd00 <chSysUnlock>
  test_assert_lock(4, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 800c3f8:	f7ff fc7a 	bl	800bcf0 <chSysLock>
 800c3fc:	ab03      	add	r3, sp, #12
 800c3fe:	4618      	mov	r0, r3
 800c400:	f7ff fcae 	bl	800bd60 <chSemGetCounterI>
 800c404:	4603      	mov	r3, r0
 800c406:	2b01      	cmp	r3, #1
 800c408:	bf14      	ite	ne
 800c40a:	2300      	movne	r3, #0
 800c40c:	2301      	moveq	r3, #1
 800c40e:	b2db      	uxtb	r3, r3
 800c410:	2004      	movs	r0, #4
 800c412:	4619      	mov	r1, r3
 800c414:	f7fe ff4c 	bl	800b2b0 <_test_assert>
 800c418:	4603      	mov	r3, r0
 800c41a:	2b00      	cmp	r3, #0
 800c41c:	d002      	beq.n	800c424 <sem4_execute+0x114>
 800c41e:	f7ff fc6f 	bl	800bd00 <chSysUnlock>
 800c422:	e03b      	b.n	800c49c <sem4_execute+0x18c>
 800c424:	f7ff fc6c 	bl	800bd00 <chSysUnlock>

  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
 800c428:	ab03      	add	r3, sp, #12
 800c42a:	4618      	mov	r0, r3
 800c42c:	f7ff fcf0 	bl	800be10 <chBSemSignal>
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
 800c430:	f7ff fc5e 	bl	800bcf0 <chSysLock>
 800c434:	ab03      	add	r3, sp, #12
 800c436:	4618      	mov	r0, r3
 800c438:	f7ff fcfa 	bl	800be30 <chBSemGetStateI>
 800c43c:	4603      	mov	r3, r0
 800c43e:	2b00      	cmp	r3, #0
 800c440:	bf0c      	ite	eq
 800c442:	2300      	moveq	r3, #0
 800c444:	2301      	movne	r3, #1
 800c446:	b2db      	uxtb	r3, r3
 800c448:	f083 0301 	eor.w	r3, r3, #1
 800c44c:	b2db      	uxtb	r3, r3
 800c44e:	f003 0301 	and.w	r3, r3, #1
 800c452:	b2db      	uxtb	r3, r3
 800c454:	2003      	movs	r0, #3
 800c456:	4619      	mov	r1, r3
 800c458:	f7fe ff2a 	bl	800b2b0 <_test_assert>
 800c45c:	4603      	mov	r3, r0
 800c45e:	2b00      	cmp	r3, #0
 800c460:	d002      	beq.n	800c468 <sem4_execute+0x158>
 800c462:	f7ff fc4d 	bl	800bd00 <chSysUnlock>
 800c466:	e019      	b.n	800c49c <sem4_execute+0x18c>
 800c468:	f7ff fc4a 	bl	800bd00 <chSysUnlock>
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 800c46c:	f7ff fc40 	bl	800bcf0 <chSysLock>
 800c470:	ab03      	add	r3, sp, #12
 800c472:	4618      	mov	r0, r3
 800c474:	f7ff fc74 	bl	800bd60 <chSemGetCounterI>
 800c478:	4603      	mov	r3, r0
 800c47a:	2b01      	cmp	r3, #1
 800c47c:	bf14      	ite	ne
 800c47e:	2300      	movne	r3, #0
 800c480:	2301      	moveq	r3, #1
 800c482:	b2db      	uxtb	r3, r3
 800c484:	2005      	movs	r0, #5
 800c486:	4619      	mov	r1, r3
 800c488:	f7fe ff12 	bl	800b2b0 <_test_assert>
 800c48c:	4603      	mov	r3, r0
 800c48e:	2b00      	cmp	r3, #0
 800c490:	d002      	beq.n	800c498 <sem4_execute+0x188>
 800c492:	f7ff fc35 	bl	800bd00 <chSysUnlock>
 800c496:	e001      	b.n	800c49c <sem4_execute+0x18c>
 800c498:	f7ff fc32 	bl	800bd00 <chSysUnlock>
}
 800c49c:	b006      	add	sp, #24
 800c49e:	bd10      	pop	{r4, pc}
 800c4a0:	08016240 	.word	0x08016240
 800c4a4:	0800c2f1 	.word	0x0800c2f1
 800c4a8:	20001224 	.word	0x20001224
 800c4ac:	f3af 8000 	nop.w

0800c4b0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800c4b0:	b082      	sub	sp, #8
 800c4b2:	2320      	movs	r3, #32
 800c4b4:	9301      	str	r3, [sp, #4]
 800c4b6:	9b01      	ldr	r3, [sp, #4]
 800c4b8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800c4bc:	b002      	add	sp, #8
 800c4be:	4770      	bx	lr

0800c4c0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800c4c0:	b082      	sub	sp, #8
 800c4c2:	2300      	movs	r3, #0
 800c4c4:	9301      	str	r3, [sp, #4]
 800c4c6:	9b01      	ldr	r3, [sp, #4]
 800c4c8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800c4cc:	b002      	add	sp, #8
 800c4ce:	4770      	bx	lr

0800c4d0 <queue_isempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {
 800c4d0:	b082      	sub	sp, #8
 800c4d2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next == (const thread_t *)tqp);
 800c4d4:	9b01      	ldr	r3, [sp, #4]
 800c4d6:	681a      	ldr	r2, [r3, #0]
 800c4d8:	9b01      	ldr	r3, [sp, #4]
 800c4da:	429a      	cmp	r2, r3
 800c4dc:	bf14      	ite	ne
 800c4de:	2300      	movne	r3, #0
 800c4e0:	2301      	moveq	r3, #1
 800c4e2:	b2db      	uxtb	r3, r3
}
 800c4e4:	4618      	mov	r0, r3
 800c4e6:	b002      	add	sp, #8
 800c4e8:	4770      	bx	lr
 800c4ea:	bf00      	nop
 800c4ec:	f3af 8000 	nop.w

0800c4f0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800c4f0:	b508      	push	{r3, lr}

  port_lock();
 800c4f2:	f7ff ffdd 	bl	800c4b0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800c4f6:	bd08      	pop	{r3, pc}
 800c4f8:	f3af 8000 	nop.w
 800c4fc:	f3af 8000 	nop.w

0800c500 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800c500:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800c502:	f7ff ffdd 	bl	800c4c0 <port_unlock>
}
 800c506:	bd08      	pop	{r3, pc}
 800c508:	f3af 8000 	nop.w
 800c50c:	f3af 8000 	nop.w

0800c510 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800c510:	4b01      	ldr	r3, [pc, #4]	; (800c518 <chThdGetSelfX+0x8>)
 800c512:	699b      	ldr	r3, [r3, #24]
}
 800c514:	4618      	mov	r0, r3
 800c516:	4770      	bx	lr
 800c518:	20000d98 	.word	0x20000d98
 800c51c:	f3af 8000 	nop.w

0800c520 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800c520:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800c522:	f7ff fff5 	bl	800c510 <chThdGetSelfX>
 800c526:	4603      	mov	r3, r0
 800c528:	689b      	ldr	r3, [r3, #8]
}
 800c52a:	4618      	mov	r0, r3
 800c52c:	bd08      	pop	{r3, pc}
 800c52e:	bf00      	nop

0800c530 <mtx1_setup>:
 * the mutex is unlocked.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void mtx1_setup(void) {
 800c530:	b508      	push	{r3, lr}

  chMtxObjectInit(&m1);
 800c532:	4802      	ldr	r0, [pc, #8]	; (800c53c <mtx1_setup+0xc>)
 800c534:	f7f5 fcdc 	bl	8001ef0 <chMtxObjectInit>
}
 800c538:	bd08      	pop	{r3, pc}
 800c53a:	bf00      	nop
 800c53c:	20000844 	.word	0x20000844

0800c540 <thread1>:

static THD_FUNCTION(thread1, p) {
 800c540:	b500      	push	{lr}
 800c542:	b083      	sub	sp, #12
 800c544:	9001      	str	r0, [sp, #4]

  chMtxLock(&m1);
 800c546:	4807      	ldr	r0, [pc, #28]	; (800c564 <thread1+0x24>)
 800c548:	f7f5 fce2 	bl	8001f10 <chMtxLock>
  test_emit_token(*(char *)p);
 800c54c:	9b01      	ldr	r3, [sp, #4]
 800c54e:	781b      	ldrb	r3, [r3, #0]
 800c550:	4618      	mov	r0, r3
 800c552:	f7fe fe7d 	bl	800b250 <test_emit_token>
  chMtxUnlock(&m1);
 800c556:	4803      	ldr	r0, [pc, #12]	; (800c564 <thread1+0x24>)
 800c558:	f7f5 fd82 	bl	8002060 <chMtxUnlock>
}
 800c55c:	b003      	add	sp, #12
 800c55e:	f85d fb04 	ldr.w	pc, [sp], #4
 800c562:	bf00      	nop
 800c564:	20000844 	.word	0x20000844
 800c568:	f3af 8000 	nop.w
 800c56c:	f3af 8000 	nop.w

0800c570 <mtx1_execute>:

static void mtx1_execute(void) {
 800c570:	b500      	push	{lr}
 800c572:	b085      	sub	sp, #20

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
 800c574:	f7ff ffd4 	bl	800c520 <chThdGetPriorityX>
 800c578:	9003      	str	r0, [sp, #12]
  chMtxLock(&m1);
 800c57a:	483a      	ldr	r0, [pc, #232]	; (800c664 <mtx1_execute+0xf4>)
 800c57c:	f7f5 fcc8 	bl	8001f10 <chMtxLock>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 800c580:	4b39      	ldr	r3, [pc, #228]	; (800c668 <mtx1_execute+0xf8>)
 800c582:	681a      	ldr	r2, [r3, #0]
 800c584:	9b03      	ldr	r3, [sp, #12]
 800c586:	3301      	adds	r3, #1
 800c588:	4938      	ldr	r1, [pc, #224]	; (800c66c <mtx1_execute+0xfc>)
 800c58a:	9100      	str	r1, [sp, #0]
 800c58c:	4610      	mov	r0, r2
 800c58e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c592:	461a      	mov	r2, r3
 800c594:	4b36      	ldr	r3, [pc, #216]	; (800c670 <mtx1_execute+0x100>)
 800c596:	f7f4 fe23 	bl	80011e0 <chThdCreateStatic>
 800c59a:	4602      	mov	r2, r0
 800c59c:	4b35      	ldr	r3, [pc, #212]	; (800c674 <mtx1_execute+0x104>)
 800c59e:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 800c5a0:	4b31      	ldr	r3, [pc, #196]	; (800c668 <mtx1_execute+0xf8>)
 800c5a2:	685a      	ldr	r2, [r3, #4]
 800c5a4:	9b03      	ldr	r3, [sp, #12]
 800c5a6:	3302      	adds	r3, #2
 800c5a8:	4933      	ldr	r1, [pc, #204]	; (800c678 <mtx1_execute+0x108>)
 800c5aa:	9100      	str	r1, [sp, #0]
 800c5ac:	4610      	mov	r0, r2
 800c5ae:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c5b2:	461a      	mov	r2, r3
 800c5b4:	4b2e      	ldr	r3, [pc, #184]	; (800c670 <mtx1_execute+0x100>)
 800c5b6:	f7f4 fe13 	bl	80011e0 <chThdCreateStatic>
 800c5ba:	4602      	mov	r2, r0
 800c5bc:	4b2d      	ldr	r3, [pc, #180]	; (800c674 <mtx1_execute+0x104>)
 800c5be:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 800c5c0:	4b29      	ldr	r3, [pc, #164]	; (800c668 <mtx1_execute+0xf8>)
 800c5c2:	689a      	ldr	r2, [r3, #8]
 800c5c4:	9b03      	ldr	r3, [sp, #12]
 800c5c6:	3303      	adds	r3, #3
 800c5c8:	492c      	ldr	r1, [pc, #176]	; (800c67c <mtx1_execute+0x10c>)
 800c5ca:	9100      	str	r1, [sp, #0]
 800c5cc:	4610      	mov	r0, r2
 800c5ce:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c5d2:	461a      	mov	r2, r3
 800c5d4:	4b26      	ldr	r3, [pc, #152]	; (800c670 <mtx1_execute+0x100>)
 800c5d6:	f7f4 fe03 	bl	80011e0 <chThdCreateStatic>
 800c5da:	4602      	mov	r2, r0
 800c5dc:	4b25      	ldr	r3, [pc, #148]	; (800c674 <mtx1_execute+0x104>)
 800c5de:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 800c5e0:	4b21      	ldr	r3, [pc, #132]	; (800c668 <mtx1_execute+0xf8>)
 800c5e2:	68da      	ldr	r2, [r3, #12]
 800c5e4:	9b03      	ldr	r3, [sp, #12]
 800c5e6:	3304      	adds	r3, #4
 800c5e8:	4925      	ldr	r1, [pc, #148]	; (800c680 <mtx1_execute+0x110>)
 800c5ea:	9100      	str	r1, [sp, #0]
 800c5ec:	4610      	mov	r0, r2
 800c5ee:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c5f2:	461a      	mov	r2, r3
 800c5f4:	4b1e      	ldr	r3, [pc, #120]	; (800c670 <mtx1_execute+0x100>)
 800c5f6:	f7f4 fdf3 	bl	80011e0 <chThdCreateStatic>
 800c5fa:	4602      	mov	r2, r0
 800c5fc:	4b1d      	ldr	r3, [pc, #116]	; (800c674 <mtx1_execute+0x104>)
 800c5fe:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 800c600:	4b19      	ldr	r3, [pc, #100]	; (800c668 <mtx1_execute+0xf8>)
 800c602:	691a      	ldr	r2, [r3, #16]
 800c604:	9b03      	ldr	r3, [sp, #12]
 800c606:	3305      	adds	r3, #5
 800c608:	491e      	ldr	r1, [pc, #120]	; (800c684 <mtx1_execute+0x114>)
 800c60a:	9100      	str	r1, [sp, #0]
 800c60c:	4610      	mov	r0, r2
 800c60e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c612:	461a      	mov	r2, r3
 800c614:	4b16      	ldr	r3, [pc, #88]	; (800c670 <mtx1_execute+0x100>)
 800c616:	f7f4 fde3 	bl	80011e0 <chThdCreateStatic>
 800c61a:	4602      	mov	r2, r0
 800c61c:	4b15      	ldr	r3, [pc, #84]	; (800c674 <mtx1_execute+0x104>)
 800c61e:	611a      	str	r2, [r3, #16]
  chMtxUnlock(&m1);
 800c620:	4810      	ldr	r0, [pc, #64]	; (800c664 <mtx1_execute+0xf4>)
 800c622:	f7f5 fd1d 	bl	8002060 <chMtxUnlock>
  test_wait_threads();
 800c626:	f7fe fec3 	bl	800b3b0 <test_wait_threads>
  test_assert(1, prio == chThdGetPriorityX(), "wrong priority level");
 800c62a:	f7ff ff79 	bl	800c520 <chThdGetPriorityX>
 800c62e:	4602      	mov	r2, r0
 800c630:	9b03      	ldr	r3, [sp, #12]
 800c632:	429a      	cmp	r2, r3
 800c634:	bf14      	ite	ne
 800c636:	2300      	movne	r3, #0
 800c638:	2301      	moveq	r3, #1
 800c63a:	b2db      	uxtb	r3, r3
 800c63c:	2001      	movs	r0, #1
 800c63e:	4619      	mov	r1, r3
 800c640:	f7fe fe36 	bl	800b2b0 <_test_assert>
 800c644:	4603      	mov	r3, r0
 800c646:	2b00      	cmp	r3, #0
 800c648:	d000      	beq.n	800c64c <mtx1_execute+0xdc>
 800c64a:	e007      	b.n	800c65c <mtx1_execute+0xec>
  test_assert_sequence(2, "ABCDE");
 800c64c:	2002      	movs	r0, #2
 800c64e:	490e      	ldr	r1, [pc, #56]	; (800c688 <mtx1_execute+0x118>)
 800c650:	f7fe fe46 	bl	800b2e0 <_test_assert_sequence>
 800c654:	4603      	mov	r3, r0
 800c656:	2b00      	cmp	r3, #0
 800c658:	d000      	beq.n	800c65c <mtx1_execute+0xec>
 800c65a:	bf00      	nop
}
 800c65c:	b005      	add	sp, #20
 800c65e:	f85d fb04 	ldr.w	pc, [sp], #4
 800c662:	bf00      	nop
 800c664:	20000844 	.word	0x20000844
 800c668:	08016240 	.word	0x08016240
 800c66c:	08016610 	.word	0x08016610
 800c670:	0800c541 	.word	0x0800c541
 800c674:	20001224 	.word	0x20001224
 800c678:	08016614 	.word	0x08016614
 800c67c:	08016618 	.word	0x08016618
 800c680:	0801661c 	.word	0x0801661c
 800c684:	08016620 	.word	0x08016620
 800c688:	08016624 	.word	0x08016624
 800c68c:	f3af 8000 	nop.w

0800c690 <mtx4_setup>:
 * thread with precise timing.<br>
 * The test expects that the priority changes caused by the priority
 * inheritance algorithm happen at the right moment and with the right values.
 */

static void mtx4_setup(void) {
 800c690:	b508      	push	{r3, lr}

  chMtxObjectInit(&m1);
 800c692:	4803      	ldr	r0, [pc, #12]	; (800c6a0 <mtx4_setup+0x10>)
 800c694:	f7f5 fc2c 	bl	8001ef0 <chMtxObjectInit>
  chMtxObjectInit(&m2);
 800c698:	4802      	ldr	r0, [pc, #8]	; (800c6a4 <mtx4_setup+0x14>)
 800c69a:	f7f5 fc29 	bl	8001ef0 <chMtxObjectInit>
}
 800c69e:	bd08      	pop	{r3, pc}
 800c6a0:	20000844 	.word	0x20000844
 800c6a4:	20000854 	.word	0x20000854
 800c6a8:	f3af 8000 	nop.w
 800c6ac:	f3af 8000 	nop.w

0800c6b0 <thread4a>:

static THD_FUNCTION(thread4a, p) {
 800c6b0:	b500      	push	{lr}
 800c6b2:	b083      	sub	sp, #12
 800c6b4:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(50);
 800c6b6:	2032      	movs	r0, #50	; 0x32
 800c6b8:	f7f4 fe0a 	bl	80012d0 <chThdSleep>
  chMtxLock(&m2);
 800c6bc:	4804      	ldr	r0, [pc, #16]	; (800c6d0 <thread4a+0x20>)
 800c6be:	f7f5 fc27 	bl	8001f10 <chMtxLock>
  chMtxUnlock(&m2);
 800c6c2:	4803      	ldr	r0, [pc, #12]	; (800c6d0 <thread4a+0x20>)
 800c6c4:	f7f5 fccc 	bl	8002060 <chMtxUnlock>
}
 800c6c8:	b003      	add	sp, #12
 800c6ca:	f85d fb04 	ldr.w	pc, [sp], #4
 800c6ce:	bf00      	nop
 800c6d0:	20000854 	.word	0x20000854
 800c6d4:	f3af 8000 	nop.w
 800c6d8:	f3af 8000 	nop.w
 800c6dc:	f3af 8000 	nop.w

0800c6e0 <thread4b>:

static THD_FUNCTION(thread4b, p) {
 800c6e0:	b500      	push	{lr}
 800c6e2:	b083      	sub	sp, #12
 800c6e4:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(150);
 800c6e6:	2096      	movs	r0, #150	; 0x96
 800c6e8:	f7f4 fdf2 	bl	80012d0 <chThdSleep>
  chMtxLock(&m1);
 800c6ec:	4804      	ldr	r0, [pc, #16]	; (800c700 <thread4b+0x20>)
 800c6ee:	f7f5 fc0f 	bl	8001f10 <chMtxLock>
  chMtxUnlock(&m1);
 800c6f2:	4803      	ldr	r0, [pc, #12]	; (800c700 <thread4b+0x20>)
 800c6f4:	f7f5 fcb4 	bl	8002060 <chMtxUnlock>
}
 800c6f8:	b003      	add	sp, #12
 800c6fa:	f85d fb04 	ldr.w	pc, [sp], #4
 800c6fe:	bf00      	nop
 800c700:	20000844 	.word	0x20000844
 800c704:	f3af 8000 	nop.w
 800c708:	f3af 8000 	nop.w
 800c70c:	f3af 8000 	nop.w

0800c710 <mtx4_execute>:

static void mtx4_execute(void) {
 800c710:	b500      	push	{lr}
 800c712:	b087      	sub	sp, #28
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
 800c714:	f7ff ff04 	bl	800c520 <chThdGetPriorityX>
 800c718:	9005      	str	r0, [sp, #20]
  p1 = p + 1;
 800c71a:	9b05      	ldr	r3, [sp, #20]
 800c71c:	3301      	adds	r3, #1
 800c71e:	9304      	str	r3, [sp, #16]
  p2 = p + 2;
 800c720:	9b05      	ldr	r3, [sp, #20]
 800c722:	3302      	adds	r3, #2
 800c724:	9303      	str	r3, [sp, #12]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 800c726:	4ba1      	ldr	r3, [pc, #644]	; (800c9ac <mtx4_execute+0x29c>)
 800c728:	681b      	ldr	r3, [r3, #0]
 800c72a:	4aa1      	ldr	r2, [pc, #644]	; (800c9b0 <mtx4_execute+0x2a0>)
 800c72c:	9200      	str	r2, [sp, #0]
 800c72e:	4618      	mov	r0, r3
 800c730:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c734:	9a04      	ldr	r2, [sp, #16]
 800c736:	4b9f      	ldr	r3, [pc, #636]	; (800c9b4 <mtx4_execute+0x2a4>)
 800c738:	f7f4 fd52 	bl	80011e0 <chThdCreateStatic>
 800c73c:	4602      	mov	r2, r0
 800c73e:	4b9e      	ldr	r3, [pc, #632]	; (800c9b8 <mtx4_execute+0x2a8>)
 800c740:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
 800c742:	4b9a      	ldr	r3, [pc, #616]	; (800c9ac <mtx4_execute+0x29c>)
 800c744:	685b      	ldr	r3, [r3, #4]
 800c746:	4a9d      	ldr	r2, [pc, #628]	; (800c9bc <mtx4_execute+0x2ac>)
 800c748:	9200      	str	r2, [sp, #0]
 800c74a:	4618      	mov	r0, r3
 800c74c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c750:	9a03      	ldr	r2, [sp, #12]
 800c752:	4b9b      	ldr	r3, [pc, #620]	; (800c9c0 <mtx4_execute+0x2b0>)
 800c754:	f7f4 fd44 	bl	80011e0 <chThdCreateStatic>
 800c758:	4602      	mov	r2, r0
 800c75a:	4b97      	ldr	r3, [pc, #604]	; (800c9b8 <mtx4_execute+0x2a8>)
 800c75c:	605a      	str	r2, [r3, #4]
  chMtxLock(&m2);
 800c75e:	4899      	ldr	r0, [pc, #612]	; (800c9c4 <mtx4_execute+0x2b4>)
 800c760:	f7f5 fbd6 	bl	8001f10 <chMtxLock>
  test_assert(1, chThdGetPriorityX() == p, "wrong priority level");
 800c764:	f7ff fedc 	bl	800c520 <chThdGetPriorityX>
 800c768:	4602      	mov	r2, r0
 800c76a:	9b05      	ldr	r3, [sp, #20]
 800c76c:	429a      	cmp	r2, r3
 800c76e:	bf14      	ite	ne
 800c770:	2300      	movne	r3, #0
 800c772:	2301      	moveq	r3, #1
 800c774:	b2db      	uxtb	r3, r3
 800c776:	2001      	movs	r0, #1
 800c778:	4619      	mov	r1, r3
 800c77a:	f7fe fd99 	bl	800b2b0 <_test_assert>
 800c77e:	4603      	mov	r3, r0
 800c780:	2b00      	cmp	r3, #0
 800c782:	d000      	beq.n	800c786 <mtx4_execute+0x76>
 800c784:	e13b      	b.n	800c9fe <mtx4_execute+0x2ee>
  chThdSleepMilliseconds(100);
 800c786:	2064      	movs	r0, #100	; 0x64
 800c788:	f7f4 fda2 	bl	80012d0 <chThdSleep>
  test_assert(2, chThdGetPriorityX() == p1, "wrong priority level");
 800c78c:	f7ff fec8 	bl	800c520 <chThdGetPriorityX>
 800c790:	4602      	mov	r2, r0
 800c792:	9b04      	ldr	r3, [sp, #16]
 800c794:	429a      	cmp	r2, r3
 800c796:	bf14      	ite	ne
 800c798:	2300      	movne	r3, #0
 800c79a:	2301      	moveq	r3, #1
 800c79c:	b2db      	uxtb	r3, r3
 800c79e:	2002      	movs	r0, #2
 800c7a0:	4619      	mov	r1, r3
 800c7a2:	f7fe fd85 	bl	800b2b0 <_test_assert>
 800c7a6:	4603      	mov	r3, r0
 800c7a8:	2b00      	cmp	r3, #0
 800c7aa:	d000      	beq.n	800c7ae <mtx4_execute+0x9e>
 800c7ac:	e127      	b.n	800c9fe <mtx4_execute+0x2ee>
  chMtxLock(&m1);
 800c7ae:	4886      	ldr	r0, [pc, #536]	; (800c9c8 <mtx4_execute+0x2b8>)
 800c7b0:	f7f5 fbae 	bl	8001f10 <chMtxLock>
  test_assert(3, chThdGetPriorityX() == p1, "wrong priority level");
 800c7b4:	f7ff feb4 	bl	800c520 <chThdGetPriorityX>
 800c7b8:	4602      	mov	r2, r0
 800c7ba:	9b04      	ldr	r3, [sp, #16]
 800c7bc:	429a      	cmp	r2, r3
 800c7be:	bf14      	ite	ne
 800c7c0:	2300      	movne	r3, #0
 800c7c2:	2301      	moveq	r3, #1
 800c7c4:	b2db      	uxtb	r3, r3
 800c7c6:	2003      	movs	r0, #3
 800c7c8:	4619      	mov	r1, r3
 800c7ca:	f7fe fd71 	bl	800b2b0 <_test_assert>
 800c7ce:	4603      	mov	r3, r0
 800c7d0:	2b00      	cmp	r3, #0
 800c7d2:	d000      	beq.n	800c7d6 <mtx4_execute+0xc6>
 800c7d4:	e113      	b.n	800c9fe <mtx4_execute+0x2ee>
  chThdSleepMilliseconds(100);
 800c7d6:	2064      	movs	r0, #100	; 0x64
 800c7d8:	f7f4 fd7a 	bl	80012d0 <chThdSleep>
  test_assert(4, chThdGetPriorityX() == p2, "wrong priority level");
 800c7dc:	f7ff fea0 	bl	800c520 <chThdGetPriorityX>
 800c7e0:	4602      	mov	r2, r0
 800c7e2:	9b03      	ldr	r3, [sp, #12]
 800c7e4:	429a      	cmp	r2, r3
 800c7e6:	bf14      	ite	ne
 800c7e8:	2300      	movne	r3, #0
 800c7ea:	2301      	moveq	r3, #1
 800c7ec:	b2db      	uxtb	r3, r3
 800c7ee:	2004      	movs	r0, #4
 800c7f0:	4619      	mov	r1, r3
 800c7f2:	f7fe fd5d 	bl	800b2b0 <_test_assert>
 800c7f6:	4603      	mov	r3, r0
 800c7f8:	2b00      	cmp	r3, #0
 800c7fa:	d000      	beq.n	800c7fe <mtx4_execute+0xee>
 800c7fc:	e0ff      	b.n	800c9fe <mtx4_execute+0x2ee>
  chMtxUnlock(&m1);
 800c7fe:	4872      	ldr	r0, [pc, #456]	; (800c9c8 <mtx4_execute+0x2b8>)
 800c800:	f7f5 fc2e 	bl	8002060 <chMtxUnlock>
  test_assert(5, chThdGetPriorityX() == p1, "wrong priority level");
 800c804:	f7ff fe8c 	bl	800c520 <chThdGetPriorityX>
 800c808:	4602      	mov	r2, r0
 800c80a:	9b04      	ldr	r3, [sp, #16]
 800c80c:	429a      	cmp	r2, r3
 800c80e:	bf14      	ite	ne
 800c810:	2300      	movne	r3, #0
 800c812:	2301      	moveq	r3, #1
 800c814:	b2db      	uxtb	r3, r3
 800c816:	2005      	movs	r0, #5
 800c818:	4619      	mov	r1, r3
 800c81a:	f7fe fd49 	bl	800b2b0 <_test_assert>
 800c81e:	4603      	mov	r3, r0
 800c820:	2b00      	cmp	r3, #0
 800c822:	d000      	beq.n	800c826 <mtx4_execute+0x116>
 800c824:	e0eb      	b.n	800c9fe <mtx4_execute+0x2ee>
  chThdSleepMilliseconds(100);
 800c826:	2064      	movs	r0, #100	; 0x64
 800c828:	f7f4 fd52 	bl	80012d0 <chThdSleep>
  test_assert(6, chThdGetPriorityX() == p1, "wrong priority level");
 800c82c:	f7ff fe78 	bl	800c520 <chThdGetPriorityX>
 800c830:	4602      	mov	r2, r0
 800c832:	9b04      	ldr	r3, [sp, #16]
 800c834:	429a      	cmp	r2, r3
 800c836:	bf14      	ite	ne
 800c838:	2300      	movne	r3, #0
 800c83a:	2301      	moveq	r3, #1
 800c83c:	b2db      	uxtb	r3, r3
 800c83e:	2006      	movs	r0, #6
 800c840:	4619      	mov	r1, r3
 800c842:	f7fe fd35 	bl	800b2b0 <_test_assert>
 800c846:	4603      	mov	r3, r0
 800c848:	2b00      	cmp	r3, #0
 800c84a:	d000      	beq.n	800c84e <mtx4_execute+0x13e>
 800c84c:	e0d7      	b.n	800c9fe <mtx4_execute+0x2ee>
  chMtxUnlockAll();
 800c84e:	f7f5 fcaf 	bl	80021b0 <chMtxUnlockAll>
  test_assert(7, chThdGetPriorityX() == p, "wrong priority level");
 800c852:	f7ff fe65 	bl	800c520 <chThdGetPriorityX>
 800c856:	4602      	mov	r2, r0
 800c858:	9b05      	ldr	r3, [sp, #20]
 800c85a:	429a      	cmp	r2, r3
 800c85c:	bf14      	ite	ne
 800c85e:	2300      	movne	r3, #0
 800c860:	2301      	moveq	r3, #1
 800c862:	b2db      	uxtb	r3, r3
 800c864:	2007      	movs	r0, #7
 800c866:	4619      	mov	r1, r3
 800c868:	f7fe fd22 	bl	800b2b0 <_test_assert>
 800c86c:	4603      	mov	r3, r0
 800c86e:	2b00      	cmp	r3, #0
 800c870:	d000      	beq.n	800c874 <mtx4_execute+0x164>
 800c872:	e0c4      	b.n	800c9fe <mtx4_execute+0x2ee>
  test_wait_threads();
 800c874:	f7fe fd9c 	bl	800b3b0 <test_wait_threads>

  /* Test repeated in order to cover chMtxUnlockS().*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "D");
 800c878:	4b4c      	ldr	r3, [pc, #304]	; (800c9ac <mtx4_execute+0x29c>)
 800c87a:	681b      	ldr	r3, [r3, #0]
 800c87c:	4a53      	ldr	r2, [pc, #332]	; (800c9cc <mtx4_execute+0x2bc>)
 800c87e:	9200      	str	r2, [sp, #0]
 800c880:	4618      	mov	r0, r3
 800c882:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c886:	9a04      	ldr	r2, [sp, #16]
 800c888:	4b4a      	ldr	r3, [pc, #296]	; (800c9b4 <mtx4_execute+0x2a4>)
 800c88a:	f7f4 fca9 	bl	80011e0 <chThdCreateStatic>
 800c88e:	4602      	mov	r2, r0
 800c890:	4b49      	ldr	r3, [pc, #292]	; (800c9b8 <mtx4_execute+0x2a8>)
 800c892:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "C");
 800c894:	4b45      	ldr	r3, [pc, #276]	; (800c9ac <mtx4_execute+0x29c>)
 800c896:	685b      	ldr	r3, [r3, #4]
 800c898:	4a4d      	ldr	r2, [pc, #308]	; (800c9d0 <mtx4_execute+0x2c0>)
 800c89a:	9200      	str	r2, [sp, #0]
 800c89c:	4618      	mov	r0, r3
 800c89e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c8a2:	9a03      	ldr	r2, [sp, #12]
 800c8a4:	4b46      	ldr	r3, [pc, #280]	; (800c9c0 <mtx4_execute+0x2b0>)
 800c8a6:	f7f4 fc9b 	bl	80011e0 <chThdCreateStatic>
 800c8aa:	4602      	mov	r2, r0
 800c8ac:	4b42      	ldr	r3, [pc, #264]	; (800c9b8 <mtx4_execute+0x2a8>)
 800c8ae:	605a      	str	r2, [r3, #4]
  chMtxLock(&m2);
 800c8b0:	4844      	ldr	r0, [pc, #272]	; (800c9c4 <mtx4_execute+0x2b4>)
 800c8b2:	f7f5 fb2d 	bl	8001f10 <chMtxLock>
  test_assert(8, chThdGetPriorityX() == p, "wrong priority level");
 800c8b6:	f7ff fe33 	bl	800c520 <chThdGetPriorityX>
 800c8ba:	4602      	mov	r2, r0
 800c8bc:	9b05      	ldr	r3, [sp, #20]
 800c8be:	429a      	cmp	r2, r3
 800c8c0:	bf14      	ite	ne
 800c8c2:	2300      	movne	r3, #0
 800c8c4:	2301      	moveq	r3, #1
 800c8c6:	b2db      	uxtb	r3, r3
 800c8c8:	2008      	movs	r0, #8
 800c8ca:	4619      	mov	r1, r3
 800c8cc:	f7fe fcf0 	bl	800b2b0 <_test_assert>
 800c8d0:	4603      	mov	r3, r0
 800c8d2:	2b00      	cmp	r3, #0
 800c8d4:	d000      	beq.n	800c8d8 <mtx4_execute+0x1c8>
 800c8d6:	e092      	b.n	800c9fe <mtx4_execute+0x2ee>
  chThdSleepMilliseconds(100);
 800c8d8:	2064      	movs	r0, #100	; 0x64
 800c8da:	f7f4 fcf9 	bl	80012d0 <chThdSleep>
  test_assert(9, chThdGetPriorityX() == p1, "wrong priority level");
 800c8de:	f7ff fe1f 	bl	800c520 <chThdGetPriorityX>
 800c8e2:	4602      	mov	r2, r0
 800c8e4:	9b04      	ldr	r3, [sp, #16]
 800c8e6:	429a      	cmp	r2, r3
 800c8e8:	bf14      	ite	ne
 800c8ea:	2300      	movne	r3, #0
 800c8ec:	2301      	moveq	r3, #1
 800c8ee:	b2db      	uxtb	r3, r3
 800c8f0:	2009      	movs	r0, #9
 800c8f2:	4619      	mov	r1, r3
 800c8f4:	f7fe fcdc 	bl	800b2b0 <_test_assert>
 800c8f8:	4603      	mov	r3, r0
 800c8fa:	2b00      	cmp	r3, #0
 800c8fc:	d000      	beq.n	800c900 <mtx4_execute+0x1f0>
 800c8fe:	e07e      	b.n	800c9fe <mtx4_execute+0x2ee>
  chMtxLock(&m1);
 800c900:	4831      	ldr	r0, [pc, #196]	; (800c9c8 <mtx4_execute+0x2b8>)
 800c902:	f7f5 fb05 	bl	8001f10 <chMtxLock>
  test_assert(10, chThdGetPriorityX() == p1, "wrong priority level");
 800c906:	f7ff fe0b 	bl	800c520 <chThdGetPriorityX>
 800c90a:	4602      	mov	r2, r0
 800c90c:	9b04      	ldr	r3, [sp, #16]
 800c90e:	429a      	cmp	r2, r3
 800c910:	bf14      	ite	ne
 800c912:	2300      	movne	r3, #0
 800c914:	2301      	moveq	r3, #1
 800c916:	b2db      	uxtb	r3, r3
 800c918:	200a      	movs	r0, #10
 800c91a:	4619      	mov	r1, r3
 800c91c:	f7fe fcc8 	bl	800b2b0 <_test_assert>
 800c920:	4603      	mov	r3, r0
 800c922:	2b00      	cmp	r3, #0
 800c924:	d000      	beq.n	800c928 <mtx4_execute+0x218>
 800c926:	e06a      	b.n	800c9fe <mtx4_execute+0x2ee>
  chThdSleepMilliseconds(100);
 800c928:	2064      	movs	r0, #100	; 0x64
 800c92a:	f7f4 fcd1 	bl	80012d0 <chThdSleep>
  test_assert(11, chThdGetPriorityX() == p2, "wrong priority level");
 800c92e:	f7ff fdf7 	bl	800c520 <chThdGetPriorityX>
 800c932:	4602      	mov	r2, r0
 800c934:	9b03      	ldr	r3, [sp, #12]
 800c936:	429a      	cmp	r2, r3
 800c938:	bf14      	ite	ne
 800c93a:	2300      	movne	r3, #0
 800c93c:	2301      	moveq	r3, #1
 800c93e:	b2db      	uxtb	r3, r3
 800c940:	200b      	movs	r0, #11
 800c942:	4619      	mov	r1, r3
 800c944:	f7fe fcb4 	bl	800b2b0 <_test_assert>
 800c948:	4603      	mov	r3, r0
 800c94a:	2b00      	cmp	r3, #0
 800c94c:	d000      	beq.n	800c950 <mtx4_execute+0x240>
 800c94e:	e056      	b.n	800c9fe <mtx4_execute+0x2ee>
  chSysLock();
 800c950:	f7ff fdce 	bl	800c4f0 <chSysLock>
  chMtxUnlockS(&m1);
 800c954:	481c      	ldr	r0, [pc, #112]	; (800c9c8 <mtx4_execute+0x2b8>)
 800c956:	f7f5 fbdb 	bl	8002110 <chMtxUnlockS>
  chSchRescheduleS();
 800c95a:	f7f4 fa11 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 800c95e:	f7ff fdcf 	bl	800c500 <chSysUnlock>
  test_assert(12, chThdGetPriorityX() == p1, "wrong priority level");
 800c962:	f7ff fddd 	bl	800c520 <chThdGetPriorityX>
 800c966:	4602      	mov	r2, r0
 800c968:	9b04      	ldr	r3, [sp, #16]
 800c96a:	429a      	cmp	r2, r3
 800c96c:	bf14      	ite	ne
 800c96e:	2300      	movne	r3, #0
 800c970:	2301      	moveq	r3, #1
 800c972:	b2db      	uxtb	r3, r3
 800c974:	200c      	movs	r0, #12
 800c976:	4619      	mov	r1, r3
 800c978:	f7fe fc9a 	bl	800b2b0 <_test_assert>
 800c97c:	4603      	mov	r3, r0
 800c97e:	2b00      	cmp	r3, #0
 800c980:	d000      	beq.n	800c984 <mtx4_execute+0x274>
 800c982:	e03c      	b.n	800c9fe <mtx4_execute+0x2ee>
  chThdSleepMilliseconds(100);
 800c984:	2064      	movs	r0, #100	; 0x64
 800c986:	f7f4 fca3 	bl	80012d0 <chThdSleep>
  test_assert(13, chThdGetPriorityX() == p1, "wrong priority level");
 800c98a:	f7ff fdc9 	bl	800c520 <chThdGetPriorityX>
 800c98e:	4602      	mov	r2, r0
 800c990:	9b04      	ldr	r3, [sp, #16]
 800c992:	429a      	cmp	r2, r3
 800c994:	bf14      	ite	ne
 800c996:	2300      	movne	r3, #0
 800c998:	2301      	moveq	r3, #1
 800c99a:	b2db      	uxtb	r3, r3
 800c99c:	200d      	movs	r0, #13
 800c99e:	4619      	mov	r1, r3
 800c9a0:	f7fe fc86 	bl	800b2b0 <_test_assert>
 800c9a4:	4603      	mov	r3, r0
 800c9a6:	2b00      	cmp	r3, #0
 800c9a8:	d014      	beq.n	800c9d4 <mtx4_execute+0x2c4>
 800c9aa:	e028      	b.n	800c9fe <mtx4_execute+0x2ee>
 800c9ac:	08016240 	.word	0x08016240
 800c9b0:	0801661c 	.word	0x0801661c
 800c9b4:	0800c6b1 	.word	0x0800c6b1
 800c9b8:	20001224 	.word	0x20001224
 800c9bc:	08016620 	.word	0x08016620
 800c9c0:	0800c6e1 	.word	0x0800c6e1
 800c9c4:	20000854 	.word	0x20000854
 800c9c8:	20000844 	.word	0x20000844
 800c9cc:	08016614 	.word	0x08016614
 800c9d0:	08016618 	.word	0x08016618
  chMtxUnlockAll();
 800c9d4:	f7f5 fbec 	bl	80021b0 <chMtxUnlockAll>
  test_assert(14, chThdGetPriorityX() == p, "wrong priority level");
 800c9d8:	f7ff fda2 	bl	800c520 <chThdGetPriorityX>
 800c9dc:	4602      	mov	r2, r0
 800c9de:	9b05      	ldr	r3, [sp, #20]
 800c9e0:	429a      	cmp	r2, r3
 800c9e2:	bf14      	ite	ne
 800c9e4:	2300      	movne	r3, #0
 800c9e6:	2301      	moveq	r3, #1
 800c9e8:	b2db      	uxtb	r3, r3
 800c9ea:	200e      	movs	r0, #14
 800c9ec:	4619      	mov	r1, r3
 800c9ee:	f7fe fc5f 	bl	800b2b0 <_test_assert>
 800c9f2:	4603      	mov	r3, r0
 800c9f4:	2b00      	cmp	r3, #0
 800c9f6:	d000      	beq.n	800c9fa <mtx4_execute+0x2ea>
 800c9f8:	e001      	b.n	800c9fe <mtx4_execute+0x2ee>
  test_wait_threads();
 800c9fa:	f7fe fcd9 	bl	800b3b0 <test_wait_threads>
}
 800c9fe:	b007      	add	sp, #28
 800ca00:	f85d fb04 	ldr.w	pc, [sp], #4
 800ca04:	f3af 8000 	nop.w
 800ca08:	f3af 8000 	nop.w
 800ca0c:	f3af 8000 	nop.w

0800ca10 <mtx5_setup>:
 * unlock operations.<br>
 * The test expects that the internal mutex status is consistent after each
 * operation.
 */

static void mtx5_setup(void) {
 800ca10:	b508      	push	{r3, lr}

  chMtxObjectInit(&m1);
 800ca12:	4802      	ldr	r0, [pc, #8]	; (800ca1c <mtx5_setup+0xc>)
 800ca14:	f7f5 fa6c 	bl	8001ef0 <chMtxObjectInit>
}
 800ca18:	bd08      	pop	{r3, pc}
 800ca1a:	bf00      	nop
 800ca1c:	20000844 	.word	0x20000844

0800ca20 <mtx5_execute>:

static void mtx5_execute(void) {
 800ca20:	b500      	push	{lr}
 800ca22:	b083      	sub	sp, #12

#if !CH_CFG_USE_MUTEXES_RECURSIVE
  bool b;
  tprio_t prio = chThdGetPriorityX();
 800ca24:	f7ff fd7c 	bl	800c520 <chThdGetPriorityX>
 800ca28:	9001      	str	r0, [sp, #4]

  b = chMtxTryLock(&m1);
 800ca2a:	4840      	ldr	r0, [pc, #256]	; (800cb2c <mtx5_execute+0x10c>)
 800ca2c:	f7f5 fae0 	bl	8001ff0 <chMtxTryLock>
 800ca30:	4603      	mov	r3, r0
 800ca32:	f88d 3003 	strb.w	r3, [sp, #3]
  test_assert(1, b, "already locked");
 800ca36:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800ca3a:	2001      	movs	r0, #1
 800ca3c:	4619      	mov	r1, r3
 800ca3e:	f7fe fc37 	bl	800b2b0 <_test_assert>
 800ca42:	4603      	mov	r3, r0
 800ca44:	2b00      	cmp	r3, #0
 800ca46:	d000      	beq.n	800ca4a <mtx5_execute+0x2a>
 800ca48:	e06d      	b.n	800cb26 <mtx5_execute+0x106>

  b = chMtxTryLock(&m1);
 800ca4a:	4838      	ldr	r0, [pc, #224]	; (800cb2c <mtx5_execute+0x10c>)
 800ca4c:	f7f5 fad0 	bl	8001ff0 <chMtxTryLock>
 800ca50:	4603      	mov	r3, r0
 800ca52:	f88d 3003 	strb.w	r3, [sp, #3]
  test_assert(2, !b, "not locked");
 800ca56:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800ca5a:	2b00      	cmp	r3, #0
 800ca5c:	bf0c      	ite	eq
 800ca5e:	2300      	moveq	r3, #0
 800ca60:	2301      	movne	r3, #1
 800ca62:	b2db      	uxtb	r3, r3
 800ca64:	f083 0301 	eor.w	r3, r3, #1
 800ca68:	b2db      	uxtb	r3, r3
 800ca6a:	f003 0301 	and.w	r3, r3, #1
 800ca6e:	b2db      	uxtb	r3, r3
 800ca70:	2002      	movs	r0, #2
 800ca72:	4619      	mov	r1, r3
 800ca74:	f7fe fc1c 	bl	800b2b0 <_test_assert>
 800ca78:	4603      	mov	r3, r0
 800ca7a:	2b00      	cmp	r3, #0
 800ca7c:	d000      	beq.n	800ca80 <mtx5_execute+0x60>
 800ca7e:	e052      	b.n	800cb26 <mtx5_execute+0x106>

  chSysLock();
 800ca80:	f7ff fd36 	bl	800c4f0 <chSysLock>
  chMtxUnlockS(&m1);
 800ca84:	4829      	ldr	r0, [pc, #164]	; (800cb2c <mtx5_execute+0x10c>)
 800ca86:	f7f5 fb43 	bl	8002110 <chMtxUnlockS>
  chSysUnlock();
 800ca8a:	f7ff fd39 	bl	800c500 <chSysUnlock>

  test_assert(3, queue_isempty(&m1.m_queue), "queue not empty");
 800ca8e:	4827      	ldr	r0, [pc, #156]	; (800cb2c <mtx5_execute+0x10c>)
 800ca90:	f7ff fd1e 	bl	800c4d0 <queue_isempty>
 800ca94:	4603      	mov	r3, r0
 800ca96:	2003      	movs	r0, #3
 800ca98:	4619      	mov	r1, r3
 800ca9a:	f7fe fc09 	bl	800b2b0 <_test_assert>
 800ca9e:	4603      	mov	r3, r0
 800caa0:	2b00      	cmp	r3, #0
 800caa2:	d000      	beq.n	800caa6 <mtx5_execute+0x86>
 800caa4:	e03f      	b.n	800cb26 <mtx5_execute+0x106>
  test_assert(4, m1.m_owner == NULL, "still owned");
 800caa6:	4b21      	ldr	r3, [pc, #132]	; (800cb2c <mtx5_execute+0x10c>)
 800caa8:	689b      	ldr	r3, [r3, #8]
 800caaa:	2b00      	cmp	r3, #0
 800caac:	bf14      	ite	ne
 800caae:	2300      	movne	r3, #0
 800cab0:	2301      	moveq	r3, #1
 800cab2:	b2db      	uxtb	r3, r3
 800cab4:	2004      	movs	r0, #4
 800cab6:	4619      	mov	r1, r3
 800cab8:	f7fe fbfa 	bl	800b2b0 <_test_assert>
 800cabc:	4603      	mov	r3, r0
 800cabe:	2b00      	cmp	r3, #0
 800cac0:	d000      	beq.n	800cac4 <mtx5_execute+0xa4>
 800cac2:	e030      	b.n	800cb26 <mtx5_execute+0x106>
  test_assert(5, chThdGetPriorityX() == prio, "wrong priority level");
 800cac4:	f7ff fd2c 	bl	800c520 <chThdGetPriorityX>
 800cac8:	4602      	mov	r2, r0
 800caca:	9b01      	ldr	r3, [sp, #4]
 800cacc:	429a      	cmp	r2, r3
 800cace:	bf14      	ite	ne
 800cad0:	2300      	movne	r3, #0
 800cad2:	2301      	moveq	r3, #1
 800cad4:	b2db      	uxtb	r3, r3
 800cad6:	2005      	movs	r0, #5
 800cad8:	4619      	mov	r1, r3
 800cada:	f7fe fbe9 	bl	800b2b0 <_test_assert>
 800cade:	4603      	mov	r3, r0
 800cae0:	2b00      	cmp	r3, #0
 800cae2:	d000      	beq.n	800cae6 <mtx5_execute+0xc6>
 800cae4:	e01f      	b.n	800cb26 <mtx5_execute+0x106>
#endif /* !CH_CFG_USE_MUTEXES_RECURSIVE */
  
  chMtxLock(&m1);
 800cae6:	4811      	ldr	r0, [pc, #68]	; (800cb2c <mtx5_execute+0x10c>)
 800cae8:	f7f5 fa12 	bl	8001f10 <chMtxLock>
  chMtxUnlockAll();
 800caec:	f7f5 fb60 	bl	80021b0 <chMtxUnlockAll>
  test_assert(6, queue_isempty(&m1.m_queue), "queue not empty");
 800caf0:	480e      	ldr	r0, [pc, #56]	; (800cb2c <mtx5_execute+0x10c>)
 800caf2:	f7ff fced 	bl	800c4d0 <queue_isempty>
 800caf6:	4603      	mov	r3, r0
 800caf8:	2006      	movs	r0, #6
 800cafa:	4619      	mov	r1, r3
 800cafc:	f7fe fbd8 	bl	800b2b0 <_test_assert>
 800cb00:	4603      	mov	r3, r0
 800cb02:	2b00      	cmp	r3, #0
 800cb04:	d000      	beq.n	800cb08 <mtx5_execute+0xe8>
 800cb06:	e00e      	b.n	800cb26 <mtx5_execute+0x106>
  test_assert(7, m1.m_owner == NULL, "still owned");
 800cb08:	4b08      	ldr	r3, [pc, #32]	; (800cb2c <mtx5_execute+0x10c>)
 800cb0a:	689b      	ldr	r3, [r3, #8]
 800cb0c:	2b00      	cmp	r3, #0
 800cb0e:	bf14      	ite	ne
 800cb10:	2300      	movne	r3, #0
 800cb12:	2301      	moveq	r3, #1
 800cb14:	b2db      	uxtb	r3, r3
 800cb16:	2007      	movs	r0, #7
 800cb18:	4619      	mov	r1, r3
 800cb1a:	f7fe fbc9 	bl	800b2b0 <_test_assert>
 800cb1e:	4603      	mov	r3, r0
 800cb20:	2b00      	cmp	r3, #0
 800cb22:	d000      	beq.n	800cb26 <mtx5_execute+0x106>
 800cb24:	bf00      	nop
}
 800cb26:	b003      	add	sp, #12
 800cb28:	f85d fb04 	ldr.w	pc, [sp], #4
 800cb2c:	20000844 	.word	0x20000844

0800cb30 <mtx6_setup>:
 * atomically.<br>
 * The test expects the threads to reach their goal in increasing priority
 * order regardless of the initial order.
 */

static void mtx6_setup(void) {
 800cb30:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 800cb32:	4803      	ldr	r0, [pc, #12]	; (800cb40 <mtx6_setup+0x10>)
 800cb34:	f7f5 fc0c 	bl	8002350 <chCondObjectInit>
  chMtxObjectInit(&m1);
 800cb38:	4802      	ldr	r0, [pc, #8]	; (800cb44 <mtx6_setup+0x14>)
 800cb3a:	f7f5 f9d9 	bl	8001ef0 <chMtxObjectInit>
}
 800cb3e:	bd08      	pop	{r3, pc}
 800cb40:	20000864 	.word	0x20000864
 800cb44:	20000844 	.word	0x20000844
 800cb48:	f3af 8000 	nop.w
 800cb4c:	f3af 8000 	nop.w

0800cb50 <thread10>:

static THD_FUNCTION(thread10, p) {
 800cb50:	b500      	push	{lr}
 800cb52:	b083      	sub	sp, #12
 800cb54:	9001      	str	r0, [sp, #4]

  chMtxLock(&m1);
 800cb56:	4808      	ldr	r0, [pc, #32]	; (800cb78 <thread10+0x28>)
 800cb58:	f7f5 f9da 	bl	8001f10 <chMtxLock>
  chCondWait(&c1);
 800cb5c:	4807      	ldr	r0, [pc, #28]	; (800cb7c <thread10+0x2c>)
 800cb5e:	f7f5 fc6f 	bl	8002440 <chCondWait>
  test_emit_token(*(char *)p);
 800cb62:	9b01      	ldr	r3, [sp, #4]
 800cb64:	781b      	ldrb	r3, [r3, #0]
 800cb66:	4618      	mov	r0, r3
 800cb68:	f7fe fb72 	bl	800b250 <test_emit_token>
  chMtxUnlock(&m1);
 800cb6c:	4802      	ldr	r0, [pc, #8]	; (800cb78 <thread10+0x28>)
 800cb6e:	f7f5 fa77 	bl	8002060 <chMtxUnlock>
}
 800cb72:	b003      	add	sp, #12
 800cb74:	f85d fb04 	ldr.w	pc, [sp], #4
 800cb78:	20000844 	.word	0x20000844
 800cb7c:	20000864 	.word	0x20000864

0800cb80 <mtx6_execute>:

static void mtx6_execute(void) {
 800cb80:	b500      	push	{lr}
 800cb82:	b085      	sub	sp, #20

  tprio_t prio = chThdGetPriorityX();
 800cb84:	f7ff fccc 	bl	800c520 <chThdGetPriorityX>
 800cb88:	9003      	str	r0, [sp, #12]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 800cb8a:	4b39      	ldr	r3, [pc, #228]	; (800cc70 <mtx6_execute+0xf0>)
 800cb8c:	681a      	ldr	r2, [r3, #0]
 800cb8e:	9b03      	ldr	r3, [sp, #12]
 800cb90:	3301      	adds	r3, #1
 800cb92:	4938      	ldr	r1, [pc, #224]	; (800cc74 <mtx6_execute+0xf4>)
 800cb94:	9100      	str	r1, [sp, #0]
 800cb96:	4610      	mov	r0, r2
 800cb98:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cb9c:	461a      	mov	r2, r3
 800cb9e:	4b36      	ldr	r3, [pc, #216]	; (800cc78 <mtx6_execute+0xf8>)
 800cba0:	f7f4 fb1e 	bl	80011e0 <chThdCreateStatic>
 800cba4:	4602      	mov	r2, r0
 800cba6:	4b35      	ldr	r3, [pc, #212]	; (800cc7c <mtx6_execute+0xfc>)
 800cba8:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 800cbaa:	4b31      	ldr	r3, [pc, #196]	; (800cc70 <mtx6_execute+0xf0>)
 800cbac:	685a      	ldr	r2, [r3, #4]
 800cbae:	9b03      	ldr	r3, [sp, #12]
 800cbb0:	3302      	adds	r3, #2
 800cbb2:	4933      	ldr	r1, [pc, #204]	; (800cc80 <mtx6_execute+0x100>)
 800cbb4:	9100      	str	r1, [sp, #0]
 800cbb6:	4610      	mov	r0, r2
 800cbb8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cbbc:	461a      	mov	r2, r3
 800cbbe:	4b2e      	ldr	r3, [pc, #184]	; (800cc78 <mtx6_execute+0xf8>)
 800cbc0:	f7f4 fb0e 	bl	80011e0 <chThdCreateStatic>
 800cbc4:	4602      	mov	r2, r0
 800cbc6:	4b2d      	ldr	r3, [pc, #180]	; (800cc7c <mtx6_execute+0xfc>)
 800cbc8:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 800cbca:	4b29      	ldr	r3, [pc, #164]	; (800cc70 <mtx6_execute+0xf0>)
 800cbcc:	689a      	ldr	r2, [r3, #8]
 800cbce:	9b03      	ldr	r3, [sp, #12]
 800cbd0:	3303      	adds	r3, #3
 800cbd2:	492c      	ldr	r1, [pc, #176]	; (800cc84 <mtx6_execute+0x104>)
 800cbd4:	9100      	str	r1, [sp, #0]
 800cbd6:	4610      	mov	r0, r2
 800cbd8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cbdc:	461a      	mov	r2, r3
 800cbde:	4b26      	ldr	r3, [pc, #152]	; (800cc78 <mtx6_execute+0xf8>)
 800cbe0:	f7f4 fafe 	bl	80011e0 <chThdCreateStatic>
 800cbe4:	4602      	mov	r2, r0
 800cbe6:	4b25      	ldr	r3, [pc, #148]	; (800cc7c <mtx6_execute+0xfc>)
 800cbe8:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 800cbea:	4b21      	ldr	r3, [pc, #132]	; (800cc70 <mtx6_execute+0xf0>)
 800cbec:	68da      	ldr	r2, [r3, #12]
 800cbee:	9b03      	ldr	r3, [sp, #12]
 800cbf0:	3304      	adds	r3, #4
 800cbf2:	4925      	ldr	r1, [pc, #148]	; (800cc88 <mtx6_execute+0x108>)
 800cbf4:	9100      	str	r1, [sp, #0]
 800cbf6:	4610      	mov	r0, r2
 800cbf8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cbfc:	461a      	mov	r2, r3
 800cbfe:	4b1e      	ldr	r3, [pc, #120]	; (800cc78 <mtx6_execute+0xf8>)
 800cc00:	f7f4 faee 	bl	80011e0 <chThdCreateStatic>
 800cc04:	4602      	mov	r2, r0
 800cc06:	4b1d      	ldr	r3, [pc, #116]	; (800cc7c <mtx6_execute+0xfc>)
 800cc08:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 800cc0a:	4b19      	ldr	r3, [pc, #100]	; (800cc70 <mtx6_execute+0xf0>)
 800cc0c:	691a      	ldr	r2, [r3, #16]
 800cc0e:	9b03      	ldr	r3, [sp, #12]
 800cc10:	3305      	adds	r3, #5
 800cc12:	491e      	ldr	r1, [pc, #120]	; (800cc8c <mtx6_execute+0x10c>)
 800cc14:	9100      	str	r1, [sp, #0]
 800cc16:	4610      	mov	r0, r2
 800cc18:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cc1c:	461a      	mov	r2, r3
 800cc1e:	4b16      	ldr	r3, [pc, #88]	; (800cc78 <mtx6_execute+0xf8>)
 800cc20:	f7f4 fade 	bl	80011e0 <chThdCreateStatic>
 800cc24:	4602      	mov	r2, r0
 800cc26:	4b15      	ldr	r3, [pc, #84]	; (800cc7c <mtx6_execute+0xfc>)
 800cc28:	611a      	str	r2, [r3, #16]
  chSysLock();
 800cc2a:	f7ff fc61 	bl	800c4f0 <chSysLock>
  chCondSignalI(&c1);
 800cc2e:	4818      	ldr	r0, [pc, #96]	; (800cc90 <mtx6_execute+0x110>)
 800cc30:	f7f5 fbbe 	bl	80023b0 <chCondSignalI>
  chCondSignalI(&c1);
 800cc34:	4816      	ldr	r0, [pc, #88]	; (800cc90 <mtx6_execute+0x110>)
 800cc36:	f7f5 fbbb 	bl	80023b0 <chCondSignalI>
  chCondSignalI(&c1);
 800cc3a:	4815      	ldr	r0, [pc, #84]	; (800cc90 <mtx6_execute+0x110>)
 800cc3c:	f7f5 fbb8 	bl	80023b0 <chCondSignalI>
  chCondSignalI(&c1);
 800cc40:	4813      	ldr	r0, [pc, #76]	; (800cc90 <mtx6_execute+0x110>)
 800cc42:	f7f5 fbb5 	bl	80023b0 <chCondSignalI>
  chCondSignalI(&c1);
 800cc46:	4812      	ldr	r0, [pc, #72]	; (800cc90 <mtx6_execute+0x110>)
 800cc48:	f7f5 fbb2 	bl	80023b0 <chCondSignalI>
  chSchRescheduleS();
 800cc4c:	f7f4 f898 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 800cc50:	f7ff fc56 	bl	800c500 <chSysUnlock>
  test_wait_threads();
 800cc54:	f7fe fbac 	bl	800b3b0 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 800cc58:	2001      	movs	r0, #1
 800cc5a:	490e      	ldr	r1, [pc, #56]	; (800cc94 <mtx6_execute+0x114>)
 800cc5c:	f7fe fb40 	bl	800b2e0 <_test_assert_sequence>
 800cc60:	4603      	mov	r3, r0
 800cc62:	2b00      	cmp	r3, #0
 800cc64:	d000      	beq.n	800cc68 <mtx6_execute+0xe8>
 800cc66:	bf00      	nop
}
 800cc68:	b005      	add	sp, #20
 800cc6a:	f85d fb04 	ldr.w	pc, [sp], #4
 800cc6e:	bf00      	nop
 800cc70:	08016240 	.word	0x08016240
 800cc74:	08016610 	.word	0x08016610
 800cc78:	0800cb51 	.word	0x0800cb51
 800cc7c:	20001224 	.word	0x20001224
 800cc80:	08016614 	.word	0x08016614
 800cc84:	08016618 	.word	0x08016618
 800cc88:	0801661c 	.word	0x0801661c
 800cc8c:	08016620 	.word	0x08016620
 800cc90:	20000864 	.word	0x20000864
 800cc94:	08016624 	.word	0x08016624
 800cc98:	f3af 8000 	nop.w
 800cc9c:	f3af 8000 	nop.w

0800cca0 <mtx7_setup>:
 * tester thread then proceeds to broadcast the conditional variable.<br>
 * The test expects the threads to reach their goal in increasing priority
 * order regardless of the initial order.
 */

static void mtx7_setup(void) {
 800cca0:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 800cca2:	4803      	ldr	r0, [pc, #12]	; (800ccb0 <mtx7_setup+0x10>)
 800cca4:	f7f5 fb54 	bl	8002350 <chCondObjectInit>
  chMtxObjectInit(&m1);
 800cca8:	4802      	ldr	r0, [pc, #8]	; (800ccb4 <mtx7_setup+0x14>)
 800ccaa:	f7f5 f921 	bl	8001ef0 <chMtxObjectInit>
}
 800ccae:	bd08      	pop	{r3, pc}
 800ccb0:	20000864 	.word	0x20000864
 800ccb4:	20000844 	.word	0x20000844
 800ccb8:	f3af 8000 	nop.w
 800ccbc:	f3af 8000 	nop.w

0800ccc0 <mtx7_execute>:

static void mtx7_execute(void) {
 800ccc0:	b500      	push	{lr}
 800ccc2:	b085      	sub	sp, #20

  tprio_t prio = chThdGetPriorityX();
 800ccc4:	f7ff fc2c 	bl	800c520 <chThdGetPriorityX>
 800ccc8:	9003      	str	r0, [sp, #12]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 800ccca:	4b30      	ldr	r3, [pc, #192]	; (800cd8c <mtx7_execute+0xcc>)
 800cccc:	681a      	ldr	r2, [r3, #0]
 800ccce:	9b03      	ldr	r3, [sp, #12]
 800ccd0:	3301      	adds	r3, #1
 800ccd2:	492f      	ldr	r1, [pc, #188]	; (800cd90 <mtx7_execute+0xd0>)
 800ccd4:	9100      	str	r1, [sp, #0]
 800ccd6:	4610      	mov	r0, r2
 800ccd8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800ccdc:	461a      	mov	r2, r3
 800ccde:	4b2d      	ldr	r3, [pc, #180]	; (800cd94 <mtx7_execute+0xd4>)
 800cce0:	f7f4 fa7e 	bl	80011e0 <chThdCreateStatic>
 800cce4:	4602      	mov	r2, r0
 800cce6:	4b2c      	ldr	r3, [pc, #176]	; (800cd98 <mtx7_execute+0xd8>)
 800cce8:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 800ccea:	4b28      	ldr	r3, [pc, #160]	; (800cd8c <mtx7_execute+0xcc>)
 800ccec:	685a      	ldr	r2, [r3, #4]
 800ccee:	9b03      	ldr	r3, [sp, #12]
 800ccf0:	3302      	adds	r3, #2
 800ccf2:	492a      	ldr	r1, [pc, #168]	; (800cd9c <mtx7_execute+0xdc>)
 800ccf4:	9100      	str	r1, [sp, #0]
 800ccf6:	4610      	mov	r0, r2
 800ccf8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800ccfc:	461a      	mov	r2, r3
 800ccfe:	4b25      	ldr	r3, [pc, #148]	; (800cd94 <mtx7_execute+0xd4>)
 800cd00:	f7f4 fa6e 	bl	80011e0 <chThdCreateStatic>
 800cd04:	4602      	mov	r2, r0
 800cd06:	4b24      	ldr	r3, [pc, #144]	; (800cd98 <mtx7_execute+0xd8>)
 800cd08:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 800cd0a:	4b20      	ldr	r3, [pc, #128]	; (800cd8c <mtx7_execute+0xcc>)
 800cd0c:	689a      	ldr	r2, [r3, #8]
 800cd0e:	9b03      	ldr	r3, [sp, #12]
 800cd10:	3303      	adds	r3, #3
 800cd12:	4923      	ldr	r1, [pc, #140]	; (800cda0 <mtx7_execute+0xe0>)
 800cd14:	9100      	str	r1, [sp, #0]
 800cd16:	4610      	mov	r0, r2
 800cd18:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cd1c:	461a      	mov	r2, r3
 800cd1e:	4b1d      	ldr	r3, [pc, #116]	; (800cd94 <mtx7_execute+0xd4>)
 800cd20:	f7f4 fa5e 	bl	80011e0 <chThdCreateStatic>
 800cd24:	4602      	mov	r2, r0
 800cd26:	4b1c      	ldr	r3, [pc, #112]	; (800cd98 <mtx7_execute+0xd8>)
 800cd28:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 800cd2a:	4b18      	ldr	r3, [pc, #96]	; (800cd8c <mtx7_execute+0xcc>)
 800cd2c:	68da      	ldr	r2, [r3, #12]
 800cd2e:	9b03      	ldr	r3, [sp, #12]
 800cd30:	3304      	adds	r3, #4
 800cd32:	491c      	ldr	r1, [pc, #112]	; (800cda4 <mtx7_execute+0xe4>)
 800cd34:	9100      	str	r1, [sp, #0]
 800cd36:	4610      	mov	r0, r2
 800cd38:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cd3c:	461a      	mov	r2, r3
 800cd3e:	4b15      	ldr	r3, [pc, #84]	; (800cd94 <mtx7_execute+0xd4>)
 800cd40:	f7f4 fa4e 	bl	80011e0 <chThdCreateStatic>
 800cd44:	4602      	mov	r2, r0
 800cd46:	4b14      	ldr	r3, [pc, #80]	; (800cd98 <mtx7_execute+0xd8>)
 800cd48:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 800cd4a:	4b10      	ldr	r3, [pc, #64]	; (800cd8c <mtx7_execute+0xcc>)
 800cd4c:	691a      	ldr	r2, [r3, #16]
 800cd4e:	9b03      	ldr	r3, [sp, #12]
 800cd50:	3305      	adds	r3, #5
 800cd52:	4915      	ldr	r1, [pc, #84]	; (800cda8 <mtx7_execute+0xe8>)
 800cd54:	9100      	str	r1, [sp, #0]
 800cd56:	4610      	mov	r0, r2
 800cd58:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cd5c:	461a      	mov	r2, r3
 800cd5e:	4b0d      	ldr	r3, [pc, #52]	; (800cd94 <mtx7_execute+0xd4>)
 800cd60:	f7f4 fa3e 	bl	80011e0 <chThdCreateStatic>
 800cd64:	4602      	mov	r2, r0
 800cd66:	4b0c      	ldr	r3, [pc, #48]	; (800cd98 <mtx7_execute+0xd8>)
 800cd68:	611a      	str	r2, [r3, #16]
  chCondBroadcast(&c1);
 800cd6a:	4810      	ldr	r0, [pc, #64]	; (800cdac <mtx7_execute+0xec>)
 800cd6c:	f7f5 fb38 	bl	80023e0 <chCondBroadcast>
  test_wait_threads();
 800cd70:	f7fe fb1e 	bl	800b3b0 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 800cd74:	2001      	movs	r0, #1
 800cd76:	490e      	ldr	r1, [pc, #56]	; (800cdb0 <mtx7_execute+0xf0>)
 800cd78:	f7fe fab2 	bl	800b2e0 <_test_assert_sequence>
 800cd7c:	4603      	mov	r3, r0
 800cd7e:	2b00      	cmp	r3, #0
 800cd80:	d000      	beq.n	800cd84 <mtx7_execute+0xc4>
 800cd82:	bf00      	nop
}
 800cd84:	b005      	add	sp, #20
 800cd86:	f85d fb04 	ldr.w	pc, [sp], #4
 800cd8a:	bf00      	nop
 800cd8c:	08016240 	.word	0x08016240
 800cd90:	08016610 	.word	0x08016610
 800cd94:	0800cb51 	.word	0x0800cb51
 800cd98:	20001224 	.word	0x20001224
 800cd9c:	08016614 	.word	0x08016614
 800cda0:	08016618 	.word	0x08016618
 800cda4:	0801661c 	.word	0x0801661c
 800cda8:	08016620 	.word	0x08016620
 800cdac:	20000864 	.word	0x20000864
 800cdb0:	08016624 	.word	0x08016624
 800cdb4:	f3af 8000 	nop.w
 800cdb8:	f3af 8000 	nop.w
 800cdbc:	f3af 8000 	nop.w

0800cdc0 <mtx8_setup>:
 * This test case verifies the priority boost of a thread waiting on a
 * conditional variable queue. It tests this very specific situation in order
 * to complete the code coverage.
 */

static void mtx8_setup(void) {
 800cdc0:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 800cdc2:	4805      	ldr	r0, [pc, #20]	; (800cdd8 <mtx8_setup+0x18>)
 800cdc4:	f7f5 fac4 	bl	8002350 <chCondObjectInit>
  chMtxObjectInit(&m1);
 800cdc8:	4804      	ldr	r0, [pc, #16]	; (800cddc <mtx8_setup+0x1c>)
 800cdca:	f7f5 f891 	bl	8001ef0 <chMtxObjectInit>
  chMtxObjectInit(&m2);
 800cdce:	4804      	ldr	r0, [pc, #16]	; (800cde0 <mtx8_setup+0x20>)
 800cdd0:	f7f5 f88e 	bl	8001ef0 <chMtxObjectInit>
}
 800cdd4:	bd08      	pop	{r3, pc}
 800cdd6:	bf00      	nop
 800cdd8:	20000864 	.word	0x20000864
 800cddc:	20000844 	.word	0x20000844
 800cde0:	20000854 	.word	0x20000854
 800cde4:	f3af 8000 	nop.w
 800cde8:	f3af 8000 	nop.w
 800cdec:	f3af 8000 	nop.w

0800cdf0 <thread11>:

static THD_FUNCTION(thread11, p) {
 800cdf0:	b500      	push	{lr}
 800cdf2:	b083      	sub	sp, #12
 800cdf4:	9001      	str	r0, [sp, #4]

  chMtxLock(&m2);
 800cdf6:	480c      	ldr	r0, [pc, #48]	; (800ce28 <thread11+0x38>)
 800cdf8:	f7f5 f88a 	bl	8001f10 <chMtxLock>
  chMtxLock(&m1);
 800cdfc:	480b      	ldr	r0, [pc, #44]	; (800ce2c <thread11+0x3c>)
 800cdfe:	f7f5 f887 	bl	8001f10 <chMtxLock>
#if CH_CFG_USE_CONDVARS_TIMEOUT || defined(__DOXYGEN__)
  chCondWaitTimeout(&c1, TIME_INFINITE);
 800ce02:	480b      	ldr	r0, [pc, #44]	; (800ce30 <thread11+0x40>)
 800ce04:	f04f 31ff 	mov.w	r1, #4294967295
 800ce08:	f7f5 fb52 	bl	80024b0 <chCondWaitTimeout>
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
 800ce0c:	9b01      	ldr	r3, [sp, #4]
 800ce0e:	781b      	ldrb	r3, [r3, #0]
 800ce10:	4618      	mov	r0, r3
 800ce12:	f7fe fa1d 	bl	800b250 <test_emit_token>
  chMtxUnlock(&m1);
 800ce16:	4805      	ldr	r0, [pc, #20]	; (800ce2c <thread11+0x3c>)
 800ce18:	f7f5 f922 	bl	8002060 <chMtxUnlock>
  chMtxUnlock(&m2);
 800ce1c:	4802      	ldr	r0, [pc, #8]	; (800ce28 <thread11+0x38>)
 800ce1e:	f7f5 f91f 	bl	8002060 <chMtxUnlock>
}
 800ce22:	b003      	add	sp, #12
 800ce24:	f85d fb04 	ldr.w	pc, [sp], #4
 800ce28:	20000854 	.word	0x20000854
 800ce2c:	20000844 	.word	0x20000844
 800ce30:	20000864 	.word	0x20000864
 800ce34:	f3af 8000 	nop.w
 800ce38:	f3af 8000 	nop.w
 800ce3c:	f3af 8000 	nop.w

0800ce40 <thread12>:

static THD_FUNCTION(thread12, p) {
 800ce40:	b500      	push	{lr}
 800ce42:	b083      	sub	sp, #12
 800ce44:	9001      	str	r0, [sp, #4]

  chMtxLock(&m2);
 800ce46:	4807      	ldr	r0, [pc, #28]	; (800ce64 <thread12+0x24>)
 800ce48:	f7f5 f862 	bl	8001f10 <chMtxLock>
  test_emit_token(*(char *)p);
 800ce4c:	9b01      	ldr	r3, [sp, #4]
 800ce4e:	781b      	ldrb	r3, [r3, #0]
 800ce50:	4618      	mov	r0, r3
 800ce52:	f7fe f9fd 	bl	800b250 <test_emit_token>
  chMtxUnlock(&m2);
 800ce56:	4803      	ldr	r0, [pc, #12]	; (800ce64 <thread12+0x24>)
 800ce58:	f7f5 f902 	bl	8002060 <chMtxUnlock>
}
 800ce5c:	b003      	add	sp, #12
 800ce5e:	f85d fb04 	ldr.w	pc, [sp], #4
 800ce62:	bf00      	nop
 800ce64:	20000854 	.word	0x20000854
 800ce68:	f3af 8000 	nop.w
 800ce6c:	f3af 8000 	nop.w

0800ce70 <mtx8_execute>:

static void mtx8_execute(void) {
 800ce70:	b500      	push	{lr}
 800ce72:	b085      	sub	sp, #20

  tprio_t prio = chThdGetPriorityX();
 800ce74:	f7ff fb54 	bl	800c520 <chThdGetPriorityX>
 800ce78:	9003      	str	r0, [sp, #12]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 800ce7a:	4b21      	ldr	r3, [pc, #132]	; (800cf00 <mtx8_execute+0x90>)
 800ce7c:	681a      	ldr	r2, [r3, #0]
 800ce7e:	9b03      	ldr	r3, [sp, #12]
 800ce80:	3301      	adds	r3, #1
 800ce82:	4920      	ldr	r1, [pc, #128]	; (800cf04 <mtx8_execute+0x94>)
 800ce84:	9100      	str	r1, [sp, #0]
 800ce86:	4610      	mov	r0, r2
 800ce88:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800ce8c:	461a      	mov	r2, r3
 800ce8e:	4b1e      	ldr	r3, [pc, #120]	; (800cf08 <mtx8_execute+0x98>)
 800ce90:	f7f4 f9a6 	bl	80011e0 <chThdCreateStatic>
 800ce94:	4602      	mov	r2, r0
 800ce96:	4b1d      	ldr	r3, [pc, #116]	; (800cf0c <mtx8_execute+0x9c>)
 800ce98:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 800ce9a:	4b19      	ldr	r3, [pc, #100]	; (800cf00 <mtx8_execute+0x90>)
 800ce9c:	685a      	ldr	r2, [r3, #4]
 800ce9e:	9b03      	ldr	r3, [sp, #12]
 800cea0:	3302      	adds	r3, #2
 800cea2:	491b      	ldr	r1, [pc, #108]	; (800cf10 <mtx8_execute+0xa0>)
 800cea4:	9100      	str	r1, [sp, #0]
 800cea6:	4610      	mov	r0, r2
 800cea8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800ceac:	461a      	mov	r2, r3
 800ceae:	4b19      	ldr	r3, [pc, #100]	; (800cf14 <mtx8_execute+0xa4>)
 800ceb0:	f7f4 f996 	bl	80011e0 <chThdCreateStatic>
 800ceb4:	4602      	mov	r2, r0
 800ceb6:	4b15      	ldr	r3, [pc, #84]	; (800cf0c <mtx8_execute+0x9c>)
 800ceb8:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
 800ceba:	4b11      	ldr	r3, [pc, #68]	; (800cf00 <mtx8_execute+0x90>)
 800cebc:	689a      	ldr	r2, [r3, #8]
 800cebe:	9b03      	ldr	r3, [sp, #12]
 800cec0:	3303      	adds	r3, #3
 800cec2:	4915      	ldr	r1, [pc, #84]	; (800cf18 <mtx8_execute+0xa8>)
 800cec4:	9100      	str	r1, [sp, #0]
 800cec6:	4610      	mov	r0, r2
 800cec8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cecc:	461a      	mov	r2, r3
 800cece:	4b13      	ldr	r3, [pc, #76]	; (800cf1c <mtx8_execute+0xac>)
 800ced0:	f7f4 f986 	bl	80011e0 <chThdCreateStatic>
 800ced4:	4602      	mov	r2, r0
 800ced6:	4b0d      	ldr	r3, [pc, #52]	; (800cf0c <mtx8_execute+0x9c>)
 800ced8:	609a      	str	r2, [r3, #8]
  chCondSignal(&c1);
 800ceda:	4811      	ldr	r0, [pc, #68]	; (800cf20 <mtx8_execute+0xb0>)
 800cedc:	f7f5 fa48 	bl	8002370 <chCondSignal>
  chCondSignal(&c1);
 800cee0:	480f      	ldr	r0, [pc, #60]	; (800cf20 <mtx8_execute+0xb0>)
 800cee2:	f7f5 fa45 	bl	8002370 <chCondSignal>
  test_wait_threads();
 800cee6:	f7fe fa63 	bl	800b3b0 <test_wait_threads>
  test_assert_sequence(1, "ABC");
 800ceea:	2001      	movs	r0, #1
 800ceec:	490d      	ldr	r1, [pc, #52]	; (800cf24 <mtx8_execute+0xb4>)
 800ceee:	f7fe f9f7 	bl	800b2e0 <_test_assert_sequence>
 800cef2:	4603      	mov	r3, r0
 800cef4:	2b00      	cmp	r3, #0
 800cef6:	d000      	beq.n	800cefa <mtx8_execute+0x8a>
 800cef8:	bf00      	nop
}
 800cefa:	b005      	add	sp, #20
 800cefc:	f85d fb04 	ldr.w	pc, [sp], #4
 800cf00:	08016240 	.word	0x08016240
 800cf04:	08016620 	.word	0x08016620
 800cf08:	0800cdf1 	.word	0x0800cdf1
 800cf0c:	20001224 	.word	0x20001224
 800cf10:	08016618 	.word	0x08016618
 800cf14:	0800cb51 	.word	0x0800cb51
 800cf18:	0801661c 	.word	0x0801661c
 800cf1c:	0800ce41 	.word	0x0800ce41
 800cf20:	20000864 	.word	0x20000864
 800cf24:	080166fc 	.word	0x080166fc
 800cf28:	f3af 8000 	nop.w
 800cf2c:	f3af 8000 	nop.w

0800cf30 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800cf30:	4b01      	ldr	r3, [pc, #4]	; (800cf38 <chThdGetSelfX+0x8>)
 800cf32:	699b      	ldr	r3, [r3, #24]
}
 800cf34:	4618      	mov	r0, r3
 800cf36:	4770      	bx	lr
 800cf38:	20000d98 	.word	0x20000d98
 800cf3c:	f3af 8000 	nop.w

0800cf40 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800cf40:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800cf42:	f7ff fff5 	bl	800cf30 <chThdGetSelfX>
 800cf46:	4603      	mov	r3, r0
 800cf48:	689b      	ldr	r3, [r3, #8]
}
 800cf4a:	4618      	mov	r0, r3
 800cf4c:	bd08      	pop	{r3, pc}
 800cf4e:	bf00      	nop

0800cf50 <chMsgGet>:
 * @param[in] tp        pointer to the thread
 * @return              The message carried by the sender.
 *
 * @api
 */
static inline msg_t chMsgGet(thread_t *tp) {
 800cf50:	b082      	sub	sp, #8
 800cf52:	9001      	str	r0, [sp, #4]

  return tp->p_msg;
 800cf54:	9b01      	ldr	r3, [sp, #4]
 800cf56:	6b1b      	ldr	r3, [r3, #48]	; 0x30
}
 800cf58:	4618      	mov	r0, r3
 800cf5a:	b002      	add	sp, #8
 800cf5c:	4770      	bx	lr
 800cf5e:	bf00      	nop

0800cf60 <thread>:
 * A thread is spawned that sends four messages back to the tester thread.<br>
 * The test expect to receive the messages in the correct sequence and to
 * not find a fifth message waiting.
 */

static THD_FUNCTION(thread, p) {
 800cf60:	b500      	push	{lr}
 800cf62:	b083      	sub	sp, #12
 800cf64:	9001      	str	r0, [sp, #4]

  chMsgSend(p, 'A');
 800cf66:	9801      	ldr	r0, [sp, #4]
 800cf68:	2141      	movs	r1, #65	; 0x41
 800cf6a:	f7f5 fe19 	bl	8002ba0 <chMsgSend>
  chMsgSend(p, 'B');
 800cf6e:	9801      	ldr	r0, [sp, #4]
 800cf70:	2142      	movs	r1, #66	; 0x42
 800cf72:	f7f5 fe15 	bl	8002ba0 <chMsgSend>
  chMsgSend(p, 'C');
 800cf76:	9801      	ldr	r0, [sp, #4]
 800cf78:	2143      	movs	r1, #67	; 0x43
 800cf7a:	f7f5 fe11 	bl	8002ba0 <chMsgSend>
}
 800cf7e:	b003      	add	sp, #12
 800cf80:	f85d fb04 	ldr.w	pc, [sp], #4
 800cf84:	f3af 8000 	nop.w
 800cf88:	f3af 8000 	nop.w
 800cf8c:	f3af 8000 	nop.w

0800cf90 <msg1_execute>:

static void msg1_execute(void) {
 800cf90:	b530      	push	{r4, r5, lr}
 800cf92:	b085      	sub	sp, #20
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 800cf94:	4b26      	ldr	r3, [pc, #152]	; (800d030 <msg1_execute+0xa0>)
 800cf96:	681d      	ldr	r5, [r3, #0]
 800cf98:	f7ff ffd2 	bl	800cf40 <chThdGetPriorityX>
 800cf9c:	4603      	mov	r3, r0
 800cf9e:	1c5c      	adds	r4, r3, #1
                                 thread, chThdGetSelfX());
 800cfa0:	f7ff ffc6 	bl	800cf30 <chThdGetSelfX>
 800cfa4:	4603      	mov	r3, r0
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 800cfa6:	9300      	str	r3, [sp, #0]
 800cfa8:	4628      	mov	r0, r5
 800cfaa:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cfae:	4622      	mov	r2, r4
 800cfb0:	4b20      	ldr	r3, [pc, #128]	; (800d034 <msg1_execute+0xa4>)
 800cfb2:	f7f4 f915 	bl	80011e0 <chThdCreateStatic>
 800cfb6:	4602      	mov	r2, r0
 800cfb8:	4b1f      	ldr	r3, [pc, #124]	; (800d038 <msg1_execute+0xa8>)
 800cfba:	601a      	str	r2, [r3, #0]
                                 thread, chThdGetSelfX());
  tp = chMsgWait();
 800cfbc:	f7f5 fe20 	bl	8002c00 <chMsgWait>
 800cfc0:	9003      	str	r0, [sp, #12]
  msg = chMsgGet(tp);
 800cfc2:	9803      	ldr	r0, [sp, #12]
 800cfc4:	f7ff ffc4 	bl	800cf50 <chMsgGet>
 800cfc8:	9002      	str	r0, [sp, #8]
  chMsgRelease(tp, msg);
 800cfca:	9803      	ldr	r0, [sp, #12]
 800cfcc:	9902      	ldr	r1, [sp, #8]
 800cfce:	f7f5 fe3f 	bl	8002c50 <chMsgRelease>
  test_emit_token(msg);
 800cfd2:	9b02      	ldr	r3, [sp, #8]
 800cfd4:	b2db      	uxtb	r3, r3
 800cfd6:	4618      	mov	r0, r3
 800cfd8:	f7fe f93a 	bl	800b250 <test_emit_token>
  tp = chMsgWait();
 800cfdc:	f7f5 fe10 	bl	8002c00 <chMsgWait>
 800cfe0:	9003      	str	r0, [sp, #12]
  msg = chMsgGet(tp);
 800cfe2:	9803      	ldr	r0, [sp, #12]
 800cfe4:	f7ff ffb4 	bl	800cf50 <chMsgGet>
 800cfe8:	9002      	str	r0, [sp, #8]
  chMsgRelease(tp, msg);
 800cfea:	9803      	ldr	r0, [sp, #12]
 800cfec:	9902      	ldr	r1, [sp, #8]
 800cfee:	f7f5 fe2f 	bl	8002c50 <chMsgRelease>
  test_emit_token(msg);
 800cff2:	9b02      	ldr	r3, [sp, #8]
 800cff4:	b2db      	uxtb	r3, r3
 800cff6:	4618      	mov	r0, r3
 800cff8:	f7fe f92a 	bl	800b250 <test_emit_token>
  tp = chMsgWait();
 800cffc:	f7f5 fe00 	bl	8002c00 <chMsgWait>
 800d000:	9003      	str	r0, [sp, #12]
  msg = chMsgGet(tp);
 800d002:	9803      	ldr	r0, [sp, #12]
 800d004:	f7ff ffa4 	bl	800cf50 <chMsgGet>
 800d008:	9002      	str	r0, [sp, #8]
  chMsgRelease(tp, msg);
 800d00a:	9803      	ldr	r0, [sp, #12]
 800d00c:	9902      	ldr	r1, [sp, #8]
 800d00e:	f7f5 fe1f 	bl	8002c50 <chMsgRelease>
  test_emit_token(msg);
 800d012:	9b02      	ldr	r3, [sp, #8]
 800d014:	b2db      	uxtb	r3, r3
 800d016:	4618      	mov	r0, r3
 800d018:	f7fe f91a 	bl	800b250 <test_emit_token>
  test_assert_sequence(1, "ABC");
 800d01c:	2001      	movs	r0, #1
 800d01e:	4907      	ldr	r1, [pc, #28]	; (800d03c <msg1_execute+0xac>)
 800d020:	f7fe f95e 	bl	800b2e0 <_test_assert_sequence>
 800d024:	4603      	mov	r3, r0
 800d026:	2b00      	cmp	r3, #0
 800d028:	d000      	beq.n	800d02c <msg1_execute+0x9c>
 800d02a:	bf00      	nop
}
 800d02c:	b005      	add	sp, #20
 800d02e:	bd30      	pop	{r4, r5, pc}
 800d030:	08016240 	.word	0x08016240
 800d034:	0800cf61 	.word	0x0800cf61
 800d038:	20001224 	.word	0x20001224
 800d03c:	08016740 	.word	0x08016740

0800d040 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800d040:	b082      	sub	sp, #8
 800d042:	2320      	movs	r3, #32
 800d044:	9301      	str	r3, [sp, #4]
 800d046:	9b01      	ldr	r3, [sp, #4]
 800d048:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800d04c:	b002      	add	sp, #8
 800d04e:	4770      	bx	lr

0800d050 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800d050:	b082      	sub	sp, #8
 800d052:	2300      	movs	r3, #0
 800d054:	9301      	str	r3, [sp, #4]
 800d056:	9b01      	ldr	r3, [sp, #4]
 800d058:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800d05c:	b002      	add	sp, #8
 800d05e:	4770      	bx	lr

0800d060 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800d060:	b508      	push	{r3, lr}

  port_lock();
 800d062:	f7ff ffed 	bl	800d040 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800d066:	bd08      	pop	{r3, pc}
 800d068:	f3af 8000 	nop.w
 800d06c:	f3af 8000 	nop.w

0800d070 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800d070:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800d072:	f7ff ffed 	bl	800d050 <port_unlock>
}
 800d076:	bd08      	pop	{r3, pc}
 800d078:	f3af 8000 	nop.w
 800d07c:	f3af 8000 	nop.w

0800d080 <chSemGetCounterI>:
 * @param[in] sp        pointer to a @p semaphore_t structure
 * @return              The semaphore counter value.
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {
 800d080:	b082      	sub	sp, #8
 800d082:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return sp->s_cnt;
 800d084:	9b01      	ldr	r3, [sp, #4]
 800d086:	689b      	ldr	r3, [r3, #8]
}
 800d088:	4618      	mov	r0, r3
 800d08a:	b002      	add	sp, #8
 800d08c:	4770      	bx	lr
 800d08e:	bf00      	nop

0800d090 <chMBGetFreeCountI>:
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of empty message slots.
 *
 * @iclass
 */
static inline cnt_t chMBGetFreeCountI(mailbox_t *mbp) {
 800d090:	b500      	push	{lr}
 800d092:	b083      	sub	sp, #12
 800d094:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return chSemGetCounterI(&mbp->mb_emptysem);
 800d096:	9b01      	ldr	r3, [sp, #4]
 800d098:	331c      	adds	r3, #28
 800d09a:	4618      	mov	r0, r3
 800d09c:	f7ff fff0 	bl	800d080 <chSemGetCounterI>
 800d0a0:	4603      	mov	r3, r0
}
 800d0a2:	4618      	mov	r0, r3
 800d0a4:	b003      	add	sp, #12
 800d0a6:	f85d fb04 	ldr.w	pc, [sp], #4
 800d0aa:	bf00      	nop
 800d0ac:	f3af 8000 	nop.w

0800d0b0 <chMBGetUsedCountI>:
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of queued messages.
 *
 * @iclass
 */
static inline cnt_t chMBGetUsedCountI(mailbox_t *mbp) {
 800d0b0:	b500      	push	{lr}
 800d0b2:	b083      	sub	sp, #12
 800d0b4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return chSemGetCounterI(&mbp->mb_fullsem);
 800d0b6:	9b01      	ldr	r3, [sp, #4]
 800d0b8:	3310      	adds	r3, #16
 800d0ba:	4618      	mov	r0, r3
 800d0bc:	f7ff ffe0 	bl	800d080 <chSemGetCounterI>
 800d0c0:	4603      	mov	r3, r0
}
 800d0c2:	4618      	mov	r0, r3
 800d0c4:	b003      	add	sp, #12
 800d0c6:	f85d fb04 	ldr.w	pc, [sp], #4
 800d0ca:	bf00      	nop
 800d0cc:	f3af 8000 	nop.w

0800d0d0 <mbox1_setup>:
 * Messages are posted/fetched from a mailbox in carefully designed sequences
 * in order to stimulate all the possible code paths inside the mailbox.<br>
 * The test expects to find a consistent mailbox status after each operation.
 */

static void mbox1_setup(void) {
 800d0d0:	b508      	push	{r3, lr}

  chMBObjectInit(&mb1, (msg_t *)test.wa.T0, MB_SIZE);
 800d0d2:	4803      	ldr	r0, [pc, #12]	; (800d0e0 <mbox1_setup+0x10>)
 800d0d4:	4903      	ldr	r1, [pc, #12]	; (800d0e4 <mbox1_setup+0x14>)
 800d0d6:	2205      	movs	r2, #5
 800d0d8:	f7f5 fe02 	bl	8002ce0 <chMBObjectInit>
}
 800d0dc:	bd08      	pop	{r3, pc}
 800d0de:	bf00      	nop
 800d0e0:	2000086c 	.word	0x2000086c
 800d0e4:	20001238 	.word	0x20001238
 800d0e8:	f3af 8000 	nop.w
 800d0ec:	f3af 8000 	nop.w

0800d0f0 <mbox1_execute>:

static void mbox1_execute(void) {
 800d0f0:	b500      	push	{lr}
 800d0f2:	b085      	sub	sp, #20
  unsigned i;

  /*
   * Testing initial space.
   */
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 800d0f4:	f7ff ffb4 	bl	800d060 <chSysLock>
 800d0f8:	48a9      	ldr	r0, [pc, #676]	; (800d3a0 <mbox1_execute+0x2b0>)
 800d0fa:	f7ff ffc9 	bl	800d090 <chMBGetFreeCountI>
 800d0fe:	4603      	mov	r3, r0
 800d100:	2b05      	cmp	r3, #5
 800d102:	bf14      	ite	ne
 800d104:	2300      	movne	r3, #0
 800d106:	2301      	moveq	r3, #1
 800d108:	b2db      	uxtb	r3, r3
 800d10a:	2001      	movs	r0, #1
 800d10c:	4619      	mov	r1, r3
 800d10e:	f7fe f8cf 	bl	800b2b0 <_test_assert>
 800d112:	4603      	mov	r3, r0
 800d114:	2b00      	cmp	r3, #0
 800d116:	d002      	beq.n	800d11e <mbox1_execute+0x2e>
 800d118:	f7ff ffaa 	bl	800d070 <chSysUnlock>
 800d11c:	e3ef      	b.n	800d8fe <mbox1_execute+0x80e>
 800d11e:	f7ff ffa7 	bl	800d070 <chSysUnlock>

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
 800d122:	2300      	movs	r3, #0
 800d124:	9303      	str	r3, [sp, #12]
 800d126:	e019      	b.n	800d15c <mbox1_execute+0x6c>
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 800d128:	9b03      	ldr	r3, [sp, #12]
 800d12a:	3342      	adds	r3, #66	; 0x42
 800d12c:	489c      	ldr	r0, [pc, #624]	; (800d3a0 <mbox1_execute+0x2b0>)
 800d12e:	4619      	mov	r1, r3
 800d130:	f04f 32ff 	mov.w	r2, #4294967295
 800d134:	f7f5 fe34 	bl	8002da0 <chMBPost>
 800d138:	9002      	str	r0, [sp, #8]
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
 800d13a:	9b02      	ldr	r3, [sp, #8]
 800d13c:	2b00      	cmp	r3, #0
 800d13e:	bf14      	ite	ne
 800d140:	2300      	movne	r3, #0
 800d142:	2301      	moveq	r3, #1
 800d144:	b2db      	uxtb	r3, r3
 800d146:	2002      	movs	r0, #2
 800d148:	4619      	mov	r1, r3
 800d14a:	f7fe f8b1 	bl	800b2b0 <_test_assert>
 800d14e:	4603      	mov	r3, r0
 800d150:	2b00      	cmp	r3, #0
 800d152:	d000      	beq.n	800d156 <mbox1_execute+0x66>
 800d154:	e3d3      	b.n	800d8fe <mbox1_execute+0x80e>
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
 800d156:	9b03      	ldr	r3, [sp, #12]
 800d158:	3301      	adds	r3, #1
 800d15a:	9303      	str	r3, [sp, #12]
 800d15c:	9b03      	ldr	r3, [sp, #12]
 800d15e:	2b03      	cmp	r3, #3
 800d160:	d9e2      	bls.n	800d128 <mbox1_execute+0x38>
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
  }
  msg1 = chMBPostAhead(&mb1, 'A', TIME_INFINITE);
 800d162:	488f      	ldr	r0, [pc, #572]	; (800d3a0 <mbox1_execute+0x2b0>)
 800d164:	2141      	movs	r1, #65	; 0x41
 800d166:	f04f 32ff 	mov.w	r2, #4294967295
 800d16a:	f7f5 fe91 	bl	8002e90 <chMBPostAhead>
 800d16e:	9002      	str	r0, [sp, #8]
  test_assert(3, msg1 == MSG_OK, "wrong wake-up message");
 800d170:	9b02      	ldr	r3, [sp, #8]
 800d172:	2b00      	cmp	r3, #0
 800d174:	bf14      	ite	ne
 800d176:	2300      	movne	r3, #0
 800d178:	2301      	moveq	r3, #1
 800d17a:	b2db      	uxtb	r3, r3
 800d17c:	2003      	movs	r0, #3
 800d17e:	4619      	mov	r1, r3
 800d180:	f7fe f896 	bl	800b2b0 <_test_assert>
 800d184:	4603      	mov	r3, r0
 800d186:	2b00      	cmp	r3, #0
 800d188:	d000      	beq.n	800d18c <mbox1_execute+0x9c>
 800d18a:	e3b8      	b.n	800d8fe <mbox1_execute+0x80e>

  /*
   * Testing post timeout.
   */
  msg1 = chMBPost(&mb1, 'X', 1);
 800d18c:	4884      	ldr	r0, [pc, #528]	; (800d3a0 <mbox1_execute+0x2b0>)
 800d18e:	2158      	movs	r1, #88	; 0x58
 800d190:	2201      	movs	r2, #1
 800d192:	f7f5 fe05 	bl	8002da0 <chMBPost>
 800d196:	9002      	str	r0, [sp, #8]
  test_assert(4, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800d198:	9b02      	ldr	r3, [sp, #8]
 800d19a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800d19e:	bf14      	ite	ne
 800d1a0:	2300      	movne	r3, #0
 800d1a2:	2301      	moveq	r3, #1
 800d1a4:	b2db      	uxtb	r3, r3
 800d1a6:	2004      	movs	r0, #4
 800d1a8:	4619      	mov	r1, r3
 800d1aa:	f7fe f881 	bl	800b2b0 <_test_assert>
 800d1ae:	4603      	mov	r3, r0
 800d1b0:	2b00      	cmp	r3, #0
 800d1b2:	d000      	beq.n	800d1b6 <mbox1_execute+0xc6>
 800d1b4:	e3a3      	b.n	800d8fe <mbox1_execute+0x80e>
  chSysLock();
 800d1b6:	f7ff ff53 	bl	800d060 <chSysLock>
  msg1 = chMBPostI(&mb1, 'X');
 800d1ba:	4879      	ldr	r0, [pc, #484]	; (800d3a0 <mbox1_execute+0x2b0>)
 800d1bc:	2158      	movs	r1, #88	; 0x58
 800d1be:	f7f5 fe37 	bl	8002e30 <chMBPostI>
 800d1c2:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 800d1c4:	f7ff ff54 	bl	800d070 <chSysUnlock>
  test_assert(5, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800d1c8:	9b02      	ldr	r3, [sp, #8]
 800d1ca:	f1b3 3fff 	cmp.w	r3, #4294967295
 800d1ce:	bf14      	ite	ne
 800d1d0:	2300      	movne	r3, #0
 800d1d2:	2301      	moveq	r3, #1
 800d1d4:	b2db      	uxtb	r3, r3
 800d1d6:	2005      	movs	r0, #5
 800d1d8:	4619      	mov	r1, r3
 800d1da:	f7fe f869 	bl	800b2b0 <_test_assert>
 800d1de:	4603      	mov	r3, r0
 800d1e0:	2b00      	cmp	r3, #0
 800d1e2:	d000      	beq.n	800d1e6 <mbox1_execute+0xf6>
 800d1e4:	e38b      	b.n	800d8fe <mbox1_execute+0x80e>
  msg1 = chMBPostAhead(&mb1, 'X', 1);
 800d1e6:	486e      	ldr	r0, [pc, #440]	; (800d3a0 <mbox1_execute+0x2b0>)
 800d1e8:	2158      	movs	r1, #88	; 0x58
 800d1ea:	2201      	movs	r2, #1
 800d1ec:	f7f5 fe50 	bl	8002e90 <chMBPostAhead>
 800d1f0:	9002      	str	r0, [sp, #8]
  test_assert(6, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800d1f2:	9b02      	ldr	r3, [sp, #8]
 800d1f4:	f1b3 3fff 	cmp.w	r3, #4294967295
 800d1f8:	bf14      	ite	ne
 800d1fa:	2300      	movne	r3, #0
 800d1fc:	2301      	moveq	r3, #1
 800d1fe:	b2db      	uxtb	r3, r3
 800d200:	2006      	movs	r0, #6
 800d202:	4619      	mov	r1, r3
 800d204:	f7fe f854 	bl	800b2b0 <_test_assert>
 800d208:	4603      	mov	r3, r0
 800d20a:	2b00      	cmp	r3, #0
 800d20c:	d000      	beq.n	800d210 <mbox1_execute+0x120>
 800d20e:	e376      	b.n	800d8fe <mbox1_execute+0x80e>
  chSysLock();
 800d210:	f7ff ff26 	bl	800d060 <chSysLock>
  msg1 = chMBPostAheadI(&mb1, 'X');
 800d214:	4862      	ldr	r0, [pc, #392]	; (800d3a0 <mbox1_execute+0x2b0>)
 800d216:	2158      	movs	r1, #88	; 0x58
 800d218:	f7f5 fe82 	bl	8002f20 <chMBPostAheadI>
 800d21c:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 800d21e:	f7ff ff27 	bl	800d070 <chSysUnlock>
  test_assert(7, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800d222:	9b02      	ldr	r3, [sp, #8]
 800d224:	f1b3 3fff 	cmp.w	r3, #4294967295
 800d228:	bf14      	ite	ne
 800d22a:	2300      	movne	r3, #0
 800d22c:	2301      	moveq	r3, #1
 800d22e:	b2db      	uxtb	r3, r3
 800d230:	2007      	movs	r0, #7
 800d232:	4619      	mov	r1, r3
 800d234:	f7fe f83c 	bl	800b2b0 <_test_assert>
 800d238:	4603      	mov	r3, r0
 800d23a:	2b00      	cmp	r3, #0
 800d23c:	d000      	beq.n	800d240 <mbox1_execute+0x150>
 800d23e:	e35e      	b.n	800d8fe <mbox1_execute+0x80e>

  /*
   * Testing final conditions.
   */
  test_assert_lock(8, chMBGetFreeCountI(&mb1) == 0, "still empty");
 800d240:	f7ff ff0e 	bl	800d060 <chSysLock>
 800d244:	4856      	ldr	r0, [pc, #344]	; (800d3a0 <mbox1_execute+0x2b0>)
 800d246:	f7ff ff23 	bl	800d090 <chMBGetFreeCountI>
 800d24a:	4603      	mov	r3, r0
 800d24c:	2b00      	cmp	r3, #0
 800d24e:	bf14      	ite	ne
 800d250:	2300      	movne	r3, #0
 800d252:	2301      	moveq	r3, #1
 800d254:	b2db      	uxtb	r3, r3
 800d256:	2008      	movs	r0, #8
 800d258:	4619      	mov	r1, r3
 800d25a:	f7fe f829 	bl	800b2b0 <_test_assert>
 800d25e:	4603      	mov	r3, r0
 800d260:	2b00      	cmp	r3, #0
 800d262:	d002      	beq.n	800d26a <mbox1_execute+0x17a>
 800d264:	f7ff ff04 	bl	800d070 <chSysUnlock>
 800d268:	e349      	b.n	800d8fe <mbox1_execute+0x80e>
 800d26a:	f7ff ff01 	bl	800d070 <chSysUnlock>
  test_assert_lock(9, chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 800d26e:	f7ff fef7 	bl	800d060 <chSysLock>
 800d272:	484b      	ldr	r0, [pc, #300]	; (800d3a0 <mbox1_execute+0x2b0>)
 800d274:	f7ff ff1c 	bl	800d0b0 <chMBGetUsedCountI>
 800d278:	4603      	mov	r3, r0
 800d27a:	2b05      	cmp	r3, #5
 800d27c:	bf14      	ite	ne
 800d27e:	2300      	movne	r3, #0
 800d280:	2301      	moveq	r3, #1
 800d282:	b2db      	uxtb	r3, r3
 800d284:	2009      	movs	r0, #9
 800d286:	4619      	mov	r1, r3
 800d288:	f7fe f812 	bl	800b2b0 <_test_assert>
 800d28c:	4603      	mov	r3, r0
 800d28e:	2b00      	cmp	r3, #0
 800d290:	d002      	beq.n	800d298 <mbox1_execute+0x1a8>
 800d292:	f7ff feed 	bl	800d070 <chSysUnlock>
 800d296:	e332      	b.n	800d8fe <mbox1_execute+0x80e>
 800d298:	f7ff feea 	bl	800d070 <chSysUnlock>
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800d29c:	f7ff fee0 	bl	800d060 <chSysLock>
 800d2a0:	4b3f      	ldr	r3, [pc, #252]	; (800d3a0 <mbox1_execute+0x2b0>)
 800d2a2:	68da      	ldr	r2, [r3, #12]
 800d2a4:	4b3e      	ldr	r3, [pc, #248]	; (800d3a0 <mbox1_execute+0x2b0>)
 800d2a6:	689b      	ldr	r3, [r3, #8]
 800d2a8:	429a      	cmp	r2, r3
 800d2aa:	bf14      	ite	ne
 800d2ac:	2300      	movne	r3, #0
 800d2ae:	2301      	moveq	r3, #1
 800d2b0:	b2db      	uxtb	r3, r3
 800d2b2:	200a      	movs	r0, #10
 800d2b4:	4619      	mov	r1, r3
 800d2b6:	f7fd fffb 	bl	800b2b0 <_test_assert>
 800d2ba:	4603      	mov	r3, r0
 800d2bc:	2b00      	cmp	r3, #0
 800d2be:	d002      	beq.n	800d2c6 <mbox1_execute+0x1d6>
 800d2c0:	f7ff fed6 	bl	800d070 <chSysUnlock>
 800d2c4:	e31b      	b.n	800d8fe <mbox1_execute+0x80e>
 800d2c6:	f7ff fed3 	bl	800d070 <chSysUnlock>

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
 800d2ca:	2300      	movs	r3, #0
 800d2cc:	9303      	str	r3, [sp, #12]
 800d2ce:	e01d      	b.n	800d30c <mbox1_execute+0x21c>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 800d2d0:	ab01      	add	r3, sp, #4
 800d2d2:	4833      	ldr	r0, [pc, #204]	; (800d3a0 <mbox1_execute+0x2b0>)
 800d2d4:	4619      	mov	r1, r3
 800d2d6:	f04f 32ff 	mov.w	r2, #4294967295
 800d2da:	f7f5 fe59 	bl	8002f90 <chMBFetch>
 800d2de:	9002      	str	r0, [sp, #8]
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
 800d2e0:	9b02      	ldr	r3, [sp, #8]
 800d2e2:	2b00      	cmp	r3, #0
 800d2e4:	bf14      	ite	ne
 800d2e6:	2300      	movne	r3, #0
 800d2e8:	2301      	moveq	r3, #1
 800d2ea:	b2db      	uxtb	r3, r3
 800d2ec:	200b      	movs	r0, #11
 800d2ee:	4619      	mov	r1, r3
 800d2f0:	f7fd ffde 	bl	800b2b0 <_test_assert>
 800d2f4:	4603      	mov	r3, r0
 800d2f6:	2b00      	cmp	r3, #0
 800d2f8:	d000      	beq.n	800d2fc <mbox1_execute+0x20c>
 800d2fa:	e300      	b.n	800d8fe <mbox1_execute+0x80e>
    test_emit_token(msg2);
 800d2fc:	9b01      	ldr	r3, [sp, #4]
 800d2fe:	b2db      	uxtb	r3, r3
 800d300:	4618      	mov	r0, r3
 800d302:	f7fd ffa5 	bl	800b250 <test_emit_token>
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
 800d306:	9b03      	ldr	r3, [sp, #12]
 800d308:	3301      	adds	r3, #1
 800d30a:	9303      	str	r3, [sp, #12]
 800d30c:	9b03      	ldr	r3, [sp, #12]
 800d30e:	2b04      	cmp	r3, #4
 800d310:	d9de      	bls.n	800d2d0 <mbox1_execute+0x1e0>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(12, "ABCDE");
 800d312:	200c      	movs	r0, #12
 800d314:	4923      	ldr	r1, [pc, #140]	; (800d3a4 <mbox1_execute+0x2b4>)
 800d316:	f7fd ffe3 	bl	800b2e0 <_test_assert_sequence>
 800d31a:	4603      	mov	r3, r0
 800d31c:	2b00      	cmp	r3, #0
 800d31e:	d000      	beq.n	800d322 <mbox1_execute+0x232>
 800d320:	e2ed      	b.n	800d8fe <mbox1_execute+0x80e>

  /*
   * Testing buffer circularity.
   */
  msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 800d322:	9b03      	ldr	r3, [sp, #12]
 800d324:	3342      	adds	r3, #66	; 0x42
 800d326:	481e      	ldr	r0, [pc, #120]	; (800d3a0 <mbox1_execute+0x2b0>)
 800d328:	4619      	mov	r1, r3
 800d32a:	f04f 32ff 	mov.w	r2, #4294967295
 800d32e:	f7f5 fd37 	bl	8002da0 <chMBPost>
 800d332:	9002      	str	r0, [sp, #8]
  test_assert(13, msg1 == MSG_OK, "wrong wake-up message");
 800d334:	9b02      	ldr	r3, [sp, #8]
 800d336:	2b00      	cmp	r3, #0
 800d338:	bf14      	ite	ne
 800d33a:	2300      	movne	r3, #0
 800d33c:	2301      	moveq	r3, #1
 800d33e:	b2db      	uxtb	r3, r3
 800d340:	200d      	movs	r0, #13
 800d342:	4619      	mov	r1, r3
 800d344:	f7fd ffb4 	bl	800b2b0 <_test_assert>
 800d348:	4603      	mov	r3, r0
 800d34a:	2b00      	cmp	r3, #0
 800d34c:	d000      	beq.n	800d350 <mbox1_execute+0x260>
 800d34e:	e2d6      	b.n	800d8fe <mbox1_execute+0x80e>
  msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 800d350:	ab01      	add	r3, sp, #4
 800d352:	4813      	ldr	r0, [pc, #76]	; (800d3a0 <mbox1_execute+0x2b0>)
 800d354:	4619      	mov	r1, r3
 800d356:	f04f 32ff 	mov.w	r2, #4294967295
 800d35a:	f7f5 fe19 	bl	8002f90 <chMBFetch>
 800d35e:	9002      	str	r0, [sp, #8]
  test_assert(14, msg1 == MSG_OK, "wrong wake-up message");
 800d360:	9b02      	ldr	r3, [sp, #8]
 800d362:	2b00      	cmp	r3, #0
 800d364:	bf14      	ite	ne
 800d366:	2300      	movne	r3, #0
 800d368:	2301      	moveq	r3, #1
 800d36a:	b2db      	uxtb	r3, r3
 800d36c:	200e      	movs	r0, #14
 800d36e:	4619      	mov	r1, r3
 800d370:	f7fd ff9e 	bl	800b2b0 <_test_assert>
 800d374:	4603      	mov	r3, r0
 800d376:	2b00      	cmp	r3, #0
 800d378:	d000      	beq.n	800d37c <mbox1_execute+0x28c>
 800d37a:	e2c0      	b.n	800d8fe <mbox1_execute+0x80e>
  test_assert(15, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 800d37c:	4b08      	ldr	r3, [pc, #32]	; (800d3a0 <mbox1_execute+0x2b0>)
 800d37e:	681a      	ldr	r2, [r3, #0]
 800d380:	4b07      	ldr	r3, [pc, #28]	; (800d3a0 <mbox1_execute+0x2b0>)
 800d382:	689b      	ldr	r3, [r3, #8]
 800d384:	429a      	cmp	r2, r3
 800d386:	bf14      	ite	ne
 800d388:	2300      	movne	r3, #0
 800d38a:	2301      	moveq	r3, #1
 800d38c:	b2db      	uxtb	r3, r3
 800d38e:	200f      	movs	r0, #15
 800d390:	4619      	mov	r1, r3
 800d392:	f7fd ff8d 	bl	800b2b0 <_test_assert>
 800d396:	4603      	mov	r3, r0
 800d398:	2b00      	cmp	r3, #0
 800d39a:	d005      	beq.n	800d3a8 <mbox1_execute+0x2b8>
 800d39c:	e2af      	b.n	800d8fe <mbox1_execute+0x80e>
 800d39e:	bf00      	nop
 800d3a0:	2000086c 	.word	0x2000086c
 800d3a4:	08016770 	.word	0x08016770
  test_assert(16, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 800d3a8:	4ba9      	ldr	r3, [pc, #676]	; (800d650 <mbox1_execute+0x560>)
 800d3aa:	681a      	ldr	r2, [r3, #0]
 800d3ac:	4ba8      	ldr	r3, [pc, #672]	; (800d650 <mbox1_execute+0x560>)
 800d3ae:	68db      	ldr	r3, [r3, #12]
 800d3b0:	429a      	cmp	r2, r3
 800d3b2:	bf14      	ite	ne
 800d3b4:	2300      	movne	r3, #0
 800d3b6:	2301      	moveq	r3, #1
 800d3b8:	b2db      	uxtb	r3, r3
 800d3ba:	2010      	movs	r0, #16
 800d3bc:	4619      	mov	r1, r3
 800d3be:	f7fd ff77 	bl	800b2b0 <_test_assert>
 800d3c2:	4603      	mov	r3, r0
 800d3c4:	2b00      	cmp	r3, #0
 800d3c6:	d000      	beq.n	800d3ca <mbox1_execute+0x2da>
 800d3c8:	e299      	b.n	800d8fe <mbox1_execute+0x80e>

  /*
   * Testing fetch timeout.
   */
  msg1 = chMBFetch(&mb1, &msg2, 1);
 800d3ca:	ab01      	add	r3, sp, #4
 800d3cc:	48a0      	ldr	r0, [pc, #640]	; (800d650 <mbox1_execute+0x560>)
 800d3ce:	4619      	mov	r1, r3
 800d3d0:	2201      	movs	r2, #1
 800d3d2:	f7f5 fddd 	bl	8002f90 <chMBFetch>
 800d3d6:	9002      	str	r0, [sp, #8]
  test_assert(17, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800d3d8:	9b02      	ldr	r3, [sp, #8]
 800d3da:	f1b3 3fff 	cmp.w	r3, #4294967295
 800d3de:	bf14      	ite	ne
 800d3e0:	2300      	movne	r3, #0
 800d3e2:	2301      	moveq	r3, #1
 800d3e4:	b2db      	uxtb	r3, r3
 800d3e6:	2011      	movs	r0, #17
 800d3e8:	4619      	mov	r1, r3
 800d3ea:	f7fd ff61 	bl	800b2b0 <_test_assert>
 800d3ee:	4603      	mov	r3, r0
 800d3f0:	2b00      	cmp	r3, #0
 800d3f2:	d000      	beq.n	800d3f6 <mbox1_execute+0x306>
 800d3f4:	e283      	b.n	800d8fe <mbox1_execute+0x80e>
  chSysLock();
 800d3f6:	f7ff fe33 	bl	800d060 <chSysLock>
  msg1 = chMBFetchI(&mb1, &msg2);
 800d3fa:	ab01      	add	r3, sp, #4
 800d3fc:	4894      	ldr	r0, [pc, #592]	; (800d650 <mbox1_execute+0x560>)
 800d3fe:	4619      	mov	r1, r3
 800d400:	f7f5 fe0e 	bl	8003020 <chMBFetchI>
 800d404:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 800d406:	f7ff fe33 	bl	800d070 <chSysUnlock>
  test_assert(18, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800d40a:	9b02      	ldr	r3, [sp, #8]
 800d40c:	f1b3 3fff 	cmp.w	r3, #4294967295
 800d410:	bf14      	ite	ne
 800d412:	2300      	movne	r3, #0
 800d414:	2301      	moveq	r3, #1
 800d416:	b2db      	uxtb	r3, r3
 800d418:	2012      	movs	r0, #18
 800d41a:	4619      	mov	r1, r3
 800d41c:	f7fd ff48 	bl	800b2b0 <_test_assert>
 800d420:	4603      	mov	r3, r0
 800d422:	2b00      	cmp	r3, #0
 800d424:	d000      	beq.n	800d428 <mbox1_execute+0x338>
 800d426:	e26a      	b.n	800d8fe <mbox1_execute+0x80e>

  /*
   * Testing final conditions.
   */
  test_assert_lock(19, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800d428:	f7ff fe1a 	bl	800d060 <chSysLock>
 800d42c:	4888      	ldr	r0, [pc, #544]	; (800d650 <mbox1_execute+0x560>)
 800d42e:	f7ff fe2f 	bl	800d090 <chMBGetFreeCountI>
 800d432:	4603      	mov	r3, r0
 800d434:	2b05      	cmp	r3, #5
 800d436:	bf14      	ite	ne
 800d438:	2300      	movne	r3, #0
 800d43a:	2301      	moveq	r3, #1
 800d43c:	b2db      	uxtb	r3, r3
 800d43e:	2013      	movs	r0, #19
 800d440:	4619      	mov	r1, r3
 800d442:	f7fd ff35 	bl	800b2b0 <_test_assert>
 800d446:	4603      	mov	r3, r0
 800d448:	2b00      	cmp	r3, #0
 800d44a:	d002      	beq.n	800d452 <mbox1_execute+0x362>
 800d44c:	f7ff fe10 	bl	800d070 <chSysUnlock>
 800d450:	e255      	b.n	800d8fe <mbox1_execute+0x80e>
 800d452:	f7ff fe0d 	bl	800d070 <chSysUnlock>
  test_assert_lock(20, chMBGetUsedCountI(&mb1) == 0, "still full");
 800d456:	f7ff fe03 	bl	800d060 <chSysLock>
 800d45a:	487d      	ldr	r0, [pc, #500]	; (800d650 <mbox1_execute+0x560>)
 800d45c:	f7ff fe28 	bl	800d0b0 <chMBGetUsedCountI>
 800d460:	4603      	mov	r3, r0
 800d462:	2b00      	cmp	r3, #0
 800d464:	bf14      	ite	ne
 800d466:	2300      	movne	r3, #0
 800d468:	2301      	moveq	r3, #1
 800d46a:	b2db      	uxtb	r3, r3
 800d46c:	2014      	movs	r0, #20
 800d46e:	4619      	mov	r1, r3
 800d470:	f7fd ff1e 	bl	800b2b0 <_test_assert>
 800d474:	4603      	mov	r3, r0
 800d476:	2b00      	cmp	r3, #0
 800d478:	d002      	beq.n	800d480 <mbox1_execute+0x390>
 800d47a:	f7ff fdf9 	bl	800d070 <chSysUnlock>
 800d47e:	e23e      	b.n	800d8fe <mbox1_execute+0x80e>
 800d480:	f7ff fdf6 	bl	800d070 <chSysUnlock>
  test_assert_lock(21, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800d484:	f7ff fdec 	bl	800d060 <chSysLock>
 800d488:	4b71      	ldr	r3, [pc, #452]	; (800d650 <mbox1_execute+0x560>)
 800d48a:	68da      	ldr	r2, [r3, #12]
 800d48c:	4b70      	ldr	r3, [pc, #448]	; (800d650 <mbox1_execute+0x560>)
 800d48e:	689b      	ldr	r3, [r3, #8]
 800d490:	429a      	cmp	r2, r3
 800d492:	bf14      	ite	ne
 800d494:	2300      	movne	r3, #0
 800d496:	2301      	moveq	r3, #1
 800d498:	b2db      	uxtb	r3, r3
 800d49a:	2015      	movs	r0, #21
 800d49c:	4619      	mov	r1, r3
 800d49e:	f7fd ff07 	bl	800b2b0 <_test_assert>
 800d4a2:	4603      	mov	r3, r0
 800d4a4:	2b00      	cmp	r3, #0
 800d4a6:	d002      	beq.n	800d4ae <mbox1_execute+0x3be>
 800d4a8:	f7ff fde2 	bl	800d070 <chSysUnlock>
 800d4ac:	e227      	b.n	800d8fe <mbox1_execute+0x80e>
 800d4ae:	f7ff fddf 	bl	800d070 <chSysUnlock>

  /*
   * Testing I-Class.
   */
  chSysLock();
 800d4b2:	f7ff fdd5 	bl	800d060 <chSysLock>
  msg1 = chMBPostI(&mb1, 'A');
 800d4b6:	4866      	ldr	r0, [pc, #408]	; (800d650 <mbox1_execute+0x560>)
 800d4b8:	2141      	movs	r1, #65	; 0x41
 800d4ba:	f7f5 fcb9 	bl	8002e30 <chMBPostI>
 800d4be:	9002      	str	r0, [sp, #8]
  test_assert(22, msg1 == MSG_OK, "wrong wake-up message");
 800d4c0:	9b02      	ldr	r3, [sp, #8]
 800d4c2:	2b00      	cmp	r3, #0
 800d4c4:	bf14      	ite	ne
 800d4c6:	2300      	movne	r3, #0
 800d4c8:	2301      	moveq	r3, #1
 800d4ca:	b2db      	uxtb	r3, r3
 800d4cc:	2016      	movs	r0, #22
 800d4ce:	4619      	mov	r1, r3
 800d4d0:	f7fd feee 	bl	800b2b0 <_test_assert>
 800d4d4:	4603      	mov	r3, r0
 800d4d6:	2b00      	cmp	r3, #0
 800d4d8:	d000      	beq.n	800d4dc <mbox1_execute+0x3ec>
 800d4da:	e210      	b.n	800d8fe <mbox1_execute+0x80e>
  msg1 = chMBPostI(&mb1, 'B');
 800d4dc:	485c      	ldr	r0, [pc, #368]	; (800d650 <mbox1_execute+0x560>)
 800d4de:	2142      	movs	r1, #66	; 0x42
 800d4e0:	f7f5 fca6 	bl	8002e30 <chMBPostI>
 800d4e4:	9002      	str	r0, [sp, #8]
  test_assert(23, msg1 == MSG_OK, "wrong wake-up message");
 800d4e6:	9b02      	ldr	r3, [sp, #8]
 800d4e8:	2b00      	cmp	r3, #0
 800d4ea:	bf14      	ite	ne
 800d4ec:	2300      	movne	r3, #0
 800d4ee:	2301      	moveq	r3, #1
 800d4f0:	b2db      	uxtb	r3, r3
 800d4f2:	2017      	movs	r0, #23
 800d4f4:	4619      	mov	r1, r3
 800d4f6:	f7fd fedb 	bl	800b2b0 <_test_assert>
 800d4fa:	4603      	mov	r3, r0
 800d4fc:	2b00      	cmp	r3, #0
 800d4fe:	d000      	beq.n	800d502 <mbox1_execute+0x412>
 800d500:	e1fd      	b.n	800d8fe <mbox1_execute+0x80e>
  msg1 = chMBPostI(&mb1, 'C');
 800d502:	4853      	ldr	r0, [pc, #332]	; (800d650 <mbox1_execute+0x560>)
 800d504:	2143      	movs	r1, #67	; 0x43
 800d506:	f7f5 fc93 	bl	8002e30 <chMBPostI>
 800d50a:	9002      	str	r0, [sp, #8]
  test_assert(24, msg1 == MSG_OK, "wrong wake-up message");
 800d50c:	9b02      	ldr	r3, [sp, #8]
 800d50e:	2b00      	cmp	r3, #0
 800d510:	bf14      	ite	ne
 800d512:	2300      	movne	r3, #0
 800d514:	2301      	moveq	r3, #1
 800d516:	b2db      	uxtb	r3, r3
 800d518:	2018      	movs	r0, #24
 800d51a:	4619      	mov	r1, r3
 800d51c:	f7fd fec8 	bl	800b2b0 <_test_assert>
 800d520:	4603      	mov	r3, r0
 800d522:	2b00      	cmp	r3, #0
 800d524:	d000      	beq.n	800d528 <mbox1_execute+0x438>
 800d526:	e1ea      	b.n	800d8fe <mbox1_execute+0x80e>
  msg1 = chMBPostI(&mb1, 'D');
 800d528:	4849      	ldr	r0, [pc, #292]	; (800d650 <mbox1_execute+0x560>)
 800d52a:	2144      	movs	r1, #68	; 0x44
 800d52c:	f7f5 fc80 	bl	8002e30 <chMBPostI>
 800d530:	9002      	str	r0, [sp, #8]
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
 800d532:	9b02      	ldr	r3, [sp, #8]
 800d534:	2b00      	cmp	r3, #0
 800d536:	bf14      	ite	ne
 800d538:	2300      	movne	r3, #0
 800d53a:	2301      	moveq	r3, #1
 800d53c:	b2db      	uxtb	r3, r3
 800d53e:	2019      	movs	r0, #25
 800d540:	4619      	mov	r1, r3
 800d542:	f7fd feb5 	bl	800b2b0 <_test_assert>
 800d546:	4603      	mov	r3, r0
 800d548:	2b00      	cmp	r3, #0
 800d54a:	d000      	beq.n	800d54e <mbox1_execute+0x45e>
 800d54c:	e1d7      	b.n	800d8fe <mbox1_execute+0x80e>
  msg1 = chMBPostI(&mb1, 'E');
 800d54e:	4840      	ldr	r0, [pc, #256]	; (800d650 <mbox1_execute+0x560>)
 800d550:	2145      	movs	r1, #69	; 0x45
 800d552:	f7f5 fc6d 	bl	8002e30 <chMBPostI>
 800d556:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 800d558:	f7ff fd8a 	bl	800d070 <chSysUnlock>
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
 800d55c:	9b02      	ldr	r3, [sp, #8]
 800d55e:	2b00      	cmp	r3, #0
 800d560:	bf14      	ite	ne
 800d562:	2300      	movne	r3, #0
 800d564:	2301      	moveq	r3, #1
 800d566:	b2db      	uxtb	r3, r3
 800d568:	201a      	movs	r0, #26
 800d56a:	4619      	mov	r1, r3
 800d56c:	f7fd fea0 	bl	800b2b0 <_test_assert>
 800d570:	4603      	mov	r3, r0
 800d572:	2b00      	cmp	r3, #0
 800d574:	d000      	beq.n	800d578 <mbox1_execute+0x488>
 800d576:	e1c2      	b.n	800d8fe <mbox1_execute+0x80e>
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800d578:	4b35      	ldr	r3, [pc, #212]	; (800d650 <mbox1_execute+0x560>)
 800d57a:	68da      	ldr	r2, [r3, #12]
 800d57c:	4b34      	ldr	r3, [pc, #208]	; (800d650 <mbox1_execute+0x560>)
 800d57e:	689b      	ldr	r3, [r3, #8]
 800d580:	429a      	cmp	r2, r3
 800d582:	bf14      	ite	ne
 800d584:	2300      	movne	r3, #0
 800d586:	2301      	moveq	r3, #1
 800d588:	b2db      	uxtb	r3, r3
 800d58a:	201b      	movs	r0, #27
 800d58c:	4619      	mov	r1, r3
 800d58e:	f7fd fe8f 	bl	800b2b0 <_test_assert>
 800d592:	4603      	mov	r3, r0
 800d594:	2b00      	cmp	r3, #0
 800d596:	d000      	beq.n	800d59a <mbox1_execute+0x4aa>
 800d598:	e1b1      	b.n	800d8fe <mbox1_execute+0x80e>
  for (i = 0; i < MB_SIZE; i++) {
 800d59a:	2300      	movs	r3, #0
 800d59c:	9303      	str	r3, [sp, #12]
 800d59e:	e01f      	b.n	800d5e0 <mbox1_execute+0x4f0>
    chSysLock();
 800d5a0:	f7ff fd5e 	bl	800d060 <chSysLock>
    msg1 = chMBFetchI(&mb1, &msg2);
 800d5a4:	ab01      	add	r3, sp, #4
 800d5a6:	482a      	ldr	r0, [pc, #168]	; (800d650 <mbox1_execute+0x560>)
 800d5a8:	4619      	mov	r1, r3
 800d5aa:	f7f5 fd39 	bl	8003020 <chMBFetchI>
 800d5ae:	9002      	str	r0, [sp, #8]
    chSysUnlock();
 800d5b0:	f7ff fd5e 	bl	800d070 <chSysUnlock>
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
 800d5b4:	9b02      	ldr	r3, [sp, #8]
 800d5b6:	2b00      	cmp	r3, #0
 800d5b8:	bf14      	ite	ne
 800d5ba:	2300      	movne	r3, #0
 800d5bc:	2301      	moveq	r3, #1
 800d5be:	b2db      	uxtb	r3, r3
 800d5c0:	201c      	movs	r0, #28
 800d5c2:	4619      	mov	r1, r3
 800d5c4:	f7fd fe74 	bl	800b2b0 <_test_assert>
 800d5c8:	4603      	mov	r3, r0
 800d5ca:	2b00      	cmp	r3, #0
 800d5cc:	d000      	beq.n	800d5d0 <mbox1_execute+0x4e0>
 800d5ce:	e196      	b.n	800d8fe <mbox1_execute+0x80e>
    test_emit_token(msg2);
 800d5d0:	9b01      	ldr	r3, [sp, #4]
 800d5d2:	b2db      	uxtb	r3, r3
 800d5d4:	4618      	mov	r0, r3
 800d5d6:	f7fd fe3b 	bl	800b250 <test_emit_token>
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
  msg1 = chMBPostI(&mb1, 'E');
  chSysUnlock();
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
 800d5da:	9b03      	ldr	r3, [sp, #12]
 800d5dc:	3301      	adds	r3, #1
 800d5de:	9303      	str	r3, [sp, #12]
 800d5e0:	9b03      	ldr	r3, [sp, #12]
 800d5e2:	2b04      	cmp	r3, #4
 800d5e4:	d9dc      	bls.n	800d5a0 <mbox1_execute+0x4b0>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(29, "ABCDE");
 800d5e6:	201d      	movs	r0, #29
 800d5e8:	491a      	ldr	r1, [pc, #104]	; (800d654 <mbox1_execute+0x564>)
 800d5ea:	f7fd fe79 	bl	800b2e0 <_test_assert_sequence>
 800d5ee:	4603      	mov	r3, r0
 800d5f0:	2b00      	cmp	r3, #0
 800d5f2:	d000      	beq.n	800d5f6 <mbox1_execute+0x506>
 800d5f4:	e183      	b.n	800d8fe <mbox1_execute+0x80e>
  test_assert_lock(30, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800d5f6:	f7ff fd33 	bl	800d060 <chSysLock>
 800d5fa:	4815      	ldr	r0, [pc, #84]	; (800d650 <mbox1_execute+0x560>)
 800d5fc:	f7ff fd48 	bl	800d090 <chMBGetFreeCountI>
 800d600:	4603      	mov	r3, r0
 800d602:	2b05      	cmp	r3, #5
 800d604:	bf14      	ite	ne
 800d606:	2300      	movne	r3, #0
 800d608:	2301      	moveq	r3, #1
 800d60a:	b2db      	uxtb	r3, r3
 800d60c:	201e      	movs	r0, #30
 800d60e:	4619      	mov	r1, r3
 800d610:	f7fd fe4e 	bl	800b2b0 <_test_assert>
 800d614:	4603      	mov	r3, r0
 800d616:	2b00      	cmp	r3, #0
 800d618:	d002      	beq.n	800d620 <mbox1_execute+0x530>
 800d61a:	f7ff fd29 	bl	800d070 <chSysUnlock>
 800d61e:	e16e      	b.n	800d8fe <mbox1_execute+0x80e>
 800d620:	f7ff fd26 	bl	800d070 <chSysUnlock>
  test_assert_lock(31, chMBGetUsedCountI(&mb1) == 0, "still full");
 800d624:	f7ff fd1c 	bl	800d060 <chSysLock>
 800d628:	4809      	ldr	r0, [pc, #36]	; (800d650 <mbox1_execute+0x560>)
 800d62a:	f7ff fd41 	bl	800d0b0 <chMBGetUsedCountI>
 800d62e:	4603      	mov	r3, r0
 800d630:	2b00      	cmp	r3, #0
 800d632:	bf14      	ite	ne
 800d634:	2300      	movne	r3, #0
 800d636:	2301      	moveq	r3, #1
 800d638:	b2db      	uxtb	r3, r3
 800d63a:	201f      	movs	r0, #31
 800d63c:	4619      	mov	r1, r3
 800d63e:	f7fd fe37 	bl	800b2b0 <_test_assert>
 800d642:	4603      	mov	r3, r0
 800d644:	2b00      	cmp	r3, #0
 800d646:	d007      	beq.n	800d658 <mbox1_execute+0x568>
 800d648:	f7ff fd12 	bl	800d070 <chSysUnlock>
 800d64c:	e157      	b.n	800d8fe <mbox1_execute+0x80e>
 800d64e:	bf00      	nop
 800d650:	2000086c 	.word	0x2000086c
 800d654:	08016770 	.word	0x08016770
 800d658:	f7ff fd0a 	bl	800d070 <chSysUnlock>
  test_assert(32, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800d65c:	4ba9      	ldr	r3, [pc, #676]	; (800d904 <mbox1_execute+0x814>)
 800d65e:	68da      	ldr	r2, [r3, #12]
 800d660:	4ba8      	ldr	r3, [pc, #672]	; (800d904 <mbox1_execute+0x814>)
 800d662:	689b      	ldr	r3, [r3, #8]
 800d664:	429a      	cmp	r2, r3
 800d666:	bf14      	ite	ne
 800d668:	2300      	movne	r3, #0
 800d66a:	2301      	moveq	r3, #1
 800d66c:	b2db      	uxtb	r3, r3
 800d66e:	2020      	movs	r0, #32
 800d670:	4619      	mov	r1, r3
 800d672:	f7fd fe1d 	bl	800b2b0 <_test_assert>
 800d676:	4603      	mov	r3, r0
 800d678:	2b00      	cmp	r3, #0
 800d67a:	d000      	beq.n	800d67e <mbox1_execute+0x58e>
 800d67c:	e13f      	b.n	800d8fe <mbox1_execute+0x80e>

  chSysLock();
 800d67e:	f7ff fcef 	bl	800d060 <chSysLock>
  msg1 = chMBPostAheadI(&mb1, 'E');
 800d682:	48a0      	ldr	r0, [pc, #640]	; (800d904 <mbox1_execute+0x814>)
 800d684:	2145      	movs	r1, #69	; 0x45
 800d686:	f7f5 fc4b 	bl	8002f20 <chMBPostAheadI>
 800d68a:	9002      	str	r0, [sp, #8]
  test_assert(33, msg1 == MSG_OK, "wrong wake-up message");
 800d68c:	9b02      	ldr	r3, [sp, #8]
 800d68e:	2b00      	cmp	r3, #0
 800d690:	bf14      	ite	ne
 800d692:	2300      	movne	r3, #0
 800d694:	2301      	moveq	r3, #1
 800d696:	b2db      	uxtb	r3, r3
 800d698:	2021      	movs	r0, #33	; 0x21
 800d69a:	4619      	mov	r1, r3
 800d69c:	f7fd fe08 	bl	800b2b0 <_test_assert>
 800d6a0:	4603      	mov	r3, r0
 800d6a2:	2b00      	cmp	r3, #0
 800d6a4:	d000      	beq.n	800d6a8 <mbox1_execute+0x5b8>
 800d6a6:	e12a      	b.n	800d8fe <mbox1_execute+0x80e>
  msg1 = chMBPostAheadI(&mb1, 'D');
 800d6a8:	4896      	ldr	r0, [pc, #600]	; (800d904 <mbox1_execute+0x814>)
 800d6aa:	2144      	movs	r1, #68	; 0x44
 800d6ac:	f7f5 fc38 	bl	8002f20 <chMBPostAheadI>
 800d6b0:	9002      	str	r0, [sp, #8]
  test_assert(34, msg1 == MSG_OK, "wrong wake-up message");
 800d6b2:	9b02      	ldr	r3, [sp, #8]
 800d6b4:	2b00      	cmp	r3, #0
 800d6b6:	bf14      	ite	ne
 800d6b8:	2300      	movne	r3, #0
 800d6ba:	2301      	moveq	r3, #1
 800d6bc:	b2db      	uxtb	r3, r3
 800d6be:	2022      	movs	r0, #34	; 0x22
 800d6c0:	4619      	mov	r1, r3
 800d6c2:	f7fd fdf5 	bl	800b2b0 <_test_assert>
 800d6c6:	4603      	mov	r3, r0
 800d6c8:	2b00      	cmp	r3, #0
 800d6ca:	d000      	beq.n	800d6ce <mbox1_execute+0x5de>
 800d6cc:	e117      	b.n	800d8fe <mbox1_execute+0x80e>
  msg1 = chMBPostAheadI(&mb1, 'C');
 800d6ce:	488d      	ldr	r0, [pc, #564]	; (800d904 <mbox1_execute+0x814>)
 800d6d0:	2143      	movs	r1, #67	; 0x43
 800d6d2:	f7f5 fc25 	bl	8002f20 <chMBPostAheadI>
 800d6d6:	9002      	str	r0, [sp, #8]
  test_assert(35, msg1 == MSG_OK, "wrong wake-up message");
 800d6d8:	9b02      	ldr	r3, [sp, #8]
 800d6da:	2b00      	cmp	r3, #0
 800d6dc:	bf14      	ite	ne
 800d6de:	2300      	movne	r3, #0
 800d6e0:	2301      	moveq	r3, #1
 800d6e2:	b2db      	uxtb	r3, r3
 800d6e4:	2023      	movs	r0, #35	; 0x23
 800d6e6:	4619      	mov	r1, r3
 800d6e8:	f7fd fde2 	bl	800b2b0 <_test_assert>
 800d6ec:	4603      	mov	r3, r0
 800d6ee:	2b00      	cmp	r3, #0
 800d6f0:	d000      	beq.n	800d6f4 <mbox1_execute+0x604>
 800d6f2:	e104      	b.n	800d8fe <mbox1_execute+0x80e>
  msg1 = chMBPostAheadI(&mb1, 'B');
 800d6f4:	4883      	ldr	r0, [pc, #524]	; (800d904 <mbox1_execute+0x814>)
 800d6f6:	2142      	movs	r1, #66	; 0x42
 800d6f8:	f7f5 fc12 	bl	8002f20 <chMBPostAheadI>
 800d6fc:	9002      	str	r0, [sp, #8]
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
 800d6fe:	9b02      	ldr	r3, [sp, #8]
 800d700:	2b00      	cmp	r3, #0
 800d702:	bf14      	ite	ne
 800d704:	2300      	movne	r3, #0
 800d706:	2301      	moveq	r3, #1
 800d708:	b2db      	uxtb	r3, r3
 800d70a:	2024      	movs	r0, #36	; 0x24
 800d70c:	4619      	mov	r1, r3
 800d70e:	f7fd fdcf 	bl	800b2b0 <_test_assert>
 800d712:	4603      	mov	r3, r0
 800d714:	2b00      	cmp	r3, #0
 800d716:	d000      	beq.n	800d71a <mbox1_execute+0x62a>
 800d718:	e0f1      	b.n	800d8fe <mbox1_execute+0x80e>
  msg1 = chMBPostAheadI(&mb1, 'A');
 800d71a:	487a      	ldr	r0, [pc, #488]	; (800d904 <mbox1_execute+0x814>)
 800d71c:	2141      	movs	r1, #65	; 0x41
 800d71e:	f7f5 fbff 	bl	8002f20 <chMBPostAheadI>
 800d722:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 800d724:	f7ff fca4 	bl	800d070 <chSysUnlock>
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
 800d728:	9b02      	ldr	r3, [sp, #8]
 800d72a:	2b00      	cmp	r3, #0
 800d72c:	bf14      	ite	ne
 800d72e:	2300      	movne	r3, #0
 800d730:	2301      	moveq	r3, #1
 800d732:	b2db      	uxtb	r3, r3
 800d734:	2025      	movs	r0, #37	; 0x25
 800d736:	4619      	mov	r1, r3
 800d738:	f7fd fdba 	bl	800b2b0 <_test_assert>
 800d73c:	4603      	mov	r3, r0
 800d73e:	2b00      	cmp	r3, #0
 800d740:	d000      	beq.n	800d744 <mbox1_execute+0x654>
 800d742:	e0dc      	b.n	800d8fe <mbox1_execute+0x80e>
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800d744:	4b6f      	ldr	r3, [pc, #444]	; (800d904 <mbox1_execute+0x814>)
 800d746:	68da      	ldr	r2, [r3, #12]
 800d748:	4b6e      	ldr	r3, [pc, #440]	; (800d904 <mbox1_execute+0x814>)
 800d74a:	689b      	ldr	r3, [r3, #8]
 800d74c:	429a      	cmp	r2, r3
 800d74e:	bf14      	ite	ne
 800d750:	2300      	movne	r3, #0
 800d752:	2301      	moveq	r3, #1
 800d754:	b2db      	uxtb	r3, r3
 800d756:	2026      	movs	r0, #38	; 0x26
 800d758:	4619      	mov	r1, r3
 800d75a:	f7fd fda9 	bl	800b2b0 <_test_assert>
 800d75e:	4603      	mov	r3, r0
 800d760:	2b00      	cmp	r3, #0
 800d762:	d000      	beq.n	800d766 <mbox1_execute+0x676>
 800d764:	e0cb      	b.n	800d8fe <mbox1_execute+0x80e>
  for (i = 0; i < MB_SIZE; i++) {
 800d766:	2300      	movs	r3, #0
 800d768:	9303      	str	r3, [sp, #12]
 800d76a:	e01f      	b.n	800d7ac <mbox1_execute+0x6bc>
    chSysLock();
 800d76c:	f7ff fc78 	bl	800d060 <chSysLock>
    msg1 = chMBFetchI(&mb1, &msg2);
 800d770:	ab01      	add	r3, sp, #4
 800d772:	4864      	ldr	r0, [pc, #400]	; (800d904 <mbox1_execute+0x814>)
 800d774:	4619      	mov	r1, r3
 800d776:	f7f5 fc53 	bl	8003020 <chMBFetchI>
 800d77a:	9002      	str	r0, [sp, #8]
    chSysUnlock();
 800d77c:	f7ff fc78 	bl	800d070 <chSysUnlock>
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
 800d780:	9b02      	ldr	r3, [sp, #8]
 800d782:	2b00      	cmp	r3, #0
 800d784:	bf14      	ite	ne
 800d786:	2300      	movne	r3, #0
 800d788:	2301      	moveq	r3, #1
 800d78a:	b2db      	uxtb	r3, r3
 800d78c:	2027      	movs	r0, #39	; 0x27
 800d78e:	4619      	mov	r1, r3
 800d790:	f7fd fd8e 	bl	800b2b0 <_test_assert>
 800d794:	4603      	mov	r3, r0
 800d796:	2b00      	cmp	r3, #0
 800d798:	d000      	beq.n	800d79c <mbox1_execute+0x6ac>
 800d79a:	e0b0      	b.n	800d8fe <mbox1_execute+0x80e>
    test_emit_token(msg2);
 800d79c:	9b01      	ldr	r3, [sp, #4]
 800d79e:	b2db      	uxtb	r3, r3
 800d7a0:	4618      	mov	r0, r3
 800d7a2:	f7fd fd55 	bl	800b250 <test_emit_token>
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
  msg1 = chMBPostAheadI(&mb1, 'A');
  chSysUnlock();
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
 800d7a6:	9b03      	ldr	r3, [sp, #12]
 800d7a8:	3301      	adds	r3, #1
 800d7aa:	9303      	str	r3, [sp, #12]
 800d7ac:	9b03      	ldr	r3, [sp, #12]
 800d7ae:	2b04      	cmp	r3, #4
 800d7b0:	d9dc      	bls.n	800d76c <mbox1_execute+0x67c>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(40, "ABCDE");
 800d7b2:	2028      	movs	r0, #40	; 0x28
 800d7b4:	4954      	ldr	r1, [pc, #336]	; (800d908 <mbox1_execute+0x818>)
 800d7b6:	f7fd fd93 	bl	800b2e0 <_test_assert_sequence>
 800d7ba:	4603      	mov	r3, r0
 800d7bc:	2b00      	cmp	r3, #0
 800d7be:	d000      	beq.n	800d7c2 <mbox1_execute+0x6d2>
 800d7c0:	e09d      	b.n	800d8fe <mbox1_execute+0x80e>
  test_assert_lock(41, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800d7c2:	f7ff fc4d 	bl	800d060 <chSysLock>
 800d7c6:	484f      	ldr	r0, [pc, #316]	; (800d904 <mbox1_execute+0x814>)
 800d7c8:	f7ff fc62 	bl	800d090 <chMBGetFreeCountI>
 800d7cc:	4603      	mov	r3, r0
 800d7ce:	2b05      	cmp	r3, #5
 800d7d0:	bf14      	ite	ne
 800d7d2:	2300      	movne	r3, #0
 800d7d4:	2301      	moveq	r3, #1
 800d7d6:	b2db      	uxtb	r3, r3
 800d7d8:	2029      	movs	r0, #41	; 0x29
 800d7da:	4619      	mov	r1, r3
 800d7dc:	f7fd fd68 	bl	800b2b0 <_test_assert>
 800d7e0:	4603      	mov	r3, r0
 800d7e2:	2b00      	cmp	r3, #0
 800d7e4:	d002      	beq.n	800d7ec <mbox1_execute+0x6fc>
 800d7e6:	f7ff fc43 	bl	800d070 <chSysUnlock>
 800d7ea:	e088      	b.n	800d8fe <mbox1_execute+0x80e>
 800d7ec:	f7ff fc40 	bl	800d070 <chSysUnlock>
  test_assert_lock(42, chMBGetUsedCountI(&mb1) == 0, "still full");
 800d7f0:	f7ff fc36 	bl	800d060 <chSysLock>
 800d7f4:	4843      	ldr	r0, [pc, #268]	; (800d904 <mbox1_execute+0x814>)
 800d7f6:	f7ff fc5b 	bl	800d0b0 <chMBGetUsedCountI>
 800d7fa:	4603      	mov	r3, r0
 800d7fc:	2b00      	cmp	r3, #0
 800d7fe:	bf14      	ite	ne
 800d800:	2300      	movne	r3, #0
 800d802:	2301      	moveq	r3, #1
 800d804:	b2db      	uxtb	r3, r3
 800d806:	202a      	movs	r0, #42	; 0x2a
 800d808:	4619      	mov	r1, r3
 800d80a:	f7fd fd51 	bl	800b2b0 <_test_assert>
 800d80e:	4603      	mov	r3, r0
 800d810:	2b00      	cmp	r3, #0
 800d812:	d002      	beq.n	800d81a <mbox1_execute+0x72a>
 800d814:	f7ff fc2c 	bl	800d070 <chSysUnlock>
 800d818:	e071      	b.n	800d8fe <mbox1_execute+0x80e>
 800d81a:	f7ff fc29 	bl	800d070 <chSysUnlock>
  test_assert(43, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800d81e:	4b39      	ldr	r3, [pc, #228]	; (800d904 <mbox1_execute+0x814>)
 800d820:	68da      	ldr	r2, [r3, #12]
 800d822:	4b38      	ldr	r3, [pc, #224]	; (800d904 <mbox1_execute+0x814>)
 800d824:	689b      	ldr	r3, [r3, #8]
 800d826:	429a      	cmp	r2, r3
 800d828:	bf14      	ite	ne
 800d82a:	2300      	movne	r3, #0
 800d82c:	2301      	moveq	r3, #1
 800d82e:	b2db      	uxtb	r3, r3
 800d830:	202b      	movs	r0, #43	; 0x2b
 800d832:	4619      	mov	r1, r3
 800d834:	f7fd fd3c 	bl	800b2b0 <_test_assert>
 800d838:	4603      	mov	r3, r0
 800d83a:	2b00      	cmp	r3, #0
 800d83c:	d000      	beq.n	800d840 <mbox1_execute+0x750>
 800d83e:	e05e      	b.n	800d8fe <mbox1_execute+0x80e>

  /*
   * Testing reset.
   */
  chMBReset(&mb1);
 800d840:	4830      	ldr	r0, [pc, #192]	; (800d904 <mbox1_execute+0x814>)
 800d842:	f7f5 fa75 	bl	8002d30 <chMBReset>

  /*
   * Re-testing final conditions.
   */
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800d846:	f7ff fc0b 	bl	800d060 <chSysLock>
 800d84a:	482e      	ldr	r0, [pc, #184]	; (800d904 <mbox1_execute+0x814>)
 800d84c:	f7ff fc20 	bl	800d090 <chMBGetFreeCountI>
 800d850:	4603      	mov	r3, r0
 800d852:	2b05      	cmp	r3, #5
 800d854:	bf14      	ite	ne
 800d856:	2300      	movne	r3, #0
 800d858:	2301      	moveq	r3, #1
 800d85a:	b2db      	uxtb	r3, r3
 800d85c:	202c      	movs	r0, #44	; 0x2c
 800d85e:	4619      	mov	r1, r3
 800d860:	f7fd fd26 	bl	800b2b0 <_test_assert>
 800d864:	4603      	mov	r3, r0
 800d866:	2b00      	cmp	r3, #0
 800d868:	d002      	beq.n	800d870 <mbox1_execute+0x780>
 800d86a:	f7ff fc01 	bl	800d070 <chSysUnlock>
 800d86e:	e046      	b.n	800d8fe <mbox1_execute+0x80e>
 800d870:	f7ff fbfe 	bl	800d070 <chSysUnlock>
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
 800d874:	f7ff fbf4 	bl	800d060 <chSysLock>
 800d878:	4822      	ldr	r0, [pc, #136]	; (800d904 <mbox1_execute+0x814>)
 800d87a:	f7ff fc19 	bl	800d0b0 <chMBGetUsedCountI>
 800d87e:	4603      	mov	r3, r0
 800d880:	2b00      	cmp	r3, #0
 800d882:	bf14      	ite	ne
 800d884:	2300      	movne	r3, #0
 800d886:	2301      	moveq	r3, #1
 800d888:	b2db      	uxtb	r3, r3
 800d88a:	202d      	movs	r0, #45	; 0x2d
 800d88c:	4619      	mov	r1, r3
 800d88e:	f7fd fd0f 	bl	800b2b0 <_test_assert>
 800d892:	4603      	mov	r3, r0
 800d894:	2b00      	cmp	r3, #0
 800d896:	d002      	beq.n	800d89e <mbox1_execute+0x7ae>
 800d898:	f7ff fbea 	bl	800d070 <chSysUnlock>
 800d89c:	e02f      	b.n	800d8fe <mbox1_execute+0x80e>
 800d89e:	f7ff fbe7 	bl	800d070 <chSysUnlock>
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 800d8a2:	f7ff fbdd 	bl	800d060 <chSysLock>
 800d8a6:	4b17      	ldr	r3, [pc, #92]	; (800d904 <mbox1_execute+0x814>)
 800d8a8:	681a      	ldr	r2, [r3, #0]
 800d8aa:	4b16      	ldr	r3, [pc, #88]	; (800d904 <mbox1_execute+0x814>)
 800d8ac:	689b      	ldr	r3, [r3, #8]
 800d8ae:	429a      	cmp	r2, r3
 800d8b0:	bf14      	ite	ne
 800d8b2:	2300      	movne	r3, #0
 800d8b4:	2301      	moveq	r3, #1
 800d8b6:	b2db      	uxtb	r3, r3
 800d8b8:	202e      	movs	r0, #46	; 0x2e
 800d8ba:	4619      	mov	r1, r3
 800d8bc:	f7fd fcf8 	bl	800b2b0 <_test_assert>
 800d8c0:	4603      	mov	r3, r0
 800d8c2:	2b00      	cmp	r3, #0
 800d8c4:	d002      	beq.n	800d8cc <mbox1_execute+0x7dc>
 800d8c6:	f7ff fbd3 	bl	800d070 <chSysUnlock>
 800d8ca:	e018      	b.n	800d8fe <mbox1_execute+0x80e>
 800d8cc:	f7ff fbd0 	bl	800d070 <chSysUnlock>
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 800d8d0:	f7ff fbc6 	bl	800d060 <chSysLock>
 800d8d4:	4b0b      	ldr	r3, [pc, #44]	; (800d904 <mbox1_execute+0x814>)
 800d8d6:	681a      	ldr	r2, [r3, #0]
 800d8d8:	4b0a      	ldr	r3, [pc, #40]	; (800d904 <mbox1_execute+0x814>)
 800d8da:	68db      	ldr	r3, [r3, #12]
 800d8dc:	429a      	cmp	r2, r3
 800d8de:	bf14      	ite	ne
 800d8e0:	2300      	movne	r3, #0
 800d8e2:	2301      	moveq	r3, #1
 800d8e4:	b2db      	uxtb	r3, r3
 800d8e6:	202f      	movs	r0, #47	; 0x2f
 800d8e8:	4619      	mov	r1, r3
 800d8ea:	f7fd fce1 	bl	800b2b0 <_test_assert>
 800d8ee:	4603      	mov	r3, r0
 800d8f0:	2b00      	cmp	r3, #0
 800d8f2:	d002      	beq.n	800d8fa <mbox1_execute+0x80a>
 800d8f4:	f7ff fbbc 	bl	800d070 <chSysUnlock>
 800d8f8:	e001      	b.n	800d8fe <mbox1_execute+0x80e>
 800d8fa:	f7ff fbb9 	bl	800d070 <chSysUnlock>
}
 800d8fe:	b005      	add	sp, #20
 800d900:	f85d fb04 	ldr.w	pc, [sp], #4
 800d904:	2000086c 	.word	0x2000086c
 800d908:	08016770 	.word	0x08016770
 800d90c:	f3af 8000 	nop.w

0800d910 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800d910:	b082      	sub	sp, #8
 800d912:	2320      	movs	r3, #32
 800d914:	9301      	str	r3, [sp, #4]
 800d916:	9b01      	ldr	r3, [sp, #4]
 800d918:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800d91c:	b002      	add	sp, #8
 800d91e:	4770      	bx	lr

0800d920 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800d920:	b082      	sub	sp, #8
 800d922:	2300      	movs	r3, #0
 800d924:	9301      	str	r3, [sp, #4]
 800d926:	9b01      	ldr	r3, [sp, #4]
 800d928:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800d92c:	b002      	add	sp, #8
 800d92e:	4770      	bx	lr

0800d930 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800d930:	b508      	push	{r3, lr}

  port_lock();
 800d932:	f7ff ffed 	bl	800d910 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800d936:	bd08      	pop	{r3, pc}
 800d938:	f3af 8000 	nop.w
 800d93c:	f3af 8000 	nop.w

0800d940 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800d940:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800d942:	f7ff ffed 	bl	800d920 <port_unlock>
}
 800d946:	bd08      	pop	{r3, pc}
 800d948:	f3af 8000 	nop.w
 800d94c:	f3af 8000 	nop.w

0800d950 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 800d950:	4b01      	ldr	r3, [pc, #4]	; (800d958 <chVTGetSystemTimeX+0x8>)
 800d952:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800d954:	4618      	mov	r0, r3
 800d956:	4770      	bx	lr
 800d958:	20000d98 	.word	0x20000d98
 800d95c:	f3af 8000 	nop.w

0800d960 <chVTGetSystemTime>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 800d960:	b500      	push	{lr}
 800d962:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 800d964:	f7ff ffe4 	bl	800d930 <chSysLock>
  systime = chVTGetSystemTimeX();
 800d968:	f7ff fff2 	bl	800d950 <chVTGetSystemTimeX>
 800d96c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 800d96e:	f7ff ffe7 	bl	800d940 <chSysUnlock>

  return systime;
 800d972:	9b01      	ldr	r3, [sp, #4]
}
 800d974:	4618      	mov	r0, r3
 800d976:	b003      	add	sp, #12
 800d978:	f85d fb04 	ldr.w	pc, [sp], #4
 800d97c:	f3af 8000 	nop.w

0800d980 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800d980:	4b01      	ldr	r3, [pc, #4]	; (800d988 <chThdGetSelfX+0x8>)
 800d982:	699b      	ldr	r3, [r3, #24]
}
 800d984:	4618      	mov	r0, r3
 800d986:	4770      	bx	lr
 800d988:	20000d98 	.word	0x20000d98
 800d98c:	f3af 8000 	nop.w

0800d990 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800d990:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800d992:	f7ff fff5 	bl	800d980 <chThdGetSelfX>
 800d996:	4603      	mov	r3, r0
 800d998:	689b      	ldr	r3, [r3, #8]
}
 800d99a:	4618      	mov	r0, r3
 800d99c:	bd08      	pop	{r3, pc}
 800d99e:	bf00      	nop

0800d9a0 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 800d9a0:	b082      	sub	sp, #8
 800d9a2:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 800d9a4:	9b01      	ldr	r3, [sp, #4]
 800d9a6:	9a01      	ldr	r2, [sp, #4]
 800d9a8:	601a      	str	r2, [r3, #0]
}
 800d9aa:	b002      	add	sp, #8
 800d9ac:	4770      	bx	lr
 800d9ae:	bf00      	nop

0800d9b0 <chEvtRegisterMask>:
 *
 * @api
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventmask_t events) {
 800d9b0:	b500      	push	{lr}
 800d9b2:	b085      	sub	sp, #20
 800d9b4:	9003      	str	r0, [sp, #12]
 800d9b6:	9102      	str	r1, [sp, #8]
 800d9b8:	9201      	str	r2, [sp, #4]

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 800d9ba:	9803      	ldr	r0, [sp, #12]
 800d9bc:	9902      	ldr	r1, [sp, #8]
 800d9be:	9a01      	ldr	r2, [sp, #4]
 800d9c0:	f04f 33ff 	mov.w	r3, #4294967295
 800d9c4:	f7f4 fdd4 	bl	8002570 <chEvtRegisterMaskWithFlags>
}
 800d9c8:	b005      	add	sp, #20
 800d9ca:	f85d fb04 	ldr.w	pc, [sp], #4
 800d9ce:	bf00      	nop

0800d9d0 <chEvtIsListeningI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @return              The event source status.
 *
 * @iclass
 */
static inline bool chEvtIsListeningI(event_source_t *esp) {
 800d9d0:	b082      	sub	sp, #8
 800d9d2:	9001      	str	r0, [sp, #4]

  return (bool)(esp != (event_source_t *)esp->es_next);
 800d9d4:	9b01      	ldr	r3, [sp, #4]
 800d9d6:	681a      	ldr	r2, [r3, #0]
 800d9d8:	9b01      	ldr	r3, [sp, #4]
 800d9da:	429a      	cmp	r2, r3
 800d9dc:	bf0c      	ite	eq
 800d9de:	2300      	moveq	r3, #0
 800d9e0:	2301      	movne	r3, #1
 800d9e2:	b2db      	uxtb	r3, r3
}
 800d9e4:	4618      	mov	r0, r3
 800d9e6:	b002      	add	sp, #8
 800d9e8:	4770      	bx	lr
 800d9ea:	bf00      	nop
 800d9ec:	f3af 8000 	nop.w

0800d9f0 <chEvtBroadcast>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @api
 */
static inline void chEvtBroadcast(event_source_t *esp) {
 800d9f0:	b500      	push	{lr}
 800d9f2:	b083      	sub	sp, #12
 800d9f4:	9001      	str	r0, [sp, #4]

  chEvtBroadcastFlags(esp, (eventflags_t)0);
 800d9f6:	9801      	ldr	r0, [sp, #4]
 800d9f8:	2100      	movs	r1, #0
 800d9fa:	f7f4 fed1 	bl	80027a0 <chEvtBroadcastFlags>
}
 800d9fe:	b003      	add	sp, #12
 800da00:	f85d fb04 	ldr.w	pc, [sp], #4
 800da04:	f3af 8000 	nop.w
 800da08:	f3af 8000 	nop.w
 800da0c:	f3af 8000 	nop.w

0800da10 <evt1_setup>:
 * the test expects no more listeners.<br>
 * In the second part the test dispatches three event flags and verifies that
 * the associated event handlers are invoked in LSb-first order.
 */

static void evt1_setup(void) {
 800da10:	b508      	push	{r3, lr}

  chEvtGetAndClearEvents(ALL_EVENTS);
 800da12:	f04f 30ff 	mov.w	r0, #4294967295
 800da16:	f7f4 fdf3 	bl	8002600 <chEvtGetAndClearEvents>
}
 800da1a:	bd08      	pop	{r3, pc}
 800da1c:	f3af 8000 	nop.w

0800da20 <h1>:

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
 800da20:	b500      	push	{lr}
 800da22:	b083      	sub	sp, #12
 800da24:	9001      	str	r0, [sp, #4]
 800da26:	2041      	movs	r0, #65	; 0x41
 800da28:	f7fd fc12 	bl	800b250 <test_emit_token>
 800da2c:	b003      	add	sp, #12
 800da2e:	f85d fb04 	ldr.w	pc, [sp], #4
 800da32:	bf00      	nop
 800da34:	f3af 8000 	nop.w
 800da38:	f3af 8000 	nop.w
 800da3c:	f3af 8000 	nop.w

0800da40 <h2>:
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
 800da40:	b500      	push	{lr}
 800da42:	b083      	sub	sp, #12
 800da44:	9001      	str	r0, [sp, #4]
 800da46:	2042      	movs	r0, #66	; 0x42
 800da48:	f7fd fc02 	bl	800b250 <test_emit_token>
 800da4c:	b003      	add	sp, #12
 800da4e:	f85d fb04 	ldr.w	pc, [sp], #4
 800da52:	bf00      	nop
 800da54:	f3af 8000 	nop.w
 800da58:	f3af 8000 	nop.w
 800da5c:	f3af 8000 	nop.w

0800da60 <h3>:
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
 800da60:	b500      	push	{lr}
 800da62:	b083      	sub	sp, #12
 800da64:	9001      	str	r0, [sp, #4]
 800da66:	2043      	movs	r0, #67	; 0x43
 800da68:	f7fd fbf2 	bl	800b250 <test_emit_token>
 800da6c:	b003      	add	sp, #12
 800da6e:	f85d fb04 	ldr.w	pc, [sp], #4
 800da72:	bf00      	nop
 800da74:	f3af 8000 	nop.w
 800da78:	f3af 8000 	nop.w
 800da7c:	f3af 8000 	nop.w

0800da80 <evt1_execute>:
static ROMCONST evhandler_t evhndl[] = {h1, h2, h3};

static void evt1_execute(void) {
 800da80:	b500      	push	{lr}
 800da82:	b08b      	sub	sp, #44	; 0x2c
  event_listener_t el1, el2;

  /*
   * Testing chEvtRegisterMask() and chEvtUnregister().
   */
  chEvtObjectInit(&es1);
 800da84:	482b      	ldr	r0, [pc, #172]	; (800db34 <evt1_execute+0xb4>)
 800da86:	f7ff ff8b 	bl	800d9a0 <chEvtObjectInit>
  chEvtRegisterMask(&es1, &el1, 1);
 800da8a:	ab05      	add	r3, sp, #20
 800da8c:	4829      	ldr	r0, [pc, #164]	; (800db34 <evt1_execute+0xb4>)
 800da8e:	4619      	mov	r1, r3
 800da90:	2201      	movs	r2, #1
 800da92:	f7ff ff8d 	bl	800d9b0 <chEvtRegisterMask>
  chEvtRegisterMask(&es1, &el2, 2);
 800da96:	466b      	mov	r3, sp
 800da98:	4826      	ldr	r0, [pc, #152]	; (800db34 <evt1_execute+0xb4>)
 800da9a:	4619      	mov	r1, r3
 800da9c:	2202      	movs	r2, #2
 800da9e:	f7ff ff87 	bl	800d9b0 <chEvtRegisterMask>
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
 800daa2:	4824      	ldr	r0, [pc, #144]	; (800db34 <evt1_execute+0xb4>)
 800daa4:	f7ff ff94 	bl	800d9d0 <chEvtIsListeningI>
 800daa8:	4603      	mov	r3, r0
 800daaa:	2001      	movs	r0, #1
 800daac:	4619      	mov	r1, r3
 800daae:	f7fd fbff 	bl	800b2b0 <_test_assert>
 800dab2:	4603      	mov	r3, r0
 800dab4:	2b00      	cmp	r3, #0
 800dab6:	d000      	beq.n	800daba <evt1_execute+0x3a>
 800dab8:	e038      	b.n	800db2c <evt1_execute+0xac>
  chEvtUnregister(&es1, &el1);
 800daba:	ab05      	add	r3, sp, #20
 800dabc:	481d      	ldr	r0, [pc, #116]	; (800db34 <evt1_execute+0xb4>)
 800dabe:	4619      	mov	r1, r3
 800dac0:	f7f4 fd7e 	bl	80025c0 <chEvtUnregister>
  test_assert(2, chEvtIsListeningI(&es1), "no listener");
 800dac4:	481b      	ldr	r0, [pc, #108]	; (800db34 <evt1_execute+0xb4>)
 800dac6:	f7ff ff83 	bl	800d9d0 <chEvtIsListeningI>
 800daca:	4603      	mov	r3, r0
 800dacc:	2002      	movs	r0, #2
 800dace:	4619      	mov	r1, r3
 800dad0:	f7fd fbee 	bl	800b2b0 <_test_assert>
 800dad4:	4603      	mov	r3, r0
 800dad6:	2b00      	cmp	r3, #0
 800dad8:	d000      	beq.n	800dadc <evt1_execute+0x5c>
 800dada:	e027      	b.n	800db2c <evt1_execute+0xac>
  chEvtUnregister(&es1, &el2);
 800dadc:	466b      	mov	r3, sp
 800dade:	4815      	ldr	r0, [pc, #84]	; (800db34 <evt1_execute+0xb4>)
 800dae0:	4619      	mov	r1, r3
 800dae2:	f7f4 fd6d 	bl	80025c0 <chEvtUnregister>
  test_assert(3, !chEvtIsListeningI(&es1), "stuck listener");
 800dae6:	4813      	ldr	r0, [pc, #76]	; (800db34 <evt1_execute+0xb4>)
 800dae8:	f7ff ff72 	bl	800d9d0 <chEvtIsListeningI>
 800daec:	4603      	mov	r3, r0
 800daee:	2b00      	cmp	r3, #0
 800daf0:	bf0c      	ite	eq
 800daf2:	2300      	moveq	r3, #0
 800daf4:	2301      	movne	r3, #1
 800daf6:	b2db      	uxtb	r3, r3
 800daf8:	f083 0301 	eor.w	r3, r3, #1
 800dafc:	b2db      	uxtb	r3, r3
 800dafe:	f003 0301 	and.w	r3, r3, #1
 800db02:	b2db      	uxtb	r3, r3
 800db04:	2003      	movs	r0, #3
 800db06:	4619      	mov	r1, r3
 800db08:	f7fd fbd2 	bl	800b2b0 <_test_assert>
 800db0c:	4603      	mov	r3, r0
 800db0e:	2b00      	cmp	r3, #0
 800db10:	d000      	beq.n	800db14 <evt1_execute+0x94>
 800db12:	e00b      	b.n	800db2c <evt1_execute+0xac>

  /*
   * Testing chEvtDispatch().
   */
  chEvtDispatch(evhndl, 7);
 800db14:	4808      	ldr	r0, [pc, #32]	; (800db38 <evt1_execute+0xb8>)
 800db16:	2107      	movs	r1, #7
 800db18:	f7f4 fe6a 	bl	80027f0 <chEvtDispatch>
  test_assert_sequence(4, "ABC");
 800db1c:	2004      	movs	r0, #4
 800db1e:	4907      	ldr	r1, [pc, #28]	; (800db3c <evt1_execute+0xbc>)
 800db20:	f7fd fbde 	bl	800b2e0 <_test_assert_sequence>
 800db24:	4603      	mov	r3, r0
 800db26:	2b00      	cmp	r3, #0
 800db28:	d000      	beq.n	800db2c <evt1_execute+0xac>
 800db2a:	bf00      	nop
}
 800db2c:	b00b      	add	sp, #44	; 0x2c
 800db2e:	f85d fb04 	ldr.w	pc, [sp], #4
 800db32:	bf00      	nop
 800db34:	20000894 	.word	0x20000894
 800db38:	080167b0 	.word	0x080167b0
 800db3c:	080167bc 	.word	0x080167bc

0800db40 <evt2_setup>:
 * .
 * After each test phase the test verifies that the events have been served at
 * the expected time and that there are no stuck event flags.
 */

static void evt2_setup(void) {
 800db40:	b508      	push	{r3, lr}

  chEvtGetAndClearEvents(ALL_EVENTS);
 800db42:	f04f 30ff 	mov.w	r0, #4294967295
 800db46:	f7f4 fd5b 	bl	8002600 <chEvtGetAndClearEvents>
}
 800db4a:	bd08      	pop	{r3, pc}
 800db4c:	f3af 8000 	nop.w

0800db50 <thread1>:

static THD_FUNCTION(thread1, p) {
 800db50:	b500      	push	{lr}
 800db52:	b083      	sub	sp, #12
 800db54:	9001      	str	r0, [sp, #4]

  chThdSleepMilliseconds(50);
 800db56:	2032      	movs	r0, #50	; 0x32
 800db58:	f7f3 fbba 	bl	80012d0 <chThdSleep>
  chEvtSignal((thread_t *)p, 1);
 800db5c:	9801      	ldr	r0, [sp, #4]
 800db5e:	2101      	movs	r1, #1
 800db60:	f7f4 fdd6 	bl	8002710 <chEvtSignal>
}
 800db64:	b003      	add	sp, #12
 800db66:	f85d fb04 	ldr.w	pc, [sp], #4
 800db6a:	bf00      	nop
 800db6c:	f3af 8000 	nop.w

0800db70 <thread2>:

static THD_FUNCTION(thread2, p) {
 800db70:	b500      	push	{lr}
 800db72:	b083      	sub	sp, #12
 800db74:	9001      	str	r0, [sp, #4]

  (void)p;
  chEvtBroadcast(&es1);
 800db76:	4806      	ldr	r0, [pc, #24]	; (800db90 <thread2+0x20>)
 800db78:	f7ff ff3a 	bl	800d9f0 <chEvtBroadcast>
  chThdSleepMilliseconds(50);
 800db7c:	2032      	movs	r0, #50	; 0x32
 800db7e:	f7f3 fba7 	bl	80012d0 <chThdSleep>
  chEvtBroadcast(&es2);
 800db82:	4804      	ldr	r0, [pc, #16]	; (800db94 <thread2+0x24>)
 800db84:	f7ff ff34 	bl	800d9f0 <chEvtBroadcast>
}
 800db88:	b003      	add	sp, #12
 800db8a:	f85d fb04 	ldr.w	pc, [sp], #4
 800db8e:	bf00      	nop
 800db90:	20000894 	.word	0x20000894
 800db94:	20000898 	.word	0x20000898
 800db98:	f3af 8000 	nop.w
 800db9c:	f3af 8000 	nop.w

0800dba0 <evt2_execute>:

static void evt2_execute(void) {
 800dba0:	b530      	push	{r4, r5, lr}
 800dba2:	b08f      	sub	sp, #60	; 0x3c
  systime_t target_time;

  /*
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(7);
 800dba4:	2007      	movs	r0, #7
 800dba6:	f7f4 fd4b 	bl	8002640 <chEvtAddEvents>
  m = chEvtWaitOne(ALL_EVENTS);
 800dbaa:	f04f 30ff 	mov.w	r0, #4294967295
 800dbae:	f7f4 fe47 	bl	8002840 <chEvtWaitOne>
 800dbb2:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(1, m == 1, "single event error");
 800dbb4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800dbb6:	2b01      	cmp	r3, #1
 800dbb8:	bf14      	ite	ne
 800dbba:	2300      	movne	r3, #0
 800dbbc:	2301      	moveq	r3, #1
 800dbbe:	b2db      	uxtb	r3, r3
 800dbc0:	2001      	movs	r0, #1
 800dbc2:	4619      	mov	r1, r3
 800dbc4:	f7fd fb74 	bl	800b2b0 <_test_assert>
 800dbc8:	4603      	mov	r3, r0
 800dbca:	2b00      	cmp	r3, #0
 800dbcc:	d000      	beq.n	800dbd0 <evt2_execute+0x30>
 800dbce:	e184      	b.n	800deda <evt2_execute+0x33a>
  m = chEvtWaitOne(ALL_EVENTS);
 800dbd0:	f04f 30ff 	mov.w	r0, #4294967295
 800dbd4:	f7f4 fe34 	bl	8002840 <chEvtWaitOne>
 800dbd8:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(2, m == 2, "single event error");
 800dbda:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800dbdc:	2b02      	cmp	r3, #2
 800dbde:	bf14      	ite	ne
 800dbe0:	2300      	movne	r3, #0
 800dbe2:	2301      	moveq	r3, #1
 800dbe4:	b2db      	uxtb	r3, r3
 800dbe6:	2002      	movs	r0, #2
 800dbe8:	4619      	mov	r1, r3
 800dbea:	f7fd fb61 	bl	800b2b0 <_test_assert>
 800dbee:	4603      	mov	r3, r0
 800dbf0:	2b00      	cmp	r3, #0
 800dbf2:	d000      	beq.n	800dbf6 <evt2_execute+0x56>
 800dbf4:	e171      	b.n	800deda <evt2_execute+0x33a>
  m = chEvtWaitOne(ALL_EVENTS);
 800dbf6:	f04f 30ff 	mov.w	r0, #4294967295
 800dbfa:	f7f4 fe21 	bl	8002840 <chEvtWaitOne>
 800dbfe:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(3, m == 4, "single event error");
 800dc00:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800dc02:	2b04      	cmp	r3, #4
 800dc04:	bf14      	ite	ne
 800dc06:	2300      	movne	r3, #0
 800dc08:	2301      	moveq	r3, #1
 800dc0a:	b2db      	uxtb	r3, r3
 800dc0c:	2003      	movs	r0, #3
 800dc0e:	4619      	mov	r1, r3
 800dc10:	f7fd fb4e 	bl	800b2b0 <_test_assert>
 800dc14:	4603      	mov	r3, r0
 800dc16:	2b00      	cmp	r3, #0
 800dc18:	d000      	beq.n	800dc1c <evt2_execute+0x7c>
 800dc1a:	e15e      	b.n	800deda <evt2_execute+0x33a>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800dc1c:	f04f 30ff 	mov.w	r0, #4294967295
 800dc20:	f7f4 fcee 	bl	8002600 <chEvtGetAndClearEvents>
 800dc24:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(4, m == 0, "stuck event");
 800dc26:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800dc28:	2b00      	cmp	r3, #0
 800dc2a:	bf14      	ite	ne
 800dc2c:	2300      	movne	r3, #0
 800dc2e:	2301      	moveq	r3, #1
 800dc30:	b2db      	uxtb	r3, r3
 800dc32:	2004      	movs	r0, #4
 800dc34:	4619      	mov	r1, r3
 800dc36:	f7fd fb3b 	bl	800b2b0 <_test_assert>
 800dc3a:	4603      	mov	r3, r0
 800dc3c:	2b00      	cmp	r3, #0
 800dc3e:	d000      	beq.n	800dc42 <evt2_execute+0xa2>
 800dc40:	e14b      	b.n	800deda <evt2_execute+0x33a>

  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
 800dc42:	f7fd fbdd 	bl	800b400 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(50);
 800dc46:	f7ff fe8b 	bl	800d960 <chVTGetSystemTime>
 800dc4a:	4603      	mov	r3, r0
 800dc4c:	3332      	adds	r3, #50	; 0x32
 800dc4e:	930c      	str	r3, [sp, #48]	; 0x30
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800dc50:	4ba3      	ldr	r3, [pc, #652]	; (800dee0 <evt2_execute+0x340>)
 800dc52:	681d      	ldr	r5, [r3, #0]
 800dc54:	f7ff fe9c 	bl	800d990 <chThdGetPriorityX>
 800dc58:	4603      	mov	r3, r0
 800dc5a:	1e5c      	subs	r4, r3, #1
                                 thread1, chThdGetSelfX());
 800dc5c:	f7ff fe90 	bl	800d980 <chThdGetSelfX>
 800dc60:	4603      	mov	r3, r0
  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800dc62:	9300      	str	r3, [sp, #0]
 800dc64:	4628      	mov	r0, r5
 800dc66:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800dc6a:	4622      	mov	r2, r4
 800dc6c:	4b9d      	ldr	r3, [pc, #628]	; (800dee4 <evt2_execute+0x344>)
 800dc6e:	f7f3 fab7 	bl	80011e0 <chThdCreateStatic>
 800dc72:	4602      	mov	r2, r0
 800dc74:	4b9c      	ldr	r3, [pc, #624]	; (800dee8 <evt2_execute+0x348>)
 800dc76:	601a      	str	r2, [r3, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitOne(ALL_EVENTS);
 800dc78:	f04f 30ff 	mov.w	r0, #4294967295
 800dc7c:	f7f4 fde0 	bl	8002840 <chEvtWaitOne>
 800dc80:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert_time_window(5, target_time, target_time + ALLOWED_DELAY);
 800dc82:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800dc84:	3305      	adds	r3, #5
 800dc86:	2005      	movs	r0, #5
 800dc88:	990c      	ldr	r1, [sp, #48]	; 0x30
 800dc8a:	461a      	mov	r2, r3
 800dc8c:	f7fd fb58 	bl	800b340 <_test_assert_time_window>
 800dc90:	4603      	mov	r3, r0
 800dc92:	2b00      	cmp	r3, #0
 800dc94:	d000      	beq.n	800dc98 <evt2_execute+0xf8>
 800dc96:	e120      	b.n	800deda <evt2_execute+0x33a>
  test_assert(6, m == 1, "single event error");
 800dc98:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800dc9a:	2b01      	cmp	r3, #1
 800dc9c:	bf14      	ite	ne
 800dc9e:	2300      	movne	r3, #0
 800dca0:	2301      	moveq	r3, #1
 800dca2:	b2db      	uxtb	r3, r3
 800dca4:	2006      	movs	r0, #6
 800dca6:	4619      	mov	r1, r3
 800dca8:	f7fd fb02 	bl	800b2b0 <_test_assert>
 800dcac:	4603      	mov	r3, r0
 800dcae:	2b00      	cmp	r3, #0
 800dcb0:	d000      	beq.n	800dcb4 <evt2_execute+0x114>
 800dcb2:	e112      	b.n	800deda <evt2_execute+0x33a>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800dcb4:	f04f 30ff 	mov.w	r0, #4294967295
 800dcb8:	f7f4 fca2 	bl	8002600 <chEvtGetAndClearEvents>
 800dcbc:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(7, m == 0, "stuck event");
 800dcbe:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800dcc0:	2b00      	cmp	r3, #0
 800dcc2:	bf14      	ite	ne
 800dcc4:	2300      	movne	r3, #0
 800dcc6:	2301      	moveq	r3, #1
 800dcc8:	b2db      	uxtb	r3, r3
 800dcca:	2007      	movs	r0, #7
 800dccc:	4619      	mov	r1, r3
 800dcce:	f7fd faef 	bl	800b2b0 <_test_assert>
 800dcd2:	4603      	mov	r3, r0
 800dcd4:	2b00      	cmp	r3, #0
 800dcd6:	d000      	beq.n	800dcda <evt2_execute+0x13a>
 800dcd8:	e0ff      	b.n	800deda <evt2_execute+0x33a>
  test_wait_threads();
 800dcda:	f7fd fb69 	bl	800b3b0 <test_wait_threads>

  /*
   * Test on chEvtWaitAny() without wait.
   */
  chEvtAddEvents(5);
 800dcde:	2005      	movs	r0, #5
 800dce0:	f7f4 fcae 	bl	8002640 <chEvtAddEvents>
  m = chEvtWaitAny(ALL_EVENTS);
 800dce4:	f04f 30ff 	mov.w	r0, #4294967295
 800dce8:	f7f4 fdda 	bl	80028a0 <chEvtWaitAny>
 800dcec:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(8, m == 5, "unexpected pending bit");
 800dcee:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800dcf0:	2b05      	cmp	r3, #5
 800dcf2:	bf14      	ite	ne
 800dcf4:	2300      	movne	r3, #0
 800dcf6:	2301      	moveq	r3, #1
 800dcf8:	b2db      	uxtb	r3, r3
 800dcfa:	2008      	movs	r0, #8
 800dcfc:	4619      	mov	r1, r3
 800dcfe:	f7fd fad7 	bl	800b2b0 <_test_assert>
 800dd02:	4603      	mov	r3, r0
 800dd04:	2b00      	cmp	r3, #0
 800dd06:	d000      	beq.n	800dd0a <evt2_execute+0x16a>
 800dd08:	e0e7      	b.n	800deda <evt2_execute+0x33a>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800dd0a:	f04f 30ff 	mov.w	r0, #4294967295
 800dd0e:	f7f4 fc77 	bl	8002600 <chEvtGetAndClearEvents>
 800dd12:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(9, m == 0, "stuck event");
 800dd14:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800dd16:	2b00      	cmp	r3, #0
 800dd18:	bf14      	ite	ne
 800dd1a:	2300      	movne	r3, #0
 800dd1c:	2301      	moveq	r3, #1
 800dd1e:	b2db      	uxtb	r3, r3
 800dd20:	2009      	movs	r0, #9
 800dd22:	4619      	mov	r1, r3
 800dd24:	f7fd fac4 	bl	800b2b0 <_test_assert>
 800dd28:	4603      	mov	r3, r0
 800dd2a:	2b00      	cmp	r3, #0
 800dd2c:	d000      	beq.n	800dd30 <evt2_execute+0x190>
 800dd2e:	e0d4      	b.n	800deda <evt2_execute+0x33a>

  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
 800dd30:	f7fd fb66 	bl	800b400 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(50);
 800dd34:	f7ff fe14 	bl	800d960 <chVTGetSystemTime>
 800dd38:	4603      	mov	r3, r0
 800dd3a:	3332      	adds	r3, #50	; 0x32
 800dd3c:	930c      	str	r3, [sp, #48]	; 0x30
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800dd3e:	4b68      	ldr	r3, [pc, #416]	; (800dee0 <evt2_execute+0x340>)
 800dd40:	681d      	ldr	r5, [r3, #0]
 800dd42:	f7ff fe25 	bl	800d990 <chThdGetPriorityX>
 800dd46:	4603      	mov	r3, r0
 800dd48:	1e5c      	subs	r4, r3, #1
                                 thread1, chThdGetSelfX());
 800dd4a:	f7ff fe19 	bl	800d980 <chThdGetSelfX>
 800dd4e:	4603      	mov	r3, r0
  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800dd50:	9300      	str	r3, [sp, #0]
 800dd52:	4628      	mov	r0, r5
 800dd54:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800dd58:	4622      	mov	r2, r4
 800dd5a:	4b62      	ldr	r3, [pc, #392]	; (800dee4 <evt2_execute+0x344>)
 800dd5c:	f7f3 fa40 	bl	80011e0 <chThdCreateStatic>
 800dd60:	4602      	mov	r2, r0
 800dd62:	4b61      	ldr	r3, [pc, #388]	; (800dee8 <evt2_execute+0x348>)
 800dd64:	601a      	str	r2, [r3, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitAny(ALL_EVENTS);
 800dd66:	f04f 30ff 	mov.w	r0, #4294967295
 800dd6a:	f7f4 fd99 	bl	80028a0 <chEvtWaitAny>
 800dd6e:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert_time_window(10, target_time, target_time + ALLOWED_DELAY);
 800dd70:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800dd72:	3305      	adds	r3, #5
 800dd74:	200a      	movs	r0, #10
 800dd76:	990c      	ldr	r1, [sp, #48]	; 0x30
 800dd78:	461a      	mov	r2, r3
 800dd7a:	f7fd fae1 	bl	800b340 <_test_assert_time_window>
 800dd7e:	4603      	mov	r3, r0
 800dd80:	2b00      	cmp	r3, #0
 800dd82:	d000      	beq.n	800dd86 <evt2_execute+0x1e6>
 800dd84:	e0a9      	b.n	800deda <evt2_execute+0x33a>
  test_assert(11, m == 1, "single event error");
 800dd86:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800dd88:	2b01      	cmp	r3, #1
 800dd8a:	bf14      	ite	ne
 800dd8c:	2300      	movne	r3, #0
 800dd8e:	2301      	moveq	r3, #1
 800dd90:	b2db      	uxtb	r3, r3
 800dd92:	200b      	movs	r0, #11
 800dd94:	4619      	mov	r1, r3
 800dd96:	f7fd fa8b 	bl	800b2b0 <_test_assert>
 800dd9a:	4603      	mov	r3, r0
 800dd9c:	2b00      	cmp	r3, #0
 800dd9e:	d000      	beq.n	800dda2 <evt2_execute+0x202>
 800dda0:	e09b      	b.n	800deda <evt2_execute+0x33a>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800dda2:	f04f 30ff 	mov.w	r0, #4294967295
 800dda6:	f7f4 fc2b 	bl	8002600 <chEvtGetAndClearEvents>
 800ddaa:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(12, m == 0, "stuck event");
 800ddac:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800ddae:	2b00      	cmp	r3, #0
 800ddb0:	bf14      	ite	ne
 800ddb2:	2300      	movne	r3, #0
 800ddb4:	2301      	moveq	r3, #1
 800ddb6:	b2db      	uxtb	r3, r3
 800ddb8:	200c      	movs	r0, #12
 800ddba:	4619      	mov	r1, r3
 800ddbc:	f7fd fa78 	bl	800b2b0 <_test_assert>
 800ddc0:	4603      	mov	r3, r0
 800ddc2:	2b00      	cmp	r3, #0
 800ddc4:	d000      	beq.n	800ddc8 <evt2_execute+0x228>
 800ddc6:	e088      	b.n	800deda <evt2_execute+0x33a>
  test_wait_threads();
 800ddc8:	f7fd faf2 	bl	800b3b0 <test_wait_threads>

  /*
   * Test on chEvtWaitAll().
   */
  chEvtObjectInit(&es1);
 800ddcc:	4847      	ldr	r0, [pc, #284]	; (800deec <evt2_execute+0x34c>)
 800ddce:	f7ff fde7 	bl	800d9a0 <chEvtObjectInit>
  chEvtObjectInit(&es2);
 800ddd2:	4847      	ldr	r0, [pc, #284]	; (800def0 <evt2_execute+0x350>)
 800ddd4:	f7ff fde4 	bl	800d9a0 <chEvtObjectInit>
  chEvtRegisterMask(&es1, &el1, 1);
 800ddd8:	ab07      	add	r3, sp, #28
 800ddda:	4844      	ldr	r0, [pc, #272]	; (800deec <evt2_execute+0x34c>)
 800dddc:	4619      	mov	r1, r3
 800ddde:	2201      	movs	r2, #1
 800dde0:	f7ff fde6 	bl	800d9b0 <chEvtRegisterMask>
  chEvtRegisterMask(&es2, &el2, 4);
 800dde4:	ab02      	add	r3, sp, #8
 800dde6:	4842      	ldr	r0, [pc, #264]	; (800def0 <evt2_execute+0x350>)
 800dde8:	4619      	mov	r1, r3
 800ddea:	2204      	movs	r2, #4
 800ddec:	f7ff fde0 	bl	800d9b0 <chEvtRegisterMask>
  test_wait_tick();
 800ddf0:	f7fd fb06 	bl	800b400 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(50);
 800ddf4:	f7ff fdb4 	bl	800d960 <chVTGetSystemTime>
 800ddf8:	4603      	mov	r3, r0
 800ddfa:	3332      	adds	r3, #50	; 0x32
 800ddfc:	930c      	str	r3, [sp, #48]	; 0x30
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800ddfe:	4b38      	ldr	r3, [pc, #224]	; (800dee0 <evt2_execute+0x340>)
 800de00:	681c      	ldr	r4, [r3, #0]
 800de02:	f7ff fdc5 	bl	800d990 <chThdGetPriorityX>
 800de06:	4603      	mov	r3, r0
 800de08:	3b01      	subs	r3, #1
 800de0a:	4a3a      	ldr	r2, [pc, #232]	; (800def4 <evt2_execute+0x354>)
 800de0c:	9200      	str	r2, [sp, #0]
 800de0e:	4620      	mov	r0, r4
 800de10:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800de14:	461a      	mov	r2, r3
 800de16:	4b38      	ldr	r3, [pc, #224]	; (800def8 <evt2_execute+0x358>)
 800de18:	f7f3 f9e2 	bl	80011e0 <chThdCreateStatic>
 800de1c:	4602      	mov	r2, r0
 800de1e:	4b32      	ldr	r3, [pc, #200]	; (800dee8 <evt2_execute+0x348>)
 800de20:	601a      	str	r2, [r3, #0]
                                 thread2, "A");
  m = chEvtWaitAll(5);
 800de22:	2005      	movs	r0, #5
 800de24:	f7f4 fd6c 	bl	8002900 <chEvtWaitAll>
 800de28:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert_time_window(13, target_time, target_time + ALLOWED_DELAY);
 800de2a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800de2c:	3305      	adds	r3, #5
 800de2e:	200d      	movs	r0, #13
 800de30:	990c      	ldr	r1, [sp, #48]	; 0x30
 800de32:	461a      	mov	r2, r3
 800de34:	f7fd fa84 	bl	800b340 <_test_assert_time_window>
 800de38:	4603      	mov	r3, r0
 800de3a:	2b00      	cmp	r3, #0
 800de3c:	d000      	beq.n	800de40 <evt2_execute+0x2a0>
 800de3e:	e04c      	b.n	800deda <evt2_execute+0x33a>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800de40:	f04f 30ff 	mov.w	r0, #4294967295
 800de44:	f7f4 fbdc 	bl	8002600 <chEvtGetAndClearEvents>
 800de48:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(14, m == 0, "stuck event");
 800de4a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800de4c:	2b00      	cmp	r3, #0
 800de4e:	bf14      	ite	ne
 800de50:	2300      	movne	r3, #0
 800de52:	2301      	moveq	r3, #1
 800de54:	b2db      	uxtb	r3, r3
 800de56:	200e      	movs	r0, #14
 800de58:	4619      	mov	r1, r3
 800de5a:	f7fd fa29 	bl	800b2b0 <_test_assert>
 800de5e:	4603      	mov	r3, r0
 800de60:	2b00      	cmp	r3, #0
 800de62:	d000      	beq.n	800de66 <evt2_execute+0x2c6>
 800de64:	e039      	b.n	800deda <evt2_execute+0x33a>
  test_wait_threads();
 800de66:	f7fd faa3 	bl	800b3b0 <test_wait_threads>
  chEvtUnregister(&es1, &el1);
 800de6a:	ab07      	add	r3, sp, #28
 800de6c:	481f      	ldr	r0, [pc, #124]	; (800deec <evt2_execute+0x34c>)
 800de6e:	4619      	mov	r1, r3
 800de70:	f7f4 fba6 	bl	80025c0 <chEvtUnregister>
  chEvtUnregister(&es2, &el2);
 800de74:	ab02      	add	r3, sp, #8
 800de76:	481e      	ldr	r0, [pc, #120]	; (800def0 <evt2_execute+0x350>)
 800de78:	4619      	mov	r1, r3
 800de7a:	f7f4 fba1 	bl	80025c0 <chEvtUnregister>
  test_assert(15, !chEvtIsListeningI(&es1), "stuck listener");
 800de7e:	481b      	ldr	r0, [pc, #108]	; (800deec <evt2_execute+0x34c>)
 800de80:	f7ff fda6 	bl	800d9d0 <chEvtIsListeningI>
 800de84:	4603      	mov	r3, r0
 800de86:	2b00      	cmp	r3, #0
 800de88:	bf0c      	ite	eq
 800de8a:	2300      	moveq	r3, #0
 800de8c:	2301      	movne	r3, #1
 800de8e:	b2db      	uxtb	r3, r3
 800de90:	f083 0301 	eor.w	r3, r3, #1
 800de94:	b2db      	uxtb	r3, r3
 800de96:	f003 0301 	and.w	r3, r3, #1
 800de9a:	b2db      	uxtb	r3, r3
 800de9c:	200f      	movs	r0, #15
 800de9e:	4619      	mov	r1, r3
 800dea0:	f7fd fa06 	bl	800b2b0 <_test_assert>
 800dea4:	4603      	mov	r3, r0
 800dea6:	2b00      	cmp	r3, #0
 800dea8:	d000      	beq.n	800deac <evt2_execute+0x30c>
 800deaa:	e016      	b.n	800deda <evt2_execute+0x33a>
  test_assert(16, !chEvtIsListeningI(&es2), "stuck listener");
 800deac:	4810      	ldr	r0, [pc, #64]	; (800def0 <evt2_execute+0x350>)
 800deae:	f7ff fd8f 	bl	800d9d0 <chEvtIsListeningI>
 800deb2:	4603      	mov	r3, r0
 800deb4:	2b00      	cmp	r3, #0
 800deb6:	bf0c      	ite	eq
 800deb8:	2300      	moveq	r3, #0
 800deba:	2301      	movne	r3, #1
 800debc:	b2db      	uxtb	r3, r3
 800debe:	f083 0301 	eor.w	r3, r3, #1
 800dec2:	b2db      	uxtb	r3, r3
 800dec4:	f003 0301 	and.w	r3, r3, #1
 800dec8:	b2db      	uxtb	r3, r3
 800deca:	2010      	movs	r0, #16
 800decc:	4619      	mov	r1, r3
 800dece:	f7fd f9ef 	bl	800b2b0 <_test_assert>
 800ded2:	4603      	mov	r3, r0
 800ded4:	2b00      	cmp	r3, #0
 800ded6:	d000      	beq.n	800deda <evt2_execute+0x33a>
 800ded8:	bf00      	nop
}
 800deda:	b00f      	add	sp, #60	; 0x3c
 800dedc:	bd30      	pop	{r4, r5, pc}
 800dede:	bf00      	nop
 800dee0:	08016240 	.word	0x08016240
 800dee4:	0800db51 	.word	0x0800db51
 800dee8:	20001224 	.word	0x20001224
 800deec:	20000894 	.word	0x20000894
 800def0:	20000898 	.word	0x20000898
 800def4:	080167f4 	.word	0x080167f4
 800def8:	0800db71 	.word	0x0800db71
 800defc:	f3af 8000 	nop.w

0800df00 <evt3_setup>:
 * - @p chEvtWaitAllTimeout()
 * .
 * After each test phase the test verifies that there are no stuck event flags.
 */

static void evt3_setup(void) {
 800df00:	b508      	push	{r3, lr}

  chEvtGetAndClearEvents(ALL_EVENTS);
 800df02:	f04f 30ff 	mov.w	r0, #4294967295
 800df06:	f7f4 fb7b 	bl	8002600 <chEvtGetAndClearEvents>
}
 800df0a:	bd08      	pop	{r3, pc}
 800df0c:	f3af 8000 	nop.w

0800df10 <evt3_execute>:

static void evt3_execute(void) {
 800df10:	b500      	push	{lr}
 800df12:	b083      	sub	sp, #12
  eventmask_t m;

  /*
   * Tests various timeout situations.
   */
  m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 800df14:	f04f 30ff 	mov.w	r0, #4294967295
 800df18:	2100      	movs	r1, #0
 800df1a:	f7f4 fd19 	bl	8002950 <chEvtWaitOneTimeout>
 800df1e:	9001      	str	r0, [sp, #4]
  test_assert(1, m == 0, "spurious event");
 800df20:	9b01      	ldr	r3, [sp, #4]
 800df22:	2b00      	cmp	r3, #0
 800df24:	bf14      	ite	ne
 800df26:	2300      	movne	r3, #0
 800df28:	2301      	moveq	r3, #1
 800df2a:	b2db      	uxtb	r3, r3
 800df2c:	2001      	movs	r0, #1
 800df2e:	4619      	mov	r1, r3
 800df30:	f7fd f9be 	bl	800b2b0 <_test_assert>
 800df34:	4603      	mov	r3, r0
 800df36:	2b00      	cmp	r3, #0
 800df38:	d000      	beq.n	800df3c <evt3_execute+0x2c>
 800df3a:	e063      	b.n	800e004 <evt3_execute+0xf4>
  m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 800df3c:	f04f 30ff 	mov.w	r0, #4294967295
 800df40:	2100      	movs	r1, #0
 800df42:	f7f4 fd45 	bl	80029d0 <chEvtWaitAnyTimeout>
 800df46:	9001      	str	r0, [sp, #4]
  test_assert(2, m == 0, "spurious event");
 800df48:	9b01      	ldr	r3, [sp, #4]
 800df4a:	2b00      	cmp	r3, #0
 800df4c:	bf14      	ite	ne
 800df4e:	2300      	movne	r3, #0
 800df50:	2301      	moveq	r3, #1
 800df52:	b2db      	uxtb	r3, r3
 800df54:	2002      	movs	r0, #2
 800df56:	4619      	mov	r1, r3
 800df58:	f7fd f9aa 	bl	800b2b0 <_test_assert>
 800df5c:	4603      	mov	r3, r0
 800df5e:	2b00      	cmp	r3, #0
 800df60:	d000      	beq.n	800df64 <evt3_execute+0x54>
 800df62:	e04f      	b.n	800e004 <evt3_execute+0xf4>
  m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 800df64:	f04f 30ff 	mov.w	r0, #4294967295
 800df68:	2100      	movs	r1, #0
 800df6a:	f7f4 fd71 	bl	8002a50 <chEvtWaitAllTimeout>
 800df6e:	9001      	str	r0, [sp, #4]
  test_assert(3, m == 0, "spurious event");
 800df70:	9b01      	ldr	r3, [sp, #4]
 800df72:	2b00      	cmp	r3, #0
 800df74:	bf14      	ite	ne
 800df76:	2300      	movne	r3, #0
 800df78:	2301      	moveq	r3, #1
 800df7a:	b2db      	uxtb	r3, r3
 800df7c:	2003      	movs	r0, #3
 800df7e:	4619      	mov	r1, r3
 800df80:	f7fd f996 	bl	800b2b0 <_test_assert>
 800df84:	4603      	mov	r3, r0
 800df86:	2b00      	cmp	r3, #0
 800df88:	d000      	beq.n	800df8c <evt3_execute+0x7c>
 800df8a:	e03b      	b.n	800e004 <evt3_execute+0xf4>
  m = chEvtWaitOneTimeout(ALL_EVENTS, 10);
 800df8c:	f04f 30ff 	mov.w	r0, #4294967295
 800df90:	210a      	movs	r1, #10
 800df92:	f7f4 fcdd 	bl	8002950 <chEvtWaitOneTimeout>
 800df96:	9001      	str	r0, [sp, #4]
  test_assert(4, m == 0, "spurious event");
 800df98:	9b01      	ldr	r3, [sp, #4]
 800df9a:	2b00      	cmp	r3, #0
 800df9c:	bf14      	ite	ne
 800df9e:	2300      	movne	r3, #0
 800dfa0:	2301      	moveq	r3, #1
 800dfa2:	b2db      	uxtb	r3, r3
 800dfa4:	2004      	movs	r0, #4
 800dfa6:	4619      	mov	r1, r3
 800dfa8:	f7fd f982 	bl	800b2b0 <_test_assert>
 800dfac:	4603      	mov	r3, r0
 800dfae:	2b00      	cmp	r3, #0
 800dfb0:	d000      	beq.n	800dfb4 <evt3_execute+0xa4>
 800dfb2:	e027      	b.n	800e004 <evt3_execute+0xf4>
  m = chEvtWaitAnyTimeout(ALL_EVENTS, 10);
 800dfb4:	f04f 30ff 	mov.w	r0, #4294967295
 800dfb8:	210a      	movs	r1, #10
 800dfba:	f7f4 fd09 	bl	80029d0 <chEvtWaitAnyTimeout>
 800dfbe:	9001      	str	r0, [sp, #4]
  test_assert(5, m == 0, "spurious event");
 800dfc0:	9b01      	ldr	r3, [sp, #4]
 800dfc2:	2b00      	cmp	r3, #0
 800dfc4:	bf14      	ite	ne
 800dfc6:	2300      	movne	r3, #0
 800dfc8:	2301      	moveq	r3, #1
 800dfca:	b2db      	uxtb	r3, r3
 800dfcc:	2005      	movs	r0, #5
 800dfce:	4619      	mov	r1, r3
 800dfd0:	f7fd f96e 	bl	800b2b0 <_test_assert>
 800dfd4:	4603      	mov	r3, r0
 800dfd6:	2b00      	cmp	r3, #0
 800dfd8:	d000      	beq.n	800dfdc <evt3_execute+0xcc>
 800dfda:	e013      	b.n	800e004 <evt3_execute+0xf4>
  m = chEvtWaitAllTimeout(ALL_EVENTS, 10);
 800dfdc:	f04f 30ff 	mov.w	r0, #4294967295
 800dfe0:	210a      	movs	r1, #10
 800dfe2:	f7f4 fd35 	bl	8002a50 <chEvtWaitAllTimeout>
 800dfe6:	9001      	str	r0, [sp, #4]
  test_assert(6, m == 0, "spurious event");
 800dfe8:	9b01      	ldr	r3, [sp, #4]
 800dfea:	2b00      	cmp	r3, #0
 800dfec:	bf14      	ite	ne
 800dfee:	2300      	movne	r3, #0
 800dff0:	2301      	moveq	r3, #1
 800dff2:	b2db      	uxtb	r3, r3
 800dff4:	2006      	movs	r0, #6
 800dff6:	4619      	mov	r1, r3
 800dff8:	f7fd f95a 	bl	800b2b0 <_test_assert>
 800dffc:	4603      	mov	r3, r0
 800dffe:	2b00      	cmp	r3, #0
 800e000:	d000      	beq.n	800e004 <evt3_execute+0xf4>
 800e002:	bf00      	nop
}
 800e004:	b003      	add	sp, #12
 800e006:	f85d fb04 	ldr.w	pc, [sp], #4
 800e00a:	bf00      	nop
 800e00c:	f3af 8000 	nop.w

0800e010 <heap1_setup>:
 * allocator.<br>
 * The test expects to find the heap back to the initial status after each
 * sequence.
 */

static void heap1_setup(void) {
 800e010:	b508      	push	{r3, lr}

  chHeapObjectInit(&test_heap, test.buffer, sizeof(union test_buffers));
 800e012:	4803      	ldr	r0, [pc, #12]	; (800e020 <heap1_setup+0x10>)
 800e014:	4903      	ldr	r1, [pc, #12]	; (800e024 <heap1_setup+0x14>)
 800e016:	f44f 62cd 	mov.w	r2, #1640	; 0x668
 800e01a:	f7f5 fb81 	bl	8003720 <chHeapObjectInit>
}
 800e01e:	bd08      	pop	{r3, pc}
 800e020:	20000b80 	.word	0x20000b80
 800e024:	20001238 	.word	0x20001238
 800e028:	f3af 8000 	nop.w
 800e02c:	f3af 8000 	nop.w

0800e030 <heap1_execute>:

static void heap1_execute(void) {
 800e030:	b500      	push	{lr}
 800e032:	b087      	sub	sp, #28
  void *p1, *p2, *p3;
  size_t n, sz;

  /* Unrelated, for coverage only.*/
  (void)chCoreGetStatusX();
 800e034:	f7f5 fb4c 	bl	80036d0 <chCoreGetStatusX>

  /*
   * Test on the default heap in order to cover the core allocator at
   * least one time.
   */
  (void)chHeapStatus(NULL, &sz);
 800e038:	ab01      	add	r3, sp, #4
 800e03a:	2000      	movs	r0, #0
 800e03c:	4619      	mov	r1, r3
 800e03e:	f7f5 fc6f 	bl	8003920 <chHeapStatus>
  p1 = chHeapAlloc(NULL, SIZE);
 800e042:	2000      	movs	r0, #0
 800e044:	2110      	movs	r1, #16
 800e046:	f7f5 fb8b 	bl	8003760 <chHeapAlloc>
 800e04a:	9005      	str	r0, [sp, #20]
  test_assert(1, p1 != NULL, "allocation failed");
 800e04c:	9b05      	ldr	r3, [sp, #20]
 800e04e:	2b00      	cmp	r3, #0
 800e050:	bf0c      	ite	eq
 800e052:	2300      	moveq	r3, #0
 800e054:	2301      	movne	r3, #1
 800e056:	b2db      	uxtb	r3, r3
 800e058:	2001      	movs	r0, #1
 800e05a:	4619      	mov	r1, r3
 800e05c:	f7fd f928 	bl	800b2b0 <_test_assert>
 800e060:	4603      	mov	r3, r0
 800e062:	2b00      	cmp	r3, #0
 800e064:	d000      	beq.n	800e068 <heap1_execute+0x38>
 800e066:	e14e      	b.n	800e306 <heap1_execute+0x2d6>
  chHeapFree(p1);
 800e068:	9805      	ldr	r0, [sp, #20]
 800e06a:	f7f5 fbf1 	bl	8003850 <chHeapFree>
  p1 = chHeapAlloc(NULL, (size_t)-256);
 800e06e:	2000      	movs	r0, #0
 800e070:	f06f 01ff 	mvn.w	r1, #255	; 0xff
 800e074:	f7f5 fb74 	bl	8003760 <chHeapAlloc>
 800e078:	9005      	str	r0, [sp, #20]
  test_assert(2, p1 == NULL, "allocation not failed");
 800e07a:	9b05      	ldr	r3, [sp, #20]
 800e07c:	2b00      	cmp	r3, #0
 800e07e:	bf14      	ite	ne
 800e080:	2300      	movne	r3, #0
 800e082:	2301      	moveq	r3, #1
 800e084:	b2db      	uxtb	r3, r3
 800e086:	2002      	movs	r0, #2
 800e088:	4619      	mov	r1, r3
 800e08a:	f7fd f911 	bl	800b2b0 <_test_assert>
 800e08e:	4603      	mov	r3, r0
 800e090:	2b00      	cmp	r3, #0
 800e092:	d000      	beq.n	800e096 <heap1_execute+0x66>
 800e094:	e137      	b.n	800e306 <heap1_execute+0x2d6>

  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);
 800e096:	ab01      	add	r3, sp, #4
 800e098:	489c      	ldr	r0, [pc, #624]	; (800e30c <heap1_execute+0x2dc>)
 800e09a:	4619      	mov	r1, r3
 800e09c:	f7f5 fc40 	bl	8003920 <chHeapStatus>

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 800e0a0:	489a      	ldr	r0, [pc, #616]	; (800e30c <heap1_execute+0x2dc>)
 800e0a2:	2110      	movs	r1, #16
 800e0a4:	f7f5 fb5c 	bl	8003760 <chHeapAlloc>
 800e0a8:	9005      	str	r0, [sp, #20]
  p2 = chHeapAlloc(&test_heap, SIZE);
 800e0aa:	4898      	ldr	r0, [pc, #608]	; (800e30c <heap1_execute+0x2dc>)
 800e0ac:	2110      	movs	r1, #16
 800e0ae:	f7f5 fb57 	bl	8003760 <chHeapAlloc>
 800e0b2:	9004      	str	r0, [sp, #16]
  p3 = chHeapAlloc(&test_heap, SIZE);
 800e0b4:	4895      	ldr	r0, [pc, #596]	; (800e30c <heap1_execute+0x2dc>)
 800e0b6:	2110      	movs	r1, #16
 800e0b8:	f7f5 fb52 	bl	8003760 <chHeapAlloc>
 800e0bc:	9003      	str	r0, [sp, #12]
  chHeapFree(p1);                               /* Does not merge.*/
 800e0be:	9805      	ldr	r0, [sp, #20]
 800e0c0:	f7f5 fbc6 	bl	8003850 <chHeapFree>
  chHeapFree(p2);                               /* Merges backward.*/
 800e0c4:	9804      	ldr	r0, [sp, #16]
 800e0c6:	f7f5 fbc3 	bl	8003850 <chHeapFree>
  chHeapFree(p3);                               /* Merges both sides.*/
 800e0ca:	9803      	ldr	r0, [sp, #12]
 800e0cc:	f7f5 fbc0 	bl	8003850 <chHeapFree>
  test_assert(3, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 800e0d0:	ab02      	add	r3, sp, #8
 800e0d2:	488e      	ldr	r0, [pc, #568]	; (800e30c <heap1_execute+0x2dc>)
 800e0d4:	4619      	mov	r1, r3
 800e0d6:	f7f5 fc23 	bl	8003920 <chHeapStatus>
 800e0da:	4603      	mov	r3, r0
 800e0dc:	2b01      	cmp	r3, #1
 800e0de:	bf14      	ite	ne
 800e0e0:	2300      	movne	r3, #0
 800e0e2:	2301      	moveq	r3, #1
 800e0e4:	b2db      	uxtb	r3, r3
 800e0e6:	2003      	movs	r0, #3
 800e0e8:	4619      	mov	r1, r3
 800e0ea:	f7fd f8e1 	bl	800b2b0 <_test_assert>
 800e0ee:	4603      	mov	r3, r0
 800e0f0:	2b00      	cmp	r3, #0
 800e0f2:	d000      	beq.n	800e0f6 <heap1_execute+0xc6>
 800e0f4:	e107      	b.n	800e306 <heap1_execute+0x2d6>

  /* Reverse order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 800e0f6:	4885      	ldr	r0, [pc, #532]	; (800e30c <heap1_execute+0x2dc>)
 800e0f8:	2110      	movs	r1, #16
 800e0fa:	f7f5 fb31 	bl	8003760 <chHeapAlloc>
 800e0fe:	9005      	str	r0, [sp, #20]
  p2 = chHeapAlloc(&test_heap, SIZE);
 800e100:	4882      	ldr	r0, [pc, #520]	; (800e30c <heap1_execute+0x2dc>)
 800e102:	2110      	movs	r1, #16
 800e104:	f7f5 fb2c 	bl	8003760 <chHeapAlloc>
 800e108:	9004      	str	r0, [sp, #16]
  p3 = chHeapAlloc(&test_heap, SIZE);
 800e10a:	4880      	ldr	r0, [pc, #512]	; (800e30c <heap1_execute+0x2dc>)
 800e10c:	2110      	movs	r1, #16
 800e10e:	f7f5 fb27 	bl	8003760 <chHeapAlloc>
 800e112:	9003      	str	r0, [sp, #12]
  chHeapFree(p3);                               /* Merges forward.*/
 800e114:	9803      	ldr	r0, [sp, #12]
 800e116:	f7f5 fb9b 	bl	8003850 <chHeapFree>
  chHeapFree(p2);                               /* Merges forward.*/
 800e11a:	9804      	ldr	r0, [sp, #16]
 800e11c:	f7f5 fb98 	bl	8003850 <chHeapFree>
  chHeapFree(p1);                               /* Merges forward.*/
 800e120:	9805      	ldr	r0, [sp, #20]
 800e122:	f7f5 fb95 	bl	8003850 <chHeapFree>
  test_assert(4, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 800e126:	ab02      	add	r3, sp, #8
 800e128:	4878      	ldr	r0, [pc, #480]	; (800e30c <heap1_execute+0x2dc>)
 800e12a:	4619      	mov	r1, r3
 800e12c:	f7f5 fbf8 	bl	8003920 <chHeapStatus>
 800e130:	4603      	mov	r3, r0
 800e132:	2b01      	cmp	r3, #1
 800e134:	bf14      	ite	ne
 800e136:	2300      	movne	r3, #0
 800e138:	2301      	moveq	r3, #1
 800e13a:	b2db      	uxtb	r3, r3
 800e13c:	2004      	movs	r0, #4
 800e13e:	4619      	mov	r1, r3
 800e140:	f7fd f8b6 	bl	800b2b0 <_test_assert>
 800e144:	4603      	mov	r3, r0
 800e146:	2b00      	cmp	r3, #0
 800e148:	d000      	beq.n	800e14c <heap1_execute+0x11c>
 800e14a:	e0dc      	b.n	800e306 <heap1_execute+0x2d6>

  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
 800e14c:	486f      	ldr	r0, [pc, #444]	; (800e30c <heap1_execute+0x2dc>)
 800e14e:	2111      	movs	r1, #17
 800e150:	f7f5 fb06 	bl	8003760 <chHeapAlloc>
 800e154:	9005      	str	r0, [sp, #20]
  p2 = chHeapAlloc(&test_heap, SIZE);
 800e156:	486d      	ldr	r0, [pc, #436]	; (800e30c <heap1_execute+0x2dc>)
 800e158:	2110      	movs	r1, #16
 800e15a:	f7f5 fb01 	bl	8003760 <chHeapAlloc>
 800e15e:	9004      	str	r0, [sp, #16]
  chHeapFree(p1);
 800e160:	9805      	ldr	r0, [sp, #20]
 800e162:	f7f5 fb75 	bl	8003850 <chHeapFree>
  test_assert(5, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 800e166:	ab02      	add	r3, sp, #8
 800e168:	4868      	ldr	r0, [pc, #416]	; (800e30c <heap1_execute+0x2dc>)
 800e16a:	4619      	mov	r1, r3
 800e16c:	f7f5 fbd8 	bl	8003920 <chHeapStatus>
 800e170:	4603      	mov	r3, r0
 800e172:	2b02      	cmp	r3, #2
 800e174:	bf14      	ite	ne
 800e176:	2300      	movne	r3, #0
 800e178:	2301      	moveq	r3, #1
 800e17a:	b2db      	uxtb	r3, r3
 800e17c:	2005      	movs	r0, #5
 800e17e:	4619      	mov	r1, r3
 800e180:	f7fd f896 	bl	800b2b0 <_test_assert>
 800e184:	4603      	mov	r3, r0
 800e186:	2b00      	cmp	r3, #0
 800e188:	d000      	beq.n	800e18c <heap1_execute+0x15c>
 800e18a:	e0bc      	b.n	800e306 <heap1_execute+0x2d6>
  p1 = chHeapAlloc(&test_heap, SIZE);
 800e18c:	485f      	ldr	r0, [pc, #380]	; (800e30c <heap1_execute+0x2dc>)
 800e18e:	2110      	movs	r1, #16
 800e190:	f7f5 fae6 	bl	8003760 <chHeapAlloc>
 800e194:	9005      	str	r0, [sp, #20]
  /* Note, the first situation happens when the alignment size is smaller
     than the header size, the second in the other cases.*/
  test_assert(6, (chHeapStatus(&test_heap, &n) == 1) ||
 800e196:	ab02      	add	r3, sp, #8
 800e198:	485c      	ldr	r0, [pc, #368]	; (800e30c <heap1_execute+0x2dc>)
 800e19a:	4619      	mov	r1, r3
 800e19c:	f7f5 fbc0 	bl	8003920 <chHeapStatus>
 800e1a0:	4603      	mov	r3, r0
 800e1a2:	2b01      	cmp	r3, #1
 800e1a4:	d007      	beq.n	800e1b6 <heap1_execute+0x186>
 800e1a6:	ab02      	add	r3, sp, #8
 800e1a8:	4858      	ldr	r0, [pc, #352]	; (800e30c <heap1_execute+0x2dc>)
 800e1aa:	4619      	mov	r1, r3
 800e1ac:	f7f5 fbb8 	bl	8003920 <chHeapStatus>
 800e1b0:	4603      	mov	r3, r0
 800e1b2:	2b02      	cmp	r3, #2
 800e1b4:	d101      	bne.n	800e1ba <heap1_execute+0x18a>
 800e1b6:	2301      	movs	r3, #1
 800e1b8:	e000      	b.n	800e1bc <heap1_execute+0x18c>
 800e1ba:	2300      	movs	r3, #0
 800e1bc:	f003 0301 	and.w	r3, r3, #1
 800e1c0:	b2db      	uxtb	r3, r3
 800e1c2:	2006      	movs	r0, #6
 800e1c4:	4619      	mov	r1, r3
 800e1c6:	f7fd f873 	bl	800b2b0 <_test_assert>
 800e1ca:	4603      	mov	r3, r0
 800e1cc:	2b00      	cmp	r3, #0
 800e1ce:	d000      	beq.n	800e1d2 <heap1_execute+0x1a2>
 800e1d0:	e099      	b.n	800e306 <heap1_execute+0x2d6>
                 (chHeapStatus(&test_heap, &n) == 2), "heap fragmented");
  chHeapFree(p2);
 800e1d2:	9804      	ldr	r0, [sp, #16]
 800e1d4:	f7f5 fb3c 	bl	8003850 <chHeapFree>
  chHeapFree(p1);
 800e1d8:	9805      	ldr	r0, [sp, #20]
 800e1da:	f7f5 fb39 	bl	8003850 <chHeapFree>
  test_assert(7, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 800e1de:	ab02      	add	r3, sp, #8
 800e1e0:	484a      	ldr	r0, [pc, #296]	; (800e30c <heap1_execute+0x2dc>)
 800e1e2:	4619      	mov	r1, r3
 800e1e4:	f7f5 fb9c 	bl	8003920 <chHeapStatus>
 800e1e8:	4603      	mov	r3, r0
 800e1ea:	2b01      	cmp	r3, #1
 800e1ec:	bf14      	ite	ne
 800e1ee:	2300      	movne	r3, #0
 800e1f0:	2301      	moveq	r3, #1
 800e1f2:	b2db      	uxtb	r3, r3
 800e1f4:	2007      	movs	r0, #7
 800e1f6:	4619      	mov	r1, r3
 800e1f8:	f7fd f85a 	bl	800b2b0 <_test_assert>
 800e1fc:	4603      	mov	r3, r0
 800e1fe:	2b00      	cmp	r3, #0
 800e200:	d000      	beq.n	800e204 <heap1_execute+0x1d4>
 800e202:	e080      	b.n	800e306 <heap1_execute+0x2d6>

  /* Skip fragment handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 800e204:	4841      	ldr	r0, [pc, #260]	; (800e30c <heap1_execute+0x2dc>)
 800e206:	2110      	movs	r1, #16
 800e208:	f7f5 faaa 	bl	8003760 <chHeapAlloc>
 800e20c:	9005      	str	r0, [sp, #20]
  p2 = chHeapAlloc(&test_heap, SIZE);
 800e20e:	483f      	ldr	r0, [pc, #252]	; (800e30c <heap1_execute+0x2dc>)
 800e210:	2110      	movs	r1, #16
 800e212:	f7f5 faa5 	bl	8003760 <chHeapAlloc>
 800e216:	9004      	str	r0, [sp, #16]
  chHeapFree(p1);
 800e218:	9805      	ldr	r0, [sp, #20]
 800e21a:	f7f5 fb19 	bl	8003850 <chHeapFree>
  test_assert(8, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 800e21e:	ab02      	add	r3, sp, #8
 800e220:	483a      	ldr	r0, [pc, #232]	; (800e30c <heap1_execute+0x2dc>)
 800e222:	4619      	mov	r1, r3
 800e224:	f7f5 fb7c 	bl	8003920 <chHeapStatus>
 800e228:	4603      	mov	r3, r0
 800e22a:	2b02      	cmp	r3, #2
 800e22c:	bf14      	ite	ne
 800e22e:	2300      	movne	r3, #0
 800e230:	2301      	moveq	r3, #1
 800e232:	b2db      	uxtb	r3, r3
 800e234:	2008      	movs	r0, #8
 800e236:	4619      	mov	r1, r3
 800e238:	f7fd f83a 	bl	800b2b0 <_test_assert>
 800e23c:	4603      	mov	r3, r0
 800e23e:	2b00      	cmp	r3, #0
 800e240:	d000      	beq.n	800e244 <heap1_execute+0x214>
 800e242:	e060      	b.n	800e306 <heap1_execute+0x2d6>
  p1 = chHeapAlloc(&test_heap, SIZE * 2);       /* Skips first fragment.*/
 800e244:	4831      	ldr	r0, [pc, #196]	; (800e30c <heap1_execute+0x2dc>)
 800e246:	2120      	movs	r1, #32
 800e248:	f7f5 fa8a 	bl	8003760 <chHeapAlloc>
 800e24c:	9005      	str	r0, [sp, #20]
  chHeapFree(p1);
 800e24e:	9805      	ldr	r0, [sp, #20]
 800e250:	f7f5 fafe 	bl	8003850 <chHeapFree>
  chHeapFree(p2);
 800e254:	9804      	ldr	r0, [sp, #16]
 800e256:	f7f5 fafb 	bl	8003850 <chHeapFree>
  test_assert(9, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 800e25a:	ab02      	add	r3, sp, #8
 800e25c:	482b      	ldr	r0, [pc, #172]	; (800e30c <heap1_execute+0x2dc>)
 800e25e:	4619      	mov	r1, r3
 800e260:	f7f5 fb5e 	bl	8003920 <chHeapStatus>
 800e264:	4603      	mov	r3, r0
 800e266:	2b01      	cmp	r3, #1
 800e268:	bf14      	ite	ne
 800e26a:	2300      	movne	r3, #0
 800e26c:	2301      	moveq	r3, #1
 800e26e:	b2db      	uxtb	r3, r3
 800e270:	2009      	movs	r0, #9
 800e272:	4619      	mov	r1, r3
 800e274:	f7fd f81c 	bl	800b2b0 <_test_assert>
 800e278:	4603      	mov	r3, r0
 800e27a:	2b00      	cmp	r3, #0
 800e27c:	d000      	beq.n	800e280 <heap1_execute+0x250>
 800e27e:	e042      	b.n	800e306 <heap1_execute+0x2d6>

  /* Allocate all handling.*/
  (void)chHeapStatus(&test_heap, &n);
 800e280:	ab02      	add	r3, sp, #8
 800e282:	4822      	ldr	r0, [pc, #136]	; (800e30c <heap1_execute+0x2dc>)
 800e284:	4619      	mov	r1, r3
 800e286:	f7f5 fb4b 	bl	8003920 <chHeapStatus>
  p1 = chHeapAlloc(&test_heap, n);
 800e28a:	9b02      	ldr	r3, [sp, #8]
 800e28c:	481f      	ldr	r0, [pc, #124]	; (800e30c <heap1_execute+0x2dc>)
 800e28e:	4619      	mov	r1, r3
 800e290:	f7f5 fa66 	bl	8003760 <chHeapAlloc>
 800e294:	9005      	str	r0, [sp, #20]
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
 800e296:	ab02      	add	r3, sp, #8
 800e298:	481c      	ldr	r0, [pc, #112]	; (800e30c <heap1_execute+0x2dc>)
 800e29a:	4619      	mov	r1, r3
 800e29c:	f7f5 fb40 	bl	8003920 <chHeapStatus>
 800e2a0:	4603      	mov	r3, r0
 800e2a2:	2b00      	cmp	r3, #0
 800e2a4:	bf14      	ite	ne
 800e2a6:	2300      	movne	r3, #0
 800e2a8:	2301      	moveq	r3, #1
 800e2aa:	b2db      	uxtb	r3, r3
 800e2ac:	200a      	movs	r0, #10
 800e2ae:	4619      	mov	r1, r3
 800e2b0:	f7fc fffe 	bl	800b2b0 <_test_assert>
 800e2b4:	4603      	mov	r3, r0
 800e2b6:	2b00      	cmp	r3, #0
 800e2b8:	d000      	beq.n	800e2bc <heap1_execute+0x28c>
 800e2ba:	e024      	b.n	800e306 <heap1_execute+0x2d6>
  chHeapFree(p1);
 800e2bc:	9805      	ldr	r0, [sp, #20]
 800e2be:	f7f5 fac7 	bl	8003850 <chHeapFree>

  test_assert(11, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 800e2c2:	ab02      	add	r3, sp, #8
 800e2c4:	4811      	ldr	r0, [pc, #68]	; (800e30c <heap1_execute+0x2dc>)
 800e2c6:	4619      	mov	r1, r3
 800e2c8:	f7f5 fb2a 	bl	8003920 <chHeapStatus>
 800e2cc:	4603      	mov	r3, r0
 800e2ce:	2b01      	cmp	r3, #1
 800e2d0:	bf14      	ite	ne
 800e2d2:	2300      	movne	r3, #0
 800e2d4:	2301      	moveq	r3, #1
 800e2d6:	b2db      	uxtb	r3, r3
 800e2d8:	200b      	movs	r0, #11
 800e2da:	4619      	mov	r1, r3
 800e2dc:	f7fc ffe8 	bl	800b2b0 <_test_assert>
 800e2e0:	4603      	mov	r3, r0
 800e2e2:	2b00      	cmp	r3, #0
 800e2e4:	d000      	beq.n	800e2e8 <heap1_execute+0x2b8>
 800e2e6:	e00e      	b.n	800e306 <heap1_execute+0x2d6>
  test_assert(12, n == sz, "size changed");
 800e2e8:	9a02      	ldr	r2, [sp, #8]
 800e2ea:	9b01      	ldr	r3, [sp, #4]
 800e2ec:	429a      	cmp	r2, r3
 800e2ee:	bf14      	ite	ne
 800e2f0:	2300      	movne	r3, #0
 800e2f2:	2301      	moveq	r3, #1
 800e2f4:	b2db      	uxtb	r3, r3
 800e2f6:	200c      	movs	r0, #12
 800e2f8:	4619      	mov	r1, r3
 800e2fa:	f7fc ffd9 	bl	800b2b0 <_test_assert>
 800e2fe:	4603      	mov	r3, r0
 800e300:	2b00      	cmp	r3, #0
 800e302:	d000      	beq.n	800e306 <heap1_execute+0x2d6>
 800e304:	bf00      	nop
}
 800e306:	b007      	add	sp, #28
 800e308:	f85d fb04 	ldr.w	pc, [sp], #4
 800e30c:	20000b80 	.word	0x20000b80

0800e310 <null_provider>:
 * Five memory blocks are added to a memory pool then removed.<br>
 * The test expects to find the pool queue in the proper status after each
 * operation.
 */

static void *null_provider(size_t size) {
 800e310:	b082      	sub	sp, #8
 800e312:	9001      	str	r0, [sp, #4]

  (void)size;
  return NULL;
 800e314:	2300      	movs	r3, #0
}
 800e316:	4618      	mov	r0, r3
 800e318:	b002      	add	sp, #8
 800e31a:	4770      	bx	lr
 800e31c:	f3af 8000 	nop.w

0800e320 <pools1_setup>:

static void pools1_setup(void) {
 800e320:	b508      	push	{r3, lr}

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
 800e322:	4803      	ldr	r0, [pc, #12]	; (800e330 <pools1_setup+0x10>)
 800e324:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800e328:	2200      	movs	r2, #0
 800e32a:	f7f5 fb61 	bl	80039f0 <chPoolObjectInit>
}
 800e32e:	bd08      	pop	{r3, pc}
 800e330:	2000089c 	.word	0x2000089c
 800e334:	f3af 8000 	nop.w
 800e338:	f3af 8000 	nop.w
 800e33c:	f3af 8000 	nop.w

0800e340 <pools1_execute>:

static void pools1_execute(void) {
 800e340:	b500      	push	{lr}
 800e342:	b083      	sub	sp, #12
  int i;

  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);
 800e344:	4b43      	ldr	r3, [pc, #268]	; (800e454 <pools1_execute+0x114>)
 800e346:	681b      	ldr	r3, [r3, #0]
 800e348:	4843      	ldr	r0, [pc, #268]	; (800e458 <pools1_execute+0x118>)
 800e34a:	4619      	mov	r1, r3
 800e34c:	2205      	movs	r2, #5
 800e34e:	f7f5 fb5f 	bl	8003a10 <chPoolLoadArray>

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
 800e352:	2300      	movs	r3, #0
 800e354:	9301      	str	r3, [sp, #4]
 800e356:	e013      	b.n	800e380 <pools1_execute+0x40>
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");
 800e358:	483f      	ldr	r0, [pc, #252]	; (800e458 <pools1_execute+0x118>)
 800e35a:	f7f5 fb91 	bl	8003a80 <chPoolAlloc>
 800e35e:	4603      	mov	r3, r0
 800e360:	2b00      	cmp	r3, #0
 800e362:	bf0c      	ite	eq
 800e364:	2300      	moveq	r3, #0
 800e366:	2301      	movne	r3, #1
 800e368:	b2db      	uxtb	r3, r3
 800e36a:	2001      	movs	r0, #1
 800e36c:	4619      	mov	r1, r3
 800e36e:	f7fc ff9f 	bl	800b2b0 <_test_assert>
 800e372:	4603      	mov	r3, r0
 800e374:	2b00      	cmp	r3, #0
 800e376:	d000      	beq.n	800e37a <pools1_execute+0x3a>
 800e378:	e068      	b.n	800e44c <pools1_execute+0x10c>

  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
 800e37a:	9b01      	ldr	r3, [sp, #4]
 800e37c:	3301      	adds	r3, #1
 800e37e:	9301      	str	r3, [sp, #4]
 800e380:	9b01      	ldr	r3, [sp, #4]
 800e382:	2b04      	cmp	r3, #4
 800e384:	dde8      	ble.n	800e358 <pools1_execute+0x18>
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");
 800e386:	4834      	ldr	r0, [pc, #208]	; (800e458 <pools1_execute+0x118>)
 800e388:	f7f5 fb7a 	bl	8003a80 <chPoolAlloc>
 800e38c:	4603      	mov	r3, r0
 800e38e:	2b00      	cmp	r3, #0
 800e390:	bf14      	ite	ne
 800e392:	2300      	movne	r3, #0
 800e394:	2301      	moveq	r3, #1
 800e396:	b2db      	uxtb	r3, r3
 800e398:	2002      	movs	r0, #2
 800e39a:	4619      	mov	r1, r3
 800e39c:	f7fc ff88 	bl	800b2b0 <_test_assert>
 800e3a0:	4603      	mov	r3, r0
 800e3a2:	2b00      	cmp	r3, #0
 800e3a4:	d000      	beq.n	800e3a8 <pools1_execute+0x68>
 800e3a6:	e051      	b.n	800e44c <pools1_execute+0x10c>

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
 800e3a8:	2300      	movs	r3, #0
 800e3aa:	9301      	str	r3, [sp, #4]
 800e3ac:	e00a      	b.n	800e3c4 <pools1_execute+0x84>
    chPoolFree(&mp1, wa[i]);
 800e3ae:	4b29      	ldr	r3, [pc, #164]	; (800e454 <pools1_execute+0x114>)
 800e3b0:	9a01      	ldr	r2, [sp, #4]
 800e3b2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800e3b6:	4828      	ldr	r0, [pc, #160]	; (800e458 <pools1_execute+0x118>)
 800e3b8:	4619      	mov	r1, r3
 800e3ba:	f7f5 fb81 	bl	8003ac0 <chPoolFree>

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
 800e3be:	9b01      	ldr	r3, [sp, #4]
 800e3c0:	3301      	adds	r3, #1
 800e3c2:	9301      	str	r3, [sp, #4]
 800e3c4:	9b01      	ldr	r3, [sp, #4]
 800e3c6:	2b04      	cmp	r3, #4
 800e3c8:	ddf1      	ble.n	800e3ae <pools1_execute+0x6e>
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
 800e3ca:	2300      	movs	r3, #0
 800e3cc:	9301      	str	r3, [sp, #4]
 800e3ce:	e013      	b.n	800e3f8 <pools1_execute+0xb8>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");
 800e3d0:	4821      	ldr	r0, [pc, #132]	; (800e458 <pools1_execute+0x118>)
 800e3d2:	f7f5 fb55 	bl	8003a80 <chPoolAlloc>
 800e3d6:	4603      	mov	r3, r0
 800e3d8:	2b00      	cmp	r3, #0
 800e3da:	bf0c      	ite	eq
 800e3dc:	2300      	moveq	r3, #0
 800e3de:	2301      	movne	r3, #1
 800e3e0:	b2db      	uxtb	r3, r3
 800e3e2:	2003      	movs	r0, #3
 800e3e4:	4619      	mov	r1, r3
 800e3e6:	f7fc ff63 	bl	800b2b0 <_test_assert>
 800e3ea:	4603      	mov	r3, r0
 800e3ec:	2b00      	cmp	r3, #0
 800e3ee:	d000      	beq.n	800e3f2 <pools1_execute+0xb2>
 800e3f0:	e02c      	b.n	800e44c <pools1_execute+0x10c>
  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
 800e3f2:	9b01      	ldr	r3, [sp, #4]
 800e3f4:	3301      	adds	r3, #1
 800e3f6:	9301      	str	r3, [sp, #4]
 800e3f8:	9b01      	ldr	r3, [sp, #4]
 800e3fa:	2b04      	cmp	r3, #4
 800e3fc:	dde8      	ble.n	800e3d0 <pools1_execute+0x90>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty again.*/
  test_assert(4, chPoolAlloc(&mp1) == NULL, "list not empty");
 800e3fe:	4816      	ldr	r0, [pc, #88]	; (800e458 <pools1_execute+0x118>)
 800e400:	f7f5 fb3e 	bl	8003a80 <chPoolAlloc>
 800e404:	4603      	mov	r3, r0
 800e406:	2b00      	cmp	r3, #0
 800e408:	bf14      	ite	ne
 800e40a:	2300      	movne	r3, #0
 800e40c:	2301      	moveq	r3, #1
 800e40e:	b2db      	uxtb	r3, r3
 800e410:	2004      	movs	r0, #4
 800e412:	4619      	mov	r1, r3
 800e414:	f7fc ff4c 	bl	800b2b0 <_test_assert>
 800e418:	4603      	mov	r3, r0
 800e41a:	2b00      	cmp	r3, #0
 800e41c:	d000      	beq.n	800e420 <pools1_execute+0xe0>
 800e41e:	e015      	b.n	800e44c <pools1_execute+0x10c>

  /* Covering the case where a provider is unable to return more memory.*/
  chPoolObjectInit(&mp1, 16, null_provider);
 800e420:	480d      	ldr	r0, [pc, #52]	; (800e458 <pools1_execute+0x118>)
 800e422:	2110      	movs	r1, #16
 800e424:	4a0d      	ldr	r2, [pc, #52]	; (800e45c <pools1_execute+0x11c>)
 800e426:	f7f5 fae3 	bl	80039f0 <chPoolObjectInit>
  test_assert(5, chPoolAlloc(&mp1) == NULL, "provider returned memory");
 800e42a:	480b      	ldr	r0, [pc, #44]	; (800e458 <pools1_execute+0x118>)
 800e42c:	f7f5 fb28 	bl	8003a80 <chPoolAlloc>
 800e430:	4603      	mov	r3, r0
 800e432:	2b00      	cmp	r3, #0
 800e434:	bf14      	ite	ne
 800e436:	2300      	movne	r3, #0
 800e438:	2301      	moveq	r3, #1
 800e43a:	b2db      	uxtb	r3, r3
 800e43c:	2005      	movs	r0, #5
 800e43e:	4619      	mov	r1, r3
 800e440:	f7fc ff36 	bl	800b2b0 <_test_assert>
 800e444:	4603      	mov	r3, r0
 800e446:	2b00      	cmp	r3, #0
 800e448:	d000      	beq.n	800e44c <pools1_execute+0x10c>
 800e44a:	bf00      	nop
}
 800e44c:	b003      	add	sp, #12
 800e44e:	f85d fb04 	ldr.w	pc, [sp], #4
 800e452:	bf00      	nop
 800e454:	08016240 	.word	0x08016240
 800e458:	2000089c 	.word	0x2000089c
 800e45c:	0800e311 	.word	0x0800e311

0800e460 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800e460:	4b01      	ldr	r3, [pc, #4]	; (800e468 <chThdGetSelfX+0x8>)
 800e462:	699b      	ldr	r3, [r3, #24]
}
 800e464:	4618      	mov	r0, r3
 800e466:	4770      	bx	lr
 800e468:	20000d98 	.word	0x20000d98
 800e46c:	f3af 8000 	nop.w

0800e470 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800e470:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800e472:	f7ff fff5 	bl	800e460 <chThdGetSelfX>
 800e476:	4603      	mov	r3, r0
 800e478:	689b      	ldr	r3, [r3, #8]
}
 800e47a:	4618      	mov	r0, r3
 800e47c:	bd08      	pop	{r3, pc}
 800e47e:	bf00      	nop

0800e480 <thread>:
 * is attempted.<br>
 * The test expects the first two threads to successfully start and the last
 * one to fail.
 */

static THD_FUNCTION(thread, p) {
 800e480:	b500      	push	{lr}
 800e482:	b083      	sub	sp, #12
 800e484:	9001      	str	r0, [sp, #4]

  test_emit_token(*(char *)p);
 800e486:	9b01      	ldr	r3, [sp, #4]
 800e488:	781b      	ldrb	r3, [r3, #0]
 800e48a:	4618      	mov	r0, r3
 800e48c:	f7fc fee0 	bl	800b250 <test_emit_token>
}
 800e490:	b003      	add	sp, #12
 800e492:	f85d fb04 	ldr.w	pc, [sp], #4
 800e496:	bf00      	nop
 800e498:	f3af 8000 	nop.w
 800e49c:	f3af 8000 	nop.w

0800e4a0 <dyn1_setup>:

#if CH_CFG_USE_HEAP || defined(__DOXYGEN__)
static void dyn1_setup(void) {
 800e4a0:	b508      	push	{r3, lr}

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
 800e4a2:	4803      	ldr	r0, [pc, #12]	; (800e4b0 <dyn1_setup+0x10>)
 800e4a4:	4903      	ldr	r1, [pc, #12]	; (800e4b4 <dyn1_setup+0x14>)
 800e4a6:	f44f 62cd 	mov.w	r2, #1640	; 0x668
 800e4aa:	f7f5 f939 	bl	8003720 <chHeapObjectInit>
}
 800e4ae:	bd08      	pop	{r3, pc}
 800e4b0:	20000ba0 	.word	0x20000ba0
 800e4b4:	20001238 	.word	0x20001238
 800e4b8:	f3af 8000 	nop.w
 800e4bc:	f3af 8000 	nop.w

0800e4c0 <dyn1_execute>:

static void dyn1_execute(void) {
 800e4c0:	b500      	push	{lr}
 800e4c2:	b087      	sub	sp, #28
  size_t n, sz;
  void *p1;
  tprio_t prio = chThdGetPriorityX();
 800e4c4:	f7ff ffd4 	bl	800e470 <chThdGetPriorityX>
 800e4c8:	9005      	str	r0, [sp, #20]

  (void)chHeapStatus(&heap1, &sz);
 800e4ca:	ab02      	add	r3, sp, #8
 800e4cc:	4846      	ldr	r0, [pc, #280]	; (800e5e8 <dyn1_execute+0x128>)
 800e4ce:	4619      	mov	r1, r3
 800e4d0:	f7f5 fa26 	bl	8003920 <chHeapStatus>
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
 800e4d4:	9b05      	ldr	r3, [sp, #20]
 800e4d6:	3b01      	subs	r3, #1
 800e4d8:	4a44      	ldr	r2, [pc, #272]	; (800e5ec <dyn1_execute+0x12c>)
 800e4da:	9200      	str	r2, [sp, #0]
 800e4dc:	4842      	ldr	r0, [pc, #264]	; (800e5e8 <dyn1_execute+0x128>)
 800e4de:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800e4e2:	461a      	mov	r2, r3
 800e4e4:	4b42      	ldr	r3, [pc, #264]	; (800e5f0 <dyn1_execute+0x130>)
 800e4e6:	f7f3 f9b3 	bl	8001850 <chThdCreateFromHeap>
 800e4ea:	4602      	mov	r2, r0
 800e4ec:	4b41      	ldr	r3, [pc, #260]	; (800e5f4 <dyn1_execute+0x134>)
 800e4ee:	601a      	str	r2, [r3, #0]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 800e4f0:	9b05      	ldr	r3, [sp, #20]
 800e4f2:	3b02      	subs	r3, #2
 800e4f4:	4a40      	ldr	r2, [pc, #256]	; (800e5f8 <dyn1_execute+0x138>)
 800e4f6:	9200      	str	r2, [sp, #0]
 800e4f8:	483b      	ldr	r0, [pc, #236]	; (800e5e8 <dyn1_execute+0x128>)
 800e4fa:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800e4fe:	461a      	mov	r2, r3
 800e500:	4b3b      	ldr	r3, [pc, #236]	; (800e5f0 <dyn1_execute+0x130>)
 800e502:	f7f3 f9a5 	bl	8001850 <chThdCreateFromHeap>
 800e506:	4602      	mov	r2, r0
 800e508:	4b3a      	ldr	r3, [pc, #232]	; (800e5f4 <dyn1_execute+0x134>)
 800e50a:	605a      	str	r2, [r3, #4]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
 800e50c:	ab03      	add	r3, sp, #12
 800e50e:	4836      	ldr	r0, [pc, #216]	; (800e5e8 <dyn1_execute+0x128>)
 800e510:	4619      	mov	r1, r3
 800e512:	f7f5 fa05 	bl	8003920 <chHeapStatus>
  p1 = chHeapAlloc(&heap1, n);
 800e516:	9b03      	ldr	r3, [sp, #12]
 800e518:	4833      	ldr	r0, [pc, #204]	; (800e5e8 <dyn1_execute+0x128>)
 800e51a:	4619      	mov	r1, r3
 800e51c:	f7f5 f920 	bl	8003760 <chHeapAlloc>
 800e520:	9004      	str	r0, [sp, #16]
  threads[2] = chThdCreateFromHeap(&heap1,
 800e522:	9b05      	ldr	r3, [sp, #20]
 800e524:	3b03      	subs	r3, #3
 800e526:	4a35      	ldr	r2, [pc, #212]	; (800e5fc <dyn1_execute+0x13c>)
 800e528:	9200      	str	r2, [sp, #0]
 800e52a:	482f      	ldr	r0, [pc, #188]	; (800e5e8 <dyn1_execute+0x128>)
 800e52c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800e530:	461a      	mov	r2, r3
 800e532:	4b2f      	ldr	r3, [pc, #188]	; (800e5f0 <dyn1_execute+0x130>)
 800e534:	f7f3 f98c 	bl	8001850 <chThdCreateFromHeap>
 800e538:	4602      	mov	r2, r0
 800e53a:	4b2e      	ldr	r3, [pc, #184]	; (800e5f4 <dyn1_execute+0x134>)
 800e53c:	609a      	str	r2, [r3, #8]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-3, thread, "C");
  chHeapFree(p1);
 800e53e:	9804      	ldr	r0, [sp, #16]
 800e540:	f7f5 f986 	bl	8003850 <chHeapFree>

  test_assert(1, (threads[0] != NULL) &&
 800e544:	4b2b      	ldr	r3, [pc, #172]	; (800e5f4 <dyn1_execute+0x134>)
 800e546:	681b      	ldr	r3, [r3, #0]
 800e548:	2b00      	cmp	r3, #0
 800e54a:	d011      	beq.n	800e570 <dyn1_execute+0xb0>
 800e54c:	4b29      	ldr	r3, [pc, #164]	; (800e5f4 <dyn1_execute+0x134>)
 800e54e:	685b      	ldr	r3, [r3, #4]
 800e550:	2b00      	cmp	r3, #0
 800e552:	d00d      	beq.n	800e570 <dyn1_execute+0xb0>
 800e554:	4b27      	ldr	r3, [pc, #156]	; (800e5f4 <dyn1_execute+0x134>)
 800e556:	689b      	ldr	r3, [r3, #8]
 800e558:	2b00      	cmp	r3, #0
 800e55a:	d109      	bne.n	800e570 <dyn1_execute+0xb0>
 800e55c:	4b25      	ldr	r3, [pc, #148]	; (800e5f4 <dyn1_execute+0x134>)
 800e55e:	68db      	ldr	r3, [r3, #12]
 800e560:	2b00      	cmp	r3, #0
 800e562:	d105      	bne.n	800e570 <dyn1_execute+0xb0>
 800e564:	4b23      	ldr	r3, [pc, #140]	; (800e5f4 <dyn1_execute+0x134>)
 800e566:	691b      	ldr	r3, [r3, #16]
 800e568:	2b00      	cmp	r3, #0
 800e56a:	d101      	bne.n	800e570 <dyn1_execute+0xb0>
 800e56c:	2301      	movs	r3, #1
 800e56e:	e000      	b.n	800e572 <dyn1_execute+0xb2>
 800e570:	2300      	movs	r3, #0
 800e572:	f003 0301 	and.w	r3, r3, #1
 800e576:	b2db      	uxtb	r3, r3
 800e578:	2001      	movs	r0, #1
 800e57a:	4619      	mov	r1, r3
 800e57c:	f7fc fe98 	bl	800b2b0 <_test_assert>
 800e580:	4603      	mov	r3, r0
 800e582:	2b00      	cmp	r3, #0
 800e584:	d000      	beq.n	800e588 <dyn1_execute+0xc8>
 800e586:	e02b      	b.n	800e5e0 <dyn1_execute+0x120>
                 (threads[3] == NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 800e588:	f7fc ff12 	bl	800b3b0 <test_wait_threads>
  test_assert_sequence(2, "AB");
 800e58c:	2002      	movs	r0, #2
 800e58e:	491c      	ldr	r1, [pc, #112]	; (800e600 <dyn1_execute+0x140>)
 800e590:	f7fc fea6 	bl	800b2e0 <_test_assert_sequence>
 800e594:	4603      	mov	r3, r0
 800e596:	2b00      	cmp	r3, #0
 800e598:	d000      	beq.n	800e59c <dyn1_execute+0xdc>
 800e59a:	e021      	b.n	800e5e0 <dyn1_execute+0x120>

  /* Heap status checked again.*/
  test_assert(3, chHeapStatus(&heap1, &n) == 1, "heap fragmented");
 800e59c:	ab03      	add	r3, sp, #12
 800e59e:	4812      	ldr	r0, [pc, #72]	; (800e5e8 <dyn1_execute+0x128>)
 800e5a0:	4619      	mov	r1, r3
 800e5a2:	f7f5 f9bd 	bl	8003920 <chHeapStatus>
 800e5a6:	4603      	mov	r3, r0
 800e5a8:	2b01      	cmp	r3, #1
 800e5aa:	bf14      	ite	ne
 800e5ac:	2300      	movne	r3, #0
 800e5ae:	2301      	moveq	r3, #1
 800e5b0:	b2db      	uxtb	r3, r3
 800e5b2:	2003      	movs	r0, #3
 800e5b4:	4619      	mov	r1, r3
 800e5b6:	f7fc fe7b 	bl	800b2b0 <_test_assert>
 800e5ba:	4603      	mov	r3, r0
 800e5bc:	2b00      	cmp	r3, #0
 800e5be:	d000      	beq.n	800e5c2 <dyn1_execute+0x102>
 800e5c0:	e00e      	b.n	800e5e0 <dyn1_execute+0x120>
  test_assert(4, n == sz, "heap size changed");
 800e5c2:	9a03      	ldr	r2, [sp, #12]
 800e5c4:	9b02      	ldr	r3, [sp, #8]
 800e5c6:	429a      	cmp	r2, r3
 800e5c8:	bf14      	ite	ne
 800e5ca:	2300      	movne	r3, #0
 800e5cc:	2301      	moveq	r3, #1
 800e5ce:	b2db      	uxtb	r3, r3
 800e5d0:	2004      	movs	r0, #4
 800e5d2:	4619      	mov	r1, r3
 800e5d4:	f7fc fe6c 	bl	800b2b0 <_test_assert>
 800e5d8:	4603      	mov	r3, r0
 800e5da:	2b00      	cmp	r3, #0
 800e5dc:	d000      	beq.n	800e5e0 <dyn1_execute+0x120>
 800e5de:	bf00      	nop
}
 800e5e0:	b007      	add	sp, #28
 800e5e2:	f85d fb04 	ldr.w	pc, [sp], #4
 800e5e6:	bf00      	nop
 800e5e8:	20000ba0 	.word	0x20000ba0
 800e5ec:	080168e0 	.word	0x080168e0
 800e5f0:	0800e481 	.word	0x0800e481
 800e5f4:	20001224 	.word	0x20001224
 800e5f8:	080168e4 	.word	0x080168e4
 800e5fc:	080168e8 	.word	0x080168e8
 800e600:	080168ec 	.word	0x080168ec
 800e604:	f3af 8000 	nop.w
 800e608:	f3af 8000 	nop.w
 800e60c:	f3af 8000 	nop.w

0800e610 <dyn2_setup>:
 * elements.<br>
 * The test expects the first four threads to successfully start and the last
 * one to fail.
 */

static void dyn2_setup(void) {
 800e610:	b508      	push	{r3, lr}

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
 800e612:	4803      	ldr	r0, [pc, #12]	; (800e620 <dyn2_setup+0x10>)
 800e614:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800e618:	2200      	movs	r2, #0
 800e61a:	f7f5 f9e9 	bl	80039f0 <chPoolObjectInit>
}
 800e61e:	bd08      	pop	{r3, pc}
 800e620:	20000bc0 	.word	0x20000bc0
 800e624:	f3af 8000 	nop.w
 800e628:	f3af 8000 	nop.w
 800e62c:	f3af 8000 	nop.w

0800e630 <dyn2_execute>:

static void dyn2_execute(void) {
 800e630:	b500      	push	{lr}
 800e632:	b083      	sub	sp, #12
  int i;
  tprio_t prio = chThdGetPriorityX();
 800e634:	f7ff ff1c 	bl	800e470 <chThdGetPriorityX>
 800e638:	9000      	str	r0, [sp, #0]

  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
 800e63a:	2300      	movs	r3, #0
 800e63c:	9301      	str	r3, [sp, #4]
 800e63e:	e00a      	b.n	800e656 <dyn2_execute+0x26>
    chPoolFree(&mp1, wa[i]);
 800e640:	4b4f      	ldr	r3, [pc, #316]	; (800e780 <dyn2_execute+0x150>)
 800e642:	9a01      	ldr	r2, [sp, #4]
 800e644:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800e648:	484e      	ldr	r0, [pc, #312]	; (800e784 <dyn2_execute+0x154>)
 800e64a:	4619      	mov	r1, r3
 800e64c:	f7f5 fa38 	bl	8003ac0 <chPoolFree>
static void dyn2_execute(void) {
  int i;
  tprio_t prio = chThdGetPriorityX();

  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
 800e650:	9b01      	ldr	r3, [sp, #4]
 800e652:	3301      	adds	r3, #1
 800e654:	9301      	str	r3, [sp, #4]
 800e656:	9b01      	ldr	r3, [sp, #4]
 800e658:	2b03      	cmp	r3, #3
 800e65a:	ddf1      	ble.n	800e640 <dyn2_execute+0x10>
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
 800e65c:	9b00      	ldr	r3, [sp, #0]
 800e65e:	3b01      	subs	r3, #1
 800e660:	4848      	ldr	r0, [pc, #288]	; (800e784 <dyn2_execute+0x154>)
 800e662:	4619      	mov	r1, r3
 800e664:	4a48      	ldr	r2, [pc, #288]	; (800e788 <dyn2_execute+0x158>)
 800e666:	4b49      	ldr	r3, [pc, #292]	; (800e78c <dyn2_execute+0x15c>)
 800e668:	f7f3 f922 	bl	80018b0 <chThdCreateFromMemoryPool>
 800e66c:	4602      	mov	r2, r0
 800e66e:	4b48      	ldr	r3, [pc, #288]	; (800e790 <dyn2_execute+0x160>)
 800e670:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 800e672:	9b00      	ldr	r3, [sp, #0]
 800e674:	3b02      	subs	r3, #2
 800e676:	4843      	ldr	r0, [pc, #268]	; (800e784 <dyn2_execute+0x154>)
 800e678:	4619      	mov	r1, r3
 800e67a:	4a43      	ldr	r2, [pc, #268]	; (800e788 <dyn2_execute+0x158>)
 800e67c:	4b45      	ldr	r3, [pc, #276]	; (800e794 <dyn2_execute+0x164>)
 800e67e:	f7f3 f917 	bl	80018b0 <chThdCreateFromMemoryPool>
 800e682:	4602      	mov	r2, r0
 800e684:	4b42      	ldr	r3, [pc, #264]	; (800e790 <dyn2_execute+0x160>)
 800e686:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 800e688:	9b00      	ldr	r3, [sp, #0]
 800e68a:	3b03      	subs	r3, #3
 800e68c:	483d      	ldr	r0, [pc, #244]	; (800e784 <dyn2_execute+0x154>)
 800e68e:	4619      	mov	r1, r3
 800e690:	4a3d      	ldr	r2, [pc, #244]	; (800e788 <dyn2_execute+0x158>)
 800e692:	4b41      	ldr	r3, [pc, #260]	; (800e798 <dyn2_execute+0x168>)
 800e694:	f7f3 f90c 	bl	80018b0 <chThdCreateFromMemoryPool>
 800e698:	4602      	mov	r2, r0
 800e69a:	4b3d      	ldr	r3, [pc, #244]	; (800e790 <dyn2_execute+0x160>)
 800e69c:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 800e69e:	9b00      	ldr	r3, [sp, #0]
 800e6a0:	3b04      	subs	r3, #4
 800e6a2:	4838      	ldr	r0, [pc, #224]	; (800e784 <dyn2_execute+0x154>)
 800e6a4:	4619      	mov	r1, r3
 800e6a6:	4a38      	ldr	r2, [pc, #224]	; (800e788 <dyn2_execute+0x158>)
 800e6a8:	4b3c      	ldr	r3, [pc, #240]	; (800e79c <dyn2_execute+0x16c>)
 800e6aa:	f7f3 f901 	bl	80018b0 <chThdCreateFromMemoryPool>
 800e6ae:	4602      	mov	r2, r0
 800e6b0:	4b37      	ldr	r3, [pc, #220]	; (800e790 <dyn2_execute+0x160>)
 800e6b2:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 800e6b4:	9b00      	ldr	r3, [sp, #0]
 800e6b6:	3b05      	subs	r3, #5
 800e6b8:	4832      	ldr	r0, [pc, #200]	; (800e784 <dyn2_execute+0x154>)
 800e6ba:	4619      	mov	r1, r3
 800e6bc:	4a32      	ldr	r2, [pc, #200]	; (800e788 <dyn2_execute+0x158>)
 800e6be:	4b38      	ldr	r3, [pc, #224]	; (800e7a0 <dyn2_execute+0x170>)
 800e6c0:	f7f3 f8f6 	bl	80018b0 <chThdCreateFromMemoryPool>
 800e6c4:	4602      	mov	r2, r0
 800e6c6:	4b32      	ldr	r3, [pc, #200]	; (800e790 <dyn2_execute+0x160>)
 800e6c8:	611a      	str	r2, [r3, #16]

  test_assert(1, (threads[0] != NULL) &&
 800e6ca:	4b31      	ldr	r3, [pc, #196]	; (800e790 <dyn2_execute+0x160>)
 800e6cc:	681b      	ldr	r3, [r3, #0]
 800e6ce:	2b00      	cmp	r3, #0
 800e6d0:	d011      	beq.n	800e6f6 <dyn2_execute+0xc6>
 800e6d2:	4b2f      	ldr	r3, [pc, #188]	; (800e790 <dyn2_execute+0x160>)
 800e6d4:	685b      	ldr	r3, [r3, #4]
 800e6d6:	2b00      	cmp	r3, #0
 800e6d8:	d00d      	beq.n	800e6f6 <dyn2_execute+0xc6>
 800e6da:	4b2d      	ldr	r3, [pc, #180]	; (800e790 <dyn2_execute+0x160>)
 800e6dc:	689b      	ldr	r3, [r3, #8]
 800e6de:	2b00      	cmp	r3, #0
 800e6e0:	d009      	beq.n	800e6f6 <dyn2_execute+0xc6>
 800e6e2:	4b2b      	ldr	r3, [pc, #172]	; (800e790 <dyn2_execute+0x160>)
 800e6e4:	68db      	ldr	r3, [r3, #12]
 800e6e6:	2b00      	cmp	r3, #0
 800e6e8:	d005      	beq.n	800e6f6 <dyn2_execute+0xc6>
 800e6ea:	4b29      	ldr	r3, [pc, #164]	; (800e790 <dyn2_execute+0x160>)
 800e6ec:	691b      	ldr	r3, [r3, #16]
 800e6ee:	2b00      	cmp	r3, #0
 800e6f0:	d101      	bne.n	800e6f6 <dyn2_execute+0xc6>
 800e6f2:	2301      	movs	r3, #1
 800e6f4:	e000      	b.n	800e6f8 <dyn2_execute+0xc8>
 800e6f6:	2300      	movs	r3, #0
 800e6f8:	f003 0301 	and.w	r3, r3, #1
 800e6fc:	b2db      	uxtb	r3, r3
 800e6fe:	2001      	movs	r0, #1
 800e700:	4619      	mov	r1, r3
 800e702:	f7fc fdd5 	bl	800b2b0 <_test_assert>
 800e706:	4603      	mov	r3, r0
 800e708:	2b00      	cmp	r3, #0
 800e70a:	d000      	beq.n	800e70e <dyn2_execute+0xde>
 800e70c:	e034      	b.n	800e778 <dyn2_execute+0x148>
                 (threads[3] != NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 800e70e:	f7fc fe4f 	bl	800b3b0 <test_wait_threads>
  test_assert_sequence(2, "ABCD");
 800e712:	2002      	movs	r0, #2
 800e714:	4923      	ldr	r1, [pc, #140]	; (800e7a4 <dyn2_execute+0x174>)
 800e716:	f7fc fde3 	bl	800b2e0 <_test_assert_sequence>
 800e71a:	4603      	mov	r3, r0
 800e71c:	2b00      	cmp	r3, #0
 800e71e:	d000      	beq.n	800e722 <dyn2_execute+0xf2>
 800e720:	e02a      	b.n	800e778 <dyn2_execute+0x148>

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
 800e722:	2300      	movs	r3, #0
 800e724:	9301      	str	r3, [sp, #4]
 800e726:	e013      	b.n	800e750 <dyn2_execute+0x120>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
 800e728:	4816      	ldr	r0, [pc, #88]	; (800e784 <dyn2_execute+0x154>)
 800e72a:	f7f5 f9a9 	bl	8003a80 <chPoolAlloc>
 800e72e:	4603      	mov	r3, r0
 800e730:	2b00      	cmp	r3, #0
 800e732:	bf0c      	ite	eq
 800e734:	2300      	moveq	r3, #0
 800e736:	2301      	movne	r3, #1
 800e738:	b2db      	uxtb	r3, r3
 800e73a:	2003      	movs	r0, #3
 800e73c:	4619      	mov	r1, r3
 800e73e:	f7fc fdb7 	bl	800b2b0 <_test_assert>
 800e742:	4603      	mov	r3, r0
 800e744:	2b00      	cmp	r3, #0
 800e746:	d000      	beq.n	800e74a <dyn2_execute+0x11a>
 800e748:	e016      	b.n	800e778 <dyn2_execute+0x148>
  /* Claiming the memory from terminated threads. */
  test_wait_threads();
  test_assert_sequence(2, "ABCD");

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
 800e74a:	9b01      	ldr	r3, [sp, #4]
 800e74c:	3301      	adds	r3, #1
 800e74e:	9301      	str	r3, [sp, #4]
 800e750:	9b01      	ldr	r3, [sp, #4]
 800e752:	2b03      	cmp	r3, #3
 800e754:	dde8      	ble.n	800e728 <dyn2_execute+0xf8>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
  test_assert(4, chPoolAlloc(&mp1) == NULL, "pool list not empty");
 800e756:	480b      	ldr	r0, [pc, #44]	; (800e784 <dyn2_execute+0x154>)
 800e758:	f7f5 f992 	bl	8003a80 <chPoolAlloc>
 800e75c:	4603      	mov	r3, r0
 800e75e:	2b00      	cmp	r3, #0
 800e760:	bf14      	ite	ne
 800e762:	2300      	movne	r3, #0
 800e764:	2301      	moveq	r3, #1
 800e766:	b2db      	uxtb	r3, r3
 800e768:	2004      	movs	r0, #4
 800e76a:	4619      	mov	r1, r3
 800e76c:	f7fc fda0 	bl	800b2b0 <_test_assert>
 800e770:	4603      	mov	r3, r0
 800e772:	2b00      	cmp	r3, #0
 800e774:	d000      	beq.n	800e778 <dyn2_execute+0x148>
 800e776:	bf00      	nop
}
 800e778:	b003      	add	sp, #12
 800e77a:	f85d fb04 	ldr.w	pc, [sp], #4
 800e77e:	bf00      	nop
 800e780:	08016240 	.word	0x08016240
 800e784:	20000bc0 	.word	0x20000bc0
 800e788:	0800e481 	.word	0x0800e481
 800e78c:	080168e0 	.word	0x080168e0
 800e790:	20001224 	.word	0x20001224
 800e794:	080168e4 	.word	0x080168e4
 800e798:	080168e8 	.word	0x080168e8
 800e79c:	0801692c 	.word	0x0801692c
 800e7a0:	08016930 	.word	0x08016930
 800e7a4:	08016934 	.word	0x08016934
 800e7a8:	f3af 8000 	nop.w
 800e7ac:	f3af 8000 	nop.w

0800e7b0 <regfind>:
 * <h2>Description</h2>
 * Registry and Thread References APIs are tested for functionality and
 * coverage.
 */

static bool regfind(thread_t *tp) {
 800e7b0:	b500      	push	{lr}
 800e7b2:	b085      	sub	sp, #20
 800e7b4:	9001      	str	r0, [sp, #4]
  thread_t *ftp;
  bool found = false;
 800e7b6:	2300      	movs	r3, #0
 800e7b8:	f88d 300b 	strb.w	r3, [sp, #11]

  ftp = chRegFirstThread();
 800e7bc:	f7f3 f8c8 	bl	8001950 <chRegFirstThread>
 800e7c0:	9003      	str	r0, [sp, #12]
  do {
    found |= ftp == tp;
 800e7c2:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800e7c6:	9903      	ldr	r1, [sp, #12]
 800e7c8:	9b01      	ldr	r3, [sp, #4]
 800e7ca:	4299      	cmp	r1, r3
 800e7cc:	bf14      	ite	ne
 800e7ce:	2300      	movne	r3, #0
 800e7d0:	2301      	moveq	r3, #1
 800e7d2:	b2db      	uxtb	r3, r3
 800e7d4:	4313      	orrs	r3, r2
 800e7d6:	2b00      	cmp	r3, #0
 800e7d8:	bf0c      	ite	eq
 800e7da:	2300      	moveq	r3, #0
 800e7dc:	2301      	movne	r3, #1
 800e7de:	f88d 300b 	strb.w	r3, [sp, #11]
    ftp = chRegNextThread(ftp);
 800e7e2:	9803      	ldr	r0, [sp, #12]
 800e7e4:	f7f3 f8cc 	bl	8001980 <chRegNextThread>
 800e7e8:	9003      	str	r0, [sp, #12]
  } while (ftp != NULL);
 800e7ea:	9b03      	ldr	r3, [sp, #12]
 800e7ec:	2b00      	cmp	r3, #0
 800e7ee:	d1e8      	bne.n	800e7c2 <regfind+0x12>
  return found;
 800e7f0:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 800e7f4:	4618      	mov	r0, r3
 800e7f6:	b005      	add	sp, #20
 800e7f8:	f85d fb04 	ldr.w	pc, [sp], #4
 800e7fc:	f3af 8000 	nop.w

0800e800 <dyn3_setup>:

static void dyn3_setup(void) {
 800e800:	b508      	push	{r3, lr}

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
 800e802:	4803      	ldr	r0, [pc, #12]	; (800e810 <dyn3_setup+0x10>)
 800e804:	4903      	ldr	r1, [pc, #12]	; (800e814 <dyn3_setup+0x14>)
 800e806:	f44f 62cd 	mov.w	r2, #1640	; 0x668
 800e80a:	f7f4 ff89 	bl	8003720 <chHeapObjectInit>
}
 800e80e:	bd08      	pop	{r3, pc}
 800e810:	20000ba0 	.word	0x20000ba0
 800e814:	20001238 	.word	0x20001238
 800e818:	f3af 8000 	nop.w
 800e81c:	f3af 8000 	nop.w

0800e820 <dyn3_execute>:

static void dyn3_execute(void) {
 800e820:	b500      	push	{lr}
 800e822:	b085      	sub	sp, #20
  thread_t *tp;
  tprio_t prio = chThdGetPriorityX();
 800e824:	f7ff fe24 	bl	800e470 <chThdGetPriorityX>
 800e828:	9003      	str	r0, [sp, #12]

  /* Testing references increase/decrease and final detach.*/
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
 800e82a:	9b03      	ldr	r3, [sp, #12]
 800e82c:	3b01      	subs	r3, #1
 800e82e:	4a63      	ldr	r2, [pc, #396]	; (800e9bc <dyn3_execute+0x19c>)
 800e830:	9200      	str	r2, [sp, #0]
 800e832:	4863      	ldr	r0, [pc, #396]	; (800e9c0 <dyn3_execute+0x1a0>)
 800e834:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800e838:	461a      	mov	r2, r3
 800e83a:	4b62      	ldr	r3, [pc, #392]	; (800e9c4 <dyn3_execute+0x1a4>)
 800e83c:	f7f3 f808 	bl	8001850 <chThdCreateFromHeap>
 800e840:	9002      	str	r0, [sp, #8]
  test_assert(1, tp->p_refs == 1, "wrong initial reference counter");
 800e842:	9b02      	ldr	r3, [sp, #8]
 800e844:	7f9b      	ldrb	r3, [r3, #30]
 800e846:	2b01      	cmp	r3, #1
 800e848:	bf14      	ite	ne
 800e84a:	2300      	movne	r3, #0
 800e84c:	2301      	moveq	r3, #1
 800e84e:	b2db      	uxtb	r3, r3
 800e850:	2001      	movs	r0, #1
 800e852:	4619      	mov	r1, r3
 800e854:	f7fc fd2c 	bl	800b2b0 <_test_assert>
 800e858:	4603      	mov	r3, r0
 800e85a:	2b00      	cmp	r3, #0
 800e85c:	d000      	beq.n	800e860 <dyn3_execute+0x40>
 800e85e:	e0a9      	b.n	800e9b4 <dyn3_execute+0x194>
  chThdAddRef(tp);
 800e860:	9802      	ldr	r0, [sp, #8]
 800e862:	f7f2 ff95 	bl	8001790 <chThdAddRef>
  test_assert(2, tp->p_refs == 2, "references increase failure");
 800e866:	9b02      	ldr	r3, [sp, #8]
 800e868:	7f9b      	ldrb	r3, [r3, #30]
 800e86a:	2b02      	cmp	r3, #2
 800e86c:	bf14      	ite	ne
 800e86e:	2300      	movne	r3, #0
 800e870:	2301      	moveq	r3, #1
 800e872:	b2db      	uxtb	r3, r3
 800e874:	2002      	movs	r0, #2
 800e876:	4619      	mov	r1, r3
 800e878:	f7fc fd1a 	bl	800b2b0 <_test_assert>
 800e87c:	4603      	mov	r3, r0
 800e87e:	2b00      	cmp	r3, #0
 800e880:	d000      	beq.n	800e884 <dyn3_execute+0x64>
 800e882:	e097      	b.n	800e9b4 <dyn3_execute+0x194>
  chThdRelease(tp);
 800e884:	9802      	ldr	r0, [sp, #8]
 800e886:	f7f2 ff9b 	bl	80017c0 <chThdRelease>
  test_assert(3, tp->p_refs == 1, "references decrease failure");
 800e88a:	9b02      	ldr	r3, [sp, #8]
 800e88c:	7f9b      	ldrb	r3, [r3, #30]
 800e88e:	2b01      	cmp	r3, #1
 800e890:	bf14      	ite	ne
 800e892:	2300      	movne	r3, #0
 800e894:	2301      	moveq	r3, #1
 800e896:	b2db      	uxtb	r3, r3
 800e898:	2003      	movs	r0, #3
 800e89a:	4619      	mov	r1, r3
 800e89c:	f7fc fd08 	bl	800b2b0 <_test_assert>
 800e8a0:	4603      	mov	r3, r0
 800e8a2:	2b00      	cmp	r3, #0
 800e8a4:	d000      	beq.n	800e8a8 <dyn3_execute+0x88>
 800e8a6:	e085      	b.n	800e9b4 <dyn3_execute+0x194>

  /* Verify the new threads count.*/
  test_assert(4, regfind(tp), "thread missing from registry");
 800e8a8:	9802      	ldr	r0, [sp, #8]
 800e8aa:	f7ff ff81 	bl	800e7b0 <regfind>
 800e8ae:	4603      	mov	r3, r0
 800e8b0:	2004      	movs	r0, #4
 800e8b2:	4619      	mov	r1, r3
 800e8b4:	f7fc fcfc 	bl	800b2b0 <_test_assert>
 800e8b8:	4603      	mov	r3, r0
 800e8ba:	2b00      	cmp	r3, #0
 800e8bc:	d000      	beq.n	800e8c0 <dyn3_execute+0xa0>
 800e8be:	e079      	b.n	800e9b4 <dyn3_execute+0x194>
  test_assert(5, regfind(tp), "thread disappeared");
 800e8c0:	9802      	ldr	r0, [sp, #8]
 800e8c2:	f7ff ff75 	bl	800e7b0 <regfind>
 800e8c6:	4603      	mov	r3, r0
 800e8c8:	2005      	movs	r0, #5
 800e8ca:	4619      	mov	r1, r3
 800e8cc:	f7fc fcf0 	bl	800b2b0 <_test_assert>
 800e8d0:	4603      	mov	r3, r0
 800e8d2:	2b00      	cmp	r3, #0
 800e8d4:	d000      	beq.n	800e8d8 <dyn3_execute+0xb8>
 800e8d6:	e06d      	b.n	800e9b4 <dyn3_execute+0x194>

  /* Detach and let the thread execute and terminate.*/
  chThdRelease(tp);
 800e8d8:	9802      	ldr	r0, [sp, #8]
 800e8da:	f7f2 ff71 	bl	80017c0 <chThdRelease>
  test_assert(6, tp->p_refs == 0, "detach failure");
 800e8de:	9b02      	ldr	r3, [sp, #8]
 800e8e0:	7f9b      	ldrb	r3, [r3, #30]
 800e8e2:	2b00      	cmp	r3, #0
 800e8e4:	bf14      	ite	ne
 800e8e6:	2300      	movne	r3, #0
 800e8e8:	2301      	moveq	r3, #1
 800e8ea:	b2db      	uxtb	r3, r3
 800e8ec:	2006      	movs	r0, #6
 800e8ee:	4619      	mov	r1, r3
 800e8f0:	f7fc fcde 	bl	800b2b0 <_test_assert>
 800e8f4:	4603      	mov	r3, r0
 800e8f6:	2b00      	cmp	r3, #0
 800e8f8:	d000      	beq.n	800e8fc <dyn3_execute+0xdc>
 800e8fa:	e05b      	b.n	800e9b4 <dyn3_execute+0x194>
  test_assert(7, tp->p_state == CH_STATE_READY, "invalid state");
 800e8fc:	9b02      	ldr	r3, [sp, #8]
 800e8fe:	7f1b      	ldrb	r3, [r3, #28]
 800e900:	2b00      	cmp	r3, #0
 800e902:	bf14      	ite	ne
 800e904:	2300      	movne	r3, #0
 800e906:	2301      	moveq	r3, #1
 800e908:	b2db      	uxtb	r3, r3
 800e90a:	2007      	movs	r0, #7
 800e90c:	4619      	mov	r1, r3
 800e90e:	f7fc fccf 	bl	800b2b0 <_test_assert>
 800e912:	4603      	mov	r3, r0
 800e914:	2b00      	cmp	r3, #0
 800e916:	d000      	beq.n	800e91a <dyn3_execute+0xfa>
 800e918:	e04c      	b.n	800e9b4 <dyn3_execute+0x194>
  test_assert(8, regfind(tp), "thread disappeared");
 800e91a:	9802      	ldr	r0, [sp, #8]
 800e91c:	f7ff ff48 	bl	800e7b0 <regfind>
 800e920:	4603      	mov	r3, r0
 800e922:	2008      	movs	r0, #8
 800e924:	4619      	mov	r1, r3
 800e926:	f7fc fcc3 	bl	800b2b0 <_test_assert>
 800e92a:	4603      	mov	r3, r0
 800e92c:	2b00      	cmp	r3, #0
 800e92e:	d000      	beq.n	800e932 <dyn3_execute+0x112>
 800e930:	e040      	b.n	800e9b4 <dyn3_execute+0x194>
  test_assert(9, regfind(tp), "thread disappeared");
 800e932:	9802      	ldr	r0, [sp, #8]
 800e934:	f7ff ff3c 	bl	800e7b0 <regfind>
 800e938:	4603      	mov	r3, r0
 800e93a:	2009      	movs	r0, #9
 800e93c:	4619      	mov	r1, r3
 800e93e:	f7fc fcb7 	bl	800b2b0 <_test_assert>
 800e942:	4603      	mov	r3, r0
 800e944:	2b00      	cmp	r3, #0
 800e946:	d000      	beq.n	800e94a <dyn3_execute+0x12a>
 800e948:	e034      	b.n	800e9b4 <dyn3_execute+0x194>
  chThdSleepMilliseconds(50);           /* The thread just terminates.      */
 800e94a:	2032      	movs	r0, #50	; 0x32
 800e94c:	f7f2 fcc0 	bl	80012d0 <chThdSleep>
  test_assert(10, tp->p_state == CH_STATE_FINAL, "invalid state");
 800e950:	9b02      	ldr	r3, [sp, #8]
 800e952:	7f1b      	ldrb	r3, [r3, #28]
 800e954:	2b0f      	cmp	r3, #15
 800e956:	bf14      	ite	ne
 800e958:	2300      	movne	r3, #0
 800e95a:	2301      	moveq	r3, #1
 800e95c:	b2db      	uxtb	r3, r3
 800e95e:	200a      	movs	r0, #10
 800e960:	4619      	mov	r1, r3
 800e962:	f7fc fca5 	bl	800b2b0 <_test_assert>
 800e966:	4603      	mov	r3, r0
 800e968:	2b00      	cmp	r3, #0
 800e96a:	d000      	beq.n	800e96e <dyn3_execute+0x14e>
 800e96c:	e022      	b.n	800e9b4 <dyn3_execute+0x194>

  /* Clearing the zombie by scanning the registry.*/
  test_assert(11, regfind(tp), "thread disappeared");
 800e96e:	9802      	ldr	r0, [sp, #8]
 800e970:	f7ff ff1e 	bl	800e7b0 <regfind>
 800e974:	4603      	mov	r3, r0
 800e976:	200b      	movs	r0, #11
 800e978:	4619      	mov	r1, r3
 800e97a:	f7fc fc99 	bl	800b2b0 <_test_assert>
 800e97e:	4603      	mov	r3, r0
 800e980:	2b00      	cmp	r3, #0
 800e982:	d000      	beq.n	800e986 <dyn3_execute+0x166>
 800e984:	e016      	b.n	800e9b4 <dyn3_execute+0x194>
  test_assert(12, !regfind(tp), "thread still in registry");
 800e986:	9802      	ldr	r0, [sp, #8]
 800e988:	f7ff ff12 	bl	800e7b0 <regfind>
 800e98c:	4603      	mov	r3, r0
 800e98e:	2b00      	cmp	r3, #0
 800e990:	bf0c      	ite	eq
 800e992:	2300      	moveq	r3, #0
 800e994:	2301      	movne	r3, #1
 800e996:	b2db      	uxtb	r3, r3
 800e998:	f083 0301 	eor.w	r3, r3, #1
 800e99c:	b2db      	uxtb	r3, r3
 800e99e:	f003 0301 	and.w	r3, r3, #1
 800e9a2:	b2db      	uxtb	r3, r3
 800e9a4:	200c      	movs	r0, #12
 800e9a6:	4619      	mov	r1, r3
 800e9a8:	f7fc fc82 	bl	800b2b0 <_test_assert>
 800e9ac:	4603      	mov	r3, r0
 800e9ae:	2b00      	cmp	r3, #0
 800e9b0:	d000      	beq.n	800e9b4 <dyn3_execute+0x194>
 800e9b2:	bf00      	nop
}
 800e9b4:	b005      	add	sp, #20
 800e9b6:	f85d fb04 	ldr.w	pc, [sp], #4
 800e9ba:	bf00      	nop
 800e9bc:	080168e0 	.word	0x080168e0
 800e9c0:	20000ba0 	.word	0x20000ba0
 800e9c4:	0800e481 	.word	0x0800e481
 800e9c8:	f3af 8000 	nop.w
 800e9cc:	f3af 8000 	nop.w

0800e9d0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800e9d0:	b082      	sub	sp, #8
 800e9d2:	2320      	movs	r3, #32
 800e9d4:	9301      	str	r3, [sp, #4]
 800e9d6:	9b01      	ldr	r3, [sp, #4]
 800e9d8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800e9dc:	b002      	add	sp, #8
 800e9de:	4770      	bx	lr

0800e9e0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800e9e0:	b082      	sub	sp, #8
 800e9e2:	2300      	movs	r3, #0
 800e9e4:	9301      	str	r3, [sp, #4]
 800e9e6:	9b01      	ldr	r3, [sp, #4]
 800e9e8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800e9ec:	b002      	add	sp, #8
 800e9ee:	4770      	bx	lr

0800e9f0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800e9f0:	b508      	push	{r3, lr}

  port_lock();
 800e9f2:	f7ff ffed 	bl	800e9d0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800e9f6:	bd08      	pop	{r3, pc}
 800e9f8:	f3af 8000 	nop.w
 800e9fc:	f3af 8000 	nop.w

0800ea00 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800ea00:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800ea02:	f7ff ffed 	bl	800e9e0 <port_unlock>
}
 800ea06:	bd08      	pop	{r3, pc}
 800ea08:	f3af 8000 	nop.w
 800ea0c:	f3af 8000 	nop.w

0800ea10 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800ea10:	4b01      	ldr	r3, [pc, #4]	; (800ea18 <chThdGetSelfX+0x8>)
 800ea12:	699b      	ldr	r3, [r3, #24]
}
 800ea14:	4618      	mov	r0, r3
 800ea16:	4770      	bx	lr
 800ea18:	20000d98 	.word	0x20000d98
 800ea1c:	f3af 8000 	nop.w

0800ea20 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800ea20:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800ea22:	f7ff fff5 	bl	800ea10 <chThdGetSelfX>
 800ea26:	4603      	mov	r3, r0
 800ea28:	689b      	ldr	r3, [r3, #8]
}
 800ea2a:	4618      	mov	r0, r3
 800ea2c:	bd08      	pop	{r3, pc}
 800ea2e:	bf00      	nop

0800ea30 <chIQGetFullI>:
 * @return              The number of full bytes in the queue.
 * @retval 0            if the queue is empty.
 *
 * @iclass
 */
static inline size_t chIQGetFullI(input_queue_t *iqp) {
 800ea30:	b082      	sub	sp, #8
 800ea32:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (size_t)chQSpaceI(iqp);
 800ea34:	9b01      	ldr	r3, [sp, #4]
 800ea36:	689b      	ldr	r3, [r3, #8]
}
 800ea38:	4618      	mov	r0, r3
 800ea3a:	b002      	add	sp, #8
 800ea3c:	4770      	bx	lr
 800ea3e:	bf00      	nop

0800ea40 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 800ea40:	b082      	sub	sp, #8
 800ea42:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 800ea44:	9b01      	ldr	r3, [sp, #4]
 800ea46:	689b      	ldr	r3, [r3, #8]
 800ea48:	2b00      	cmp	r3, #0
 800ea4a:	bf14      	ite	ne
 800ea4c:	2300      	movne	r3, #0
 800ea4e:	2301      	moveq	r3, #1
 800ea50:	b2db      	uxtb	r3, r3
}
 800ea52:	4618      	mov	r0, r3
 800ea54:	b002      	add	sp, #8
 800ea56:	4770      	bx	lr
 800ea58:	f3af 8000 	nop.w
 800ea5c:	f3af 8000 	nop.w

0800ea60 <chIQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {
 800ea60:	b082      	sub	sp, #8
 800ea62:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 800ea64:	9b01      	ldr	r3, [sp, #4]
 800ea66:	695a      	ldr	r2, [r3, #20]
 800ea68:	9b01      	ldr	r3, [sp, #4]
 800ea6a:	699b      	ldr	r3, [r3, #24]
 800ea6c:	429a      	cmp	r2, r3
 800ea6e:	d105      	bne.n	800ea7c <chIQIsFullI+0x1c>
 800ea70:	9b01      	ldr	r3, [sp, #4]
 800ea72:	689b      	ldr	r3, [r3, #8]
 800ea74:	2b00      	cmp	r3, #0
 800ea76:	d001      	beq.n	800ea7c <chIQIsFullI+0x1c>
 800ea78:	2301      	movs	r3, #1
 800ea7a:	e000      	b.n	800ea7e <chIQIsFullI+0x1e>
 800ea7c:	2300      	movs	r3, #0
 800ea7e:	f003 0301 	and.w	r3, r3, #1
 800ea82:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 800ea84:	4618      	mov	r0, r3
 800ea86:	b002      	add	sp, #8
 800ea88:	4770      	bx	lr
 800ea8a:	bf00      	nop
 800ea8c:	f3af 8000 	nop.w

0800ea90 <chIQGet>:
 * @return              A byte value from the queue.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {
 800ea90:	b500      	push	{lr}
 800ea92:	b083      	sub	sp, #12
 800ea94:	9001      	str	r0, [sp, #4]

  return chIQGetTimeout(iqp, TIME_INFINITE);
 800ea96:	9801      	ldr	r0, [sp, #4]
 800ea98:	f04f 31ff 	mov.w	r1, #4294967295
 800ea9c:	f7f4 fbf0 	bl	8003280 <chIQGetTimeout>
 800eaa0:	4603      	mov	r3, r0
}
 800eaa2:	4618      	mov	r0, r3
 800eaa4:	b003      	add	sp, #12
 800eaa6:	f85d fb04 	ldr.w	pc, [sp], #4
 800eaaa:	bf00      	nop
 800eaac:	f3af 8000 	nop.w

0800eab0 <chOQGetFullI>:
 * @return              The number of full bytes in the queue.
 * @retval 0            if the queue is empty.
 *
 * @iclass
 */
static inline size_t chOQGetFullI(output_queue_t *oqp) {
 800eab0:	b082      	sub	sp, #8
 800eab2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (size_t)(chQSizeX(oqp) - chQSpaceI(oqp));
 800eab4:	9b01      	ldr	r3, [sp, #4]
 800eab6:	691b      	ldr	r3, [r3, #16]
 800eab8:	461a      	mov	r2, r3
 800eaba:	9b01      	ldr	r3, [sp, #4]
 800eabc:	68db      	ldr	r3, [r3, #12]
 800eabe:	1ad3      	subs	r3, r2, r3
 800eac0:	461a      	mov	r2, r3
 800eac2:	9b01      	ldr	r3, [sp, #4]
 800eac4:	689b      	ldr	r3, [r3, #8]
 800eac6:	1ad3      	subs	r3, r2, r3
}
 800eac8:	4618      	mov	r0, r3
 800eaca:	b002      	add	sp, #8
 800eacc:	4770      	bx	lr
 800eace:	bf00      	nop

0800ead0 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 800ead0:	b082      	sub	sp, #8
 800ead2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 800ead4:	9b01      	ldr	r3, [sp, #4]
 800ead6:	695a      	ldr	r2, [r3, #20]
 800ead8:	9b01      	ldr	r3, [sp, #4]
 800eada:	699b      	ldr	r3, [r3, #24]
 800eadc:	429a      	cmp	r2, r3
 800eade:	d105      	bne.n	800eaec <chOQIsEmptyI+0x1c>
 800eae0:	9b01      	ldr	r3, [sp, #4]
 800eae2:	689b      	ldr	r3, [r3, #8]
 800eae4:	2b00      	cmp	r3, #0
 800eae6:	d001      	beq.n	800eaec <chOQIsEmptyI+0x1c>
 800eae8:	2301      	movs	r3, #1
 800eaea:	e000      	b.n	800eaee <chOQIsEmptyI+0x1e>
 800eaec:	2300      	movs	r3, #0
 800eaee:	f003 0301 	and.w	r3, r3, #1
 800eaf2:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 800eaf4:	4618      	mov	r0, r3
 800eaf6:	b002      	add	sp, #8
 800eaf8:	4770      	bx	lr
 800eafa:	bf00      	nop
 800eafc:	f3af 8000 	nop.w

0800eb00 <chOQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
 800eb00:	b082      	sub	sp, #8
 800eb02:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 800eb04:	9b01      	ldr	r3, [sp, #4]
 800eb06:	689b      	ldr	r3, [r3, #8]
 800eb08:	2b00      	cmp	r3, #0
 800eb0a:	bf14      	ite	ne
 800eb0c:	2300      	movne	r3, #0
 800eb0e:	2301      	moveq	r3, #1
 800eb10:	b2db      	uxtb	r3, r3
}
 800eb12:	4618      	mov	r0, r3
 800eb14:	b002      	add	sp, #8
 800eb16:	4770      	bx	lr
 800eb18:	f3af 8000 	nop.w
 800eb1c:	f3af 8000 	nop.w

0800eb20 <chOQPut>:
 * @retval Q_OK         if the operation succeeded.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
static inline msg_t chOQPut(output_queue_t *oqp, uint8_t b) {
 800eb20:	b500      	push	{lr}
 800eb22:	b083      	sub	sp, #12
 800eb24:	9001      	str	r0, [sp, #4]
 800eb26:	460b      	mov	r3, r1
 800eb28:	f88d 3003 	strb.w	r3, [sp, #3]

  return chOQPutTimeout(oqp, b, TIME_INFINITE);
 800eb2c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800eb30:	9801      	ldr	r0, [sp, #4]
 800eb32:	4619      	mov	r1, r3
 800eb34:	f04f 32ff 	mov.w	r2, #4294967295
 800eb38:	f7f4 fc8a 	bl	8003450 <chOQPutTimeout>
 800eb3c:	4603      	mov	r3, r0
}
 800eb3e:	4618      	mov	r0, r3
 800eb40:	b003      	add	sp, #12
 800eb42:	f85d fb04 	ldr.w	pc, [sp], #4
 800eb46:	bf00      	nop
 800eb48:	f3af 8000 	nop.w
 800eb4c:	f3af 8000 	nop.w

0800eb50 <notify>:

#if CH_CFG_USE_QUEUES || defined(__DOXYGEN__)

#define TEST_QUEUES_SIZE 4

static void notify(io_queue_t *qp) {
 800eb50:	b082      	sub	sp, #8
 800eb52:	9001      	str	r0, [sp, #4]
  (void)qp;
}
 800eb54:	b002      	add	sp, #8
 800eb56:	4770      	bx	lr
 800eb58:	f3af 8000 	nop.w
 800eb5c:	f3af 8000 	nop.w

0800eb60 <queues1_setup>:
 * This test case tests synchronous and asynchronous operations on an
 * @p InputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues1_setup(void) {
 800eb60:	b500      	push	{lr}
 800eb62:	b083      	sub	sp, #12

  chIQObjectInit(&iq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
 800eb64:	4b06      	ldr	r3, [pc, #24]	; (800eb80 <queues1_setup+0x20>)
 800eb66:	681b      	ldr	r3, [r3, #0]
 800eb68:	2200      	movs	r2, #0
 800eb6a:	9200      	str	r2, [sp, #0]
 800eb6c:	4805      	ldr	r0, [pc, #20]	; (800eb84 <queues1_setup+0x24>)
 800eb6e:	4619      	mov	r1, r3
 800eb70:	2204      	movs	r2, #4
 800eb72:	4b05      	ldr	r3, [pc, #20]	; (800eb88 <queues1_setup+0x28>)
 800eb74:	f7f4 fb14 	bl	80031a0 <chIQObjectInit>
}
 800eb78:	b003      	add	sp, #12
 800eb7a:	f85d fb04 	ldr.w	pc, [sp], #4
 800eb7e:	bf00      	nop
 800eb80:	08016240 	.word	0x08016240
 800eb84:	200008a8 	.word	0x200008a8
 800eb88:	0800eb51 	.word	0x0800eb51
 800eb8c:	f3af 8000 	nop.w

0800eb90 <thread1>:

static THD_FUNCTION(thread1, p) {
 800eb90:	b500      	push	{lr}
 800eb92:	b083      	sub	sp, #12
 800eb94:	9001      	str	r0, [sp, #4]

  (void)p;
  chIQGetTimeout(&iq, MS2ST(200));
 800eb96:	4803      	ldr	r0, [pc, #12]	; (800eba4 <thread1+0x14>)
 800eb98:	21c8      	movs	r1, #200	; 0xc8
 800eb9a:	f7f4 fb71 	bl	8003280 <chIQGetTimeout>
}
 800eb9e:	b003      	add	sp, #12
 800eba0:	f85d fb04 	ldr.w	pc, [sp], #4
 800eba4:	200008a8 	.word	0x200008a8
 800eba8:	f3af 8000 	nop.w
 800ebac:	f3af 8000 	nop.w

0800ebb0 <queues1_execute>:

static void queues1_execute(void) {
 800ebb0:	b510      	push	{r4, lr}
 800ebb2:	b084      	sub	sp, #16
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");
 800ebb4:	f7ff ff1c 	bl	800e9f0 <chSysLock>
 800ebb8:	48ab      	ldr	r0, [pc, #684]	; (800ee68 <queues1_execute+0x2b8>)
 800ebba:	f7ff ff41 	bl	800ea40 <chIQIsEmptyI>
 800ebbe:	4603      	mov	r3, r0
 800ebc0:	2001      	movs	r0, #1
 800ebc2:	4619      	mov	r1, r3
 800ebc4:	f7fc fb74 	bl	800b2b0 <_test_assert>
 800ebc8:	4603      	mov	r3, r0
 800ebca:	2b00      	cmp	r3, #0
 800ebcc:	d002      	beq.n	800ebd4 <queues1_execute+0x24>
 800ebce:	f7ff ff17 	bl	800ea00 <chSysUnlock>
 800ebd2:	e16a      	b.n	800eeaa <queues1_execute+0x2fa>
 800ebd4:	f7ff ff14 	bl	800ea00 <chSysUnlock>

  /* Queue filling */
  chSysLock();
 800ebd8:	f7ff ff0a 	bl	800e9f0 <chSysLock>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800ebdc:	2300      	movs	r3, #0
 800ebde:	9303      	str	r3, [sp, #12]
 800ebe0:	e00a      	b.n	800ebf8 <queues1_execute+0x48>
    chIQPutI(&iq, 'A' + i);
 800ebe2:	9b03      	ldr	r3, [sp, #12]
 800ebe4:	b2db      	uxtb	r3, r3
 800ebe6:	3341      	adds	r3, #65	; 0x41
 800ebe8:	b2db      	uxtb	r3, r3
 800ebea:	489f      	ldr	r0, [pc, #636]	; (800ee68 <queues1_execute+0x2b8>)
 800ebec:	4619      	mov	r1, r3
 800ebee:	f7f4 fb17 	bl	8003220 <chIQPutI>
  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");

  /* Queue filling */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800ebf2:	9b03      	ldr	r3, [sp, #12]
 800ebf4:	3301      	adds	r3, #1
 800ebf6:	9303      	str	r3, [sp, #12]
 800ebf8:	9b03      	ldr	r3, [sp, #12]
 800ebfa:	2b03      	cmp	r3, #3
 800ebfc:	d9f1      	bls.n	800ebe2 <queues1_execute+0x32>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
 800ebfe:	f7ff feff 	bl	800ea00 <chSysUnlock>
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
 800ec02:	f7ff fef5 	bl	800e9f0 <chSysLock>
 800ec06:	4898      	ldr	r0, [pc, #608]	; (800ee68 <queues1_execute+0x2b8>)
 800ec08:	f7ff ff2a 	bl	800ea60 <chIQIsFullI>
 800ec0c:	4603      	mov	r3, r0
 800ec0e:	2002      	movs	r0, #2
 800ec10:	4619      	mov	r1, r3
 800ec12:	f7fc fb4d 	bl	800b2b0 <_test_assert>
 800ec16:	4603      	mov	r3, r0
 800ec18:	2b00      	cmp	r3, #0
 800ec1a:	d002      	beq.n	800ec22 <queues1_execute+0x72>
 800ec1c:	f7ff fef0 	bl	800ea00 <chSysUnlock>
 800ec20:	e143      	b.n	800eeaa <queues1_execute+0x2fa>
 800ec22:	f7ff feed 	bl	800ea00 <chSysUnlock>
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");
 800ec26:	f7ff fee3 	bl	800e9f0 <chSysLock>
 800ec2a:	488f      	ldr	r0, [pc, #572]	; (800ee68 <queues1_execute+0x2b8>)
 800ec2c:	2100      	movs	r1, #0
 800ec2e:	f7f4 faf7 	bl	8003220 <chIQPutI>
 800ec32:	4603      	mov	r3, r0
 800ec34:	f113 0f04 	cmn.w	r3, #4
 800ec38:	bf14      	ite	ne
 800ec3a:	2300      	movne	r3, #0
 800ec3c:	2301      	moveq	r3, #1
 800ec3e:	b2db      	uxtb	r3, r3
 800ec40:	2003      	movs	r0, #3
 800ec42:	4619      	mov	r1, r3
 800ec44:	f7fc fb34 	bl	800b2b0 <_test_assert>
 800ec48:	4603      	mov	r3, r0
 800ec4a:	2b00      	cmp	r3, #0
 800ec4c:	d002      	beq.n	800ec54 <queues1_execute+0xa4>
 800ec4e:	f7ff fed7 	bl	800ea00 <chSysUnlock>
 800ec52:	e12a      	b.n	800eeaa <queues1_execute+0x2fa>
 800ec54:	f7ff fed4 	bl	800ea00 <chSysUnlock>

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800ec58:	2300      	movs	r3, #0
 800ec5a:	9303      	str	r3, [sp, #12]
 800ec5c:	e00a      	b.n	800ec74 <queues1_execute+0xc4>
    test_emit_token(chIQGet(&iq));
 800ec5e:	4882      	ldr	r0, [pc, #520]	; (800ee68 <queues1_execute+0x2b8>)
 800ec60:	f7ff ff16 	bl	800ea90 <chIQGet>
 800ec64:	4603      	mov	r3, r0
 800ec66:	b2db      	uxtb	r3, r3
 800ec68:	4618      	mov	r0, r3
 800ec6a:	f7fc faf1 	bl	800b250 <test_emit_token>
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800ec6e:	9b03      	ldr	r3, [sp, #12]
 800ec70:	3301      	adds	r3, #1
 800ec72:	9303      	str	r3, [sp, #12]
 800ec74:	9b03      	ldr	r3, [sp, #12]
 800ec76:	2b03      	cmp	r3, #3
 800ec78:	d9f1      	bls.n	800ec5e <queues1_execute+0xae>
    test_emit_token(chIQGet(&iq));
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
 800ec7a:	f7ff feb9 	bl	800e9f0 <chSysLock>
 800ec7e:	487a      	ldr	r0, [pc, #488]	; (800ee68 <queues1_execute+0x2b8>)
 800ec80:	f7ff fede 	bl	800ea40 <chIQIsEmptyI>
 800ec84:	4603      	mov	r3, r0
 800ec86:	2004      	movs	r0, #4
 800ec88:	4619      	mov	r1, r3
 800ec8a:	f7fc fb11 	bl	800b2b0 <_test_assert>
 800ec8e:	4603      	mov	r3, r0
 800ec90:	2b00      	cmp	r3, #0
 800ec92:	d002      	beq.n	800ec9a <queues1_execute+0xea>
 800ec94:	f7ff feb4 	bl	800ea00 <chSysUnlock>
 800ec98:	e107      	b.n	800eeaa <queues1_execute+0x2fa>
 800ec9a:	f7ff feb1 	bl	800ea00 <chSysUnlock>
  test_assert_sequence(5, "ABCD");
 800ec9e:	2005      	movs	r0, #5
 800eca0:	4972      	ldr	r1, [pc, #456]	; (800ee6c <queues1_execute+0x2bc>)
 800eca2:	f7fc fb1d 	bl	800b2e0 <_test_assert_sequence>
 800eca6:	4603      	mov	r3, r0
 800eca8:	2b00      	cmp	r3, #0
 800ecaa:	d000      	beq.n	800ecae <queues1_execute+0xfe>
 800ecac:	e0fd      	b.n	800eeaa <queues1_execute+0x2fa>

  /* Queue filling again */
  chSysLock();
 800ecae:	f7ff fe9f 	bl	800e9f0 <chSysLock>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800ecb2:	2300      	movs	r3, #0
 800ecb4:	9303      	str	r3, [sp, #12]
 800ecb6:	e00a      	b.n	800ecce <queues1_execute+0x11e>
    chIQPutI(&iq, 'A' + i);
 800ecb8:	9b03      	ldr	r3, [sp, #12]
 800ecba:	b2db      	uxtb	r3, r3
 800ecbc:	3341      	adds	r3, #65	; 0x41
 800ecbe:	b2db      	uxtb	r3, r3
 800ecc0:	4869      	ldr	r0, [pc, #420]	; (800ee68 <queues1_execute+0x2b8>)
 800ecc2:	4619      	mov	r1, r3
 800ecc4:	f7f4 faac 	bl	8003220 <chIQPutI>
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
  test_assert_sequence(5, "ABCD");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800ecc8:	9b03      	ldr	r3, [sp, #12]
 800ecca:	3301      	adds	r3, #1
 800eccc:	9303      	str	r3, [sp, #12]
 800ecce:	9b03      	ldr	r3, [sp, #12]
 800ecd0:	2b03      	cmp	r3, #3
 800ecd2:	d9f1      	bls.n	800ecb8 <queues1_execute+0x108>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
 800ecd4:	f7ff fe94 	bl	800ea00 <chSysUnlock>

  /* Reading the whole thing */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 800ecd8:	4b65      	ldr	r3, [pc, #404]	; (800ee70 <queues1_execute+0x2c0>)
 800ecda:	685b      	ldr	r3, [r3, #4]
 800ecdc:	4862      	ldr	r0, [pc, #392]	; (800ee68 <queues1_execute+0x2b8>)
 800ecde:	4619      	mov	r1, r3
 800ece0:	2208      	movs	r2, #8
 800ece2:	2300      	movs	r3, #0
 800ece4:	f7f4 fb14 	bl	8003310 <chIQReadTimeout>
 800ece8:	9002      	str	r0, [sp, #8]
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 800ecea:	9b02      	ldr	r3, [sp, #8]
 800ecec:	2b04      	cmp	r3, #4
 800ecee:	bf14      	ite	ne
 800ecf0:	2300      	movne	r3, #0
 800ecf2:	2301      	moveq	r3, #1
 800ecf4:	b2db      	uxtb	r3, r3
 800ecf6:	2006      	movs	r0, #6
 800ecf8:	4619      	mov	r1, r3
 800ecfa:	f7fc fad9 	bl	800b2b0 <_test_assert>
 800ecfe:	4603      	mov	r3, r0
 800ed00:	2b00      	cmp	r3, #0
 800ed02:	d000      	beq.n	800ed06 <queues1_execute+0x156>
 800ed04:	e0d1      	b.n	800eeaa <queues1_execute+0x2fa>
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");
 800ed06:	f7ff fe73 	bl	800e9f0 <chSysLock>
 800ed0a:	4857      	ldr	r0, [pc, #348]	; (800ee68 <queues1_execute+0x2b8>)
 800ed0c:	f7ff fe98 	bl	800ea40 <chIQIsEmptyI>
 800ed10:	4603      	mov	r3, r0
 800ed12:	2007      	movs	r0, #7
 800ed14:	4619      	mov	r1, r3
 800ed16:	f7fc facb 	bl	800b2b0 <_test_assert>
 800ed1a:	4603      	mov	r3, r0
 800ed1c:	2b00      	cmp	r3, #0
 800ed1e:	d002      	beq.n	800ed26 <queues1_execute+0x176>
 800ed20:	f7ff fe6e 	bl	800ea00 <chSysUnlock>
 800ed24:	e0c1      	b.n	800eeaa <queues1_execute+0x2fa>
 800ed26:	f7ff fe6b 	bl	800ea00 <chSysUnlock>

  /* Queue filling again */
  chSysLock();
 800ed2a:	f7ff fe61 	bl	800e9f0 <chSysLock>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800ed2e:	2300      	movs	r3, #0
 800ed30:	9303      	str	r3, [sp, #12]
 800ed32:	e00a      	b.n	800ed4a <queues1_execute+0x19a>
    chIQPutI(&iq, 'A' + i);
 800ed34:	9b03      	ldr	r3, [sp, #12]
 800ed36:	b2db      	uxtb	r3, r3
 800ed38:	3341      	adds	r3, #65	; 0x41
 800ed3a:	b2db      	uxtb	r3, r3
 800ed3c:	484a      	ldr	r0, [pc, #296]	; (800ee68 <queues1_execute+0x2b8>)
 800ed3e:	4619      	mov	r1, r3
 800ed40:	f7f4 fa6e 	bl	8003220 <chIQPutI>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800ed44:	9b03      	ldr	r3, [sp, #12]
 800ed46:	3301      	adds	r3, #1
 800ed48:	9303      	str	r3, [sp, #12]
 800ed4a:	9b03      	ldr	r3, [sp, #12]
 800ed4c:	2b03      	cmp	r3, #3
 800ed4e:	d9f1      	bls.n	800ed34 <queues1_execute+0x184>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
 800ed50:	f7ff fe56 	bl	800ea00 <chSysUnlock>

  /* Partial reads */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 800ed54:	4b46      	ldr	r3, [pc, #280]	; (800ee70 <queues1_execute+0x2c0>)
 800ed56:	685b      	ldr	r3, [r3, #4]
 800ed58:	4843      	ldr	r0, [pc, #268]	; (800ee68 <queues1_execute+0x2b8>)
 800ed5a:	4619      	mov	r1, r3
 800ed5c:	2202      	movs	r2, #2
 800ed5e:	2300      	movs	r3, #0
 800ed60:	f7f4 fad6 	bl	8003310 <chIQReadTimeout>
 800ed64:	9002      	str	r0, [sp, #8]
  test_assert(8, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800ed66:	9b02      	ldr	r3, [sp, #8]
 800ed68:	2b02      	cmp	r3, #2
 800ed6a:	bf14      	ite	ne
 800ed6c:	2300      	movne	r3, #0
 800ed6e:	2301      	moveq	r3, #1
 800ed70:	b2db      	uxtb	r3, r3
 800ed72:	2008      	movs	r0, #8
 800ed74:	4619      	mov	r1, r3
 800ed76:	f7fc fa9b 	bl	800b2b0 <_test_assert>
 800ed7a:	4603      	mov	r3, r0
 800ed7c:	2b00      	cmp	r3, #0
 800ed7e:	d000      	beq.n	800ed82 <queues1_execute+0x1d2>
 800ed80:	e093      	b.n	800eeaa <queues1_execute+0x2fa>
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 800ed82:	4b3b      	ldr	r3, [pc, #236]	; (800ee70 <queues1_execute+0x2c0>)
 800ed84:	685b      	ldr	r3, [r3, #4]
 800ed86:	4838      	ldr	r0, [pc, #224]	; (800ee68 <queues1_execute+0x2b8>)
 800ed88:	4619      	mov	r1, r3
 800ed8a:	2202      	movs	r2, #2
 800ed8c:	2300      	movs	r3, #0
 800ed8e:	f7f4 fabf 	bl	8003310 <chIQReadTimeout>
 800ed92:	9002      	str	r0, [sp, #8]
  test_assert(9, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800ed94:	9b02      	ldr	r3, [sp, #8]
 800ed96:	2b02      	cmp	r3, #2
 800ed98:	bf14      	ite	ne
 800ed9a:	2300      	movne	r3, #0
 800ed9c:	2301      	moveq	r3, #1
 800ed9e:	b2db      	uxtb	r3, r3
 800eda0:	2009      	movs	r0, #9
 800eda2:	4619      	mov	r1, r3
 800eda4:	f7fc fa84 	bl	800b2b0 <_test_assert>
 800eda8:	4603      	mov	r3, r0
 800edaa:	2b00      	cmp	r3, #0
 800edac:	d000      	beq.n	800edb0 <queues1_execute+0x200>
 800edae:	e07c      	b.n	800eeaa <queues1_execute+0x2fa>
  test_assert_lock(10, chIQIsEmptyI(&iq), "still full");
 800edb0:	f7ff fe1e 	bl	800e9f0 <chSysLock>
 800edb4:	482c      	ldr	r0, [pc, #176]	; (800ee68 <queues1_execute+0x2b8>)
 800edb6:	f7ff fe43 	bl	800ea40 <chIQIsEmptyI>
 800edba:	4603      	mov	r3, r0
 800edbc:	200a      	movs	r0, #10
 800edbe:	4619      	mov	r1, r3
 800edc0:	f7fc fa76 	bl	800b2b0 <_test_assert>
 800edc4:	4603      	mov	r3, r0
 800edc6:	2b00      	cmp	r3, #0
 800edc8:	d002      	beq.n	800edd0 <queues1_execute+0x220>
 800edca:	f7ff fe19 	bl	800ea00 <chSysUnlock>
 800edce:	e06c      	b.n	800eeaa <queues1_execute+0x2fa>
 800edd0:	f7ff fe16 	bl	800ea00 <chSysUnlock>

  /* Testing reset */
  chSysLock();
 800edd4:	f7ff fe0c 	bl	800e9f0 <chSysLock>
  chIQPutI(&iq, 0);
 800edd8:	4823      	ldr	r0, [pc, #140]	; (800ee68 <queues1_execute+0x2b8>)
 800edda:	2100      	movs	r1, #0
 800eddc:	f7f4 fa20 	bl	8003220 <chIQPutI>
  chIQResetI(&iq);
 800ede0:	4821      	ldr	r0, [pc, #132]	; (800ee68 <queues1_execute+0x2b8>)
 800ede2:	f7f4 fa05 	bl	80031f0 <chIQResetI>
  chSysUnlock();
 800ede6:	f7ff fe0b 	bl	800ea00 <chSysUnlock>
  test_assert_lock(11, chIQGetFullI(&iq) == 0, "still full");
 800edea:	f7ff fe01 	bl	800e9f0 <chSysLock>
 800edee:	481e      	ldr	r0, [pc, #120]	; (800ee68 <queues1_execute+0x2b8>)
 800edf0:	f7ff fe1e 	bl	800ea30 <chIQGetFullI>
 800edf4:	4603      	mov	r3, r0
 800edf6:	2b00      	cmp	r3, #0
 800edf8:	bf14      	ite	ne
 800edfa:	2300      	movne	r3, #0
 800edfc:	2301      	moveq	r3, #1
 800edfe:	b2db      	uxtb	r3, r3
 800ee00:	200b      	movs	r0, #11
 800ee02:	4619      	mov	r1, r3
 800ee04:	f7fc fa54 	bl	800b2b0 <_test_assert>
 800ee08:	4603      	mov	r3, r0
 800ee0a:	2b00      	cmp	r3, #0
 800ee0c:	d002      	beq.n	800ee14 <queues1_execute+0x264>
 800ee0e:	f7ff fdf7 	bl	800ea00 <chSysUnlock>
 800ee12:	e04a      	b.n	800eeaa <queues1_execute+0x2fa>
 800ee14:	f7ff fdf4 	bl	800ea00 <chSysUnlock>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, NULL);
 800ee18:	4b15      	ldr	r3, [pc, #84]	; (800ee70 <queues1_execute+0x2c0>)
 800ee1a:	681c      	ldr	r4, [r3, #0]
 800ee1c:	f7ff fe00 	bl	800ea20 <chThdGetPriorityX>
 800ee20:	4603      	mov	r3, r0
 800ee22:	3301      	adds	r3, #1
 800ee24:	2200      	movs	r2, #0
 800ee26:	9200      	str	r2, [sp, #0]
 800ee28:	4620      	mov	r0, r4
 800ee2a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800ee2e:	461a      	mov	r2, r3
 800ee30:	4b10      	ldr	r3, [pc, #64]	; (800ee74 <queues1_execute+0x2c4>)
 800ee32:	f7f2 f9d5 	bl	80011e0 <chThdCreateStatic>
 800ee36:	4602      	mov	r2, r0
 800ee38:	4b0f      	ldr	r3, [pc, #60]	; (800ee78 <queues1_execute+0x2c8>)
 800ee3a:	601a      	str	r2, [r3, #0]
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
 800ee3c:	f7ff fdd8 	bl	800e9f0 <chSysLock>
 800ee40:	4809      	ldr	r0, [pc, #36]	; (800ee68 <queues1_execute+0x2b8>)
 800ee42:	f7ff fdf5 	bl	800ea30 <chIQGetFullI>
 800ee46:	4603      	mov	r3, r0
 800ee48:	2b00      	cmp	r3, #0
 800ee4a:	bf14      	ite	ne
 800ee4c:	2300      	movne	r3, #0
 800ee4e:	2301      	moveq	r3, #1
 800ee50:	b2db      	uxtb	r3, r3
 800ee52:	200c      	movs	r0, #12
 800ee54:	4619      	mov	r1, r3
 800ee56:	f7fc fa2b 	bl	800b2b0 <_test_assert>
 800ee5a:	4603      	mov	r3, r0
 800ee5c:	2b00      	cmp	r3, #0
 800ee5e:	d00d      	beq.n	800ee7c <queues1_execute+0x2cc>
 800ee60:	f7ff fdce 	bl	800ea00 <chSysUnlock>
 800ee64:	e021      	b.n	800eeaa <queues1_execute+0x2fa>
 800ee66:	bf00      	nop
 800ee68:	200008a8 	.word	0x200008a8
 800ee6c:	080169d0 	.word	0x080169d0
 800ee70:	08016240 	.word	0x08016240
 800ee74:	0800eb91 	.word	0x0800eb91
 800ee78:	20001224 	.word	0x20001224
 800ee7c:	f7ff fdc0 	bl	800ea00 <chSysUnlock>
  test_wait_threads();
 800ee80:	f7fc fa96 	bl	800b3b0 <test_wait_threads>

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
 800ee84:	480a      	ldr	r0, [pc, #40]	; (800eeb0 <queues1_execute+0x300>)
 800ee86:	210a      	movs	r1, #10
 800ee88:	f7f4 f9fa 	bl	8003280 <chIQGetTimeout>
 800ee8c:	4603      	mov	r3, r0
 800ee8e:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ee92:	bf14      	ite	ne
 800ee94:	2300      	movne	r3, #0
 800ee96:	2301      	moveq	r3, #1
 800ee98:	b2db      	uxtb	r3, r3
 800ee9a:	200d      	movs	r0, #13
 800ee9c:	4619      	mov	r1, r3
 800ee9e:	f7fc fa07 	bl	800b2b0 <_test_assert>
 800eea2:	4603      	mov	r3, r0
 800eea4:	2b00      	cmp	r3, #0
 800eea6:	d000      	beq.n	800eeaa <queues1_execute+0x2fa>
 800eea8:	bf00      	nop
}
 800eeaa:	b004      	add	sp, #16
 800eeac:	bd10      	pop	{r4, pc}
 800eeae:	bf00      	nop
 800eeb0:	200008a8 	.word	0x200008a8
 800eeb4:	f3af 8000 	nop.w
 800eeb8:	f3af 8000 	nop.w
 800eebc:	f3af 8000 	nop.w

0800eec0 <queues2_setup>:
 * This test case tests synchronous and asynchronous operations on an
 * @p OutputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues2_setup(void) {
 800eec0:	b500      	push	{lr}
 800eec2:	b083      	sub	sp, #12

  chOQObjectInit(&oq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
 800eec4:	4b06      	ldr	r3, [pc, #24]	; (800eee0 <queues2_setup+0x20>)
 800eec6:	681b      	ldr	r3, [r3, #0]
 800eec8:	2200      	movs	r2, #0
 800eeca:	9200      	str	r2, [sp, #0]
 800eecc:	4805      	ldr	r0, [pc, #20]	; (800eee4 <queues2_setup+0x24>)
 800eece:	4619      	mov	r1, r3
 800eed0:	2204      	movs	r2, #4
 800eed2:	4b05      	ldr	r3, [pc, #20]	; (800eee8 <queues2_setup+0x28>)
 800eed4:	f7f4 fa74 	bl	80033c0 <chOQObjectInit>
}
 800eed8:	b003      	add	sp, #12
 800eeda:	f85d fb04 	ldr.w	pc, [sp], #4
 800eede:	bf00      	nop
 800eee0:	08016240 	.word	0x08016240
 800eee4:	200008cc 	.word	0x200008cc
 800eee8:	0800eb51 	.word	0x0800eb51
 800eeec:	f3af 8000 	nop.w

0800eef0 <thread2>:

static THD_FUNCTION(thread2, p) {
 800eef0:	b500      	push	{lr}
 800eef2:	b083      	sub	sp, #12
 800eef4:	9001      	str	r0, [sp, #4]

  (void)p;
  chOQPutTimeout(&oq, 0, MS2ST(200));
 800eef6:	4804      	ldr	r0, [pc, #16]	; (800ef08 <thread2+0x18>)
 800eef8:	2100      	movs	r1, #0
 800eefa:	22c8      	movs	r2, #200	; 0xc8
 800eefc:	f7f4 faa8 	bl	8003450 <chOQPutTimeout>
}
 800ef00:	b003      	add	sp, #12
 800ef02:	f85d fb04 	ldr.w	pc, [sp], #4
 800ef06:	bf00      	nop
 800ef08:	200008cc 	.word	0x200008cc
 800ef0c:	f3af 8000 	nop.w

0800ef10 <queues2_execute>:

static void queues2_execute(void) {
 800ef10:	b510      	push	{r4, lr}
 800ef12:	b086      	sub	sp, #24
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");
 800ef14:	f7ff fd6c 	bl	800e9f0 <chSysLock>
 800ef18:	48a2      	ldr	r0, [pc, #648]	; (800f1a4 <queues2_execute+0x294>)
 800ef1a:	f7ff fdd9 	bl	800ead0 <chOQIsEmptyI>
 800ef1e:	4603      	mov	r3, r0
 800ef20:	2001      	movs	r0, #1
 800ef22:	4619      	mov	r1, r3
 800ef24:	f7fc f9c4 	bl	800b2b0 <_test_assert>
 800ef28:	4603      	mov	r3, r0
 800ef2a:	2b00      	cmp	r3, #0
 800ef2c:	d002      	beq.n	800ef34 <queues2_execute+0x24>
 800ef2e:	f7ff fd67 	bl	800ea00 <chSysUnlock>
 800ef32:	e134      	b.n	800f19e <queues2_execute+0x28e>
 800ef34:	f7ff fd64 	bl	800ea00 <chSysUnlock>

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800ef38:	2300      	movs	r3, #0
 800ef3a:	9305      	str	r3, [sp, #20]
 800ef3c:	e00a      	b.n	800ef54 <queues2_execute+0x44>
    chOQPut(&oq, 'A' + i);
 800ef3e:	9b05      	ldr	r3, [sp, #20]
 800ef40:	b2db      	uxtb	r3, r3
 800ef42:	3341      	adds	r3, #65	; 0x41
 800ef44:	b2db      	uxtb	r3, r3
 800ef46:	4897      	ldr	r0, [pc, #604]	; (800f1a4 <queues2_execute+0x294>)
 800ef48:	4619      	mov	r1, r3
 800ef4a:	f7ff fde9 	bl	800eb20 <chOQPut>

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800ef4e:	9b05      	ldr	r3, [sp, #20]
 800ef50:	3301      	adds	r3, #1
 800ef52:	9305      	str	r3, [sp, #20]
 800ef54:	9b05      	ldr	r3, [sp, #20]
 800ef56:	2b03      	cmp	r3, #3
 800ef58:	d9f1      	bls.n	800ef3e <queues2_execute+0x2e>
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");
 800ef5a:	f7ff fd49 	bl	800e9f0 <chSysLock>
 800ef5e:	4891      	ldr	r0, [pc, #580]	; (800f1a4 <queues2_execute+0x294>)
 800ef60:	f7ff fdce 	bl	800eb00 <chOQIsFullI>
 800ef64:	4603      	mov	r3, r0
 800ef66:	2002      	movs	r0, #2
 800ef68:	4619      	mov	r1, r3
 800ef6a:	f7fc f9a1 	bl	800b2b0 <_test_assert>
 800ef6e:	4603      	mov	r3, r0
 800ef70:	2b00      	cmp	r3, #0
 800ef72:	d002      	beq.n	800ef7a <queues2_execute+0x6a>
 800ef74:	f7ff fd44 	bl	800ea00 <chSysUnlock>
 800ef78:	e111      	b.n	800f19e <queues2_execute+0x28e>
 800ef7a:	f7ff fd41 	bl	800ea00 <chSysUnlock>

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
 800ef7e:	2300      	movs	r3, #0
 800ef80:	9305      	str	r3, [sp, #20]
 800ef82:	e011      	b.n	800efa8 <queues2_execute+0x98>
    char c;

    chSysLock();
 800ef84:	f7ff fd34 	bl	800e9f0 <chSysLock>
    c = chOQGetI(&oq);
 800ef88:	4886      	ldr	r0, [pc, #536]	; (800f1a4 <queues2_execute+0x294>)
 800ef8a:	f7f4 faa9 	bl	80034e0 <chOQGetI>
 800ef8e:	4603      	mov	r3, r0
 800ef90:	f88d 3013 	strb.w	r3, [sp, #19]
    chSysUnlock();
 800ef94:	f7ff fd34 	bl	800ea00 <chSysUnlock>
    test_emit_token(c);
 800ef98:	f89d 3013 	ldrb.w	r3, [sp, #19]
 800ef9c:	4618      	mov	r0, r3
 800ef9e:	f7fc f957 	bl	800b250 <test_emit_token>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
 800efa2:	9b05      	ldr	r3, [sp, #20]
 800efa4:	3301      	adds	r3, #1
 800efa6:	9305      	str	r3, [sp, #20]
 800efa8:	9b05      	ldr	r3, [sp, #20]
 800efaa:	2b03      	cmp	r3, #3
 800efac:	d9ea      	bls.n	800ef84 <queues2_execute+0x74>
    chSysLock();
    c = chOQGetI(&oq);
    chSysUnlock();
    test_emit_token(c);
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
 800efae:	f7ff fd1f 	bl	800e9f0 <chSysLock>
 800efb2:	487c      	ldr	r0, [pc, #496]	; (800f1a4 <queues2_execute+0x294>)
 800efb4:	f7ff fd8c 	bl	800ead0 <chOQIsEmptyI>
 800efb8:	4603      	mov	r3, r0
 800efba:	2003      	movs	r0, #3
 800efbc:	4619      	mov	r1, r3
 800efbe:	f7fc f977 	bl	800b2b0 <_test_assert>
 800efc2:	4603      	mov	r3, r0
 800efc4:	2b00      	cmp	r3, #0
 800efc6:	d002      	beq.n	800efce <queues2_execute+0xbe>
 800efc8:	f7ff fd1a 	bl	800ea00 <chSysUnlock>
 800efcc:	e0e7      	b.n	800f19e <queues2_execute+0x28e>
 800efce:	f7ff fd17 	bl	800ea00 <chSysUnlock>
  test_assert_sequence(4, "ABCD");
 800efd2:	2004      	movs	r0, #4
 800efd4:	4974      	ldr	r1, [pc, #464]	; (800f1a8 <queues2_execute+0x298>)
 800efd6:	f7fc f983 	bl	800b2e0 <_test_assert_sequence>
 800efda:	4603      	mov	r3, r0
 800efdc:	2b00      	cmp	r3, #0
 800efde:	d000      	beq.n	800efe2 <queues2_execute+0xd2>
 800efe0:	e0dd      	b.n	800f19e <queues2_execute+0x28e>
  test_assert_lock(5, chOQGetI(&oq) == Q_EMPTY, "failed to report Q_EMPTY");
 800efe2:	f7ff fd05 	bl	800e9f0 <chSysLock>
 800efe6:	486f      	ldr	r0, [pc, #444]	; (800f1a4 <queues2_execute+0x294>)
 800efe8:	f7f4 fa7a 	bl	80034e0 <chOQGetI>
 800efec:	4603      	mov	r3, r0
 800efee:	f113 0f03 	cmn.w	r3, #3
 800eff2:	bf14      	ite	ne
 800eff4:	2300      	movne	r3, #0
 800eff6:	2301      	moveq	r3, #1
 800eff8:	b2db      	uxtb	r3, r3
 800effa:	2005      	movs	r0, #5
 800effc:	4619      	mov	r1, r3
 800effe:	f7fc f957 	bl	800b2b0 <_test_assert>
 800f002:	4603      	mov	r3, r0
 800f004:	2b00      	cmp	r3, #0
 800f006:	d002      	beq.n	800f00e <queues2_execute+0xfe>
 800f008:	f7ff fcfa 	bl	800ea00 <chSysUnlock>
 800f00c:	e0c7      	b.n	800f19e <queues2_execute+0x28e>
 800f00e:	f7ff fcf7 	bl	800ea00 <chSysUnlock>

  /* Writing the whole thing */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 800f012:	4b66      	ldr	r3, [pc, #408]	; (800f1ac <queues2_execute+0x29c>)
 800f014:	685b      	ldr	r3, [r3, #4]
 800f016:	4863      	ldr	r0, [pc, #396]	; (800f1a4 <queues2_execute+0x294>)
 800f018:	4619      	mov	r1, r3
 800f01a:	2208      	movs	r2, #8
 800f01c:	2300      	movs	r3, #0
 800f01e:	f7f4 fa8f 	bl	8003540 <chOQWriteTimeout>
 800f022:	9003      	str	r0, [sp, #12]
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 800f024:	9b03      	ldr	r3, [sp, #12]
 800f026:	2b04      	cmp	r3, #4
 800f028:	bf14      	ite	ne
 800f02a:	2300      	movne	r3, #0
 800f02c:	2301      	moveq	r3, #1
 800f02e:	b2db      	uxtb	r3, r3
 800f030:	2006      	movs	r0, #6
 800f032:	4619      	mov	r1, r3
 800f034:	f7fc f93c 	bl	800b2b0 <_test_assert>
 800f038:	4603      	mov	r3, r0
 800f03a:	2b00      	cmp	r3, #0
 800f03c:	d000      	beq.n	800f040 <queues2_execute+0x130>
 800f03e:	e0ae      	b.n	800f19e <queues2_execute+0x28e>
  test_assert_lock(7, chOQIsFullI(&oq), "not full");
 800f040:	f7ff fcd6 	bl	800e9f0 <chSysLock>
 800f044:	4857      	ldr	r0, [pc, #348]	; (800f1a4 <queues2_execute+0x294>)
 800f046:	f7ff fd5b 	bl	800eb00 <chOQIsFullI>
 800f04a:	4603      	mov	r3, r0
 800f04c:	2007      	movs	r0, #7
 800f04e:	4619      	mov	r1, r3
 800f050:	f7fc f92e 	bl	800b2b0 <_test_assert>
 800f054:	4603      	mov	r3, r0
 800f056:	2b00      	cmp	r3, #0
 800f058:	d002      	beq.n	800f060 <queues2_execute+0x150>
 800f05a:	f7ff fcd1 	bl	800ea00 <chSysUnlock>
 800f05e:	e09e      	b.n	800f19e <queues2_execute+0x28e>
 800f060:	f7ff fcce 	bl	800ea00 <chSysUnlock>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 800f064:	4b51      	ldr	r3, [pc, #324]	; (800f1ac <queues2_execute+0x29c>)
 800f066:	681c      	ldr	r4, [r3, #0]
 800f068:	f7ff fcda 	bl	800ea20 <chThdGetPriorityX>
 800f06c:	4603      	mov	r3, r0
 800f06e:	3301      	adds	r3, #1
 800f070:	2200      	movs	r2, #0
 800f072:	9200      	str	r2, [sp, #0]
 800f074:	4620      	mov	r0, r4
 800f076:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f07a:	461a      	mov	r2, r3
 800f07c:	4b4c      	ldr	r3, [pc, #304]	; (800f1b0 <queues2_execute+0x2a0>)
 800f07e:	f7f2 f8af 	bl	80011e0 <chThdCreateStatic>
 800f082:	4602      	mov	r2, r0
 800f084:	4b4b      	ldr	r3, [pc, #300]	; (800f1b4 <queues2_execute+0x2a4>)
 800f086:	601a      	str	r2, [r3, #0]
  test_assert_lock(8, chOQGetFullI(&oq) == TEST_QUEUES_SIZE, "not empty");
 800f088:	f7ff fcb2 	bl	800e9f0 <chSysLock>
 800f08c:	4845      	ldr	r0, [pc, #276]	; (800f1a4 <queues2_execute+0x294>)
 800f08e:	f7ff fd0f 	bl	800eab0 <chOQGetFullI>
 800f092:	4603      	mov	r3, r0
 800f094:	2b04      	cmp	r3, #4
 800f096:	bf14      	ite	ne
 800f098:	2300      	movne	r3, #0
 800f09a:	2301      	moveq	r3, #1
 800f09c:	b2db      	uxtb	r3, r3
 800f09e:	2008      	movs	r0, #8
 800f0a0:	4619      	mov	r1, r3
 800f0a2:	f7fc f905 	bl	800b2b0 <_test_assert>
 800f0a6:	4603      	mov	r3, r0
 800f0a8:	2b00      	cmp	r3, #0
 800f0aa:	d002      	beq.n	800f0b2 <queues2_execute+0x1a2>
 800f0ac:	f7ff fca8 	bl	800ea00 <chSysUnlock>
 800f0b0:	e075      	b.n	800f19e <queues2_execute+0x28e>
 800f0b2:	f7ff fca5 	bl	800ea00 <chSysUnlock>
  test_wait_threads();
 800f0b6:	f7fc f97b 	bl	800b3b0 <test_wait_threads>

  /* Testing reset */
  chSysLock();
 800f0ba:	f7ff fc99 	bl	800e9f0 <chSysLock>
  chOQResetI(&oq);
 800f0be:	4839      	ldr	r0, [pc, #228]	; (800f1a4 <queues2_execute+0x294>)
 800f0c0:	f7f4 f9a6 	bl	8003410 <chOQResetI>
  chSysUnlock();
 800f0c4:	f7ff fc9c 	bl	800ea00 <chSysUnlock>
  test_assert_lock(9, chOQGetFullI(&oq) == 0, "still full");
 800f0c8:	f7ff fc92 	bl	800e9f0 <chSysLock>
 800f0cc:	4835      	ldr	r0, [pc, #212]	; (800f1a4 <queues2_execute+0x294>)
 800f0ce:	f7ff fcef 	bl	800eab0 <chOQGetFullI>
 800f0d2:	4603      	mov	r3, r0
 800f0d4:	2b00      	cmp	r3, #0
 800f0d6:	bf14      	ite	ne
 800f0d8:	2300      	movne	r3, #0
 800f0da:	2301      	moveq	r3, #1
 800f0dc:	b2db      	uxtb	r3, r3
 800f0de:	2009      	movs	r0, #9
 800f0e0:	4619      	mov	r1, r3
 800f0e2:	f7fc f8e5 	bl	800b2b0 <_test_assert>
 800f0e6:	4603      	mov	r3, r0
 800f0e8:	2b00      	cmp	r3, #0
 800f0ea:	d002      	beq.n	800f0f2 <queues2_execute+0x1e2>
 800f0ec:	f7ff fc88 	bl	800ea00 <chSysUnlock>
 800f0f0:	e055      	b.n	800f19e <queues2_execute+0x28e>
 800f0f2:	f7ff fc85 	bl	800ea00 <chSysUnlock>

  /* Partial writes */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 800f0f6:	4b2d      	ldr	r3, [pc, #180]	; (800f1ac <queues2_execute+0x29c>)
 800f0f8:	685b      	ldr	r3, [r3, #4]
 800f0fa:	482a      	ldr	r0, [pc, #168]	; (800f1a4 <queues2_execute+0x294>)
 800f0fc:	4619      	mov	r1, r3
 800f0fe:	2202      	movs	r2, #2
 800f100:	2300      	movs	r3, #0
 800f102:	f7f4 fa1d 	bl	8003540 <chOQWriteTimeout>
 800f106:	9003      	str	r0, [sp, #12]
  test_assert(10, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800f108:	9b03      	ldr	r3, [sp, #12]
 800f10a:	2b02      	cmp	r3, #2
 800f10c:	bf14      	ite	ne
 800f10e:	2300      	movne	r3, #0
 800f110:	2301      	moveq	r3, #1
 800f112:	b2db      	uxtb	r3, r3
 800f114:	200a      	movs	r0, #10
 800f116:	4619      	mov	r1, r3
 800f118:	f7fc f8ca 	bl	800b2b0 <_test_assert>
 800f11c:	4603      	mov	r3, r0
 800f11e:	2b00      	cmp	r3, #0
 800f120:	d000      	beq.n	800f124 <queues2_execute+0x214>
 800f122:	e03c      	b.n	800f19e <queues2_execute+0x28e>
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 800f124:	4b21      	ldr	r3, [pc, #132]	; (800f1ac <queues2_execute+0x29c>)
 800f126:	685b      	ldr	r3, [r3, #4]
 800f128:	481e      	ldr	r0, [pc, #120]	; (800f1a4 <queues2_execute+0x294>)
 800f12a:	4619      	mov	r1, r3
 800f12c:	2202      	movs	r2, #2
 800f12e:	2300      	movs	r3, #0
 800f130:	f7f4 fa06 	bl	8003540 <chOQWriteTimeout>
 800f134:	9003      	str	r0, [sp, #12]
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800f136:	9b03      	ldr	r3, [sp, #12]
 800f138:	2b02      	cmp	r3, #2
 800f13a:	bf14      	ite	ne
 800f13c:	2300      	movne	r3, #0
 800f13e:	2301      	moveq	r3, #1
 800f140:	b2db      	uxtb	r3, r3
 800f142:	200b      	movs	r0, #11
 800f144:	4619      	mov	r1, r3
 800f146:	f7fc f8b3 	bl	800b2b0 <_test_assert>
 800f14a:	4603      	mov	r3, r0
 800f14c:	2b00      	cmp	r3, #0
 800f14e:	d000      	beq.n	800f152 <queues2_execute+0x242>
 800f150:	e025      	b.n	800f19e <queues2_execute+0x28e>
  test_assert_lock(12, chOQIsFullI(&oq), "not full");
 800f152:	f7ff fc4d 	bl	800e9f0 <chSysLock>
 800f156:	4813      	ldr	r0, [pc, #76]	; (800f1a4 <queues2_execute+0x294>)
 800f158:	f7ff fcd2 	bl	800eb00 <chOQIsFullI>
 800f15c:	4603      	mov	r3, r0
 800f15e:	200c      	movs	r0, #12
 800f160:	4619      	mov	r1, r3
 800f162:	f7fc f8a5 	bl	800b2b0 <_test_assert>
 800f166:	4603      	mov	r3, r0
 800f168:	2b00      	cmp	r3, #0
 800f16a:	d002      	beq.n	800f172 <queues2_execute+0x262>
 800f16c:	f7ff fc48 	bl	800ea00 <chSysUnlock>
 800f170:	e015      	b.n	800f19e <queues2_execute+0x28e>
 800f172:	f7ff fc45 	bl	800ea00 <chSysUnlock>

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
 800f176:	480b      	ldr	r0, [pc, #44]	; (800f1a4 <queues2_execute+0x294>)
 800f178:	2100      	movs	r1, #0
 800f17a:	220a      	movs	r2, #10
 800f17c:	f7f4 f968 	bl	8003450 <chOQPutTimeout>
 800f180:	4603      	mov	r3, r0
 800f182:	f1b3 3fff 	cmp.w	r3, #4294967295
 800f186:	bf14      	ite	ne
 800f188:	2300      	movne	r3, #0
 800f18a:	2301      	moveq	r3, #1
 800f18c:	b2db      	uxtb	r3, r3
 800f18e:	200d      	movs	r0, #13
 800f190:	4619      	mov	r1, r3
 800f192:	f7fc f88d 	bl	800b2b0 <_test_assert>
 800f196:	4603      	mov	r3, r0
 800f198:	2b00      	cmp	r3, #0
 800f19a:	d000      	beq.n	800f19e <queues2_execute+0x28e>
 800f19c:	bf00      	nop
}
 800f19e:	b006      	add	sp, #24
 800f1a0:	bd10      	pop	{r4, pc}
 800f1a2:	bf00      	nop
 800f1a4:	200008cc 	.word	0x200008cc
 800f1a8:	080169d0 	.word	0x080169d0
 800f1ac:	08016240 	.word	0x08016240
 800f1b0:	0800eef1 	.word	0x0800eef1
 800f1b4:	20001224 	.word	0x20001224
 800f1b8:	f3af 8000 	nop.w
 800f1bc:	f3af 8000 	nop.w

0800f1c0 <port_get_irq_status>:
/**
 * @brief   Returns a word encoding the current interrupts status.
 *
 * @return              The interrupts status.
 */
static inline syssts_t port_get_irq_status(void) {
 800f1c0:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800f1c2:	f3ef 8311 	mrs	r3, BASEPRI
 800f1c6:	9300      	str	r3, [sp, #0]
  return(result);
 800f1c8:	9b00      	ldr	r3, [sp, #0]
  syssts_t sts;

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  sts = (syssts_t)__get_BASEPRI();
 800f1ca:	9301      	str	r3, [sp, #4]
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  sts = (syssts_t)__get_PRIMASK();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
  return sts;
 800f1cc:	9b01      	ldr	r3, [sp, #4]
}
 800f1ce:	4618      	mov	r0, r3
 800f1d0:	b002      	add	sp, #8
 800f1d2:	4770      	bx	lr
 800f1d4:	f3af 8000 	nop.w
 800f1d8:	f3af 8000 	nop.w
 800f1dc:	f3af 8000 	nop.w

0800f1e0 <port_irq_enabled>:
 *
 * @return              The interrupt status.
 * @retvel false        the word specified a disabled interrupts status.
 * @retvel true         the word specified an enabled interrupts status.
 */
static inline bool port_irq_enabled(syssts_t sts) {
 800f1e0:	b082      	sub	sp, #8
 800f1e2:	9001      	str	r0, [sp, #4]

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  return sts == (syssts_t)CORTEX_BASEPRI_DISABLED;
 800f1e4:	9b01      	ldr	r3, [sp, #4]
 800f1e6:	2b00      	cmp	r3, #0
 800f1e8:	bf14      	ite	ne
 800f1ea:	2300      	movne	r3, #0
 800f1ec:	2301      	moveq	r3, #1
 800f1ee:	b2db      	uxtb	r3, r3
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  return (sts & (syssts_t)1) == (syssts_t)0;
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800f1f0:	4618      	mov	r0, r3
 800f1f2:	b002      	add	sp, #8
 800f1f4:	4770      	bx	lr
 800f1f6:	bf00      	nop
 800f1f8:	f3af 8000 	nop.w
 800f1fc:	f3af 8000 	nop.w

0800f200 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800f200:	b082      	sub	sp, #8
 800f202:	2320      	movs	r3, #32
 800f204:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800f206:	9b01      	ldr	r3, [sp, #4]
 800f208:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800f20c:	b002      	add	sp, #8
 800f20e:	4770      	bx	lr

0800f210 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800f210:	b082      	sub	sp, #8
 800f212:	2300      	movs	r3, #0
 800f214:	9301      	str	r3, [sp, #4]
 800f216:	9b01      	ldr	r3, [sp, #4]
 800f218:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800f21c:	b002      	add	sp, #8
 800f21e:	4770      	bx	lr

0800f220 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800f220:	b508      	push	{r3, lr}

  port_lock();
 800f222:	f7ff ffed 	bl	800f200 <port_lock>
}
 800f226:	bd08      	pop	{r3, pc}
 800f228:	f3af 8000 	nop.w
 800f22c:	f3af 8000 	nop.w

0800f230 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800f230:	b508      	push	{r3, lr}

  port_unlock();
 800f232:	f7ff ffed 	bl	800f210 <port_unlock>
}
 800f236:	bd08      	pop	{r3, pc}
 800f238:	f3af 8000 	nop.w
 800f23c:	f3af 8000 	nop.w

0800f240 <port_disable>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800f240:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 800f242:	4770      	bx	lr
 800f244:	f3af 8000 	nop.w
 800f248:	f3af 8000 	nop.w
 800f24c:	f3af 8000 	nop.w

0800f250 <port_suspend>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 * @note    Interrupt sources above kernel level remains enabled.
 * @note    In this port it raises/lowers the base priority to kernel level.
 */
static inline void port_suspend(void) {
 800f250:	b082      	sub	sp, #8
 800f252:	2320      	movs	r3, #32
 800f254:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800f256:	9b01      	ldr	r3, [sp, #4]
 800f258:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800f25c:	b662      	cpsie	i
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
  __enable_irq();
#else
  __disable_irq();
#endif
}
 800f25e:	b002      	add	sp, #8
 800f260:	4770      	bx	lr
 800f262:	bf00      	nop
 800f264:	f3af 8000 	nop.w
 800f268:	f3af 8000 	nop.w
 800f26c:	f3af 8000 	nop.w

0800f270 <port_enable>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
 800f270:	b082      	sub	sp, #8
 800f272:	2300      	movs	r3, #0
 800f274:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800f276:	9b01      	ldr	r3, [sp, #4]
 800f278:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800f27c:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
 800f27e:	b002      	add	sp, #8
 800f280:	4770      	bx	lr
 800f282:	bf00      	nop
 800f284:	f3af 8000 	nop.w
 800f288:	f3af 8000 	nop.w
 800f28c:	f3af 8000 	nop.w

0800f290 <chSysDisable>:
 *          hardware priority.
 * @note    Do not invoke this API from within a kernel lock.
 *
 * @special
 */
static inline void chSysDisable(void) {
 800f290:	b508      	push	{r3, lr}

  port_disable();
 800f292:	f7ff ffd5 	bl	800f240 <port_disable>
  _dbg_check_disable();
}
 800f296:	bd08      	pop	{r3, pc}
 800f298:	f3af 8000 	nop.w
 800f29c:	f3af 8000 	nop.w

0800f2a0 <chSysSuspend>:
 * @note    This API is no replacement for @p chSysLock(), the @p chSysLock()
 *          could do more than just disable the interrupts.
 *
 * @special
 */
static inline void chSysSuspend(void) {
 800f2a0:	b508      	push	{r3, lr}

  port_suspend();
 800f2a2:	f7ff ffd5 	bl	800f250 <port_suspend>
  _dbg_check_suspend();
}
 800f2a6:	bd08      	pop	{r3, pc}
 800f2a8:	f3af 8000 	nop.w
 800f2ac:	f3af 8000 	nop.w

0800f2b0 <chSysEnable>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 800f2b0:	b508      	push	{r3, lr}

  _dbg_check_enable();
  port_enable();
 800f2b2:	f7ff ffdd 	bl	800f270 <port_enable>
}
 800f2b6:	bd08      	pop	{r3, pc}
 800f2b8:	f3af 8000 	nop.w
 800f2bc:	f3af 8000 	nop.w

0800f2c0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800f2c0:	b508      	push	{r3, lr}

  port_lock();
 800f2c2:	f7ff ff9d 	bl	800f200 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800f2c6:	bd08      	pop	{r3, pc}
 800f2c8:	f3af 8000 	nop.w
 800f2cc:	f3af 8000 	nop.w

0800f2d0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800f2d0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800f2d2:	f7ff ff9d 	bl	800f210 <port_unlock>
}
 800f2d6:	bd08      	pop	{r3, pc}
 800f2d8:	f3af 8000 	nop.w
 800f2dc:	f3af 8000 	nop.w

0800f2e0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 800f2e0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800f2e2:	f7ff ff9d 	bl	800f220 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 800f2e6:	bd08      	pop	{r3, pc}
 800f2e8:	f3af 8000 	nop.w
 800f2ec:	f3af 8000 	nop.w

0800f2f0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 800f2f0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 800f2f2:	f7ff ff9d 	bl	800f230 <port_unlock_from_isr>
}
 800f2f6:	bd08      	pop	{r3, pc}
 800f2f8:	f3af 8000 	nop.w
 800f2fc:	f3af 8000 	nop.w

0800f300 <chSysUnconditionalLock>:
 * @note    Can be called without previous knowledge of the current lock state.
 *          The final state is "s-locked".
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {
 800f300:	b508      	push	{r3, lr}

  if (port_irq_enabled(port_get_irq_status())) {
 800f302:	f7ff ff5d 	bl	800f1c0 <port_get_irq_status>
 800f306:	4603      	mov	r3, r0
 800f308:	4618      	mov	r0, r3
 800f30a:	f7ff ff69 	bl	800f1e0 <port_irq_enabled>
 800f30e:	4603      	mov	r3, r0
 800f310:	2b00      	cmp	r3, #0
 800f312:	d001      	beq.n	800f318 <chSysUnconditionalLock+0x18>
    chSysLock();
 800f314:	f7ff ffd4 	bl	800f2c0 <chSysLock>
  }
}
 800f318:	bd08      	pop	{r3, pc}
 800f31a:	bf00      	nop
 800f31c:	f3af 8000 	nop.w

0800f320 <chSysUnconditionalUnlock>:
 * @note    Can be called without previous knowledge of the current lock state.
 *          The final state is "normal".
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {
 800f320:	b508      	push	{r3, lr}

  if (!port_irq_enabled(port_get_irq_status())) {
 800f322:	f7ff ff4d 	bl	800f1c0 <port_get_irq_status>
 800f326:	4603      	mov	r3, r0
 800f328:	4618      	mov	r0, r3
 800f32a:	f7ff ff59 	bl	800f1e0 <port_irq_enabled>
 800f32e:	4603      	mov	r3, r0
 800f330:	f083 0301 	eor.w	r3, r3, #1
 800f334:	b2db      	uxtb	r3, r3
 800f336:	2b00      	cmp	r3, #0
 800f338:	d001      	beq.n	800f33e <chSysUnconditionalUnlock+0x1e>
    chSysUnlock();
 800f33a:	f7ff ffc9 	bl	800f2d0 <chSysUnlock>
  }
}
 800f33e:	bd08      	pop	{r3, pc}

0800f340 <chVTObjectInit>:
 *
 * @param[out] vtp      the @p virtual_timer_t structure pointer
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {
 800f340:	b082      	sub	sp, #8
 800f342:	9001      	str	r0, [sp, #4]

  vtp->vt_func = NULL;
 800f344:	9b01      	ldr	r3, [sp, #4]
 800f346:	2200      	movs	r2, #0
 800f348:	60da      	str	r2, [r3, #12]
}
 800f34a:	b002      	add	sp, #8
 800f34c:	4770      	bx	lr
 800f34e:	bf00      	nop

0800f350 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 800f350:	b082      	sub	sp, #8
 800f352:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->vt_func != NULL);
 800f354:	9b01      	ldr	r3, [sp, #4]
 800f356:	68db      	ldr	r3, [r3, #12]
 800f358:	2b00      	cmp	r3, #0
 800f35a:	bf0c      	ite	eq
 800f35c:	2300      	moveq	r3, #0
 800f35e:	2301      	movne	r3, #1
 800f360:	b2db      	uxtb	r3, r3
}
 800f362:	4618      	mov	r0, r3
 800f364:	b002      	add	sp, #8
 800f366:	4770      	bx	lr
 800f368:	f3af 8000 	nop.w
 800f36c:	f3af 8000 	nop.w

0800f370 <chVTIsArmed>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @api
 */
static inline bool chVTIsArmed(virtual_timer_t *vtp) {
 800f370:	b500      	push	{lr}
 800f372:	b085      	sub	sp, #20
 800f374:	9001      	str	r0, [sp, #4]
  bool b;

  chSysLock();
 800f376:	f7ff ffa3 	bl	800f2c0 <chSysLock>
  b = chVTIsArmedI(vtp);
 800f37a:	9801      	ldr	r0, [sp, #4]
 800f37c:	f7ff ffe8 	bl	800f350 <chVTIsArmedI>
 800f380:	4603      	mov	r3, r0
 800f382:	f88d 300f 	strb.w	r3, [sp, #15]
  chSysUnlock();
 800f386:	f7ff ffa3 	bl	800f2d0 <chSysUnlock>

  return b;
 800f38a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 800f38e:	4618      	mov	r0, r3
 800f390:	b005      	add	sp, #20
 800f392:	f85d fb04 	ldr.w	pc, [sp], #4
 800f396:	bf00      	nop
 800f398:	f3af 8000 	nop.w
 800f39c:	f3af 8000 	nop.w

0800f3a0 <chVTResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {
 800f3a0:	b500      	push	{lr}
 800f3a2:	b083      	sub	sp, #12
 800f3a4:	9001      	str	r0, [sp, #4]

  if (chVTIsArmedI(vtp)) {
 800f3a6:	9801      	ldr	r0, [sp, #4]
 800f3a8:	f7ff ffd2 	bl	800f350 <chVTIsArmedI>
 800f3ac:	4603      	mov	r3, r0
 800f3ae:	2b00      	cmp	r3, #0
 800f3b0:	d002      	beq.n	800f3b8 <chVTResetI+0x18>
    chVTDoResetI(vtp);
 800f3b2:	9801      	ldr	r0, [sp, #4]
 800f3b4:	f7f1 fb2c 	bl	8000a10 <chVTDoResetI>
  }
}
 800f3b8:	b003      	add	sp, #12
 800f3ba:	f85d fb04 	ldr.w	pc, [sp], #4
 800f3be:	bf00      	nop

0800f3c0 <chVTSetI>:
 *                      function
 *
 * @iclass
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {
 800f3c0:	b500      	push	{lr}
 800f3c2:	b085      	sub	sp, #20
 800f3c4:	9003      	str	r0, [sp, #12]
 800f3c6:	9102      	str	r1, [sp, #8]
 800f3c8:	9201      	str	r2, [sp, #4]
 800f3ca:	9300      	str	r3, [sp, #0]

  chVTResetI(vtp);
 800f3cc:	9803      	ldr	r0, [sp, #12]
 800f3ce:	f7ff ffe7 	bl	800f3a0 <chVTResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
 800f3d2:	9803      	ldr	r0, [sp, #12]
 800f3d4:	9902      	ldr	r1, [sp, #8]
 800f3d6:	9a01      	ldr	r2, [sp, #4]
 800f3d8:	9b00      	ldr	r3, [sp, #0]
 800f3da:	f7f1 fad9 	bl	8000990 <chVTDoSetI>
}
 800f3de:	b005      	add	sp, #20
 800f3e0:	f85d fb04 	ldr.w	pc, [sp], #4
 800f3e4:	f3af 8000 	nop.w
 800f3e8:	f3af 8000 	nop.w
 800f3ec:	f3af 8000 	nop.w

0800f3f0 <chVTSet>:
 *                      function
 *
 * @api
 */
static inline void chVTSet(virtual_timer_t *vtp, systime_t delay,
                           vtfunc_t vtfunc, void *par) {
 800f3f0:	b500      	push	{lr}
 800f3f2:	b085      	sub	sp, #20
 800f3f4:	9003      	str	r0, [sp, #12]
 800f3f6:	9102      	str	r1, [sp, #8]
 800f3f8:	9201      	str	r2, [sp, #4]
 800f3fa:	9300      	str	r3, [sp, #0]

  chSysLock();
 800f3fc:	f7ff ff60 	bl	800f2c0 <chSysLock>
  chVTSetI(vtp, delay, vtfunc, par);
 800f400:	9803      	ldr	r0, [sp, #12]
 800f402:	9902      	ldr	r1, [sp, #8]
 800f404:	9a01      	ldr	r2, [sp, #4]
 800f406:	9b00      	ldr	r3, [sp, #0]
 800f408:	f7ff ffda 	bl	800f3c0 <chVTSetI>
  chSysUnlock();
 800f40c:	f7ff ff60 	bl	800f2d0 <chSysUnlock>
}
 800f410:	b005      	add	sp, #20
 800f412:	f85d fb04 	ldr.w	pc, [sp], #4
 800f416:	bf00      	nop
 800f418:	f3af 8000 	nop.w
 800f41c:	f3af 8000 	nop.w

0800f420 <vtcb>:
 *
 * <h2>Description</h2>
 * The critical zones API is invoked for coverage.
 */

static void vtcb(void *p) {
 800f420:	b500      	push	{lr}
 800f422:	b085      	sub	sp, #20
 800f424:	9001      	str	r0, [sp, #4]
  syssts_t sts;

  (void)p;

  /* Testing normal case.*/
  chSysLockFromISR();
 800f426:	f7ff ff5b 	bl	800f2e0 <chSysLockFromISR>
  chSysUnlockFromISR();
 800f42a:	f7ff ff61 	bl	800f2f0 <chSysUnlockFromISR>

  /* Reentrant case.*/
  chSysLockFromISR();
 800f42e:	f7ff ff57 	bl	800f2e0 <chSysLockFromISR>
  sts = chSysGetStatusAndLockX();
 800f432:	f7f1 fa25 	bl	8000880 <chSysGetStatusAndLockX>
 800f436:	9003      	str	r0, [sp, #12]
  chSysRestoreStatusX(sts);
 800f438:	9803      	ldr	r0, [sp, #12]
 800f43a:	f7f1 fa41 	bl	80008c0 <chSysRestoreStatusX>
  chSysUnlockFromISR();
 800f43e:	f7ff ff57 	bl	800f2f0 <chSysUnlockFromISR>
}
 800f442:	b005      	add	sp, #20
 800f444:	f85d fb04 	ldr.w	pc, [sp], #4
 800f448:	f3af 8000 	nop.w
 800f44c:	f3af 8000 	nop.w

0800f450 <sys1_execute>:

static void sys1_execute(void) {
 800f450:	b500      	push	{lr}
 800f452:	b087      	sub	sp, #28
  syssts_t sts;
  virtual_timer_t vt;

  /* Testing normal case.*/
  sts = chSysGetStatusAndLockX();
 800f454:	f7f1 fa14 	bl	8000880 <chSysGetStatusAndLockX>
 800f458:	9005      	str	r0, [sp, #20]
  chSysRestoreStatusX(sts);
 800f45a:	9805      	ldr	r0, [sp, #20]
 800f45c:	f7f1 fa30 	bl	80008c0 <chSysRestoreStatusX>

  /* Reentrant case.*/
  chSysLock();
 800f460:	f7ff ff2e 	bl	800f2c0 <chSysLock>
  sts = chSysGetStatusAndLockX();
 800f464:	f7f1 fa0c 	bl	8000880 <chSysGetStatusAndLockX>
 800f468:	9005      	str	r0, [sp, #20]
  chSysRestoreStatusX(sts);
 800f46a:	9805      	ldr	r0, [sp, #20]
 800f46c:	f7f1 fa28 	bl	80008c0 <chSysRestoreStatusX>
  chSysUnlock();
 800f470:	f7ff ff2e 	bl	800f2d0 <chSysUnlock>

  /* Unconditional lock.*/
  chSysUnconditionalLock();
 800f474:	f7ff ff44 	bl	800f300 <chSysUnconditionalLock>
  chSysUnconditionalLock();
 800f478:	f7ff ff42 	bl	800f300 <chSysUnconditionalLock>
  chSysUnlock();
 800f47c:	f7ff ff28 	bl	800f2d0 <chSysUnlock>

  /* Unconditional unlock.*/
  chSysLock();
 800f480:	f7ff ff1e 	bl	800f2c0 <chSysLock>
  chSysUnconditionalUnlock();
 800f484:	f7ff ff4c 	bl	800f320 <chSysUnconditionalUnlock>
  chSysUnconditionalUnlock();
 800f488:	f7ff ff4a 	bl	800f320 <chSysUnconditionalUnlock>

  /*/Testing from ISR context using a virtual timer.*/
  chVTObjectInit(&vt);
 800f48c:	466b      	mov	r3, sp
 800f48e:	4618      	mov	r0, r3
 800f490:	f7ff ff56 	bl	800f340 <chVTObjectInit>
  chVTSet(&vt, 1, vtcb, NULL);
 800f494:	466b      	mov	r3, sp
 800f496:	4618      	mov	r0, r3
 800f498:	2101      	movs	r1, #1
 800f49a:	4a10      	ldr	r2, [pc, #64]	; (800f4dc <sys1_execute+0x8c>)
 800f49c:	2300      	movs	r3, #0
 800f49e:	f7ff ffa7 	bl	800f3f0 <chVTSet>
  chThdSleep(10);
 800f4a2:	200a      	movs	r0, #10
 800f4a4:	f7f1 ff14 	bl	80012d0 <chThdSleep>

  test_assert(1, chVTIsArmed(&vt) == false, "timer still armed");
 800f4a8:	466b      	mov	r3, sp
 800f4aa:	4618      	mov	r0, r3
 800f4ac:	f7ff ff60 	bl	800f370 <chVTIsArmed>
 800f4b0:	4603      	mov	r3, r0
 800f4b2:	2b00      	cmp	r3, #0
 800f4b4:	bf0c      	ite	eq
 800f4b6:	2300      	moveq	r3, #0
 800f4b8:	2301      	movne	r3, #1
 800f4ba:	b2db      	uxtb	r3, r3
 800f4bc:	f083 0301 	eor.w	r3, r3, #1
 800f4c0:	b2db      	uxtb	r3, r3
 800f4c2:	f003 0301 	and.w	r3, r3, #1
 800f4c6:	b2db      	uxtb	r3, r3
 800f4c8:	2001      	movs	r0, #1
 800f4ca:	4619      	mov	r1, r3
 800f4cc:	f7fb fef0 	bl	800b2b0 <_test_assert>
 800f4d0:	4603      	mov	r3, r0
 800f4d2:	2b00      	cmp	r3, #0
}
 800f4d4:	b007      	add	sp, #28
 800f4d6:	f85d fb04 	ldr.w	pc, [sp], #4
 800f4da:	bf00      	nop
 800f4dc:	0800f421 	.word	0x0800f421

0800f4e0 <sys2_execute>:
 *
 * <h2>Description</h2>
 * The interrupts handling API is invoked for coverage.
 */

static void sys2_execute(void) {
 800f4e0:	b508      	push	{r3, lr}

  chSysSuspend();
 800f4e2:	f7ff fedd 	bl	800f2a0 <chSysSuspend>
  chSysDisable();
 800f4e6:	f7ff fed3 	bl	800f290 <chSysDisable>
  chSysSuspend();
 800f4ea:	f7ff fed9 	bl	800f2a0 <chSysSuspend>
  chSysEnable();
 800f4ee:	f7ff fedf 	bl	800f2b0 <chSysEnable>
}
 800f4f2:	bd08      	pop	{r3, pc}
 800f4f4:	f3af 8000 	nop.w
 800f4f8:	f3af 8000 	nop.w
 800f4fc:	f3af 8000 	nop.w

0800f500 <sys3_execute>:
 * <h2>Description</h2>
 * The chSysIntegrityCheckI() API is invoked in order to asses the state of the
 * system data structures.
 */

static void sys3_execute(void) {
 800f500:	b500      	push	{lr}
 800f502:	b083      	sub	sp, #12
  bool result;

  chSysLock();
 800f504:	f7ff fedc 	bl	800f2c0 <chSysLock>
  result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
 800f508:	2001      	movs	r0, #1
 800f50a:	f7f1 f919 	bl	8000740 <chSysIntegrityCheckI>
 800f50e:	4603      	mov	r3, r0
 800f510:	f88d 3007 	strb.w	r3, [sp, #7]
  chSysUnlock();
 800f514:	f7ff fedc 	bl	800f2d0 <chSysUnlock>
  test_assert(1, result == false, "ready list check failed");
 800f518:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800f51c:	2b00      	cmp	r3, #0
 800f51e:	bf0c      	ite	eq
 800f520:	2300      	moveq	r3, #0
 800f522:	2301      	movne	r3, #1
 800f524:	b2db      	uxtb	r3, r3
 800f526:	f083 0301 	eor.w	r3, r3, #1
 800f52a:	b2db      	uxtb	r3, r3
 800f52c:	f003 0301 	and.w	r3, r3, #1
 800f530:	b2db      	uxtb	r3, r3
 800f532:	2001      	movs	r0, #1
 800f534:	4619      	mov	r1, r3
 800f536:	f7fb febb 	bl	800b2b0 <_test_assert>
 800f53a:	4603      	mov	r3, r0
 800f53c:	2b00      	cmp	r3, #0
 800f53e:	d000      	beq.n	800f542 <sys3_execute+0x42>
 800f540:	e05c      	b.n	800f5fc <sys3_execute+0xfc>

  chSysLock();
 800f542:	f7ff febd 	bl	800f2c0 <chSysLock>
  result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
 800f546:	2002      	movs	r0, #2
 800f548:	f7f1 f8fa 	bl	8000740 <chSysIntegrityCheckI>
 800f54c:	4603      	mov	r3, r0
 800f54e:	f88d 3007 	strb.w	r3, [sp, #7]
  chSysUnlock();
 800f552:	f7ff febd 	bl	800f2d0 <chSysUnlock>
  test_assert(2, result == false, "virtual timers list check failed");
 800f556:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800f55a:	2b00      	cmp	r3, #0
 800f55c:	bf0c      	ite	eq
 800f55e:	2300      	moveq	r3, #0
 800f560:	2301      	movne	r3, #1
 800f562:	b2db      	uxtb	r3, r3
 800f564:	f083 0301 	eor.w	r3, r3, #1
 800f568:	b2db      	uxtb	r3, r3
 800f56a:	f003 0301 	and.w	r3, r3, #1
 800f56e:	b2db      	uxtb	r3, r3
 800f570:	2002      	movs	r0, #2
 800f572:	4619      	mov	r1, r3
 800f574:	f7fb fe9c 	bl	800b2b0 <_test_assert>
 800f578:	4603      	mov	r3, r0
 800f57a:	2b00      	cmp	r3, #0
 800f57c:	d000      	beq.n	800f580 <sys3_execute+0x80>
 800f57e:	e03d      	b.n	800f5fc <sys3_execute+0xfc>

  chSysLock();
 800f580:	f7ff fe9e 	bl	800f2c0 <chSysLock>
  result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
 800f584:	2004      	movs	r0, #4
 800f586:	f7f1 f8db 	bl	8000740 <chSysIntegrityCheckI>
 800f58a:	4603      	mov	r3, r0
 800f58c:	f88d 3007 	strb.w	r3, [sp, #7]
  chSysUnlock();
 800f590:	f7ff fe9e 	bl	800f2d0 <chSysUnlock>
  test_assert(3, result == false, "registry list check failed");
 800f594:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800f598:	2b00      	cmp	r3, #0
 800f59a:	bf0c      	ite	eq
 800f59c:	2300      	moveq	r3, #0
 800f59e:	2301      	movne	r3, #1
 800f5a0:	b2db      	uxtb	r3, r3
 800f5a2:	f083 0301 	eor.w	r3, r3, #1
 800f5a6:	b2db      	uxtb	r3, r3
 800f5a8:	f003 0301 	and.w	r3, r3, #1
 800f5ac:	b2db      	uxtb	r3, r3
 800f5ae:	2003      	movs	r0, #3
 800f5b0:	4619      	mov	r1, r3
 800f5b2:	f7fb fe7d 	bl	800b2b0 <_test_assert>
 800f5b6:	4603      	mov	r3, r0
 800f5b8:	2b00      	cmp	r3, #0
 800f5ba:	d000      	beq.n	800f5be <sys3_execute+0xbe>
 800f5bc:	e01e      	b.n	800f5fc <sys3_execute+0xfc>

  chSysLock();
 800f5be:	f7ff fe7f 	bl	800f2c0 <chSysLock>
  result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
 800f5c2:	2008      	movs	r0, #8
 800f5c4:	f7f1 f8bc 	bl	8000740 <chSysIntegrityCheckI>
 800f5c8:	4603      	mov	r3, r0
 800f5ca:	f88d 3007 	strb.w	r3, [sp, #7]
  chSysUnlock();
 800f5ce:	f7ff fe7f 	bl	800f2d0 <chSysUnlock>
  test_assert(4, result == false, "port layer check failed");
 800f5d2:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800f5d6:	2b00      	cmp	r3, #0
 800f5d8:	bf0c      	ite	eq
 800f5da:	2300      	moveq	r3, #0
 800f5dc:	2301      	movne	r3, #1
 800f5de:	b2db      	uxtb	r3, r3
 800f5e0:	f083 0301 	eor.w	r3, r3, #1
 800f5e4:	b2db      	uxtb	r3, r3
 800f5e6:	f003 0301 	and.w	r3, r3, #1
 800f5ea:	b2db      	uxtb	r3, r3
 800f5ec:	2004      	movs	r0, #4
 800f5ee:	4619      	mov	r1, r3
 800f5f0:	f7fb fe5e 	bl	800b2b0 <_test_assert>
 800f5f4:	4603      	mov	r3, r0
 800f5f6:	2b00      	cmp	r3, #0
 800f5f8:	d000      	beq.n	800f5fc <sys3_execute+0xfc>
 800f5fa:	bf00      	nop
}
 800f5fc:	b003      	add	sp, #12
 800f5fe:	f85d fb04 	ldr.w	pc, [sp], #4
 800f602:	bf00      	nop
 800f604:	f3af 8000 	nop.w
 800f608:	f3af 8000 	nop.w
 800f60c:	f3af 8000 	nop.w

0800f610 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800f610:	b082      	sub	sp, #8
 800f612:	2320      	movs	r3, #32
 800f614:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800f616:	9b01      	ldr	r3, [sp, #4]
 800f618:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800f61c:	b002      	add	sp, #8
 800f61e:	4770      	bx	lr

0800f620 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800f620:	b082      	sub	sp, #8
 800f622:	2300      	movs	r3, #0
 800f624:	9301      	str	r3, [sp, #4]
 800f626:	9b01      	ldr	r3, [sp, #4]
 800f628:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800f62c:	b002      	add	sp, #8
 800f62e:	4770      	bx	lr

0800f630 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800f630:	b508      	push	{r3, lr}

  port_lock();
 800f632:	f7ff ffed 	bl	800f610 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800f636:	bd08      	pop	{r3, pc}
 800f638:	f3af 8000 	nop.w
 800f63c:	f3af 8000 	nop.w

0800f640 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800f640:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800f642:	f7ff ffed 	bl	800f620 <port_unlock>
}
 800f646:	bd08      	pop	{r3, pc}
 800f648:	f3af 8000 	nop.w
 800f64c:	f3af 8000 	nop.w

0800f650 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800f650:	4b01      	ldr	r3, [pc, #4]	; (800f658 <chThdGetSelfX+0x8>)
 800f652:	699b      	ldr	r3, [r3, #24]
}
 800f654:	4618      	mov	r0, r3
 800f656:	4770      	bx	lr
 800f658:	20000d98 	.word	0x20000d98
 800f65c:	f3af 8000 	nop.w

0800f660 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800f660:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800f662:	f7ff fff5 	bl	800f650 <chThdGetSelfX>
 800f666:	4603      	mov	r3, r0
 800f668:	689b      	ldr	r3, [r3, #8]
}
 800f66a:	4618      	mov	r0, r3
 800f66c:	bd08      	pop	{r3, pc}
 800f66e:	bf00      	nop

0800f670 <chThdShouldTerminateX>:
 * @retval true         termination request pending.
 * @retval false        termination request not pending.
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {
 800f670:	b508      	push	{r3, lr}

  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 800f672:	f7ff ffed 	bl	800f650 <chThdGetSelfX>
 800f676:	4603      	mov	r3, r0
 800f678:	7f5b      	ldrb	r3, [r3, #29]
 800f67a:	f003 0304 	and.w	r3, r3, #4
 800f67e:	2b00      	cmp	r3, #0
 800f680:	bf0c      	ite	eq
 800f682:	2300      	moveq	r3, #0
 800f684:	2301      	movne	r3, #1
 800f686:	b2db      	uxtb	r3, r3
}
 800f688:	4618      	mov	r0, r3
 800f68a:	bd08      	pop	{r3, pc}
 800f68c:	f3af 8000 	nop.w

0800f690 <chMsgGet>:
 * @param[in] tp        pointer to the thread
 * @return              The message carried by the sender.
 *
 * @api
 */
static inline msg_t chMsgGet(thread_t *tp) {
 800f690:	b082      	sub	sp, #8
 800f692:	9001      	str	r0, [sp, #4]

  return tp->p_msg;
 800f694:	9b01      	ldr	r3, [sp, #4]
 800f696:	6b1b      	ldr	r3, [r3, #48]	; 0x30
}
 800f698:	4618      	mov	r0, r3
 800f69a:	b002      	add	sp, #8
 800f69c:	4770      	bx	lr
 800f69e:	bf00      	nop

0800f6a0 <chIQGet>:
 * @return              A byte value from the queue.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {
 800f6a0:	b500      	push	{lr}
 800f6a2:	b083      	sub	sp, #12
 800f6a4:	9001      	str	r0, [sp, #4]

  return chIQGetTimeout(iqp, TIME_INFINITE);
 800f6a6:	9801      	ldr	r0, [sp, #4]
 800f6a8:	f04f 31ff 	mov.w	r1, #4294967295
 800f6ac:	f7f3 fde8 	bl	8003280 <chIQGetTimeout>
 800f6b0:	4603      	mov	r3, r0
}
 800f6b2:	4618      	mov	r0, r3
 800f6b4:	b003      	add	sp, #12
 800f6b6:	f85d fb04 	ldr.w	pc, [sp], #4
 800f6ba:	bf00      	nop
 800f6bc:	f3af 8000 	nop.w

0800f6c0 <thread1>:
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
static mutex_t mtx1;
#endif

static THD_FUNCTION(thread1, p) {
 800f6c0:	b500      	push	{lr}
 800f6c2:	b083      	sub	sp, #12
 800f6c4:	9001      	str	r0, [sp, #4]

  chThdExit((msg_t)p);
 800f6c6:	9b01      	ldr	r3, [sp, #4]
 800f6c8:	4618      	mov	r0, r3
 800f6ca:	f7f1 fe51 	bl	8001370 <chThdExit>
}
 800f6ce:	b003      	add	sp, #12
 800f6d0:	f85d fb04 	ldr.w	pc, [sp], #4
 800f6d4:	f3af 8000 	nop.w
 800f6d8:	f3af 8000 	nop.w
 800f6dc:	f3af 8000 	nop.w

0800f6e0 <thread2>:

#if CH_CFG_USE_MESSAGES || defined(__DOXYGEN__)
static THD_FUNCTION(thread2, p) {
 800f6e0:	b500      	push	{lr}
 800f6e2:	b085      	sub	sp, #20
 800f6e4:	9001      	str	r0, [sp, #4]
  thread_t *tp;
  msg_t msg;

  (void)p;
  do {
    tp = chMsgWait();
 800f6e6:	f7f3 fa8b 	bl	8002c00 <chMsgWait>
 800f6ea:	9003      	str	r0, [sp, #12]
    msg = chMsgGet(tp);
 800f6ec:	9803      	ldr	r0, [sp, #12]
 800f6ee:	f7ff ffcf 	bl	800f690 <chMsgGet>
 800f6f2:	9002      	str	r0, [sp, #8]
    chMsgRelease(tp, msg);
 800f6f4:	9803      	ldr	r0, [sp, #12]
 800f6f6:	9902      	ldr	r1, [sp, #8]
 800f6f8:	f7f3 faaa 	bl	8002c50 <chMsgRelease>
  } while (msg);
 800f6fc:	9b02      	ldr	r3, [sp, #8]
 800f6fe:	2b00      	cmp	r3, #0
 800f700:	d1f1      	bne.n	800f6e6 <thread2+0x6>
}
 800f702:	b005      	add	sp, #20
 800f704:	f85d fb04 	ldr.w	pc, [sp], #4
 800f708:	f3af 8000 	nop.w
 800f70c:	f3af 8000 	nop.w

0800f710 <msg_loop_test>:

#ifdef __GNUC__
__attribute__((noinline))
#endif
static unsigned int msg_loop_test(thread_t *tp) {
 800f710:	b500      	push	{lr}
 800f712:	b085      	sub	sp, #20
 800f714:	9001      	str	r0, [sp, #4]

  uint32_t n = 0;
 800f716:	2300      	movs	r3, #0
 800f718:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 800f71a:	f7fb fe71 	bl	800b400 <test_wait_tick>
  test_start_timer(1000);
 800f71e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800f722:	f7fb fe8d 	bl	800b440 <test_start_timer>
  do {
    (void)chMsgSend(tp, 1);
 800f726:	9801      	ldr	r0, [sp, #4]
 800f728:	2101      	movs	r1, #1
 800f72a:	f7f3 fa39 	bl	8002ba0 <chMsgSend>
    n++;
 800f72e:	9b03      	ldr	r3, [sp, #12]
 800f730:	3301      	adds	r3, #1
 800f732:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 800f734:	4b07      	ldr	r3, [pc, #28]	; (800f754 <msg_loop_test+0x44>)
 800f736:	781b      	ldrb	r3, [r3, #0]
 800f738:	f083 0301 	eor.w	r3, r3, #1
 800f73c:	b2db      	uxtb	r3, r3
 800f73e:	2b00      	cmp	r3, #0
 800f740:	d1f1      	bne.n	800f726 <msg_loop_test+0x16>
  (void)chMsgSend(tp, 0);
 800f742:	9801      	ldr	r0, [sp, #4]
 800f744:	2100      	movs	r1, #0
 800f746:	f7f3 fa2b 	bl	8002ba0 <chMsgSend>
  return n;
 800f74a:	9b03      	ldr	r3, [sp, #12]
}
 800f74c:	4618      	mov	r0, r3
 800f74e:	b005      	add	sp, #20
 800f750:	f85d fb04 	ldr.w	pc, [sp], #4
 800f754:	20001221 	.word	0x20001221
 800f758:	f3af 8000 	nop.w
 800f75c:	f3af 8000 	nop.w

0800f760 <bmk1_execute>:
 * A message server thread is created with a lower priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk1_execute(void) {
 800f760:	b510      	push	{r4, lr}
 800f762:	b084      	sub	sp, #16
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2, NULL);
 800f764:	4b16      	ldr	r3, [pc, #88]	; (800f7c0 <bmk1_execute+0x60>)
 800f766:	681c      	ldr	r4, [r3, #0]
 800f768:	f7ff ff7a 	bl	800f660 <chThdGetPriorityX>
 800f76c:	4603      	mov	r3, r0
 800f76e:	3b01      	subs	r3, #1
 800f770:	2200      	movs	r2, #0
 800f772:	9200      	str	r2, [sp, #0]
 800f774:	4620      	mov	r0, r4
 800f776:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f77a:	461a      	mov	r2, r3
 800f77c:	4b11      	ldr	r3, [pc, #68]	; (800f7c4 <bmk1_execute+0x64>)
 800f77e:	f7f1 fd2f 	bl	80011e0 <chThdCreateStatic>
 800f782:	4602      	mov	r2, r0
 800f784:	4b10      	ldr	r3, [pc, #64]	; (800f7c8 <bmk1_execute+0x68>)
 800f786:	601a      	str	r2, [r3, #0]
  n = msg_loop_test(threads[0]);
 800f788:	4b0f      	ldr	r3, [pc, #60]	; (800f7c8 <bmk1_execute+0x68>)
 800f78a:	681b      	ldr	r3, [r3, #0]
 800f78c:	4618      	mov	r0, r3
 800f78e:	f7ff ffbf 	bl	800f710 <msg_loop_test>
 800f792:	9003      	str	r0, [sp, #12]
  test_wait_threads();
 800f794:	f7fb fe0c 	bl	800b3b0 <test_wait_threads>
  test_print("--- Score : ");
 800f798:	480c      	ldr	r0, [pc, #48]	; (800f7cc <bmk1_execute+0x6c>)
 800f79a:	f7fb fcf9 	bl	800b190 <test_print>
  test_printn(n);
 800f79e:	9803      	ldr	r0, [sp, #12]
 800f7a0:	f7fb fcae 	bl	800b100 <test_printn>
  test_print(" msgs/S, ");
 800f7a4:	480a      	ldr	r0, [pc, #40]	; (800f7d0 <bmk1_execute+0x70>)
 800f7a6:	f7fb fcf3 	bl	800b190 <test_print>
  test_printn(n << 1);
 800f7aa:	9b03      	ldr	r3, [sp, #12]
 800f7ac:	005b      	lsls	r3, r3, #1
 800f7ae:	4618      	mov	r0, r3
 800f7b0:	f7fb fca6 	bl	800b100 <test_printn>
  test_println(" ctxswc/S");
 800f7b4:	4807      	ldr	r0, [pc, #28]	; (800f7d4 <bmk1_execute+0x74>)
 800f7b6:	f7fb fd0b 	bl	800b1d0 <test_println>
}
 800f7ba:	b004      	add	sp, #16
 800f7bc:	bd10      	pop	{r4, pc}
 800f7be:	bf00      	nop
 800f7c0:	08016240 	.word	0x08016240
 800f7c4:	0800f6e1 	.word	0x0800f6e1
 800f7c8:	20001224 	.word	0x20001224
 800f7cc:	08016ad0 	.word	0x08016ad0
 800f7d0:	08016ae0 	.word	0x08016ae0
 800f7d4:	08016aec 	.word	0x08016aec
 800f7d8:	f3af 8000 	nop.w
 800f7dc:	f3af 8000 	nop.w

0800f7e0 <bmk2_execute>:
 * A message server thread is created with an higher priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk2_execute(void) {
 800f7e0:	b510      	push	{r4, lr}
 800f7e2:	b084      	sub	sp, #16
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 800f7e4:	4b16      	ldr	r3, [pc, #88]	; (800f840 <bmk2_execute+0x60>)
 800f7e6:	681c      	ldr	r4, [r3, #0]
 800f7e8:	f7ff ff3a 	bl	800f660 <chThdGetPriorityX>
 800f7ec:	4603      	mov	r3, r0
 800f7ee:	3301      	adds	r3, #1
 800f7f0:	2200      	movs	r2, #0
 800f7f2:	9200      	str	r2, [sp, #0]
 800f7f4:	4620      	mov	r0, r4
 800f7f6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f7fa:	461a      	mov	r2, r3
 800f7fc:	4b11      	ldr	r3, [pc, #68]	; (800f844 <bmk2_execute+0x64>)
 800f7fe:	f7f1 fcef 	bl	80011e0 <chThdCreateStatic>
 800f802:	4602      	mov	r2, r0
 800f804:	4b10      	ldr	r3, [pc, #64]	; (800f848 <bmk2_execute+0x68>)
 800f806:	601a      	str	r2, [r3, #0]
  n = msg_loop_test(threads[0]);
 800f808:	4b0f      	ldr	r3, [pc, #60]	; (800f848 <bmk2_execute+0x68>)
 800f80a:	681b      	ldr	r3, [r3, #0]
 800f80c:	4618      	mov	r0, r3
 800f80e:	f7ff ff7f 	bl	800f710 <msg_loop_test>
 800f812:	9003      	str	r0, [sp, #12]
  test_wait_threads();
 800f814:	f7fb fdcc 	bl	800b3b0 <test_wait_threads>
  test_print("--- Score : ");
 800f818:	480c      	ldr	r0, [pc, #48]	; (800f84c <bmk2_execute+0x6c>)
 800f81a:	f7fb fcb9 	bl	800b190 <test_print>
  test_printn(n);
 800f81e:	9803      	ldr	r0, [sp, #12]
 800f820:	f7fb fc6e 	bl	800b100 <test_printn>
  test_print(" msgs/S, ");
 800f824:	480a      	ldr	r0, [pc, #40]	; (800f850 <bmk2_execute+0x70>)
 800f826:	f7fb fcb3 	bl	800b190 <test_print>
  test_printn(n << 1);
 800f82a:	9b03      	ldr	r3, [sp, #12]
 800f82c:	005b      	lsls	r3, r3, #1
 800f82e:	4618      	mov	r0, r3
 800f830:	f7fb fc66 	bl	800b100 <test_printn>
  test_println(" ctxswc/S");
 800f834:	4807      	ldr	r0, [pc, #28]	; (800f854 <bmk2_execute+0x74>)
 800f836:	f7fb fccb 	bl	800b1d0 <test_println>
}
 800f83a:	b004      	add	sp, #16
 800f83c:	bd10      	pop	{r4, pc}
 800f83e:	bf00      	nop
 800f840:	08016240 	.word	0x08016240
 800f844:	0800f6e1 	.word	0x0800f6e1
 800f848:	20001224 	.word	0x20001224
 800f84c:	08016ad0 	.word	0x08016ad0
 800f850:	08016ae0 	.word	0x08016ae0
 800f854:	08016aec 	.word	0x08016aec
 800f858:	f3af 8000 	nop.w
 800f85c:	f3af 8000 	nop.w

0800f860 <bmk3_execute>:
 * thread, four lower priority threads crowd the ready list, the messages
 * throughput per second is measured while the ready list and the result
 * printed in the output log.
 */

static void bmk3_execute(void) {
 800f860:	b510      	push	{r4, lr}
 800f862:	b084      	sub	sp, #16
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 800f864:	4b3a      	ldr	r3, [pc, #232]	; (800f950 <bmk3_execute+0xf0>)
 800f866:	681c      	ldr	r4, [r3, #0]
 800f868:	f7ff fefa 	bl	800f660 <chThdGetPriorityX>
 800f86c:	4603      	mov	r3, r0
 800f86e:	3301      	adds	r3, #1
 800f870:	2200      	movs	r2, #0
 800f872:	9200      	str	r2, [sp, #0]
 800f874:	4620      	mov	r0, r4
 800f876:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f87a:	461a      	mov	r2, r3
 800f87c:	4b35      	ldr	r3, [pc, #212]	; (800f954 <bmk3_execute+0xf4>)
 800f87e:	f7f1 fcaf 	bl	80011e0 <chThdCreateStatic>
 800f882:	4602      	mov	r2, r0
 800f884:	4b34      	ldr	r3, [pc, #208]	; (800f958 <bmk3_execute+0xf8>)
 800f886:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 800f888:	4b31      	ldr	r3, [pc, #196]	; (800f950 <bmk3_execute+0xf0>)
 800f88a:	685c      	ldr	r4, [r3, #4]
 800f88c:	f7ff fee8 	bl	800f660 <chThdGetPriorityX>
 800f890:	4603      	mov	r3, r0
 800f892:	3b02      	subs	r3, #2
 800f894:	2200      	movs	r2, #0
 800f896:	9200      	str	r2, [sp, #0]
 800f898:	4620      	mov	r0, r4
 800f89a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f89e:	461a      	mov	r2, r3
 800f8a0:	4b2e      	ldr	r3, [pc, #184]	; (800f95c <bmk3_execute+0xfc>)
 800f8a2:	f7f1 fc9d 	bl	80011e0 <chThdCreateStatic>
 800f8a6:	4602      	mov	r2, r0
 800f8a8:	4b2b      	ldr	r3, [pc, #172]	; (800f958 <bmk3_execute+0xf8>)
 800f8aa:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
 800f8ac:	4b28      	ldr	r3, [pc, #160]	; (800f950 <bmk3_execute+0xf0>)
 800f8ae:	689c      	ldr	r4, [r3, #8]
 800f8b0:	f7ff fed6 	bl	800f660 <chThdGetPriorityX>
 800f8b4:	4603      	mov	r3, r0
 800f8b6:	3b03      	subs	r3, #3
 800f8b8:	2200      	movs	r2, #0
 800f8ba:	9200      	str	r2, [sp, #0]
 800f8bc:	4620      	mov	r0, r4
 800f8be:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f8c2:	461a      	mov	r2, r3
 800f8c4:	4b25      	ldr	r3, [pc, #148]	; (800f95c <bmk3_execute+0xfc>)
 800f8c6:	f7f1 fc8b 	bl	80011e0 <chThdCreateStatic>
 800f8ca:	4602      	mov	r2, r0
 800f8cc:	4b22      	ldr	r3, [pc, #136]	; (800f958 <bmk3_execute+0xf8>)
 800f8ce:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
 800f8d0:	4b1f      	ldr	r3, [pc, #124]	; (800f950 <bmk3_execute+0xf0>)
 800f8d2:	68dc      	ldr	r4, [r3, #12]
 800f8d4:	f7ff fec4 	bl	800f660 <chThdGetPriorityX>
 800f8d8:	4603      	mov	r3, r0
 800f8da:	3b04      	subs	r3, #4
 800f8dc:	2200      	movs	r2, #0
 800f8de:	9200      	str	r2, [sp, #0]
 800f8e0:	4620      	mov	r0, r4
 800f8e2:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f8e6:	461a      	mov	r2, r3
 800f8e8:	4b1c      	ldr	r3, [pc, #112]	; (800f95c <bmk3_execute+0xfc>)
 800f8ea:	f7f1 fc79 	bl	80011e0 <chThdCreateStatic>
 800f8ee:	4602      	mov	r2, r0
 800f8f0:	4b19      	ldr	r3, [pc, #100]	; (800f958 <bmk3_execute+0xf8>)
 800f8f2:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, thread1, NULL);
 800f8f4:	4b16      	ldr	r3, [pc, #88]	; (800f950 <bmk3_execute+0xf0>)
 800f8f6:	691c      	ldr	r4, [r3, #16]
 800f8f8:	f7ff feb2 	bl	800f660 <chThdGetPriorityX>
 800f8fc:	4603      	mov	r3, r0
 800f8fe:	3b05      	subs	r3, #5
 800f900:	2200      	movs	r2, #0
 800f902:	9200      	str	r2, [sp, #0]
 800f904:	4620      	mov	r0, r4
 800f906:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f90a:	461a      	mov	r2, r3
 800f90c:	4b13      	ldr	r3, [pc, #76]	; (800f95c <bmk3_execute+0xfc>)
 800f90e:	f7f1 fc67 	bl	80011e0 <chThdCreateStatic>
 800f912:	4602      	mov	r2, r0
 800f914:	4b10      	ldr	r3, [pc, #64]	; (800f958 <bmk3_execute+0xf8>)
 800f916:	611a      	str	r2, [r3, #16]
  n = msg_loop_test(threads[0]);
 800f918:	4b0f      	ldr	r3, [pc, #60]	; (800f958 <bmk3_execute+0xf8>)
 800f91a:	681b      	ldr	r3, [r3, #0]
 800f91c:	4618      	mov	r0, r3
 800f91e:	f7ff fef7 	bl	800f710 <msg_loop_test>
 800f922:	9003      	str	r0, [sp, #12]
  test_wait_threads();
 800f924:	f7fb fd44 	bl	800b3b0 <test_wait_threads>
  test_print("--- Score : ");
 800f928:	480d      	ldr	r0, [pc, #52]	; (800f960 <bmk3_execute+0x100>)
 800f92a:	f7fb fc31 	bl	800b190 <test_print>
  test_printn(n);
 800f92e:	9803      	ldr	r0, [sp, #12]
 800f930:	f7fb fbe6 	bl	800b100 <test_printn>
  test_print(" msgs/S, ");
 800f934:	480b      	ldr	r0, [pc, #44]	; (800f964 <bmk3_execute+0x104>)
 800f936:	f7fb fc2b 	bl	800b190 <test_print>
  test_printn(n << 1);
 800f93a:	9b03      	ldr	r3, [sp, #12]
 800f93c:	005b      	lsls	r3, r3, #1
 800f93e:	4618      	mov	r0, r3
 800f940:	f7fb fbde 	bl	800b100 <test_printn>
  test_println(" ctxswc/S");
 800f944:	4808      	ldr	r0, [pc, #32]	; (800f968 <bmk3_execute+0x108>)
 800f946:	f7fb fc43 	bl	800b1d0 <test_println>
}
 800f94a:	b004      	add	sp, #16
 800f94c:	bd10      	pop	{r4, pc}
 800f94e:	bf00      	nop
 800f950:	08016240 	.word	0x08016240
 800f954:	0800f6e1 	.word	0x0800f6e1
 800f958:	20001224 	.word	0x20001224
 800f95c:	0800f6c1 	.word	0x0800f6c1
 800f960:	08016ad0 	.word	0x08016ad0
 800f964:	08016ae0 	.word	0x08016ae0
 800f968:	08016aec 	.word	0x08016aec
 800f96c:	f3af 8000 	nop.w

0800f970 <thread4>:
 * the thread is awakened as fast is possible by the tester thread.<br>
 * The Context Switch performance is calculated by measuring the number of
 * iterations after a second of continuous operations.
 */

static THD_FUNCTION(thread4, p) {
 800f970:	b500      	push	{lr}
 800f972:	b085      	sub	sp, #20
 800f974:	9001      	str	r0, [sp, #4]
  msg_t msg;
  thread_t *self = chThdGetSelfX();
 800f976:	f7ff fe6b 	bl	800f650 <chThdGetSelfX>
 800f97a:	9003      	str	r0, [sp, #12]

  (void)p;
  chSysLock();
 800f97c:	f7ff fe58 	bl	800f630 <chSysLock>
  do {
    chSchGoSleepS(CH_STATE_SUSPENDED);
 800f980:	2003      	movs	r0, #3
 800f982:	f7f1 f935 	bl	8000bf0 <chSchGoSleepS>
    msg = self->p_u.rdymsg;
 800f986:	9b03      	ldr	r3, [sp, #12]
 800f988:	6a1b      	ldr	r3, [r3, #32]
 800f98a:	9302      	str	r3, [sp, #8]
  } while (msg == MSG_OK);
 800f98c:	9b02      	ldr	r3, [sp, #8]
 800f98e:	2b00      	cmp	r3, #0
 800f990:	d0f6      	beq.n	800f980 <thread4+0x10>
  chSysUnlock();
 800f992:	f7ff fe55 	bl	800f640 <chSysUnlock>
}
 800f996:	b005      	add	sp, #20
 800f998:	f85d fb04 	ldr.w	pc, [sp], #4
 800f99c:	f3af 8000 	nop.w

0800f9a0 <bmk4_execute>:

static void bmk4_execute(void) {
 800f9a0:	b510      	push	{r4, lr}
 800f9a2:	b084      	sub	sp, #16
  thread_t *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 800f9a4:	4b29      	ldr	r3, [pc, #164]	; (800fa4c <bmk4_execute+0xac>)
 800f9a6:	681c      	ldr	r4, [r3, #0]
 800f9a8:	f7ff fe5a 	bl	800f660 <chThdGetPriorityX>
 800f9ac:	4603      	mov	r3, r0
 800f9ae:	3301      	adds	r3, #1
 800f9b0:	2200      	movs	r2, #0
 800f9b2:	9200      	str	r2, [sp, #0]
 800f9b4:	4620      	mov	r0, r4
 800f9b6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f9ba:	461a      	mov	r2, r3
 800f9bc:	4b24      	ldr	r3, [pc, #144]	; (800fa50 <bmk4_execute+0xb0>)
 800f9be:	f7f1 fc0f 	bl	80011e0 <chThdCreateStatic>
 800f9c2:	4602      	mov	r2, r0
 800f9c4:	4b23      	ldr	r3, [pc, #140]	; (800fa54 <bmk4_execute+0xb4>)
 800f9c6:	601a      	str	r2, [r3, #0]
 800f9c8:	4b22      	ldr	r3, [pc, #136]	; (800fa54 <bmk4_execute+0xb4>)
 800f9ca:	681b      	ldr	r3, [r3, #0]
 800f9cc:	9302      	str	r3, [sp, #8]
                                      thread4, NULL);
  n = 0;
 800f9ce:	2300      	movs	r3, #0
 800f9d0:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 800f9d2:	f7fb fd15 	bl	800b400 <test_wait_tick>
  test_start_timer(1000);
 800f9d6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800f9da:	f7fb fd31 	bl	800b440 <test_start_timer>
  do {
    chSysLock();
 800f9de:	f7ff fe27 	bl	800f630 <chSysLock>
    chSchWakeupS(tp, MSG_OK);
 800f9e2:	9802      	ldr	r0, [sp, #8]
 800f9e4:	2100      	movs	r1, #0
 800f9e6:	f7f1 f9a3 	bl	8000d30 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 800f9ea:	9802      	ldr	r0, [sp, #8]
 800f9ec:	2100      	movs	r1, #0
 800f9ee:	f7f1 f99f 	bl	8000d30 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 800f9f2:	9802      	ldr	r0, [sp, #8]
 800f9f4:	2100      	movs	r1, #0
 800f9f6:	f7f1 f99b 	bl	8000d30 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 800f9fa:	9802      	ldr	r0, [sp, #8]
 800f9fc:	2100      	movs	r1, #0
 800f9fe:	f7f1 f997 	bl	8000d30 <chSchWakeupS>
    chSysUnlock();
 800fa02:	f7ff fe1d 	bl	800f640 <chSysUnlock>
    n += 4;
 800fa06:	9b03      	ldr	r3, [sp, #12]
 800fa08:	3304      	adds	r3, #4
 800fa0a:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 800fa0c:	4b12      	ldr	r3, [pc, #72]	; (800fa58 <bmk4_execute+0xb8>)
 800fa0e:	781b      	ldrb	r3, [r3, #0]
 800fa10:	f083 0301 	eor.w	r3, r3, #1
 800fa14:	b2db      	uxtb	r3, r3
 800fa16:	2b00      	cmp	r3, #0
 800fa18:	d1e1      	bne.n	800f9de <bmk4_execute+0x3e>
  chSysLock();
 800fa1a:	f7ff fe09 	bl	800f630 <chSysLock>
  chSchWakeupS(tp, MSG_TIMEOUT);
 800fa1e:	9802      	ldr	r0, [sp, #8]
 800fa20:	f04f 31ff 	mov.w	r1, #4294967295
 800fa24:	f7f1 f984 	bl	8000d30 <chSchWakeupS>
  chSysUnlock();
 800fa28:	f7ff fe0a 	bl	800f640 <chSysUnlock>

  test_wait_threads();
 800fa2c:	f7fb fcc0 	bl	800b3b0 <test_wait_threads>
  test_print("--- Score : ");
 800fa30:	480a      	ldr	r0, [pc, #40]	; (800fa5c <bmk4_execute+0xbc>)
 800fa32:	f7fb fbad 	bl	800b190 <test_print>
  test_printn(n * 2);
 800fa36:	9b03      	ldr	r3, [sp, #12]
 800fa38:	005b      	lsls	r3, r3, #1
 800fa3a:	4618      	mov	r0, r3
 800fa3c:	f7fb fb60 	bl	800b100 <test_printn>
  test_println(" ctxswc/S");
 800fa40:	4807      	ldr	r0, [pc, #28]	; (800fa60 <bmk4_execute+0xc0>)
 800fa42:	f7fb fbc5 	bl	800b1d0 <test_println>
}
 800fa46:	b004      	add	sp, #16
 800fa48:	bd10      	pop	{r4, pc}
 800fa4a:	bf00      	nop
 800fa4c:	08016240 	.word	0x08016240
 800fa50:	0800f971 	.word	0x0800f971
 800fa54:	20001224 	.word	0x20001224
 800fa58:	20001221 	.word	0x20001221
 800fa5c:	08016ad0 	.word	0x08016ad0
 800fa60:	08016aec 	.word	0x08016aec
 800fa64:	f3af 8000 	nop.w
 800fa68:	f3af 8000 	nop.w
 800fa6c:	f3af 8000 	nop.w

0800fa70 <bmk5_execute>:
 * in each iteration.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk5_execute(void) {
 800fa70:	b500      	push	{lr}
 800fa72:	b087      	sub	sp, #28

  uint32_t n = 0;
 800fa74:	2300      	movs	r3, #0
 800fa76:	9305      	str	r3, [sp, #20]
  void *wap = wa[0];
 800fa78:	4b18      	ldr	r3, [pc, #96]	; (800fadc <bmk5_execute+0x6c>)
 800fa7a:	681b      	ldr	r3, [r3, #0]
 800fa7c:	9304      	str	r3, [sp, #16]
  tprio_t prio = chThdGetPriorityX() - 1;
 800fa7e:	f7ff fdef 	bl	800f660 <chThdGetPriorityX>
 800fa82:	4603      	mov	r3, r0
 800fa84:	3b01      	subs	r3, #1
 800fa86:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 800fa88:	f7fb fcba 	bl	800b400 <test_wait_tick>
  test_start_timer(1000);
 800fa8c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800fa90:	f7fb fcd6 	bl	800b440 <test_start_timer>
  do {
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
 800fa94:	2300      	movs	r3, #0
 800fa96:	9300      	str	r3, [sp, #0]
 800fa98:	9804      	ldr	r0, [sp, #16]
 800fa9a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800fa9e:	9a03      	ldr	r2, [sp, #12]
 800faa0:	4b0f      	ldr	r3, [pc, #60]	; (800fae0 <bmk5_execute+0x70>)
 800faa2:	f7f1 fb9d 	bl	80011e0 <chThdCreateStatic>
 800faa6:	4603      	mov	r3, r0
 800faa8:	4618      	mov	r0, r3
 800faaa:	f7f1 fca9 	bl	8001400 <chThdWait>
    n++;
 800faae:	9b05      	ldr	r3, [sp, #20]
 800fab0:	3301      	adds	r3, #1
 800fab2:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 800fab4:	4b0b      	ldr	r3, [pc, #44]	; (800fae4 <bmk5_execute+0x74>)
 800fab6:	781b      	ldrb	r3, [r3, #0]
 800fab8:	f083 0301 	eor.w	r3, r3, #1
 800fabc:	b2db      	uxtb	r3, r3
 800fabe:	2b00      	cmp	r3, #0
 800fac0:	d1e8      	bne.n	800fa94 <bmk5_execute+0x24>
  test_print("--- Score : ");
 800fac2:	4809      	ldr	r0, [pc, #36]	; (800fae8 <bmk5_execute+0x78>)
 800fac4:	f7fb fb64 	bl	800b190 <test_print>
  test_printn(n);
 800fac8:	9805      	ldr	r0, [sp, #20]
 800faca:	f7fb fb19 	bl	800b100 <test_printn>
  test_println(" threads/S");
 800face:	4807      	ldr	r0, [pc, #28]	; (800faec <bmk5_execute+0x7c>)
 800fad0:	f7fb fb7e 	bl	800b1d0 <test_println>
}
 800fad4:	b007      	add	sp, #28
 800fad6:	f85d fb04 	ldr.w	pc, [sp], #4
 800fada:	bf00      	nop
 800fadc:	08016240 	.word	0x08016240
 800fae0:	0800f6c1 	.word	0x0800f6c1
 800fae4:	20001221 	.word	0x20001221
 800fae8:	08016ad0 	.word	0x08016ad0
 800faec:	08016b9c 	.word	0x08016b9c

0800faf0 <bmk6_execute>:
 * terminate.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk6_execute(void) {
 800faf0:	b500      	push	{lr}
 800faf2:	b087      	sub	sp, #28

  uint32_t n = 0;
 800faf4:	2300      	movs	r3, #0
 800faf6:	9305      	str	r3, [sp, #20]
  void *wap = wa[0];
 800faf8:	4b16      	ldr	r3, [pc, #88]	; (800fb54 <bmk6_execute+0x64>)
 800fafa:	681b      	ldr	r3, [r3, #0]
 800fafc:	9304      	str	r3, [sp, #16]
  tprio_t prio = chThdGetPriorityX() + 1;
 800fafe:	f7ff fdaf 	bl	800f660 <chThdGetPriorityX>
 800fb02:	4603      	mov	r3, r0
 800fb04:	3301      	adds	r3, #1
 800fb06:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 800fb08:	f7fb fc7a 	bl	800b400 <test_wait_tick>
  test_start_timer(1000);
 800fb0c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800fb10:	f7fb fc96 	bl	800b440 <test_start_timer>
  do {
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
 800fb14:	2300      	movs	r3, #0
 800fb16:	9300      	str	r3, [sp, #0]
 800fb18:	9804      	ldr	r0, [sp, #16]
 800fb1a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800fb1e:	9a03      	ldr	r2, [sp, #12]
 800fb20:	4b0d      	ldr	r3, [pc, #52]	; (800fb58 <bmk6_execute+0x68>)
 800fb22:	f7f1 fb5d 	bl	80011e0 <chThdCreateStatic>
    n++;
 800fb26:	9b05      	ldr	r3, [sp, #20]
 800fb28:	3301      	adds	r3, #1
 800fb2a:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 800fb2c:	4b0b      	ldr	r3, [pc, #44]	; (800fb5c <bmk6_execute+0x6c>)
 800fb2e:	781b      	ldrb	r3, [r3, #0]
 800fb30:	f083 0301 	eor.w	r3, r3, #1
 800fb34:	b2db      	uxtb	r3, r3
 800fb36:	2b00      	cmp	r3, #0
 800fb38:	d1ec      	bne.n	800fb14 <bmk6_execute+0x24>
  test_print("--- Score : ");
 800fb3a:	4809      	ldr	r0, [pc, #36]	; (800fb60 <bmk6_execute+0x70>)
 800fb3c:	f7fb fb28 	bl	800b190 <test_print>
  test_printn(n);
 800fb40:	9805      	ldr	r0, [sp, #20]
 800fb42:	f7fb fadd 	bl	800b100 <test_printn>
  test_println(" threads/S");
 800fb46:	4807      	ldr	r0, [pc, #28]	; (800fb64 <bmk6_execute+0x74>)
 800fb48:	f7fb fb42 	bl	800b1d0 <test_println>
}
 800fb4c:	b007      	add	sp, #28
 800fb4e:	f85d fb04 	ldr.w	pc, [sp], #4
 800fb52:	bf00      	nop
 800fb54:	08016240 	.word	0x08016240
 800fb58:	0800f6c1 	.word	0x0800f6c1
 800fb5c:	20001221 	.word	0x20001221
 800fb60:	08016ad0 	.word	0x08016ad0
 800fb64:	08016b9c 	.word	0x08016b9c
 800fb68:	f3af 8000 	nop.w
 800fb6c:	f3af 8000 	nop.w

0800fb70 <thread3>:
 * continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static THD_FUNCTION(thread3, p) {
 800fb70:	b500      	push	{lr}
 800fb72:	b083      	sub	sp, #12
 800fb74:	9001      	str	r0, [sp, #4]

  (void)p;
  while (!chThdShouldTerminateX())
 800fb76:	e002      	b.n	800fb7e <thread3+0xe>
    chSemWait(&sem1);
 800fb78:	4806      	ldr	r0, [pc, #24]	; (800fb94 <thread3+0x24>)
 800fb7a:	f7f1 ffe9 	bl	8001b50 <chSemWait>
 */

static THD_FUNCTION(thread3, p) {

  (void)p;
  while (!chThdShouldTerminateX())
 800fb7e:	f7ff fd77 	bl	800f670 <chThdShouldTerminateX>
 800fb82:	4603      	mov	r3, r0
 800fb84:	f083 0301 	eor.w	r3, r3, #1
 800fb88:	b2db      	uxtb	r3, r3
 800fb8a:	2b00      	cmp	r3, #0
 800fb8c:	d1f4      	bne.n	800fb78 <thread3+0x8>
    chSemWait(&sem1);
}
 800fb8e:	b003      	add	sp, #12
 800fb90:	f85d fb04 	ldr.w	pc, [sp], #4
 800fb94:	20000bd0 	.word	0x20000bd0
 800fb98:	f3af 8000 	nop.w
 800fb9c:	f3af 8000 	nop.w

0800fba0 <bmk7_setup>:

static void bmk7_setup(void) {
 800fba0:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 0);
 800fba2:	4802      	ldr	r0, [pc, #8]	; (800fbac <bmk7_setup+0xc>)
 800fba4:	2100      	movs	r1, #0
 800fba6:	f7f1 ff8b 	bl	8001ac0 <chSemObjectInit>
}
 800fbaa:	bd08      	pop	{r3, pc}
 800fbac:	20000bd0 	.word	0x20000bd0

0800fbb0 <bmk7_execute>:

static void bmk7_execute(void) {
 800fbb0:	b510      	push	{r4, lr}
 800fbb2:	b084      	sub	sp, #16
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 800fbb4:	4b46      	ldr	r3, [pc, #280]	; (800fcd0 <bmk7_execute+0x120>)
 800fbb6:	681c      	ldr	r4, [r3, #0]
 800fbb8:	f7ff fd52 	bl	800f660 <chThdGetPriorityX>
 800fbbc:	4603      	mov	r3, r0
 800fbbe:	3305      	adds	r3, #5
 800fbc0:	2200      	movs	r2, #0
 800fbc2:	9200      	str	r2, [sp, #0]
 800fbc4:	4620      	mov	r0, r4
 800fbc6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800fbca:	461a      	mov	r2, r3
 800fbcc:	4b41      	ldr	r3, [pc, #260]	; (800fcd4 <bmk7_execute+0x124>)
 800fbce:	f7f1 fb07 	bl	80011e0 <chThdCreateStatic>
 800fbd2:	4602      	mov	r2, r0
 800fbd4:	4b40      	ldr	r3, [pc, #256]	; (800fcd8 <bmk7_execute+0x128>)
 800fbd6:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
 800fbd8:	4b3d      	ldr	r3, [pc, #244]	; (800fcd0 <bmk7_execute+0x120>)
 800fbda:	685c      	ldr	r4, [r3, #4]
 800fbdc:	f7ff fd40 	bl	800f660 <chThdGetPriorityX>
 800fbe0:	4603      	mov	r3, r0
 800fbe2:	3304      	adds	r3, #4
 800fbe4:	2200      	movs	r2, #0
 800fbe6:	9200      	str	r2, [sp, #0]
 800fbe8:	4620      	mov	r0, r4
 800fbea:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800fbee:	461a      	mov	r2, r3
 800fbf0:	4b38      	ldr	r3, [pc, #224]	; (800fcd4 <bmk7_execute+0x124>)
 800fbf2:	f7f1 faf5 	bl	80011e0 <chThdCreateStatic>
 800fbf6:	4602      	mov	r2, r0
 800fbf8:	4b37      	ldr	r3, [pc, #220]	; (800fcd8 <bmk7_execute+0x128>)
 800fbfa:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
 800fbfc:	4b34      	ldr	r3, [pc, #208]	; (800fcd0 <bmk7_execute+0x120>)
 800fbfe:	689c      	ldr	r4, [r3, #8]
 800fc00:	f7ff fd2e 	bl	800f660 <chThdGetPriorityX>
 800fc04:	4603      	mov	r3, r0
 800fc06:	3303      	adds	r3, #3
 800fc08:	2200      	movs	r2, #0
 800fc0a:	9200      	str	r2, [sp, #0]
 800fc0c:	4620      	mov	r0, r4
 800fc0e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800fc12:	461a      	mov	r2, r3
 800fc14:	4b2f      	ldr	r3, [pc, #188]	; (800fcd4 <bmk7_execute+0x124>)
 800fc16:	f7f1 fae3 	bl	80011e0 <chThdCreateStatic>
 800fc1a:	4602      	mov	r2, r0
 800fc1c:	4b2e      	ldr	r3, [pc, #184]	; (800fcd8 <bmk7_execute+0x128>)
 800fc1e:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
 800fc20:	4b2b      	ldr	r3, [pc, #172]	; (800fcd0 <bmk7_execute+0x120>)
 800fc22:	68dc      	ldr	r4, [r3, #12]
 800fc24:	f7ff fd1c 	bl	800f660 <chThdGetPriorityX>
 800fc28:	4603      	mov	r3, r0
 800fc2a:	3302      	adds	r3, #2
 800fc2c:	2200      	movs	r2, #0
 800fc2e:	9200      	str	r2, [sp, #0]
 800fc30:	4620      	mov	r0, r4
 800fc32:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800fc36:	461a      	mov	r2, r3
 800fc38:	4b26      	ldr	r3, [pc, #152]	; (800fcd4 <bmk7_execute+0x124>)
 800fc3a:	f7f1 fad1 	bl	80011e0 <chThdCreateStatic>
 800fc3e:	4602      	mov	r2, r0
 800fc40:	4b25      	ldr	r3, [pc, #148]	; (800fcd8 <bmk7_execute+0x128>)
 800fc42:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, thread3, NULL);
 800fc44:	4b22      	ldr	r3, [pc, #136]	; (800fcd0 <bmk7_execute+0x120>)
 800fc46:	691c      	ldr	r4, [r3, #16]
 800fc48:	f7ff fd0a 	bl	800f660 <chThdGetPriorityX>
 800fc4c:	4603      	mov	r3, r0
 800fc4e:	3301      	adds	r3, #1
 800fc50:	2200      	movs	r2, #0
 800fc52:	9200      	str	r2, [sp, #0]
 800fc54:	4620      	mov	r0, r4
 800fc56:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800fc5a:	461a      	mov	r2, r3
 800fc5c:	4b1d      	ldr	r3, [pc, #116]	; (800fcd4 <bmk7_execute+0x124>)
 800fc5e:	f7f1 fabf 	bl	80011e0 <chThdCreateStatic>
 800fc62:	4602      	mov	r2, r0
 800fc64:	4b1c      	ldr	r3, [pc, #112]	; (800fcd8 <bmk7_execute+0x128>)
 800fc66:	611a      	str	r2, [r3, #16]

  n = 0;
 800fc68:	2300      	movs	r3, #0
 800fc6a:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 800fc6c:	f7fb fbc8 	bl	800b400 <test_wait_tick>
  test_start_timer(1000);
 800fc70:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800fc74:	f7fb fbe4 	bl	800b440 <test_start_timer>
  do {
    chSemReset(&sem1, 0);
 800fc78:	4818      	ldr	r0, [pc, #96]	; (800fcdc <bmk7_execute+0x12c>)
 800fc7a:	2100      	movs	r1, #0
 800fc7c:	f7f1 ff30 	bl	8001ae0 <chSemReset>
    n++;
 800fc80:	9b03      	ldr	r3, [sp, #12]
 800fc82:	3301      	adds	r3, #1
 800fc84:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 800fc86:	4b16      	ldr	r3, [pc, #88]	; (800fce0 <bmk7_execute+0x130>)
 800fc88:	781b      	ldrb	r3, [r3, #0]
 800fc8a:	f083 0301 	eor.w	r3, r3, #1
 800fc8e:	b2db      	uxtb	r3, r3
 800fc90:	2b00      	cmp	r3, #0
 800fc92:	d1f1      	bne.n	800fc78 <bmk7_execute+0xc8>
  test_terminate_threads();
 800fc94:	f7fb fb6c 	bl	800b370 <test_terminate_threads>
  chSemReset(&sem1, 0);
 800fc98:	4810      	ldr	r0, [pc, #64]	; (800fcdc <bmk7_execute+0x12c>)
 800fc9a:	2100      	movs	r1, #0
 800fc9c:	f7f1 ff20 	bl	8001ae0 <chSemReset>
  test_wait_threads();
 800fca0:	f7fb fb86 	bl	800b3b0 <test_wait_threads>

  test_print("--- Score : ");
 800fca4:	480f      	ldr	r0, [pc, #60]	; (800fce4 <bmk7_execute+0x134>)
 800fca6:	f7fb fa73 	bl	800b190 <test_print>
  test_printn(n);
 800fcaa:	9803      	ldr	r0, [sp, #12]
 800fcac:	f7fb fa28 	bl	800b100 <test_printn>
  test_print(" reschedules/S, ");
 800fcb0:	480d      	ldr	r0, [pc, #52]	; (800fce8 <bmk7_execute+0x138>)
 800fcb2:	f7fb fa6d 	bl	800b190 <test_print>
  test_printn(n * 6);
 800fcb6:	9a03      	ldr	r2, [sp, #12]
 800fcb8:	4613      	mov	r3, r2
 800fcba:	005b      	lsls	r3, r3, #1
 800fcbc:	4413      	add	r3, r2
 800fcbe:	005b      	lsls	r3, r3, #1
 800fcc0:	4618      	mov	r0, r3
 800fcc2:	f7fb fa1d 	bl	800b100 <test_printn>
  test_println(" ctxswc/S");
 800fcc6:	4809      	ldr	r0, [pc, #36]	; (800fcec <bmk7_execute+0x13c>)
 800fcc8:	f7fb fa82 	bl	800b1d0 <test_println>
}
 800fccc:	b004      	add	sp, #16
 800fcce:	bd10      	pop	{r4, pc}
 800fcd0:	08016240 	.word	0x08016240
 800fcd4:	0800fb71 	.word	0x0800fb71
 800fcd8:	20001224 	.word	0x20001224
 800fcdc:	20000bd0 	.word	0x20000bd0
 800fce0:	20001221 	.word	0x20001221
 800fce4:	08016ad0 	.word	0x08016ad0
 800fce8:	08016c08 	.word	0x08016c08
 800fcec:	08016aec 	.word	0x08016aec

0800fcf0 <thread8>:
 * variable and yields.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static THD_FUNCTION(thread8, p) {
 800fcf0:	b500      	push	{lr}
 800fcf2:	b083      	sub	sp, #12
 800fcf4:	9001      	str	r0, [sp, #4]

  do {
    chThdYield();
 800fcf6:	f7f1 fb33 	bl	8001360 <chThdYield>
    chThdYield();
 800fcfa:	f7f1 fb31 	bl	8001360 <chThdYield>
    chThdYield();
 800fcfe:	f7f1 fb2f 	bl	8001360 <chThdYield>
    chThdYield();
 800fd02:	f7f1 fb2d 	bl	8001360 <chThdYield>
    (*(uint32_t *)p) += 4;
 800fd06:	9b01      	ldr	r3, [sp, #4]
 800fd08:	681b      	ldr	r3, [r3, #0]
 800fd0a:	1d1a      	adds	r2, r3, #4
 800fd0c:	9b01      	ldr	r3, [sp, #4]
 800fd0e:	601a      	str	r2, [r3, #0]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
 800fd10:	f7ff fcae 	bl	800f670 <chThdShouldTerminateX>
 800fd14:	4603      	mov	r3, r0
 800fd16:	f083 0301 	eor.w	r3, r3, #1
 800fd1a:	b2db      	uxtb	r3, r3
 800fd1c:	2b00      	cmp	r3, #0
 800fd1e:	d1ea      	bne.n	800fcf6 <thread8+0x6>
}
 800fd20:	b003      	add	sp, #12
 800fd22:	f85d fb04 	ldr.w	pc, [sp], #4
 800fd26:	bf00      	nop
 800fd28:	f3af 8000 	nop.w
 800fd2c:	f3af 8000 	nop.w

0800fd30 <bmk8_execute>:

static void bmk8_execute(void) {
 800fd30:	b510      	push	{r4, lr}
 800fd32:	b084      	sub	sp, #16
  uint32_t n;

  n = 0;
 800fd34:	2300      	movs	r3, #0
 800fd36:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 800fd38:	f7fb fb62 	bl	800b400 <test_wait_tick>

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 800fd3c:	4b36      	ldr	r3, [pc, #216]	; (800fe18 <bmk8_execute+0xe8>)
 800fd3e:	681c      	ldr	r4, [r3, #0]
 800fd40:	f7ff fc8e 	bl	800f660 <chThdGetPriorityX>
 800fd44:	4603      	mov	r3, r0
 800fd46:	3b01      	subs	r3, #1
 800fd48:	aa03      	add	r2, sp, #12
 800fd4a:	9200      	str	r2, [sp, #0]
 800fd4c:	4620      	mov	r0, r4
 800fd4e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800fd52:	461a      	mov	r2, r3
 800fd54:	4b31      	ldr	r3, [pc, #196]	; (800fe1c <bmk8_execute+0xec>)
 800fd56:	f7f1 fa43 	bl	80011e0 <chThdCreateStatic>
 800fd5a:	4602      	mov	r2, r0
 800fd5c:	4b30      	ldr	r3, [pc, #192]	; (800fe20 <bmk8_execute+0xf0>)
 800fd5e:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 800fd60:	4b2d      	ldr	r3, [pc, #180]	; (800fe18 <bmk8_execute+0xe8>)
 800fd62:	685c      	ldr	r4, [r3, #4]
 800fd64:	f7ff fc7c 	bl	800f660 <chThdGetPriorityX>
 800fd68:	4603      	mov	r3, r0
 800fd6a:	3b01      	subs	r3, #1
 800fd6c:	aa03      	add	r2, sp, #12
 800fd6e:	9200      	str	r2, [sp, #0]
 800fd70:	4620      	mov	r0, r4
 800fd72:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800fd76:	461a      	mov	r2, r3
 800fd78:	4b28      	ldr	r3, [pc, #160]	; (800fe1c <bmk8_execute+0xec>)
 800fd7a:	f7f1 fa31 	bl	80011e0 <chThdCreateStatic>
 800fd7e:	4602      	mov	r2, r0
 800fd80:	4b27      	ldr	r3, [pc, #156]	; (800fe20 <bmk8_execute+0xf0>)
 800fd82:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 800fd84:	4b24      	ldr	r3, [pc, #144]	; (800fe18 <bmk8_execute+0xe8>)
 800fd86:	689c      	ldr	r4, [r3, #8]
 800fd88:	f7ff fc6a 	bl	800f660 <chThdGetPriorityX>
 800fd8c:	4603      	mov	r3, r0
 800fd8e:	3b01      	subs	r3, #1
 800fd90:	aa03      	add	r2, sp, #12
 800fd92:	9200      	str	r2, [sp, #0]
 800fd94:	4620      	mov	r0, r4
 800fd96:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800fd9a:	461a      	mov	r2, r3
 800fd9c:	4b1f      	ldr	r3, [pc, #124]	; (800fe1c <bmk8_execute+0xec>)
 800fd9e:	f7f1 fa1f 	bl	80011e0 <chThdCreateStatic>
 800fda2:	4602      	mov	r2, r0
 800fda4:	4b1e      	ldr	r3, [pc, #120]	; (800fe20 <bmk8_execute+0xf0>)
 800fda6:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 800fda8:	4b1b      	ldr	r3, [pc, #108]	; (800fe18 <bmk8_execute+0xe8>)
 800fdaa:	68dc      	ldr	r4, [r3, #12]
 800fdac:	f7ff fc58 	bl	800f660 <chThdGetPriorityX>
 800fdb0:	4603      	mov	r3, r0
 800fdb2:	3b01      	subs	r3, #1
 800fdb4:	aa03      	add	r2, sp, #12
 800fdb6:	9200      	str	r2, [sp, #0]
 800fdb8:	4620      	mov	r0, r4
 800fdba:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800fdbe:	461a      	mov	r2, r3
 800fdc0:	4b16      	ldr	r3, [pc, #88]	; (800fe1c <bmk8_execute+0xec>)
 800fdc2:	f7f1 fa0d 	bl	80011e0 <chThdCreateStatic>
 800fdc6:	4602      	mov	r2, r0
 800fdc8:	4b15      	ldr	r3, [pc, #84]	; (800fe20 <bmk8_execute+0xf0>)
 800fdca:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 800fdcc:	4b12      	ldr	r3, [pc, #72]	; (800fe18 <bmk8_execute+0xe8>)
 800fdce:	691c      	ldr	r4, [r3, #16]
 800fdd0:	f7ff fc46 	bl	800f660 <chThdGetPriorityX>
 800fdd4:	4603      	mov	r3, r0
 800fdd6:	3b01      	subs	r3, #1
 800fdd8:	aa03      	add	r2, sp, #12
 800fdda:	9200      	str	r2, [sp, #0]
 800fddc:	4620      	mov	r0, r4
 800fdde:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800fde2:	461a      	mov	r2, r3
 800fde4:	4b0d      	ldr	r3, [pc, #52]	; (800fe1c <bmk8_execute+0xec>)
 800fde6:	f7f1 f9fb 	bl	80011e0 <chThdCreateStatic>
 800fdea:	4602      	mov	r2, r0
 800fdec:	4b0c      	ldr	r3, [pc, #48]	; (800fe20 <bmk8_execute+0xf0>)
 800fdee:	611a      	str	r2, [r3, #16]

  chThdSleepSeconds(1);
 800fdf0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800fdf4:	f7f1 fa6c 	bl	80012d0 <chThdSleep>
  test_terminate_threads();
 800fdf8:	f7fb faba 	bl	800b370 <test_terminate_threads>
  test_wait_threads();
 800fdfc:	f7fb fad8 	bl	800b3b0 <test_wait_threads>

  test_print("--- Score : ");
 800fe00:	4808      	ldr	r0, [pc, #32]	; (800fe24 <bmk8_execute+0xf4>)
 800fe02:	f7fb f9c5 	bl	800b190 <test_print>
  test_printn(n);
 800fe06:	9b03      	ldr	r3, [sp, #12]
 800fe08:	4618      	mov	r0, r3
 800fe0a:	f7fb f979 	bl	800b100 <test_printn>
  test_println(" ctxswc/S");
 800fe0e:	4806      	ldr	r0, [pc, #24]	; (800fe28 <bmk8_execute+0xf8>)
 800fe10:	f7fb f9de 	bl	800b1d0 <test_println>
}
 800fe14:	b004      	add	sp, #16
 800fe16:	bd10      	pop	{r4, pc}
 800fe18:	08016240 	.word	0x08016240
 800fe1c:	0800fcf1 	.word	0x0800fcf1
 800fe20:	20001224 	.word	0x20001224
 800fe24:	08016ad0 	.word	0x08016ad0
 800fe28:	08016aec 	.word	0x08016aec
 800fe2c:	f3af 8000 	nop.w

0800fe30 <bmk9_execute>:
 * loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk9_execute(void) {
 800fe30:	b500      	push	{lr}
 800fe32:	b085      	sub	sp, #20
  uint32_t n;
  static uint8_t ib[16];
  static input_queue_t iq;

  chIQObjectInit(&iq, ib, sizeof(ib), NULL, NULL);
 800fe34:	2300      	movs	r3, #0
 800fe36:	9300      	str	r3, [sp, #0]
 800fe38:	4822      	ldr	r0, [pc, #136]	; (800fec4 <bmk9_execute+0x94>)
 800fe3a:	4923      	ldr	r1, [pc, #140]	; (800fec8 <bmk9_execute+0x98>)
 800fe3c:	2210      	movs	r2, #16
 800fe3e:	2300      	movs	r3, #0
 800fe40:	f7f3 f9ae 	bl	80031a0 <chIQObjectInit>
  n = 0;
 800fe44:	2300      	movs	r3, #0
 800fe46:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 800fe48:	f7fb fada 	bl	800b400 <test_wait_tick>
  test_start_timer(1000);
 800fe4c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800fe50:	f7fb faf6 	bl	800b440 <test_start_timer>
  do {
    chSysLock();
 800fe54:	f7ff fbec 	bl	800f630 <chSysLock>
    chIQPutI(&iq, 0);
 800fe58:	481a      	ldr	r0, [pc, #104]	; (800fec4 <bmk9_execute+0x94>)
 800fe5a:	2100      	movs	r1, #0
 800fe5c:	f7f3 f9e0 	bl	8003220 <chIQPutI>
    chIQPutI(&iq, 1);
 800fe60:	4818      	ldr	r0, [pc, #96]	; (800fec4 <bmk9_execute+0x94>)
 800fe62:	2101      	movs	r1, #1
 800fe64:	f7f3 f9dc 	bl	8003220 <chIQPutI>
    chIQPutI(&iq, 2);
 800fe68:	4816      	ldr	r0, [pc, #88]	; (800fec4 <bmk9_execute+0x94>)
 800fe6a:	2102      	movs	r1, #2
 800fe6c:	f7f3 f9d8 	bl	8003220 <chIQPutI>
    chIQPutI(&iq, 3);
 800fe70:	4814      	ldr	r0, [pc, #80]	; (800fec4 <bmk9_execute+0x94>)
 800fe72:	2103      	movs	r1, #3
 800fe74:	f7f3 f9d4 	bl	8003220 <chIQPutI>
    chSysUnlock();
 800fe78:	f7ff fbe2 	bl	800f640 <chSysUnlock>
    (void)chIQGet(&iq);
 800fe7c:	4811      	ldr	r0, [pc, #68]	; (800fec4 <bmk9_execute+0x94>)
 800fe7e:	f7ff fc0f 	bl	800f6a0 <chIQGet>
    (void)chIQGet(&iq);
 800fe82:	4810      	ldr	r0, [pc, #64]	; (800fec4 <bmk9_execute+0x94>)
 800fe84:	f7ff fc0c 	bl	800f6a0 <chIQGet>
    (void)chIQGet(&iq);
 800fe88:	480e      	ldr	r0, [pc, #56]	; (800fec4 <bmk9_execute+0x94>)
 800fe8a:	f7ff fc09 	bl	800f6a0 <chIQGet>
    (void)chIQGet(&iq);
 800fe8e:	480d      	ldr	r0, [pc, #52]	; (800fec4 <bmk9_execute+0x94>)
 800fe90:	f7ff fc06 	bl	800f6a0 <chIQGet>
    n++;
 800fe94:	9b03      	ldr	r3, [sp, #12]
 800fe96:	3301      	adds	r3, #1
 800fe98:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 800fe9a:	4b0c      	ldr	r3, [pc, #48]	; (800fecc <bmk9_execute+0x9c>)
 800fe9c:	781b      	ldrb	r3, [r3, #0]
 800fe9e:	f083 0301 	eor.w	r3, r3, #1
 800fea2:	b2db      	uxtb	r3, r3
 800fea4:	2b00      	cmp	r3, #0
 800fea6:	d1d5      	bne.n	800fe54 <bmk9_execute+0x24>
  test_print("--- Score : ");
 800fea8:	4809      	ldr	r0, [pc, #36]	; (800fed0 <bmk9_execute+0xa0>)
 800feaa:	f7fb f971 	bl	800b190 <test_print>
  test_printn(n * 4);
 800feae:	9b03      	ldr	r3, [sp, #12]
 800feb0:	009b      	lsls	r3, r3, #2
 800feb2:	4618      	mov	r0, r3
 800feb4:	f7fb f924 	bl	800b100 <test_printn>
  test_println(" bytes/S");
 800feb8:	4806      	ldr	r0, [pc, #24]	; (800fed4 <bmk9_execute+0xa4>)
 800feba:	f7fb f989 	bl	800b1d0 <test_println>
}
 800febe:	b005      	add	sp, #20
 800fec0:	f85d fb04 	ldr.w	pc, [sp], #4
 800fec4:	20000bec 	.word	0x20000bec
 800fec8:	20000c10 	.word	0x20000c10
 800fecc:	20001221 	.word	0x20001221
 800fed0:	08016ad0 	.word	0x08016ad0
 800fed4:	08016c90 	.word	0x08016c90
 800fed8:	f3af 8000 	nop.w
 800fedc:	f3af 8000 	nop.w

0800fee0 <tmo>:
 * A virtual timer is set and immediately reset into a continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void tmo(void *param) {(void)param;}
 800fee0:	b082      	sub	sp, #8
 800fee2:	9001      	str	r0, [sp, #4]
 800fee4:	b002      	add	sp, #8
 800fee6:	4770      	bx	lr
 800fee8:	f3af 8000 	nop.w
 800feec:	f3af 8000 	nop.w

0800fef0 <bmk10_execute>:

static void bmk10_execute(void) {
 800fef0:	b500      	push	{lr}
 800fef2:	b083      	sub	sp, #12
  static virtual_timer_t vt1, vt2;
  uint32_t n = 0;
 800fef4:	2300      	movs	r3, #0
 800fef6:	9301      	str	r3, [sp, #4]

  test_wait_tick();
 800fef8:	f7fb fa82 	bl	800b400 <test_wait_tick>
  test_start_timer(1000);
 800fefc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800ff00:	f7fb fa9e 	bl	800b440 <test_start_timer>
  do {
    chSysLock();
 800ff04:	f7ff fb94 	bl	800f630 <chSysLock>
    chVTDoSetI(&vt1, 1, tmo, NULL);
 800ff08:	4816      	ldr	r0, [pc, #88]	; (800ff64 <bmk10_execute+0x74>)
 800ff0a:	2101      	movs	r1, #1
 800ff0c:	4a16      	ldr	r2, [pc, #88]	; (800ff68 <bmk10_execute+0x78>)
 800ff0e:	2300      	movs	r3, #0
 800ff10:	f7f0 fd3e 	bl	8000990 <chVTDoSetI>
    chVTDoSetI(&vt2, 10000, tmo, NULL);
 800ff14:	4815      	ldr	r0, [pc, #84]	; (800ff6c <bmk10_execute+0x7c>)
 800ff16:	f242 7110 	movw	r1, #10000	; 0x2710
 800ff1a:	4a13      	ldr	r2, [pc, #76]	; (800ff68 <bmk10_execute+0x78>)
 800ff1c:	2300      	movs	r3, #0
 800ff1e:	f7f0 fd37 	bl	8000990 <chVTDoSetI>
    chVTDoResetI(&vt1);
 800ff22:	4810      	ldr	r0, [pc, #64]	; (800ff64 <bmk10_execute+0x74>)
 800ff24:	f7f0 fd74 	bl	8000a10 <chVTDoResetI>
    chVTDoResetI(&vt2);
 800ff28:	4810      	ldr	r0, [pc, #64]	; (800ff6c <bmk10_execute+0x7c>)
 800ff2a:	f7f0 fd71 	bl	8000a10 <chVTDoResetI>
    chSysUnlock();
 800ff2e:	f7ff fb87 	bl	800f640 <chSysUnlock>
    n++;
 800ff32:	9b01      	ldr	r3, [sp, #4]
 800ff34:	3301      	adds	r3, #1
 800ff36:	9301      	str	r3, [sp, #4]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 800ff38:	4b0d      	ldr	r3, [pc, #52]	; (800ff70 <bmk10_execute+0x80>)
 800ff3a:	781b      	ldrb	r3, [r3, #0]
 800ff3c:	f083 0301 	eor.w	r3, r3, #1
 800ff40:	b2db      	uxtb	r3, r3
 800ff42:	2b00      	cmp	r3, #0
 800ff44:	d1de      	bne.n	800ff04 <bmk10_execute+0x14>
  test_print("--- Score : ");
 800ff46:	480b      	ldr	r0, [pc, #44]	; (800ff74 <bmk10_execute+0x84>)
 800ff48:	f7fb f922 	bl	800b190 <test_print>
  test_printn(n * 2);
 800ff4c:	9b01      	ldr	r3, [sp, #4]
 800ff4e:	005b      	lsls	r3, r3, #1
 800ff50:	4618      	mov	r0, r3
 800ff52:	f7fb f8d5 	bl	800b100 <test_printn>
  test_println(" timers/S");
 800ff56:	4808      	ldr	r0, [pc, #32]	; (800ff78 <bmk10_execute+0x88>)
 800ff58:	f7fb f93a 	bl	800b1d0 <test_println>
}
 800ff5c:	b003      	add	sp, #12
 800ff5e:	f85d fb04 	ldr.w	pc, [sp], #4
 800ff62:	bf00      	nop
 800ff64:	20000c20 	.word	0x20000c20
 800ff68:	0800fee1 	.word	0x0800fee1
 800ff6c:	20000c34 	.word	0x20000c34
 800ff70:	20001221 	.word	0x20001221
 800ff74:	08016ad0 	.word	0x08016ad0
 800ff78:	08016cd0 	.word	0x08016cd0
 800ff7c:	f3af 8000 	nop.w

0800ff80 <bmk11_setup>:
 * Switch happens because the counter is always non negative.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk11_setup(void) {
 800ff80:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 1);
 800ff82:	4802      	ldr	r0, [pc, #8]	; (800ff8c <bmk11_setup+0xc>)
 800ff84:	2101      	movs	r1, #1
 800ff86:	f7f1 fd9b 	bl	8001ac0 <chSemObjectInit>
}
 800ff8a:	bd08      	pop	{r3, pc}
 800ff8c:	20000bd0 	.word	0x20000bd0

0800ff90 <bmk11_execute>:

static void bmk11_execute(void) {
 800ff90:	b500      	push	{lr}
 800ff92:	b083      	sub	sp, #12
  uint32_t n = 0;
 800ff94:	2300      	movs	r3, #0
 800ff96:	9301      	str	r3, [sp, #4]

  test_wait_tick();
 800ff98:	f7fb fa32 	bl	800b400 <test_wait_tick>
  test_start_timer(1000);
 800ff9c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800ffa0:	f7fb fa4e 	bl	800b440 <test_start_timer>
  do {
    chSemWait(&sem1);
 800ffa4:	4817      	ldr	r0, [pc, #92]	; (8010004 <bmk11_execute+0x74>)
 800ffa6:	f7f1 fdd3 	bl	8001b50 <chSemWait>
    chSemSignal(&sem1);
 800ffaa:	4816      	ldr	r0, [pc, #88]	; (8010004 <bmk11_execute+0x74>)
 800ffac:	f7f1 fe50 	bl	8001c50 <chSemSignal>
    chSemWait(&sem1);
 800ffb0:	4814      	ldr	r0, [pc, #80]	; (8010004 <bmk11_execute+0x74>)
 800ffb2:	f7f1 fdcd 	bl	8001b50 <chSemWait>
    chSemSignal(&sem1);
 800ffb6:	4813      	ldr	r0, [pc, #76]	; (8010004 <bmk11_execute+0x74>)
 800ffb8:	f7f1 fe4a 	bl	8001c50 <chSemSignal>
    chSemWait(&sem1);
 800ffbc:	4811      	ldr	r0, [pc, #68]	; (8010004 <bmk11_execute+0x74>)
 800ffbe:	f7f1 fdc7 	bl	8001b50 <chSemWait>
    chSemSignal(&sem1);
 800ffc2:	4810      	ldr	r0, [pc, #64]	; (8010004 <bmk11_execute+0x74>)
 800ffc4:	f7f1 fe44 	bl	8001c50 <chSemSignal>
    chSemWait(&sem1);
 800ffc8:	480e      	ldr	r0, [pc, #56]	; (8010004 <bmk11_execute+0x74>)
 800ffca:	f7f1 fdc1 	bl	8001b50 <chSemWait>
    chSemSignal(&sem1);
 800ffce:	480d      	ldr	r0, [pc, #52]	; (8010004 <bmk11_execute+0x74>)
 800ffd0:	f7f1 fe3e 	bl	8001c50 <chSemSignal>
    n++;
 800ffd4:	9b01      	ldr	r3, [sp, #4]
 800ffd6:	3301      	adds	r3, #1
 800ffd8:	9301      	str	r3, [sp, #4]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 800ffda:	4b0b      	ldr	r3, [pc, #44]	; (8010008 <bmk11_execute+0x78>)
 800ffdc:	781b      	ldrb	r3, [r3, #0]
 800ffde:	f083 0301 	eor.w	r3, r3, #1
 800ffe2:	b2db      	uxtb	r3, r3
 800ffe4:	2b00      	cmp	r3, #0
 800ffe6:	d1dd      	bne.n	800ffa4 <bmk11_execute+0x14>
  test_print("--- Score : ");
 800ffe8:	4808      	ldr	r0, [pc, #32]	; (801000c <bmk11_execute+0x7c>)
 800ffea:	f7fb f8d1 	bl	800b190 <test_print>
  test_printn(n * 4);
 800ffee:	9b01      	ldr	r3, [sp, #4]
 800fff0:	009b      	lsls	r3, r3, #2
 800fff2:	4618      	mov	r0, r3
 800fff4:	f7fb f884 	bl	800b100 <test_printn>
  test_println(" wait+signal/S");
 800fff8:	4805      	ldr	r0, [pc, #20]	; (8010010 <bmk11_execute+0x80>)
 800fffa:	f7fb f8e9 	bl	800b1d0 <test_println>
}
 800fffe:	b003      	add	sp, #12
 8010000:	f85d fb04 	ldr.w	pc, [sp], #4
 8010004:	20000bd0 	.word	0x20000bd0
 8010008:	20001221 	.word	0x20001221
 801000c:	08016ad0 	.word	0x08016ad0
 8010010:	08016d10 	.word	0x08016d10
 8010014:	f3af 8000 	nop.w
 8010018:	f3af 8000 	nop.w
 801001c:	f3af 8000 	nop.w

08010020 <bmk12_setup>:
 * because there are no other threads asking for the mutex.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk12_setup(void) {
 8010020:	b508      	push	{r3, lr}

  chMtxObjectInit(&mtx1);
 8010022:	4802      	ldr	r0, [pc, #8]	; (801002c <bmk12_setup+0xc>)
 8010024:	f7f1 ff64 	bl	8001ef0 <chMtxObjectInit>
}
 8010028:	bd08      	pop	{r3, pc}
 801002a:	bf00      	nop
 801002c:	20000bdc 	.word	0x20000bdc

08010030 <bmk12_execute>:

static void bmk12_execute(void) {
 8010030:	b500      	push	{lr}
 8010032:	b083      	sub	sp, #12
  uint32_t n = 0;
 8010034:	2300      	movs	r3, #0
 8010036:	9301      	str	r3, [sp, #4]

  test_wait_tick();
 8010038:	f7fb f9e2 	bl	800b400 <test_wait_tick>
  test_start_timer(1000);
 801003c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8010040:	f7fb f9fe 	bl	800b440 <test_start_timer>
  do {
    chMtxLock(&mtx1);
 8010044:	4817      	ldr	r0, [pc, #92]	; (80100a4 <bmk12_execute+0x74>)
 8010046:	f7f1 ff63 	bl	8001f10 <chMtxLock>
    chMtxUnlock(&mtx1);
 801004a:	4816      	ldr	r0, [pc, #88]	; (80100a4 <bmk12_execute+0x74>)
 801004c:	f7f2 f808 	bl	8002060 <chMtxUnlock>
    chMtxLock(&mtx1);
 8010050:	4814      	ldr	r0, [pc, #80]	; (80100a4 <bmk12_execute+0x74>)
 8010052:	f7f1 ff5d 	bl	8001f10 <chMtxLock>
    chMtxUnlock(&mtx1);
 8010056:	4813      	ldr	r0, [pc, #76]	; (80100a4 <bmk12_execute+0x74>)
 8010058:	f7f2 f802 	bl	8002060 <chMtxUnlock>
    chMtxLock(&mtx1);
 801005c:	4811      	ldr	r0, [pc, #68]	; (80100a4 <bmk12_execute+0x74>)
 801005e:	f7f1 ff57 	bl	8001f10 <chMtxLock>
    chMtxUnlock(&mtx1);
 8010062:	4810      	ldr	r0, [pc, #64]	; (80100a4 <bmk12_execute+0x74>)
 8010064:	f7f1 fffc 	bl	8002060 <chMtxUnlock>
    chMtxLock(&mtx1);
 8010068:	480e      	ldr	r0, [pc, #56]	; (80100a4 <bmk12_execute+0x74>)
 801006a:	f7f1 ff51 	bl	8001f10 <chMtxLock>
    chMtxUnlock(&mtx1);
 801006e:	480d      	ldr	r0, [pc, #52]	; (80100a4 <bmk12_execute+0x74>)
 8010070:	f7f1 fff6 	bl	8002060 <chMtxUnlock>
    n++;
 8010074:	9b01      	ldr	r3, [sp, #4]
 8010076:	3301      	adds	r3, #1
 8010078:	9301      	str	r3, [sp, #4]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 801007a:	4b0b      	ldr	r3, [pc, #44]	; (80100a8 <bmk12_execute+0x78>)
 801007c:	781b      	ldrb	r3, [r3, #0]
 801007e:	f083 0301 	eor.w	r3, r3, #1
 8010082:	b2db      	uxtb	r3, r3
 8010084:	2b00      	cmp	r3, #0
 8010086:	d1dd      	bne.n	8010044 <bmk12_execute+0x14>
  test_print("--- Score : ");
 8010088:	4808      	ldr	r0, [pc, #32]	; (80100ac <bmk12_execute+0x7c>)
 801008a:	f7fb f881 	bl	800b190 <test_print>
  test_printn(n * 4);
 801008e:	9b01      	ldr	r3, [sp, #4]
 8010090:	009b      	lsls	r3, r3, #2
 8010092:	4618      	mov	r0, r3
 8010094:	f7fb f834 	bl	800b100 <test_printn>
  test_println(" lock+unlock/S");
 8010098:	4805      	ldr	r0, [pc, #20]	; (80100b0 <bmk12_execute+0x80>)
 801009a:	f7fb f899 	bl	800b1d0 <test_println>
}
 801009e:	b003      	add	sp, #12
 80100a0:	f85d fb04 	ldr.w	pc, [sp], #4
 80100a4:	20000bdc 	.word	0x20000bdc
 80100a8:	20001221 	.word	0x20001221
 80100ac:	08016ad0 	.word	0x08016ad0
 80100b0:	08016d54 	.word	0x08016d54
 80100b4:	f3af 8000 	nop.w
 80100b8:	f3af 8000 	nop.w
 80100bc:	f3af 8000 	nop.w

080100c0 <bmk13_execute>:
 *
 * <h2>Description</h2>
 * The memory size of the various kernel objects is printed.
 */

static void bmk13_execute(void) {
 80100c0:	b508      	push	{r3, lr}

  test_print("--- System: ");
 80100c2:	482e      	ldr	r0, [pc, #184]	; (801017c <bmk13_execute+0xbc>)
 80100c4:	f7fb f864 	bl	800b190 <test_print>
  test_printn(sizeof(ch_system_t));
 80100c8:	f44f 70a8 	mov.w	r0, #336	; 0x150
 80100cc:	f7fb f818 	bl	800b100 <test_printn>
  test_println(" bytes");
 80100d0:	482b      	ldr	r0, [pc, #172]	; (8010180 <bmk13_execute+0xc0>)
 80100d2:	f7fb f87d 	bl	800b1d0 <test_println>
  test_print("--- Thread: ");
 80100d6:	482b      	ldr	r0, [pc, #172]	; (8010184 <bmk13_execute+0xc4>)
 80100d8:	f7fb f85a 	bl	800b190 <test_print>
  test_printn(sizeof(thread_t));
 80100dc:	2044      	movs	r0, #68	; 0x44
 80100de:	f7fb f80f 	bl	800b100 <test_printn>
  test_println(" bytes");
 80100e2:	4827      	ldr	r0, [pc, #156]	; (8010180 <bmk13_execute+0xc0>)
 80100e4:	f7fb f874 	bl	800b1d0 <test_println>
  test_print("--- Timer : ");
 80100e8:	4827      	ldr	r0, [pc, #156]	; (8010188 <bmk13_execute+0xc8>)
 80100ea:	f7fb f851 	bl	800b190 <test_print>
  test_printn(sizeof(virtual_timer_t));
 80100ee:	2014      	movs	r0, #20
 80100f0:	f7fb f806 	bl	800b100 <test_printn>
  test_println(" bytes");
 80100f4:	4822      	ldr	r0, [pc, #136]	; (8010180 <bmk13_execute+0xc0>)
 80100f6:	f7fb f86b 	bl	800b1d0 <test_println>
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
  test_print("--- Semaph: ");
 80100fa:	4824      	ldr	r0, [pc, #144]	; (801018c <bmk13_execute+0xcc>)
 80100fc:	f7fb f848 	bl	800b190 <test_print>
  test_printn(sizeof(semaphore_t));
 8010100:	200c      	movs	r0, #12
 8010102:	f7fa fffd 	bl	800b100 <test_printn>
  test_println(" bytes");
 8010106:	481e      	ldr	r0, [pc, #120]	; (8010180 <bmk13_execute+0xc0>)
 8010108:	f7fb f862 	bl	800b1d0 <test_println>
#endif
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
  test_print("--- EventS: ");
 801010c:	4820      	ldr	r0, [pc, #128]	; (8010190 <bmk13_execute+0xd0>)
 801010e:	f7fb f83f 	bl	800b190 <test_print>
  test_printn(sizeof(event_source_t));
 8010112:	2004      	movs	r0, #4
 8010114:	f7fa fff4 	bl	800b100 <test_printn>
  test_println(" bytes");
 8010118:	4819      	ldr	r0, [pc, #100]	; (8010180 <bmk13_execute+0xc0>)
 801011a:	f7fb f859 	bl	800b1d0 <test_println>
  test_print("--- EventL: ");
 801011e:	481d      	ldr	r0, [pc, #116]	; (8010194 <bmk13_execute+0xd4>)
 8010120:	f7fb f836 	bl	800b190 <test_print>
  test_printn(sizeof(event_listener_t));
 8010124:	2014      	movs	r0, #20
 8010126:	f7fa ffeb 	bl	800b100 <test_printn>
  test_println(" bytes");
 801012a:	4815      	ldr	r0, [pc, #84]	; (8010180 <bmk13_execute+0xc0>)
 801012c:	f7fb f850 	bl	800b1d0 <test_println>
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  test_print("--- Mutex : ");
 8010130:	4819      	ldr	r0, [pc, #100]	; (8010198 <bmk13_execute+0xd8>)
 8010132:	f7fb f82d 	bl	800b190 <test_print>
  test_printn(sizeof(mutex_t));
 8010136:	2010      	movs	r0, #16
 8010138:	f7fa ffe2 	bl	800b100 <test_printn>
  test_println(" bytes");
 801013c:	4810      	ldr	r0, [pc, #64]	; (8010180 <bmk13_execute+0xc0>)
 801013e:	f7fb f847 	bl	800b1d0 <test_println>
#endif
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
  test_print("--- CondV.: ");
 8010142:	4816      	ldr	r0, [pc, #88]	; (801019c <bmk13_execute+0xdc>)
 8010144:	f7fb f824 	bl	800b190 <test_print>
  test_printn(sizeof(condition_variable_t));
 8010148:	2008      	movs	r0, #8
 801014a:	f7fa ffd9 	bl	800b100 <test_printn>
  test_println(" bytes");
 801014e:	480c      	ldr	r0, [pc, #48]	; (8010180 <bmk13_execute+0xc0>)
 8010150:	f7fb f83e 	bl	800b1d0 <test_println>
#endif
#if CH_CFG_USE_QUEUES || defined(__DOXYGEN__)
  test_print("--- Queue : ");
 8010154:	4812      	ldr	r0, [pc, #72]	; (80101a0 <bmk13_execute+0xe0>)
 8010156:	f7fb f81b 	bl	800b190 <test_print>
  test_printn(sizeof(io_queue_t));
 801015a:	2024      	movs	r0, #36	; 0x24
 801015c:	f7fa ffd0 	bl	800b100 <test_printn>
  test_println(" bytes");
 8010160:	4807      	ldr	r0, [pc, #28]	; (8010180 <bmk13_execute+0xc0>)
 8010162:	f7fb f835 	bl	800b1d0 <test_println>
#endif
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
  test_print("--- MailB.: ");
 8010166:	480f      	ldr	r0, [pc, #60]	; (80101a4 <bmk13_execute+0xe4>)
 8010168:	f7fb f812 	bl	800b190 <test_print>
  test_printn(sizeof(mailbox_t));
 801016c:	2028      	movs	r0, #40	; 0x28
 801016e:	f7fa ffc7 	bl	800b100 <test_printn>
  test_println(" bytes");
 8010172:	4803      	ldr	r0, [pc, #12]	; (8010180 <bmk13_execute+0xc0>)
 8010174:	f7fb f82c 	bl	800b1d0 <test_println>
#endif
}
 8010178:	bd08      	pop	{r3, pc}
 801017a:	bf00      	nop
 801017c:	08016d94 	.word	0x08016d94
 8010180:	08016da4 	.word	0x08016da4
 8010184:	08016dac 	.word	0x08016dac
 8010188:	08016dbc 	.word	0x08016dbc
 801018c:	08016dcc 	.word	0x08016dcc
 8010190:	08016ddc 	.word	0x08016ddc
 8010194:	08016dec 	.word	0x08016dec
 8010198:	08016dfc 	.word	0x08016dfc
 801019c:	08016e0c 	.word	0x08016e0c
 80101a0:	08016e1c 	.word	0x08016e1c
 80101a4:	08016e2c 	.word	0x08016e2c
 80101a8:	f3af 8000 	nop.w
 80101ac:	f3af 8000 	nop.w

080101b0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80101b0:	b082      	sub	sp, #8
 80101b2:	2320      	movs	r3, #32
 80101b4:	9301      	str	r3, [sp, #4]
 80101b6:	9b01      	ldr	r3, [sp, #4]
 80101b8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80101bc:	b002      	add	sp, #8
 80101be:	4770      	bx	lr

080101c0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80101c0:	b082      	sub	sp, #8
 80101c2:	2300      	movs	r3, #0
 80101c4:	9301      	str	r3, [sp, #4]
 80101c6:	9b01      	ldr	r3, [sp, #4]
 80101c8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80101cc:	b002      	add	sp, #8
 80101ce:	4770      	bx	lr

080101d0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80101d0:	b508      	push	{r3, lr}

  port_lock();
 80101d2:	f7ff ffed 	bl	80101b0 <port_lock>
}
 80101d6:	bd08      	pop	{r3, pc}
 80101d8:	f3af 8000 	nop.w
 80101dc:	f3af 8000 	nop.w

080101e0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 80101e0:	b508      	push	{r3, lr}

  port_unlock();
 80101e2:	f7ff ffed 	bl	80101c0 <port_unlock>
}
 80101e6:	bd08      	pop	{r3, pc}
 80101e8:	f3af 8000 	nop.w
 80101ec:	f3af 8000 	nop.w

080101f0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80101f0:	b508      	push	{r3, lr}

  port_lock();
 80101f2:	f7ff ffdd 	bl	80101b0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80101f6:	bd08      	pop	{r3, pc}
 80101f8:	f3af 8000 	nop.w
 80101fc:	f3af 8000 	nop.w

08010200 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8010200:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8010202:	f7ff ffdd 	bl	80101c0 <port_unlock>
}
 8010206:	bd08      	pop	{r3, pc}
 8010208:	f3af 8000 	nop.w
 801020c:	f3af 8000 	nop.w

08010210 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8010210:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8010212:	f7ff ffdd 	bl	80101d0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8010216:	bd08      	pop	{r3, pc}
 8010218:	f3af 8000 	nop.w
 801021c:	f3af 8000 	nop.w

08010220 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8010220:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8010222:	f7ff ffdd 	bl	80101e0 <port_unlock_from_isr>
}
 8010226:	bd08      	pop	{r3, pc}
 8010228:	f3af 8000 	nop.w
 801022c:	f3af 8000 	nop.w

08010230 <chVTObjectInit>:
 *
 * @param[out] vtp      the @p virtual_timer_t structure pointer
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {
 8010230:	b082      	sub	sp, #8
 8010232:	9001      	str	r0, [sp, #4]

  vtp->vt_func = NULL;
 8010234:	9b01      	ldr	r3, [sp, #4]
 8010236:	2200      	movs	r2, #0
 8010238:	60da      	str	r2, [r3, #12]
}
 801023a:	b002      	add	sp, #8
 801023c:	4770      	bx	lr
 801023e:	bf00      	nop

08010240 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 8010240:	b082      	sub	sp, #8
 8010242:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->vt_func != NULL);
 8010244:	9b01      	ldr	r3, [sp, #4]
 8010246:	68db      	ldr	r3, [r3, #12]
 8010248:	2b00      	cmp	r3, #0
 801024a:	bf0c      	ite	eq
 801024c:	2300      	moveq	r3, #0
 801024e:	2301      	movne	r3, #1
 8010250:	b2db      	uxtb	r3, r3
}
 8010252:	4618      	mov	r0, r3
 8010254:	b002      	add	sp, #8
 8010256:	4770      	bx	lr
 8010258:	f3af 8000 	nop.w
 801025c:	f3af 8000 	nop.w

08010260 <chVTResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {
 8010260:	b500      	push	{lr}
 8010262:	b083      	sub	sp, #12
 8010264:	9001      	str	r0, [sp, #4]

  if (chVTIsArmedI(vtp)) {
 8010266:	9801      	ldr	r0, [sp, #4]
 8010268:	f7ff ffea 	bl	8010240 <chVTIsArmedI>
 801026c:	4603      	mov	r3, r0
 801026e:	2b00      	cmp	r3, #0
 8010270:	d002      	beq.n	8010278 <chVTResetI+0x18>
    chVTDoResetI(vtp);
 8010272:	9801      	ldr	r0, [sp, #4]
 8010274:	f7f0 fbcc 	bl	8000a10 <chVTDoResetI>
  }
}
 8010278:	b003      	add	sp, #12
 801027a:	f85d fb04 	ldr.w	pc, [sp], #4
 801027e:	bf00      	nop

08010280 <chVTSetI>:
 *                      function
 *
 * @iclass
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {
 8010280:	b500      	push	{lr}
 8010282:	b085      	sub	sp, #20
 8010284:	9003      	str	r0, [sp, #12]
 8010286:	9102      	str	r1, [sp, #8]
 8010288:	9201      	str	r2, [sp, #4]
 801028a:	9300      	str	r3, [sp, #0]

  chVTResetI(vtp);
 801028c:	9803      	ldr	r0, [sp, #12]
 801028e:	f7ff ffe7 	bl	8010260 <chVTResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
 8010292:	9803      	ldr	r0, [sp, #12]
 8010294:	9902      	ldr	r1, [sp, #8]
 8010296:	9a01      	ldr	r2, [sp, #4]
 8010298:	9b00      	ldr	r3, [sp, #0]
 801029a:	f7f0 fb79 	bl	8000990 <chVTDoSetI>
}
 801029e:	b005      	add	sp, #20
 80102a0:	f85d fb04 	ldr.w	pc, [sp], #4
 80102a4:	f3af 8000 	nop.w
 80102a8:	f3af 8000 	nop.w
 80102ac:	f3af 8000 	nop.w

080102b0 <chVTSet>:
 *                      function
 *
 * @api
 */
static inline void chVTSet(virtual_timer_t *vtp, systime_t delay,
                           vtfunc_t vtfunc, void *par) {
 80102b0:	b500      	push	{lr}
 80102b2:	b085      	sub	sp, #20
 80102b4:	9003      	str	r0, [sp, #12]
 80102b6:	9102      	str	r1, [sp, #8]
 80102b8:	9201      	str	r2, [sp, #4]
 80102ba:	9300      	str	r3, [sp, #0]

  chSysLock();
 80102bc:	f7ff ff98 	bl	80101f0 <chSysLock>
  chVTSetI(vtp, delay, vtfunc, par);
 80102c0:	9803      	ldr	r0, [sp, #12]
 80102c2:	9902      	ldr	r1, [sp, #8]
 80102c4:	9a01      	ldr	r2, [sp, #4]
 80102c6:	9b00      	ldr	r3, [sp, #0]
 80102c8:	f7ff ffda 	bl	8010280 <chVTSetI>
  chSysUnlock();
 80102cc:	f7ff ff98 	bl	8010200 <chSysUnlock>
}
 80102d0:	b005      	add	sp, #20
 80102d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80102d6:	bf00      	nop
 80102d8:	f3af 8000 	nop.w
 80102dc:	f3af 8000 	nop.w

080102e0 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 80102e0:	b082      	sub	sp, #8
 80102e2:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 80102e4:	9b01      	ldr	r3, [sp, #4]
 80102e6:	9a01      	ldr	r2, [sp, #4]
 80102e8:	601a      	str	r2, [r3, #0]
}
 80102ea:	b002      	add	sp, #8
 80102ec:	4770      	bx	lr
 80102ee:	bf00      	nop

080102f0 <chEvtBroadcastI>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {
 80102f0:	b500      	push	{lr}
 80102f2:	b083      	sub	sp, #12
 80102f4:	9001      	str	r0, [sp, #4]

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
 80102f6:	9801      	ldr	r0, [sp, #4]
 80102f8:	2100      	movs	r1, #0
 80102fa:	f7f2 f9c1 	bl	8002680 <chEvtBroadcastFlagsI>
}
 80102fe:	b003      	add	sp, #12
 8010300:	f85d fb04 	ldr.w	pc, [sp], #4
 8010304:	f3af 8000 	nop.w
 8010308:	f3af 8000 	nop.w
 801030c:	f3af 8000 	nop.w

08010310 <tmrcb>:

/*===========================================================================*/
/* Module local functions.                                                   */
/*===========================================================================*/

static void tmrcb(void *p) {
 8010310:	b500      	push	{lr}
 8010312:	b085      	sub	sp, #20
 8010314:	9001      	str	r0, [sp, #4]
  event_timer_t *etp = p;
 8010316:	9b01      	ldr	r3, [sp, #4]
 8010318:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 801031a:	f7ff ff79 	bl	8010210 <chSysLockFromISR>
  chEvtBroadcastI(&etp->et_es);
 801031e:	9b03      	ldr	r3, [sp, #12]
 8010320:	3314      	adds	r3, #20
 8010322:	4618      	mov	r0, r3
 8010324:	f7ff ffe4 	bl	80102f0 <chEvtBroadcastI>
  chVTDoSetI(&etp->et_vt, etp->et_interval, tmrcb, etp);
 8010328:	9a03      	ldr	r2, [sp, #12]
 801032a:	9b03      	ldr	r3, [sp, #12]
 801032c:	699b      	ldr	r3, [r3, #24]
 801032e:	4610      	mov	r0, r2
 8010330:	4619      	mov	r1, r3
 8010332:	4a04      	ldr	r2, [pc, #16]	; (8010344 <tmrcb+0x34>)
 8010334:	9b03      	ldr	r3, [sp, #12]
 8010336:	f7f0 fb2b 	bl	8000990 <chVTDoSetI>
  chSysUnlockFromISR();
 801033a:	f7ff ff71 	bl	8010220 <chSysUnlockFromISR>
}
 801033e:	b005      	add	sp, #20
 8010340:	f85d fb04 	ldr.w	pc, [sp], #4
 8010344:	08010311 	.word	0x08010311
 8010348:	f3af 8000 	nop.w
 801034c:	f3af 8000 	nop.w

08010350 <evtObjectInit>:
 * @brief Initializes an @p event_timer_t structure.
 *
 * @param[out] etp      the @p event_timer_t structure to be initialized
 * @param[in] time      the interval in system ticks
 */
void evtObjectInit(event_timer_t *etp, systime_t time) {
 8010350:	b500      	push	{lr}
 8010352:	b083      	sub	sp, #12
 8010354:	9001      	str	r0, [sp, #4]
 8010356:	9100      	str	r1, [sp, #0]

  chEvtObjectInit(&etp->et_es);
 8010358:	9b01      	ldr	r3, [sp, #4]
 801035a:	3314      	adds	r3, #20
 801035c:	4618      	mov	r0, r3
 801035e:	f7ff ffbf 	bl	80102e0 <chEvtObjectInit>
  chVTObjectInit(&etp->et_vt);
 8010362:	9b01      	ldr	r3, [sp, #4]
 8010364:	4618      	mov	r0, r3
 8010366:	f7ff ff63 	bl	8010230 <chVTObjectInit>
  etp->et_interval = time;
 801036a:	9b01      	ldr	r3, [sp, #4]
 801036c:	9a00      	ldr	r2, [sp, #0]
 801036e:	619a      	str	r2, [r3, #24]
}
 8010370:	b003      	add	sp, #12
 8010372:	f85d fb04 	ldr.w	pc, [sp], #4
 8010376:	bf00      	nop
 8010378:	f3af 8000 	nop.w
 801037c:	f3af 8000 	nop.w

08010380 <evtStart>:
 * @brief   Starts the timer
 * @details If the timer was already running then the function has no effect.
 *
 * @param[in] etp       pointer to an initialized @p event_timer_t structure.
 */
void evtStart(event_timer_t *etp) {
 8010380:	b500      	push	{lr}
 8010382:	b083      	sub	sp, #12
 8010384:	9001      	str	r0, [sp, #4]

  chVTSet(&etp->et_vt, etp->et_interval, tmrcb, etp);
 8010386:	9a01      	ldr	r2, [sp, #4]
 8010388:	9b01      	ldr	r3, [sp, #4]
 801038a:	699b      	ldr	r3, [r3, #24]
 801038c:	4610      	mov	r0, r2
 801038e:	4619      	mov	r1, r3
 8010390:	4a03      	ldr	r2, [pc, #12]	; (80103a0 <evtStart+0x20>)
 8010392:	9b01      	ldr	r3, [sp, #4]
 8010394:	f7ff ff8c 	bl	80102b0 <chVTSet>
}
 8010398:	b003      	add	sp, #12
 801039a:	f85d fb04 	ldr.w	pc, [sp], #4
 801039e:	bf00      	nop
 80103a0:	08010311 	.word	0x08010311
 80103a4:	f3af 8000 	nop.w
 80103a8:	f3af 8000 	nop.w
 80103ac:	f3af 8000 	nop.w

080103b0 <writes>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static size_t writes(void *ip, const uint8_t *bp, size_t n) {
 80103b0:	b500      	push	{lr}
 80103b2:	b087      	sub	sp, #28
 80103b4:	9003      	str	r0, [sp, #12]
 80103b6:	9102      	str	r1, [sp, #8]
 80103b8:	9201      	str	r2, [sp, #4]
  MemoryStream *msp = ip;
 80103ba:	9b03      	ldr	r3, [sp, #12]
 80103bc:	9305      	str	r3, [sp, #20]

  if (msp->size - msp->eos < n)
 80103be:	9b05      	ldr	r3, [sp, #20]
 80103c0:	689a      	ldr	r2, [r3, #8]
 80103c2:	9b05      	ldr	r3, [sp, #20]
 80103c4:	68db      	ldr	r3, [r3, #12]
 80103c6:	1ad2      	subs	r2, r2, r3
 80103c8:	9b01      	ldr	r3, [sp, #4]
 80103ca:	429a      	cmp	r2, r3
 80103cc:	d205      	bcs.n	80103da <writes+0x2a>
    n = msp->size - msp->eos;
 80103ce:	9b05      	ldr	r3, [sp, #20]
 80103d0:	689a      	ldr	r2, [r3, #8]
 80103d2:	9b05      	ldr	r3, [sp, #20]
 80103d4:	68db      	ldr	r3, [r3, #12]
 80103d6:	1ad3      	subs	r3, r2, r3
 80103d8:	9301      	str	r3, [sp, #4]
  memcpy(msp->buffer + msp->eos, bp, n);
 80103da:	9b05      	ldr	r3, [sp, #20]
 80103dc:	685a      	ldr	r2, [r3, #4]
 80103de:	9b05      	ldr	r3, [sp, #20]
 80103e0:	68db      	ldr	r3, [r3, #12]
 80103e2:	4413      	add	r3, r2
 80103e4:	4618      	mov	r0, r3
 80103e6:	9902      	ldr	r1, [sp, #8]
 80103e8:	9a01      	ldr	r2, [sp, #4]
 80103ea:	f005 fb09 	bl	8015a00 <memcpy>
  msp->eos += n;
 80103ee:	9b05      	ldr	r3, [sp, #20]
 80103f0:	68da      	ldr	r2, [r3, #12]
 80103f2:	9b01      	ldr	r3, [sp, #4]
 80103f4:	441a      	add	r2, r3
 80103f6:	9b05      	ldr	r3, [sp, #20]
 80103f8:	60da      	str	r2, [r3, #12]
  return n;
 80103fa:	9b01      	ldr	r3, [sp, #4]
}
 80103fc:	4618      	mov	r0, r3
 80103fe:	b007      	add	sp, #28
 8010400:	f85d fb04 	ldr.w	pc, [sp], #4
 8010404:	f3af 8000 	nop.w
 8010408:	f3af 8000 	nop.w
 801040c:	f3af 8000 	nop.w

08010410 <reads>:

static size_t reads(void *ip, uint8_t *bp, size_t n) {
 8010410:	b500      	push	{lr}
 8010412:	b087      	sub	sp, #28
 8010414:	9003      	str	r0, [sp, #12]
 8010416:	9102      	str	r1, [sp, #8]
 8010418:	9201      	str	r2, [sp, #4]
  MemoryStream *msp = ip;
 801041a:	9b03      	ldr	r3, [sp, #12]
 801041c:	9305      	str	r3, [sp, #20]

  if (msp->eos - msp->offset < n)
 801041e:	9b05      	ldr	r3, [sp, #20]
 8010420:	68da      	ldr	r2, [r3, #12]
 8010422:	9b05      	ldr	r3, [sp, #20]
 8010424:	691b      	ldr	r3, [r3, #16]
 8010426:	1ad2      	subs	r2, r2, r3
 8010428:	9b01      	ldr	r3, [sp, #4]
 801042a:	429a      	cmp	r2, r3
 801042c:	d205      	bcs.n	801043a <reads+0x2a>
    n = msp->eos - msp->offset;
 801042e:	9b05      	ldr	r3, [sp, #20]
 8010430:	68da      	ldr	r2, [r3, #12]
 8010432:	9b05      	ldr	r3, [sp, #20]
 8010434:	691b      	ldr	r3, [r3, #16]
 8010436:	1ad3      	subs	r3, r2, r3
 8010438:	9301      	str	r3, [sp, #4]
  memcpy(bp, msp->buffer + msp->offset, n);
 801043a:	9b05      	ldr	r3, [sp, #20]
 801043c:	685a      	ldr	r2, [r3, #4]
 801043e:	9b05      	ldr	r3, [sp, #20]
 8010440:	691b      	ldr	r3, [r3, #16]
 8010442:	4413      	add	r3, r2
 8010444:	9802      	ldr	r0, [sp, #8]
 8010446:	4619      	mov	r1, r3
 8010448:	9a01      	ldr	r2, [sp, #4]
 801044a:	f005 fad9 	bl	8015a00 <memcpy>
  msp->offset += n;
 801044e:	9b05      	ldr	r3, [sp, #20]
 8010450:	691a      	ldr	r2, [r3, #16]
 8010452:	9b01      	ldr	r3, [sp, #4]
 8010454:	441a      	add	r2, r3
 8010456:	9b05      	ldr	r3, [sp, #20]
 8010458:	611a      	str	r2, [r3, #16]
  return n;
 801045a:	9b01      	ldr	r3, [sp, #4]
}
 801045c:	4618      	mov	r0, r3
 801045e:	b007      	add	sp, #28
 8010460:	f85d fb04 	ldr.w	pc, [sp], #4
 8010464:	f3af 8000 	nop.w
 8010468:	f3af 8000 	nop.w
 801046c:	f3af 8000 	nop.w

08010470 <put>:

static msg_t put(void *ip, uint8_t b) {
 8010470:	b084      	sub	sp, #16
 8010472:	9001      	str	r0, [sp, #4]
 8010474:	460b      	mov	r3, r1
 8010476:	f88d 3003 	strb.w	r3, [sp, #3]
  MemoryStream *msp = ip;
 801047a:	9b01      	ldr	r3, [sp, #4]
 801047c:	9303      	str	r3, [sp, #12]

  if (msp->size - msp->eos <= 0)
 801047e:	9b03      	ldr	r3, [sp, #12]
 8010480:	689a      	ldr	r2, [r3, #8]
 8010482:	9b03      	ldr	r3, [sp, #12]
 8010484:	68db      	ldr	r3, [r3, #12]
 8010486:	429a      	cmp	r2, r3
 8010488:	d102      	bne.n	8010490 <put+0x20>
    return MSG_RESET;
 801048a:	f06f 0301 	mvn.w	r3, #1
 801048e:	e00d      	b.n	80104ac <put+0x3c>
  *(msp->buffer + msp->eos) = b;
 8010490:	9b03      	ldr	r3, [sp, #12]
 8010492:	685a      	ldr	r2, [r3, #4]
 8010494:	9b03      	ldr	r3, [sp, #12]
 8010496:	68db      	ldr	r3, [r3, #12]
 8010498:	4413      	add	r3, r2
 801049a:	f89d 2003 	ldrb.w	r2, [sp, #3]
 801049e:	701a      	strb	r2, [r3, #0]
  msp->eos += 1;
 80104a0:	9b03      	ldr	r3, [sp, #12]
 80104a2:	68db      	ldr	r3, [r3, #12]
 80104a4:	1c5a      	adds	r2, r3, #1
 80104a6:	9b03      	ldr	r3, [sp, #12]
 80104a8:	60da      	str	r2, [r3, #12]
  return MSG_OK;
 80104aa:	2300      	movs	r3, #0
}
 80104ac:	4618      	mov	r0, r3
 80104ae:	b004      	add	sp, #16
 80104b0:	4770      	bx	lr
 80104b2:	bf00      	nop
 80104b4:	f3af 8000 	nop.w
 80104b8:	f3af 8000 	nop.w
 80104bc:	f3af 8000 	nop.w

080104c0 <get>:

static msg_t get(void *ip) {
 80104c0:	b084      	sub	sp, #16
 80104c2:	9001      	str	r0, [sp, #4]
  uint8_t b;
  MemoryStream *msp = ip;
 80104c4:	9b01      	ldr	r3, [sp, #4]
 80104c6:	9303      	str	r3, [sp, #12]

  if (msp->eos - msp->offset <= 0)
 80104c8:	9b03      	ldr	r3, [sp, #12]
 80104ca:	68da      	ldr	r2, [r3, #12]
 80104cc:	9b03      	ldr	r3, [sp, #12]
 80104ce:	691b      	ldr	r3, [r3, #16]
 80104d0:	429a      	cmp	r2, r3
 80104d2:	d102      	bne.n	80104da <get+0x1a>
    return MSG_RESET;
 80104d4:	f06f 0301 	mvn.w	r3, #1
 80104d8:	e00e      	b.n	80104f8 <get+0x38>
  b = *(msp->buffer + msp->offset);
 80104da:	9b03      	ldr	r3, [sp, #12]
 80104dc:	685a      	ldr	r2, [r3, #4]
 80104de:	9b03      	ldr	r3, [sp, #12]
 80104e0:	691b      	ldr	r3, [r3, #16]
 80104e2:	4413      	add	r3, r2
 80104e4:	781b      	ldrb	r3, [r3, #0]
 80104e6:	f88d 300b 	strb.w	r3, [sp, #11]
  msp->offset += 1;
 80104ea:	9b03      	ldr	r3, [sp, #12]
 80104ec:	691b      	ldr	r3, [r3, #16]
 80104ee:	1c5a      	adds	r2, r3, #1
 80104f0:	9b03      	ldr	r3, [sp, #12]
 80104f2:	611a      	str	r2, [r3, #16]
  return b;
 80104f4:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 80104f8:	4618      	mov	r0, r3
 80104fa:	b004      	add	sp, #16
 80104fc:	4770      	bx	lr
 80104fe:	bf00      	nop

08010500 <msObjectInit>:
 * @param[in] eos       initial End Of Stream offset. Normally you need to
 *                      put this to zero for RAM buffers or equal to @p size
 *                      for ROM streams.
 */
void msObjectInit(MemoryStream *msp, uint8_t *buffer,
                  size_t size, size_t eos) {
 8010500:	b084      	sub	sp, #16
 8010502:	9003      	str	r0, [sp, #12]
 8010504:	9102      	str	r1, [sp, #8]
 8010506:	9201      	str	r2, [sp, #4]
 8010508:	9300      	str	r3, [sp, #0]

  msp->vmt    = &vmt;
 801050a:	9b03      	ldr	r3, [sp, #12]
 801050c:	4a07      	ldr	r2, [pc, #28]	; (801052c <msObjectInit+0x2c>)
 801050e:	601a      	str	r2, [r3, #0]
  msp->buffer = buffer;
 8010510:	9b03      	ldr	r3, [sp, #12]
 8010512:	9a02      	ldr	r2, [sp, #8]
 8010514:	605a      	str	r2, [r3, #4]
  msp->size   = size;
 8010516:	9b03      	ldr	r3, [sp, #12]
 8010518:	9a01      	ldr	r2, [sp, #4]
 801051a:	609a      	str	r2, [r3, #8]
  msp->eos    = eos;
 801051c:	9b03      	ldr	r3, [sp, #12]
 801051e:	9a00      	ldr	r2, [sp, #0]
 8010520:	60da      	str	r2, [r3, #12]
  msp->offset = 0;
 8010522:	9b03      	ldr	r3, [sp, #12]
 8010524:	2200      	movs	r2, #0
 8010526:	611a      	str	r2, [r3, #16]
}
 8010528:	b004      	add	sp, #16
 801052a:	4770      	bx	lr
 801052c:	08016ea0 	.word	0x08016ea0

08010530 <long_to_string_with_divisor>:
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
                                         long num,
                                         unsigned radix,
                                         long divisor) {
 8010530:	b088      	sub	sp, #32
 8010532:	9003      	str	r0, [sp, #12]
 8010534:	9102      	str	r1, [sp, #8]
 8010536:	9201      	str	r2, [sp, #4]
 8010538:	9300      	str	r3, [sp, #0]
  int i;
  char *q;
  long l, ll;

  l = num;
 801053a:	9b02      	ldr	r3, [sp, #8]
 801053c:	9305      	str	r3, [sp, #20]
  if (divisor == 0) {
 801053e:	9b00      	ldr	r3, [sp, #0]
 8010540:	2b00      	cmp	r3, #0
 8010542:	d102      	bne.n	801054a <long_to_string_with_divisor+0x1a>
    ll = num;
 8010544:	9b02      	ldr	r3, [sp, #8]
 8010546:	9304      	str	r3, [sp, #16]
 8010548:	e001      	b.n	801054e <long_to_string_with_divisor+0x1e>
  } else {
    ll = divisor;
 801054a:	9b00      	ldr	r3, [sp, #0]
 801054c:	9304      	str	r3, [sp, #16]
  }

  q = p + MAX_FILLER;
 801054e:	9b03      	ldr	r3, [sp, #12]
 8010550:	330b      	adds	r3, #11
 8010552:	9306      	str	r3, [sp, #24]
  do {
    i = (int)(l % radix);
 8010554:	9b05      	ldr	r3, [sp, #20]
 8010556:	9a01      	ldr	r2, [sp, #4]
 8010558:	fbb3 f2f2 	udiv	r2, r3, r2
 801055c:	9901      	ldr	r1, [sp, #4]
 801055e:	fb01 f202 	mul.w	r2, r1, r2
 8010562:	1a9b      	subs	r3, r3, r2
 8010564:	9307      	str	r3, [sp, #28]
    i += '0';
 8010566:	9b07      	ldr	r3, [sp, #28]
 8010568:	3330      	adds	r3, #48	; 0x30
 801056a:	9307      	str	r3, [sp, #28]
    if (i > '9')
 801056c:	9b07      	ldr	r3, [sp, #28]
 801056e:	2b39      	cmp	r3, #57	; 0x39
 8010570:	dd02      	ble.n	8010578 <long_to_string_with_divisor+0x48>
      i += 'A' - '0' - 10;
 8010572:	9b07      	ldr	r3, [sp, #28]
 8010574:	3307      	adds	r3, #7
 8010576:	9307      	str	r3, [sp, #28]
    *--q = i;
 8010578:	9b06      	ldr	r3, [sp, #24]
 801057a:	3b01      	subs	r3, #1
 801057c:	9306      	str	r3, [sp, #24]
 801057e:	9b07      	ldr	r3, [sp, #28]
 8010580:	b2da      	uxtb	r2, r3
 8010582:	9b06      	ldr	r3, [sp, #24]
 8010584:	701a      	strb	r2, [r3, #0]
    l /= radix;
 8010586:	9a05      	ldr	r2, [sp, #20]
 8010588:	9b01      	ldr	r3, [sp, #4]
 801058a:	fbb2 f3f3 	udiv	r3, r2, r3
 801058e:	9305      	str	r3, [sp, #20]
  } while ((ll /= radix) != 0);
 8010590:	9a04      	ldr	r2, [sp, #16]
 8010592:	9b01      	ldr	r3, [sp, #4]
 8010594:	fbb2 f3f3 	udiv	r3, r2, r3
 8010598:	9304      	str	r3, [sp, #16]
 801059a:	9b04      	ldr	r3, [sp, #16]
 801059c:	2b00      	cmp	r3, #0
 801059e:	d1d9      	bne.n	8010554 <long_to_string_with_divisor+0x24>

  i = (int)(p + MAX_FILLER - q);
 80105a0:	9b03      	ldr	r3, [sp, #12]
 80105a2:	330b      	adds	r3, #11
 80105a4:	461a      	mov	r2, r3
 80105a6:	9b06      	ldr	r3, [sp, #24]
 80105a8:	1ad3      	subs	r3, r2, r3
 80105aa:	9307      	str	r3, [sp, #28]
  do
    *p++ = *q++;
 80105ac:	9b03      	ldr	r3, [sp, #12]
 80105ae:	1c5a      	adds	r2, r3, #1
 80105b0:	9203      	str	r2, [sp, #12]
 80105b2:	9a06      	ldr	r2, [sp, #24]
 80105b4:	1c51      	adds	r1, r2, #1
 80105b6:	9106      	str	r1, [sp, #24]
 80105b8:	7812      	ldrb	r2, [r2, #0]
 80105ba:	701a      	strb	r2, [r3, #0]
  while (--i);
 80105bc:	9b07      	ldr	r3, [sp, #28]
 80105be:	3b01      	subs	r3, #1
 80105c0:	9307      	str	r3, [sp, #28]
 80105c2:	9b07      	ldr	r3, [sp, #28]
 80105c4:	2b00      	cmp	r3, #0
 80105c6:	d1f1      	bne.n	80105ac <long_to_string_with_divisor+0x7c>

  return p;
 80105c8:	9b03      	ldr	r3, [sp, #12]
}
 80105ca:	4618      	mov	r0, r3
 80105cc:	b008      	add	sp, #32
 80105ce:	4770      	bx	lr

080105d0 <ch_ltoa>:

static char *ch_ltoa(char *p, long num, unsigned radix) {
 80105d0:	b500      	push	{lr}
 80105d2:	b085      	sub	sp, #20
 80105d4:	9003      	str	r0, [sp, #12]
 80105d6:	9102      	str	r1, [sp, #8]
 80105d8:	9201      	str	r2, [sp, #4]

  return long_to_string_with_divisor(p, num, radix, 0);
 80105da:	9803      	ldr	r0, [sp, #12]
 80105dc:	9902      	ldr	r1, [sp, #8]
 80105de:	9a01      	ldr	r2, [sp, #4]
 80105e0:	2300      	movs	r3, #0
 80105e2:	f7ff ffa5 	bl	8010530 <long_to_string_with_divisor>
 80105e6:	4603      	mov	r3, r0
}
 80105e8:	4618      	mov	r0, r3
 80105ea:	b005      	add	sp, #20
 80105ec:	f85d fb04 	ldr.w	pc, [sp], #4

080105f0 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 80105f0:	b500      	push	{lr}
 80105f2:	b091      	sub	sp, #68	; 0x44
 80105f4:	9003      	str	r0, [sp, #12]
 80105f6:	9102      	str	r1, [sp, #8]
 80105f8:	9201      	str	r2, [sp, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 80105fa:	2300      	movs	r3, #0
 80105fc:	9309      	str	r3, [sp, #36]	; 0x24
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 80105fe:	9b02      	ldr	r3, [sp, #8]
 8010600:	1c5a      	adds	r2, r3, #1
 8010602:	9202      	str	r2, [sp, #8]
 8010604:	781b      	ldrb	r3, [r3, #0]
 8010606:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    if (c == 0)
 801060a:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801060e:	2b00      	cmp	r3, #0
 8010610:	d101      	bne.n	8010616 <chvprintf+0x26>
      return n;
 8010612:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8010614:	e210      	b.n	8010a38 <chvprintf+0x448>
    if (c != '%') {
 8010616:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801061a:	2b25      	cmp	r3, #37	; 0x25
 801061c:	d00b      	beq.n	8010636 <chvprintf+0x46>
      streamPut(chp, (uint8_t)c);
 801061e:	9b03      	ldr	r3, [sp, #12]
 8010620:	681b      	ldr	r3, [r3, #0]
 8010622:	689b      	ldr	r3, [r3, #8]
 8010624:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 8010628:	9803      	ldr	r0, [sp, #12]
 801062a:	4611      	mov	r1, r2
 801062c:	4798      	blx	r3
      n++;
 801062e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8010630:	3301      	adds	r3, #1
 8010632:	9309      	str	r3, [sp, #36]	; 0x24
      continue;
 8010634:	e1ff      	b.n	8010a36 <chvprintf+0x446>
    }
    p = tmpbuf;
 8010636:	ab04      	add	r3, sp, #16
 8010638:	930f      	str	r3, [sp, #60]	; 0x3c
    s = tmpbuf;
 801063a:	ab04      	add	r3, sp, #16
 801063c:	930e      	str	r3, [sp, #56]	; 0x38
    left_align = FALSE;
 801063e:	2300      	movs	r3, #0
 8010640:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    if (*fmt == '-') {
 8010644:	9b02      	ldr	r3, [sp, #8]
 8010646:	781b      	ldrb	r3, [r3, #0]
 8010648:	2b2d      	cmp	r3, #45	; 0x2d
 801064a:	d105      	bne.n	8010658 <chvprintf+0x68>
      fmt++;
 801064c:	9b02      	ldr	r3, [sp, #8]
 801064e:	3301      	adds	r3, #1
 8010650:	9302      	str	r3, [sp, #8]
      left_align = TRUE;
 8010652:	2301      	movs	r3, #1
 8010654:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    }
    filler = ' ';
 8010658:	2320      	movs	r3, #32
 801065a:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    if (*fmt == '0') {
 801065e:	9b02      	ldr	r3, [sp, #8]
 8010660:	781b      	ldrb	r3, [r3, #0]
 8010662:	2b30      	cmp	r3, #48	; 0x30
 8010664:	d105      	bne.n	8010672 <chvprintf+0x82>
      fmt++;
 8010666:	9b02      	ldr	r3, [sp, #8]
 8010668:	3301      	adds	r3, #1
 801066a:	9302      	str	r3, [sp, #8]
      filler = '0';
 801066c:	2330      	movs	r3, #48	; 0x30
 801066e:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    }
    width = 0;
 8010672:	2300      	movs	r3, #0
 8010674:	930a      	str	r3, [sp, #40]	; 0x28
    while (TRUE) {
      c = *fmt++;
 8010676:	9b02      	ldr	r3, [sp, #8]
 8010678:	1c5a      	adds	r2, r3, #1
 801067a:	9202      	str	r2, [sp, #8]
 801067c:	781b      	ldrb	r3, [r3, #0]
 801067e:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      if (c >= '0' && c <= '9')
 8010682:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8010686:	2b2f      	cmp	r3, #47	; 0x2f
 8010688:	d909      	bls.n	801069e <chvprintf+0xae>
 801068a:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801068e:	2b39      	cmp	r3, #57	; 0x39
 8010690:	d805      	bhi.n	801069e <chvprintf+0xae>
        c -= '0';
 8010692:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8010696:	3b30      	subs	r3, #48	; 0x30
 8010698:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 801069c:	e012      	b.n	80106c4 <chvprintf+0xd4>
      else if (c == '*')
 801069e:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80106a2:	2b2a      	cmp	r3, #42	; 0x2a
 80106a4:	d106      	bne.n	80106b4 <chvprintf+0xc4>
        c = va_arg(ap, int);
 80106a6:	9b01      	ldr	r3, [sp, #4]
 80106a8:	1d1a      	adds	r2, r3, #4
 80106aa:	9201      	str	r2, [sp, #4]
 80106ac:	681b      	ldr	r3, [r3, #0]
 80106ae:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 80106b2:	e007      	b.n	80106c4 <chvprintf+0xd4>
      else
        break;
 80106b4:	bf00      	nop
      width = width * 10 + c;
    }
    precision = 0;
 80106b6:	2300      	movs	r3, #0
 80106b8:	930b      	str	r3, [sp, #44]	; 0x2c
    if (c == '.') {
 80106ba:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80106be:	2b2e      	cmp	r3, #46	; 0x2e
 80106c0:	d137      	bne.n	8010732 <chvprintf+0x142>
 80106c2:	e00a      	b.n	80106da <chvprintf+0xea>
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
      else
        break;
      width = width * 10 + c;
 80106c4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80106c6:	4613      	mov	r3, r2
 80106c8:	009b      	lsls	r3, r3, #2
 80106ca:	4413      	add	r3, r2
 80106cc:	005b      	lsls	r3, r3, #1
 80106ce:	461a      	mov	r2, r3
 80106d0:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80106d4:	4413      	add	r3, r2
 80106d6:	930a      	str	r3, [sp, #40]	; 0x28
    }
 80106d8:	e7cd      	b.n	8010676 <chvprintf+0x86>
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
 80106da:	9b02      	ldr	r3, [sp, #8]
 80106dc:	1c5a      	adds	r2, r3, #1
 80106de:	9202      	str	r2, [sp, #8]
 80106e0:	781b      	ldrb	r3, [r3, #0]
 80106e2:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
        if (c >= '0' && c <= '9')
 80106e6:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80106ea:	2b2f      	cmp	r3, #47	; 0x2f
 80106ec:	d909      	bls.n	8010702 <chvprintf+0x112>
 80106ee:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80106f2:	2b39      	cmp	r3, #57	; 0x39
 80106f4:	d805      	bhi.n	8010702 <chvprintf+0x112>
          c -= '0';
 80106f6:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80106fa:	3b30      	subs	r3, #48	; 0x30
 80106fc:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 8010700:	e00b      	b.n	801071a <chvprintf+0x12a>
        else if (c == '*')
 8010702:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8010706:	2b2a      	cmp	r3, #42	; 0x2a
 8010708:	d106      	bne.n	8010718 <chvprintf+0x128>
          c = va_arg(ap, int);
 801070a:	9b01      	ldr	r3, [sp, #4]
 801070c:	1d1a      	adds	r2, r3, #4
 801070e:	9201      	str	r2, [sp, #4]
 8010710:	681b      	ldr	r3, [r3, #0]
 8010712:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 8010716:	e000      	b.n	801071a <chvprintf+0x12a>
        else
          break;
 8010718:	e00b      	b.n	8010732 <chvprintf+0x142>
        precision *= 10;
 801071a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801071c:	4613      	mov	r3, r2
 801071e:	009b      	lsls	r3, r3, #2
 8010720:	4413      	add	r3, r2
 8010722:	005b      	lsls	r3, r3, #1
 8010724:	930b      	str	r3, [sp, #44]	; 0x2c
        precision += c;
 8010726:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801072a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801072c:	4413      	add	r3, r2
 801072e:	930b      	str	r3, [sp, #44]	; 0x2c
      }
 8010730:	e7d3      	b.n	80106da <chvprintf+0xea>
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8010732:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8010736:	2b6c      	cmp	r3, #108	; 0x6c
 8010738:	d003      	beq.n	8010742 <chvprintf+0x152>
 801073a:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801073e:	2b4c      	cmp	r3, #76	; 0x4c
 8010740:	d10e      	bne.n	8010760 <chvprintf+0x170>
      is_long = TRUE;
 8010742:	2301      	movs	r3, #1
 8010744:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
      if (*fmt)
 8010748:	9b02      	ldr	r3, [sp, #8]
 801074a:	781b      	ldrb	r3, [r3, #0]
 801074c:	2b00      	cmp	r3, #0
 801074e:	d006      	beq.n	801075e <chvprintf+0x16e>
        c = *fmt++;
 8010750:	9b02      	ldr	r3, [sp, #8]
 8010752:	1c5a      	adds	r2, r3, #1
 8010754:	9202      	str	r2, [sp, #8]
 8010756:	781b      	ldrb	r3, [r3, #0]
 8010758:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
 801075c:	e013      	b.n	8010786 <chvprintf+0x196>
 801075e:	e012      	b.n	8010786 <chvprintf+0x196>
        c = *fmt++;
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');
 8010760:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8010764:	2b40      	cmp	r3, #64	; 0x40
 8010766:	d905      	bls.n	8010774 <chvprintf+0x184>
 8010768:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801076c:	2b5a      	cmp	r3, #90	; 0x5a
 801076e:	d801      	bhi.n	8010774 <chvprintf+0x184>
 8010770:	2301      	movs	r3, #1
 8010772:	e000      	b.n	8010776 <chvprintf+0x186>
 8010774:	2300      	movs	r3, #0
 8010776:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
 801077a:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 801077e:	f003 0301 	and.w	r3, r3, #1
 8010782:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23

    /* Command decoding.*/
    switch (c) {
 8010786:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801078a:	3b44      	subs	r3, #68	; 0x44
 801078c:	2b34      	cmp	r3, #52	; 0x34
 801078e:	f200 80e2 	bhi.w	8010956 <chvprintf+0x366>
 8010792:	a201      	add	r2, pc, #4	; (adr r2, 8010798 <chvprintf+0x1a8>)
 8010794:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8010798:	080108cf 	.word	0x080108cf
 801079c:	08010957 	.word	0x08010957
 80107a0:	08010957 	.word	0x08010957
 80107a4:	08010957 	.word	0x08010957
 80107a8:	08010957 	.word	0x08010957
 80107ac:	080108cf 	.word	0x080108cf
 80107b0:	08010957 	.word	0x08010957
 80107b4:	08010957 	.word	0x08010957
 80107b8:	08010957 	.word	0x08010957
 80107bc:	08010957 	.word	0x08010957
 80107c0:	08010957 	.word	0x08010957
 80107c4:	08010921 	.word	0x08010921
 80107c8:	08010957 	.word	0x08010957
 80107cc:	08010957 	.word	0x08010957
 80107d0:	08010957 	.word	0x08010957
 80107d4:	08010957 	.word	0x08010957
 80107d8:	08010957 	.word	0x08010957
 80107dc:	08010919 	.word	0x08010919
 80107e0:	08010957 	.word	0x08010957
 80107e4:	08010957 	.word	0x08010957
 80107e8:	08010911 	.word	0x08010911
 80107ec:	08010957 	.word	0x08010957
 80107f0:	08010957 	.word	0x08010957
 80107f4:	08010957 	.word	0x08010957
 80107f8:	08010957 	.word	0x08010957
 80107fc:	08010957 	.word	0x08010957
 8010800:	08010957 	.word	0x08010957
 8010804:	08010957 	.word	0x08010957
 8010808:	08010957 	.word	0x08010957
 801080c:	08010957 	.word	0x08010957
 8010810:	08010957 	.word	0x08010957
 8010814:	0801086d 	.word	0x0801086d
 8010818:	080108cf 	.word	0x080108cf
 801081c:	08010957 	.word	0x08010957
 8010820:	08010957 	.word	0x08010957
 8010824:	08010957 	.word	0x08010957
 8010828:	08010957 	.word	0x08010957
 801082c:	080108cf 	.word	0x080108cf
 8010830:	08010957 	.word	0x08010957
 8010834:	08010957 	.word	0x08010957
 8010838:	08010957 	.word	0x08010957
 801083c:	08010957 	.word	0x08010957
 8010840:	08010957 	.word	0x08010957
 8010844:	08010921 	.word	0x08010921
 8010848:	08010957 	.word	0x08010957
 801084c:	08010957 	.word	0x08010957
 8010850:	08010957 	.word	0x08010957
 8010854:	08010887 	.word	0x08010887
 8010858:	08010957 	.word	0x08010957
 801085c:	08010919 	.word	0x08010919
 8010860:	08010957 	.word	0x08010957
 8010864:	08010957 	.word	0x08010957
 8010868:	08010911 	.word	0x08010911
    case 'c':
      filler = ' ';
 801086c:	2320      	movs	r3, #32
 801086e:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
      *p++ = va_arg(ap, int);
 8010872:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8010874:	1c5a      	adds	r2, r3, #1
 8010876:	920f      	str	r2, [sp, #60]	; 0x3c
 8010878:	9a01      	ldr	r2, [sp, #4]
 801087a:	1d11      	adds	r1, r2, #4
 801087c:	9101      	str	r1, [sp, #4]
 801087e:	6812      	ldr	r2, [r2, #0]
 8010880:	b2d2      	uxtb	r2, r2
 8010882:	701a      	strb	r2, [r3, #0]
      break;
 8010884:	e06e      	b.n	8010964 <chvprintf+0x374>
    case 's':
      filler = ' ';
 8010886:	2320      	movs	r3, #32
 8010888:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
      if ((s = va_arg(ap, char *)) == 0)
 801088c:	9b01      	ldr	r3, [sp, #4]
 801088e:	1d1a      	adds	r2, r3, #4
 8010890:	9201      	str	r2, [sp, #4]
 8010892:	681b      	ldr	r3, [r3, #0]
 8010894:	930e      	str	r3, [sp, #56]	; 0x38
 8010896:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8010898:	2b00      	cmp	r3, #0
 801089a:	d101      	bne.n	80108a0 <chvprintf+0x2b0>
        s = "(null)";
 801089c:	4b68      	ldr	r3, [pc, #416]	; (8010a40 <chvprintf+0x450>)
 801089e:	930e      	str	r3, [sp, #56]	; 0x38
      if (precision == 0)
 80108a0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80108a2:	2b00      	cmp	r3, #0
 80108a4:	d102      	bne.n	80108ac <chvprintf+0x2bc>
        precision = 32767;
 80108a6:	f647 73ff 	movw	r3, #32767	; 0x7fff
 80108aa:	930b      	str	r3, [sp, #44]	; 0x2c
      for (p = s; *p && (--precision >= 0); p++)
 80108ac:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80108ae:	930f      	str	r3, [sp, #60]	; 0x3c
 80108b0:	e002      	b.n	80108b8 <chvprintf+0x2c8>
 80108b2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80108b4:	3301      	adds	r3, #1
 80108b6:	930f      	str	r3, [sp, #60]	; 0x3c
 80108b8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80108ba:	781b      	ldrb	r3, [r3, #0]
 80108bc:	2b00      	cmp	r3, #0
 80108be:	d005      	beq.n	80108cc <chvprintf+0x2dc>
 80108c0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80108c2:	3b01      	subs	r3, #1
 80108c4:	930b      	str	r3, [sp, #44]	; 0x2c
 80108c6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80108c8:	2b00      	cmp	r3, #0
 80108ca:	daf2      	bge.n	80108b2 <chvprintf+0x2c2>
        ;
      break;
 80108cc:	e04a      	b.n	8010964 <chvprintf+0x374>
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long)
 80108ce:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 80108d2:	2b00      	cmp	r3, #0
 80108d4:	d005      	beq.n	80108e2 <chvprintf+0x2f2>
        l = va_arg(ap, long);
 80108d6:	9b01      	ldr	r3, [sp, #4]
 80108d8:	1d1a      	adds	r2, r3, #4
 80108da:	9201      	str	r2, [sp, #4]
 80108dc:	681b      	ldr	r3, [r3, #0]
 80108de:	9307      	str	r3, [sp, #28]
 80108e0:	e004      	b.n	80108ec <chvprintf+0x2fc>
      else
        l = va_arg(ap, int);
 80108e2:	9b01      	ldr	r3, [sp, #4]
 80108e4:	1d1a      	adds	r2, r3, #4
 80108e6:	9201      	str	r2, [sp, #4]
 80108e8:	681b      	ldr	r3, [r3, #0]
 80108ea:	9307      	str	r3, [sp, #28]
      if (l < 0) {
 80108ec:	9b07      	ldr	r3, [sp, #28]
 80108ee:	2b00      	cmp	r3, #0
 80108f0:	da07      	bge.n	8010902 <chvprintf+0x312>
        *p++ = '-';
 80108f2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80108f4:	1c5a      	adds	r2, r3, #1
 80108f6:	920f      	str	r2, [sp, #60]	; 0x3c
 80108f8:	222d      	movs	r2, #45	; 0x2d
 80108fa:	701a      	strb	r2, [r3, #0]
        l = -l;
 80108fc:	9b07      	ldr	r3, [sp, #28]
 80108fe:	425b      	negs	r3, r3
 8010900:	9307      	str	r3, [sp, #28]
      }
      p = ch_ltoa(p, l, 10);
 8010902:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8010904:	9907      	ldr	r1, [sp, #28]
 8010906:	220a      	movs	r2, #10
 8010908:	f7ff fe62 	bl	80105d0 <ch_ltoa>
 801090c:	900f      	str	r0, [sp, #60]	; 0x3c
      break;
 801090e:	e029      	b.n	8010964 <chvprintf+0x374>
      p = ftoa(p, f, precision);
      break;
#endif
    case 'X':
    case 'x':
      c = 16;
 8010910:	2310      	movs	r3, #16
 8010912:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      goto unsigned_common;
 8010916:	e006      	b.n	8010926 <chvprintf+0x336>
    case 'U':
    case 'u':
      c = 10;
 8010918:	230a      	movs	r3, #10
 801091a:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      goto unsigned_common;
 801091e:	e002      	b.n	8010926 <chvprintf+0x336>
    case 'O':
    case 'o':
      c = 8;
 8010920:	2308      	movs	r3, #8
 8010922:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
unsigned_common:
      if (is_long)
 8010926:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 801092a:	2b00      	cmp	r3, #0
 801092c:	d005      	beq.n	801093a <chvprintf+0x34a>
        l = va_arg(ap, unsigned long);
 801092e:	9b01      	ldr	r3, [sp, #4]
 8010930:	1d1a      	adds	r2, r3, #4
 8010932:	9201      	str	r2, [sp, #4]
 8010934:	681b      	ldr	r3, [r3, #0]
 8010936:	9307      	str	r3, [sp, #28]
 8010938:	e004      	b.n	8010944 <chvprintf+0x354>
      else
        l = va_arg(ap, unsigned int);
 801093a:	9b01      	ldr	r3, [sp, #4]
 801093c:	1d1a      	adds	r2, r3, #4
 801093e:	9201      	str	r2, [sp, #4]
 8010940:	681b      	ldr	r3, [r3, #0]
 8010942:	9307      	str	r3, [sp, #28]
      p = ch_ltoa(p, l, c);
 8010944:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8010948:	980f      	ldr	r0, [sp, #60]	; 0x3c
 801094a:	9907      	ldr	r1, [sp, #28]
 801094c:	461a      	mov	r2, r3
 801094e:	f7ff fe3f 	bl	80105d0 <ch_ltoa>
 8010952:	900f      	str	r0, [sp, #60]	; 0x3c
      break;
 8010954:	e006      	b.n	8010964 <chvprintf+0x374>
    default:
      *p++ = c;
 8010956:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8010958:	1c5a      	adds	r2, r3, #1
 801095a:	920f      	str	r2, [sp, #60]	; 0x3c
 801095c:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 8010960:	701a      	strb	r2, [r3, #0]
      break;
 8010962:	bf00      	nop
    }
    i = (int)(p - s);
 8010964:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8010966:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8010968:	1ad3      	subs	r3, r2, r3
 801096a:	930c      	str	r3, [sp, #48]	; 0x30
    if ((width -= i) < 0)
 801096c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801096e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8010970:	1ad3      	subs	r3, r2, r3
 8010972:	930a      	str	r3, [sp, #40]	; 0x28
 8010974:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8010976:	2b00      	cmp	r3, #0
 8010978:	da01      	bge.n	801097e <chvprintf+0x38e>
      width = 0;
 801097a:	2300      	movs	r3, #0
 801097c:	930a      	str	r3, [sp, #40]	; 0x28
    if (left_align == FALSE)
 801097e:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
 8010982:	f083 0301 	eor.w	r3, r3, #1
 8010986:	b2db      	uxtb	r3, r3
 8010988:	2b00      	cmp	r3, #0
 801098a:	d002      	beq.n	8010992 <chvprintf+0x3a2>
      width = -width;
 801098c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801098e:	425b      	negs	r3, r3
 8010990:	930a      	str	r3, [sp, #40]	; 0x28
    if (width < 0) {
 8010992:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8010994:	2b00      	cmp	r3, #0
 8010996:	da28      	bge.n	80109ea <chvprintf+0x3fa>
      if (*s == '-' && filler == '0') {
 8010998:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801099a:	781b      	ldrb	r3, [r3, #0]
 801099c:	2b2d      	cmp	r3, #45	; 0x2d
 801099e:	d113      	bne.n	80109c8 <chvprintf+0x3d8>
 80109a0:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
 80109a4:	2b30      	cmp	r3, #48	; 0x30
 80109a6:	d10f      	bne.n	80109c8 <chvprintf+0x3d8>
        streamPut(chp, (uint8_t)*s++);
 80109a8:	9b03      	ldr	r3, [sp, #12]
 80109aa:	681b      	ldr	r3, [r3, #0]
 80109ac:	689a      	ldr	r2, [r3, #8]
 80109ae:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80109b0:	1c59      	adds	r1, r3, #1
 80109b2:	910e      	str	r1, [sp, #56]	; 0x38
 80109b4:	781b      	ldrb	r3, [r3, #0]
 80109b6:	9803      	ldr	r0, [sp, #12]
 80109b8:	4619      	mov	r1, r3
 80109ba:	4790      	blx	r2
        n++;
 80109bc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80109be:	3301      	adds	r3, #1
 80109c0:	9309      	str	r3, [sp, #36]	; 0x24
        i--;
 80109c2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80109c4:	3b01      	subs	r3, #1
 80109c6:	930c      	str	r3, [sp, #48]	; 0x30
      }
      do {
        streamPut(chp, (uint8_t)filler);
 80109c8:	9b03      	ldr	r3, [sp, #12]
 80109ca:	681b      	ldr	r3, [r3, #0]
 80109cc:	689b      	ldr	r3, [r3, #8]
 80109ce:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
 80109d2:	9803      	ldr	r0, [sp, #12]
 80109d4:	4611      	mov	r1, r2
 80109d6:	4798      	blx	r3
        n++;
 80109d8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80109da:	3301      	adds	r3, #1
 80109dc:	9309      	str	r3, [sp, #36]	; 0x24
      } while (++width != 0);
 80109de:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80109e0:	3301      	adds	r3, #1
 80109e2:	930a      	str	r3, [sp, #40]	; 0x28
 80109e4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80109e6:	2b00      	cmp	r3, #0
 80109e8:	d1ee      	bne.n	80109c8 <chvprintf+0x3d8>
    }
    while (--i >= 0) {
 80109ea:	e00c      	b.n	8010a06 <chvprintf+0x416>
      streamPut(chp, (uint8_t)*s++);
 80109ec:	9b03      	ldr	r3, [sp, #12]
 80109ee:	681b      	ldr	r3, [r3, #0]
 80109f0:	689a      	ldr	r2, [r3, #8]
 80109f2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80109f4:	1c59      	adds	r1, r3, #1
 80109f6:	910e      	str	r1, [sp, #56]	; 0x38
 80109f8:	781b      	ldrb	r3, [r3, #0]
 80109fa:	9803      	ldr	r0, [sp, #12]
 80109fc:	4619      	mov	r1, r3
 80109fe:	4790      	blx	r2
      n++;
 8010a00:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8010a02:	3301      	adds	r3, #1
 8010a04:	9309      	str	r3, [sp, #36]	; 0x24
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8010a06:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8010a08:	3b01      	subs	r3, #1
 8010a0a:	930c      	str	r3, [sp, #48]	; 0x30
 8010a0c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8010a0e:	2b00      	cmp	r3, #0
 8010a10:	daec      	bge.n	80109ec <chvprintf+0x3fc>
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8010a12:	e00d      	b.n	8010a30 <chvprintf+0x440>
      streamPut(chp, (uint8_t)filler);
 8010a14:	9b03      	ldr	r3, [sp, #12]
 8010a16:	681b      	ldr	r3, [r3, #0]
 8010a18:	689b      	ldr	r3, [r3, #8]
 8010a1a:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
 8010a1e:	9803      	ldr	r0, [sp, #12]
 8010a20:	4611      	mov	r1, r2
 8010a22:	4798      	blx	r3
      n++;
 8010a24:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8010a26:	3301      	adds	r3, #1
 8010a28:	9309      	str	r3, [sp, #36]	; 0x24
      width--;
 8010a2a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8010a2c:	3b01      	subs	r3, #1
 8010a2e:	930a      	str	r3, [sp, #40]	; 0x28
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8010a30:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8010a32:	2b00      	cmp	r3, #0
 8010a34:	d1ee      	bne.n	8010a14 <chvprintf+0x424>
      streamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
 8010a36:	e5e2      	b.n	80105fe <chvprintf+0xe>
}
 8010a38:	4618      	mov	r0, r3
 8010a3a:	b011      	add	sp, #68	; 0x44
 8010a3c:	f85d fb04 	ldr.w	pc, [sp], #4
 8010a40:	08016eb0 	.word	0x08016eb0
 8010a44:	f3af 8000 	nop.w
 8010a48:	f3af 8000 	nop.w
 8010a4c:	f3af 8000 	nop.w

08010a50 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8010a50:	b40e      	push	{r1, r2, r3}
 8010a52:	b500      	push	{lr}
 8010a54:	b084      	sub	sp, #16
 8010a56:	9001      	str	r0, [sp, #4]
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8010a58:	ab06      	add	r3, sp, #24
 8010a5a:	9302      	str	r3, [sp, #8]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8010a5c:	9801      	ldr	r0, [sp, #4]
 8010a5e:	9905      	ldr	r1, [sp, #20]
 8010a60:	9a02      	ldr	r2, [sp, #8]
 8010a62:	f7ff fdc5 	bl	80105f0 <chvprintf>
 8010a66:	9003      	str	r0, [sp, #12]
  va_end(ap);

  return formatted_bytes;
 8010a68:	9b03      	ldr	r3, [sp, #12]
}
 8010a6a:	4618      	mov	r0, r3
 8010a6c:	b004      	add	sp, #16
 8010a6e:	f85d eb04 	ldr.w	lr, [sp], #4
 8010a72:	b003      	add	sp, #12
 8010a74:	4770      	bx	lr
 8010a76:	bf00      	nop
 8010a78:	f3af 8000 	nop.w
 8010a7c:	f3af 8000 	nop.w

08010a80 <chsnprintf>:
 *                      terminating NUL byte) that would have been
 *                      stored in @p str if there was room.
 *
 * @api
 */
int chsnprintf(char *str, size_t size, const char *fmt, ...) {
 8010a80:	b40c      	push	{r2, r3}
 8010a82:	b500      	push	{lr}
 8010a84:	b08d      	sub	sp, #52	; 0x34
 8010a86:	9001      	str	r0, [sp, #4]
 8010a88:	9100      	str	r1, [sp, #0]
  MemoryStream ms;
  BaseSequentialStream *chp;
  size_t size_wo_nul;
  int retval;

  if (size > 0)
 8010a8a:	9b00      	ldr	r3, [sp, #0]
 8010a8c:	2b00      	cmp	r3, #0
 8010a8e:	d003      	beq.n	8010a98 <chsnprintf+0x18>
    size_wo_nul = size - 1;
 8010a90:	9b00      	ldr	r3, [sp, #0]
 8010a92:	3b01      	subs	r3, #1
 8010a94:	930b      	str	r3, [sp, #44]	; 0x2c
 8010a96:	e001      	b.n	8010a9c <chsnprintf+0x1c>
  else
    size_wo_nul = 0;
 8010a98:	2300      	movs	r3, #0
 8010a9a:	930b      	str	r3, [sp, #44]	; 0x2c

  /* Memory stream object to be used as a string writer, reserving one
     byte for the final zero.*/
  msObjectInit(&ms, (uint8_t *)str, size_wo_nul, 0);
 8010a9c:	ab03      	add	r3, sp, #12
 8010a9e:	4618      	mov	r0, r3
 8010aa0:	9901      	ldr	r1, [sp, #4]
 8010aa2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8010aa4:	2300      	movs	r3, #0
 8010aa6:	f7ff fd2b 	bl	8010500 <msObjectInit>

  /* Performing the print operation using the common code.*/
  chp = (BaseSequentialStream *)(void *)&ms;
 8010aaa:	ab03      	add	r3, sp, #12
 8010aac:	930a      	str	r3, [sp, #40]	; 0x28
  va_start(ap, fmt);
 8010aae:	ab0f      	add	r3, sp, #60	; 0x3c
 8010ab0:	9308      	str	r3, [sp, #32]
  retval = chvprintf(chp, fmt, ap);
 8010ab2:	980a      	ldr	r0, [sp, #40]	; 0x28
 8010ab4:	990e      	ldr	r1, [sp, #56]	; 0x38
 8010ab6:	9a08      	ldr	r2, [sp, #32]
 8010ab8:	f7ff fd9a 	bl	80105f0 <chvprintf>
 8010abc:	9009      	str	r0, [sp, #36]	; 0x24
  va_end(ap);

  /* Terminate with a zero, unless size==0.*/
  if (ms.eos < size)
 8010abe:	9a06      	ldr	r2, [sp, #24]
 8010ac0:	9b00      	ldr	r3, [sp, #0]
 8010ac2:	429a      	cmp	r2, r3
 8010ac4:	d204      	bcs.n	8010ad0 <chsnprintf+0x50>
      str[ms.eos] = 0;
 8010ac6:	9b06      	ldr	r3, [sp, #24]
 8010ac8:	9a01      	ldr	r2, [sp, #4]
 8010aca:	4413      	add	r3, r2
 8010acc:	2200      	movs	r2, #0
 8010ace:	701a      	strb	r2, [r3, #0]

  /* Return number of bytes that would have been written.*/
  return retval;
 8010ad0:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
 8010ad2:	4618      	mov	r0, r3
 8010ad4:	b00d      	add	sp, #52	; 0x34
 8010ad6:	f85d eb04 	ldr.w	lr, [sp], #4
 8010ada:	b002      	add	sp, #8
 8010adc:	4770      	bx	lr
 8010ade:	bf00      	nop

08010ae0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8010ae0:	b082      	sub	sp, #8
 8010ae2:	2320      	movs	r3, #32
 8010ae4:	9301      	str	r3, [sp, #4]
 8010ae6:	9b01      	ldr	r3, [sp, #4]
 8010ae8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8010aec:	b002      	add	sp, #8
 8010aee:	4770      	bx	lr

08010af0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8010af0:	b082      	sub	sp, #8
 8010af2:	2300      	movs	r3, #0
 8010af4:	9301      	str	r3, [sp, #4]
 8010af6:	9b01      	ldr	r3, [sp, #4]
 8010af8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8010afc:	b002      	add	sp, #8
 8010afe:	4770      	bx	lr

08010b00 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8010b00:	b508      	push	{r3, lr}

  port_lock();
 8010b02:	f7ff ffed 	bl	8010ae0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8010b06:	bd08      	pop	{r3, pc}
 8010b08:	f3af 8000 	nop.w
 8010b0c:	f3af 8000 	nop.w

08010b10 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8010b10:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8010b12:	f7ff ffed 	bl	8010af0 <port_unlock>
}
 8010b16:	bd08      	pop	{r3, pc}
 8010b18:	f3af 8000 	nop.w
 8010b1c:	f3af 8000 	nop.w

08010b20 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 8010b20:	4b01      	ldr	r3, [pc, #4]	; (8010b28 <chVTGetSystemTimeX+0x8>)
 8010b22:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8010b24:	4618      	mov	r0, r3
 8010b26:	4770      	bx	lr
 8010b28:	20000d98 	.word	0x20000d98
 8010b2c:	f3af 8000 	nop.w

08010b30 <chVTGetSystemTime>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 8010b30:	b500      	push	{lr}
 8010b32:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 8010b34:	f7ff ffe4 	bl	8010b00 <chSysLock>
  systime = chVTGetSystemTimeX();
 8010b38:	f7ff fff2 	bl	8010b20 <chVTGetSystemTimeX>
 8010b3c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 8010b3e:	f7ff ffe7 	bl	8010b10 <chSysUnlock>

  return systime;
 8010b42:	9b01      	ldr	r3, [sp, #4]
}
 8010b44:	4618      	mov	r0, r3
 8010b46:	b003      	add	sp, #12
 8010b48:	f85d fb04 	ldr.w	pc, [sp], #4
 8010b4c:	f3af 8000 	nop.w

08010b50 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8010b50:	b082      	sub	sp, #8
 8010b52:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8010b54:	4b02      	ldr	r3, [pc, #8]	; (8010b60 <chRegSetThreadName+0x10>)
 8010b56:	699b      	ldr	r3, [r3, #24]
 8010b58:	9a01      	ldr	r2, [sp, #4]
 8010b5a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 8010b5c:	b002      	add	sp, #8
 8010b5e:	4770      	bx	lr
 8010b60:	20000d98 	.word	0x20000d98
 8010b64:	f3af 8000 	nop.w
 8010b68:	f3af 8000 	nop.w
 8010b6c:	f3af 8000 	nop.w

08010b70 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 8010b70:	b082      	sub	sp, #8
 8010b72:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 8010b74:	9b01      	ldr	r3, [sp, #4]
 8010b76:	9a01      	ldr	r2, [sp, #4]
 8010b78:	601a      	str	r2, [r3, #0]
}
 8010b7a:	b002      	add	sp, #8
 8010b7c:	4770      	bx	lr
 8010b7e:	bf00      	nop

08010b80 <chEvtBroadcastI>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {
 8010b80:	b500      	push	{lr}
 8010b82:	b083      	sub	sp, #12
 8010b84:	9001      	str	r0, [sp, #4]

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
 8010b86:	9801      	ldr	r0, [sp, #4]
 8010b88:	2100      	movs	r1, #0
 8010b8a:	f7f1 fd79 	bl	8002680 <chEvtBroadcastFlagsI>
}
 8010b8e:	b003      	add	sp, #12
 8010b90:	f85d fb04 	ldr.w	pc, [sp], #4
 8010b94:	f3af 8000 	nop.w
 8010b98:	f3af 8000 	nop.w
 8010b9c:	f3af 8000 	nop.w

08010ba0 <_strtok>:
/**
 * @brief   Shell termination event source.
 */
event_source_t shell_terminated;

static char *_strtok(char *str, const char *delim, char **saveptr) {
 8010ba0:	b500      	push	{lr}
 8010ba2:	b087      	sub	sp, #28
 8010ba4:	9003      	str	r0, [sp, #12]
 8010ba6:	9102      	str	r1, [sp, #8]
 8010ba8:	9201      	str	r2, [sp, #4]
  char *token;
  if (str)
 8010baa:	9b03      	ldr	r3, [sp, #12]
 8010bac:	2b00      	cmp	r3, #0
 8010bae:	d002      	beq.n	8010bb6 <_strtok+0x16>
    *saveptr = str;
 8010bb0:	9b01      	ldr	r3, [sp, #4]
 8010bb2:	9a03      	ldr	r2, [sp, #12]
 8010bb4:	601a      	str	r2, [r3, #0]
  token = *saveptr;
 8010bb6:	9b01      	ldr	r3, [sp, #4]
 8010bb8:	681b      	ldr	r3, [r3, #0]
 8010bba:	9305      	str	r3, [sp, #20]

  if (!token)
 8010bbc:	9b05      	ldr	r3, [sp, #20]
 8010bbe:	2b00      	cmp	r3, #0
 8010bc0:	d101      	bne.n	8010bc6 <_strtok+0x26>
    return NULL;
 8010bc2:	2300      	movs	r3, #0
 8010bc4:	e020      	b.n	8010c08 <_strtok+0x68>

  token += strspn(token, delim);
 8010bc6:	9805      	ldr	r0, [sp, #20]
 8010bc8:	9902      	ldr	r1, [sp, #8]
 8010bca:	f005 f941 	bl	8015e50 <strspn>
 8010bce:	4603      	mov	r3, r0
 8010bd0:	9a05      	ldr	r2, [sp, #20]
 8010bd2:	4413      	add	r3, r2
 8010bd4:	9305      	str	r3, [sp, #20]
  *saveptr = strpbrk(token, delim);
 8010bd6:	9805      	ldr	r0, [sp, #20]
 8010bd8:	9902      	ldr	r1, [sp, #8]
 8010bda:	f005 f911 	bl	8015e00 <strpbrk>
 8010bde:	4602      	mov	r2, r0
 8010be0:	9b01      	ldr	r3, [sp, #4]
 8010be2:	601a      	str	r2, [r3, #0]
  if (*saveptr)
 8010be4:	9b01      	ldr	r3, [sp, #4]
 8010be6:	681b      	ldr	r3, [r3, #0]
 8010be8:	2b00      	cmp	r3, #0
 8010bea:	d006      	beq.n	8010bfa <_strtok+0x5a>
    *(*saveptr)++ = '\0';
 8010bec:	9b01      	ldr	r3, [sp, #4]
 8010bee:	681b      	ldr	r3, [r3, #0]
 8010bf0:	1c59      	adds	r1, r3, #1
 8010bf2:	9a01      	ldr	r2, [sp, #4]
 8010bf4:	6011      	str	r1, [r2, #0]
 8010bf6:	2200      	movs	r2, #0
 8010bf8:	701a      	strb	r2, [r3, #0]

  return *token ? token : NULL;
 8010bfa:	9b05      	ldr	r3, [sp, #20]
 8010bfc:	781b      	ldrb	r3, [r3, #0]
 8010bfe:	2b00      	cmp	r3, #0
 8010c00:	d001      	beq.n	8010c06 <_strtok+0x66>
 8010c02:	9b05      	ldr	r3, [sp, #20]
 8010c04:	e000      	b.n	8010c08 <_strtok+0x68>
 8010c06:	2300      	movs	r3, #0
}
 8010c08:	4618      	mov	r0, r3
 8010c0a:	b007      	add	sp, #28
 8010c0c:	f85d fb04 	ldr.w	pc, [sp], #4

08010c10 <usage>:

static void usage(BaseSequentialStream *chp, char *p) {
 8010c10:	b500      	push	{lr}
 8010c12:	b083      	sub	sp, #12
 8010c14:	9001      	str	r0, [sp, #4]
 8010c16:	9100      	str	r1, [sp, #0]

  chprintf(chp, "Usage: %s\r\n", p);
 8010c18:	9801      	ldr	r0, [sp, #4]
 8010c1a:	4903      	ldr	r1, [pc, #12]	; (8010c28 <usage+0x18>)
 8010c1c:	9a00      	ldr	r2, [sp, #0]
 8010c1e:	f7ff ff17 	bl	8010a50 <chprintf>
}
 8010c22:	b003      	add	sp, #12
 8010c24:	f85d fb04 	ldr.w	pc, [sp], #4
 8010c28:	08016ec0 	.word	0x08016ec0
 8010c2c:	f3af 8000 	nop.w

08010c30 <list_commands>:

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {
 8010c30:	b500      	push	{lr}
 8010c32:	b083      	sub	sp, #12
 8010c34:	9001      	str	r0, [sp, #4]
 8010c36:	9100      	str	r1, [sp, #0]

  while (scp->sc_name != NULL) {
 8010c38:	e009      	b.n	8010c4e <list_commands+0x1e>
    chprintf(chp, "%s ", scp->sc_name);
 8010c3a:	9b00      	ldr	r3, [sp, #0]
 8010c3c:	681b      	ldr	r3, [r3, #0]
 8010c3e:	9801      	ldr	r0, [sp, #4]
 8010c40:	4906      	ldr	r1, [pc, #24]	; (8010c5c <list_commands+0x2c>)
 8010c42:	461a      	mov	r2, r3
 8010c44:	f7ff ff04 	bl	8010a50 <chprintf>
    scp++;
 8010c48:	9b00      	ldr	r3, [sp, #0]
 8010c4a:	3308      	adds	r3, #8
 8010c4c:	9300      	str	r3, [sp, #0]
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 8010c4e:	9b00      	ldr	r3, [sp, #0]
 8010c50:	681b      	ldr	r3, [r3, #0]
 8010c52:	2b00      	cmp	r3, #0
 8010c54:	d1f1      	bne.n	8010c3a <list_commands+0xa>
    chprintf(chp, "%s ", scp->sc_name);
    scp++;
  }
}
 8010c56:	b003      	add	sp, #12
 8010c58:	f85d fb04 	ldr.w	pc, [sp], #4
 8010c5c:	08016ecc 	.word	0x08016ecc

08010c60 <cmd_info>:

static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 8010c60:	b500      	push	{lr}
 8010c62:	b087      	sub	sp, #28
 8010c64:	9005      	str	r0, [sp, #20]
 8010c66:	9104      	str	r1, [sp, #16]
 8010c68:	9203      	str	r2, [sp, #12]

  (void)argv;
  if (argc > 0) {
 8010c6a:	9b04      	ldr	r3, [sp, #16]
 8010c6c:	2b00      	cmp	r3, #0
 8010c6e:	dd04      	ble.n	8010c7a <cmd_info+0x1a>
    usage(chp, "info");
 8010c70:	9805      	ldr	r0, [sp, #20]
 8010c72:	4919      	ldr	r1, [pc, #100]	; (8010cd8 <cmd_info+0x78>)
 8010c74:	f7ff ffcc 	bl	8010c10 <usage>
    return;
 8010c78:	e02a      	b.n	8010cd0 <cmd_info+0x70>
  }

  chprintf(chp, "Kernel:       %s\r\n", CH_KERNEL_VERSION);
 8010c7a:	9805      	ldr	r0, [sp, #20]
 8010c7c:	4917      	ldr	r1, [pc, #92]	; (8010cdc <cmd_info+0x7c>)
 8010c7e:	4a18      	ldr	r2, [pc, #96]	; (8010ce0 <cmd_info+0x80>)
 8010c80:	f7ff fee6 	bl	8010a50 <chprintf>
#ifdef PORT_COMPILER_NAME
  chprintf(chp, "Compiler:     %s\r\n", PORT_COMPILER_NAME);
 8010c84:	9805      	ldr	r0, [sp, #20]
 8010c86:	4917      	ldr	r1, [pc, #92]	; (8010ce4 <cmd_info+0x84>)
 8010c88:	4a17      	ldr	r2, [pc, #92]	; (8010ce8 <cmd_info+0x88>)
 8010c8a:	f7ff fee1 	bl	8010a50 <chprintf>
#endif
  chprintf(chp, "Architecture: %s\r\n", PORT_ARCHITECTURE_NAME);
 8010c8e:	9805      	ldr	r0, [sp, #20]
 8010c90:	4916      	ldr	r1, [pc, #88]	; (8010cec <cmd_info+0x8c>)
 8010c92:	4a17      	ldr	r2, [pc, #92]	; (8010cf0 <cmd_info+0x90>)
 8010c94:	f7ff fedc 	bl	8010a50 <chprintf>
#ifdef PORT_CORE_VARIANT_NAME
  chprintf(chp, "Core Variant: %s\r\n", PORT_CORE_VARIANT_NAME);
 8010c98:	9805      	ldr	r0, [sp, #20]
 8010c9a:	4916      	ldr	r1, [pc, #88]	; (8010cf4 <cmd_info+0x94>)
 8010c9c:	4a16      	ldr	r2, [pc, #88]	; (8010cf8 <cmd_info+0x98>)
 8010c9e:	f7ff fed7 	bl	8010a50 <chprintf>
#endif
#ifdef PORT_INFO
  chprintf(chp, "Port Info:    %s\r\n", PORT_INFO);
 8010ca2:	9805      	ldr	r0, [sp, #20]
 8010ca4:	4915      	ldr	r1, [pc, #84]	; (8010cfc <cmd_info+0x9c>)
 8010ca6:	4a16      	ldr	r2, [pc, #88]	; (8010d00 <cmd_info+0xa0>)
 8010ca8:	f7ff fed2 	bl	8010a50 <chprintf>
#endif
#ifdef PLATFORM_NAME
  chprintf(chp, "Platform:     %s\r\n", PLATFORM_NAME);
 8010cac:	9805      	ldr	r0, [sp, #20]
 8010cae:	4915      	ldr	r1, [pc, #84]	; (8010d04 <cmd_info+0xa4>)
 8010cb0:	4a15      	ldr	r2, [pc, #84]	; (8010d08 <cmd_info+0xa8>)
 8010cb2:	f7ff fecd 	bl	8010a50 <chprintf>
#endif
#ifdef BOARD_NAME
  chprintf(chp, "Board:        %s\r\n", BOARD_NAME);
 8010cb6:	9805      	ldr	r0, [sp, #20]
 8010cb8:	4914      	ldr	r1, [pc, #80]	; (8010d0c <cmd_info+0xac>)
 8010cba:	4a15      	ldr	r2, [pc, #84]	; (8010d10 <cmd_info+0xb0>)
 8010cbc:	f7ff fec8 	bl	8010a50 <chprintf>
#endif
#ifdef __DATE__
#ifdef __TIME__
  chprintf(chp, "Build time:   %s%s%s\r\n", __DATE__, " - ", __TIME__);
 8010cc0:	4b14      	ldr	r3, [pc, #80]	; (8010d14 <cmd_info+0xb4>)
 8010cc2:	9300      	str	r3, [sp, #0]
 8010cc4:	9805      	ldr	r0, [sp, #20]
 8010cc6:	4914      	ldr	r1, [pc, #80]	; (8010d18 <cmd_info+0xb8>)
 8010cc8:	4a14      	ldr	r2, [pc, #80]	; (8010d1c <cmd_info+0xbc>)
 8010cca:	4b15      	ldr	r3, [pc, #84]	; (8010d20 <cmd_info+0xc0>)
 8010ccc:	f7ff fec0 	bl	8010a50 <chprintf>
#endif
#endif
}
 8010cd0:	b007      	add	sp, #28
 8010cd2:	f85d fb04 	ldr.w	pc, [sp], #4
 8010cd6:	bf00      	nop
 8010cd8:	08016ed0 	.word	0x08016ed0
 8010cdc:	08016ed8 	.word	0x08016ed8
 8010ce0:	08016eec 	.word	0x08016eec
 8010ce4:	08016ef4 	.word	0x08016ef4
 8010ce8:	08016f08 	.word	0x08016f08
 8010cec:	08016f50 	.word	0x08016f50
 8010cf0:	08016f64 	.word	0x08016f64
 8010cf4:	08016f70 	.word	0x08016f70
 8010cf8:	08016f84 	.word	0x08016f84
 8010cfc:	08016f90 	.word	0x08016f90
 8010d00:	08016fa4 	.word	0x08016fa4
 8010d04:	08016fbc 	.word	0x08016fbc
 8010d08:	08016fd0 	.word	0x08016fd0
 8010d0c:	08016fec 	.word	0x08016fec
 8010d10:	08017000 	.word	0x08017000
 8010d14:	08017038 	.word	0x08017038
 8010d18:	08017010 	.word	0x08017010
 8010d1c:	08017028 	.word	0x08017028
 8010d20:	08017034 	.word	0x08017034
 8010d24:	f3af 8000 	nop.w
 8010d28:	f3af 8000 	nop.w
 8010d2c:	f3af 8000 	nop.w

08010d30 <cmd_systime>:

static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {
 8010d30:	b500      	push	{lr}
 8010d32:	b085      	sub	sp, #20
 8010d34:	9003      	str	r0, [sp, #12]
 8010d36:	9102      	str	r1, [sp, #8]
 8010d38:	9201      	str	r2, [sp, #4]

  (void)argv;
  if (argc > 0) {
 8010d3a:	9b02      	ldr	r3, [sp, #8]
 8010d3c:	2b00      	cmp	r3, #0
 8010d3e:	dd04      	ble.n	8010d4a <cmd_systime+0x1a>
    usage(chp, "systime");
 8010d40:	9803      	ldr	r0, [sp, #12]
 8010d42:	4907      	ldr	r1, [pc, #28]	; (8010d60 <cmd_systime+0x30>)
 8010d44:	f7ff ff64 	bl	8010c10 <usage>
    return;
 8010d48:	e007      	b.n	8010d5a <cmd_systime+0x2a>
  }
  chprintf(chp, "%lu\r\n", (unsigned long)chVTGetSystemTime());
 8010d4a:	f7ff fef1 	bl	8010b30 <chVTGetSystemTime>
 8010d4e:	4603      	mov	r3, r0
 8010d50:	9803      	ldr	r0, [sp, #12]
 8010d52:	4904      	ldr	r1, [pc, #16]	; (8010d64 <cmd_systime+0x34>)
 8010d54:	461a      	mov	r2, r3
 8010d56:	f7ff fe7b 	bl	8010a50 <chprintf>
}
 8010d5a:	b005      	add	sp, #20
 8010d5c:	f85d fb04 	ldr.w	pc, [sp], #4
 8010d60:	08017044 	.word	0x08017044
 8010d64:	0801704c 	.word	0x0801704c
 8010d68:	f3af 8000 	nop.w
 8010d6c:	f3af 8000 	nop.w

08010d70 <cmdexec>:
  {"systime", cmd_systime},
  {NULL, NULL}
};

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {
 8010d70:	b500      	push	{lr}
 8010d72:	b085      	sub	sp, #20
 8010d74:	9003      	str	r0, [sp, #12]
 8010d76:	9102      	str	r1, [sp, #8]
 8010d78:	9201      	str	r2, [sp, #4]
 8010d7a:	9300      	str	r3, [sp, #0]

  while (scp->sc_name != NULL) {
 8010d7c:	e013      	b.n	8010da6 <cmdexec+0x36>
    if (strcmp(scp->sc_name, name) == 0) {
 8010d7e:	9b03      	ldr	r3, [sp, #12]
 8010d80:	681b      	ldr	r3, [r3, #0]
 8010d82:	4618      	mov	r0, r3
 8010d84:	9901      	ldr	r1, [sp, #4]
 8010d86:	f004 fedb 	bl	8015b40 <strcmp>
 8010d8a:	4603      	mov	r3, r0
 8010d8c:	2b00      	cmp	r3, #0
 8010d8e:	d107      	bne.n	8010da0 <cmdexec+0x30>
      scp->sc_function(chp, argc, argv);
 8010d90:	9b03      	ldr	r3, [sp, #12]
 8010d92:	685b      	ldr	r3, [r3, #4]
 8010d94:	9802      	ldr	r0, [sp, #8]
 8010d96:	9900      	ldr	r1, [sp, #0]
 8010d98:	9a06      	ldr	r2, [sp, #24]
 8010d9a:	4798      	blx	r3
      return false;
 8010d9c:	2300      	movs	r3, #0
 8010d9e:	e007      	b.n	8010db0 <cmdexec+0x40>
    }
    scp++;
 8010da0:	9b03      	ldr	r3, [sp, #12]
 8010da2:	3308      	adds	r3, #8
 8010da4:	9303      	str	r3, [sp, #12]
};

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {

  while (scp->sc_name != NULL) {
 8010da6:	9b03      	ldr	r3, [sp, #12]
 8010da8:	681b      	ldr	r3, [r3, #0]
 8010daa:	2b00      	cmp	r3, #0
 8010dac:	d1e7      	bne.n	8010d7e <cmdexec+0xe>
      scp->sc_function(chp, argc, argv);
      return false;
    }
    scp++;
  }
  return true;
 8010dae:	2301      	movs	r3, #1
}
 8010db0:	4618      	mov	r0, r3
 8010db2:	b005      	add	sp, #20
 8010db4:	f85d fb04 	ldr.w	pc, [sp], #4
 8010db8:	f3af 8000 	nop.w
 8010dbc:	f3af 8000 	nop.w

08010dc0 <shell_thread>:
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
static THD_FUNCTION(shell_thread, p) {
 8010dc0:	b500      	push	{lr}
 8010dc2:	b0a1      	sub	sp, #132	; 0x84
 8010dc4:	9003      	str	r0, [sp, #12]
  int n;
  BaseSequentialStream *chp = ((ShellConfig *)p)->sc_channel;
 8010dc6:	9b03      	ldr	r3, [sp, #12]
 8010dc8:	681b      	ldr	r3, [r3, #0]
 8010dca:	931d      	str	r3, [sp, #116]	; 0x74
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
 8010dcc:	9b03      	ldr	r3, [sp, #12]
 8010dce:	685b      	ldr	r3, [r3, #4]
 8010dd0:	931c      	str	r3, [sp, #112]	; 0x70
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("shell");
 8010dd2:	4855      	ldr	r0, [pc, #340]	; (8010f28 <shell_thread+0x168>)
 8010dd4:	f7ff febc 	bl	8010b50 <chRegSetThreadName>
  chprintf(chp, "\r\nChibiOS/RT Shell\r\n");
 8010dd8:	981d      	ldr	r0, [sp, #116]	; 0x74
 8010dda:	4954      	ldr	r1, [pc, #336]	; (8010f2c <shell_thread+0x16c>)
 8010ddc:	f7ff fe38 	bl	8010a50 <chprintf>
  while (true) {
    chprintf(chp, "ch> ");
 8010de0:	981d      	ldr	r0, [sp, #116]	; 0x74
 8010de2:	4953      	ldr	r1, [pc, #332]	; (8010f30 <shell_thread+0x170>)
 8010de4:	f7ff fe34 	bl	8010a50 <chprintf>
    if (shellGetLine(chp, line, sizeof(line))) {
 8010de8:	ab0a      	add	r3, sp, #40	; 0x28
 8010dea:	981d      	ldr	r0, [sp, #116]	; 0x74
 8010dec:	4619      	mov	r1, r3
 8010dee:	2240      	movs	r2, #64	; 0x40
 8010df0:	f000 f8fe 	bl	8010ff0 <shellGetLine>
 8010df4:	4603      	mov	r3, r0
 8010df6:	2b00      	cmp	r3, #0
 8010df8:	d004      	beq.n	8010e04 <shell_thread+0x44>
      chprintf(chp, "\r\nlogout");
 8010dfa:	981d      	ldr	r0, [sp, #116]	; 0x74
 8010dfc:	494d      	ldr	r1, [pc, #308]	; (8010f34 <shell_thread+0x174>)
 8010dfe:	f7ff fe27 	bl	8010a50 <chprintf>
      break;
 8010e02:	e08a      	b.n	8010f1a <shell_thread+0x15a>
    }
    lp = _strtok(line, " \t", &tokp);
 8010e04:	aa0a      	add	r2, sp, #40	; 0x28
 8010e06:	ab1a      	add	r3, sp, #104	; 0x68
 8010e08:	4610      	mov	r0, r2
 8010e0a:	494b      	ldr	r1, [pc, #300]	; (8010f38 <shell_thread+0x178>)
 8010e0c:	461a      	mov	r2, r3
 8010e0e:	f7ff fec7 	bl	8010ba0 <_strtok>
 8010e12:	901b      	str	r0, [sp, #108]	; 0x6c
    cmd = lp;
 8010e14:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010e16:	931e      	str	r3, [sp, #120]	; 0x78
    n = 0;
 8010e18:	2300      	movs	r3, #0
 8010e1a:	931f      	str	r3, [sp, #124]	; 0x7c
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 8010e1c:	e012      	b.n	8010e44 <shell_thread+0x84>
      if (n >= SHELL_MAX_ARGUMENTS) {
 8010e1e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8010e20:	2b03      	cmp	r3, #3
 8010e22:	dd06      	ble.n	8010e32 <shell_thread+0x72>
        chprintf(chp, "too many arguments\r\n");
 8010e24:	981d      	ldr	r0, [sp, #116]	; 0x74
 8010e26:	4945      	ldr	r1, [pc, #276]	; (8010f3c <shell_thread+0x17c>)
 8010e28:	f7ff fe12 	bl	8010a50 <chprintf>
        cmd = NULL;
 8010e2c:	2300      	movs	r3, #0
 8010e2e:	931e      	str	r3, [sp, #120]	; 0x78
        break;
 8010e30:	e012      	b.n	8010e58 <shell_thread+0x98>
      }
      args[n++] = lp;
 8010e32:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8010e34:	1c5a      	adds	r2, r3, #1
 8010e36:	921f      	str	r2, [sp, #124]	; 0x7c
 8010e38:	009b      	lsls	r3, r3, #2
 8010e3a:	aa20      	add	r2, sp, #128	; 0x80
 8010e3c:	4413      	add	r3, r2
 8010e3e:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 8010e40:	f843 2c6c 	str.w	r2, [r3, #-108]
      break;
    }
    lp = _strtok(line, " \t", &tokp);
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 8010e44:	ab1a      	add	r3, sp, #104	; 0x68
 8010e46:	2000      	movs	r0, #0
 8010e48:	493b      	ldr	r1, [pc, #236]	; (8010f38 <shell_thread+0x178>)
 8010e4a:	461a      	mov	r2, r3
 8010e4c:	f7ff fea8 	bl	8010ba0 <_strtok>
 8010e50:	901b      	str	r0, [sp, #108]	; 0x6c
 8010e52:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8010e54:	2b00      	cmp	r3, #0
 8010e56:	d1e2      	bne.n	8010e1e <shell_thread+0x5e>
        cmd = NULL;
        break;
      }
      args[n++] = lp;
    }
    args[n] = NULL;
 8010e58:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8010e5a:	009b      	lsls	r3, r3, #2
 8010e5c:	aa20      	add	r2, sp, #128	; 0x80
 8010e5e:	4413      	add	r3, r2
 8010e60:	2200      	movs	r2, #0
 8010e62:	f843 2c6c 	str.w	r2, [r3, #-108]
    if (cmd != NULL) {
 8010e66:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8010e68:	2b00      	cmp	r3, #0
 8010e6a:	d055      	beq.n	8010f18 <shell_thread+0x158>
      if (strcmp(cmd, "exit") == 0) {
 8010e6c:	981e      	ldr	r0, [sp, #120]	; 0x78
 8010e6e:	4934      	ldr	r1, [pc, #208]	; (8010f40 <shell_thread+0x180>)
 8010e70:	f004 fe66 	bl	8015b40 <strcmp>
 8010e74:	4603      	mov	r3, r0
 8010e76:	2b00      	cmp	r3, #0
 8010e78:	d108      	bne.n	8010e8c <shell_thread+0xcc>
        if (n > 0) {
 8010e7a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8010e7c:	2b00      	cmp	r3, #0
 8010e7e:	dd04      	ble.n	8010e8a <shell_thread+0xca>
          usage(chp, "exit");
 8010e80:	981d      	ldr	r0, [sp, #116]	; 0x74
 8010e82:	492f      	ldr	r1, [pc, #188]	; (8010f40 <shell_thread+0x180>)
 8010e84:	f7ff fec4 	bl	8010c10 <usage>
          continue;
 8010e88:	e046      	b.n	8010f18 <shell_thread+0x158>
        }
        break;
 8010e8a:	e046      	b.n	8010f1a <shell_thread+0x15a>
      }
      else if (strcmp(cmd, "help") == 0) {
 8010e8c:	981e      	ldr	r0, [sp, #120]	; 0x78
 8010e8e:	492d      	ldr	r1, [pc, #180]	; (8010f44 <shell_thread+0x184>)
 8010e90:	f004 fe56 	bl	8015b40 <strcmp>
 8010e94:	4603      	mov	r3, r0
 8010e96:	2b00      	cmp	r3, #0
 8010e98:	d11b      	bne.n	8010ed2 <shell_thread+0x112>
        if (n > 0) {
 8010e9a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8010e9c:	2b00      	cmp	r3, #0
 8010e9e:	dd04      	ble.n	8010eaa <shell_thread+0xea>
          usage(chp, "help");
 8010ea0:	981d      	ldr	r0, [sp, #116]	; 0x74
 8010ea2:	4928      	ldr	r1, [pc, #160]	; (8010f44 <shell_thread+0x184>)
 8010ea4:	f7ff feb4 	bl	8010c10 <usage>
          continue;
 8010ea8:	e036      	b.n	8010f18 <shell_thread+0x158>
        }
        chprintf(chp, "Commands: help exit ");
 8010eaa:	981d      	ldr	r0, [sp, #116]	; 0x74
 8010eac:	4926      	ldr	r1, [pc, #152]	; (8010f48 <shell_thread+0x188>)
 8010eae:	f7ff fdcf 	bl	8010a50 <chprintf>
        list_commands(chp, local_commands);
 8010eb2:	981d      	ldr	r0, [sp, #116]	; 0x74
 8010eb4:	4925      	ldr	r1, [pc, #148]	; (8010f4c <shell_thread+0x18c>)
 8010eb6:	f7ff febb 	bl	8010c30 <list_commands>
        if (scp != NULL)
 8010eba:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8010ebc:	2b00      	cmp	r3, #0
 8010ebe:	d003      	beq.n	8010ec8 <shell_thread+0x108>
          list_commands(chp, scp);
 8010ec0:	981d      	ldr	r0, [sp, #116]	; 0x74
 8010ec2:	991c      	ldr	r1, [sp, #112]	; 0x70
 8010ec4:	f7ff feb4 	bl	8010c30 <list_commands>
        chprintf(chp, "\r\n");
 8010ec8:	981d      	ldr	r0, [sp, #116]	; 0x74
 8010eca:	4921      	ldr	r1, [pc, #132]	; (8010f50 <shell_thread+0x190>)
 8010ecc:	f7ff fdc0 	bl	8010a50 <chprintf>
 8010ed0:	e022      	b.n	8010f18 <shell_thread+0x158>
      }
      else if (cmdexec(local_commands, chp, cmd, n, args) &&
 8010ed2:	ab05      	add	r3, sp, #20
 8010ed4:	9300      	str	r3, [sp, #0]
 8010ed6:	481d      	ldr	r0, [pc, #116]	; (8010f4c <shell_thread+0x18c>)
 8010ed8:	991d      	ldr	r1, [sp, #116]	; 0x74
 8010eda:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 8010edc:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8010ede:	f7ff ff47 	bl	8010d70 <cmdexec>
 8010ee2:	4603      	mov	r3, r0
 8010ee4:	2b00      	cmp	r3, #0
 8010ee6:	d017      	beq.n	8010f18 <shell_thread+0x158>
 8010ee8:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8010eea:	2b00      	cmp	r3, #0
 8010eec:	d00a      	beq.n	8010f04 <shell_thread+0x144>
          ((scp == NULL) || cmdexec(scp, chp, cmd, n, args))) {
 8010eee:	ab05      	add	r3, sp, #20
 8010ef0:	9300      	str	r3, [sp, #0]
 8010ef2:	981c      	ldr	r0, [sp, #112]	; 0x70
 8010ef4:	991d      	ldr	r1, [sp, #116]	; 0x74
 8010ef6:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 8010ef8:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8010efa:	f7ff ff39 	bl	8010d70 <cmdexec>
 8010efe:	4603      	mov	r3, r0
 8010f00:	2b00      	cmp	r3, #0
 8010f02:	d009      	beq.n	8010f18 <shell_thread+0x158>
        chprintf(chp, "%s", cmd);
 8010f04:	981d      	ldr	r0, [sp, #116]	; 0x74
 8010f06:	4913      	ldr	r1, [pc, #76]	; (8010f54 <shell_thread+0x194>)
 8010f08:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 8010f0a:	f7ff fda1 	bl	8010a50 <chprintf>
        chprintf(chp, " ?\r\n");
 8010f0e:	981d      	ldr	r0, [sp, #116]	; 0x74
 8010f10:	4911      	ldr	r1, [pc, #68]	; (8010f58 <shell_thread+0x198>)
 8010f12:	f7ff fd9d 	bl	8010a50 <chprintf>
      }
    }
  }
 8010f16:	e763      	b.n	8010de0 <shell_thread+0x20>
 8010f18:	e762      	b.n	8010de0 <shell_thread+0x20>
  shellExit(MSG_OK);
 8010f1a:	2000      	movs	r0, #0
 8010f1c:	f000 f828 	bl	8010f70 <shellExit>
}
 8010f20:	b021      	add	sp, #132	; 0x84
 8010f22:	f85d fb04 	ldr.w	pc, [sp], #4
 8010f26:	bf00      	nop
 8010f28:	0801706c 	.word	0x0801706c
 8010f2c:	08017074 	.word	0x08017074
 8010f30:	0801708c 	.word	0x0801708c
 8010f34:	08017094 	.word	0x08017094
 8010f38:	080170a0 	.word	0x080170a0
 8010f3c:	080170a4 	.word	0x080170a4
 8010f40:	080170bc 	.word	0x080170bc
 8010f44:	080170c4 	.word	0x080170c4
 8010f48:	080170cc 	.word	0x080170cc
 8010f4c:	08017054 	.word	0x08017054
 8010f50:	080170e4 	.word	0x080170e4
 8010f54:	080170e8 	.word	0x080170e8
 8010f58:	080170ec 	.word	0x080170ec
 8010f5c:	f3af 8000 	nop.w

08010f60 <shellInit>:
/**
 * @brief   Shell manager initialization.
 *
 * @api
 */
void shellInit(void) {
 8010f60:	b508      	push	{r3, lr}

  chEvtObjectInit(&shell_terminated);
 8010f62:	4802      	ldr	r0, [pc, #8]	; (8010f6c <shellInit+0xc>)
 8010f64:	f7ff fe04 	bl	8010b70 <chEvtObjectInit>
}
 8010f68:	bd08      	pop	{r3, pc}
 8010f6a:	bf00      	nop
 8010f6c:	200018a0 	.word	0x200018a0

08010f70 <shellExit>:
 *
 * @param[in] msg       shell exit code
 *
 * @api
 */
void shellExit(msg_t msg) {
 8010f70:	b500      	push	{lr}
 8010f72:	b083      	sub	sp, #12
 8010f74:	9001      	str	r0, [sp, #4]

  /* Atomically broadcasting the event source and terminating the thread,
     there is not a chSysUnlock() because the thread terminates upon return.*/
  chSysLock();
 8010f76:	f7ff fdc3 	bl	8010b00 <chSysLock>
  chEvtBroadcastI(&shell_terminated);
 8010f7a:	4804      	ldr	r0, [pc, #16]	; (8010f8c <shellExit+0x1c>)
 8010f7c:	f7ff fe00 	bl	8010b80 <chEvtBroadcastI>
  chThdExitS(msg);
 8010f80:	9801      	ldr	r0, [sp, #4]
 8010f82:	f7f0 fa05 	bl	8001390 <chThdExitS>
}
 8010f86:	b003      	add	sp, #12
 8010f88:	f85d fb04 	ldr.w	pc, [sp], #4
 8010f8c:	200018a0 	.word	0x200018a0

08010f90 <shellCreate>:
 * @retval NULL         thread creation failed because memory allocation.
 *
 * @api
 */
#if CH_CFG_USE_HEAP && CH_CFG_USE_DYNAMIC
thread_t *shellCreate(const ShellConfig *scp, size_t size, tprio_t prio) {
 8010f90:	b500      	push	{lr}
 8010f92:	b087      	sub	sp, #28
 8010f94:	9005      	str	r0, [sp, #20]
 8010f96:	9104      	str	r1, [sp, #16]
 8010f98:	9203      	str	r2, [sp, #12]

  return chThdCreateFromHeap(NULL, size, prio, shell_thread, (void *)scp);
 8010f9a:	9b05      	ldr	r3, [sp, #20]
 8010f9c:	9300      	str	r3, [sp, #0]
 8010f9e:	2000      	movs	r0, #0
 8010fa0:	9904      	ldr	r1, [sp, #16]
 8010fa2:	9a03      	ldr	r2, [sp, #12]
 8010fa4:	4b03      	ldr	r3, [pc, #12]	; (8010fb4 <shellCreate+0x24>)
 8010fa6:	f7f0 fc53 	bl	8001850 <chThdCreateFromHeap>
 8010faa:	4603      	mov	r3, r0
}
 8010fac:	4618      	mov	r0, r3
 8010fae:	b007      	add	sp, #28
 8010fb0:	f85d fb04 	ldr.w	pc, [sp], #4
 8010fb4:	08010dc1 	.word	0x08010dc1
 8010fb8:	f3af 8000 	nop.w
 8010fbc:	f3af 8000 	nop.w

08010fc0 <shellCreateStatic>:
 * @return              A pointer to the shell thread.
 *
 * @api
 */
thread_t *shellCreateStatic(const ShellConfig *scp, void *wsp,
                            size_t size, tprio_t prio) {
 8010fc0:	b500      	push	{lr}
 8010fc2:	b087      	sub	sp, #28
 8010fc4:	9005      	str	r0, [sp, #20]
 8010fc6:	9104      	str	r1, [sp, #16]
 8010fc8:	9203      	str	r2, [sp, #12]
 8010fca:	9302      	str	r3, [sp, #8]

  return chThdCreateStatic(wsp, size, prio, shell_thread, (void *)scp);
 8010fcc:	9b05      	ldr	r3, [sp, #20]
 8010fce:	9300      	str	r3, [sp, #0]
 8010fd0:	9804      	ldr	r0, [sp, #16]
 8010fd2:	9903      	ldr	r1, [sp, #12]
 8010fd4:	9a02      	ldr	r2, [sp, #8]
 8010fd6:	4b04      	ldr	r3, [pc, #16]	; (8010fe8 <shellCreateStatic+0x28>)
 8010fd8:	f7f0 f902 	bl	80011e0 <chThdCreateStatic>
 8010fdc:	4603      	mov	r3, r0
}
 8010fde:	4618      	mov	r0, r3
 8010fe0:	b007      	add	sp, #28
 8010fe2:	f85d fb04 	ldr.w	pc, [sp], #4
 8010fe6:	bf00      	nop
 8010fe8:	08010dc1 	.word	0x08010dc1
 8010fec:	f3af 8000 	nop.w

08010ff0 <shellGetLine>:
 * @retval true         the channel was reset or CTRL-D pressed.
 * @retval false        operation successful.
 *
 * @api
 */
bool shellGetLine(BaseSequentialStream *chp, char *line, unsigned size) {
 8010ff0:	b500      	push	{lr}
 8010ff2:	b087      	sub	sp, #28
 8010ff4:	9003      	str	r0, [sp, #12]
 8010ff6:	9102      	str	r1, [sp, #8]
 8010ff8:	9201      	str	r2, [sp, #4]
  char *p = line;
 8010ffa:	9b02      	ldr	r3, [sp, #8]
 8010ffc:	9305      	str	r3, [sp, #20]

  while (true) {
    char c;

    if (chSequentialStreamRead(chp, (uint8_t *)&c, 1) == 0)
 8010ffe:	9b03      	ldr	r3, [sp, #12]
 8011000:	681b      	ldr	r3, [r3, #0]
 8011002:	685b      	ldr	r3, [r3, #4]
 8011004:	f10d 0213 	add.w	r2, sp, #19
 8011008:	9803      	ldr	r0, [sp, #12]
 801100a:	4611      	mov	r1, r2
 801100c:	2201      	movs	r2, #1
 801100e:	4798      	blx	r3
 8011010:	4603      	mov	r3, r0
 8011012:	2b00      	cmp	r3, #0
 8011014:	d101      	bne.n	801101a <shellGetLine+0x2a>
      return true;
 8011016:	2301      	movs	r3, #1
 8011018:	e055      	b.n	80110c6 <shellGetLine+0xd6>
    if (c == 4) {
 801101a:	f89d 3013 	ldrb.w	r3, [sp, #19]
 801101e:	2b04      	cmp	r3, #4
 8011020:	d105      	bne.n	801102e <shellGetLine+0x3e>
      chprintf(chp, "^D");
 8011022:	9803      	ldr	r0, [sp, #12]
 8011024:	492a      	ldr	r1, [pc, #168]	; (80110d0 <shellGetLine+0xe0>)
 8011026:	f7ff fd13 	bl	8010a50 <chprintf>
      return true;
 801102a:	2301      	movs	r3, #1
 801102c:	e04b      	b.n	80110c6 <shellGetLine+0xd6>
    }
    if ((c == 8) || (c == 127)) {
 801102e:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8011032:	2b08      	cmp	r3, #8
 8011034:	d003      	beq.n	801103e <shellGetLine+0x4e>
 8011036:	f89d 3013 	ldrb.w	r3, [sp, #19]
 801103a:	2b7f      	cmp	r3, #127	; 0x7f
 801103c:	d11a      	bne.n	8011074 <shellGetLine+0x84>
      if (p != line) {
 801103e:	9a05      	ldr	r2, [sp, #20]
 8011040:	9b02      	ldr	r3, [sp, #8]
 8011042:	429a      	cmp	r2, r3
 8011044:	d015      	beq.n	8011072 <shellGetLine+0x82>
        chSequentialStreamPut(chp, 0x08);
 8011046:	9b03      	ldr	r3, [sp, #12]
 8011048:	681b      	ldr	r3, [r3, #0]
 801104a:	689b      	ldr	r3, [r3, #8]
 801104c:	9803      	ldr	r0, [sp, #12]
 801104e:	2108      	movs	r1, #8
 8011050:	4798      	blx	r3
        chSequentialStreamPut(chp, 0x20);
 8011052:	9b03      	ldr	r3, [sp, #12]
 8011054:	681b      	ldr	r3, [r3, #0]
 8011056:	689b      	ldr	r3, [r3, #8]
 8011058:	9803      	ldr	r0, [sp, #12]
 801105a:	2120      	movs	r1, #32
 801105c:	4798      	blx	r3
        chSequentialStreamPut(chp, 0x08);
 801105e:	9b03      	ldr	r3, [sp, #12]
 8011060:	681b      	ldr	r3, [r3, #0]
 8011062:	689b      	ldr	r3, [r3, #8]
 8011064:	9803      	ldr	r0, [sp, #12]
 8011066:	2108      	movs	r1, #8
 8011068:	4798      	blx	r3
        p--;
 801106a:	9b05      	ldr	r3, [sp, #20]
 801106c:	3b01      	subs	r3, #1
 801106e:	9305      	str	r3, [sp, #20]
      }
      continue;
 8011070:	e028      	b.n	80110c4 <shellGetLine+0xd4>
 8011072:	e027      	b.n	80110c4 <shellGetLine+0xd4>
    }
    if (c == '\r') {
 8011074:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8011078:	2b0d      	cmp	r3, #13
 801107a:	d108      	bne.n	801108e <shellGetLine+0x9e>
      chprintf(chp, "\r\n");
 801107c:	9803      	ldr	r0, [sp, #12]
 801107e:	4915      	ldr	r1, [pc, #84]	; (80110d4 <shellGetLine+0xe4>)
 8011080:	f7ff fce6 	bl	8010a50 <chprintf>
      *p = 0;
 8011084:	9b05      	ldr	r3, [sp, #20]
 8011086:	2200      	movs	r2, #0
 8011088:	701a      	strb	r2, [r3, #0]
      return false;
 801108a:	2300      	movs	r3, #0
 801108c:	e01b      	b.n	80110c6 <shellGetLine+0xd6>
    }
    if (c < 0x20)
 801108e:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8011092:	2b1f      	cmp	r3, #31
 8011094:	d800      	bhi.n	8011098 <shellGetLine+0xa8>
      continue;
 8011096:	e015      	b.n	80110c4 <shellGetLine+0xd4>
    if (p < line + size - 1) {
 8011098:	9b01      	ldr	r3, [sp, #4]
 801109a:	3b01      	subs	r3, #1
 801109c:	9a02      	ldr	r2, [sp, #8]
 801109e:	441a      	add	r2, r3
 80110a0:	9b05      	ldr	r3, [sp, #20]
 80110a2:	429a      	cmp	r2, r3
 80110a4:	d90e      	bls.n	80110c4 <shellGetLine+0xd4>
      chSequentialStreamPut(chp, c);
 80110a6:	9b03      	ldr	r3, [sp, #12]
 80110a8:	681b      	ldr	r3, [r3, #0]
 80110aa:	689b      	ldr	r3, [r3, #8]
 80110ac:	f89d 2013 	ldrb.w	r2, [sp, #19]
 80110b0:	9803      	ldr	r0, [sp, #12]
 80110b2:	4611      	mov	r1, r2
 80110b4:	4798      	blx	r3
      *p++ = (char)c;
 80110b6:	9b05      	ldr	r3, [sp, #20]
 80110b8:	1c5a      	adds	r2, r3, #1
 80110ba:	9205      	str	r2, [sp, #20]
 80110bc:	f89d 2013 	ldrb.w	r2, [sp, #19]
 80110c0:	701a      	strb	r2, [r3, #0]
    }
  }
 80110c2:	e79c      	b.n	8010ffe <shellGetLine+0xe>
 80110c4:	e79b      	b.n	8010ffe <shellGetLine+0xe>
}
 80110c6:	4618      	mov	r0, r3
 80110c8:	b007      	add	sp, #28
 80110ca:	f85d fb04 	ldr.w	pc, [sp], #4
 80110ce:	bf00      	nop
 80110d0:	080170f4 	.word	0x080170f4
 80110d4:	080170e4 	.word	0x080170e4
 80110d8:	f3af 8000 	nop.w
 80110dc:	f3af 8000 	nop.w

080110e0 <chThdTerminatedX>:
 * @retval true         thread terminated.
 * @retval false        thread not terminated.
 *
 * @xclass
 */
static inline bool chThdTerminatedX(thread_t *tp) {
 80110e0:	b082      	sub	sp, #8
 80110e2:	9001      	str	r0, [sp, #4]

  return (bool)(tp->p_state == CH_STATE_FINAL);
 80110e4:	9b01      	ldr	r3, [sp, #4]
 80110e6:	7f1b      	ldrb	r3, [r3, #28]
 80110e8:	2b0f      	cmp	r3, #15
 80110ea:	bf14      	ite	ne
 80110ec:	2300      	movne	r3, #0
 80110ee:	2301      	moveq	r3, #1
 80110f0:	b2db      	uxtb	r3, r3
}
 80110f2:	4618      	mov	r0, r3
 80110f4:	b002      	add	sp, #8
 80110f6:	4770      	bx	lr
 80110f8:	f3af 8000 	nop.w
 80110fc:	f3af 8000 	nop.w

08011100 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8011100:	b082      	sub	sp, #8
 8011102:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8011104:	4b02      	ldr	r3, [pc, #8]	; (8011110 <chRegSetThreadName+0x10>)
 8011106:	699b      	ldr	r3, [r3, #24]
 8011108:	9a01      	ldr	r2, [sp, #4]
 801110a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 801110c:	b002      	add	sp, #8
 801110e:	4770      	bx	lr
 8011110:	20000d98 	.word	0x20000d98
 8011114:	f3af 8000 	nop.w
 8011118:	f3af 8000 	nop.w
 801111c:	f3af 8000 	nop.w

08011120 <counterThread>:
#define UNUSED(x) (void)(x)
#define BOARD_LED LINE_SAI_SD

/* Thread that blinks North LED as an "alive" indicator */
static THD_WORKING_AREA(waCounterThread,128);
static THD_FUNCTION(counterThread,arg) {
 8011120:	b500      	push	{lr}
 8011122:	b083      	sub	sp, #12
 8011124:	9001      	str	r0, [sp, #4]
  UNUSED(arg);
  chRegSetThreadName("blinker");
 8011126:	480a      	ldr	r0, [pc, #40]	; (8011150 <counterThread+0x30>)
 8011128:	f7ff ffea 	bl	8011100 <chRegSetThreadName>
  while (TRUE) {
    palSetLine(BOARD_LED);   
 801112c:	4b09      	ldr	r3, [pc, #36]	; (8011154 <counterThread+0x34>)
 801112e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8011132:	831a      	strh	r2, [r3, #24]
    chThdSleepMilliseconds(500);
 8011134:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8011138:	f7f0 f8ca 	bl	80012d0 <chThdSleep>
    palClearLine(BOARD_LED);   
 801113c:	4b05      	ldr	r3, [pc, #20]	; (8011154 <counterThread+0x34>)
 801113e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8011142:	835a      	strh	r2, [r3, #26]
    chThdSleepMilliseconds(500);
 8011144:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8011148:	f7f0 f8c2 	bl	80012d0 <chThdSleep>
  }
 801114c:	e7ee      	b.n	801112c <counterThread+0xc>
 801114e:	bf00      	nop
 8011150:	08017100 	.word	0x08017100
 8011154:	48001800 	.word	0x48001800
 8011158:	f3af 8000 	nop.w
 801115c:	f3af 8000 	nop.w

08011160 <cmd_myecho>:
}

static void cmd_myecho(BaseSequentialStream *chp, int argc, char *argv[]) {
 8011160:	b500      	push	{lr}
 8011162:	b087      	sub	sp, #28
 8011164:	9003      	str	r0, [sp, #12]
 8011166:	9102      	str	r1, [sp, #8]
 8011168:	9201      	str	r2, [sp, #4]
  int32_t i;
  (void)argv;
  for (i=0;i<argc;i++) {
 801116a:	2300      	movs	r3, #0
 801116c:	9305      	str	r3, [sp, #20]
 801116e:	e00c      	b.n	801118a <cmd_myecho+0x2a>
    chprintf(chp, "%s\n\r", argv[i]);
 8011170:	9b05      	ldr	r3, [sp, #20]
 8011172:	009b      	lsls	r3, r3, #2
 8011174:	9a01      	ldr	r2, [sp, #4]
 8011176:	4413      	add	r3, r2
 8011178:	681b      	ldr	r3, [r3, #0]
 801117a:	9803      	ldr	r0, [sp, #12]
 801117c:	4906      	ldr	r1, [pc, #24]	; (8011198 <cmd_myecho+0x38>)
 801117e:	461a      	mov	r2, r3
 8011180:	f7ff fc66 	bl	8010a50 <chprintf>
}

static void cmd_myecho(BaseSequentialStream *chp, int argc, char *argv[]) {
  int32_t i;
  (void)argv;
  for (i=0;i<argc;i++) {
 8011184:	9b05      	ldr	r3, [sp, #20]
 8011186:	3301      	adds	r3, #1
 8011188:	9305      	str	r3, [sp, #20]
 801118a:	9a05      	ldr	r2, [sp, #20]
 801118c:	9b02      	ldr	r3, [sp, #8]
 801118e:	429a      	cmp	r2, r3
 8011190:	dbee      	blt.n	8011170 <cmd_myecho+0x10>
    chprintf(chp, "%s\n\r", argv[i]);
  }
}
 8011192:	b007      	add	sp, #28
 8011194:	f85d fb04 	ldr.w	pc, [sp], #4
 8011198:	08017108 	.word	0x08017108
 801119c:	f3af 8000 	nop.w

080111a0 <cmd_accel_wai>:

static void cmd_accel_wai(BaseSequentialStream *chp, int argc, char *argv[]) {
 80111a0:	b500      	push	{lr}
 80111a2:	b087      	sub	sp, #28
 80111a4:	9003      	str	r0, [sp, #12]
 80111a6:	9102      	str	r1, [sp, #8]
 80111a8:	9201      	str	r2, [sp, #4]
  uint8_t wai;
  (void)argv;
  (void)argc;

  LSM303AGR_ACC_R_WHO_AM_I(NULL, &wai);
 80111aa:	f10d 0317 	add.w	r3, sp, #23
 80111ae:	2000      	movs	r0, #0
 80111b0:	4619      	mov	r1, r3
 80111b2:	f000 f8c5 	bl	8011340 <LSM303AGR_ACC_R_WHO_AM_I>
  chprintf(chp,"lsm303 Who Am I data = 0x%02x\n\r",wai);
 80111b6:	f89d 3017 	ldrb.w	r3, [sp, #23]
 80111ba:	9803      	ldr	r0, [sp, #12]
 80111bc:	4903      	ldr	r1, [pc, #12]	; (80111cc <cmd_accel_wai+0x2c>)
 80111be:	461a      	mov	r2, r3
 80111c0:	f7ff fc46 	bl	8010a50 <chprintf>
}
 80111c4:	b007      	add	sp, #28
 80111c6:	f85d fb04 	ldr.w	pc, [sp], #4
 80111ca:	bf00      	nop
 80111cc:	08017110 	.word	0x08017110

080111d0 <main>:

/*
 * Application entry point.
 */

int main(void) {
 80111d0:	b500      	push	{lr}
 80111d2:	b083      	sub	sp, #12
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  static thread_t *shelltp = NULL;

  halInit();
 80111d4:	f7f2 fcfc 	bl	8003bd0 <halInit>
  chSysInit();
 80111d8:	f7ef fa62 	bl	80006a0 <chSysInit>

  /* Initialize the Accelerometer */
  LSM303AGR_ACC_Init();
 80111dc:	f000 f848 	bl	8011270 <LSM303AGR_ACC_Init>

  /*
   * Activates the serial driver 5 using the driver default configuration.
   * PC12(TX) and PD2(RX). The default baud rate is 38400.
   */
  sdStart(&SD5, NULL);
 80111e0:	481a      	ldr	r0, [pc, #104]	; (801124c <main+0x7c>)
 80111e2:	2100      	movs	r1, #0
 80111e4:	f7f4 fe3c 	bl	8005e60 <sdStart>
  chprintf((BaseSequentialStream*)&SD5, "\n\rUp and Running\n\r");
 80111e8:	4818      	ldr	r0, [pc, #96]	; (801124c <main+0x7c>)
 80111ea:	4919      	ldr	r1, [pc, #100]	; (8011250 <main+0x80>)
 80111ec:	f7ff fc30 	bl	8010a50 <chprintf>

  /* Initialize the command shell */ 
  shellInit();
 80111f0:	f7ff feb6 	bl	8010f60 <shellInit>
  chThdCreateStatic(waCounterThread, sizeof(waCounterThread), NORMALPRIO+1, counterThread, NULL);
 80111f4:	2300      	movs	r3, #0
 80111f6:	9300      	str	r3, [sp, #0]
 80111f8:	4816      	ldr	r0, [pc, #88]	; (8011254 <main+0x84>)
 80111fa:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80111fe:	2241      	movs	r2, #65	; 0x41
 8011200:	4b15      	ldr	r3, [pc, #84]	; (8011258 <main+0x88>)
 8011202:	f7ef ffed 	bl	80011e0 <chThdCreateStatic>

  while (TRUE) {
    if (!shelltp) {
 8011206:	4b15      	ldr	r3, [pc, #84]	; (801125c <main+0x8c>)
 8011208:	681b      	ldr	r3, [r3, #0]
 801120a:	2b00      	cmp	r3, #0
 801120c:	d109      	bne.n	8011222 <main+0x52>
      shelltp = shellCreate(&shell_cfg1, SHELL_WA_SIZE, NORMALPRIO);
 801120e:	4814      	ldr	r0, [pc, #80]	; (8011260 <main+0x90>)
 8011210:	f640 01c8 	movw	r1, #2248	; 0x8c8
 8011214:	2240      	movs	r2, #64	; 0x40
 8011216:	f7ff febb 	bl	8010f90 <shellCreate>
 801121a:	4602      	mov	r2, r0
 801121c:	4b0f      	ldr	r3, [pc, #60]	; (801125c <main+0x8c>)
 801121e:	601a      	str	r2, [r3, #0]
 8011220:	e00f      	b.n	8011242 <main+0x72>
    }
    else if (chThdTerminatedX(shelltp)) {
 8011222:	4b0e      	ldr	r3, [pc, #56]	; (801125c <main+0x8c>)
 8011224:	681b      	ldr	r3, [r3, #0]
 8011226:	4618      	mov	r0, r3
 8011228:	f7ff ff5a 	bl	80110e0 <chThdTerminatedX>
 801122c:	4603      	mov	r3, r0
 801122e:	2b00      	cmp	r3, #0
 8011230:	d007      	beq.n	8011242 <main+0x72>
      chThdRelease(shelltp);    /* Recovers memory of the previous shell.   */
 8011232:	4b0a      	ldr	r3, [pc, #40]	; (801125c <main+0x8c>)
 8011234:	681b      	ldr	r3, [r3, #0]
 8011236:	4618      	mov	r0, r3
 8011238:	f7f0 fac2 	bl	80017c0 <chThdRelease>
      shelltp = NULL;           /* Triggers spawning of a new shell.        */
 801123c:	4b07      	ldr	r3, [pc, #28]	; (801125c <main+0x8c>)
 801123e:	2200      	movs	r2, #0
 8011240:	601a      	str	r2, [r3, #0]
    }
    chThdSleepMilliseconds(1000);
 8011242:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8011246:	f7f0 f843 	bl	80012d0 <chThdSleep>
  }
 801124a:	e7dc      	b.n	8011206 <main+0x36>
 801124c:	200011a4 	.word	0x200011a4
 8011250:	08017164 	.word	0x08017164
 8011254:	20000c48 	.word	0x20000c48
 8011258:	08011121 	.word	0x08011121
 801125c:	20000d90 	.word	0x20000d90
 8011260:	0801715c 	.word	0x0801715c
 8011264:	f3af 8000 	nop.w
 8011268:	f3af 8000 	nop.w
 801126c:	f3af 8000 	nop.w

08011270 <LSM303AGR_ACC_Init>:
/************** Generic Function  *******************/


/* Enable 3 wire SPI mode on the LSM303AGR */

status_t LSM303AGR_ACC_Init(void) {
 8011270:	b500      	push	{lr}
 8011272:	b083      	sub	sp, #12
  uint8_t value = LSM303AGR_ACC_SIM_3_WIRES;
 8011274:	2301      	movs	r3, #1
 8011276:	f88d 3007 	strb.w	r3, [sp, #7]
  LSM303AGR_ACC_WriteReg(NULL,LSM303AGR_ACC_CTRL_REG4,&value,1);
 801127a:	f10d 0307 	add.w	r3, sp, #7
 801127e:	2000      	movs	r0, #0
 8011280:	2123      	movs	r1, #35	; 0x23
 8011282:	461a      	mov	r2, r3
 8011284:	2301      	movs	r3, #1
 8011286:	f000 f80b 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
  return MEMS_SUCCESS;
 801128a:	2301      	movs	r3, #1
}
 801128c:	4618      	mov	r0, r3
 801128e:	b003      	add	sp, #12
 8011290:	f85d fb04 	ldr.w	pc, [sp], #4
 8011294:	f3af 8000 	nop.w
 8011298:	f3af 8000 	nop.w
 801129c:	f3af 8000 	nop.w

080112a0 <LSM303AGR_ACC_WriteReg>:
* Input       : Register Address, ptr to buffer to be written,
*                                 length of buffer
* Output      : None
* Return      : None
*******************************************************************************/
status_t LSM303AGR_ACC_WriteReg(void *handle, u8_t Reg, u8_t *Bufp, u16_t len) {
 80112a0:	b500      	push	{lr}
 80112a2:	b087      	sub	sp, #28
 80112a4:	9005      	str	r0, [sp, #20]
 80112a6:	9203      	str	r2, [sp, #12]
 80112a8:	460a      	mov	r2, r1
 80112aa:	f88d 2013 	strb.w	r2, [sp, #19]
 80112ae:	f8ad 3010 	strh.w	r3, [sp, #16]
  UNUSED(handle);
  if (Sensor_IO_SPI_Write(&SENSOR_PORT, &lsm303ad_accel_cfg, Reg, Bufp, len))
 80112b2:	f89d 3013 	ldrb.w	r3, [sp, #19]
 80112b6:	f8bd 2010 	ldrh.w	r2, [sp, #16]
 80112ba:	9200      	str	r2, [sp, #0]
 80112bc:	4807      	ldr	r0, [pc, #28]	; (80112dc <LSM303AGR_ACC_WriteReg+0x3c>)
 80112be:	4908      	ldr	r1, [pc, #32]	; (80112e0 <LSM303AGR_ACC_WriteReg+0x40>)
 80112c0:	461a      	mov	r2, r3
 80112c2:	9b03      	ldr	r3, [sp, #12]
 80112c4:	f003 ffdc 	bl	8015280 <Sensor_IO_SPI_Write>
 80112c8:	4603      	mov	r3, r0
 80112ca:	2b00      	cmp	r3, #0
 80112cc:	d001      	beq.n	80112d2 <LSM303AGR_ACC_WriteReg+0x32>
  {
    return MEMS_ERROR;
 80112ce:	2300      	movs	r3, #0
 80112d0:	e000      	b.n	80112d4 <LSM303AGR_ACC_WriteReg+0x34>
  }
  else
  {
    return MEMS_SUCCESS;
 80112d2:	2301      	movs	r3, #1
  }
}
 80112d4:	4618      	mov	r0, r3
 80112d6:	b007      	add	sp, #28
 80112d8:	f85d fb04 	ldr.w	pc, [sp], #4
 80112dc:	20001174 	.word	0x20001174
 80112e0:	200008f0 	.word	0x200008f0
 80112e4:	f3af 8000 	nop.w
 80112e8:	f3af 8000 	nop.w
 80112ec:	f3af 8000 	nop.w

080112f0 <LSM303AGR_ACC_ReadReg>:
* Input       : Register Address, ptr to buffer to be read,
*                                 length of buffer
* Output      : None
* Return      : None
*******************************************************************************/
status_t LSM303AGR_ACC_ReadReg(void *handle, u8_t Reg, u8_t *Bufp, u16_t len) {
 80112f0:	b500      	push	{lr}
 80112f2:	b087      	sub	sp, #28
 80112f4:	9005      	str	r0, [sp, #20]
 80112f6:	9203      	str	r2, [sp, #12]
 80112f8:	460a      	mov	r2, r1
 80112fa:	f88d 2013 	strb.w	r2, [sp, #19]
 80112fe:	f8ad 3010 	strh.w	r3, [sp, #16]
  UNUSED(handle);
  if (Sensor_IO_SPI_Read(&SENSOR_PORT, &lsm303ad_accel_cfg, Reg, Bufp, len))
 8011302:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8011306:	f8bd 2010 	ldrh.w	r2, [sp, #16]
 801130a:	9200      	str	r2, [sp, #0]
 801130c:	4807      	ldr	r0, [pc, #28]	; (801132c <LSM303AGR_ACC_ReadReg+0x3c>)
 801130e:	4908      	ldr	r1, [pc, #32]	; (8011330 <LSM303AGR_ACC_ReadReg+0x40>)
 8011310:	461a      	mov	r2, r3
 8011312:	9b03      	ldr	r3, [sp, #12]
 8011314:	f004 f814 	bl	8015340 <Sensor_IO_SPI_Read>
 8011318:	4603      	mov	r3, r0
 801131a:	2b00      	cmp	r3, #0
 801131c:	d001      	beq.n	8011322 <LSM303AGR_ACC_ReadReg+0x32>
  {
    return MEMS_ERROR;
 801131e:	2300      	movs	r3, #0
 8011320:	e000      	b.n	8011324 <LSM303AGR_ACC_ReadReg+0x34>
  }
  else
  {
    return MEMS_SUCCESS;
 8011322:	2301      	movs	r3, #1
  }
}
 8011324:	4618      	mov	r0, r3
 8011326:	b007      	add	sp, #28
 8011328:	f85d fb04 	ldr.w	pc, [sp], #4
 801132c:	20001174 	.word	0x20001174
 8011330:	200008f0 	.word	0x200008f0
 8011334:	f3af 8000 	nop.w
 8011338:	f3af 8000 	nop.w
 801133c:	f3af 8000 	nop.w

08011340 <LSM303AGR_ACC_R_WHO_AM_I>:
* Input          : Pointer to u8_t
* Output         : Status of WHO_AM_I
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_WHO_AM_I(void *handle, u8_t *value)
{
 8011340:	b500      	push	{lr}
 8011342:	b083      	sub	sp, #12
 8011344:	9001      	str	r0, [sp, #4]
 8011346:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_WHO_AM_I_REG, value, 1) )
 8011348:	9801      	ldr	r0, [sp, #4]
 801134a:	210f      	movs	r1, #15
 801134c:	9a00      	ldr	r2, [sp, #0]
 801134e:	2301      	movs	r3, #1
 8011350:	f7ff ffce 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8011354:	4603      	mov	r3, r0
 8011356:	2b00      	cmp	r3, #0
 8011358:	d101      	bne.n	801135e <LSM303AGR_ACC_R_WHO_AM_I+0x1e>
    return MEMS_ERROR;
 801135a:	2300      	movs	r3, #0
 801135c:	e000      	b.n	8011360 <LSM303AGR_ACC_R_WHO_AM_I+0x20>

  /* *value &= LSM303AGR_ACC_WHO_AM_I_MASK; //coerce */
  /* *value = *value >> LSM303AGR_ACC_WHO_AM_I_POSITION; //mask */

  return MEMS_SUCCESS;
 801135e:	2301      	movs	r3, #1
}
 8011360:	4618      	mov	r0, r3
 8011362:	b003      	add	sp, #12
 8011364:	f85d fb04 	ldr.w	pc, [sp], #4
 8011368:	f3af 8000 	nop.w
 801136c:	f3af 8000 	nop.w

08011370 <LSM303AGR_ACC_W_BlockDataUpdate>:
* Input          : LSM303AGR_ACC_BDU_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_BlockDataUpdate(void *handle, LSM303AGR_ACC_BDU_t newValue)
{
 8011370:	b500      	push	{lr}
 8011372:	b085      	sub	sp, #20
 8011374:	9001      	str	r0, [sp, #4]
 8011376:	460b      	mov	r3, r1
 8011378:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 801137c:	f10d 030f 	add.w	r3, sp, #15
 8011380:	9801      	ldr	r0, [sp, #4]
 8011382:	2123      	movs	r1, #35	; 0x23
 8011384:	461a      	mov	r2, r3
 8011386:	2301      	movs	r3, #1
 8011388:	f7ff ffb2 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 801138c:	4603      	mov	r3, r0
 801138e:	2b00      	cmp	r3, #0
 8011390:	d101      	bne.n	8011396 <LSM303AGR_ACC_W_BlockDataUpdate+0x26>
    return MEMS_ERROR;
 8011392:	2300      	movs	r3, #0
 8011394:	e01c      	b.n	80113d0 <LSM303AGR_ACC_W_BlockDataUpdate+0x60>

  value &= ~LSM303AGR_ACC_BDU_MASK;
 8011396:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801139a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 801139e:	b2db      	uxtb	r3, r3
 80113a0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80113a4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80113a8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80113ac:	4313      	orrs	r3, r2
 80113ae:	b2db      	uxtb	r3, r3
 80113b0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 80113b4:	f10d 030f 	add.w	r3, sp, #15
 80113b8:	9801      	ldr	r0, [sp, #4]
 80113ba:	2123      	movs	r1, #35	; 0x23
 80113bc:	461a      	mov	r2, r3
 80113be:	2301      	movs	r3, #1
 80113c0:	f7ff ff6e 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 80113c4:	4603      	mov	r3, r0
 80113c6:	2b00      	cmp	r3, #0
 80113c8:	d101      	bne.n	80113ce <LSM303AGR_ACC_W_BlockDataUpdate+0x5e>
    return MEMS_ERROR;
 80113ca:	2300      	movs	r3, #0
 80113cc:	e000      	b.n	80113d0 <LSM303AGR_ACC_W_BlockDataUpdate+0x60>

  return MEMS_SUCCESS;
 80113ce:	2301      	movs	r3, #1
}
 80113d0:	4618      	mov	r0, r3
 80113d2:	b005      	add	sp, #20
 80113d4:	f85d fb04 	ldr.w	pc, [sp], #4
 80113d8:	f3af 8000 	nop.w
 80113dc:	f3af 8000 	nop.w

080113e0 <LSM303AGR_ACC_R_BlockDataUpdate>:
* Input          : Pointer to LSM303AGR_ACC_BDU_t
* Output         : Status of BDU see LSM303AGR_ACC_BDU_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_BlockDataUpdate(void *handle, LSM303AGR_ACC_BDU_t *value)
{
 80113e0:	b500      	push	{lr}
 80113e2:	b083      	sub	sp, #12
 80113e4:	9001      	str	r0, [sp, #4]
 80113e6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
 80113e8:	9801      	ldr	r0, [sp, #4]
 80113ea:	2123      	movs	r1, #35	; 0x23
 80113ec:	9a00      	ldr	r2, [sp, #0]
 80113ee:	2301      	movs	r3, #1
 80113f0:	f7ff ff7e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80113f4:	4603      	mov	r3, r0
 80113f6:	2b00      	cmp	r3, #0
 80113f8:	d101      	bne.n	80113fe <LSM303AGR_ACC_R_BlockDataUpdate+0x1e>
    return MEMS_ERROR;
 80113fa:	2300      	movs	r3, #0
 80113fc:	e007      	b.n	801140e <LSM303AGR_ACC_R_BlockDataUpdate+0x2e>

  *value &= LSM303AGR_ACC_BDU_MASK; //mask
 80113fe:	9b00      	ldr	r3, [sp, #0]
 8011400:	781b      	ldrb	r3, [r3, #0]
 8011402:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8011406:	b2da      	uxtb	r2, r3
 8011408:	9b00      	ldr	r3, [sp, #0]
 801140a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801140c:	2301      	movs	r3, #1
}
 801140e:	4618      	mov	r0, r3
 8011410:	b003      	add	sp, #12
 8011412:	f85d fb04 	ldr.w	pc, [sp], #4
 8011416:	bf00      	nop
 8011418:	f3af 8000 	nop.w
 801141c:	f3af 8000 	nop.w

08011420 <LSM303AGR_ACC_W_FullScale>:
* Input          : LSM303AGR_ACC_FS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FullScale(void *handle, LSM303AGR_ACC_FS_t newValue)
{
 8011420:	b500      	push	{lr}
 8011422:	b085      	sub	sp, #20
 8011424:	9001      	str	r0, [sp, #4]
 8011426:	460b      	mov	r3, r1
 8011428:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 801142c:	f10d 030f 	add.w	r3, sp, #15
 8011430:	9801      	ldr	r0, [sp, #4]
 8011432:	2123      	movs	r1, #35	; 0x23
 8011434:	461a      	mov	r2, r3
 8011436:	2301      	movs	r3, #1
 8011438:	f7ff ff5a 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 801143c:	4603      	mov	r3, r0
 801143e:	2b00      	cmp	r3, #0
 8011440:	d101      	bne.n	8011446 <LSM303AGR_ACC_W_FullScale+0x26>
    return MEMS_ERROR;
 8011442:	2300      	movs	r3, #0
 8011444:	e01c      	b.n	8011480 <LSM303AGR_ACC_W_FullScale+0x60>

  value &= ~LSM303AGR_ACC_FS_MASK;
 8011446:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801144a:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 801144e:	b2db      	uxtb	r3, r3
 8011450:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8011454:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8011458:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801145c:	4313      	orrs	r3, r2
 801145e:	b2db      	uxtb	r3, r3
 8011460:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 8011464:	f10d 030f 	add.w	r3, sp, #15
 8011468:	9801      	ldr	r0, [sp, #4]
 801146a:	2123      	movs	r1, #35	; 0x23
 801146c:	461a      	mov	r2, r3
 801146e:	2301      	movs	r3, #1
 8011470:	f7ff ff16 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8011474:	4603      	mov	r3, r0
 8011476:	2b00      	cmp	r3, #0
 8011478:	d101      	bne.n	801147e <LSM303AGR_ACC_W_FullScale+0x5e>
    return MEMS_ERROR;
 801147a:	2300      	movs	r3, #0
 801147c:	e000      	b.n	8011480 <LSM303AGR_ACC_W_FullScale+0x60>

  return MEMS_SUCCESS;
 801147e:	2301      	movs	r3, #1
}
 8011480:	4618      	mov	r0, r3
 8011482:	b005      	add	sp, #20
 8011484:	f85d fb04 	ldr.w	pc, [sp], #4
 8011488:	f3af 8000 	nop.w
 801148c:	f3af 8000 	nop.w

08011490 <LSM303AGR_ACC_R_FullScale>:
* Input          : Pointer to LSM303AGR_ACC_FS_t
* Output         : Status of FS see LSM303AGR_ACC_FS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FullScale(void *handle, LSM303AGR_ACC_FS_t *value)
{
 8011490:	b500      	push	{lr}
 8011492:	b083      	sub	sp, #12
 8011494:	9001      	str	r0, [sp, #4]
 8011496:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
 8011498:	9801      	ldr	r0, [sp, #4]
 801149a:	2123      	movs	r1, #35	; 0x23
 801149c:	9a00      	ldr	r2, [sp, #0]
 801149e:	2301      	movs	r3, #1
 80114a0:	f7ff ff26 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80114a4:	4603      	mov	r3, r0
 80114a6:	2b00      	cmp	r3, #0
 80114a8:	d101      	bne.n	80114ae <LSM303AGR_ACC_R_FullScale+0x1e>
    return MEMS_ERROR;
 80114aa:	2300      	movs	r3, #0
 80114ac:	e007      	b.n	80114be <LSM303AGR_ACC_R_FullScale+0x2e>

  *value &= LSM303AGR_ACC_FS_MASK; //mask
 80114ae:	9b00      	ldr	r3, [sp, #0]
 80114b0:	781b      	ldrb	r3, [r3, #0]
 80114b2:	f003 0330 	and.w	r3, r3, #48	; 0x30
 80114b6:	b2da      	uxtb	r2, r3
 80114b8:	9b00      	ldr	r3, [sp, #0]
 80114ba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80114bc:	2301      	movs	r3, #1
}
 80114be:	4618      	mov	r0, r3
 80114c0:	b003      	add	sp, #12
 80114c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80114c6:	bf00      	nop
 80114c8:	f3af 8000 	nop.w
 80114cc:	f3af 8000 	nop.w

080114d0 <LSM303AGR_ACC_Get_Raw_Acceleration>:
* Input          : pointer to [u8_t]
* Output         : Acceleration buffer u8_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_Get_Raw_Acceleration(void *handle, u8_t *buff)
{
 80114d0:	b500      	push	{lr}
 80114d2:	b083      	sub	sp, #12
 80114d4:	9001      	str	r0, [sp, #4]
 80114d6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_OUT_X_L, buff, 6 ) )
 80114d8:	9801      	ldr	r0, [sp, #4]
 80114da:	2128      	movs	r1, #40	; 0x28
 80114dc:	9a00      	ldr	r2, [sp, #0]
 80114de:	2306      	movs	r3, #6
 80114e0:	f7ff ff06 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80114e4:	4603      	mov	r3, r0
 80114e6:	2b00      	cmp	r3, #0
 80114e8:	d101      	bne.n	80114ee <LSM303AGR_ACC_Get_Raw_Acceleration+0x1e>
    return MEMS_ERROR;
 80114ea:	2300      	movs	r3, #0
 80114ec:	e000      	b.n	80114f0 <LSM303AGR_ACC_Get_Raw_Acceleration+0x20>

  return MEMS_SUCCESS;
 80114ee:	2301      	movs	r3, #1
}
 80114f0:	4618      	mov	r0, r3
 80114f2:	b003      	add	sp, #12
 80114f4:	f85d fb04 	ldr.w	pc, [sp], #4
 80114f8:	f3af 8000 	nop.w
 80114fc:	f3af 8000 	nop.w

08011500 <LSM303AGR_ACC_Get_Acceleration>:
    62520,  /* FS @8g */
    187580, /* FS @16g */
  },
};
status_t LSM303AGR_ACC_Get_Acceleration(void *handle, int *buff)
{
 8011500:	b570      	push	{r4, r5, r6, lr}
 8011502:	b086      	sub	sp, #24
 8011504:	9001      	str	r0, [sp, #4]
 8011506:	9100      	str	r1, [sp, #0]
  Type3Axis16bit_U raw_data_tmp;
  u8_t op_mode = 0, fs_mode = 0, shift = 0;
 8011508:	2300      	movs	r3, #0
 801150a:	f88d 3017 	strb.w	r3, [sp, #23]
 801150e:	2300      	movs	r3, #0
 8011510:	f88d 3016 	strb.w	r3, [sp, #22]
 8011514:	2300      	movs	r3, #0
 8011516:	f88d 3015 	strb.w	r3, [sp, #21]
  LSM303AGR_ACC_LPEN_t lp;
  LSM303AGR_ACC_HR_t hr;
  LSM303AGR_ACC_FS_t fs;

  /* Determine which operational mode the acc is set */
  LSM303AGR_ACC_R_HiRes(handle, &hr);
 801151a:	f10d 030a 	add.w	r3, sp, #10
 801151e:	9801      	ldr	r0, [sp, #4]
 8011520:	4619      	mov	r1, r3
 8011522:	f001 f9dd 	bl	80128e0 <LSM303AGR_ACC_R_HiRes>
  LSM303AGR_ACC_R_LOWPWR_EN(handle, &lp);
 8011526:	f10d 030b 	add.w	r3, sp, #11
 801152a:	9801      	ldr	r0, [sp, #4]
 801152c:	4619      	mov	r1, r3
 801152e:	f000 fc57 	bl	8011de0 <LSM303AGR_ACC_R_LOWPWR_EN>

  if (lp == LSM303AGR_ACC_LPEN_ENABLED && hr == LSM303AGR_ACC_HR_DISABLED)
 8011532:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8011536:	2b08      	cmp	r3, #8
 8011538:	d10a      	bne.n	8011550 <LSM303AGR_ACC_Get_Acceleration+0x50>
 801153a:	f89d 300a 	ldrb.w	r3, [sp, #10]
 801153e:	2b00      	cmp	r3, #0
 8011540:	d106      	bne.n	8011550 <LSM303AGR_ACC_Get_Acceleration+0x50>
  {
    /* op mode is LP 8-bit */
    op_mode = 2;
 8011542:	2302      	movs	r3, #2
 8011544:	f88d 3017 	strb.w	r3, [sp, #23]
    shift = 8;
 8011548:	2308      	movs	r3, #8
 801154a:	f88d 3015 	strb.w	r3, [sp, #21]
 801154e:	e01f      	b.n	8011590 <LSM303AGR_ACC_Get_Acceleration+0x90>
  }
  else if (lp == LSM303AGR_ACC_LPEN_DISABLED && hr == LSM303AGR_ACC_HR_DISABLED)
 8011550:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8011554:	2b00      	cmp	r3, #0
 8011556:	d10a      	bne.n	801156e <LSM303AGR_ACC_Get_Acceleration+0x6e>
 8011558:	f89d 300a 	ldrb.w	r3, [sp, #10]
 801155c:	2b00      	cmp	r3, #0
 801155e:	d106      	bne.n	801156e <LSM303AGR_ACC_Get_Acceleration+0x6e>
  {
    /* op mode is Normal 10-bit */
    op_mode = 1;
 8011560:	2301      	movs	r3, #1
 8011562:	f88d 3017 	strb.w	r3, [sp, #23]
    shift = 6;
 8011566:	2306      	movs	r3, #6
 8011568:	f88d 3015 	strb.w	r3, [sp, #21]
 801156c:	e010      	b.n	8011590 <LSM303AGR_ACC_Get_Acceleration+0x90>
  }
  else if (lp == LSM303AGR_ACC_LPEN_DISABLED && hr == LSM303AGR_ACC_HR_ENABLED)
 801156e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8011572:	2b00      	cmp	r3, #0
 8011574:	d10a      	bne.n	801158c <LSM303AGR_ACC_Get_Acceleration+0x8c>
 8011576:	f89d 300a 	ldrb.w	r3, [sp, #10]
 801157a:	2b08      	cmp	r3, #8
 801157c:	d106      	bne.n	801158c <LSM303AGR_ACC_Get_Acceleration+0x8c>
  {
    /* op mode is HR 12-bit */
    op_mode = 0;
 801157e:	2300      	movs	r3, #0
 8011580:	f88d 3017 	strb.w	r3, [sp, #23]
    shift = 4;
 8011584:	2304      	movs	r3, #4
 8011586:	f88d 3015 	strb.w	r3, [sp, #21]
 801158a:	e001      	b.n	8011590 <LSM303AGR_ACC_Get_Acceleration+0x90>
  }
  else
    return MEMS_ERROR;
 801158c:	2300      	movs	r3, #0
 801158e:	e0b8      	b.n	8011702 <LSM303AGR_ACC_Get_Acceleration+0x202>

  /* Determine the Full Scale the acc is set */
  LSM303AGR_ACC_R_FullScale(handle, &fs);
 8011590:	f10d 0309 	add.w	r3, sp, #9
 8011594:	9801      	ldr	r0, [sp, #4]
 8011596:	4619      	mov	r1, r3
 8011598:	f7ff ff7a 	bl	8011490 <LSM303AGR_ACC_R_FullScale>
  switch (fs)
 801159c:	f89d 3009 	ldrb.w	r3, [sp, #9]
 80115a0:	2b10      	cmp	r3, #16
 80115a2:	d00d      	beq.n	80115c0 <LSM303AGR_ACC_Get_Acceleration+0xc0>
 80115a4:	2b10      	cmp	r3, #16
 80115a6:	dc02      	bgt.n	80115ae <LSM303AGR_ACC_Get_Acceleration+0xae>
 80115a8:	2b00      	cmp	r3, #0
 80115aa:	d005      	beq.n	80115b8 <LSM303AGR_ACC_Get_Acceleration+0xb8>
 80115ac:	e014      	b.n	80115d8 <LSM303AGR_ACC_Get_Acceleration+0xd8>
 80115ae:	2b20      	cmp	r3, #32
 80115b0:	d00a      	beq.n	80115c8 <LSM303AGR_ACC_Get_Acceleration+0xc8>
 80115b2:	2b30      	cmp	r3, #48	; 0x30
 80115b4:	d00c      	beq.n	80115d0 <LSM303AGR_ACC_Get_Acceleration+0xd0>
 80115b6:	e00f      	b.n	80115d8 <LSM303AGR_ACC_Get_Acceleration+0xd8>
  {
    case LSM303AGR_ACC_FS_2G:
      fs_mode = 0;
 80115b8:	2300      	movs	r3, #0
 80115ba:	f88d 3016 	strb.w	r3, [sp, #22]
      break;
 80115be:	e00b      	b.n	80115d8 <LSM303AGR_ACC_Get_Acceleration+0xd8>

    case LSM303AGR_ACC_FS_4G:
      fs_mode = 1;
 80115c0:	2301      	movs	r3, #1
 80115c2:	f88d 3016 	strb.w	r3, [sp, #22]
      break;
 80115c6:	e007      	b.n	80115d8 <LSM303AGR_ACC_Get_Acceleration+0xd8>

    case LSM303AGR_ACC_FS_8G:
      fs_mode = 2;
 80115c8:	2302      	movs	r3, #2
 80115ca:	f88d 3016 	strb.w	r3, [sp, #22]
      break;
 80115ce:	e003      	b.n	80115d8 <LSM303AGR_ACC_Get_Acceleration+0xd8>

    case LSM303AGR_ACC_FS_16G:
      fs_mode = 3;
 80115d0:	2303      	movs	r3, #3
 80115d2:	f88d 3016 	strb.w	r3, [sp, #22]
      break;
 80115d6:	bf00      	nop
  }

  /* Read out raw accelerometer samples */
  LSM303AGR_ACC_Get_Raw_Acceleration(handle, raw_data_tmp.u8bit);
 80115d8:	ab03      	add	r3, sp, #12
 80115da:	9801      	ldr	r0, [sp, #4]
 80115dc:	4619      	mov	r1, r3
 80115de:	f7ff ff77 	bl	80114d0 <LSM303AGR_ACC_Get_Raw_Acceleration>

  /* Apply proper shift and sensitivity */
  buff[0] = ((raw_data_tmp.i16bit[0] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 80115e2:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 80115e6:	b21a      	sxth	r2, r3
 80115e8:	f89d 3015 	ldrb.w	r3, [sp, #21]
 80115ec:	fa42 f303 	asr.w	r3, r2, r3
 80115f0:	4618      	mov	r0, r3
 80115f2:	ea4f 71e0 	mov.w	r1, r0, asr #31
 80115f6:	f89d 4017 	ldrb.w	r4, [sp, #23]
 80115fa:	f89d 3016 	ldrb.w	r3, [sp, #22]
 80115fe:	4a42      	ldr	r2, [pc, #264]	; (8011708 <LSM303AGR_ACC_Get_Acceleration+0x208>)
 8011600:	00a4      	lsls	r4, r4, #2
 8011602:	4423      	add	r3, r4
 8011604:	00db      	lsls	r3, r3, #3
 8011606:	4413      	add	r3, r2
 8011608:	e9d3 2300 	ldrd	r2, r3, [r3]
 801160c:	fb02 f501 	mul.w	r5, r2, r1
 8011610:	fb00 f403 	mul.w	r4, r0, r3
 8011614:	442c      	add	r4, r5
 8011616:	fba0 2302 	umull	r2, r3, r0, r2
 801161a:	18e1      	adds	r1, r4, r3
 801161c:	460b      	mov	r3, r1
 801161e:	f512 72fa 	adds.w	r2, r2, #500	; 0x1f4
 8011622:	f143 0300 	adc.w	r3, r3, #0
 8011626:	4610      	mov	r0, r2
 8011628:	4619      	mov	r1, r3
 801162a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 801162e:	f04f 0300 	mov.w	r3, #0
 8011632:	f003 fef5 	bl	8015420 <__aeabi_ldivmod>
 8011636:	4602      	mov	r2, r0
 8011638:	460b      	mov	r3, r1
 801163a:	9b00      	ldr	r3, [sp, #0]
 801163c:	601a      	str	r2, [r3, #0]
  buff[1] = ((raw_data_tmp.i16bit[1] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 801163e:	9b00      	ldr	r3, [sp, #0]
 8011640:	1d1c      	adds	r4, r3, #4
 8011642:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8011646:	b21a      	sxth	r2, r3
 8011648:	f89d 3015 	ldrb.w	r3, [sp, #21]
 801164c:	fa42 f303 	asr.w	r3, r2, r3
 8011650:	4618      	mov	r0, r3
 8011652:	ea4f 71e0 	mov.w	r1, r0, asr #31
 8011656:	f89d 5017 	ldrb.w	r5, [sp, #23]
 801165a:	f89d 3016 	ldrb.w	r3, [sp, #22]
 801165e:	4a2a      	ldr	r2, [pc, #168]	; (8011708 <LSM303AGR_ACC_Get_Acceleration+0x208>)
 8011660:	00ad      	lsls	r5, r5, #2
 8011662:	442b      	add	r3, r5
 8011664:	00db      	lsls	r3, r3, #3
 8011666:	4413      	add	r3, r2
 8011668:	e9d3 2300 	ldrd	r2, r3, [r3]
 801166c:	fb02 f601 	mul.w	r6, r2, r1
 8011670:	fb00 f503 	mul.w	r5, r0, r3
 8011674:	4435      	add	r5, r6
 8011676:	fba0 2302 	umull	r2, r3, r0, r2
 801167a:	18e9      	adds	r1, r5, r3
 801167c:	460b      	mov	r3, r1
 801167e:	f512 72fa 	adds.w	r2, r2, #500	; 0x1f4
 8011682:	f143 0300 	adc.w	r3, r3, #0
 8011686:	4610      	mov	r0, r2
 8011688:	4619      	mov	r1, r3
 801168a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 801168e:	f04f 0300 	mov.w	r3, #0
 8011692:	f003 fec5 	bl	8015420 <__aeabi_ldivmod>
 8011696:	4602      	mov	r2, r0
 8011698:	460b      	mov	r3, r1
 801169a:	4613      	mov	r3, r2
 801169c:	6023      	str	r3, [r4, #0]
  buff[2] = ((raw_data_tmp.i16bit[2] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 801169e:	9b00      	ldr	r3, [sp, #0]
 80116a0:	f103 0408 	add.w	r4, r3, #8
 80116a4:	f8bd 3010 	ldrh.w	r3, [sp, #16]
 80116a8:	b21a      	sxth	r2, r3
 80116aa:	f89d 3015 	ldrb.w	r3, [sp, #21]
 80116ae:	fa42 f303 	asr.w	r3, r2, r3
 80116b2:	4618      	mov	r0, r3
 80116b4:	ea4f 71e0 	mov.w	r1, r0, asr #31
 80116b8:	f89d 5017 	ldrb.w	r5, [sp, #23]
 80116bc:	f89d 3016 	ldrb.w	r3, [sp, #22]
 80116c0:	4a11      	ldr	r2, [pc, #68]	; (8011708 <LSM303AGR_ACC_Get_Acceleration+0x208>)
 80116c2:	00ad      	lsls	r5, r5, #2
 80116c4:	442b      	add	r3, r5
 80116c6:	00db      	lsls	r3, r3, #3
 80116c8:	4413      	add	r3, r2
 80116ca:	e9d3 2300 	ldrd	r2, r3, [r3]
 80116ce:	fb02 f601 	mul.w	r6, r2, r1
 80116d2:	fb00 f503 	mul.w	r5, r0, r3
 80116d6:	4435      	add	r5, r6
 80116d8:	fba0 2302 	umull	r2, r3, r0, r2
 80116dc:	18e9      	adds	r1, r5, r3
 80116de:	460b      	mov	r3, r1
 80116e0:	f512 72fa 	adds.w	r2, r2, #500	; 0x1f4
 80116e4:	f143 0300 	adc.w	r3, r3, #0
 80116e8:	4610      	mov	r0, r2
 80116ea:	4619      	mov	r1, r3
 80116ec:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80116f0:	f04f 0300 	mov.w	r3, #0
 80116f4:	f003 fe94 	bl	8015420 <__aeabi_ldivmod>
 80116f8:	4602      	mov	r2, r0
 80116fa:	460b      	mov	r3, r1
 80116fc:	4613      	mov	r3, r2
 80116fe:	6023      	str	r3, [r4, #0]

  return MEMS_SUCCESS;
 8011700:	2301      	movs	r3, #1
}
 8011702:	4618      	mov	r0, r3
 8011704:	b006      	add	sp, #24
 8011706:	bd70      	pop	{r4, r5, r6, pc}
 8011708:	08017180 	.word	0x08017180
 801170c:	f3af 8000 	nop.w

08011710 <LSM303AGR_ACC_W_ODR>:
* Input          : LSM303AGR_ACC_ODR_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ODR(void *handle, LSM303AGR_ACC_ODR_t newValue)
{
 8011710:	b500      	push	{lr}
 8011712:	b085      	sub	sp, #20
 8011714:	9001      	str	r0, [sp, #4]
 8011716:	460b      	mov	r3, r1
 8011718:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 801171c:	f10d 030f 	add.w	r3, sp, #15
 8011720:	9801      	ldr	r0, [sp, #4]
 8011722:	2120      	movs	r1, #32
 8011724:	461a      	mov	r2, r3
 8011726:	2301      	movs	r3, #1
 8011728:	f7ff fde2 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 801172c:	4603      	mov	r3, r0
 801172e:	2b00      	cmp	r3, #0
 8011730:	d101      	bne.n	8011736 <LSM303AGR_ACC_W_ODR+0x26>
    return MEMS_ERROR;
 8011732:	2300      	movs	r3, #0
 8011734:	e01c      	b.n	8011770 <LSM303AGR_ACC_W_ODR+0x60>

  value &= ~LSM303AGR_ACC_ODR_MASK;
 8011736:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801173a:	f003 030f 	and.w	r3, r3, #15
 801173e:	b2db      	uxtb	r3, r3
 8011740:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8011744:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8011748:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801174c:	4313      	orrs	r3, r2
 801174e:	b2db      	uxtb	r3, r3
 8011750:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 8011754:	f10d 030f 	add.w	r3, sp, #15
 8011758:	9801      	ldr	r0, [sp, #4]
 801175a:	2120      	movs	r1, #32
 801175c:	461a      	mov	r2, r3
 801175e:	2301      	movs	r3, #1
 8011760:	f7ff fd9e 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8011764:	4603      	mov	r3, r0
 8011766:	2b00      	cmp	r3, #0
 8011768:	d101      	bne.n	801176e <LSM303AGR_ACC_W_ODR+0x5e>
    return MEMS_ERROR;
 801176a:	2300      	movs	r3, #0
 801176c:	e000      	b.n	8011770 <LSM303AGR_ACC_W_ODR+0x60>

  return MEMS_SUCCESS;
 801176e:	2301      	movs	r3, #1
}
 8011770:	4618      	mov	r0, r3
 8011772:	b005      	add	sp, #20
 8011774:	f85d fb04 	ldr.w	pc, [sp], #4
 8011778:	f3af 8000 	nop.w
 801177c:	f3af 8000 	nop.w

08011780 <LSM303AGR_ACC_R_ODR>:
* Input          : Pointer to LSM303AGR_ACC_ODR_t
* Output         : Status of ODR see LSM303AGR_ACC_ODR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ODR(void *handle, LSM303AGR_ACC_ODR_t *value)
{
 8011780:	b500      	push	{lr}
 8011782:	b083      	sub	sp, #12
 8011784:	9001      	str	r0, [sp, #4]
 8011786:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, (u8_t *)value, 1) )
 8011788:	9801      	ldr	r0, [sp, #4]
 801178a:	2120      	movs	r1, #32
 801178c:	9a00      	ldr	r2, [sp, #0]
 801178e:	2301      	movs	r3, #1
 8011790:	f7ff fdae 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8011794:	4603      	mov	r3, r0
 8011796:	2b00      	cmp	r3, #0
 8011798:	d101      	bne.n	801179e <LSM303AGR_ACC_R_ODR+0x1e>
    return MEMS_ERROR;
 801179a:	2300      	movs	r3, #0
 801179c:	e007      	b.n	80117ae <LSM303AGR_ACC_R_ODR+0x2e>

  *value &= LSM303AGR_ACC_ODR_MASK; //mask
 801179e:	9b00      	ldr	r3, [sp, #0]
 80117a0:	781b      	ldrb	r3, [r3, #0]
 80117a2:	f023 030f 	bic.w	r3, r3, #15
 80117a6:	b2da      	uxtb	r2, r3
 80117a8:	9b00      	ldr	r3, [sp, #0]
 80117aa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80117ac:	2301      	movs	r3, #1
}
 80117ae:	4618      	mov	r0, r3
 80117b0:	b003      	add	sp, #12
 80117b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80117b6:	bf00      	nop
 80117b8:	f3af 8000 	nop.w
 80117bc:	f3af 8000 	nop.w

080117c0 <LSM303AGR_ACC_R_x_data_avail>:
* Input          : Pointer to LSM303AGR_ACC_1DA_t
* Output         : Status of 1DA see LSM303AGR_ACC_1DA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_x_data_avail(void *handle, LSM303AGR_ACC_1DA_t *value)
{
 80117c0:	b500      	push	{lr}
 80117c2:	b083      	sub	sp, #12
 80117c4:	9001      	str	r0, [sp, #4]
 80117c6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 80117c8:	9801      	ldr	r0, [sp, #4]
 80117ca:	2107      	movs	r1, #7
 80117cc:	9a00      	ldr	r2, [sp, #0]
 80117ce:	2301      	movs	r3, #1
 80117d0:	f7ff fd8e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80117d4:	4603      	mov	r3, r0
 80117d6:	2b00      	cmp	r3, #0
 80117d8:	d101      	bne.n	80117de <LSM303AGR_ACC_R_x_data_avail+0x1e>
    return MEMS_ERROR;
 80117da:	2300      	movs	r3, #0
 80117dc:	e007      	b.n	80117ee <LSM303AGR_ACC_R_x_data_avail+0x2e>

  *value &= LSM303AGR_ACC_1DA_MASK; //mask
 80117de:	9b00      	ldr	r3, [sp, #0]
 80117e0:	781b      	ldrb	r3, [r3, #0]
 80117e2:	f003 0301 	and.w	r3, r3, #1
 80117e6:	b2da      	uxtb	r2, r3
 80117e8:	9b00      	ldr	r3, [sp, #0]
 80117ea:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80117ec:	2301      	movs	r3, #1
}
 80117ee:	4618      	mov	r0, r3
 80117f0:	b003      	add	sp, #12
 80117f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80117f6:	bf00      	nop
 80117f8:	f3af 8000 	nop.w
 80117fc:	f3af 8000 	nop.w

08011800 <LSM303AGR_ACC_R_y_data_avail>:
* Input          : Pointer to LSM303AGR_ACC_2DA__t
* Output         : Status of 2DA_ see LSM303AGR_ACC_2DA__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_y_data_avail(void *handle, LSM303AGR_ACC_2DA__t *value)
{
 8011800:	b500      	push	{lr}
 8011802:	b083      	sub	sp, #12
 8011804:	9001      	str	r0, [sp, #4]
 8011806:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 8011808:	9801      	ldr	r0, [sp, #4]
 801180a:	2107      	movs	r1, #7
 801180c:	9a00      	ldr	r2, [sp, #0]
 801180e:	2301      	movs	r3, #1
 8011810:	f7ff fd6e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8011814:	4603      	mov	r3, r0
 8011816:	2b00      	cmp	r3, #0
 8011818:	d101      	bne.n	801181e <LSM303AGR_ACC_R_y_data_avail+0x1e>
    return MEMS_ERROR;
 801181a:	2300      	movs	r3, #0
 801181c:	e007      	b.n	801182e <LSM303AGR_ACC_R_y_data_avail+0x2e>

  *value &= LSM303AGR_ACC_2DA__MASK; //mask
 801181e:	9b00      	ldr	r3, [sp, #0]
 8011820:	781b      	ldrb	r3, [r3, #0]
 8011822:	f003 0302 	and.w	r3, r3, #2
 8011826:	b2da      	uxtb	r2, r3
 8011828:	9b00      	ldr	r3, [sp, #0]
 801182a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801182c:	2301      	movs	r3, #1
}
 801182e:	4618      	mov	r0, r3
 8011830:	b003      	add	sp, #12
 8011832:	f85d fb04 	ldr.w	pc, [sp], #4
 8011836:	bf00      	nop
 8011838:	f3af 8000 	nop.w
 801183c:	f3af 8000 	nop.w

08011840 <LSM303AGR_ACC_R_z_data_avail>:
* Input          : Pointer to LSM303AGR_ACC_3DA__t
* Output         : Status of 3DA_ see LSM303AGR_ACC_3DA__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_z_data_avail(void *handle, LSM303AGR_ACC_3DA__t *value)
{
 8011840:	b500      	push	{lr}
 8011842:	b083      	sub	sp, #12
 8011844:	9001      	str	r0, [sp, #4]
 8011846:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 8011848:	9801      	ldr	r0, [sp, #4]
 801184a:	2107      	movs	r1, #7
 801184c:	9a00      	ldr	r2, [sp, #0]
 801184e:	2301      	movs	r3, #1
 8011850:	f7ff fd4e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8011854:	4603      	mov	r3, r0
 8011856:	2b00      	cmp	r3, #0
 8011858:	d101      	bne.n	801185e <LSM303AGR_ACC_R_z_data_avail+0x1e>
    return MEMS_ERROR;
 801185a:	2300      	movs	r3, #0
 801185c:	e007      	b.n	801186e <LSM303AGR_ACC_R_z_data_avail+0x2e>

  *value &= LSM303AGR_ACC_3DA__MASK; //mask
 801185e:	9b00      	ldr	r3, [sp, #0]
 8011860:	781b      	ldrb	r3, [r3, #0]
 8011862:	f003 0304 	and.w	r3, r3, #4
 8011866:	b2da      	uxtb	r2, r3
 8011868:	9b00      	ldr	r3, [sp, #0]
 801186a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801186c:	2301      	movs	r3, #1
}
 801186e:	4618      	mov	r0, r3
 8011870:	b003      	add	sp, #12
 8011872:	f85d fb04 	ldr.w	pc, [sp], #4
 8011876:	bf00      	nop
 8011878:	f3af 8000 	nop.w
 801187c:	f3af 8000 	nop.w

08011880 <LSM303AGR_ACC_R_xyz_data_avail>:
* Input          : Pointer to LSM303AGR_ACC_321DA__t
* Output         : Status of 321DA_ see LSM303AGR_ACC_321DA__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_xyz_data_avail(void *handle, LSM303AGR_ACC_321DA__t *value)
{
 8011880:	b500      	push	{lr}
 8011882:	b083      	sub	sp, #12
 8011884:	9001      	str	r0, [sp, #4]
 8011886:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 8011888:	9801      	ldr	r0, [sp, #4]
 801188a:	2107      	movs	r1, #7
 801188c:	9a00      	ldr	r2, [sp, #0]
 801188e:	2301      	movs	r3, #1
 8011890:	f7ff fd2e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8011894:	4603      	mov	r3, r0
 8011896:	2b00      	cmp	r3, #0
 8011898:	d101      	bne.n	801189e <LSM303AGR_ACC_R_xyz_data_avail+0x1e>
    return MEMS_ERROR;
 801189a:	2300      	movs	r3, #0
 801189c:	e007      	b.n	80118ae <LSM303AGR_ACC_R_xyz_data_avail+0x2e>

  *value &= LSM303AGR_ACC_321DA__MASK; //mask
 801189e:	9b00      	ldr	r3, [sp, #0]
 80118a0:	781b      	ldrb	r3, [r3, #0]
 80118a2:	f003 0308 	and.w	r3, r3, #8
 80118a6:	b2da      	uxtb	r2, r3
 80118a8:	9b00      	ldr	r3, [sp, #0]
 80118aa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80118ac:	2301      	movs	r3, #1
}
 80118ae:	4618      	mov	r0, r3
 80118b0:	b003      	add	sp, #12
 80118b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80118b6:	bf00      	nop
 80118b8:	f3af 8000 	nop.w
 80118bc:	f3af 8000 	nop.w

080118c0 <LSM303AGR_ACC_R_DataXOverrun>:
* Input          : Pointer to LSM303AGR_ACC_1OR__t
* Output         : Status of 1OR_ see LSM303AGR_ACC_1OR__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_DataXOverrun(void *handle, LSM303AGR_ACC_1OR__t *value)
{
 80118c0:	b500      	push	{lr}
 80118c2:	b083      	sub	sp, #12
 80118c4:	9001      	str	r0, [sp, #4]
 80118c6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 80118c8:	9801      	ldr	r0, [sp, #4]
 80118ca:	2107      	movs	r1, #7
 80118cc:	9a00      	ldr	r2, [sp, #0]
 80118ce:	2301      	movs	r3, #1
 80118d0:	f7ff fd0e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80118d4:	4603      	mov	r3, r0
 80118d6:	2b00      	cmp	r3, #0
 80118d8:	d101      	bne.n	80118de <LSM303AGR_ACC_R_DataXOverrun+0x1e>
    return MEMS_ERROR;
 80118da:	2300      	movs	r3, #0
 80118dc:	e007      	b.n	80118ee <LSM303AGR_ACC_R_DataXOverrun+0x2e>

  *value &= LSM303AGR_ACC_1OR__MASK; //mask
 80118de:	9b00      	ldr	r3, [sp, #0]
 80118e0:	781b      	ldrb	r3, [r3, #0]
 80118e2:	f003 0310 	and.w	r3, r3, #16
 80118e6:	b2da      	uxtb	r2, r3
 80118e8:	9b00      	ldr	r3, [sp, #0]
 80118ea:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80118ec:	2301      	movs	r3, #1
}
 80118ee:	4618      	mov	r0, r3
 80118f0:	b003      	add	sp, #12
 80118f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80118f6:	bf00      	nop
 80118f8:	f3af 8000 	nop.w
 80118fc:	f3af 8000 	nop.w

08011900 <LSM303AGR_ACC_R_DataYOverrun>:
* Input          : Pointer to LSM303AGR_ACC_2OR__t
* Output         : Status of 2OR_ see LSM303AGR_ACC_2OR__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_DataYOverrun(void *handle, LSM303AGR_ACC_2OR__t *value)
{
 8011900:	b500      	push	{lr}
 8011902:	b083      	sub	sp, #12
 8011904:	9001      	str	r0, [sp, #4]
 8011906:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 8011908:	9801      	ldr	r0, [sp, #4]
 801190a:	2107      	movs	r1, #7
 801190c:	9a00      	ldr	r2, [sp, #0]
 801190e:	2301      	movs	r3, #1
 8011910:	f7ff fcee 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8011914:	4603      	mov	r3, r0
 8011916:	2b00      	cmp	r3, #0
 8011918:	d101      	bne.n	801191e <LSM303AGR_ACC_R_DataYOverrun+0x1e>
    return MEMS_ERROR;
 801191a:	2300      	movs	r3, #0
 801191c:	e007      	b.n	801192e <LSM303AGR_ACC_R_DataYOverrun+0x2e>

  *value &= LSM303AGR_ACC_2OR__MASK; //mask
 801191e:	9b00      	ldr	r3, [sp, #0]
 8011920:	781b      	ldrb	r3, [r3, #0]
 8011922:	f003 0320 	and.w	r3, r3, #32
 8011926:	b2da      	uxtb	r2, r3
 8011928:	9b00      	ldr	r3, [sp, #0]
 801192a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801192c:	2301      	movs	r3, #1
}
 801192e:	4618      	mov	r0, r3
 8011930:	b003      	add	sp, #12
 8011932:	f85d fb04 	ldr.w	pc, [sp], #4
 8011936:	bf00      	nop
 8011938:	f3af 8000 	nop.w
 801193c:	f3af 8000 	nop.w

08011940 <LSM303AGR_ACC_R_DataZOverrun>:
* Input          : Pointer to LSM303AGR_ACC_3OR__t
* Output         : Status of 3OR_ see LSM303AGR_ACC_3OR__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_DataZOverrun(void *handle, LSM303AGR_ACC_3OR__t *value)
{
 8011940:	b500      	push	{lr}
 8011942:	b083      	sub	sp, #12
 8011944:	9001      	str	r0, [sp, #4]
 8011946:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 8011948:	9801      	ldr	r0, [sp, #4]
 801194a:	2107      	movs	r1, #7
 801194c:	9a00      	ldr	r2, [sp, #0]
 801194e:	2301      	movs	r3, #1
 8011950:	f7ff fcce 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8011954:	4603      	mov	r3, r0
 8011956:	2b00      	cmp	r3, #0
 8011958:	d101      	bne.n	801195e <LSM303AGR_ACC_R_DataZOverrun+0x1e>
    return MEMS_ERROR;
 801195a:	2300      	movs	r3, #0
 801195c:	e007      	b.n	801196e <LSM303AGR_ACC_R_DataZOverrun+0x2e>

  *value &= LSM303AGR_ACC_3OR__MASK; //mask
 801195e:	9b00      	ldr	r3, [sp, #0]
 8011960:	781b      	ldrb	r3, [r3, #0]
 8011962:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8011966:	b2da      	uxtb	r2, r3
 8011968:	9b00      	ldr	r3, [sp, #0]
 801196a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801196c:	2301      	movs	r3, #1
}
 801196e:	4618      	mov	r0, r3
 8011970:	b003      	add	sp, #12
 8011972:	f85d fb04 	ldr.w	pc, [sp], #4
 8011976:	bf00      	nop
 8011978:	f3af 8000 	nop.w
 801197c:	f3af 8000 	nop.w

08011980 <LSM303AGR_ACC_R_DataXYZOverrun>:
* Input          : Pointer to LSM303AGR_ACC_321OR__t
* Output         : Status of 321OR_ see LSM303AGR_ACC_321OR__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_DataXYZOverrun(void *handle, LSM303AGR_ACC_321OR__t *value)
{
 8011980:	b500      	push	{lr}
 8011982:	b083      	sub	sp, #12
 8011984:	9001      	str	r0, [sp, #4]
 8011986:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 8011988:	9801      	ldr	r0, [sp, #4]
 801198a:	2107      	movs	r1, #7
 801198c:	9a00      	ldr	r2, [sp, #0]
 801198e:	2301      	movs	r3, #1
 8011990:	f7ff fcae 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8011994:	4603      	mov	r3, r0
 8011996:	2b00      	cmp	r3, #0
 8011998:	d101      	bne.n	801199e <LSM303AGR_ACC_R_DataXYZOverrun+0x1e>
    return MEMS_ERROR;
 801199a:	2300      	movs	r3, #0
 801199c:	e007      	b.n	80119ae <LSM303AGR_ACC_R_DataXYZOverrun+0x2e>

  *value &= LSM303AGR_ACC_321OR__MASK; //mask
 801199e:	9b00      	ldr	r3, [sp, #0]
 80119a0:	781b      	ldrb	r3, [r3, #0]
 80119a2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80119a6:	b2da      	uxtb	r2, r3
 80119a8:	9b00      	ldr	r3, [sp, #0]
 80119aa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80119ac:	2301      	movs	r3, #1
}
 80119ae:	4618      	mov	r0, r3
 80119b0:	b003      	add	sp, #12
 80119b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80119b6:	bf00      	nop
 80119b8:	f3af 8000 	nop.w
 80119bc:	f3af 8000 	nop.w

080119c0 <LSM303AGR_ACC_R_int_counter>:
* Input          : Pointer to u8_t
* Output         : Status of IC
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_int_counter(void *handle, u8_t *value)
{
 80119c0:	b500      	push	{lr}
 80119c2:	b083      	sub	sp, #12
 80119c4:	9001      	str	r0, [sp, #4]
 80119c6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT_COUNTER_REG, (u8_t *)value, 1) )
 80119c8:	9801      	ldr	r0, [sp, #4]
 80119ca:	210e      	movs	r1, #14
 80119cc:	9a00      	ldr	r2, [sp, #0]
 80119ce:	2301      	movs	r3, #1
 80119d0:	f7ff fc8e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80119d4:	4603      	mov	r3, r0
 80119d6:	2b00      	cmp	r3, #0
 80119d8:	d101      	bne.n	80119de <LSM303AGR_ACC_R_int_counter+0x1e>
    return MEMS_ERROR;
 80119da:	2300      	movs	r3, #0
 80119dc:	e008      	b.n	80119f0 <LSM303AGR_ACC_R_int_counter+0x30>

  *value &= LSM303AGR_ACC_IC_MASK; //coerce
 80119de:	9b00      	ldr	r3, [sp, #0]
 80119e0:	781a      	ldrb	r2, [r3, #0]
 80119e2:	9b00      	ldr	r3, [sp, #0]
 80119e4:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_IC_POSITION; //mask
 80119e6:	9b00      	ldr	r3, [sp, #0]
 80119e8:	781a      	ldrb	r2, [r3, #0]
 80119ea:	9b00      	ldr	r3, [sp, #0]
 80119ec:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80119ee:	2301      	movs	r3, #1
}
 80119f0:	4618      	mov	r0, r3
 80119f2:	b003      	add	sp, #12
 80119f4:	f85d fb04 	ldr.w	pc, [sp], #4
 80119f8:	f3af 8000 	nop.w
 80119fc:	f3af 8000 	nop.w

08011a00 <LSM303AGR_ACC_W_TEMP_EN_bits>:
* Input          : LSM303AGR_ACC_TEMP_EN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_TEMP_EN_bits(void *handle, LSM303AGR_ACC_TEMP_EN_t newValue)
{
 8011a00:	b500      	push	{lr}
 8011a02:	b085      	sub	sp, #20
 8011a04:	9001      	str	r0, [sp, #4]
 8011a06:	460b      	mov	r3, r1
 8011a08:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TEMP_CFG_REG, &value, 1) )
 8011a0c:	f10d 030f 	add.w	r3, sp, #15
 8011a10:	9801      	ldr	r0, [sp, #4]
 8011a12:	211f      	movs	r1, #31
 8011a14:	461a      	mov	r2, r3
 8011a16:	2301      	movs	r3, #1
 8011a18:	f7ff fc6a 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8011a1c:	4603      	mov	r3, r0
 8011a1e:	2b00      	cmp	r3, #0
 8011a20:	d101      	bne.n	8011a26 <LSM303AGR_ACC_W_TEMP_EN_bits+0x26>
    return MEMS_ERROR;
 8011a22:	2300      	movs	r3, #0
 8011a24:	e01c      	b.n	8011a60 <LSM303AGR_ACC_W_TEMP_EN_bits+0x60>

  value &= ~LSM303AGR_ACC_TEMP_EN_MASK;
 8011a26:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8011a2a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8011a2e:	b2db      	uxtb	r3, r3
 8011a30:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8011a34:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8011a38:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8011a3c:	4313      	orrs	r3, r2
 8011a3e:	b2db      	uxtb	r3, r3
 8011a40:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_TEMP_CFG_REG, &value, 1) )
 8011a44:	f10d 030f 	add.w	r3, sp, #15
 8011a48:	9801      	ldr	r0, [sp, #4]
 8011a4a:	211f      	movs	r1, #31
 8011a4c:	461a      	mov	r2, r3
 8011a4e:	2301      	movs	r3, #1
 8011a50:	f7ff fc26 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8011a54:	4603      	mov	r3, r0
 8011a56:	2b00      	cmp	r3, #0
 8011a58:	d101      	bne.n	8011a5e <LSM303AGR_ACC_W_TEMP_EN_bits+0x5e>
    return MEMS_ERROR;
 8011a5a:	2300      	movs	r3, #0
 8011a5c:	e000      	b.n	8011a60 <LSM303AGR_ACC_W_TEMP_EN_bits+0x60>

  return MEMS_SUCCESS;
 8011a5e:	2301      	movs	r3, #1
}
 8011a60:	4618      	mov	r0, r3
 8011a62:	b005      	add	sp, #20
 8011a64:	f85d fb04 	ldr.w	pc, [sp], #4
 8011a68:	f3af 8000 	nop.w
 8011a6c:	f3af 8000 	nop.w

08011a70 <LSM303AGR_ACC_R_TEMP_EN_bits>:
* Input          : Pointer to LSM303AGR_ACC_TEMP_EN_t
* Output         : Status of TEMP_EN see LSM303AGR_ACC_TEMP_EN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_TEMP_EN_bits(void *handle, LSM303AGR_ACC_TEMP_EN_t *value)
{
 8011a70:	b500      	push	{lr}
 8011a72:	b083      	sub	sp, #12
 8011a74:	9001      	str	r0, [sp, #4]
 8011a76:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TEMP_CFG_REG, (u8_t *)value, 1) )
 8011a78:	9801      	ldr	r0, [sp, #4]
 8011a7a:	211f      	movs	r1, #31
 8011a7c:	9a00      	ldr	r2, [sp, #0]
 8011a7e:	2301      	movs	r3, #1
 8011a80:	f7ff fc36 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8011a84:	4603      	mov	r3, r0
 8011a86:	2b00      	cmp	r3, #0
 8011a88:	d101      	bne.n	8011a8e <LSM303AGR_ACC_R_TEMP_EN_bits+0x1e>
    return MEMS_ERROR;
 8011a8a:	2300      	movs	r3, #0
 8011a8c:	e007      	b.n	8011a9e <LSM303AGR_ACC_R_TEMP_EN_bits+0x2e>

  *value &= LSM303AGR_ACC_TEMP_EN_MASK; //mask
 8011a8e:	9b00      	ldr	r3, [sp, #0]
 8011a90:	781b      	ldrb	r3, [r3, #0]
 8011a92:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8011a96:	b2da      	uxtb	r2, r3
 8011a98:	9b00      	ldr	r3, [sp, #0]
 8011a9a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8011a9c:	2301      	movs	r3, #1
}
 8011a9e:	4618      	mov	r0, r3
 8011aa0:	b003      	add	sp, #12
 8011aa2:	f85d fb04 	ldr.w	pc, [sp], #4
 8011aa6:	bf00      	nop
 8011aa8:	f3af 8000 	nop.w
 8011aac:	f3af 8000 	nop.w

08011ab0 <LSM303AGR_ACC_W_ADC_PD>:
* Input          : LSM303AGR_ACC_ADC_PD_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ADC_PD(void *handle, LSM303AGR_ACC_ADC_PD_t newValue)
{
 8011ab0:	b500      	push	{lr}
 8011ab2:	b085      	sub	sp, #20
 8011ab4:	9001      	str	r0, [sp, #4]
 8011ab6:	460b      	mov	r3, r1
 8011ab8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TEMP_CFG_REG, &value, 1) )
 8011abc:	f10d 030f 	add.w	r3, sp, #15
 8011ac0:	9801      	ldr	r0, [sp, #4]
 8011ac2:	211f      	movs	r1, #31
 8011ac4:	461a      	mov	r2, r3
 8011ac6:	2301      	movs	r3, #1
 8011ac8:	f7ff fc12 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8011acc:	4603      	mov	r3, r0
 8011ace:	2b00      	cmp	r3, #0
 8011ad0:	d101      	bne.n	8011ad6 <LSM303AGR_ACC_W_ADC_PD+0x26>
    return MEMS_ERROR;
 8011ad2:	2300      	movs	r3, #0
 8011ad4:	e01c      	b.n	8011b10 <LSM303AGR_ACC_W_ADC_PD+0x60>

  value &= ~LSM303AGR_ACC_ADC_PD_MASK;
 8011ad6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8011ada:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8011ade:	b2db      	uxtb	r3, r3
 8011ae0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8011ae4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8011ae8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8011aec:	4313      	orrs	r3, r2
 8011aee:	b2db      	uxtb	r3, r3
 8011af0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_TEMP_CFG_REG, &value, 1) )
 8011af4:	f10d 030f 	add.w	r3, sp, #15
 8011af8:	9801      	ldr	r0, [sp, #4]
 8011afa:	211f      	movs	r1, #31
 8011afc:	461a      	mov	r2, r3
 8011afe:	2301      	movs	r3, #1
 8011b00:	f7ff fbce 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8011b04:	4603      	mov	r3, r0
 8011b06:	2b00      	cmp	r3, #0
 8011b08:	d101      	bne.n	8011b0e <LSM303AGR_ACC_W_ADC_PD+0x5e>
    return MEMS_ERROR;
 8011b0a:	2300      	movs	r3, #0
 8011b0c:	e000      	b.n	8011b10 <LSM303AGR_ACC_W_ADC_PD+0x60>

  return MEMS_SUCCESS;
 8011b0e:	2301      	movs	r3, #1
}
 8011b10:	4618      	mov	r0, r3
 8011b12:	b005      	add	sp, #20
 8011b14:	f85d fb04 	ldr.w	pc, [sp], #4
 8011b18:	f3af 8000 	nop.w
 8011b1c:	f3af 8000 	nop.w

08011b20 <LSM303AGR_ACC_R_ADC_PD>:
* Input          : Pointer to LSM303AGR_ACC_ADC_PD_t
* Output         : Status of ADC_PD see LSM303AGR_ACC_ADC_PD_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ADC_PD(void *handle, LSM303AGR_ACC_ADC_PD_t *value)
{
 8011b20:	b500      	push	{lr}
 8011b22:	b083      	sub	sp, #12
 8011b24:	9001      	str	r0, [sp, #4]
 8011b26:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TEMP_CFG_REG, (u8_t *)value, 1) )
 8011b28:	9801      	ldr	r0, [sp, #4]
 8011b2a:	211f      	movs	r1, #31
 8011b2c:	9a00      	ldr	r2, [sp, #0]
 8011b2e:	2301      	movs	r3, #1
 8011b30:	f7ff fbde 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8011b34:	4603      	mov	r3, r0
 8011b36:	2b00      	cmp	r3, #0
 8011b38:	d101      	bne.n	8011b3e <LSM303AGR_ACC_R_ADC_PD+0x1e>
    return MEMS_ERROR;
 8011b3a:	2300      	movs	r3, #0
 8011b3c:	e007      	b.n	8011b4e <LSM303AGR_ACC_R_ADC_PD+0x2e>

  *value &= LSM303AGR_ACC_ADC_PD_MASK; //mask
 8011b3e:	9b00      	ldr	r3, [sp, #0]
 8011b40:	781b      	ldrb	r3, [r3, #0]
 8011b42:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8011b46:	b2da      	uxtb	r2, r3
 8011b48:	9b00      	ldr	r3, [sp, #0]
 8011b4a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8011b4c:	2301      	movs	r3, #1
}
 8011b4e:	4618      	mov	r0, r3
 8011b50:	b003      	add	sp, #12
 8011b52:	f85d fb04 	ldr.w	pc, [sp], #4
 8011b56:	bf00      	nop
 8011b58:	f3af 8000 	nop.w
 8011b5c:	f3af 8000 	nop.w

08011b60 <LSM303AGR_ACC_W_XEN>:
* Input          : LSM303AGR_ACC_XEN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_XEN(void *handle, LSM303AGR_ACC_XEN_t newValue)
{
 8011b60:	b500      	push	{lr}
 8011b62:	b085      	sub	sp, #20
 8011b64:	9001      	str	r0, [sp, #4]
 8011b66:	460b      	mov	r3, r1
 8011b68:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 8011b6c:	f10d 030f 	add.w	r3, sp, #15
 8011b70:	9801      	ldr	r0, [sp, #4]
 8011b72:	2120      	movs	r1, #32
 8011b74:	461a      	mov	r2, r3
 8011b76:	2301      	movs	r3, #1
 8011b78:	f7ff fbba 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8011b7c:	4603      	mov	r3, r0
 8011b7e:	2b00      	cmp	r3, #0
 8011b80:	d101      	bne.n	8011b86 <LSM303AGR_ACC_W_XEN+0x26>
    return MEMS_ERROR;
 8011b82:	2300      	movs	r3, #0
 8011b84:	e01c      	b.n	8011bc0 <LSM303AGR_ACC_W_XEN+0x60>

  value &= ~LSM303AGR_ACC_XEN_MASK;
 8011b86:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8011b8a:	f023 0301 	bic.w	r3, r3, #1
 8011b8e:	b2db      	uxtb	r3, r3
 8011b90:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8011b94:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8011b98:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8011b9c:	4313      	orrs	r3, r2
 8011b9e:	b2db      	uxtb	r3, r3
 8011ba0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 8011ba4:	f10d 030f 	add.w	r3, sp, #15
 8011ba8:	9801      	ldr	r0, [sp, #4]
 8011baa:	2120      	movs	r1, #32
 8011bac:	461a      	mov	r2, r3
 8011bae:	2301      	movs	r3, #1
 8011bb0:	f7ff fb76 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8011bb4:	4603      	mov	r3, r0
 8011bb6:	2b00      	cmp	r3, #0
 8011bb8:	d101      	bne.n	8011bbe <LSM303AGR_ACC_W_XEN+0x5e>
    return MEMS_ERROR;
 8011bba:	2300      	movs	r3, #0
 8011bbc:	e000      	b.n	8011bc0 <LSM303AGR_ACC_W_XEN+0x60>

  return MEMS_SUCCESS;
 8011bbe:	2301      	movs	r3, #1
}
 8011bc0:	4618      	mov	r0, r3
 8011bc2:	b005      	add	sp, #20
 8011bc4:	f85d fb04 	ldr.w	pc, [sp], #4
 8011bc8:	f3af 8000 	nop.w
 8011bcc:	f3af 8000 	nop.w

08011bd0 <LSM303AGR_ACC_R_XEN>:
* Input          : Pointer to LSM303AGR_ACC_XEN_t
* Output         : Status of XEN see LSM303AGR_ACC_XEN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XEN(void *handle, LSM303AGR_ACC_XEN_t *value)
{
 8011bd0:	b500      	push	{lr}
 8011bd2:	b083      	sub	sp, #12
 8011bd4:	9001      	str	r0, [sp, #4]
 8011bd6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, (u8_t *)value, 1) )
 8011bd8:	9801      	ldr	r0, [sp, #4]
 8011bda:	2120      	movs	r1, #32
 8011bdc:	9a00      	ldr	r2, [sp, #0]
 8011bde:	2301      	movs	r3, #1
 8011be0:	f7ff fb86 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8011be4:	4603      	mov	r3, r0
 8011be6:	2b00      	cmp	r3, #0
 8011be8:	d101      	bne.n	8011bee <LSM303AGR_ACC_R_XEN+0x1e>
    return MEMS_ERROR;
 8011bea:	2300      	movs	r3, #0
 8011bec:	e007      	b.n	8011bfe <LSM303AGR_ACC_R_XEN+0x2e>

  *value &= LSM303AGR_ACC_XEN_MASK; //mask
 8011bee:	9b00      	ldr	r3, [sp, #0]
 8011bf0:	781b      	ldrb	r3, [r3, #0]
 8011bf2:	f003 0301 	and.w	r3, r3, #1
 8011bf6:	b2da      	uxtb	r2, r3
 8011bf8:	9b00      	ldr	r3, [sp, #0]
 8011bfa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8011bfc:	2301      	movs	r3, #1
}
 8011bfe:	4618      	mov	r0, r3
 8011c00:	b003      	add	sp, #12
 8011c02:	f85d fb04 	ldr.w	pc, [sp], #4
 8011c06:	bf00      	nop
 8011c08:	f3af 8000 	nop.w
 8011c0c:	f3af 8000 	nop.w

08011c10 <LSM303AGR_ACC_W_YEN>:
* Input          : LSM303AGR_ACC_YEN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_YEN(void *handle, LSM303AGR_ACC_YEN_t newValue)
{
 8011c10:	b500      	push	{lr}
 8011c12:	b085      	sub	sp, #20
 8011c14:	9001      	str	r0, [sp, #4]
 8011c16:	460b      	mov	r3, r1
 8011c18:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 8011c1c:	f10d 030f 	add.w	r3, sp, #15
 8011c20:	9801      	ldr	r0, [sp, #4]
 8011c22:	2120      	movs	r1, #32
 8011c24:	461a      	mov	r2, r3
 8011c26:	2301      	movs	r3, #1
 8011c28:	f7ff fb62 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8011c2c:	4603      	mov	r3, r0
 8011c2e:	2b00      	cmp	r3, #0
 8011c30:	d101      	bne.n	8011c36 <LSM303AGR_ACC_W_YEN+0x26>
    return MEMS_ERROR;
 8011c32:	2300      	movs	r3, #0
 8011c34:	e01c      	b.n	8011c70 <LSM303AGR_ACC_W_YEN+0x60>

  value &= ~LSM303AGR_ACC_YEN_MASK;
 8011c36:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8011c3a:	f023 0302 	bic.w	r3, r3, #2
 8011c3e:	b2db      	uxtb	r3, r3
 8011c40:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8011c44:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8011c48:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8011c4c:	4313      	orrs	r3, r2
 8011c4e:	b2db      	uxtb	r3, r3
 8011c50:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 8011c54:	f10d 030f 	add.w	r3, sp, #15
 8011c58:	9801      	ldr	r0, [sp, #4]
 8011c5a:	2120      	movs	r1, #32
 8011c5c:	461a      	mov	r2, r3
 8011c5e:	2301      	movs	r3, #1
 8011c60:	f7ff fb1e 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8011c64:	4603      	mov	r3, r0
 8011c66:	2b00      	cmp	r3, #0
 8011c68:	d101      	bne.n	8011c6e <LSM303AGR_ACC_W_YEN+0x5e>
    return MEMS_ERROR;
 8011c6a:	2300      	movs	r3, #0
 8011c6c:	e000      	b.n	8011c70 <LSM303AGR_ACC_W_YEN+0x60>

  return MEMS_SUCCESS;
 8011c6e:	2301      	movs	r3, #1
}
 8011c70:	4618      	mov	r0, r3
 8011c72:	b005      	add	sp, #20
 8011c74:	f85d fb04 	ldr.w	pc, [sp], #4
 8011c78:	f3af 8000 	nop.w
 8011c7c:	f3af 8000 	nop.w

08011c80 <LSM303AGR_ACC_R_YEN>:
* Input          : Pointer to LSM303AGR_ACC_YEN_t
* Output         : Status of YEN see LSM303AGR_ACC_YEN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_YEN(void *handle, LSM303AGR_ACC_YEN_t *value)
{
 8011c80:	b500      	push	{lr}
 8011c82:	b083      	sub	sp, #12
 8011c84:	9001      	str	r0, [sp, #4]
 8011c86:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, (u8_t *)value, 1) )
 8011c88:	9801      	ldr	r0, [sp, #4]
 8011c8a:	2120      	movs	r1, #32
 8011c8c:	9a00      	ldr	r2, [sp, #0]
 8011c8e:	2301      	movs	r3, #1
 8011c90:	f7ff fb2e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8011c94:	4603      	mov	r3, r0
 8011c96:	2b00      	cmp	r3, #0
 8011c98:	d101      	bne.n	8011c9e <LSM303AGR_ACC_R_YEN+0x1e>
    return MEMS_ERROR;
 8011c9a:	2300      	movs	r3, #0
 8011c9c:	e007      	b.n	8011cae <LSM303AGR_ACC_R_YEN+0x2e>

  *value &= LSM303AGR_ACC_YEN_MASK; //mask
 8011c9e:	9b00      	ldr	r3, [sp, #0]
 8011ca0:	781b      	ldrb	r3, [r3, #0]
 8011ca2:	f003 0302 	and.w	r3, r3, #2
 8011ca6:	b2da      	uxtb	r2, r3
 8011ca8:	9b00      	ldr	r3, [sp, #0]
 8011caa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8011cac:	2301      	movs	r3, #1
}
 8011cae:	4618      	mov	r0, r3
 8011cb0:	b003      	add	sp, #12
 8011cb2:	f85d fb04 	ldr.w	pc, [sp], #4
 8011cb6:	bf00      	nop
 8011cb8:	f3af 8000 	nop.w
 8011cbc:	f3af 8000 	nop.w

08011cc0 <LSM303AGR_ACC_W_ZEN>:
* Input          : LSM303AGR_ACC_ZEN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ZEN(void *handle, LSM303AGR_ACC_ZEN_t newValue)
{
 8011cc0:	b500      	push	{lr}
 8011cc2:	b085      	sub	sp, #20
 8011cc4:	9001      	str	r0, [sp, #4]
 8011cc6:	460b      	mov	r3, r1
 8011cc8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 8011ccc:	f10d 030f 	add.w	r3, sp, #15
 8011cd0:	9801      	ldr	r0, [sp, #4]
 8011cd2:	2120      	movs	r1, #32
 8011cd4:	461a      	mov	r2, r3
 8011cd6:	2301      	movs	r3, #1
 8011cd8:	f7ff fb0a 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8011cdc:	4603      	mov	r3, r0
 8011cde:	2b00      	cmp	r3, #0
 8011ce0:	d101      	bne.n	8011ce6 <LSM303AGR_ACC_W_ZEN+0x26>
    return MEMS_ERROR;
 8011ce2:	2300      	movs	r3, #0
 8011ce4:	e01c      	b.n	8011d20 <LSM303AGR_ACC_W_ZEN+0x60>

  value &= ~LSM303AGR_ACC_ZEN_MASK;
 8011ce6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8011cea:	f023 0304 	bic.w	r3, r3, #4
 8011cee:	b2db      	uxtb	r3, r3
 8011cf0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8011cf4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8011cf8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8011cfc:	4313      	orrs	r3, r2
 8011cfe:	b2db      	uxtb	r3, r3
 8011d00:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 8011d04:	f10d 030f 	add.w	r3, sp, #15
 8011d08:	9801      	ldr	r0, [sp, #4]
 8011d0a:	2120      	movs	r1, #32
 8011d0c:	461a      	mov	r2, r3
 8011d0e:	2301      	movs	r3, #1
 8011d10:	f7ff fac6 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8011d14:	4603      	mov	r3, r0
 8011d16:	2b00      	cmp	r3, #0
 8011d18:	d101      	bne.n	8011d1e <LSM303AGR_ACC_W_ZEN+0x5e>
    return MEMS_ERROR;
 8011d1a:	2300      	movs	r3, #0
 8011d1c:	e000      	b.n	8011d20 <LSM303AGR_ACC_W_ZEN+0x60>

  return MEMS_SUCCESS;
 8011d1e:	2301      	movs	r3, #1
}
 8011d20:	4618      	mov	r0, r3
 8011d22:	b005      	add	sp, #20
 8011d24:	f85d fb04 	ldr.w	pc, [sp], #4
 8011d28:	f3af 8000 	nop.w
 8011d2c:	f3af 8000 	nop.w

08011d30 <LSM303AGR_ACC_R_ZEN>:
* Input          : Pointer to LSM303AGR_ACC_ZEN_t
* Output         : Status of ZEN see LSM303AGR_ACC_ZEN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ZEN(void *handle, LSM303AGR_ACC_ZEN_t *value)
{
 8011d30:	b500      	push	{lr}
 8011d32:	b083      	sub	sp, #12
 8011d34:	9001      	str	r0, [sp, #4]
 8011d36:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, (u8_t *)value, 1) )
 8011d38:	9801      	ldr	r0, [sp, #4]
 8011d3a:	2120      	movs	r1, #32
 8011d3c:	9a00      	ldr	r2, [sp, #0]
 8011d3e:	2301      	movs	r3, #1
 8011d40:	f7ff fad6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8011d44:	4603      	mov	r3, r0
 8011d46:	2b00      	cmp	r3, #0
 8011d48:	d101      	bne.n	8011d4e <LSM303AGR_ACC_R_ZEN+0x1e>
    return MEMS_ERROR;
 8011d4a:	2300      	movs	r3, #0
 8011d4c:	e007      	b.n	8011d5e <LSM303AGR_ACC_R_ZEN+0x2e>

  *value &= LSM303AGR_ACC_ZEN_MASK; //mask
 8011d4e:	9b00      	ldr	r3, [sp, #0]
 8011d50:	781b      	ldrb	r3, [r3, #0]
 8011d52:	f003 0304 	and.w	r3, r3, #4
 8011d56:	b2da      	uxtb	r2, r3
 8011d58:	9b00      	ldr	r3, [sp, #0]
 8011d5a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8011d5c:	2301      	movs	r3, #1
}
 8011d5e:	4618      	mov	r0, r3
 8011d60:	b003      	add	sp, #12
 8011d62:	f85d fb04 	ldr.w	pc, [sp], #4
 8011d66:	bf00      	nop
 8011d68:	f3af 8000 	nop.w
 8011d6c:	f3af 8000 	nop.w

08011d70 <LSM303AGR_ACC_W_LOWPWR_EN>:
* Input          : LSM303AGR_ACC_LPEN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_LOWPWR_EN(void *handle, LSM303AGR_ACC_LPEN_t newValue)
{
 8011d70:	b500      	push	{lr}
 8011d72:	b085      	sub	sp, #20
 8011d74:	9001      	str	r0, [sp, #4]
 8011d76:	460b      	mov	r3, r1
 8011d78:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 8011d7c:	f10d 030f 	add.w	r3, sp, #15
 8011d80:	9801      	ldr	r0, [sp, #4]
 8011d82:	2120      	movs	r1, #32
 8011d84:	461a      	mov	r2, r3
 8011d86:	2301      	movs	r3, #1
 8011d88:	f7ff fab2 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8011d8c:	4603      	mov	r3, r0
 8011d8e:	2b00      	cmp	r3, #0
 8011d90:	d101      	bne.n	8011d96 <LSM303AGR_ACC_W_LOWPWR_EN+0x26>
    return MEMS_ERROR;
 8011d92:	2300      	movs	r3, #0
 8011d94:	e01c      	b.n	8011dd0 <LSM303AGR_ACC_W_LOWPWR_EN+0x60>

  value &= ~LSM303AGR_ACC_LPEN_MASK;
 8011d96:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8011d9a:	f023 0308 	bic.w	r3, r3, #8
 8011d9e:	b2db      	uxtb	r3, r3
 8011da0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8011da4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8011da8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8011dac:	4313      	orrs	r3, r2
 8011dae:	b2db      	uxtb	r3, r3
 8011db0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 8011db4:	f10d 030f 	add.w	r3, sp, #15
 8011db8:	9801      	ldr	r0, [sp, #4]
 8011dba:	2120      	movs	r1, #32
 8011dbc:	461a      	mov	r2, r3
 8011dbe:	2301      	movs	r3, #1
 8011dc0:	f7ff fa6e 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8011dc4:	4603      	mov	r3, r0
 8011dc6:	2b00      	cmp	r3, #0
 8011dc8:	d101      	bne.n	8011dce <LSM303AGR_ACC_W_LOWPWR_EN+0x5e>
    return MEMS_ERROR;
 8011dca:	2300      	movs	r3, #0
 8011dcc:	e000      	b.n	8011dd0 <LSM303AGR_ACC_W_LOWPWR_EN+0x60>

  return MEMS_SUCCESS;
 8011dce:	2301      	movs	r3, #1
}
 8011dd0:	4618      	mov	r0, r3
 8011dd2:	b005      	add	sp, #20
 8011dd4:	f85d fb04 	ldr.w	pc, [sp], #4
 8011dd8:	f3af 8000 	nop.w
 8011ddc:	f3af 8000 	nop.w

08011de0 <LSM303AGR_ACC_R_LOWPWR_EN>:
* Input          : Pointer to LSM303AGR_ACC_LPEN_t
* Output         : Status of LPEN see LSM303AGR_ACC_LPEN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_LOWPWR_EN(void *handle, LSM303AGR_ACC_LPEN_t *value)
{
 8011de0:	b500      	push	{lr}
 8011de2:	b083      	sub	sp, #12
 8011de4:	9001      	str	r0, [sp, #4]
 8011de6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, (u8_t *)value, 1) )
 8011de8:	9801      	ldr	r0, [sp, #4]
 8011dea:	2120      	movs	r1, #32
 8011dec:	9a00      	ldr	r2, [sp, #0]
 8011dee:	2301      	movs	r3, #1
 8011df0:	f7ff fa7e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8011df4:	4603      	mov	r3, r0
 8011df6:	2b00      	cmp	r3, #0
 8011df8:	d101      	bne.n	8011dfe <LSM303AGR_ACC_R_LOWPWR_EN+0x1e>
    return MEMS_ERROR;
 8011dfa:	2300      	movs	r3, #0
 8011dfc:	e007      	b.n	8011e0e <LSM303AGR_ACC_R_LOWPWR_EN+0x2e>

  *value &= LSM303AGR_ACC_LPEN_MASK; //mask
 8011dfe:	9b00      	ldr	r3, [sp, #0]
 8011e00:	781b      	ldrb	r3, [r3, #0]
 8011e02:	f003 0308 	and.w	r3, r3, #8
 8011e06:	b2da      	uxtb	r2, r3
 8011e08:	9b00      	ldr	r3, [sp, #0]
 8011e0a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8011e0c:	2301      	movs	r3, #1
}
 8011e0e:	4618      	mov	r0, r3
 8011e10:	b003      	add	sp, #12
 8011e12:	f85d fb04 	ldr.w	pc, [sp], #4
 8011e16:	bf00      	nop
 8011e18:	f3af 8000 	nop.w
 8011e1c:	f3af 8000 	nop.w

08011e20 <LSM303AGR_ACC_W_hpf_aoi_en_int1>:
* Input          : LSM303AGR_ACC_HPIS1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_hpf_aoi_en_int1(void *handle, LSM303AGR_ACC_HPIS1_t newValue)
{
 8011e20:	b500      	push	{lr}
 8011e22:	b085      	sub	sp, #20
 8011e24:	9001      	str	r0, [sp, #4]
 8011e26:	460b      	mov	r3, r1
 8011e28:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8011e2c:	f10d 030f 	add.w	r3, sp, #15
 8011e30:	9801      	ldr	r0, [sp, #4]
 8011e32:	2121      	movs	r1, #33	; 0x21
 8011e34:	461a      	mov	r2, r3
 8011e36:	2301      	movs	r3, #1
 8011e38:	f7ff fa5a 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8011e3c:	4603      	mov	r3, r0
 8011e3e:	2b00      	cmp	r3, #0
 8011e40:	d101      	bne.n	8011e46 <LSM303AGR_ACC_W_hpf_aoi_en_int1+0x26>
    return MEMS_ERROR;
 8011e42:	2300      	movs	r3, #0
 8011e44:	e01c      	b.n	8011e80 <LSM303AGR_ACC_W_hpf_aoi_en_int1+0x60>

  value &= ~LSM303AGR_ACC_HPIS1_MASK;
 8011e46:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8011e4a:	f023 0301 	bic.w	r3, r3, #1
 8011e4e:	b2db      	uxtb	r3, r3
 8011e50:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8011e54:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8011e58:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8011e5c:	4313      	orrs	r3, r2
 8011e5e:	b2db      	uxtb	r3, r3
 8011e60:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8011e64:	f10d 030f 	add.w	r3, sp, #15
 8011e68:	9801      	ldr	r0, [sp, #4]
 8011e6a:	2121      	movs	r1, #33	; 0x21
 8011e6c:	461a      	mov	r2, r3
 8011e6e:	2301      	movs	r3, #1
 8011e70:	f7ff fa16 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8011e74:	4603      	mov	r3, r0
 8011e76:	2b00      	cmp	r3, #0
 8011e78:	d101      	bne.n	8011e7e <LSM303AGR_ACC_W_hpf_aoi_en_int1+0x5e>
    return MEMS_ERROR;
 8011e7a:	2300      	movs	r3, #0
 8011e7c:	e000      	b.n	8011e80 <LSM303AGR_ACC_W_hpf_aoi_en_int1+0x60>

  return MEMS_SUCCESS;
 8011e7e:	2301      	movs	r3, #1
}
 8011e80:	4618      	mov	r0, r3
 8011e82:	b005      	add	sp, #20
 8011e84:	f85d fb04 	ldr.w	pc, [sp], #4
 8011e88:	f3af 8000 	nop.w
 8011e8c:	f3af 8000 	nop.w

08011e90 <LSM303AGR_ACC_R_hpf_aoi_en_int1>:
* Input          : Pointer to LSM303AGR_ACC_HPIS1_t
* Output         : Status of HPIS1 see LSM303AGR_ACC_HPIS1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_hpf_aoi_en_int1(void *handle, LSM303AGR_ACC_HPIS1_t *value)
{
 8011e90:	b500      	push	{lr}
 8011e92:	b083      	sub	sp, #12
 8011e94:	9001      	str	r0, [sp, #4]
 8011e96:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, (u8_t *)value, 1) )
 8011e98:	9801      	ldr	r0, [sp, #4]
 8011e9a:	2121      	movs	r1, #33	; 0x21
 8011e9c:	9a00      	ldr	r2, [sp, #0]
 8011e9e:	2301      	movs	r3, #1
 8011ea0:	f7ff fa26 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8011ea4:	4603      	mov	r3, r0
 8011ea6:	2b00      	cmp	r3, #0
 8011ea8:	d101      	bne.n	8011eae <LSM303AGR_ACC_R_hpf_aoi_en_int1+0x1e>
    return MEMS_ERROR;
 8011eaa:	2300      	movs	r3, #0
 8011eac:	e007      	b.n	8011ebe <LSM303AGR_ACC_R_hpf_aoi_en_int1+0x2e>

  *value &= LSM303AGR_ACC_HPIS1_MASK; //mask
 8011eae:	9b00      	ldr	r3, [sp, #0]
 8011eb0:	781b      	ldrb	r3, [r3, #0]
 8011eb2:	f003 0301 	and.w	r3, r3, #1
 8011eb6:	b2da      	uxtb	r2, r3
 8011eb8:	9b00      	ldr	r3, [sp, #0]
 8011eba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8011ebc:	2301      	movs	r3, #1
}
 8011ebe:	4618      	mov	r0, r3
 8011ec0:	b003      	add	sp, #12
 8011ec2:	f85d fb04 	ldr.w	pc, [sp], #4
 8011ec6:	bf00      	nop
 8011ec8:	f3af 8000 	nop.w
 8011ecc:	f3af 8000 	nop.w

08011ed0 <LSM303AGR_ACC_W_hpf_aoi_en_int2>:
* Input          : LSM303AGR_ACC_HPIS2_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_hpf_aoi_en_int2(void *handle, LSM303AGR_ACC_HPIS2_t newValue)
{
 8011ed0:	b500      	push	{lr}
 8011ed2:	b085      	sub	sp, #20
 8011ed4:	9001      	str	r0, [sp, #4]
 8011ed6:	460b      	mov	r3, r1
 8011ed8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8011edc:	f10d 030f 	add.w	r3, sp, #15
 8011ee0:	9801      	ldr	r0, [sp, #4]
 8011ee2:	2121      	movs	r1, #33	; 0x21
 8011ee4:	461a      	mov	r2, r3
 8011ee6:	2301      	movs	r3, #1
 8011ee8:	f7ff fa02 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8011eec:	4603      	mov	r3, r0
 8011eee:	2b00      	cmp	r3, #0
 8011ef0:	d101      	bne.n	8011ef6 <LSM303AGR_ACC_W_hpf_aoi_en_int2+0x26>
    return MEMS_ERROR;
 8011ef2:	2300      	movs	r3, #0
 8011ef4:	e01c      	b.n	8011f30 <LSM303AGR_ACC_W_hpf_aoi_en_int2+0x60>

  value &= ~LSM303AGR_ACC_HPIS2_MASK;
 8011ef6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8011efa:	f023 0302 	bic.w	r3, r3, #2
 8011efe:	b2db      	uxtb	r3, r3
 8011f00:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8011f04:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8011f08:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8011f0c:	4313      	orrs	r3, r2
 8011f0e:	b2db      	uxtb	r3, r3
 8011f10:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8011f14:	f10d 030f 	add.w	r3, sp, #15
 8011f18:	9801      	ldr	r0, [sp, #4]
 8011f1a:	2121      	movs	r1, #33	; 0x21
 8011f1c:	461a      	mov	r2, r3
 8011f1e:	2301      	movs	r3, #1
 8011f20:	f7ff f9be 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8011f24:	4603      	mov	r3, r0
 8011f26:	2b00      	cmp	r3, #0
 8011f28:	d101      	bne.n	8011f2e <LSM303AGR_ACC_W_hpf_aoi_en_int2+0x5e>
    return MEMS_ERROR;
 8011f2a:	2300      	movs	r3, #0
 8011f2c:	e000      	b.n	8011f30 <LSM303AGR_ACC_W_hpf_aoi_en_int2+0x60>

  return MEMS_SUCCESS;
 8011f2e:	2301      	movs	r3, #1
}
 8011f30:	4618      	mov	r0, r3
 8011f32:	b005      	add	sp, #20
 8011f34:	f85d fb04 	ldr.w	pc, [sp], #4
 8011f38:	f3af 8000 	nop.w
 8011f3c:	f3af 8000 	nop.w

08011f40 <LSM303AGR_ACC_R_hpf_aoi_en_int2>:
* Input          : Pointer to LSM303AGR_ACC_HPIS2_t
* Output         : Status of HPIS2 see LSM303AGR_ACC_HPIS2_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_hpf_aoi_en_int2(void *handle, LSM303AGR_ACC_HPIS2_t *value)
{
 8011f40:	b500      	push	{lr}
 8011f42:	b083      	sub	sp, #12
 8011f44:	9001      	str	r0, [sp, #4]
 8011f46:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, (u8_t *)value, 1) )
 8011f48:	9801      	ldr	r0, [sp, #4]
 8011f4a:	2121      	movs	r1, #33	; 0x21
 8011f4c:	9a00      	ldr	r2, [sp, #0]
 8011f4e:	2301      	movs	r3, #1
 8011f50:	f7ff f9ce 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8011f54:	4603      	mov	r3, r0
 8011f56:	2b00      	cmp	r3, #0
 8011f58:	d101      	bne.n	8011f5e <LSM303AGR_ACC_R_hpf_aoi_en_int2+0x1e>
    return MEMS_ERROR;
 8011f5a:	2300      	movs	r3, #0
 8011f5c:	e007      	b.n	8011f6e <LSM303AGR_ACC_R_hpf_aoi_en_int2+0x2e>

  *value &= LSM303AGR_ACC_HPIS2_MASK; //mask
 8011f5e:	9b00      	ldr	r3, [sp, #0]
 8011f60:	781b      	ldrb	r3, [r3, #0]
 8011f62:	f003 0302 	and.w	r3, r3, #2
 8011f66:	b2da      	uxtb	r2, r3
 8011f68:	9b00      	ldr	r3, [sp, #0]
 8011f6a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8011f6c:	2301      	movs	r3, #1
}
 8011f6e:	4618      	mov	r0, r3
 8011f70:	b003      	add	sp, #12
 8011f72:	f85d fb04 	ldr.w	pc, [sp], #4
 8011f76:	bf00      	nop
 8011f78:	f3af 8000 	nop.w
 8011f7c:	f3af 8000 	nop.w

08011f80 <LSM303AGR_ACC_W_hpf_click_en>:
* Input          : LSM303AGR_ACC_HPCLICK_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_hpf_click_en(void *handle, LSM303AGR_ACC_HPCLICK_t newValue)
{
 8011f80:	b500      	push	{lr}
 8011f82:	b085      	sub	sp, #20
 8011f84:	9001      	str	r0, [sp, #4]
 8011f86:	460b      	mov	r3, r1
 8011f88:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8011f8c:	f10d 030f 	add.w	r3, sp, #15
 8011f90:	9801      	ldr	r0, [sp, #4]
 8011f92:	2121      	movs	r1, #33	; 0x21
 8011f94:	461a      	mov	r2, r3
 8011f96:	2301      	movs	r3, #1
 8011f98:	f7ff f9aa 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8011f9c:	4603      	mov	r3, r0
 8011f9e:	2b00      	cmp	r3, #0
 8011fa0:	d101      	bne.n	8011fa6 <LSM303AGR_ACC_W_hpf_click_en+0x26>
    return MEMS_ERROR;
 8011fa2:	2300      	movs	r3, #0
 8011fa4:	e01c      	b.n	8011fe0 <LSM303AGR_ACC_W_hpf_click_en+0x60>

  value &= ~LSM303AGR_ACC_HPCLICK_MASK;
 8011fa6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8011faa:	f023 0304 	bic.w	r3, r3, #4
 8011fae:	b2db      	uxtb	r3, r3
 8011fb0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8011fb4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8011fb8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8011fbc:	4313      	orrs	r3, r2
 8011fbe:	b2db      	uxtb	r3, r3
 8011fc0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8011fc4:	f10d 030f 	add.w	r3, sp, #15
 8011fc8:	9801      	ldr	r0, [sp, #4]
 8011fca:	2121      	movs	r1, #33	; 0x21
 8011fcc:	461a      	mov	r2, r3
 8011fce:	2301      	movs	r3, #1
 8011fd0:	f7ff f966 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8011fd4:	4603      	mov	r3, r0
 8011fd6:	2b00      	cmp	r3, #0
 8011fd8:	d101      	bne.n	8011fde <LSM303AGR_ACC_W_hpf_click_en+0x5e>
    return MEMS_ERROR;
 8011fda:	2300      	movs	r3, #0
 8011fdc:	e000      	b.n	8011fe0 <LSM303AGR_ACC_W_hpf_click_en+0x60>

  return MEMS_SUCCESS;
 8011fde:	2301      	movs	r3, #1
}
 8011fe0:	4618      	mov	r0, r3
 8011fe2:	b005      	add	sp, #20
 8011fe4:	f85d fb04 	ldr.w	pc, [sp], #4
 8011fe8:	f3af 8000 	nop.w
 8011fec:	f3af 8000 	nop.w

08011ff0 <LSM303AGR_ACC_R_hpf_click_en>:
* Input          : Pointer to LSM303AGR_ACC_HPCLICK_t
* Output         : Status of HPCLICK see LSM303AGR_ACC_HPCLICK_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_hpf_click_en(void *handle, LSM303AGR_ACC_HPCLICK_t *value)
{
 8011ff0:	b500      	push	{lr}
 8011ff2:	b083      	sub	sp, #12
 8011ff4:	9001      	str	r0, [sp, #4]
 8011ff6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, (u8_t *)value, 1) )
 8011ff8:	9801      	ldr	r0, [sp, #4]
 8011ffa:	2121      	movs	r1, #33	; 0x21
 8011ffc:	9a00      	ldr	r2, [sp, #0]
 8011ffe:	2301      	movs	r3, #1
 8012000:	f7ff f976 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012004:	4603      	mov	r3, r0
 8012006:	2b00      	cmp	r3, #0
 8012008:	d101      	bne.n	801200e <LSM303AGR_ACC_R_hpf_click_en+0x1e>
    return MEMS_ERROR;
 801200a:	2300      	movs	r3, #0
 801200c:	e007      	b.n	801201e <LSM303AGR_ACC_R_hpf_click_en+0x2e>

  *value &= LSM303AGR_ACC_HPCLICK_MASK; //mask
 801200e:	9b00      	ldr	r3, [sp, #0]
 8012010:	781b      	ldrb	r3, [r3, #0]
 8012012:	f003 0304 	and.w	r3, r3, #4
 8012016:	b2da      	uxtb	r2, r3
 8012018:	9b00      	ldr	r3, [sp, #0]
 801201a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801201c:	2301      	movs	r3, #1
}
 801201e:	4618      	mov	r0, r3
 8012020:	b003      	add	sp, #12
 8012022:	f85d fb04 	ldr.w	pc, [sp], #4
 8012026:	bf00      	nop
 8012028:	f3af 8000 	nop.w
 801202c:	f3af 8000 	nop.w

08012030 <LSM303AGR_ACC_W_Data_Filter>:
* Input          : LSM303AGR_ACC_FDS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Data_Filter(void *handle, LSM303AGR_ACC_FDS_t newValue)
{
 8012030:	b500      	push	{lr}
 8012032:	b085      	sub	sp, #20
 8012034:	9001      	str	r0, [sp, #4]
 8012036:	460b      	mov	r3, r1
 8012038:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 801203c:	f10d 030f 	add.w	r3, sp, #15
 8012040:	9801      	ldr	r0, [sp, #4]
 8012042:	2121      	movs	r1, #33	; 0x21
 8012044:	461a      	mov	r2, r3
 8012046:	2301      	movs	r3, #1
 8012048:	f7ff f952 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 801204c:	4603      	mov	r3, r0
 801204e:	2b00      	cmp	r3, #0
 8012050:	d101      	bne.n	8012056 <LSM303AGR_ACC_W_Data_Filter+0x26>
    return MEMS_ERROR;
 8012052:	2300      	movs	r3, #0
 8012054:	e01c      	b.n	8012090 <LSM303AGR_ACC_W_Data_Filter+0x60>

  value &= ~LSM303AGR_ACC_FDS_MASK;
 8012056:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801205a:	f023 0308 	bic.w	r3, r3, #8
 801205e:	b2db      	uxtb	r3, r3
 8012060:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012064:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012068:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801206c:	4313      	orrs	r3, r2
 801206e:	b2db      	uxtb	r3, r3
 8012070:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8012074:	f10d 030f 	add.w	r3, sp, #15
 8012078:	9801      	ldr	r0, [sp, #4]
 801207a:	2121      	movs	r1, #33	; 0x21
 801207c:	461a      	mov	r2, r3
 801207e:	2301      	movs	r3, #1
 8012080:	f7ff f90e 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8012084:	4603      	mov	r3, r0
 8012086:	2b00      	cmp	r3, #0
 8012088:	d101      	bne.n	801208e <LSM303AGR_ACC_W_Data_Filter+0x5e>
    return MEMS_ERROR;
 801208a:	2300      	movs	r3, #0
 801208c:	e000      	b.n	8012090 <LSM303AGR_ACC_W_Data_Filter+0x60>

  return MEMS_SUCCESS;
 801208e:	2301      	movs	r3, #1
}
 8012090:	4618      	mov	r0, r3
 8012092:	b005      	add	sp, #20
 8012094:	f85d fb04 	ldr.w	pc, [sp], #4
 8012098:	f3af 8000 	nop.w
 801209c:	f3af 8000 	nop.w

080120a0 <LSM303AGR_ACC_R_Data_Filter>:
* Input          : Pointer to LSM303AGR_ACC_FDS_t
* Output         : Status of FDS see LSM303AGR_ACC_FDS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Data_Filter(void *handle, LSM303AGR_ACC_FDS_t *value)
{
 80120a0:	b500      	push	{lr}
 80120a2:	b083      	sub	sp, #12
 80120a4:	9001      	str	r0, [sp, #4]
 80120a6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, (u8_t *)value, 1) )
 80120a8:	9801      	ldr	r0, [sp, #4]
 80120aa:	2121      	movs	r1, #33	; 0x21
 80120ac:	9a00      	ldr	r2, [sp, #0]
 80120ae:	2301      	movs	r3, #1
 80120b0:	f7ff f91e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80120b4:	4603      	mov	r3, r0
 80120b6:	2b00      	cmp	r3, #0
 80120b8:	d101      	bne.n	80120be <LSM303AGR_ACC_R_Data_Filter+0x1e>
    return MEMS_ERROR;
 80120ba:	2300      	movs	r3, #0
 80120bc:	e007      	b.n	80120ce <LSM303AGR_ACC_R_Data_Filter+0x2e>

  *value &= LSM303AGR_ACC_FDS_MASK; //mask
 80120be:	9b00      	ldr	r3, [sp, #0]
 80120c0:	781b      	ldrb	r3, [r3, #0]
 80120c2:	f003 0308 	and.w	r3, r3, #8
 80120c6:	b2da      	uxtb	r2, r3
 80120c8:	9b00      	ldr	r3, [sp, #0]
 80120ca:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80120cc:	2301      	movs	r3, #1
}
 80120ce:	4618      	mov	r0, r3
 80120d0:	b003      	add	sp, #12
 80120d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80120d6:	bf00      	nop
 80120d8:	f3af 8000 	nop.w
 80120dc:	f3af 8000 	nop.w

080120e0 <LSM303AGR_ACC_W_hpf_cutoff_freq>:
* Input          : LSM303AGR_ACC_HPCF_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_hpf_cutoff_freq(void *handle, LSM303AGR_ACC_HPCF_t newValue)
{
 80120e0:	b500      	push	{lr}
 80120e2:	b085      	sub	sp, #20
 80120e4:	9001      	str	r0, [sp, #4]
 80120e6:	460b      	mov	r3, r1
 80120e8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 80120ec:	f10d 030f 	add.w	r3, sp, #15
 80120f0:	9801      	ldr	r0, [sp, #4]
 80120f2:	2121      	movs	r1, #33	; 0x21
 80120f4:	461a      	mov	r2, r3
 80120f6:	2301      	movs	r3, #1
 80120f8:	f7ff f8fa 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80120fc:	4603      	mov	r3, r0
 80120fe:	2b00      	cmp	r3, #0
 8012100:	d101      	bne.n	8012106 <LSM303AGR_ACC_W_hpf_cutoff_freq+0x26>
    return MEMS_ERROR;
 8012102:	2300      	movs	r3, #0
 8012104:	e01c      	b.n	8012140 <LSM303AGR_ACC_W_hpf_cutoff_freq+0x60>

  value &= ~LSM303AGR_ACC_HPCF_MASK;
 8012106:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801210a:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 801210e:	b2db      	uxtb	r3, r3
 8012110:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012114:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012118:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801211c:	4313      	orrs	r3, r2
 801211e:	b2db      	uxtb	r3, r3
 8012120:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8012124:	f10d 030f 	add.w	r3, sp, #15
 8012128:	9801      	ldr	r0, [sp, #4]
 801212a:	2121      	movs	r1, #33	; 0x21
 801212c:	461a      	mov	r2, r3
 801212e:	2301      	movs	r3, #1
 8012130:	f7ff f8b6 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8012134:	4603      	mov	r3, r0
 8012136:	2b00      	cmp	r3, #0
 8012138:	d101      	bne.n	801213e <LSM303AGR_ACC_W_hpf_cutoff_freq+0x5e>
    return MEMS_ERROR;
 801213a:	2300      	movs	r3, #0
 801213c:	e000      	b.n	8012140 <LSM303AGR_ACC_W_hpf_cutoff_freq+0x60>

  return MEMS_SUCCESS;
 801213e:	2301      	movs	r3, #1
}
 8012140:	4618      	mov	r0, r3
 8012142:	b005      	add	sp, #20
 8012144:	f85d fb04 	ldr.w	pc, [sp], #4
 8012148:	f3af 8000 	nop.w
 801214c:	f3af 8000 	nop.w

08012150 <LSM303AGR_ACC_R_hpf_cutoff_freq>:
* Input          : Pointer to LSM303AGR_ACC_HPCF_t
* Output         : Status of HPCF see LSM303AGR_ACC_HPCF_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_hpf_cutoff_freq(void *handle, LSM303AGR_ACC_HPCF_t *value)
{
 8012150:	b500      	push	{lr}
 8012152:	b083      	sub	sp, #12
 8012154:	9001      	str	r0, [sp, #4]
 8012156:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, (u8_t *)value, 1) )
 8012158:	9801      	ldr	r0, [sp, #4]
 801215a:	2121      	movs	r1, #33	; 0x21
 801215c:	9a00      	ldr	r2, [sp, #0]
 801215e:	2301      	movs	r3, #1
 8012160:	f7ff f8c6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012164:	4603      	mov	r3, r0
 8012166:	2b00      	cmp	r3, #0
 8012168:	d101      	bne.n	801216e <LSM303AGR_ACC_R_hpf_cutoff_freq+0x1e>
    return MEMS_ERROR;
 801216a:	2300      	movs	r3, #0
 801216c:	e007      	b.n	801217e <LSM303AGR_ACC_R_hpf_cutoff_freq+0x2e>

  *value &= LSM303AGR_ACC_HPCF_MASK; //mask
 801216e:	9b00      	ldr	r3, [sp, #0]
 8012170:	781b      	ldrb	r3, [r3, #0]
 8012172:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8012176:	b2da      	uxtb	r2, r3
 8012178:	9b00      	ldr	r3, [sp, #0]
 801217a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801217c:	2301      	movs	r3, #1
}
 801217e:	4618      	mov	r0, r3
 8012180:	b003      	add	sp, #12
 8012182:	f85d fb04 	ldr.w	pc, [sp], #4
 8012186:	bf00      	nop
 8012188:	f3af 8000 	nop.w
 801218c:	f3af 8000 	nop.w

08012190 <LSM303AGR_ACC_W_hpf_mode>:
* Input          : LSM303AGR_ACC_HPM_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_hpf_mode(void *handle, LSM303AGR_ACC_HPM_t newValue)
{
 8012190:	b500      	push	{lr}
 8012192:	b085      	sub	sp, #20
 8012194:	9001      	str	r0, [sp, #4]
 8012196:	460b      	mov	r3, r1
 8012198:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 801219c:	f10d 030f 	add.w	r3, sp, #15
 80121a0:	9801      	ldr	r0, [sp, #4]
 80121a2:	2121      	movs	r1, #33	; 0x21
 80121a4:	461a      	mov	r2, r3
 80121a6:	2301      	movs	r3, #1
 80121a8:	f7ff f8a2 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80121ac:	4603      	mov	r3, r0
 80121ae:	2b00      	cmp	r3, #0
 80121b0:	d101      	bne.n	80121b6 <LSM303AGR_ACC_W_hpf_mode+0x26>
    return MEMS_ERROR;
 80121b2:	2300      	movs	r3, #0
 80121b4:	e01c      	b.n	80121f0 <LSM303AGR_ACC_W_hpf_mode+0x60>

  value &= ~LSM303AGR_ACC_HPM_MASK;
 80121b6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80121ba:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80121be:	b2db      	uxtb	r3, r3
 80121c0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80121c4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80121c8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80121cc:	4313      	orrs	r3, r2
 80121ce:	b2db      	uxtb	r3, r3
 80121d0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 80121d4:	f10d 030f 	add.w	r3, sp, #15
 80121d8:	9801      	ldr	r0, [sp, #4]
 80121da:	2121      	movs	r1, #33	; 0x21
 80121dc:	461a      	mov	r2, r3
 80121de:	2301      	movs	r3, #1
 80121e0:	f7ff f85e 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 80121e4:	4603      	mov	r3, r0
 80121e6:	2b00      	cmp	r3, #0
 80121e8:	d101      	bne.n	80121ee <LSM303AGR_ACC_W_hpf_mode+0x5e>
    return MEMS_ERROR;
 80121ea:	2300      	movs	r3, #0
 80121ec:	e000      	b.n	80121f0 <LSM303AGR_ACC_W_hpf_mode+0x60>

  return MEMS_SUCCESS;
 80121ee:	2301      	movs	r3, #1
}
 80121f0:	4618      	mov	r0, r3
 80121f2:	b005      	add	sp, #20
 80121f4:	f85d fb04 	ldr.w	pc, [sp], #4
 80121f8:	f3af 8000 	nop.w
 80121fc:	f3af 8000 	nop.w

08012200 <LSM303AGR_ACC_R_hpf_mode>:
* Input          : Pointer to LSM303AGR_ACC_HPM_t
* Output         : Status of HPM see LSM303AGR_ACC_HPM_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_hpf_mode(void *handle, LSM303AGR_ACC_HPM_t *value)
{
 8012200:	b500      	push	{lr}
 8012202:	b083      	sub	sp, #12
 8012204:	9001      	str	r0, [sp, #4]
 8012206:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, (u8_t *)value, 1) )
 8012208:	9801      	ldr	r0, [sp, #4]
 801220a:	2121      	movs	r1, #33	; 0x21
 801220c:	9a00      	ldr	r2, [sp, #0]
 801220e:	2301      	movs	r3, #1
 8012210:	f7ff f86e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012214:	4603      	mov	r3, r0
 8012216:	2b00      	cmp	r3, #0
 8012218:	d101      	bne.n	801221e <LSM303AGR_ACC_R_hpf_mode+0x1e>
    return MEMS_ERROR;
 801221a:	2300      	movs	r3, #0
 801221c:	e007      	b.n	801222e <LSM303AGR_ACC_R_hpf_mode+0x2e>

  *value &= LSM303AGR_ACC_HPM_MASK; //mask
 801221e:	9b00      	ldr	r3, [sp, #0]
 8012220:	781b      	ldrb	r3, [r3, #0]
 8012222:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8012226:	b2da      	uxtb	r2, r3
 8012228:	9b00      	ldr	r3, [sp, #0]
 801222a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801222c:	2301      	movs	r3, #1
}
 801222e:	4618      	mov	r0, r3
 8012230:	b003      	add	sp, #12
 8012232:	f85d fb04 	ldr.w	pc, [sp], #4
 8012236:	bf00      	nop
 8012238:	f3af 8000 	nop.w
 801223c:	f3af 8000 	nop.w

08012240 <LSM303AGR_ACC_W_FIFO_Overrun_on_INT1>:
* Input          : LSM303AGR_ACC_I1_OVERRUN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_Overrun_on_INT1(void *handle, LSM303AGR_ACC_I1_OVERRUN_t newValue)
{
 8012240:	b500      	push	{lr}
 8012242:	b085      	sub	sp, #20
 8012244:	9001      	str	r0, [sp, #4]
 8012246:	460b      	mov	r3, r1
 8012248:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 801224c:	f10d 030f 	add.w	r3, sp, #15
 8012250:	9801      	ldr	r0, [sp, #4]
 8012252:	2122      	movs	r1, #34	; 0x22
 8012254:	461a      	mov	r2, r3
 8012256:	2301      	movs	r3, #1
 8012258:	f7ff f84a 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 801225c:	4603      	mov	r3, r0
 801225e:	2b00      	cmp	r3, #0
 8012260:	d101      	bne.n	8012266 <LSM303AGR_ACC_W_FIFO_Overrun_on_INT1+0x26>
    return MEMS_ERROR;
 8012262:	2300      	movs	r3, #0
 8012264:	e01c      	b.n	80122a0 <LSM303AGR_ACC_W_FIFO_Overrun_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_OVERRUN_MASK;
 8012266:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801226a:	f023 0302 	bic.w	r3, r3, #2
 801226e:	b2db      	uxtb	r3, r3
 8012270:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012274:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012278:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801227c:	4313      	orrs	r3, r2
 801227e:	b2db      	uxtb	r3, r3
 8012280:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8012284:	f10d 030f 	add.w	r3, sp, #15
 8012288:	9801      	ldr	r0, [sp, #4]
 801228a:	2122      	movs	r1, #34	; 0x22
 801228c:	461a      	mov	r2, r3
 801228e:	2301      	movs	r3, #1
 8012290:	f7ff f806 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8012294:	4603      	mov	r3, r0
 8012296:	2b00      	cmp	r3, #0
 8012298:	d101      	bne.n	801229e <LSM303AGR_ACC_W_FIFO_Overrun_on_INT1+0x5e>
    return MEMS_ERROR;
 801229a:	2300      	movs	r3, #0
 801229c:	e000      	b.n	80122a0 <LSM303AGR_ACC_W_FIFO_Overrun_on_INT1+0x60>

  return MEMS_SUCCESS;
 801229e:	2301      	movs	r3, #1
}
 80122a0:	4618      	mov	r0, r3
 80122a2:	b005      	add	sp, #20
 80122a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80122a8:	f3af 8000 	nop.w
 80122ac:	f3af 8000 	nop.w

080122b0 <LSM303AGR_ACC_R_FIFO_Overrun_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_OVERRUN_t
* Output         : Status of I1_OVERRUN see LSM303AGR_ACC_I1_OVERRUN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_Overrun_on_INT1(void *handle, LSM303AGR_ACC_I1_OVERRUN_t *value)
{
 80122b0:	b500      	push	{lr}
 80122b2:	b083      	sub	sp, #12
 80122b4:	9001      	str	r0, [sp, #4]
 80122b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 80122b8:	9801      	ldr	r0, [sp, #4]
 80122ba:	2122      	movs	r1, #34	; 0x22
 80122bc:	9a00      	ldr	r2, [sp, #0]
 80122be:	2301      	movs	r3, #1
 80122c0:	f7ff f816 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80122c4:	4603      	mov	r3, r0
 80122c6:	2b00      	cmp	r3, #0
 80122c8:	d101      	bne.n	80122ce <LSM303AGR_ACC_R_FIFO_Overrun_on_INT1+0x1e>
    return MEMS_ERROR;
 80122ca:	2300      	movs	r3, #0
 80122cc:	e007      	b.n	80122de <LSM303AGR_ACC_R_FIFO_Overrun_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_OVERRUN_MASK; //mask
 80122ce:	9b00      	ldr	r3, [sp, #0]
 80122d0:	781b      	ldrb	r3, [r3, #0]
 80122d2:	f003 0302 	and.w	r3, r3, #2
 80122d6:	b2da      	uxtb	r2, r3
 80122d8:	9b00      	ldr	r3, [sp, #0]
 80122da:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80122dc:	2301      	movs	r3, #1
}
 80122de:	4618      	mov	r0, r3
 80122e0:	b003      	add	sp, #12
 80122e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80122e6:	bf00      	nop
 80122e8:	f3af 8000 	nop.w
 80122ec:	f3af 8000 	nop.w

080122f0 <LSM303AGR_ACC_W_FIFO_Watermark_on_INT1>:
* Input          : LSM303AGR_ACC_I1_WTM_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_Watermark_on_INT1(void *handle, LSM303AGR_ACC_I1_WTM_t newValue)
{
 80122f0:	b500      	push	{lr}
 80122f2:	b085      	sub	sp, #20
 80122f4:	9001      	str	r0, [sp, #4]
 80122f6:	460b      	mov	r3, r1
 80122f8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 80122fc:	f10d 030f 	add.w	r3, sp, #15
 8012300:	9801      	ldr	r0, [sp, #4]
 8012302:	2122      	movs	r1, #34	; 0x22
 8012304:	461a      	mov	r2, r3
 8012306:	2301      	movs	r3, #1
 8012308:	f7fe fff2 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 801230c:	4603      	mov	r3, r0
 801230e:	2b00      	cmp	r3, #0
 8012310:	d101      	bne.n	8012316 <LSM303AGR_ACC_W_FIFO_Watermark_on_INT1+0x26>
    return MEMS_ERROR;
 8012312:	2300      	movs	r3, #0
 8012314:	e01c      	b.n	8012350 <LSM303AGR_ACC_W_FIFO_Watermark_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_WTM_MASK;
 8012316:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801231a:	f023 0304 	bic.w	r3, r3, #4
 801231e:	b2db      	uxtb	r3, r3
 8012320:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012324:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012328:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801232c:	4313      	orrs	r3, r2
 801232e:	b2db      	uxtb	r3, r3
 8012330:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8012334:	f10d 030f 	add.w	r3, sp, #15
 8012338:	9801      	ldr	r0, [sp, #4]
 801233a:	2122      	movs	r1, #34	; 0x22
 801233c:	461a      	mov	r2, r3
 801233e:	2301      	movs	r3, #1
 8012340:	f7fe ffae 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8012344:	4603      	mov	r3, r0
 8012346:	2b00      	cmp	r3, #0
 8012348:	d101      	bne.n	801234e <LSM303AGR_ACC_W_FIFO_Watermark_on_INT1+0x5e>
    return MEMS_ERROR;
 801234a:	2300      	movs	r3, #0
 801234c:	e000      	b.n	8012350 <LSM303AGR_ACC_W_FIFO_Watermark_on_INT1+0x60>

  return MEMS_SUCCESS;
 801234e:	2301      	movs	r3, #1
}
 8012350:	4618      	mov	r0, r3
 8012352:	b005      	add	sp, #20
 8012354:	f85d fb04 	ldr.w	pc, [sp], #4
 8012358:	f3af 8000 	nop.w
 801235c:	f3af 8000 	nop.w

08012360 <LSM303AGR_ACC_R_FIFO_Watermark_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_WTM_t
* Output         : Status of I1_WTM see LSM303AGR_ACC_I1_WTM_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_Watermark_on_INT1(void *handle, LSM303AGR_ACC_I1_WTM_t *value)
{
 8012360:	b500      	push	{lr}
 8012362:	b083      	sub	sp, #12
 8012364:	9001      	str	r0, [sp, #4]
 8012366:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 8012368:	9801      	ldr	r0, [sp, #4]
 801236a:	2122      	movs	r1, #34	; 0x22
 801236c:	9a00      	ldr	r2, [sp, #0]
 801236e:	2301      	movs	r3, #1
 8012370:	f7fe ffbe 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012374:	4603      	mov	r3, r0
 8012376:	2b00      	cmp	r3, #0
 8012378:	d101      	bne.n	801237e <LSM303AGR_ACC_R_FIFO_Watermark_on_INT1+0x1e>
    return MEMS_ERROR;
 801237a:	2300      	movs	r3, #0
 801237c:	e007      	b.n	801238e <LSM303AGR_ACC_R_FIFO_Watermark_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_WTM_MASK; //mask
 801237e:	9b00      	ldr	r3, [sp, #0]
 8012380:	781b      	ldrb	r3, [r3, #0]
 8012382:	f003 0304 	and.w	r3, r3, #4
 8012386:	b2da      	uxtb	r2, r3
 8012388:	9b00      	ldr	r3, [sp, #0]
 801238a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801238c:	2301      	movs	r3, #1
}
 801238e:	4618      	mov	r0, r3
 8012390:	b003      	add	sp, #12
 8012392:	f85d fb04 	ldr.w	pc, [sp], #4
 8012396:	bf00      	nop
 8012398:	f3af 8000 	nop.w
 801239c:	f3af 8000 	nop.w

080123a0 <LSM303AGR_ACC_W_FIFO_DRDY2_on_INT1>:
* Input          : LSM303AGR_ACC_I1_DRDY2_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_DRDY2_on_INT1(void *handle, LSM303AGR_ACC_I1_DRDY2_t newValue)
{
 80123a0:	b500      	push	{lr}
 80123a2:	b085      	sub	sp, #20
 80123a4:	9001      	str	r0, [sp, #4]
 80123a6:	460b      	mov	r3, r1
 80123a8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 80123ac:	f10d 030f 	add.w	r3, sp, #15
 80123b0:	9801      	ldr	r0, [sp, #4]
 80123b2:	2122      	movs	r1, #34	; 0x22
 80123b4:	461a      	mov	r2, r3
 80123b6:	2301      	movs	r3, #1
 80123b8:	f7fe ff9a 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80123bc:	4603      	mov	r3, r0
 80123be:	2b00      	cmp	r3, #0
 80123c0:	d101      	bne.n	80123c6 <LSM303AGR_ACC_W_FIFO_DRDY2_on_INT1+0x26>
    return MEMS_ERROR;
 80123c2:	2300      	movs	r3, #0
 80123c4:	e01c      	b.n	8012400 <LSM303AGR_ACC_W_FIFO_DRDY2_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_DRDY2_MASK;
 80123c6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80123ca:	f023 0308 	bic.w	r3, r3, #8
 80123ce:	b2db      	uxtb	r3, r3
 80123d0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80123d4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80123d8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80123dc:	4313      	orrs	r3, r2
 80123de:	b2db      	uxtb	r3, r3
 80123e0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 80123e4:	f10d 030f 	add.w	r3, sp, #15
 80123e8:	9801      	ldr	r0, [sp, #4]
 80123ea:	2122      	movs	r1, #34	; 0x22
 80123ec:	461a      	mov	r2, r3
 80123ee:	2301      	movs	r3, #1
 80123f0:	f7fe ff56 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 80123f4:	4603      	mov	r3, r0
 80123f6:	2b00      	cmp	r3, #0
 80123f8:	d101      	bne.n	80123fe <LSM303AGR_ACC_W_FIFO_DRDY2_on_INT1+0x5e>
    return MEMS_ERROR;
 80123fa:	2300      	movs	r3, #0
 80123fc:	e000      	b.n	8012400 <LSM303AGR_ACC_W_FIFO_DRDY2_on_INT1+0x60>

  return MEMS_SUCCESS;
 80123fe:	2301      	movs	r3, #1
}
 8012400:	4618      	mov	r0, r3
 8012402:	b005      	add	sp, #20
 8012404:	f85d fb04 	ldr.w	pc, [sp], #4
 8012408:	f3af 8000 	nop.w
 801240c:	f3af 8000 	nop.w

08012410 <LSM303AGR_ACC_R_FIFO_DRDY2_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_DRDY2_t
* Output         : Status of I1_DRDY2 see LSM303AGR_ACC_I1_DRDY2_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_DRDY2_on_INT1(void *handle, LSM303AGR_ACC_I1_DRDY2_t *value)
{
 8012410:	b500      	push	{lr}
 8012412:	b083      	sub	sp, #12
 8012414:	9001      	str	r0, [sp, #4]
 8012416:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 8012418:	9801      	ldr	r0, [sp, #4]
 801241a:	2122      	movs	r1, #34	; 0x22
 801241c:	9a00      	ldr	r2, [sp, #0]
 801241e:	2301      	movs	r3, #1
 8012420:	f7fe ff66 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012424:	4603      	mov	r3, r0
 8012426:	2b00      	cmp	r3, #0
 8012428:	d101      	bne.n	801242e <LSM303AGR_ACC_R_FIFO_DRDY2_on_INT1+0x1e>
    return MEMS_ERROR;
 801242a:	2300      	movs	r3, #0
 801242c:	e007      	b.n	801243e <LSM303AGR_ACC_R_FIFO_DRDY2_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_DRDY2_MASK; //mask
 801242e:	9b00      	ldr	r3, [sp, #0]
 8012430:	781b      	ldrb	r3, [r3, #0]
 8012432:	f003 0308 	and.w	r3, r3, #8
 8012436:	b2da      	uxtb	r2, r3
 8012438:	9b00      	ldr	r3, [sp, #0]
 801243a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801243c:	2301      	movs	r3, #1
}
 801243e:	4618      	mov	r0, r3
 8012440:	b003      	add	sp, #12
 8012442:	f85d fb04 	ldr.w	pc, [sp], #4
 8012446:	bf00      	nop
 8012448:	f3af 8000 	nop.w
 801244c:	f3af 8000 	nop.w

08012450 <LSM303AGR_ACC_W_FIFO_DRDY1_on_INT1>:
* Input          : LSM303AGR_ACC_I1_DRDY1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_DRDY1_on_INT1(void *handle, LSM303AGR_ACC_I1_DRDY1_t newValue)
{
 8012450:	b500      	push	{lr}
 8012452:	b085      	sub	sp, #20
 8012454:	9001      	str	r0, [sp, #4]
 8012456:	460b      	mov	r3, r1
 8012458:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 801245c:	f10d 030f 	add.w	r3, sp, #15
 8012460:	9801      	ldr	r0, [sp, #4]
 8012462:	2122      	movs	r1, #34	; 0x22
 8012464:	461a      	mov	r2, r3
 8012466:	2301      	movs	r3, #1
 8012468:	f7fe ff42 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 801246c:	4603      	mov	r3, r0
 801246e:	2b00      	cmp	r3, #0
 8012470:	d101      	bne.n	8012476 <LSM303AGR_ACC_W_FIFO_DRDY1_on_INT1+0x26>
    return MEMS_ERROR;
 8012472:	2300      	movs	r3, #0
 8012474:	e01c      	b.n	80124b0 <LSM303AGR_ACC_W_FIFO_DRDY1_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_DRDY1_MASK;
 8012476:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801247a:	f023 0310 	bic.w	r3, r3, #16
 801247e:	b2db      	uxtb	r3, r3
 8012480:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012484:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012488:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801248c:	4313      	orrs	r3, r2
 801248e:	b2db      	uxtb	r3, r3
 8012490:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8012494:	f10d 030f 	add.w	r3, sp, #15
 8012498:	9801      	ldr	r0, [sp, #4]
 801249a:	2122      	movs	r1, #34	; 0x22
 801249c:	461a      	mov	r2, r3
 801249e:	2301      	movs	r3, #1
 80124a0:	f7fe fefe 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 80124a4:	4603      	mov	r3, r0
 80124a6:	2b00      	cmp	r3, #0
 80124a8:	d101      	bne.n	80124ae <LSM303AGR_ACC_W_FIFO_DRDY1_on_INT1+0x5e>
    return MEMS_ERROR;
 80124aa:	2300      	movs	r3, #0
 80124ac:	e000      	b.n	80124b0 <LSM303AGR_ACC_W_FIFO_DRDY1_on_INT1+0x60>

  return MEMS_SUCCESS;
 80124ae:	2301      	movs	r3, #1
}
 80124b0:	4618      	mov	r0, r3
 80124b2:	b005      	add	sp, #20
 80124b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80124b8:	f3af 8000 	nop.w
 80124bc:	f3af 8000 	nop.w

080124c0 <LSM303AGR_ACC_R_FIFO_DRDY1_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_DRDY1_t
* Output         : Status of I1_DRDY1 see LSM303AGR_ACC_I1_DRDY1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_DRDY1_on_INT1(void *handle, LSM303AGR_ACC_I1_DRDY1_t *value)
{
 80124c0:	b500      	push	{lr}
 80124c2:	b083      	sub	sp, #12
 80124c4:	9001      	str	r0, [sp, #4]
 80124c6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 80124c8:	9801      	ldr	r0, [sp, #4]
 80124ca:	2122      	movs	r1, #34	; 0x22
 80124cc:	9a00      	ldr	r2, [sp, #0]
 80124ce:	2301      	movs	r3, #1
 80124d0:	f7fe ff0e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80124d4:	4603      	mov	r3, r0
 80124d6:	2b00      	cmp	r3, #0
 80124d8:	d101      	bne.n	80124de <LSM303AGR_ACC_R_FIFO_DRDY1_on_INT1+0x1e>
    return MEMS_ERROR;
 80124da:	2300      	movs	r3, #0
 80124dc:	e007      	b.n	80124ee <LSM303AGR_ACC_R_FIFO_DRDY1_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_DRDY1_MASK; //mask
 80124de:	9b00      	ldr	r3, [sp, #0]
 80124e0:	781b      	ldrb	r3, [r3, #0]
 80124e2:	f003 0310 	and.w	r3, r3, #16
 80124e6:	b2da      	uxtb	r2, r3
 80124e8:	9b00      	ldr	r3, [sp, #0]
 80124ea:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80124ec:	2301      	movs	r3, #1
}
 80124ee:	4618      	mov	r0, r3
 80124f0:	b003      	add	sp, #12
 80124f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80124f6:	bf00      	nop
 80124f8:	f3af 8000 	nop.w
 80124fc:	f3af 8000 	nop.w

08012500 <LSM303AGR_ACC_W_FIFO_AOL2_on_INT1>:
* Input          : LSM303AGR_ACC_I1_AOI2_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_AOL2_on_INT1(void *handle, LSM303AGR_ACC_I1_AOI2_t newValue)
{
 8012500:	b500      	push	{lr}
 8012502:	b085      	sub	sp, #20
 8012504:	9001      	str	r0, [sp, #4]
 8012506:	460b      	mov	r3, r1
 8012508:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 801250c:	f10d 030f 	add.w	r3, sp, #15
 8012510:	9801      	ldr	r0, [sp, #4]
 8012512:	2122      	movs	r1, #34	; 0x22
 8012514:	461a      	mov	r2, r3
 8012516:	2301      	movs	r3, #1
 8012518:	f7fe feea 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 801251c:	4603      	mov	r3, r0
 801251e:	2b00      	cmp	r3, #0
 8012520:	d101      	bne.n	8012526 <LSM303AGR_ACC_W_FIFO_AOL2_on_INT1+0x26>
    return MEMS_ERROR;
 8012522:	2300      	movs	r3, #0
 8012524:	e01c      	b.n	8012560 <LSM303AGR_ACC_W_FIFO_AOL2_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_AOI2_MASK;
 8012526:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801252a:	f023 0320 	bic.w	r3, r3, #32
 801252e:	b2db      	uxtb	r3, r3
 8012530:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012534:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012538:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801253c:	4313      	orrs	r3, r2
 801253e:	b2db      	uxtb	r3, r3
 8012540:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8012544:	f10d 030f 	add.w	r3, sp, #15
 8012548:	9801      	ldr	r0, [sp, #4]
 801254a:	2122      	movs	r1, #34	; 0x22
 801254c:	461a      	mov	r2, r3
 801254e:	2301      	movs	r3, #1
 8012550:	f7fe fea6 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8012554:	4603      	mov	r3, r0
 8012556:	2b00      	cmp	r3, #0
 8012558:	d101      	bne.n	801255e <LSM303AGR_ACC_W_FIFO_AOL2_on_INT1+0x5e>
    return MEMS_ERROR;
 801255a:	2300      	movs	r3, #0
 801255c:	e000      	b.n	8012560 <LSM303AGR_ACC_W_FIFO_AOL2_on_INT1+0x60>

  return MEMS_SUCCESS;
 801255e:	2301      	movs	r3, #1
}
 8012560:	4618      	mov	r0, r3
 8012562:	b005      	add	sp, #20
 8012564:	f85d fb04 	ldr.w	pc, [sp], #4
 8012568:	f3af 8000 	nop.w
 801256c:	f3af 8000 	nop.w

08012570 <LSM303AGR_ACC_R_FIFO_AOL2_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_AOI2_t
* Output         : Status of I1_AOI2 see LSM303AGR_ACC_I1_AOI2_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_AOL2_on_INT1(void *handle, LSM303AGR_ACC_I1_AOI2_t *value)
{
 8012570:	b500      	push	{lr}
 8012572:	b083      	sub	sp, #12
 8012574:	9001      	str	r0, [sp, #4]
 8012576:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 8012578:	9801      	ldr	r0, [sp, #4]
 801257a:	2122      	movs	r1, #34	; 0x22
 801257c:	9a00      	ldr	r2, [sp, #0]
 801257e:	2301      	movs	r3, #1
 8012580:	f7fe feb6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012584:	4603      	mov	r3, r0
 8012586:	2b00      	cmp	r3, #0
 8012588:	d101      	bne.n	801258e <LSM303AGR_ACC_R_FIFO_AOL2_on_INT1+0x1e>
    return MEMS_ERROR;
 801258a:	2300      	movs	r3, #0
 801258c:	e007      	b.n	801259e <LSM303AGR_ACC_R_FIFO_AOL2_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_AOI2_MASK; //mask
 801258e:	9b00      	ldr	r3, [sp, #0]
 8012590:	781b      	ldrb	r3, [r3, #0]
 8012592:	f003 0320 	and.w	r3, r3, #32
 8012596:	b2da      	uxtb	r2, r3
 8012598:	9b00      	ldr	r3, [sp, #0]
 801259a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801259c:	2301      	movs	r3, #1
}
 801259e:	4618      	mov	r0, r3
 80125a0:	b003      	add	sp, #12
 80125a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80125a6:	bf00      	nop
 80125a8:	f3af 8000 	nop.w
 80125ac:	f3af 8000 	nop.w

080125b0 <LSM303AGR_ACC_W_FIFO_AOL1_on_INT1>:
* Input          : LSM303AGR_ACC_I1_AOI1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_AOL1_on_INT1(void *handle, LSM303AGR_ACC_I1_AOI1_t newValue)
{
 80125b0:	b500      	push	{lr}
 80125b2:	b085      	sub	sp, #20
 80125b4:	9001      	str	r0, [sp, #4]
 80125b6:	460b      	mov	r3, r1
 80125b8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 80125bc:	f10d 030f 	add.w	r3, sp, #15
 80125c0:	9801      	ldr	r0, [sp, #4]
 80125c2:	2122      	movs	r1, #34	; 0x22
 80125c4:	461a      	mov	r2, r3
 80125c6:	2301      	movs	r3, #1
 80125c8:	f7fe fe92 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80125cc:	4603      	mov	r3, r0
 80125ce:	2b00      	cmp	r3, #0
 80125d0:	d101      	bne.n	80125d6 <LSM303AGR_ACC_W_FIFO_AOL1_on_INT1+0x26>
    return MEMS_ERROR;
 80125d2:	2300      	movs	r3, #0
 80125d4:	e01c      	b.n	8012610 <LSM303AGR_ACC_W_FIFO_AOL1_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_AOI1_MASK;
 80125d6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80125da:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80125de:	b2db      	uxtb	r3, r3
 80125e0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80125e4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80125e8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80125ec:	4313      	orrs	r3, r2
 80125ee:	b2db      	uxtb	r3, r3
 80125f0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 80125f4:	f10d 030f 	add.w	r3, sp, #15
 80125f8:	9801      	ldr	r0, [sp, #4]
 80125fa:	2122      	movs	r1, #34	; 0x22
 80125fc:	461a      	mov	r2, r3
 80125fe:	2301      	movs	r3, #1
 8012600:	f7fe fe4e 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8012604:	4603      	mov	r3, r0
 8012606:	2b00      	cmp	r3, #0
 8012608:	d101      	bne.n	801260e <LSM303AGR_ACC_W_FIFO_AOL1_on_INT1+0x5e>
    return MEMS_ERROR;
 801260a:	2300      	movs	r3, #0
 801260c:	e000      	b.n	8012610 <LSM303AGR_ACC_W_FIFO_AOL1_on_INT1+0x60>

  return MEMS_SUCCESS;
 801260e:	2301      	movs	r3, #1
}
 8012610:	4618      	mov	r0, r3
 8012612:	b005      	add	sp, #20
 8012614:	f85d fb04 	ldr.w	pc, [sp], #4
 8012618:	f3af 8000 	nop.w
 801261c:	f3af 8000 	nop.w

08012620 <LSM303AGR_ACC_R_FIFO_AOL1_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_AOI1_t
* Output         : Status of I1_AOI1 see LSM303AGR_ACC_I1_AOI1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_AOL1_on_INT1(void *handle, LSM303AGR_ACC_I1_AOI1_t *value)
{
 8012620:	b500      	push	{lr}
 8012622:	b083      	sub	sp, #12
 8012624:	9001      	str	r0, [sp, #4]
 8012626:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 8012628:	9801      	ldr	r0, [sp, #4]
 801262a:	2122      	movs	r1, #34	; 0x22
 801262c:	9a00      	ldr	r2, [sp, #0]
 801262e:	2301      	movs	r3, #1
 8012630:	f7fe fe5e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012634:	4603      	mov	r3, r0
 8012636:	2b00      	cmp	r3, #0
 8012638:	d101      	bne.n	801263e <LSM303AGR_ACC_R_FIFO_AOL1_on_INT1+0x1e>
    return MEMS_ERROR;
 801263a:	2300      	movs	r3, #0
 801263c:	e007      	b.n	801264e <LSM303AGR_ACC_R_FIFO_AOL1_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_AOI1_MASK; //mask
 801263e:	9b00      	ldr	r3, [sp, #0]
 8012640:	781b      	ldrb	r3, [r3, #0]
 8012642:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8012646:	b2da      	uxtb	r2, r3
 8012648:	9b00      	ldr	r3, [sp, #0]
 801264a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801264c:	2301      	movs	r3, #1
}
 801264e:	4618      	mov	r0, r3
 8012650:	b003      	add	sp, #12
 8012652:	f85d fb04 	ldr.w	pc, [sp], #4
 8012656:	bf00      	nop
 8012658:	f3af 8000 	nop.w
 801265c:	f3af 8000 	nop.w

08012660 <LSM303AGR_ACC_W_FIFO_Click_on_INT1>:
* Input          : LSM303AGR_ACC_I1_CLICK_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_Click_on_INT1(void *handle, LSM303AGR_ACC_I1_CLICK_t newValue)
{
 8012660:	b500      	push	{lr}
 8012662:	b085      	sub	sp, #20
 8012664:	9001      	str	r0, [sp, #4]
 8012666:	460b      	mov	r3, r1
 8012668:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 801266c:	f10d 030f 	add.w	r3, sp, #15
 8012670:	9801      	ldr	r0, [sp, #4]
 8012672:	2122      	movs	r1, #34	; 0x22
 8012674:	461a      	mov	r2, r3
 8012676:	2301      	movs	r3, #1
 8012678:	f7fe fe3a 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 801267c:	4603      	mov	r3, r0
 801267e:	2b00      	cmp	r3, #0
 8012680:	d101      	bne.n	8012686 <LSM303AGR_ACC_W_FIFO_Click_on_INT1+0x26>
    return MEMS_ERROR;
 8012682:	2300      	movs	r3, #0
 8012684:	e01c      	b.n	80126c0 <LSM303AGR_ACC_W_FIFO_Click_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_CLICK_MASK;
 8012686:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801268a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 801268e:	b2db      	uxtb	r3, r3
 8012690:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012694:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012698:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801269c:	4313      	orrs	r3, r2
 801269e:	b2db      	uxtb	r3, r3
 80126a0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 80126a4:	f10d 030f 	add.w	r3, sp, #15
 80126a8:	9801      	ldr	r0, [sp, #4]
 80126aa:	2122      	movs	r1, #34	; 0x22
 80126ac:	461a      	mov	r2, r3
 80126ae:	2301      	movs	r3, #1
 80126b0:	f7fe fdf6 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 80126b4:	4603      	mov	r3, r0
 80126b6:	2b00      	cmp	r3, #0
 80126b8:	d101      	bne.n	80126be <LSM303AGR_ACC_W_FIFO_Click_on_INT1+0x5e>
    return MEMS_ERROR;
 80126ba:	2300      	movs	r3, #0
 80126bc:	e000      	b.n	80126c0 <LSM303AGR_ACC_W_FIFO_Click_on_INT1+0x60>

  return MEMS_SUCCESS;
 80126be:	2301      	movs	r3, #1
}
 80126c0:	4618      	mov	r0, r3
 80126c2:	b005      	add	sp, #20
 80126c4:	f85d fb04 	ldr.w	pc, [sp], #4
 80126c8:	f3af 8000 	nop.w
 80126cc:	f3af 8000 	nop.w

080126d0 <LSM303AGR_ACC_R_FIFO_Click_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_CLICK_t
* Output         : Status of I1_CLICK see LSM303AGR_ACC_I1_CLICK_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_Click_on_INT1(void *handle, LSM303AGR_ACC_I1_CLICK_t *value)
{
 80126d0:	b500      	push	{lr}
 80126d2:	b083      	sub	sp, #12
 80126d4:	9001      	str	r0, [sp, #4]
 80126d6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 80126d8:	9801      	ldr	r0, [sp, #4]
 80126da:	2122      	movs	r1, #34	; 0x22
 80126dc:	9a00      	ldr	r2, [sp, #0]
 80126de:	2301      	movs	r3, #1
 80126e0:	f7fe fe06 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80126e4:	4603      	mov	r3, r0
 80126e6:	2b00      	cmp	r3, #0
 80126e8:	d101      	bne.n	80126ee <LSM303AGR_ACC_R_FIFO_Click_on_INT1+0x1e>
    return MEMS_ERROR;
 80126ea:	2300      	movs	r3, #0
 80126ec:	e007      	b.n	80126fe <LSM303AGR_ACC_R_FIFO_Click_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_CLICK_MASK; //mask
 80126ee:	9b00      	ldr	r3, [sp, #0]
 80126f0:	781b      	ldrb	r3, [r3, #0]
 80126f2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80126f6:	b2da      	uxtb	r2, r3
 80126f8:	9b00      	ldr	r3, [sp, #0]
 80126fa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80126fc:	2301      	movs	r3, #1
}
 80126fe:	4618      	mov	r0, r3
 8012700:	b003      	add	sp, #12
 8012702:	f85d fb04 	ldr.w	pc, [sp], #4
 8012706:	bf00      	nop
 8012708:	f3af 8000 	nop.w
 801270c:	f3af 8000 	nop.w

08012710 <LSM303AGR_ACC_W_SPI_mode>:
* Input          : LSM303AGR_ACC_SIM_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_SPI_mode(void *handle, LSM303AGR_ACC_SIM_t newValue)
{
 8012710:	b500      	push	{lr}
 8012712:	b085      	sub	sp, #20
 8012714:	9001      	str	r0, [sp, #4]
 8012716:	460b      	mov	r3, r1
 8012718:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 801271c:	f10d 030f 	add.w	r3, sp, #15
 8012720:	9801      	ldr	r0, [sp, #4]
 8012722:	2123      	movs	r1, #35	; 0x23
 8012724:	461a      	mov	r2, r3
 8012726:	2301      	movs	r3, #1
 8012728:	f7fe fde2 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 801272c:	4603      	mov	r3, r0
 801272e:	2b00      	cmp	r3, #0
 8012730:	d101      	bne.n	8012736 <LSM303AGR_ACC_W_SPI_mode+0x26>
    return MEMS_ERROR;
 8012732:	2300      	movs	r3, #0
 8012734:	e01c      	b.n	8012770 <LSM303AGR_ACC_W_SPI_mode+0x60>

  value &= ~LSM303AGR_ACC_SIM_MASK;
 8012736:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801273a:	f023 0301 	bic.w	r3, r3, #1
 801273e:	b2db      	uxtb	r3, r3
 8012740:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012744:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012748:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801274c:	4313      	orrs	r3, r2
 801274e:	b2db      	uxtb	r3, r3
 8012750:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 8012754:	f10d 030f 	add.w	r3, sp, #15
 8012758:	9801      	ldr	r0, [sp, #4]
 801275a:	2123      	movs	r1, #35	; 0x23
 801275c:	461a      	mov	r2, r3
 801275e:	2301      	movs	r3, #1
 8012760:	f7fe fd9e 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8012764:	4603      	mov	r3, r0
 8012766:	2b00      	cmp	r3, #0
 8012768:	d101      	bne.n	801276e <LSM303AGR_ACC_W_SPI_mode+0x5e>
    return MEMS_ERROR;
 801276a:	2300      	movs	r3, #0
 801276c:	e000      	b.n	8012770 <LSM303AGR_ACC_W_SPI_mode+0x60>

  return MEMS_SUCCESS;
 801276e:	2301      	movs	r3, #1
}
 8012770:	4618      	mov	r0, r3
 8012772:	b005      	add	sp, #20
 8012774:	f85d fb04 	ldr.w	pc, [sp], #4
 8012778:	f3af 8000 	nop.w
 801277c:	f3af 8000 	nop.w

08012780 <LSM303AGR_ACC_R_SPI_mode>:
* Input          : Pointer to LSM303AGR_ACC_SIM_t
* Output         : Status of SIM see LSM303AGR_ACC_SIM_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_SPI_mode(void *handle, LSM303AGR_ACC_SIM_t *value)
{
 8012780:	b500      	push	{lr}
 8012782:	b083      	sub	sp, #12
 8012784:	9001      	str	r0, [sp, #4]
 8012786:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
 8012788:	9801      	ldr	r0, [sp, #4]
 801278a:	2123      	movs	r1, #35	; 0x23
 801278c:	9a00      	ldr	r2, [sp, #0]
 801278e:	2301      	movs	r3, #1
 8012790:	f7fe fdae 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012794:	4603      	mov	r3, r0
 8012796:	2b00      	cmp	r3, #0
 8012798:	d101      	bne.n	801279e <LSM303AGR_ACC_R_SPI_mode+0x1e>
    return MEMS_ERROR;
 801279a:	2300      	movs	r3, #0
 801279c:	e007      	b.n	80127ae <LSM303AGR_ACC_R_SPI_mode+0x2e>

  *value &= LSM303AGR_ACC_SIM_MASK; //mask
 801279e:	9b00      	ldr	r3, [sp, #0]
 80127a0:	781b      	ldrb	r3, [r3, #0]
 80127a2:	f003 0301 	and.w	r3, r3, #1
 80127a6:	b2da      	uxtb	r2, r3
 80127a8:	9b00      	ldr	r3, [sp, #0]
 80127aa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80127ac:	2301      	movs	r3, #1
}
 80127ae:	4618      	mov	r0, r3
 80127b0:	b003      	add	sp, #12
 80127b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80127b6:	bf00      	nop
 80127b8:	f3af 8000 	nop.w
 80127bc:	f3af 8000 	nop.w

080127c0 <LSM303AGR_ACC_W_SelfTest>:
* Input          : LSM303AGR_ACC_ST_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_SelfTest(void *handle, LSM303AGR_ACC_ST_t newValue)
{
 80127c0:	b500      	push	{lr}
 80127c2:	b085      	sub	sp, #20
 80127c4:	9001      	str	r0, [sp, #4]
 80127c6:	460b      	mov	r3, r1
 80127c8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 80127cc:	f10d 030f 	add.w	r3, sp, #15
 80127d0:	9801      	ldr	r0, [sp, #4]
 80127d2:	2123      	movs	r1, #35	; 0x23
 80127d4:	461a      	mov	r2, r3
 80127d6:	2301      	movs	r3, #1
 80127d8:	f7fe fd8a 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80127dc:	4603      	mov	r3, r0
 80127de:	2b00      	cmp	r3, #0
 80127e0:	d101      	bne.n	80127e6 <LSM303AGR_ACC_W_SelfTest+0x26>
    return MEMS_ERROR;
 80127e2:	2300      	movs	r3, #0
 80127e4:	e01c      	b.n	8012820 <LSM303AGR_ACC_W_SelfTest+0x60>

  value &= ~LSM303AGR_ACC_ST_MASK;
 80127e6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80127ea:	f023 0306 	bic.w	r3, r3, #6
 80127ee:	b2db      	uxtb	r3, r3
 80127f0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80127f4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80127f8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80127fc:	4313      	orrs	r3, r2
 80127fe:	b2db      	uxtb	r3, r3
 8012800:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 8012804:	f10d 030f 	add.w	r3, sp, #15
 8012808:	9801      	ldr	r0, [sp, #4]
 801280a:	2123      	movs	r1, #35	; 0x23
 801280c:	461a      	mov	r2, r3
 801280e:	2301      	movs	r3, #1
 8012810:	f7fe fd46 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8012814:	4603      	mov	r3, r0
 8012816:	2b00      	cmp	r3, #0
 8012818:	d101      	bne.n	801281e <LSM303AGR_ACC_W_SelfTest+0x5e>
    return MEMS_ERROR;
 801281a:	2300      	movs	r3, #0
 801281c:	e000      	b.n	8012820 <LSM303AGR_ACC_W_SelfTest+0x60>

  return MEMS_SUCCESS;
 801281e:	2301      	movs	r3, #1
}
 8012820:	4618      	mov	r0, r3
 8012822:	b005      	add	sp, #20
 8012824:	f85d fb04 	ldr.w	pc, [sp], #4
 8012828:	f3af 8000 	nop.w
 801282c:	f3af 8000 	nop.w

08012830 <LSM303AGR_ACC_R_SelfTest>:
* Input          : Pointer to LSM303AGR_ACC_ST_t
* Output         : Status of ST see LSM303AGR_ACC_ST_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_SelfTest(void *handle, LSM303AGR_ACC_ST_t *value)
{
 8012830:	b500      	push	{lr}
 8012832:	b083      	sub	sp, #12
 8012834:	9001      	str	r0, [sp, #4]
 8012836:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
 8012838:	9801      	ldr	r0, [sp, #4]
 801283a:	2123      	movs	r1, #35	; 0x23
 801283c:	9a00      	ldr	r2, [sp, #0]
 801283e:	2301      	movs	r3, #1
 8012840:	f7fe fd56 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012844:	4603      	mov	r3, r0
 8012846:	2b00      	cmp	r3, #0
 8012848:	d101      	bne.n	801284e <LSM303AGR_ACC_R_SelfTest+0x1e>
    return MEMS_ERROR;
 801284a:	2300      	movs	r3, #0
 801284c:	e007      	b.n	801285e <LSM303AGR_ACC_R_SelfTest+0x2e>

  *value &= LSM303AGR_ACC_ST_MASK; //mask
 801284e:	9b00      	ldr	r3, [sp, #0]
 8012850:	781b      	ldrb	r3, [r3, #0]
 8012852:	f003 0306 	and.w	r3, r3, #6
 8012856:	b2da      	uxtb	r2, r3
 8012858:	9b00      	ldr	r3, [sp, #0]
 801285a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801285c:	2301      	movs	r3, #1
}
 801285e:	4618      	mov	r0, r3
 8012860:	b003      	add	sp, #12
 8012862:	f85d fb04 	ldr.w	pc, [sp], #4
 8012866:	bf00      	nop
 8012868:	f3af 8000 	nop.w
 801286c:	f3af 8000 	nop.w

08012870 <LSM303AGR_ACC_W_HiRes>:
* Input          : LSM303AGR_ACC_HR_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_HiRes(void *handle, LSM303AGR_ACC_HR_t newValue)
{
 8012870:	b500      	push	{lr}
 8012872:	b085      	sub	sp, #20
 8012874:	9001      	str	r0, [sp, #4]
 8012876:	460b      	mov	r3, r1
 8012878:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 801287c:	f10d 030f 	add.w	r3, sp, #15
 8012880:	9801      	ldr	r0, [sp, #4]
 8012882:	2123      	movs	r1, #35	; 0x23
 8012884:	461a      	mov	r2, r3
 8012886:	2301      	movs	r3, #1
 8012888:	f7fe fd32 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 801288c:	4603      	mov	r3, r0
 801288e:	2b00      	cmp	r3, #0
 8012890:	d101      	bne.n	8012896 <LSM303AGR_ACC_W_HiRes+0x26>
    return MEMS_ERROR;
 8012892:	2300      	movs	r3, #0
 8012894:	e01c      	b.n	80128d0 <LSM303AGR_ACC_W_HiRes+0x60>

  value &= ~LSM303AGR_ACC_HR_MASK;
 8012896:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801289a:	f023 0308 	bic.w	r3, r3, #8
 801289e:	b2db      	uxtb	r3, r3
 80128a0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80128a4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80128a8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80128ac:	4313      	orrs	r3, r2
 80128ae:	b2db      	uxtb	r3, r3
 80128b0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 80128b4:	f10d 030f 	add.w	r3, sp, #15
 80128b8:	9801      	ldr	r0, [sp, #4]
 80128ba:	2123      	movs	r1, #35	; 0x23
 80128bc:	461a      	mov	r2, r3
 80128be:	2301      	movs	r3, #1
 80128c0:	f7fe fcee 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 80128c4:	4603      	mov	r3, r0
 80128c6:	2b00      	cmp	r3, #0
 80128c8:	d101      	bne.n	80128ce <LSM303AGR_ACC_W_HiRes+0x5e>
    return MEMS_ERROR;
 80128ca:	2300      	movs	r3, #0
 80128cc:	e000      	b.n	80128d0 <LSM303AGR_ACC_W_HiRes+0x60>

  return MEMS_SUCCESS;
 80128ce:	2301      	movs	r3, #1
}
 80128d0:	4618      	mov	r0, r3
 80128d2:	b005      	add	sp, #20
 80128d4:	f85d fb04 	ldr.w	pc, [sp], #4
 80128d8:	f3af 8000 	nop.w
 80128dc:	f3af 8000 	nop.w

080128e0 <LSM303AGR_ACC_R_HiRes>:
* Input          : Pointer to LSM303AGR_ACC_HR_t
* Output         : Status of HR see LSM303AGR_ACC_HR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_HiRes(void *handle, LSM303AGR_ACC_HR_t *value)
{
 80128e0:	b500      	push	{lr}
 80128e2:	b083      	sub	sp, #12
 80128e4:	9001      	str	r0, [sp, #4]
 80128e6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
 80128e8:	9801      	ldr	r0, [sp, #4]
 80128ea:	2123      	movs	r1, #35	; 0x23
 80128ec:	9a00      	ldr	r2, [sp, #0]
 80128ee:	2301      	movs	r3, #1
 80128f0:	f7fe fcfe 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80128f4:	4603      	mov	r3, r0
 80128f6:	2b00      	cmp	r3, #0
 80128f8:	d101      	bne.n	80128fe <LSM303AGR_ACC_R_HiRes+0x1e>
    return MEMS_ERROR;
 80128fa:	2300      	movs	r3, #0
 80128fc:	e007      	b.n	801290e <LSM303AGR_ACC_R_HiRes+0x2e>

  *value &= LSM303AGR_ACC_HR_MASK; //mask
 80128fe:	9b00      	ldr	r3, [sp, #0]
 8012900:	781b      	ldrb	r3, [r3, #0]
 8012902:	f003 0308 	and.w	r3, r3, #8
 8012906:	b2da      	uxtb	r2, r3
 8012908:	9b00      	ldr	r3, [sp, #0]
 801290a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801290c:	2301      	movs	r3, #1
}
 801290e:	4618      	mov	r0, r3
 8012910:	b003      	add	sp, #12
 8012912:	f85d fb04 	ldr.w	pc, [sp], #4
 8012916:	bf00      	nop
 8012918:	f3af 8000 	nop.w
 801291c:	f3af 8000 	nop.w

08012920 <LSM303AGR_ACC_W_LittleBigEndian>:
* Input          : LSM303AGR_ACC_BLE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_LittleBigEndian(void *handle, LSM303AGR_ACC_BLE_t newValue)
{
 8012920:	b500      	push	{lr}
 8012922:	b085      	sub	sp, #20
 8012924:	9001      	str	r0, [sp, #4]
 8012926:	460b      	mov	r3, r1
 8012928:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 801292c:	f10d 030f 	add.w	r3, sp, #15
 8012930:	9801      	ldr	r0, [sp, #4]
 8012932:	2123      	movs	r1, #35	; 0x23
 8012934:	461a      	mov	r2, r3
 8012936:	2301      	movs	r3, #1
 8012938:	f7fe fcda 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 801293c:	4603      	mov	r3, r0
 801293e:	2b00      	cmp	r3, #0
 8012940:	d101      	bne.n	8012946 <LSM303AGR_ACC_W_LittleBigEndian+0x26>
    return MEMS_ERROR;
 8012942:	2300      	movs	r3, #0
 8012944:	e01c      	b.n	8012980 <LSM303AGR_ACC_W_LittleBigEndian+0x60>

  value &= ~LSM303AGR_ACC_BLE_MASK;
 8012946:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801294a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 801294e:	b2db      	uxtb	r3, r3
 8012950:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012954:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012958:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801295c:	4313      	orrs	r3, r2
 801295e:	b2db      	uxtb	r3, r3
 8012960:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 8012964:	f10d 030f 	add.w	r3, sp, #15
 8012968:	9801      	ldr	r0, [sp, #4]
 801296a:	2123      	movs	r1, #35	; 0x23
 801296c:	461a      	mov	r2, r3
 801296e:	2301      	movs	r3, #1
 8012970:	f7fe fc96 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8012974:	4603      	mov	r3, r0
 8012976:	2b00      	cmp	r3, #0
 8012978:	d101      	bne.n	801297e <LSM303AGR_ACC_W_LittleBigEndian+0x5e>
    return MEMS_ERROR;
 801297a:	2300      	movs	r3, #0
 801297c:	e000      	b.n	8012980 <LSM303AGR_ACC_W_LittleBigEndian+0x60>

  return MEMS_SUCCESS;
 801297e:	2301      	movs	r3, #1
}
 8012980:	4618      	mov	r0, r3
 8012982:	b005      	add	sp, #20
 8012984:	f85d fb04 	ldr.w	pc, [sp], #4
 8012988:	f3af 8000 	nop.w
 801298c:	f3af 8000 	nop.w

08012990 <LSM303AGR_ACC_R_LittleBigEndian>:
* Input          : Pointer to LSM303AGR_ACC_BLE_t
* Output         : Status of BLE see LSM303AGR_ACC_BLE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_LittleBigEndian(void *handle, LSM303AGR_ACC_BLE_t *value)
{
 8012990:	b500      	push	{lr}
 8012992:	b083      	sub	sp, #12
 8012994:	9001      	str	r0, [sp, #4]
 8012996:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
 8012998:	9801      	ldr	r0, [sp, #4]
 801299a:	2123      	movs	r1, #35	; 0x23
 801299c:	9a00      	ldr	r2, [sp, #0]
 801299e:	2301      	movs	r3, #1
 80129a0:	f7fe fca6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80129a4:	4603      	mov	r3, r0
 80129a6:	2b00      	cmp	r3, #0
 80129a8:	d101      	bne.n	80129ae <LSM303AGR_ACC_R_LittleBigEndian+0x1e>
    return MEMS_ERROR;
 80129aa:	2300      	movs	r3, #0
 80129ac:	e007      	b.n	80129be <LSM303AGR_ACC_R_LittleBigEndian+0x2e>

  *value &= LSM303AGR_ACC_BLE_MASK; //mask
 80129ae:	9b00      	ldr	r3, [sp, #0]
 80129b0:	781b      	ldrb	r3, [r3, #0]
 80129b2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80129b6:	b2da      	uxtb	r2, r3
 80129b8:	9b00      	ldr	r3, [sp, #0]
 80129ba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80129bc:	2301      	movs	r3, #1
}
 80129be:	4618      	mov	r0, r3
 80129c0:	b003      	add	sp, #12
 80129c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80129c6:	bf00      	nop
 80129c8:	f3af 8000 	nop.w
 80129cc:	f3af 8000 	nop.w

080129d0 <LSM303AGR_ACC_W_4D_on_INT2>:
* Input          : LSM303AGR_ACC_D4D_INT2_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_4D_on_INT2(void *handle, LSM303AGR_ACC_D4D_INT2_t newValue)
{
 80129d0:	b500      	push	{lr}
 80129d2:	b085      	sub	sp, #20
 80129d4:	9001      	str	r0, [sp, #4]
 80129d6:	460b      	mov	r3, r1
 80129d8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 80129dc:	f10d 030f 	add.w	r3, sp, #15
 80129e0:	9801      	ldr	r0, [sp, #4]
 80129e2:	2124      	movs	r1, #36	; 0x24
 80129e4:	461a      	mov	r2, r3
 80129e6:	2301      	movs	r3, #1
 80129e8:	f7fe fc82 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80129ec:	4603      	mov	r3, r0
 80129ee:	2b00      	cmp	r3, #0
 80129f0:	d101      	bne.n	80129f6 <LSM303AGR_ACC_W_4D_on_INT2+0x26>
    return MEMS_ERROR;
 80129f2:	2300      	movs	r3, #0
 80129f4:	e01c      	b.n	8012a30 <LSM303AGR_ACC_W_4D_on_INT2+0x60>

  value &= ~LSM303AGR_ACC_D4D_INT2_MASK;
 80129f6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80129fa:	f023 0301 	bic.w	r3, r3, #1
 80129fe:	b2db      	uxtb	r3, r3
 8012a00:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012a04:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012a08:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012a0c:	4313      	orrs	r3, r2
 8012a0e:	b2db      	uxtb	r3, r3
 8012a10:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8012a14:	f10d 030f 	add.w	r3, sp, #15
 8012a18:	9801      	ldr	r0, [sp, #4]
 8012a1a:	2124      	movs	r1, #36	; 0x24
 8012a1c:	461a      	mov	r2, r3
 8012a1e:	2301      	movs	r3, #1
 8012a20:	f7fe fc3e 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8012a24:	4603      	mov	r3, r0
 8012a26:	2b00      	cmp	r3, #0
 8012a28:	d101      	bne.n	8012a2e <LSM303AGR_ACC_W_4D_on_INT2+0x5e>
    return MEMS_ERROR;
 8012a2a:	2300      	movs	r3, #0
 8012a2c:	e000      	b.n	8012a30 <LSM303AGR_ACC_W_4D_on_INT2+0x60>

  return MEMS_SUCCESS;
 8012a2e:	2301      	movs	r3, #1
}
 8012a30:	4618      	mov	r0, r3
 8012a32:	b005      	add	sp, #20
 8012a34:	f85d fb04 	ldr.w	pc, [sp], #4
 8012a38:	f3af 8000 	nop.w
 8012a3c:	f3af 8000 	nop.w

08012a40 <LSM303AGR_ACC_R_4D_on_INT2>:
* Input          : Pointer to LSM303AGR_ACC_D4D_INT2_t
* Output         : Status of D4D_INT2 see LSM303AGR_ACC_D4D_INT2_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_4D_on_INT2(void *handle, LSM303AGR_ACC_D4D_INT2_t *value)
{
 8012a40:	b500      	push	{lr}
 8012a42:	b083      	sub	sp, #12
 8012a44:	9001      	str	r0, [sp, #4]
 8012a46:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, (u8_t *)value, 1) )
 8012a48:	9801      	ldr	r0, [sp, #4]
 8012a4a:	2124      	movs	r1, #36	; 0x24
 8012a4c:	9a00      	ldr	r2, [sp, #0]
 8012a4e:	2301      	movs	r3, #1
 8012a50:	f7fe fc4e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012a54:	4603      	mov	r3, r0
 8012a56:	2b00      	cmp	r3, #0
 8012a58:	d101      	bne.n	8012a5e <LSM303AGR_ACC_R_4D_on_INT2+0x1e>
    return MEMS_ERROR;
 8012a5a:	2300      	movs	r3, #0
 8012a5c:	e007      	b.n	8012a6e <LSM303AGR_ACC_R_4D_on_INT2+0x2e>

  *value &= LSM303AGR_ACC_D4D_INT2_MASK; //mask
 8012a5e:	9b00      	ldr	r3, [sp, #0]
 8012a60:	781b      	ldrb	r3, [r3, #0]
 8012a62:	f003 0301 	and.w	r3, r3, #1
 8012a66:	b2da      	uxtb	r2, r3
 8012a68:	9b00      	ldr	r3, [sp, #0]
 8012a6a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012a6c:	2301      	movs	r3, #1
}
 8012a6e:	4618      	mov	r0, r3
 8012a70:	b003      	add	sp, #12
 8012a72:	f85d fb04 	ldr.w	pc, [sp], #4
 8012a76:	bf00      	nop
 8012a78:	f3af 8000 	nop.w
 8012a7c:	f3af 8000 	nop.w

08012a80 <LSM303AGR_ACC_W_LatchInterrupt_on_INT2>:
* Input          : LSM303AGR_ACC_LIR_INT2_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_LatchInterrupt_on_INT2(void *handle, LSM303AGR_ACC_LIR_INT2_t newValue)
{
 8012a80:	b500      	push	{lr}
 8012a82:	b085      	sub	sp, #20
 8012a84:	9001      	str	r0, [sp, #4]
 8012a86:	460b      	mov	r3, r1
 8012a88:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8012a8c:	f10d 030f 	add.w	r3, sp, #15
 8012a90:	9801      	ldr	r0, [sp, #4]
 8012a92:	2124      	movs	r1, #36	; 0x24
 8012a94:	461a      	mov	r2, r3
 8012a96:	2301      	movs	r3, #1
 8012a98:	f7fe fc2a 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012a9c:	4603      	mov	r3, r0
 8012a9e:	2b00      	cmp	r3, #0
 8012aa0:	d101      	bne.n	8012aa6 <LSM303AGR_ACC_W_LatchInterrupt_on_INT2+0x26>
    return MEMS_ERROR;
 8012aa2:	2300      	movs	r3, #0
 8012aa4:	e01c      	b.n	8012ae0 <LSM303AGR_ACC_W_LatchInterrupt_on_INT2+0x60>

  value &= ~LSM303AGR_ACC_LIR_INT2_MASK;
 8012aa6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012aaa:	f023 0302 	bic.w	r3, r3, #2
 8012aae:	b2db      	uxtb	r3, r3
 8012ab0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012ab4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012ab8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012abc:	4313      	orrs	r3, r2
 8012abe:	b2db      	uxtb	r3, r3
 8012ac0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8012ac4:	f10d 030f 	add.w	r3, sp, #15
 8012ac8:	9801      	ldr	r0, [sp, #4]
 8012aca:	2124      	movs	r1, #36	; 0x24
 8012acc:	461a      	mov	r2, r3
 8012ace:	2301      	movs	r3, #1
 8012ad0:	f7fe fbe6 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8012ad4:	4603      	mov	r3, r0
 8012ad6:	2b00      	cmp	r3, #0
 8012ad8:	d101      	bne.n	8012ade <LSM303AGR_ACC_W_LatchInterrupt_on_INT2+0x5e>
    return MEMS_ERROR;
 8012ada:	2300      	movs	r3, #0
 8012adc:	e000      	b.n	8012ae0 <LSM303AGR_ACC_W_LatchInterrupt_on_INT2+0x60>

  return MEMS_SUCCESS;
 8012ade:	2301      	movs	r3, #1
}
 8012ae0:	4618      	mov	r0, r3
 8012ae2:	b005      	add	sp, #20
 8012ae4:	f85d fb04 	ldr.w	pc, [sp], #4
 8012ae8:	f3af 8000 	nop.w
 8012aec:	f3af 8000 	nop.w

08012af0 <LSM303AGR_ACC_R_LatchInterrupt_on_INT2>:
* Input          : Pointer to LSM303AGR_ACC_LIR_INT2_t
* Output         : Status of LIR_INT2 see LSM303AGR_ACC_LIR_INT2_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_LatchInterrupt_on_INT2(void *handle, LSM303AGR_ACC_LIR_INT2_t *value)
{
 8012af0:	b500      	push	{lr}
 8012af2:	b083      	sub	sp, #12
 8012af4:	9001      	str	r0, [sp, #4]
 8012af6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, (u8_t *)value, 1) )
 8012af8:	9801      	ldr	r0, [sp, #4]
 8012afa:	2124      	movs	r1, #36	; 0x24
 8012afc:	9a00      	ldr	r2, [sp, #0]
 8012afe:	2301      	movs	r3, #1
 8012b00:	f7fe fbf6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012b04:	4603      	mov	r3, r0
 8012b06:	2b00      	cmp	r3, #0
 8012b08:	d101      	bne.n	8012b0e <LSM303AGR_ACC_R_LatchInterrupt_on_INT2+0x1e>
    return MEMS_ERROR;
 8012b0a:	2300      	movs	r3, #0
 8012b0c:	e007      	b.n	8012b1e <LSM303AGR_ACC_R_LatchInterrupt_on_INT2+0x2e>

  *value &= LSM303AGR_ACC_LIR_INT2_MASK; //mask
 8012b0e:	9b00      	ldr	r3, [sp, #0]
 8012b10:	781b      	ldrb	r3, [r3, #0]
 8012b12:	f003 0302 	and.w	r3, r3, #2
 8012b16:	b2da      	uxtb	r2, r3
 8012b18:	9b00      	ldr	r3, [sp, #0]
 8012b1a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012b1c:	2301      	movs	r3, #1
}
 8012b1e:	4618      	mov	r0, r3
 8012b20:	b003      	add	sp, #12
 8012b22:	f85d fb04 	ldr.w	pc, [sp], #4
 8012b26:	bf00      	nop
 8012b28:	f3af 8000 	nop.w
 8012b2c:	f3af 8000 	nop.w

08012b30 <LSM303AGR_ACC_W_4D_on_INT1>:
* Input          : LSM303AGR_ACC_D4D_INT1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_4D_on_INT1(void *handle, LSM303AGR_ACC_D4D_INT1_t newValue)
{
 8012b30:	b500      	push	{lr}
 8012b32:	b085      	sub	sp, #20
 8012b34:	9001      	str	r0, [sp, #4]
 8012b36:	460b      	mov	r3, r1
 8012b38:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8012b3c:	f10d 030f 	add.w	r3, sp, #15
 8012b40:	9801      	ldr	r0, [sp, #4]
 8012b42:	2124      	movs	r1, #36	; 0x24
 8012b44:	461a      	mov	r2, r3
 8012b46:	2301      	movs	r3, #1
 8012b48:	f7fe fbd2 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012b4c:	4603      	mov	r3, r0
 8012b4e:	2b00      	cmp	r3, #0
 8012b50:	d101      	bne.n	8012b56 <LSM303AGR_ACC_W_4D_on_INT1+0x26>
    return MEMS_ERROR;
 8012b52:	2300      	movs	r3, #0
 8012b54:	e01c      	b.n	8012b90 <LSM303AGR_ACC_W_4D_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_D4D_INT1_MASK;
 8012b56:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012b5a:	f023 0304 	bic.w	r3, r3, #4
 8012b5e:	b2db      	uxtb	r3, r3
 8012b60:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012b64:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012b68:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012b6c:	4313      	orrs	r3, r2
 8012b6e:	b2db      	uxtb	r3, r3
 8012b70:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8012b74:	f10d 030f 	add.w	r3, sp, #15
 8012b78:	9801      	ldr	r0, [sp, #4]
 8012b7a:	2124      	movs	r1, #36	; 0x24
 8012b7c:	461a      	mov	r2, r3
 8012b7e:	2301      	movs	r3, #1
 8012b80:	f7fe fb8e 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8012b84:	4603      	mov	r3, r0
 8012b86:	2b00      	cmp	r3, #0
 8012b88:	d101      	bne.n	8012b8e <LSM303AGR_ACC_W_4D_on_INT1+0x5e>
    return MEMS_ERROR;
 8012b8a:	2300      	movs	r3, #0
 8012b8c:	e000      	b.n	8012b90 <LSM303AGR_ACC_W_4D_on_INT1+0x60>

  return MEMS_SUCCESS;
 8012b8e:	2301      	movs	r3, #1
}
 8012b90:	4618      	mov	r0, r3
 8012b92:	b005      	add	sp, #20
 8012b94:	f85d fb04 	ldr.w	pc, [sp], #4
 8012b98:	f3af 8000 	nop.w
 8012b9c:	f3af 8000 	nop.w

08012ba0 <LSM303AGR_ACC_R_4D_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_D4D_INT1_t
* Output         : Status of D4D_INT1 see LSM303AGR_ACC_D4D_INT1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_4D_on_INT1(void *handle, LSM303AGR_ACC_D4D_INT1_t *value)
{
 8012ba0:	b500      	push	{lr}
 8012ba2:	b083      	sub	sp, #12
 8012ba4:	9001      	str	r0, [sp, #4]
 8012ba6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, (u8_t *)value, 1) )
 8012ba8:	9801      	ldr	r0, [sp, #4]
 8012baa:	2124      	movs	r1, #36	; 0x24
 8012bac:	9a00      	ldr	r2, [sp, #0]
 8012bae:	2301      	movs	r3, #1
 8012bb0:	f7fe fb9e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012bb4:	4603      	mov	r3, r0
 8012bb6:	2b00      	cmp	r3, #0
 8012bb8:	d101      	bne.n	8012bbe <LSM303AGR_ACC_R_4D_on_INT1+0x1e>
    return MEMS_ERROR;
 8012bba:	2300      	movs	r3, #0
 8012bbc:	e007      	b.n	8012bce <LSM303AGR_ACC_R_4D_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_D4D_INT1_MASK; //mask
 8012bbe:	9b00      	ldr	r3, [sp, #0]
 8012bc0:	781b      	ldrb	r3, [r3, #0]
 8012bc2:	f003 0304 	and.w	r3, r3, #4
 8012bc6:	b2da      	uxtb	r2, r3
 8012bc8:	9b00      	ldr	r3, [sp, #0]
 8012bca:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012bcc:	2301      	movs	r3, #1
}
 8012bce:	4618      	mov	r0, r3
 8012bd0:	b003      	add	sp, #12
 8012bd2:	f85d fb04 	ldr.w	pc, [sp], #4
 8012bd6:	bf00      	nop
 8012bd8:	f3af 8000 	nop.w
 8012bdc:	f3af 8000 	nop.w

08012be0 <LSM303AGR_ACC_W_LatchInterrupt_on_INT1>:
* Input          : LSM303AGR_ACC_LIR_INT1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_LatchInterrupt_on_INT1(void *handle, LSM303AGR_ACC_LIR_INT1_t newValue)
{
 8012be0:	b500      	push	{lr}
 8012be2:	b085      	sub	sp, #20
 8012be4:	9001      	str	r0, [sp, #4]
 8012be6:	460b      	mov	r3, r1
 8012be8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8012bec:	f10d 030f 	add.w	r3, sp, #15
 8012bf0:	9801      	ldr	r0, [sp, #4]
 8012bf2:	2124      	movs	r1, #36	; 0x24
 8012bf4:	461a      	mov	r2, r3
 8012bf6:	2301      	movs	r3, #1
 8012bf8:	f7fe fb7a 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012bfc:	4603      	mov	r3, r0
 8012bfe:	2b00      	cmp	r3, #0
 8012c00:	d101      	bne.n	8012c06 <LSM303AGR_ACC_W_LatchInterrupt_on_INT1+0x26>
    return MEMS_ERROR;
 8012c02:	2300      	movs	r3, #0
 8012c04:	e01c      	b.n	8012c40 <LSM303AGR_ACC_W_LatchInterrupt_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_LIR_INT1_MASK;
 8012c06:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012c0a:	f023 0308 	bic.w	r3, r3, #8
 8012c0e:	b2db      	uxtb	r3, r3
 8012c10:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012c14:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012c18:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012c1c:	4313      	orrs	r3, r2
 8012c1e:	b2db      	uxtb	r3, r3
 8012c20:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8012c24:	f10d 030f 	add.w	r3, sp, #15
 8012c28:	9801      	ldr	r0, [sp, #4]
 8012c2a:	2124      	movs	r1, #36	; 0x24
 8012c2c:	461a      	mov	r2, r3
 8012c2e:	2301      	movs	r3, #1
 8012c30:	f7fe fb36 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8012c34:	4603      	mov	r3, r0
 8012c36:	2b00      	cmp	r3, #0
 8012c38:	d101      	bne.n	8012c3e <LSM303AGR_ACC_W_LatchInterrupt_on_INT1+0x5e>
    return MEMS_ERROR;
 8012c3a:	2300      	movs	r3, #0
 8012c3c:	e000      	b.n	8012c40 <LSM303AGR_ACC_W_LatchInterrupt_on_INT1+0x60>

  return MEMS_SUCCESS;
 8012c3e:	2301      	movs	r3, #1
}
 8012c40:	4618      	mov	r0, r3
 8012c42:	b005      	add	sp, #20
 8012c44:	f85d fb04 	ldr.w	pc, [sp], #4
 8012c48:	f3af 8000 	nop.w
 8012c4c:	f3af 8000 	nop.w

08012c50 <LSM303AGR_ACC_R_LatchInterrupt_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_LIR_INT1_t
* Output         : Status of LIR_INT1 see LSM303AGR_ACC_LIR_INT1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_LatchInterrupt_on_INT1(void *handle, LSM303AGR_ACC_LIR_INT1_t *value)
{
 8012c50:	b500      	push	{lr}
 8012c52:	b083      	sub	sp, #12
 8012c54:	9001      	str	r0, [sp, #4]
 8012c56:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, (u8_t *)value, 1) )
 8012c58:	9801      	ldr	r0, [sp, #4]
 8012c5a:	2124      	movs	r1, #36	; 0x24
 8012c5c:	9a00      	ldr	r2, [sp, #0]
 8012c5e:	2301      	movs	r3, #1
 8012c60:	f7fe fb46 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012c64:	4603      	mov	r3, r0
 8012c66:	2b00      	cmp	r3, #0
 8012c68:	d101      	bne.n	8012c6e <LSM303AGR_ACC_R_LatchInterrupt_on_INT1+0x1e>
    return MEMS_ERROR;
 8012c6a:	2300      	movs	r3, #0
 8012c6c:	e007      	b.n	8012c7e <LSM303AGR_ACC_R_LatchInterrupt_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_LIR_INT1_MASK; //mask
 8012c6e:	9b00      	ldr	r3, [sp, #0]
 8012c70:	781b      	ldrb	r3, [r3, #0]
 8012c72:	f003 0308 	and.w	r3, r3, #8
 8012c76:	b2da      	uxtb	r2, r3
 8012c78:	9b00      	ldr	r3, [sp, #0]
 8012c7a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012c7c:	2301      	movs	r3, #1
}
 8012c7e:	4618      	mov	r0, r3
 8012c80:	b003      	add	sp, #12
 8012c82:	f85d fb04 	ldr.w	pc, [sp], #4
 8012c86:	bf00      	nop
 8012c88:	f3af 8000 	nop.w
 8012c8c:	f3af 8000 	nop.w

08012c90 <LSM303AGR_ACC_W_FIFO_EN>:
* Input          : LSM303AGR_ACC_FIFO_EN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_EN(void *handle, LSM303AGR_ACC_FIFO_EN_t newValue)
{
 8012c90:	b500      	push	{lr}
 8012c92:	b085      	sub	sp, #20
 8012c94:	9001      	str	r0, [sp, #4]
 8012c96:	460b      	mov	r3, r1
 8012c98:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8012c9c:	f10d 030f 	add.w	r3, sp, #15
 8012ca0:	9801      	ldr	r0, [sp, #4]
 8012ca2:	2124      	movs	r1, #36	; 0x24
 8012ca4:	461a      	mov	r2, r3
 8012ca6:	2301      	movs	r3, #1
 8012ca8:	f7fe fb22 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012cac:	4603      	mov	r3, r0
 8012cae:	2b00      	cmp	r3, #0
 8012cb0:	d101      	bne.n	8012cb6 <LSM303AGR_ACC_W_FIFO_EN+0x26>
    return MEMS_ERROR;
 8012cb2:	2300      	movs	r3, #0
 8012cb4:	e01c      	b.n	8012cf0 <LSM303AGR_ACC_W_FIFO_EN+0x60>

  value &= ~LSM303AGR_ACC_FIFO_EN_MASK;
 8012cb6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012cba:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8012cbe:	b2db      	uxtb	r3, r3
 8012cc0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012cc4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012cc8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012ccc:	4313      	orrs	r3, r2
 8012cce:	b2db      	uxtb	r3, r3
 8012cd0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8012cd4:	f10d 030f 	add.w	r3, sp, #15
 8012cd8:	9801      	ldr	r0, [sp, #4]
 8012cda:	2124      	movs	r1, #36	; 0x24
 8012cdc:	461a      	mov	r2, r3
 8012cde:	2301      	movs	r3, #1
 8012ce0:	f7fe fade 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8012ce4:	4603      	mov	r3, r0
 8012ce6:	2b00      	cmp	r3, #0
 8012ce8:	d101      	bne.n	8012cee <LSM303AGR_ACC_W_FIFO_EN+0x5e>
    return MEMS_ERROR;
 8012cea:	2300      	movs	r3, #0
 8012cec:	e000      	b.n	8012cf0 <LSM303AGR_ACC_W_FIFO_EN+0x60>

  return MEMS_SUCCESS;
 8012cee:	2301      	movs	r3, #1
}
 8012cf0:	4618      	mov	r0, r3
 8012cf2:	b005      	add	sp, #20
 8012cf4:	f85d fb04 	ldr.w	pc, [sp], #4
 8012cf8:	f3af 8000 	nop.w
 8012cfc:	f3af 8000 	nop.w

08012d00 <LSM303AGR_ACC_R_FIFO_EN>:
* Input          : Pointer to LSM303AGR_ACC_FIFO_EN_t
* Output         : Status of FIFO_EN see LSM303AGR_ACC_FIFO_EN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_EN(void *handle, LSM303AGR_ACC_FIFO_EN_t *value)
{
 8012d00:	b500      	push	{lr}
 8012d02:	b083      	sub	sp, #12
 8012d04:	9001      	str	r0, [sp, #4]
 8012d06:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, (u8_t *)value, 1) )
 8012d08:	9801      	ldr	r0, [sp, #4]
 8012d0a:	2124      	movs	r1, #36	; 0x24
 8012d0c:	9a00      	ldr	r2, [sp, #0]
 8012d0e:	2301      	movs	r3, #1
 8012d10:	f7fe faee 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012d14:	4603      	mov	r3, r0
 8012d16:	2b00      	cmp	r3, #0
 8012d18:	d101      	bne.n	8012d1e <LSM303AGR_ACC_R_FIFO_EN+0x1e>
    return MEMS_ERROR;
 8012d1a:	2300      	movs	r3, #0
 8012d1c:	e007      	b.n	8012d2e <LSM303AGR_ACC_R_FIFO_EN+0x2e>

  *value &= LSM303AGR_ACC_FIFO_EN_MASK; //mask
 8012d1e:	9b00      	ldr	r3, [sp, #0]
 8012d20:	781b      	ldrb	r3, [r3, #0]
 8012d22:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8012d26:	b2da      	uxtb	r2, r3
 8012d28:	9b00      	ldr	r3, [sp, #0]
 8012d2a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012d2c:	2301      	movs	r3, #1
}
 8012d2e:	4618      	mov	r0, r3
 8012d30:	b003      	add	sp, #12
 8012d32:	f85d fb04 	ldr.w	pc, [sp], #4
 8012d36:	bf00      	nop
 8012d38:	f3af 8000 	nop.w
 8012d3c:	f3af 8000 	nop.w

08012d40 <LSM303AGR_ACC_W_RebootMemory>:
* Input          : LSM303AGR_ACC_BOOT_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_RebootMemory(void *handle, LSM303AGR_ACC_BOOT_t newValue)
{
 8012d40:	b500      	push	{lr}
 8012d42:	b085      	sub	sp, #20
 8012d44:	9001      	str	r0, [sp, #4]
 8012d46:	460b      	mov	r3, r1
 8012d48:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8012d4c:	f10d 030f 	add.w	r3, sp, #15
 8012d50:	9801      	ldr	r0, [sp, #4]
 8012d52:	2124      	movs	r1, #36	; 0x24
 8012d54:	461a      	mov	r2, r3
 8012d56:	2301      	movs	r3, #1
 8012d58:	f7fe faca 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012d5c:	4603      	mov	r3, r0
 8012d5e:	2b00      	cmp	r3, #0
 8012d60:	d101      	bne.n	8012d66 <LSM303AGR_ACC_W_RebootMemory+0x26>
    return MEMS_ERROR;
 8012d62:	2300      	movs	r3, #0
 8012d64:	e01c      	b.n	8012da0 <LSM303AGR_ACC_W_RebootMemory+0x60>

  value &= ~LSM303AGR_ACC_BOOT_MASK;
 8012d66:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012d6a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8012d6e:	b2db      	uxtb	r3, r3
 8012d70:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012d74:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012d78:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012d7c:	4313      	orrs	r3, r2
 8012d7e:	b2db      	uxtb	r3, r3
 8012d80:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8012d84:	f10d 030f 	add.w	r3, sp, #15
 8012d88:	9801      	ldr	r0, [sp, #4]
 8012d8a:	2124      	movs	r1, #36	; 0x24
 8012d8c:	461a      	mov	r2, r3
 8012d8e:	2301      	movs	r3, #1
 8012d90:	f7fe fa86 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8012d94:	4603      	mov	r3, r0
 8012d96:	2b00      	cmp	r3, #0
 8012d98:	d101      	bne.n	8012d9e <LSM303AGR_ACC_W_RebootMemory+0x5e>
    return MEMS_ERROR;
 8012d9a:	2300      	movs	r3, #0
 8012d9c:	e000      	b.n	8012da0 <LSM303AGR_ACC_W_RebootMemory+0x60>

  return MEMS_SUCCESS;
 8012d9e:	2301      	movs	r3, #1
}
 8012da0:	4618      	mov	r0, r3
 8012da2:	b005      	add	sp, #20
 8012da4:	f85d fb04 	ldr.w	pc, [sp], #4
 8012da8:	f3af 8000 	nop.w
 8012dac:	f3af 8000 	nop.w

08012db0 <LSM303AGR_ACC_R_RebootMemory>:
* Input          : Pointer to LSM303AGR_ACC_BOOT_t
* Output         : Status of BOOT see LSM303AGR_ACC_BOOT_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_RebootMemory(void *handle, LSM303AGR_ACC_BOOT_t *value)
{
 8012db0:	b500      	push	{lr}
 8012db2:	b083      	sub	sp, #12
 8012db4:	9001      	str	r0, [sp, #4]
 8012db6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, (u8_t *)value, 1) )
 8012db8:	9801      	ldr	r0, [sp, #4]
 8012dba:	2124      	movs	r1, #36	; 0x24
 8012dbc:	9a00      	ldr	r2, [sp, #0]
 8012dbe:	2301      	movs	r3, #1
 8012dc0:	f7fe fa96 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012dc4:	4603      	mov	r3, r0
 8012dc6:	2b00      	cmp	r3, #0
 8012dc8:	d101      	bne.n	8012dce <LSM303AGR_ACC_R_RebootMemory+0x1e>
    return MEMS_ERROR;
 8012dca:	2300      	movs	r3, #0
 8012dcc:	e007      	b.n	8012dde <LSM303AGR_ACC_R_RebootMemory+0x2e>

  *value &= LSM303AGR_ACC_BOOT_MASK; //mask
 8012dce:	9b00      	ldr	r3, [sp, #0]
 8012dd0:	781b      	ldrb	r3, [r3, #0]
 8012dd2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8012dd6:	b2da      	uxtb	r2, r3
 8012dd8:	9b00      	ldr	r3, [sp, #0]
 8012dda:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012ddc:	2301      	movs	r3, #1
}
 8012dde:	4618      	mov	r0, r3
 8012de0:	b003      	add	sp, #12
 8012de2:	f85d fb04 	ldr.w	pc, [sp], #4
 8012de6:	bf00      	nop
 8012de8:	f3af 8000 	nop.w
 8012dec:	f3af 8000 	nop.w

08012df0 <LSM303AGR_ACC_W_IntActive>:
* Input          : LSM303AGR_ACC_H_LACTIVE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_IntActive(void *handle, LSM303AGR_ACC_H_LACTIVE_t newValue)
{
 8012df0:	b500      	push	{lr}
 8012df2:	b085      	sub	sp, #20
 8012df4:	9001      	str	r0, [sp, #4]
 8012df6:	460b      	mov	r3, r1
 8012df8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8012dfc:	f10d 030f 	add.w	r3, sp, #15
 8012e00:	9801      	ldr	r0, [sp, #4]
 8012e02:	2125      	movs	r1, #37	; 0x25
 8012e04:	461a      	mov	r2, r3
 8012e06:	2301      	movs	r3, #1
 8012e08:	f7fe fa72 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012e0c:	4603      	mov	r3, r0
 8012e0e:	2b00      	cmp	r3, #0
 8012e10:	d101      	bne.n	8012e16 <LSM303AGR_ACC_W_IntActive+0x26>
    return MEMS_ERROR;
 8012e12:	2300      	movs	r3, #0
 8012e14:	e01c      	b.n	8012e50 <LSM303AGR_ACC_W_IntActive+0x60>

  value &= ~LSM303AGR_ACC_H_LACTIVE_MASK;
 8012e16:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012e1a:	f023 0302 	bic.w	r3, r3, #2
 8012e1e:	b2db      	uxtb	r3, r3
 8012e20:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012e24:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012e28:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012e2c:	4313      	orrs	r3, r2
 8012e2e:	b2db      	uxtb	r3, r3
 8012e30:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8012e34:	f10d 030f 	add.w	r3, sp, #15
 8012e38:	9801      	ldr	r0, [sp, #4]
 8012e3a:	2125      	movs	r1, #37	; 0x25
 8012e3c:	461a      	mov	r2, r3
 8012e3e:	2301      	movs	r3, #1
 8012e40:	f7fe fa2e 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8012e44:	4603      	mov	r3, r0
 8012e46:	2b00      	cmp	r3, #0
 8012e48:	d101      	bne.n	8012e4e <LSM303AGR_ACC_W_IntActive+0x5e>
    return MEMS_ERROR;
 8012e4a:	2300      	movs	r3, #0
 8012e4c:	e000      	b.n	8012e50 <LSM303AGR_ACC_W_IntActive+0x60>

  return MEMS_SUCCESS;
 8012e4e:	2301      	movs	r3, #1
}
 8012e50:	4618      	mov	r0, r3
 8012e52:	b005      	add	sp, #20
 8012e54:	f85d fb04 	ldr.w	pc, [sp], #4
 8012e58:	f3af 8000 	nop.w
 8012e5c:	f3af 8000 	nop.w

08012e60 <LSM303AGR_ACC_R_IntActive>:
* Input          : Pointer to LSM303AGR_ACC_H_LACTIVE_t
* Output         : Status of H_LACTIVE see LSM303AGR_ACC_H_LACTIVE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_IntActive(void *handle, LSM303AGR_ACC_H_LACTIVE_t *value)
{
 8012e60:	b500      	push	{lr}
 8012e62:	b083      	sub	sp, #12
 8012e64:	9001      	str	r0, [sp, #4]
 8012e66:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, (u8_t *)value, 1) )
 8012e68:	9801      	ldr	r0, [sp, #4]
 8012e6a:	2125      	movs	r1, #37	; 0x25
 8012e6c:	9a00      	ldr	r2, [sp, #0]
 8012e6e:	2301      	movs	r3, #1
 8012e70:	f7fe fa3e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012e74:	4603      	mov	r3, r0
 8012e76:	2b00      	cmp	r3, #0
 8012e78:	d101      	bne.n	8012e7e <LSM303AGR_ACC_R_IntActive+0x1e>
    return MEMS_ERROR;
 8012e7a:	2300      	movs	r3, #0
 8012e7c:	e007      	b.n	8012e8e <LSM303AGR_ACC_R_IntActive+0x2e>

  *value &= LSM303AGR_ACC_H_LACTIVE_MASK; //mask
 8012e7e:	9b00      	ldr	r3, [sp, #0]
 8012e80:	781b      	ldrb	r3, [r3, #0]
 8012e82:	f003 0302 	and.w	r3, r3, #2
 8012e86:	b2da      	uxtb	r2, r3
 8012e88:	9b00      	ldr	r3, [sp, #0]
 8012e8a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012e8c:	2301      	movs	r3, #1
}
 8012e8e:	4618      	mov	r0, r3
 8012e90:	b003      	add	sp, #12
 8012e92:	f85d fb04 	ldr.w	pc, [sp], #4
 8012e96:	bf00      	nop
 8012e98:	f3af 8000 	nop.w
 8012e9c:	f3af 8000 	nop.w

08012ea0 <LSM303AGR_ACC_W_P2_ACT>:
* Input          : LSM303AGR_ACC_P2_ACT_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_P2_ACT(void *handle, LSM303AGR_ACC_P2_ACT_t newValue)
{
 8012ea0:	b500      	push	{lr}
 8012ea2:	b085      	sub	sp, #20
 8012ea4:	9001      	str	r0, [sp, #4]
 8012ea6:	460b      	mov	r3, r1
 8012ea8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8012eac:	f10d 030f 	add.w	r3, sp, #15
 8012eb0:	9801      	ldr	r0, [sp, #4]
 8012eb2:	2125      	movs	r1, #37	; 0x25
 8012eb4:	461a      	mov	r2, r3
 8012eb6:	2301      	movs	r3, #1
 8012eb8:	f7fe fa1a 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012ebc:	4603      	mov	r3, r0
 8012ebe:	2b00      	cmp	r3, #0
 8012ec0:	d101      	bne.n	8012ec6 <LSM303AGR_ACC_W_P2_ACT+0x26>
    return MEMS_ERROR;
 8012ec2:	2300      	movs	r3, #0
 8012ec4:	e01c      	b.n	8012f00 <LSM303AGR_ACC_W_P2_ACT+0x60>

  value &= ~LSM303AGR_ACC_P2_ACT_MASK;
 8012ec6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012eca:	f023 0308 	bic.w	r3, r3, #8
 8012ece:	b2db      	uxtb	r3, r3
 8012ed0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012ed4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012ed8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012edc:	4313      	orrs	r3, r2
 8012ede:	b2db      	uxtb	r3, r3
 8012ee0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8012ee4:	f10d 030f 	add.w	r3, sp, #15
 8012ee8:	9801      	ldr	r0, [sp, #4]
 8012eea:	2125      	movs	r1, #37	; 0x25
 8012eec:	461a      	mov	r2, r3
 8012eee:	2301      	movs	r3, #1
 8012ef0:	f7fe f9d6 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8012ef4:	4603      	mov	r3, r0
 8012ef6:	2b00      	cmp	r3, #0
 8012ef8:	d101      	bne.n	8012efe <LSM303AGR_ACC_W_P2_ACT+0x5e>
    return MEMS_ERROR;
 8012efa:	2300      	movs	r3, #0
 8012efc:	e000      	b.n	8012f00 <LSM303AGR_ACC_W_P2_ACT+0x60>

  return MEMS_SUCCESS;
 8012efe:	2301      	movs	r3, #1
}
 8012f00:	4618      	mov	r0, r3
 8012f02:	b005      	add	sp, #20
 8012f04:	f85d fb04 	ldr.w	pc, [sp], #4
 8012f08:	f3af 8000 	nop.w
 8012f0c:	f3af 8000 	nop.w

08012f10 <LSM303AGR_ACC_R_P2_ACT>:
* Input          : Pointer to LSM303AGR_ACC_P2_ACT_t
* Output         : Status of P2_ACT see LSM303AGR_ACC_P2_ACT_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_P2_ACT(void *handle, LSM303AGR_ACC_P2_ACT_t *value)
{
 8012f10:	b500      	push	{lr}
 8012f12:	b083      	sub	sp, #12
 8012f14:	9001      	str	r0, [sp, #4]
 8012f16:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, (u8_t *)value, 1) )
 8012f18:	9801      	ldr	r0, [sp, #4]
 8012f1a:	2125      	movs	r1, #37	; 0x25
 8012f1c:	9a00      	ldr	r2, [sp, #0]
 8012f1e:	2301      	movs	r3, #1
 8012f20:	f7fe f9e6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012f24:	4603      	mov	r3, r0
 8012f26:	2b00      	cmp	r3, #0
 8012f28:	d101      	bne.n	8012f2e <LSM303AGR_ACC_R_P2_ACT+0x1e>
    return MEMS_ERROR;
 8012f2a:	2300      	movs	r3, #0
 8012f2c:	e007      	b.n	8012f3e <LSM303AGR_ACC_R_P2_ACT+0x2e>

  *value &= LSM303AGR_ACC_P2_ACT_MASK; //mask
 8012f2e:	9b00      	ldr	r3, [sp, #0]
 8012f30:	781b      	ldrb	r3, [r3, #0]
 8012f32:	f003 0308 	and.w	r3, r3, #8
 8012f36:	b2da      	uxtb	r2, r3
 8012f38:	9b00      	ldr	r3, [sp, #0]
 8012f3a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012f3c:	2301      	movs	r3, #1
}
 8012f3e:	4618      	mov	r0, r3
 8012f40:	b003      	add	sp, #12
 8012f42:	f85d fb04 	ldr.w	pc, [sp], #4
 8012f46:	bf00      	nop
 8012f48:	f3af 8000 	nop.w
 8012f4c:	f3af 8000 	nop.w

08012f50 <LSM303AGR_ACC_W_Boot_on_INT2>:
* Input          : LSM303AGR_ACC_BOOT_I1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Boot_on_INT2(void *handle, LSM303AGR_ACC_BOOT_I1_t newValue)
{
 8012f50:	b500      	push	{lr}
 8012f52:	b085      	sub	sp, #20
 8012f54:	9001      	str	r0, [sp, #4]
 8012f56:	460b      	mov	r3, r1
 8012f58:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8012f5c:	f10d 030f 	add.w	r3, sp, #15
 8012f60:	9801      	ldr	r0, [sp, #4]
 8012f62:	2125      	movs	r1, #37	; 0x25
 8012f64:	461a      	mov	r2, r3
 8012f66:	2301      	movs	r3, #1
 8012f68:	f7fe f9c2 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012f6c:	4603      	mov	r3, r0
 8012f6e:	2b00      	cmp	r3, #0
 8012f70:	d101      	bne.n	8012f76 <LSM303AGR_ACC_W_Boot_on_INT2+0x26>
    return MEMS_ERROR;
 8012f72:	2300      	movs	r3, #0
 8012f74:	e01c      	b.n	8012fb0 <LSM303AGR_ACC_W_Boot_on_INT2+0x60>

  value &= ~LSM303AGR_ACC_BOOT_I1_MASK;
 8012f76:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012f7a:	f023 0310 	bic.w	r3, r3, #16
 8012f7e:	b2db      	uxtb	r3, r3
 8012f80:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012f84:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012f88:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012f8c:	4313      	orrs	r3, r2
 8012f8e:	b2db      	uxtb	r3, r3
 8012f90:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8012f94:	f10d 030f 	add.w	r3, sp, #15
 8012f98:	9801      	ldr	r0, [sp, #4]
 8012f9a:	2125      	movs	r1, #37	; 0x25
 8012f9c:	461a      	mov	r2, r3
 8012f9e:	2301      	movs	r3, #1
 8012fa0:	f7fe f97e 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8012fa4:	4603      	mov	r3, r0
 8012fa6:	2b00      	cmp	r3, #0
 8012fa8:	d101      	bne.n	8012fae <LSM303AGR_ACC_W_Boot_on_INT2+0x5e>
    return MEMS_ERROR;
 8012faa:	2300      	movs	r3, #0
 8012fac:	e000      	b.n	8012fb0 <LSM303AGR_ACC_W_Boot_on_INT2+0x60>

  return MEMS_SUCCESS;
 8012fae:	2301      	movs	r3, #1
}
 8012fb0:	4618      	mov	r0, r3
 8012fb2:	b005      	add	sp, #20
 8012fb4:	f85d fb04 	ldr.w	pc, [sp], #4
 8012fb8:	f3af 8000 	nop.w
 8012fbc:	f3af 8000 	nop.w

08012fc0 <LSM303AGR_ACC_R_Boot_on_INT2>:
* Input          : Pointer to LSM303AGR_ACC_BOOT_I1_t
* Output         : Status of BOOT_I1 see LSM303AGR_ACC_BOOT_I1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Boot_on_INT2(void *handle, LSM303AGR_ACC_BOOT_I1_t *value)
{
 8012fc0:	b500      	push	{lr}
 8012fc2:	b083      	sub	sp, #12
 8012fc4:	9001      	str	r0, [sp, #4]
 8012fc6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, (u8_t *)value, 1) )
 8012fc8:	9801      	ldr	r0, [sp, #4]
 8012fca:	2125      	movs	r1, #37	; 0x25
 8012fcc:	9a00      	ldr	r2, [sp, #0]
 8012fce:	2301      	movs	r3, #1
 8012fd0:	f7fe f98e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8012fd4:	4603      	mov	r3, r0
 8012fd6:	2b00      	cmp	r3, #0
 8012fd8:	d101      	bne.n	8012fde <LSM303AGR_ACC_R_Boot_on_INT2+0x1e>
    return MEMS_ERROR;
 8012fda:	2300      	movs	r3, #0
 8012fdc:	e007      	b.n	8012fee <LSM303AGR_ACC_R_Boot_on_INT2+0x2e>

  *value &= LSM303AGR_ACC_BOOT_I1_MASK; //mask
 8012fde:	9b00      	ldr	r3, [sp, #0]
 8012fe0:	781b      	ldrb	r3, [r3, #0]
 8012fe2:	f003 0310 	and.w	r3, r3, #16
 8012fe6:	b2da      	uxtb	r2, r3
 8012fe8:	9b00      	ldr	r3, [sp, #0]
 8012fea:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012fec:	2301      	movs	r3, #1
}
 8012fee:	4618      	mov	r0, r3
 8012ff0:	b003      	add	sp, #12
 8012ff2:	f85d fb04 	ldr.w	pc, [sp], #4
 8012ff6:	bf00      	nop
 8012ff8:	f3af 8000 	nop.w
 8012ffc:	f3af 8000 	nop.w

08013000 <LSM303AGR_ACC_W_I2_on_INT2>:
* Input          : LSM303AGR_ACC_I2_INT2_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_I2_on_INT2(void *handle, LSM303AGR_ACC_I2_INT2_t newValue)
{
 8013000:	b500      	push	{lr}
 8013002:	b085      	sub	sp, #20
 8013004:	9001      	str	r0, [sp, #4]
 8013006:	460b      	mov	r3, r1
 8013008:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 801300c:	f10d 030f 	add.w	r3, sp, #15
 8013010:	9801      	ldr	r0, [sp, #4]
 8013012:	2125      	movs	r1, #37	; 0x25
 8013014:	461a      	mov	r2, r3
 8013016:	2301      	movs	r3, #1
 8013018:	f7fe f96a 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 801301c:	4603      	mov	r3, r0
 801301e:	2b00      	cmp	r3, #0
 8013020:	d101      	bne.n	8013026 <LSM303AGR_ACC_W_I2_on_INT2+0x26>
    return MEMS_ERROR;
 8013022:	2300      	movs	r3, #0
 8013024:	e01c      	b.n	8013060 <LSM303AGR_ACC_W_I2_on_INT2+0x60>

  value &= ~LSM303AGR_ACC_I2_INT2_MASK;
 8013026:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801302a:	f023 0320 	bic.w	r3, r3, #32
 801302e:	b2db      	uxtb	r3, r3
 8013030:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013034:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013038:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801303c:	4313      	orrs	r3, r2
 801303e:	b2db      	uxtb	r3, r3
 8013040:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8013044:	f10d 030f 	add.w	r3, sp, #15
 8013048:	9801      	ldr	r0, [sp, #4]
 801304a:	2125      	movs	r1, #37	; 0x25
 801304c:	461a      	mov	r2, r3
 801304e:	2301      	movs	r3, #1
 8013050:	f7fe f926 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8013054:	4603      	mov	r3, r0
 8013056:	2b00      	cmp	r3, #0
 8013058:	d101      	bne.n	801305e <LSM303AGR_ACC_W_I2_on_INT2+0x5e>
    return MEMS_ERROR;
 801305a:	2300      	movs	r3, #0
 801305c:	e000      	b.n	8013060 <LSM303AGR_ACC_W_I2_on_INT2+0x60>

  return MEMS_SUCCESS;
 801305e:	2301      	movs	r3, #1
}
 8013060:	4618      	mov	r0, r3
 8013062:	b005      	add	sp, #20
 8013064:	f85d fb04 	ldr.w	pc, [sp], #4
 8013068:	f3af 8000 	nop.w
 801306c:	f3af 8000 	nop.w

08013070 <LSM303AGR_ACC_R_I2_on_INT2>:
* Input          : Pointer to LSM303AGR_ACC_I2_INT2_t
* Output         : Status of I2_INT2 see LSM303AGR_ACC_I2_INT2_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_I2_on_INT2(void *handle, LSM303AGR_ACC_I2_INT2_t *value)
{
 8013070:	b500      	push	{lr}
 8013072:	b083      	sub	sp, #12
 8013074:	9001      	str	r0, [sp, #4]
 8013076:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, (u8_t *)value, 1) )
 8013078:	9801      	ldr	r0, [sp, #4]
 801307a:	2125      	movs	r1, #37	; 0x25
 801307c:	9a00      	ldr	r2, [sp, #0]
 801307e:	2301      	movs	r3, #1
 8013080:	f7fe f936 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013084:	4603      	mov	r3, r0
 8013086:	2b00      	cmp	r3, #0
 8013088:	d101      	bne.n	801308e <LSM303AGR_ACC_R_I2_on_INT2+0x1e>
    return MEMS_ERROR;
 801308a:	2300      	movs	r3, #0
 801308c:	e007      	b.n	801309e <LSM303AGR_ACC_R_I2_on_INT2+0x2e>

  *value &= LSM303AGR_ACC_I2_INT2_MASK; //mask
 801308e:	9b00      	ldr	r3, [sp, #0]
 8013090:	781b      	ldrb	r3, [r3, #0]
 8013092:	f003 0320 	and.w	r3, r3, #32
 8013096:	b2da      	uxtb	r2, r3
 8013098:	9b00      	ldr	r3, [sp, #0]
 801309a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801309c:	2301      	movs	r3, #1
}
 801309e:	4618      	mov	r0, r3
 80130a0:	b003      	add	sp, #12
 80130a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80130a6:	bf00      	nop
 80130a8:	f3af 8000 	nop.w
 80130ac:	f3af 8000 	nop.w

080130b0 <LSM303AGR_ACC_W_I2_on_INT1>:
* Input          : LSM303AGR_ACC_I2_INT1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_I2_on_INT1(void *handle, LSM303AGR_ACC_I2_INT1_t newValue)
{
 80130b0:	b500      	push	{lr}
 80130b2:	b085      	sub	sp, #20
 80130b4:	9001      	str	r0, [sp, #4]
 80130b6:	460b      	mov	r3, r1
 80130b8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 80130bc:	f10d 030f 	add.w	r3, sp, #15
 80130c0:	9801      	ldr	r0, [sp, #4]
 80130c2:	2125      	movs	r1, #37	; 0x25
 80130c4:	461a      	mov	r2, r3
 80130c6:	2301      	movs	r3, #1
 80130c8:	f7fe f912 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80130cc:	4603      	mov	r3, r0
 80130ce:	2b00      	cmp	r3, #0
 80130d0:	d101      	bne.n	80130d6 <LSM303AGR_ACC_W_I2_on_INT1+0x26>
    return MEMS_ERROR;
 80130d2:	2300      	movs	r3, #0
 80130d4:	e01c      	b.n	8013110 <LSM303AGR_ACC_W_I2_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I2_INT1_MASK;
 80130d6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80130da:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80130de:	b2db      	uxtb	r3, r3
 80130e0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80130e4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80130e8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80130ec:	4313      	orrs	r3, r2
 80130ee:	b2db      	uxtb	r3, r3
 80130f0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 80130f4:	f10d 030f 	add.w	r3, sp, #15
 80130f8:	9801      	ldr	r0, [sp, #4]
 80130fa:	2125      	movs	r1, #37	; 0x25
 80130fc:	461a      	mov	r2, r3
 80130fe:	2301      	movs	r3, #1
 8013100:	f7fe f8ce 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8013104:	4603      	mov	r3, r0
 8013106:	2b00      	cmp	r3, #0
 8013108:	d101      	bne.n	801310e <LSM303AGR_ACC_W_I2_on_INT1+0x5e>
    return MEMS_ERROR;
 801310a:	2300      	movs	r3, #0
 801310c:	e000      	b.n	8013110 <LSM303AGR_ACC_W_I2_on_INT1+0x60>

  return MEMS_SUCCESS;
 801310e:	2301      	movs	r3, #1
}
 8013110:	4618      	mov	r0, r3
 8013112:	b005      	add	sp, #20
 8013114:	f85d fb04 	ldr.w	pc, [sp], #4
 8013118:	f3af 8000 	nop.w
 801311c:	f3af 8000 	nop.w

08013120 <LSM303AGR_ACC_R_I2_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I2_INT1_t
* Output         : Status of I2_INT1 see LSM303AGR_ACC_I2_INT1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_I2_on_INT1(void *handle, LSM303AGR_ACC_I2_INT1_t *value)
{
 8013120:	b500      	push	{lr}
 8013122:	b083      	sub	sp, #12
 8013124:	9001      	str	r0, [sp, #4]
 8013126:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, (u8_t *)value, 1) )
 8013128:	9801      	ldr	r0, [sp, #4]
 801312a:	2125      	movs	r1, #37	; 0x25
 801312c:	9a00      	ldr	r2, [sp, #0]
 801312e:	2301      	movs	r3, #1
 8013130:	f7fe f8de 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013134:	4603      	mov	r3, r0
 8013136:	2b00      	cmp	r3, #0
 8013138:	d101      	bne.n	801313e <LSM303AGR_ACC_R_I2_on_INT1+0x1e>
    return MEMS_ERROR;
 801313a:	2300      	movs	r3, #0
 801313c:	e007      	b.n	801314e <LSM303AGR_ACC_R_I2_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I2_INT1_MASK; //mask
 801313e:	9b00      	ldr	r3, [sp, #0]
 8013140:	781b      	ldrb	r3, [r3, #0]
 8013142:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8013146:	b2da      	uxtb	r2, r3
 8013148:	9b00      	ldr	r3, [sp, #0]
 801314a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801314c:	2301      	movs	r3, #1
}
 801314e:	4618      	mov	r0, r3
 8013150:	b003      	add	sp, #12
 8013152:	f85d fb04 	ldr.w	pc, [sp], #4
 8013156:	bf00      	nop
 8013158:	f3af 8000 	nop.w
 801315c:	f3af 8000 	nop.w

08013160 <LSM303AGR_ACC_W_Click_on_INT2>:
* Input          : LSM303AGR_ACC_I2_CLICKEN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Click_on_INT2(void *handle, LSM303AGR_ACC_I2_CLICKEN_t newValue)
{
 8013160:	b500      	push	{lr}
 8013162:	b085      	sub	sp, #20
 8013164:	9001      	str	r0, [sp, #4]
 8013166:	460b      	mov	r3, r1
 8013168:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 801316c:	f10d 030f 	add.w	r3, sp, #15
 8013170:	9801      	ldr	r0, [sp, #4]
 8013172:	2125      	movs	r1, #37	; 0x25
 8013174:	461a      	mov	r2, r3
 8013176:	2301      	movs	r3, #1
 8013178:	f7fe f8ba 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 801317c:	4603      	mov	r3, r0
 801317e:	2b00      	cmp	r3, #0
 8013180:	d101      	bne.n	8013186 <LSM303AGR_ACC_W_Click_on_INT2+0x26>
    return MEMS_ERROR;
 8013182:	2300      	movs	r3, #0
 8013184:	e01c      	b.n	80131c0 <LSM303AGR_ACC_W_Click_on_INT2+0x60>

  value &= ~LSM303AGR_ACC_I2_CLICKEN_MASK;
 8013186:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801318a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 801318e:	b2db      	uxtb	r3, r3
 8013190:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013194:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013198:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801319c:	4313      	orrs	r3, r2
 801319e:	b2db      	uxtb	r3, r3
 80131a0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 80131a4:	f10d 030f 	add.w	r3, sp, #15
 80131a8:	9801      	ldr	r0, [sp, #4]
 80131aa:	2125      	movs	r1, #37	; 0x25
 80131ac:	461a      	mov	r2, r3
 80131ae:	2301      	movs	r3, #1
 80131b0:	f7fe f876 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 80131b4:	4603      	mov	r3, r0
 80131b6:	2b00      	cmp	r3, #0
 80131b8:	d101      	bne.n	80131be <LSM303AGR_ACC_W_Click_on_INT2+0x5e>
    return MEMS_ERROR;
 80131ba:	2300      	movs	r3, #0
 80131bc:	e000      	b.n	80131c0 <LSM303AGR_ACC_W_Click_on_INT2+0x60>

  return MEMS_SUCCESS;
 80131be:	2301      	movs	r3, #1
}
 80131c0:	4618      	mov	r0, r3
 80131c2:	b005      	add	sp, #20
 80131c4:	f85d fb04 	ldr.w	pc, [sp], #4
 80131c8:	f3af 8000 	nop.w
 80131cc:	f3af 8000 	nop.w

080131d0 <LSM303AGR_ACC_R_Click_on_INT2>:
* Input          : Pointer to LSM303AGR_ACC_I2_CLICKEN_t
* Output         : Status of I2_CLICKEN see LSM303AGR_ACC_I2_CLICKEN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Click_on_INT2(void *handle, LSM303AGR_ACC_I2_CLICKEN_t *value)
{
 80131d0:	b500      	push	{lr}
 80131d2:	b083      	sub	sp, #12
 80131d4:	9001      	str	r0, [sp, #4]
 80131d6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, (u8_t *)value, 1) )
 80131d8:	9801      	ldr	r0, [sp, #4]
 80131da:	2125      	movs	r1, #37	; 0x25
 80131dc:	9a00      	ldr	r2, [sp, #0]
 80131de:	2301      	movs	r3, #1
 80131e0:	f7fe f886 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80131e4:	4603      	mov	r3, r0
 80131e6:	2b00      	cmp	r3, #0
 80131e8:	d101      	bne.n	80131ee <LSM303AGR_ACC_R_Click_on_INT2+0x1e>
    return MEMS_ERROR;
 80131ea:	2300      	movs	r3, #0
 80131ec:	e007      	b.n	80131fe <LSM303AGR_ACC_R_Click_on_INT2+0x2e>

  *value &= LSM303AGR_ACC_I2_CLICKEN_MASK; //mask
 80131ee:	9b00      	ldr	r3, [sp, #0]
 80131f0:	781b      	ldrb	r3, [r3, #0]
 80131f2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80131f6:	b2da      	uxtb	r2, r3
 80131f8:	9b00      	ldr	r3, [sp, #0]
 80131fa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80131fc:	2301      	movs	r3, #1
}
 80131fe:	4618      	mov	r0, r3
 8013200:	b003      	add	sp, #12
 8013202:	f85d fb04 	ldr.w	pc, [sp], #4
 8013206:	bf00      	nop
 8013208:	f3af 8000 	nop.w
 801320c:	f3af 8000 	nop.w

08013210 <LSM303AGR_ACC_W_ReferenceVal>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ReferenceVal(void *handle, u8_t newValue)
{
 8013210:	b500      	push	{lr}
 8013212:	b085      	sub	sp, #20
 8013214:	9001      	str	r0, [sp, #4]
 8013216:	460b      	mov	r3, r1
 8013218:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_REF_POSITION; //mask
  newValue &= LSM303AGR_ACC_REF_MASK; //coerce

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_REFERENCE, &value, 1) )
 801321c:	f10d 030f 	add.w	r3, sp, #15
 8013220:	9801      	ldr	r0, [sp, #4]
 8013222:	2126      	movs	r1, #38	; 0x26
 8013224:	461a      	mov	r2, r3
 8013226:	2301      	movs	r3, #1
 8013228:	f7fe f862 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 801322c:	4603      	mov	r3, r0
 801322e:	2b00      	cmp	r3, #0
 8013230:	d101      	bne.n	8013236 <LSM303AGR_ACC_W_ReferenceVal+0x26>
    return MEMS_ERROR;
 8013232:	2300      	movs	r3, #0
 8013234:	e018      	b.n	8013268 <LSM303AGR_ACC_W_ReferenceVal+0x58>

  value &= (u8_t)~LSM303AGR_ACC_REF_MASK;
 8013236:	2300      	movs	r3, #0
 8013238:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 801323c:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013240:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013244:	4313      	orrs	r3, r2
 8013246:	b2db      	uxtb	r3, r3
 8013248:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_REFERENCE, &value, 1) )
 801324c:	f10d 030f 	add.w	r3, sp, #15
 8013250:	9801      	ldr	r0, [sp, #4]
 8013252:	2126      	movs	r1, #38	; 0x26
 8013254:	461a      	mov	r2, r3
 8013256:	2301      	movs	r3, #1
 8013258:	f7fe f822 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 801325c:	4603      	mov	r3, r0
 801325e:	2b00      	cmp	r3, #0
 8013260:	d101      	bne.n	8013266 <LSM303AGR_ACC_W_ReferenceVal+0x56>
    return MEMS_ERROR;
 8013262:	2300      	movs	r3, #0
 8013264:	e000      	b.n	8013268 <LSM303AGR_ACC_W_ReferenceVal+0x58>

  return MEMS_SUCCESS;
 8013266:	2301      	movs	r3, #1
}
 8013268:	4618      	mov	r0, r3
 801326a:	b005      	add	sp, #20
 801326c:	f85d fb04 	ldr.w	pc, [sp], #4

08013270 <LSM303AGR_ACC_R_ReferenceVal>:
* Input          : Pointer to u8_t
* Output         : Status of REF
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ReferenceVal(void *handle, u8_t *value)
{
 8013270:	b500      	push	{lr}
 8013272:	b083      	sub	sp, #12
 8013274:	9001      	str	r0, [sp, #4]
 8013276:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_REFERENCE, (u8_t *)value, 1) )
 8013278:	9801      	ldr	r0, [sp, #4]
 801327a:	2126      	movs	r1, #38	; 0x26
 801327c:	9a00      	ldr	r2, [sp, #0]
 801327e:	2301      	movs	r3, #1
 8013280:	f7fe f836 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013284:	4603      	mov	r3, r0
 8013286:	2b00      	cmp	r3, #0
 8013288:	d101      	bne.n	801328e <LSM303AGR_ACC_R_ReferenceVal+0x1e>
    return MEMS_ERROR;
 801328a:	2300      	movs	r3, #0
 801328c:	e008      	b.n	80132a0 <LSM303AGR_ACC_R_ReferenceVal+0x30>

  *value &= LSM303AGR_ACC_REF_MASK; //coerce
 801328e:	9b00      	ldr	r3, [sp, #0]
 8013290:	781a      	ldrb	r2, [r3, #0]
 8013292:	9b00      	ldr	r3, [sp, #0]
 8013294:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_REF_POSITION; //mask
 8013296:	9b00      	ldr	r3, [sp, #0]
 8013298:	781a      	ldrb	r2, [r3, #0]
 801329a:	9b00      	ldr	r3, [sp, #0]
 801329c:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801329e:	2301      	movs	r3, #1
}
 80132a0:	4618      	mov	r0, r3
 80132a2:	b003      	add	sp, #12
 80132a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80132a8:	f3af 8000 	nop.w
 80132ac:	f3af 8000 	nop.w

080132b0 <LSM303AGR_ACC_R_XDataAvail>:
* Input          : Pointer to LSM303AGR_ACC_XDA_t
* Output         : Status of XDA see LSM303AGR_ACC_XDA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XDataAvail(void *handle, LSM303AGR_ACC_XDA_t *value)
{
 80132b0:	b500      	push	{lr}
 80132b2:	b083      	sub	sp, #12
 80132b4:	9001      	str	r0, [sp, #4]
 80132b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 80132b8:	9801      	ldr	r0, [sp, #4]
 80132ba:	2127      	movs	r1, #39	; 0x27
 80132bc:	9a00      	ldr	r2, [sp, #0]
 80132be:	2301      	movs	r3, #1
 80132c0:	f7fe f816 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80132c4:	4603      	mov	r3, r0
 80132c6:	2b00      	cmp	r3, #0
 80132c8:	d101      	bne.n	80132ce <LSM303AGR_ACC_R_XDataAvail+0x1e>
    return MEMS_ERROR;
 80132ca:	2300      	movs	r3, #0
 80132cc:	e007      	b.n	80132de <LSM303AGR_ACC_R_XDataAvail+0x2e>

  *value &= LSM303AGR_ACC_XDA_MASK; //mask
 80132ce:	9b00      	ldr	r3, [sp, #0]
 80132d0:	781b      	ldrb	r3, [r3, #0]
 80132d2:	f003 0301 	and.w	r3, r3, #1
 80132d6:	b2da      	uxtb	r2, r3
 80132d8:	9b00      	ldr	r3, [sp, #0]
 80132da:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80132dc:	2301      	movs	r3, #1
}
 80132de:	4618      	mov	r0, r3
 80132e0:	b003      	add	sp, #12
 80132e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80132e6:	bf00      	nop
 80132e8:	f3af 8000 	nop.w
 80132ec:	f3af 8000 	nop.w

080132f0 <LSM303AGR_ACC_R_YDataAvail>:
* Input          : Pointer to LSM303AGR_ACC_YDA_t
* Output         : Status of YDA see LSM303AGR_ACC_YDA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_YDataAvail(void *handle, LSM303AGR_ACC_YDA_t *value)
{
 80132f0:	b500      	push	{lr}
 80132f2:	b083      	sub	sp, #12
 80132f4:	9001      	str	r0, [sp, #4]
 80132f6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 80132f8:	9801      	ldr	r0, [sp, #4]
 80132fa:	2127      	movs	r1, #39	; 0x27
 80132fc:	9a00      	ldr	r2, [sp, #0]
 80132fe:	2301      	movs	r3, #1
 8013300:	f7fd fff6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013304:	4603      	mov	r3, r0
 8013306:	2b00      	cmp	r3, #0
 8013308:	d101      	bne.n	801330e <LSM303AGR_ACC_R_YDataAvail+0x1e>
    return MEMS_ERROR;
 801330a:	2300      	movs	r3, #0
 801330c:	e007      	b.n	801331e <LSM303AGR_ACC_R_YDataAvail+0x2e>

  *value &= LSM303AGR_ACC_YDA_MASK; //mask
 801330e:	9b00      	ldr	r3, [sp, #0]
 8013310:	781b      	ldrb	r3, [r3, #0]
 8013312:	f003 0302 	and.w	r3, r3, #2
 8013316:	b2da      	uxtb	r2, r3
 8013318:	9b00      	ldr	r3, [sp, #0]
 801331a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801331c:	2301      	movs	r3, #1
}
 801331e:	4618      	mov	r0, r3
 8013320:	b003      	add	sp, #12
 8013322:	f85d fb04 	ldr.w	pc, [sp], #4
 8013326:	bf00      	nop
 8013328:	f3af 8000 	nop.w
 801332c:	f3af 8000 	nop.w

08013330 <LSM303AGR_ACC_R_ZDataAvail>:
* Input          : Pointer to LSM303AGR_ACC_ZDA_t
* Output         : Status of ZDA see LSM303AGR_ACC_ZDA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ZDataAvail(void *handle, LSM303AGR_ACC_ZDA_t *value)
{
 8013330:	b500      	push	{lr}
 8013332:	b083      	sub	sp, #12
 8013334:	9001      	str	r0, [sp, #4]
 8013336:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8013338:	9801      	ldr	r0, [sp, #4]
 801333a:	2127      	movs	r1, #39	; 0x27
 801333c:	9a00      	ldr	r2, [sp, #0]
 801333e:	2301      	movs	r3, #1
 8013340:	f7fd ffd6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013344:	4603      	mov	r3, r0
 8013346:	2b00      	cmp	r3, #0
 8013348:	d101      	bne.n	801334e <LSM303AGR_ACC_R_ZDataAvail+0x1e>
    return MEMS_ERROR;
 801334a:	2300      	movs	r3, #0
 801334c:	e007      	b.n	801335e <LSM303AGR_ACC_R_ZDataAvail+0x2e>

  *value &= LSM303AGR_ACC_ZDA_MASK; //mask
 801334e:	9b00      	ldr	r3, [sp, #0]
 8013350:	781b      	ldrb	r3, [r3, #0]
 8013352:	f003 0304 	and.w	r3, r3, #4
 8013356:	b2da      	uxtb	r2, r3
 8013358:	9b00      	ldr	r3, [sp, #0]
 801335a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801335c:	2301      	movs	r3, #1
}
 801335e:	4618      	mov	r0, r3
 8013360:	b003      	add	sp, #12
 8013362:	f85d fb04 	ldr.w	pc, [sp], #4
 8013366:	bf00      	nop
 8013368:	f3af 8000 	nop.w
 801336c:	f3af 8000 	nop.w

08013370 <LSM303AGR_ACC_R_XYZDataAvail>:
* Input          : Pointer to LSM303AGR_ACC_ZYXDA_t
* Output         : Status of ZYXDA see LSM303AGR_ACC_ZYXDA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XYZDataAvail(void *handle, LSM303AGR_ACC_ZYXDA_t *value)
{
 8013370:	b500      	push	{lr}
 8013372:	b083      	sub	sp, #12
 8013374:	9001      	str	r0, [sp, #4]
 8013376:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8013378:	9801      	ldr	r0, [sp, #4]
 801337a:	2127      	movs	r1, #39	; 0x27
 801337c:	9a00      	ldr	r2, [sp, #0]
 801337e:	2301      	movs	r3, #1
 8013380:	f7fd ffb6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013384:	4603      	mov	r3, r0
 8013386:	2b00      	cmp	r3, #0
 8013388:	d101      	bne.n	801338e <LSM303AGR_ACC_R_XYZDataAvail+0x1e>
    return MEMS_ERROR;
 801338a:	2300      	movs	r3, #0
 801338c:	e007      	b.n	801339e <LSM303AGR_ACC_R_XYZDataAvail+0x2e>

  *value &= LSM303AGR_ACC_ZYXDA_MASK; //mask
 801338e:	9b00      	ldr	r3, [sp, #0]
 8013390:	781b      	ldrb	r3, [r3, #0]
 8013392:	f003 0308 	and.w	r3, r3, #8
 8013396:	b2da      	uxtb	r2, r3
 8013398:	9b00      	ldr	r3, [sp, #0]
 801339a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801339c:	2301      	movs	r3, #1
}
 801339e:	4618      	mov	r0, r3
 80133a0:	b003      	add	sp, #12
 80133a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80133a6:	bf00      	nop
 80133a8:	f3af 8000 	nop.w
 80133ac:	f3af 8000 	nop.w

080133b0 <LSM303AGR_ACC_R_XDataOverrun>:
* Input          : Pointer to LSM303AGR_ACC_XOR_t
* Output         : Status of XOR see LSM303AGR_ACC_XOR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XDataOverrun(void *handle, LSM303AGR_ACC_XOR_t *value)
{
 80133b0:	b500      	push	{lr}
 80133b2:	b083      	sub	sp, #12
 80133b4:	9001      	str	r0, [sp, #4]
 80133b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 80133b8:	9801      	ldr	r0, [sp, #4]
 80133ba:	2127      	movs	r1, #39	; 0x27
 80133bc:	9a00      	ldr	r2, [sp, #0]
 80133be:	2301      	movs	r3, #1
 80133c0:	f7fd ff96 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80133c4:	4603      	mov	r3, r0
 80133c6:	2b00      	cmp	r3, #0
 80133c8:	d101      	bne.n	80133ce <LSM303AGR_ACC_R_XDataOverrun+0x1e>
    return MEMS_ERROR;
 80133ca:	2300      	movs	r3, #0
 80133cc:	e007      	b.n	80133de <LSM303AGR_ACC_R_XDataOverrun+0x2e>

  *value &= LSM303AGR_ACC_XOR_MASK; //mask
 80133ce:	9b00      	ldr	r3, [sp, #0]
 80133d0:	781b      	ldrb	r3, [r3, #0]
 80133d2:	f003 0310 	and.w	r3, r3, #16
 80133d6:	b2da      	uxtb	r2, r3
 80133d8:	9b00      	ldr	r3, [sp, #0]
 80133da:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80133dc:	2301      	movs	r3, #1
}
 80133de:	4618      	mov	r0, r3
 80133e0:	b003      	add	sp, #12
 80133e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80133e6:	bf00      	nop
 80133e8:	f3af 8000 	nop.w
 80133ec:	f3af 8000 	nop.w

080133f0 <LSM303AGR_ACC_R_YDataOverrun>:
* Input          : Pointer to LSM303AGR_ACC_YOR_t
* Output         : Status of YOR see LSM303AGR_ACC_YOR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_YDataOverrun(void *handle, LSM303AGR_ACC_YOR_t *value)
{
 80133f0:	b500      	push	{lr}
 80133f2:	b083      	sub	sp, #12
 80133f4:	9001      	str	r0, [sp, #4]
 80133f6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 80133f8:	9801      	ldr	r0, [sp, #4]
 80133fa:	2127      	movs	r1, #39	; 0x27
 80133fc:	9a00      	ldr	r2, [sp, #0]
 80133fe:	2301      	movs	r3, #1
 8013400:	f7fd ff76 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013404:	4603      	mov	r3, r0
 8013406:	2b00      	cmp	r3, #0
 8013408:	d101      	bne.n	801340e <LSM303AGR_ACC_R_YDataOverrun+0x1e>
    return MEMS_ERROR;
 801340a:	2300      	movs	r3, #0
 801340c:	e007      	b.n	801341e <LSM303AGR_ACC_R_YDataOverrun+0x2e>

  *value &= LSM303AGR_ACC_YOR_MASK; //mask
 801340e:	9b00      	ldr	r3, [sp, #0]
 8013410:	781b      	ldrb	r3, [r3, #0]
 8013412:	f003 0320 	and.w	r3, r3, #32
 8013416:	b2da      	uxtb	r2, r3
 8013418:	9b00      	ldr	r3, [sp, #0]
 801341a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801341c:	2301      	movs	r3, #1
}
 801341e:	4618      	mov	r0, r3
 8013420:	b003      	add	sp, #12
 8013422:	f85d fb04 	ldr.w	pc, [sp], #4
 8013426:	bf00      	nop
 8013428:	f3af 8000 	nop.w
 801342c:	f3af 8000 	nop.w

08013430 <LSM303AGR_ACC_R_ZDataOverrun>:
* Input          : Pointer to LSM303AGR_ACC_ZOR_t
* Output         : Status of ZOR see LSM303AGR_ACC_ZOR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ZDataOverrun(void *handle, LSM303AGR_ACC_ZOR_t *value)
{
 8013430:	b500      	push	{lr}
 8013432:	b083      	sub	sp, #12
 8013434:	9001      	str	r0, [sp, #4]
 8013436:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8013438:	9801      	ldr	r0, [sp, #4]
 801343a:	2127      	movs	r1, #39	; 0x27
 801343c:	9a00      	ldr	r2, [sp, #0]
 801343e:	2301      	movs	r3, #1
 8013440:	f7fd ff56 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013444:	4603      	mov	r3, r0
 8013446:	2b00      	cmp	r3, #0
 8013448:	d101      	bne.n	801344e <LSM303AGR_ACC_R_ZDataOverrun+0x1e>
    return MEMS_ERROR;
 801344a:	2300      	movs	r3, #0
 801344c:	e007      	b.n	801345e <LSM303AGR_ACC_R_ZDataOverrun+0x2e>

  *value &= LSM303AGR_ACC_ZOR_MASK; //mask
 801344e:	9b00      	ldr	r3, [sp, #0]
 8013450:	781b      	ldrb	r3, [r3, #0]
 8013452:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8013456:	b2da      	uxtb	r2, r3
 8013458:	9b00      	ldr	r3, [sp, #0]
 801345a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801345c:	2301      	movs	r3, #1
}
 801345e:	4618      	mov	r0, r3
 8013460:	b003      	add	sp, #12
 8013462:	f85d fb04 	ldr.w	pc, [sp], #4
 8013466:	bf00      	nop
 8013468:	f3af 8000 	nop.w
 801346c:	f3af 8000 	nop.w

08013470 <LSM303AGR_ACC_R_XYZDataOverrun>:
* Input          : Pointer to LSM303AGR_ACC_ZYXOR_t
* Output         : Status of ZYXOR see LSM303AGR_ACC_ZYXOR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XYZDataOverrun(void *handle, LSM303AGR_ACC_ZYXOR_t *value)
{
 8013470:	b500      	push	{lr}
 8013472:	b083      	sub	sp, #12
 8013474:	9001      	str	r0, [sp, #4]
 8013476:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8013478:	9801      	ldr	r0, [sp, #4]
 801347a:	2127      	movs	r1, #39	; 0x27
 801347c:	9a00      	ldr	r2, [sp, #0]
 801347e:	2301      	movs	r3, #1
 8013480:	f7fd ff36 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013484:	4603      	mov	r3, r0
 8013486:	2b00      	cmp	r3, #0
 8013488:	d101      	bne.n	801348e <LSM303AGR_ACC_R_XYZDataOverrun+0x1e>
    return MEMS_ERROR;
 801348a:	2300      	movs	r3, #0
 801348c:	e007      	b.n	801349e <LSM303AGR_ACC_R_XYZDataOverrun+0x2e>

  *value &= LSM303AGR_ACC_ZYXOR_MASK; //mask
 801348e:	9b00      	ldr	r3, [sp, #0]
 8013490:	781b      	ldrb	r3, [r3, #0]
 8013492:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8013496:	b2da      	uxtb	r2, r3
 8013498:	9b00      	ldr	r3, [sp, #0]
 801349a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801349c:	2301      	movs	r3, #1
}
 801349e:	4618      	mov	r0, r3
 80134a0:	b003      	add	sp, #12
 80134a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80134a6:	bf00      	nop
 80134a8:	f3af 8000 	nop.w
 80134ac:	f3af 8000 	nop.w

080134b0 <LSM303AGR_ACC_W_FifoThreshold>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FifoThreshold(void *handle, u8_t newValue)
{
 80134b0:	b500      	push	{lr}
 80134b2:	b085      	sub	sp, #20
 80134b4:	9001      	str	r0, [sp, #4]
 80134b6:	460b      	mov	r3, r1
 80134b8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_FTH_POSITION; //mask
  newValue &= LSM303AGR_ACC_FTH_MASK; //coerce
 80134bc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80134c0:	f003 031f 	and.w	r3, r3, #31
 80134c4:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
 80134c8:	f10d 030f 	add.w	r3, sp, #15
 80134cc:	9801      	ldr	r0, [sp, #4]
 80134ce:	212e      	movs	r1, #46	; 0x2e
 80134d0:	461a      	mov	r2, r3
 80134d2:	2301      	movs	r3, #1
 80134d4:	f7fd ff0c 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80134d8:	4603      	mov	r3, r0
 80134da:	2b00      	cmp	r3, #0
 80134dc:	d101      	bne.n	80134e2 <LSM303AGR_ACC_W_FifoThreshold+0x32>
    return MEMS_ERROR;
 80134de:	2300      	movs	r3, #0
 80134e0:	e01c      	b.n	801351c <LSM303AGR_ACC_W_FifoThreshold+0x6c>

  value &= ~LSM303AGR_ACC_FTH_MASK;
 80134e2:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80134e6:	f023 031f 	bic.w	r3, r3, #31
 80134ea:	b2db      	uxtb	r3, r3
 80134ec:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80134f0:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80134f4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80134f8:	4313      	orrs	r3, r2
 80134fa:	b2db      	uxtb	r3, r3
 80134fc:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
 8013500:	f10d 030f 	add.w	r3, sp, #15
 8013504:	9801      	ldr	r0, [sp, #4]
 8013506:	212e      	movs	r1, #46	; 0x2e
 8013508:	461a      	mov	r2, r3
 801350a:	2301      	movs	r3, #1
 801350c:	f7fd fec8 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8013510:	4603      	mov	r3, r0
 8013512:	2b00      	cmp	r3, #0
 8013514:	d101      	bne.n	801351a <LSM303AGR_ACC_W_FifoThreshold+0x6a>
    return MEMS_ERROR;
 8013516:	2300      	movs	r3, #0
 8013518:	e000      	b.n	801351c <LSM303AGR_ACC_W_FifoThreshold+0x6c>

  return MEMS_SUCCESS;
 801351a:	2301      	movs	r3, #1
}
 801351c:	4618      	mov	r0, r3
 801351e:	b005      	add	sp, #20
 8013520:	f85d fb04 	ldr.w	pc, [sp], #4
 8013524:	f3af 8000 	nop.w
 8013528:	f3af 8000 	nop.w
 801352c:	f3af 8000 	nop.w

08013530 <LSM303AGR_ACC_R_FifoThreshold>:
* Input          : Pointer to u8_t
* Output         : Status of FTH
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FifoThreshold(void *handle, u8_t *value)
{
 8013530:	b500      	push	{lr}
 8013532:	b083      	sub	sp, #12
 8013534:	9001      	str	r0, [sp, #4]
 8013536:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, (u8_t *)value, 1) )
 8013538:	9801      	ldr	r0, [sp, #4]
 801353a:	212e      	movs	r1, #46	; 0x2e
 801353c:	9a00      	ldr	r2, [sp, #0]
 801353e:	2301      	movs	r3, #1
 8013540:	f7fd fed6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013544:	4603      	mov	r3, r0
 8013546:	2b00      	cmp	r3, #0
 8013548:	d101      	bne.n	801354e <LSM303AGR_ACC_R_FifoThreshold+0x1e>
    return MEMS_ERROR;
 801354a:	2300      	movs	r3, #0
 801354c:	e00b      	b.n	8013566 <LSM303AGR_ACC_R_FifoThreshold+0x36>

  *value &= LSM303AGR_ACC_FTH_MASK; //coerce
 801354e:	9b00      	ldr	r3, [sp, #0]
 8013550:	781b      	ldrb	r3, [r3, #0]
 8013552:	f003 031f 	and.w	r3, r3, #31
 8013556:	b2da      	uxtb	r2, r3
 8013558:	9b00      	ldr	r3, [sp, #0]
 801355a:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_FTH_POSITION; //mask
 801355c:	9b00      	ldr	r3, [sp, #0]
 801355e:	781a      	ldrb	r2, [r3, #0]
 8013560:	9b00      	ldr	r3, [sp, #0]
 8013562:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013564:	2301      	movs	r3, #1
}
 8013566:	4618      	mov	r0, r3
 8013568:	b003      	add	sp, #12
 801356a:	f85d fb04 	ldr.w	pc, [sp], #4
 801356e:	bf00      	nop

08013570 <LSM303AGR_ACC_W_TriggerSel>:
* Input          : LSM303AGR_ACC_TR_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_TriggerSel(void *handle, LSM303AGR_ACC_TR_t newValue)
{
 8013570:	b500      	push	{lr}
 8013572:	b085      	sub	sp, #20
 8013574:	9001      	str	r0, [sp, #4]
 8013576:	460b      	mov	r3, r1
 8013578:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
 801357c:	f10d 030f 	add.w	r3, sp, #15
 8013580:	9801      	ldr	r0, [sp, #4]
 8013582:	212e      	movs	r1, #46	; 0x2e
 8013584:	461a      	mov	r2, r3
 8013586:	2301      	movs	r3, #1
 8013588:	f7fd feb2 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 801358c:	4603      	mov	r3, r0
 801358e:	2b00      	cmp	r3, #0
 8013590:	d101      	bne.n	8013596 <LSM303AGR_ACC_W_TriggerSel+0x26>
    return MEMS_ERROR;
 8013592:	2300      	movs	r3, #0
 8013594:	e01c      	b.n	80135d0 <LSM303AGR_ACC_W_TriggerSel+0x60>

  value &= ~LSM303AGR_ACC_TR_MASK;
 8013596:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801359a:	f023 0320 	bic.w	r3, r3, #32
 801359e:	b2db      	uxtb	r3, r3
 80135a0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80135a4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80135a8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80135ac:	4313      	orrs	r3, r2
 80135ae:	b2db      	uxtb	r3, r3
 80135b0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
 80135b4:	f10d 030f 	add.w	r3, sp, #15
 80135b8:	9801      	ldr	r0, [sp, #4]
 80135ba:	212e      	movs	r1, #46	; 0x2e
 80135bc:	461a      	mov	r2, r3
 80135be:	2301      	movs	r3, #1
 80135c0:	f7fd fe6e 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 80135c4:	4603      	mov	r3, r0
 80135c6:	2b00      	cmp	r3, #0
 80135c8:	d101      	bne.n	80135ce <LSM303AGR_ACC_W_TriggerSel+0x5e>
    return MEMS_ERROR;
 80135ca:	2300      	movs	r3, #0
 80135cc:	e000      	b.n	80135d0 <LSM303AGR_ACC_W_TriggerSel+0x60>

  return MEMS_SUCCESS;
 80135ce:	2301      	movs	r3, #1
}
 80135d0:	4618      	mov	r0, r3
 80135d2:	b005      	add	sp, #20
 80135d4:	f85d fb04 	ldr.w	pc, [sp], #4
 80135d8:	f3af 8000 	nop.w
 80135dc:	f3af 8000 	nop.w

080135e0 <LSM303AGR_ACC_R_TriggerSel>:
* Input          : Pointer to LSM303AGR_ACC_TR_t
* Output         : Status of TR see LSM303AGR_ACC_TR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_TriggerSel(void *handle, LSM303AGR_ACC_TR_t *value)
{
 80135e0:	b500      	push	{lr}
 80135e2:	b083      	sub	sp, #12
 80135e4:	9001      	str	r0, [sp, #4]
 80135e6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, (u8_t *)value, 1) )
 80135e8:	9801      	ldr	r0, [sp, #4]
 80135ea:	212e      	movs	r1, #46	; 0x2e
 80135ec:	9a00      	ldr	r2, [sp, #0]
 80135ee:	2301      	movs	r3, #1
 80135f0:	f7fd fe7e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80135f4:	4603      	mov	r3, r0
 80135f6:	2b00      	cmp	r3, #0
 80135f8:	d101      	bne.n	80135fe <LSM303AGR_ACC_R_TriggerSel+0x1e>
    return MEMS_ERROR;
 80135fa:	2300      	movs	r3, #0
 80135fc:	e007      	b.n	801360e <LSM303AGR_ACC_R_TriggerSel+0x2e>

  *value &= LSM303AGR_ACC_TR_MASK; //mask
 80135fe:	9b00      	ldr	r3, [sp, #0]
 8013600:	781b      	ldrb	r3, [r3, #0]
 8013602:	f003 0320 	and.w	r3, r3, #32
 8013606:	b2da      	uxtb	r2, r3
 8013608:	9b00      	ldr	r3, [sp, #0]
 801360a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801360c:	2301      	movs	r3, #1
}
 801360e:	4618      	mov	r0, r3
 8013610:	b003      	add	sp, #12
 8013612:	f85d fb04 	ldr.w	pc, [sp], #4
 8013616:	bf00      	nop
 8013618:	f3af 8000 	nop.w
 801361c:	f3af 8000 	nop.w

08013620 <LSM303AGR_ACC_W_FifoMode>:
* Input          : LSM303AGR_ACC_FM_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FifoMode(void *handle, LSM303AGR_ACC_FM_t newValue)
{
 8013620:	b500      	push	{lr}
 8013622:	b085      	sub	sp, #20
 8013624:	9001      	str	r0, [sp, #4]
 8013626:	460b      	mov	r3, r1
 8013628:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
 801362c:	f10d 030f 	add.w	r3, sp, #15
 8013630:	9801      	ldr	r0, [sp, #4]
 8013632:	212e      	movs	r1, #46	; 0x2e
 8013634:	461a      	mov	r2, r3
 8013636:	2301      	movs	r3, #1
 8013638:	f7fd fe5a 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 801363c:	4603      	mov	r3, r0
 801363e:	2b00      	cmp	r3, #0
 8013640:	d101      	bne.n	8013646 <LSM303AGR_ACC_W_FifoMode+0x26>
    return MEMS_ERROR;
 8013642:	2300      	movs	r3, #0
 8013644:	e01c      	b.n	8013680 <LSM303AGR_ACC_W_FifoMode+0x60>

  value &= ~LSM303AGR_ACC_FM_MASK;
 8013646:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801364a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801364e:	b2db      	uxtb	r3, r3
 8013650:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013654:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013658:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801365c:	4313      	orrs	r3, r2
 801365e:	b2db      	uxtb	r3, r3
 8013660:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
 8013664:	f10d 030f 	add.w	r3, sp, #15
 8013668:	9801      	ldr	r0, [sp, #4]
 801366a:	212e      	movs	r1, #46	; 0x2e
 801366c:	461a      	mov	r2, r3
 801366e:	2301      	movs	r3, #1
 8013670:	f7fd fe16 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8013674:	4603      	mov	r3, r0
 8013676:	2b00      	cmp	r3, #0
 8013678:	d101      	bne.n	801367e <LSM303AGR_ACC_W_FifoMode+0x5e>
    return MEMS_ERROR;
 801367a:	2300      	movs	r3, #0
 801367c:	e000      	b.n	8013680 <LSM303AGR_ACC_W_FifoMode+0x60>

  return MEMS_SUCCESS;
 801367e:	2301      	movs	r3, #1
}
 8013680:	4618      	mov	r0, r3
 8013682:	b005      	add	sp, #20
 8013684:	f85d fb04 	ldr.w	pc, [sp], #4
 8013688:	f3af 8000 	nop.w
 801368c:	f3af 8000 	nop.w

08013690 <LSM303AGR_ACC_R_FifoMode>:
* Input          : Pointer to LSM303AGR_ACC_FM_t
* Output         : Status of FM see LSM303AGR_ACC_FM_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FifoMode(void *handle, LSM303AGR_ACC_FM_t *value)
{
 8013690:	b500      	push	{lr}
 8013692:	b083      	sub	sp, #12
 8013694:	9001      	str	r0, [sp, #4]
 8013696:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, (u8_t *)value, 1) )
 8013698:	9801      	ldr	r0, [sp, #4]
 801369a:	212e      	movs	r1, #46	; 0x2e
 801369c:	9a00      	ldr	r2, [sp, #0]
 801369e:	2301      	movs	r3, #1
 80136a0:	f7fd fe26 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80136a4:	4603      	mov	r3, r0
 80136a6:	2b00      	cmp	r3, #0
 80136a8:	d101      	bne.n	80136ae <LSM303AGR_ACC_R_FifoMode+0x1e>
    return MEMS_ERROR;
 80136aa:	2300      	movs	r3, #0
 80136ac:	e007      	b.n	80136be <LSM303AGR_ACC_R_FifoMode+0x2e>

  *value &= LSM303AGR_ACC_FM_MASK; //mask
 80136ae:	9b00      	ldr	r3, [sp, #0]
 80136b0:	781b      	ldrb	r3, [r3, #0]
 80136b2:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 80136b6:	b2da      	uxtb	r2, r3
 80136b8:	9b00      	ldr	r3, [sp, #0]
 80136ba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80136bc:	2301      	movs	r3, #1
}
 80136be:	4618      	mov	r0, r3
 80136c0:	b003      	add	sp, #12
 80136c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80136c6:	bf00      	nop
 80136c8:	f3af 8000 	nop.w
 80136cc:	f3af 8000 	nop.w

080136d0 <LSM303AGR_ACC_R_FifoSamplesAvail>:
* Input          : Pointer to u8_t
* Output         : Status of FSS
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FifoSamplesAvail(void *handle, u8_t *value)
{
 80136d0:	b500      	push	{lr}
 80136d2:	b083      	sub	sp, #12
 80136d4:	9001      	str	r0, [sp, #4]
 80136d6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_SRC_REG, (u8_t *)value, 1) )
 80136d8:	9801      	ldr	r0, [sp, #4]
 80136da:	212f      	movs	r1, #47	; 0x2f
 80136dc:	9a00      	ldr	r2, [sp, #0]
 80136de:	2301      	movs	r3, #1
 80136e0:	f7fd fe06 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80136e4:	4603      	mov	r3, r0
 80136e6:	2b00      	cmp	r3, #0
 80136e8:	d101      	bne.n	80136ee <LSM303AGR_ACC_R_FifoSamplesAvail+0x1e>
    return MEMS_ERROR;
 80136ea:	2300      	movs	r3, #0
 80136ec:	e00b      	b.n	8013706 <LSM303AGR_ACC_R_FifoSamplesAvail+0x36>

  *value &= LSM303AGR_ACC_FSS_MASK; //coerce
 80136ee:	9b00      	ldr	r3, [sp, #0]
 80136f0:	781b      	ldrb	r3, [r3, #0]
 80136f2:	f003 031f 	and.w	r3, r3, #31
 80136f6:	b2da      	uxtb	r2, r3
 80136f8:	9b00      	ldr	r3, [sp, #0]
 80136fa:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_FSS_POSITION; //mask
 80136fc:	9b00      	ldr	r3, [sp, #0]
 80136fe:	781a      	ldrb	r2, [r3, #0]
 8013700:	9b00      	ldr	r3, [sp, #0]
 8013702:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013704:	2301      	movs	r3, #1
}
 8013706:	4618      	mov	r0, r3
 8013708:	b003      	add	sp, #12
 801370a:	f85d fb04 	ldr.w	pc, [sp], #4
 801370e:	bf00      	nop

08013710 <LSM303AGR_ACC_R_FifoEmpty>:
* Input          : Pointer to LSM303AGR_ACC_EMPTY_t
* Output         : Status of EMPTY see LSM303AGR_ACC_EMPTY_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FifoEmpty(void *handle, LSM303AGR_ACC_EMPTY_t *value)
{
 8013710:	b500      	push	{lr}
 8013712:	b083      	sub	sp, #12
 8013714:	9001      	str	r0, [sp, #4]
 8013716:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_SRC_REG, (u8_t *)value, 1) )
 8013718:	9801      	ldr	r0, [sp, #4]
 801371a:	212f      	movs	r1, #47	; 0x2f
 801371c:	9a00      	ldr	r2, [sp, #0]
 801371e:	2301      	movs	r3, #1
 8013720:	f7fd fde6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013724:	4603      	mov	r3, r0
 8013726:	2b00      	cmp	r3, #0
 8013728:	d101      	bne.n	801372e <LSM303AGR_ACC_R_FifoEmpty+0x1e>
    return MEMS_ERROR;
 801372a:	2300      	movs	r3, #0
 801372c:	e007      	b.n	801373e <LSM303AGR_ACC_R_FifoEmpty+0x2e>

  *value &= LSM303AGR_ACC_EMPTY_MASK; //mask
 801372e:	9b00      	ldr	r3, [sp, #0]
 8013730:	781b      	ldrb	r3, [r3, #0]
 8013732:	f003 0320 	and.w	r3, r3, #32
 8013736:	b2da      	uxtb	r2, r3
 8013738:	9b00      	ldr	r3, [sp, #0]
 801373a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801373c:	2301      	movs	r3, #1
}
 801373e:	4618      	mov	r0, r3
 8013740:	b003      	add	sp, #12
 8013742:	f85d fb04 	ldr.w	pc, [sp], #4
 8013746:	bf00      	nop
 8013748:	f3af 8000 	nop.w
 801374c:	f3af 8000 	nop.w

08013750 <LSM303AGR_ACC_R_FifoOverrun>:
* Input          : Pointer to LSM303AGR_ACC_OVRN_FIFO_t
* Output         : Status of OVRN_FIFO see LSM303AGR_ACC_OVRN_FIFO_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FifoOverrun(void *handle, LSM303AGR_ACC_OVRN_FIFO_t *value)
{
 8013750:	b500      	push	{lr}
 8013752:	b083      	sub	sp, #12
 8013754:	9001      	str	r0, [sp, #4]
 8013756:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_SRC_REG, (u8_t *)value, 1) )
 8013758:	9801      	ldr	r0, [sp, #4]
 801375a:	212f      	movs	r1, #47	; 0x2f
 801375c:	9a00      	ldr	r2, [sp, #0]
 801375e:	2301      	movs	r3, #1
 8013760:	f7fd fdc6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013764:	4603      	mov	r3, r0
 8013766:	2b00      	cmp	r3, #0
 8013768:	d101      	bne.n	801376e <LSM303AGR_ACC_R_FifoOverrun+0x1e>
    return MEMS_ERROR;
 801376a:	2300      	movs	r3, #0
 801376c:	e007      	b.n	801377e <LSM303AGR_ACC_R_FifoOverrun+0x2e>

  *value &= LSM303AGR_ACC_OVRN_FIFO_MASK; //mask
 801376e:	9b00      	ldr	r3, [sp, #0]
 8013770:	781b      	ldrb	r3, [r3, #0]
 8013772:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8013776:	b2da      	uxtb	r2, r3
 8013778:	9b00      	ldr	r3, [sp, #0]
 801377a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801377c:	2301      	movs	r3, #1
}
 801377e:	4618      	mov	r0, r3
 8013780:	b003      	add	sp, #12
 8013782:	f85d fb04 	ldr.w	pc, [sp], #4
 8013786:	bf00      	nop
 8013788:	f3af 8000 	nop.w
 801378c:	f3af 8000 	nop.w

08013790 <LSM303AGR_ACC_R_WatermarkLevel>:
* Input          : Pointer to LSM303AGR_ACC_WTM_t
* Output         : Status of WTM see LSM303AGR_ACC_WTM_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_WatermarkLevel(void *handle, LSM303AGR_ACC_WTM_t *value)
{
 8013790:	b500      	push	{lr}
 8013792:	b083      	sub	sp, #12
 8013794:	9001      	str	r0, [sp, #4]
 8013796:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_SRC_REG, (u8_t *)value, 1) )
 8013798:	9801      	ldr	r0, [sp, #4]
 801379a:	212f      	movs	r1, #47	; 0x2f
 801379c:	9a00      	ldr	r2, [sp, #0]
 801379e:	2301      	movs	r3, #1
 80137a0:	f7fd fda6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80137a4:	4603      	mov	r3, r0
 80137a6:	2b00      	cmp	r3, #0
 80137a8:	d101      	bne.n	80137ae <LSM303AGR_ACC_R_WatermarkLevel+0x1e>
    return MEMS_ERROR;
 80137aa:	2300      	movs	r3, #0
 80137ac:	e007      	b.n	80137be <LSM303AGR_ACC_R_WatermarkLevel+0x2e>

  *value &= LSM303AGR_ACC_WTM_MASK; //mask
 80137ae:	9b00      	ldr	r3, [sp, #0]
 80137b0:	781b      	ldrb	r3, [r3, #0]
 80137b2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80137b6:	b2da      	uxtb	r2, r3
 80137b8:	9b00      	ldr	r3, [sp, #0]
 80137ba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80137bc:	2301      	movs	r3, #1
}
 80137be:	4618      	mov	r0, r3
 80137c0:	b003      	add	sp, #12
 80137c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80137c6:	bf00      	nop
 80137c8:	f3af 8000 	nop.w
 80137cc:	f3af 8000 	nop.w

080137d0 <LSM303AGR_ACC_W_Int1EnXLo>:
* Input          : LSM303AGR_ACC_XLIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1EnXLo(void *handle, LSM303AGR_ACC_XLIE_t newValue)
{
 80137d0:	b500      	push	{lr}
 80137d2:	b085      	sub	sp, #20
 80137d4:	9001      	str	r0, [sp, #4]
 80137d6:	460b      	mov	r3, r1
 80137d8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 80137dc:	f10d 030f 	add.w	r3, sp, #15
 80137e0:	9801      	ldr	r0, [sp, #4]
 80137e2:	2130      	movs	r1, #48	; 0x30
 80137e4:	461a      	mov	r2, r3
 80137e6:	2301      	movs	r3, #1
 80137e8:	f7fd fd82 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80137ec:	4603      	mov	r3, r0
 80137ee:	2b00      	cmp	r3, #0
 80137f0:	d101      	bne.n	80137f6 <LSM303AGR_ACC_W_Int1EnXLo+0x26>
    return MEMS_ERROR;
 80137f2:	2300      	movs	r3, #0
 80137f4:	e01c      	b.n	8013830 <LSM303AGR_ACC_W_Int1EnXLo+0x60>

  value &= ~LSM303AGR_ACC_XLIE_MASK;
 80137f6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80137fa:	f023 0301 	bic.w	r3, r3, #1
 80137fe:	b2db      	uxtb	r3, r3
 8013800:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013804:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013808:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801380c:	4313      	orrs	r3, r2
 801380e:	b2db      	uxtb	r3, r3
 8013810:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8013814:	f10d 030f 	add.w	r3, sp, #15
 8013818:	9801      	ldr	r0, [sp, #4]
 801381a:	2130      	movs	r1, #48	; 0x30
 801381c:	461a      	mov	r2, r3
 801381e:	2301      	movs	r3, #1
 8013820:	f7fd fd3e 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8013824:	4603      	mov	r3, r0
 8013826:	2b00      	cmp	r3, #0
 8013828:	d101      	bne.n	801382e <LSM303AGR_ACC_W_Int1EnXLo+0x5e>
    return MEMS_ERROR;
 801382a:	2300      	movs	r3, #0
 801382c:	e000      	b.n	8013830 <LSM303AGR_ACC_W_Int1EnXLo+0x60>

  return MEMS_SUCCESS;
 801382e:	2301      	movs	r3, #1
}
 8013830:	4618      	mov	r0, r3
 8013832:	b005      	add	sp, #20
 8013834:	f85d fb04 	ldr.w	pc, [sp], #4
 8013838:	f3af 8000 	nop.w
 801383c:	f3af 8000 	nop.w

08013840 <LSM303AGR_ACC_R_Int1EnXLo>:
* Input          : Pointer to LSM303AGR_ACC_XLIE_t
* Output         : Status of XLIE see LSM303AGR_ACC_XLIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1EnXLo(void *handle, LSM303AGR_ACC_XLIE_t *value)
{
 8013840:	b500      	push	{lr}
 8013842:	b083      	sub	sp, #12
 8013844:	9001      	str	r0, [sp, #4]
 8013846:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 8013848:	9801      	ldr	r0, [sp, #4]
 801384a:	2130      	movs	r1, #48	; 0x30
 801384c:	9a00      	ldr	r2, [sp, #0]
 801384e:	2301      	movs	r3, #1
 8013850:	f7fd fd4e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013854:	4603      	mov	r3, r0
 8013856:	2b00      	cmp	r3, #0
 8013858:	d101      	bne.n	801385e <LSM303AGR_ACC_R_Int1EnXLo+0x1e>
    return MEMS_ERROR;
 801385a:	2300      	movs	r3, #0
 801385c:	e007      	b.n	801386e <LSM303AGR_ACC_R_Int1EnXLo+0x2e>

  *value &= LSM303AGR_ACC_XLIE_MASK; //mask
 801385e:	9b00      	ldr	r3, [sp, #0]
 8013860:	781b      	ldrb	r3, [r3, #0]
 8013862:	f003 0301 	and.w	r3, r3, #1
 8013866:	b2da      	uxtb	r2, r3
 8013868:	9b00      	ldr	r3, [sp, #0]
 801386a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801386c:	2301      	movs	r3, #1
}
 801386e:	4618      	mov	r0, r3
 8013870:	b003      	add	sp, #12
 8013872:	f85d fb04 	ldr.w	pc, [sp], #4
 8013876:	bf00      	nop
 8013878:	f3af 8000 	nop.w
 801387c:	f3af 8000 	nop.w

08013880 <LSM303AGR_ACC_W_Int1EnXHi>:
* Input          : LSM303AGR_ACC_XHIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1EnXHi(void *handle, LSM303AGR_ACC_XHIE_t newValue)
{
 8013880:	b500      	push	{lr}
 8013882:	b085      	sub	sp, #20
 8013884:	9001      	str	r0, [sp, #4]
 8013886:	460b      	mov	r3, r1
 8013888:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 801388c:	f10d 030f 	add.w	r3, sp, #15
 8013890:	9801      	ldr	r0, [sp, #4]
 8013892:	2130      	movs	r1, #48	; 0x30
 8013894:	461a      	mov	r2, r3
 8013896:	2301      	movs	r3, #1
 8013898:	f7fd fd2a 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 801389c:	4603      	mov	r3, r0
 801389e:	2b00      	cmp	r3, #0
 80138a0:	d101      	bne.n	80138a6 <LSM303AGR_ACC_W_Int1EnXHi+0x26>
    return MEMS_ERROR;
 80138a2:	2300      	movs	r3, #0
 80138a4:	e01c      	b.n	80138e0 <LSM303AGR_ACC_W_Int1EnXHi+0x60>

  value &= ~LSM303AGR_ACC_XHIE_MASK;
 80138a6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80138aa:	f023 0302 	bic.w	r3, r3, #2
 80138ae:	b2db      	uxtb	r3, r3
 80138b0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80138b4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80138b8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80138bc:	4313      	orrs	r3, r2
 80138be:	b2db      	uxtb	r3, r3
 80138c0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 80138c4:	f10d 030f 	add.w	r3, sp, #15
 80138c8:	9801      	ldr	r0, [sp, #4]
 80138ca:	2130      	movs	r1, #48	; 0x30
 80138cc:	461a      	mov	r2, r3
 80138ce:	2301      	movs	r3, #1
 80138d0:	f7fd fce6 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 80138d4:	4603      	mov	r3, r0
 80138d6:	2b00      	cmp	r3, #0
 80138d8:	d101      	bne.n	80138de <LSM303AGR_ACC_W_Int1EnXHi+0x5e>
    return MEMS_ERROR;
 80138da:	2300      	movs	r3, #0
 80138dc:	e000      	b.n	80138e0 <LSM303AGR_ACC_W_Int1EnXHi+0x60>

  return MEMS_SUCCESS;
 80138de:	2301      	movs	r3, #1
}
 80138e0:	4618      	mov	r0, r3
 80138e2:	b005      	add	sp, #20
 80138e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80138e8:	f3af 8000 	nop.w
 80138ec:	f3af 8000 	nop.w

080138f0 <LSM303AGR_ACC_R_Int1EnXHi>:
* Input          : Pointer to LSM303AGR_ACC_XHIE_t
* Output         : Status of XHIE see LSM303AGR_ACC_XHIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1EnXHi(void *handle, LSM303AGR_ACC_XHIE_t *value)
{
 80138f0:	b500      	push	{lr}
 80138f2:	b083      	sub	sp, #12
 80138f4:	9001      	str	r0, [sp, #4]
 80138f6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 80138f8:	9801      	ldr	r0, [sp, #4]
 80138fa:	2130      	movs	r1, #48	; 0x30
 80138fc:	9a00      	ldr	r2, [sp, #0]
 80138fe:	2301      	movs	r3, #1
 8013900:	f7fd fcf6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013904:	4603      	mov	r3, r0
 8013906:	2b00      	cmp	r3, #0
 8013908:	d101      	bne.n	801390e <LSM303AGR_ACC_R_Int1EnXHi+0x1e>
    return MEMS_ERROR;
 801390a:	2300      	movs	r3, #0
 801390c:	e007      	b.n	801391e <LSM303AGR_ACC_R_Int1EnXHi+0x2e>

  *value &= LSM303AGR_ACC_XHIE_MASK; //mask
 801390e:	9b00      	ldr	r3, [sp, #0]
 8013910:	781b      	ldrb	r3, [r3, #0]
 8013912:	f003 0302 	and.w	r3, r3, #2
 8013916:	b2da      	uxtb	r2, r3
 8013918:	9b00      	ldr	r3, [sp, #0]
 801391a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801391c:	2301      	movs	r3, #1
}
 801391e:	4618      	mov	r0, r3
 8013920:	b003      	add	sp, #12
 8013922:	f85d fb04 	ldr.w	pc, [sp], #4
 8013926:	bf00      	nop
 8013928:	f3af 8000 	nop.w
 801392c:	f3af 8000 	nop.w

08013930 <LSM303AGR_ACC_W_Int1EnYLo>:
* Input          : LSM303AGR_ACC_YLIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1EnYLo(void *handle, LSM303AGR_ACC_YLIE_t newValue)
{
 8013930:	b500      	push	{lr}
 8013932:	b085      	sub	sp, #20
 8013934:	9001      	str	r0, [sp, #4]
 8013936:	460b      	mov	r3, r1
 8013938:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 801393c:	f10d 030f 	add.w	r3, sp, #15
 8013940:	9801      	ldr	r0, [sp, #4]
 8013942:	2130      	movs	r1, #48	; 0x30
 8013944:	461a      	mov	r2, r3
 8013946:	2301      	movs	r3, #1
 8013948:	f7fd fcd2 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 801394c:	4603      	mov	r3, r0
 801394e:	2b00      	cmp	r3, #0
 8013950:	d101      	bne.n	8013956 <LSM303AGR_ACC_W_Int1EnYLo+0x26>
    return MEMS_ERROR;
 8013952:	2300      	movs	r3, #0
 8013954:	e01c      	b.n	8013990 <LSM303AGR_ACC_W_Int1EnYLo+0x60>

  value &= ~LSM303AGR_ACC_YLIE_MASK;
 8013956:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801395a:	f023 0304 	bic.w	r3, r3, #4
 801395e:	b2db      	uxtb	r3, r3
 8013960:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013964:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013968:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801396c:	4313      	orrs	r3, r2
 801396e:	b2db      	uxtb	r3, r3
 8013970:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8013974:	f10d 030f 	add.w	r3, sp, #15
 8013978:	9801      	ldr	r0, [sp, #4]
 801397a:	2130      	movs	r1, #48	; 0x30
 801397c:	461a      	mov	r2, r3
 801397e:	2301      	movs	r3, #1
 8013980:	f7fd fc8e 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8013984:	4603      	mov	r3, r0
 8013986:	2b00      	cmp	r3, #0
 8013988:	d101      	bne.n	801398e <LSM303AGR_ACC_W_Int1EnYLo+0x5e>
    return MEMS_ERROR;
 801398a:	2300      	movs	r3, #0
 801398c:	e000      	b.n	8013990 <LSM303AGR_ACC_W_Int1EnYLo+0x60>

  return MEMS_SUCCESS;
 801398e:	2301      	movs	r3, #1
}
 8013990:	4618      	mov	r0, r3
 8013992:	b005      	add	sp, #20
 8013994:	f85d fb04 	ldr.w	pc, [sp], #4
 8013998:	f3af 8000 	nop.w
 801399c:	f3af 8000 	nop.w

080139a0 <LSM303AGR_ACC_R_Int1EnYLo>:
* Input          : Pointer to LSM303AGR_ACC_YLIE_t
* Output         : Status of YLIE see LSM303AGR_ACC_YLIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1EnYLo(void *handle, LSM303AGR_ACC_YLIE_t *value)
{
 80139a0:	b500      	push	{lr}
 80139a2:	b083      	sub	sp, #12
 80139a4:	9001      	str	r0, [sp, #4]
 80139a6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 80139a8:	9801      	ldr	r0, [sp, #4]
 80139aa:	2130      	movs	r1, #48	; 0x30
 80139ac:	9a00      	ldr	r2, [sp, #0]
 80139ae:	2301      	movs	r3, #1
 80139b0:	f7fd fc9e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80139b4:	4603      	mov	r3, r0
 80139b6:	2b00      	cmp	r3, #0
 80139b8:	d101      	bne.n	80139be <LSM303AGR_ACC_R_Int1EnYLo+0x1e>
    return MEMS_ERROR;
 80139ba:	2300      	movs	r3, #0
 80139bc:	e007      	b.n	80139ce <LSM303AGR_ACC_R_Int1EnYLo+0x2e>

  *value &= LSM303AGR_ACC_YLIE_MASK; //mask
 80139be:	9b00      	ldr	r3, [sp, #0]
 80139c0:	781b      	ldrb	r3, [r3, #0]
 80139c2:	f003 0304 	and.w	r3, r3, #4
 80139c6:	b2da      	uxtb	r2, r3
 80139c8:	9b00      	ldr	r3, [sp, #0]
 80139ca:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80139cc:	2301      	movs	r3, #1
}
 80139ce:	4618      	mov	r0, r3
 80139d0:	b003      	add	sp, #12
 80139d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80139d6:	bf00      	nop
 80139d8:	f3af 8000 	nop.w
 80139dc:	f3af 8000 	nop.w

080139e0 <LSM303AGR_ACC_W_Int1EnYHi>:
* Input          : LSM303AGR_ACC_YHIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1EnYHi(void *handle, LSM303AGR_ACC_YHIE_t newValue)
{
 80139e0:	b500      	push	{lr}
 80139e2:	b085      	sub	sp, #20
 80139e4:	9001      	str	r0, [sp, #4]
 80139e6:	460b      	mov	r3, r1
 80139e8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 80139ec:	f10d 030f 	add.w	r3, sp, #15
 80139f0:	9801      	ldr	r0, [sp, #4]
 80139f2:	2130      	movs	r1, #48	; 0x30
 80139f4:	461a      	mov	r2, r3
 80139f6:	2301      	movs	r3, #1
 80139f8:	f7fd fc7a 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80139fc:	4603      	mov	r3, r0
 80139fe:	2b00      	cmp	r3, #0
 8013a00:	d101      	bne.n	8013a06 <LSM303AGR_ACC_W_Int1EnYHi+0x26>
    return MEMS_ERROR;
 8013a02:	2300      	movs	r3, #0
 8013a04:	e01c      	b.n	8013a40 <LSM303AGR_ACC_W_Int1EnYHi+0x60>

  value &= ~LSM303AGR_ACC_YHIE_MASK;
 8013a06:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013a0a:	f023 0308 	bic.w	r3, r3, #8
 8013a0e:	b2db      	uxtb	r3, r3
 8013a10:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013a14:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013a18:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013a1c:	4313      	orrs	r3, r2
 8013a1e:	b2db      	uxtb	r3, r3
 8013a20:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8013a24:	f10d 030f 	add.w	r3, sp, #15
 8013a28:	9801      	ldr	r0, [sp, #4]
 8013a2a:	2130      	movs	r1, #48	; 0x30
 8013a2c:	461a      	mov	r2, r3
 8013a2e:	2301      	movs	r3, #1
 8013a30:	f7fd fc36 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8013a34:	4603      	mov	r3, r0
 8013a36:	2b00      	cmp	r3, #0
 8013a38:	d101      	bne.n	8013a3e <LSM303AGR_ACC_W_Int1EnYHi+0x5e>
    return MEMS_ERROR;
 8013a3a:	2300      	movs	r3, #0
 8013a3c:	e000      	b.n	8013a40 <LSM303AGR_ACC_W_Int1EnYHi+0x60>

  return MEMS_SUCCESS;
 8013a3e:	2301      	movs	r3, #1
}
 8013a40:	4618      	mov	r0, r3
 8013a42:	b005      	add	sp, #20
 8013a44:	f85d fb04 	ldr.w	pc, [sp], #4
 8013a48:	f3af 8000 	nop.w
 8013a4c:	f3af 8000 	nop.w

08013a50 <LSM303AGR_ACC_R_Int1EnYHi>:
* Input          : Pointer to LSM303AGR_ACC_YHIE_t
* Output         : Status of YHIE see LSM303AGR_ACC_YHIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1EnYHi(void *handle, LSM303AGR_ACC_YHIE_t *value)
{
 8013a50:	b500      	push	{lr}
 8013a52:	b083      	sub	sp, #12
 8013a54:	9001      	str	r0, [sp, #4]
 8013a56:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 8013a58:	9801      	ldr	r0, [sp, #4]
 8013a5a:	2130      	movs	r1, #48	; 0x30
 8013a5c:	9a00      	ldr	r2, [sp, #0]
 8013a5e:	2301      	movs	r3, #1
 8013a60:	f7fd fc46 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013a64:	4603      	mov	r3, r0
 8013a66:	2b00      	cmp	r3, #0
 8013a68:	d101      	bne.n	8013a6e <LSM303AGR_ACC_R_Int1EnYHi+0x1e>
    return MEMS_ERROR;
 8013a6a:	2300      	movs	r3, #0
 8013a6c:	e007      	b.n	8013a7e <LSM303AGR_ACC_R_Int1EnYHi+0x2e>

  *value &= LSM303AGR_ACC_YHIE_MASK; //mask
 8013a6e:	9b00      	ldr	r3, [sp, #0]
 8013a70:	781b      	ldrb	r3, [r3, #0]
 8013a72:	f003 0308 	and.w	r3, r3, #8
 8013a76:	b2da      	uxtb	r2, r3
 8013a78:	9b00      	ldr	r3, [sp, #0]
 8013a7a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013a7c:	2301      	movs	r3, #1
}
 8013a7e:	4618      	mov	r0, r3
 8013a80:	b003      	add	sp, #12
 8013a82:	f85d fb04 	ldr.w	pc, [sp], #4
 8013a86:	bf00      	nop
 8013a88:	f3af 8000 	nop.w
 8013a8c:	f3af 8000 	nop.w

08013a90 <LSM303AGR_ACC_W_Int1EnZLo>:
* Input          : LSM303AGR_ACC_ZLIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1EnZLo(void *handle, LSM303AGR_ACC_ZLIE_t newValue)
{
 8013a90:	b500      	push	{lr}
 8013a92:	b085      	sub	sp, #20
 8013a94:	9001      	str	r0, [sp, #4]
 8013a96:	460b      	mov	r3, r1
 8013a98:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8013a9c:	f10d 030f 	add.w	r3, sp, #15
 8013aa0:	9801      	ldr	r0, [sp, #4]
 8013aa2:	2130      	movs	r1, #48	; 0x30
 8013aa4:	461a      	mov	r2, r3
 8013aa6:	2301      	movs	r3, #1
 8013aa8:	f7fd fc22 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013aac:	4603      	mov	r3, r0
 8013aae:	2b00      	cmp	r3, #0
 8013ab0:	d101      	bne.n	8013ab6 <LSM303AGR_ACC_W_Int1EnZLo+0x26>
    return MEMS_ERROR;
 8013ab2:	2300      	movs	r3, #0
 8013ab4:	e01c      	b.n	8013af0 <LSM303AGR_ACC_W_Int1EnZLo+0x60>

  value &= ~LSM303AGR_ACC_ZLIE_MASK;
 8013ab6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013aba:	f023 0310 	bic.w	r3, r3, #16
 8013abe:	b2db      	uxtb	r3, r3
 8013ac0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013ac4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013ac8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013acc:	4313      	orrs	r3, r2
 8013ace:	b2db      	uxtb	r3, r3
 8013ad0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8013ad4:	f10d 030f 	add.w	r3, sp, #15
 8013ad8:	9801      	ldr	r0, [sp, #4]
 8013ada:	2130      	movs	r1, #48	; 0x30
 8013adc:	461a      	mov	r2, r3
 8013ade:	2301      	movs	r3, #1
 8013ae0:	f7fd fbde 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8013ae4:	4603      	mov	r3, r0
 8013ae6:	2b00      	cmp	r3, #0
 8013ae8:	d101      	bne.n	8013aee <LSM303AGR_ACC_W_Int1EnZLo+0x5e>
    return MEMS_ERROR;
 8013aea:	2300      	movs	r3, #0
 8013aec:	e000      	b.n	8013af0 <LSM303AGR_ACC_W_Int1EnZLo+0x60>

  return MEMS_SUCCESS;
 8013aee:	2301      	movs	r3, #1
}
 8013af0:	4618      	mov	r0, r3
 8013af2:	b005      	add	sp, #20
 8013af4:	f85d fb04 	ldr.w	pc, [sp], #4
 8013af8:	f3af 8000 	nop.w
 8013afc:	f3af 8000 	nop.w

08013b00 <LSM303AGR_ACC_R_Int1EnZLo>:
* Input          : Pointer to LSM303AGR_ACC_ZLIE_t
* Output         : Status of ZLIE see LSM303AGR_ACC_ZLIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1EnZLo(void *handle, LSM303AGR_ACC_ZLIE_t *value)
{
 8013b00:	b500      	push	{lr}
 8013b02:	b083      	sub	sp, #12
 8013b04:	9001      	str	r0, [sp, #4]
 8013b06:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 8013b08:	9801      	ldr	r0, [sp, #4]
 8013b0a:	2130      	movs	r1, #48	; 0x30
 8013b0c:	9a00      	ldr	r2, [sp, #0]
 8013b0e:	2301      	movs	r3, #1
 8013b10:	f7fd fbee 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013b14:	4603      	mov	r3, r0
 8013b16:	2b00      	cmp	r3, #0
 8013b18:	d101      	bne.n	8013b1e <LSM303AGR_ACC_R_Int1EnZLo+0x1e>
    return MEMS_ERROR;
 8013b1a:	2300      	movs	r3, #0
 8013b1c:	e007      	b.n	8013b2e <LSM303AGR_ACC_R_Int1EnZLo+0x2e>

  *value &= LSM303AGR_ACC_ZLIE_MASK; //mask
 8013b1e:	9b00      	ldr	r3, [sp, #0]
 8013b20:	781b      	ldrb	r3, [r3, #0]
 8013b22:	f003 0310 	and.w	r3, r3, #16
 8013b26:	b2da      	uxtb	r2, r3
 8013b28:	9b00      	ldr	r3, [sp, #0]
 8013b2a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013b2c:	2301      	movs	r3, #1
}
 8013b2e:	4618      	mov	r0, r3
 8013b30:	b003      	add	sp, #12
 8013b32:	f85d fb04 	ldr.w	pc, [sp], #4
 8013b36:	bf00      	nop
 8013b38:	f3af 8000 	nop.w
 8013b3c:	f3af 8000 	nop.w

08013b40 <LSM303AGR_ACC_W_Int1EnZHi>:
* Input          : LSM303AGR_ACC_ZHIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1EnZHi(void *handle, LSM303AGR_ACC_ZHIE_t newValue)
{
 8013b40:	b500      	push	{lr}
 8013b42:	b085      	sub	sp, #20
 8013b44:	9001      	str	r0, [sp, #4]
 8013b46:	460b      	mov	r3, r1
 8013b48:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8013b4c:	f10d 030f 	add.w	r3, sp, #15
 8013b50:	9801      	ldr	r0, [sp, #4]
 8013b52:	2130      	movs	r1, #48	; 0x30
 8013b54:	461a      	mov	r2, r3
 8013b56:	2301      	movs	r3, #1
 8013b58:	f7fd fbca 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013b5c:	4603      	mov	r3, r0
 8013b5e:	2b00      	cmp	r3, #0
 8013b60:	d101      	bne.n	8013b66 <LSM303AGR_ACC_W_Int1EnZHi+0x26>
    return MEMS_ERROR;
 8013b62:	2300      	movs	r3, #0
 8013b64:	e01c      	b.n	8013ba0 <LSM303AGR_ACC_W_Int1EnZHi+0x60>

  value &= ~LSM303AGR_ACC_ZHIE_MASK;
 8013b66:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013b6a:	f023 0320 	bic.w	r3, r3, #32
 8013b6e:	b2db      	uxtb	r3, r3
 8013b70:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013b74:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013b78:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013b7c:	4313      	orrs	r3, r2
 8013b7e:	b2db      	uxtb	r3, r3
 8013b80:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8013b84:	f10d 030f 	add.w	r3, sp, #15
 8013b88:	9801      	ldr	r0, [sp, #4]
 8013b8a:	2130      	movs	r1, #48	; 0x30
 8013b8c:	461a      	mov	r2, r3
 8013b8e:	2301      	movs	r3, #1
 8013b90:	f7fd fb86 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8013b94:	4603      	mov	r3, r0
 8013b96:	2b00      	cmp	r3, #0
 8013b98:	d101      	bne.n	8013b9e <LSM303AGR_ACC_W_Int1EnZHi+0x5e>
    return MEMS_ERROR;
 8013b9a:	2300      	movs	r3, #0
 8013b9c:	e000      	b.n	8013ba0 <LSM303AGR_ACC_W_Int1EnZHi+0x60>

  return MEMS_SUCCESS;
 8013b9e:	2301      	movs	r3, #1
}
 8013ba0:	4618      	mov	r0, r3
 8013ba2:	b005      	add	sp, #20
 8013ba4:	f85d fb04 	ldr.w	pc, [sp], #4
 8013ba8:	f3af 8000 	nop.w
 8013bac:	f3af 8000 	nop.w

08013bb0 <LSM303AGR_ACC_R_Int1EnZHi>:
* Input          : Pointer to LSM303AGR_ACC_ZHIE_t
* Output         : Status of ZHIE see LSM303AGR_ACC_ZHIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1EnZHi(void *handle, LSM303AGR_ACC_ZHIE_t *value)
{
 8013bb0:	b500      	push	{lr}
 8013bb2:	b083      	sub	sp, #12
 8013bb4:	9001      	str	r0, [sp, #4]
 8013bb6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 8013bb8:	9801      	ldr	r0, [sp, #4]
 8013bba:	2130      	movs	r1, #48	; 0x30
 8013bbc:	9a00      	ldr	r2, [sp, #0]
 8013bbe:	2301      	movs	r3, #1
 8013bc0:	f7fd fb96 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013bc4:	4603      	mov	r3, r0
 8013bc6:	2b00      	cmp	r3, #0
 8013bc8:	d101      	bne.n	8013bce <LSM303AGR_ACC_R_Int1EnZHi+0x1e>
    return MEMS_ERROR;
 8013bca:	2300      	movs	r3, #0
 8013bcc:	e007      	b.n	8013bde <LSM303AGR_ACC_R_Int1EnZHi+0x2e>

  *value &= LSM303AGR_ACC_ZHIE_MASK; //mask
 8013bce:	9b00      	ldr	r3, [sp, #0]
 8013bd0:	781b      	ldrb	r3, [r3, #0]
 8013bd2:	f003 0320 	and.w	r3, r3, #32
 8013bd6:	b2da      	uxtb	r2, r3
 8013bd8:	9b00      	ldr	r3, [sp, #0]
 8013bda:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013bdc:	2301      	movs	r3, #1
}
 8013bde:	4618      	mov	r0, r3
 8013be0:	b003      	add	sp, #12
 8013be2:	f85d fb04 	ldr.w	pc, [sp], #4
 8013be6:	bf00      	nop
 8013be8:	f3af 8000 	nop.w
 8013bec:	f3af 8000 	nop.w

08013bf0 <LSM303AGR_ACC_W_Int1_6D>:
* Input          : LSM303AGR_ACC_6D_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1_6D(void *handle, LSM303AGR_ACC_6D_t newValue)
{
 8013bf0:	b500      	push	{lr}
 8013bf2:	b085      	sub	sp, #20
 8013bf4:	9001      	str	r0, [sp, #4]
 8013bf6:	460b      	mov	r3, r1
 8013bf8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8013bfc:	f10d 030f 	add.w	r3, sp, #15
 8013c00:	9801      	ldr	r0, [sp, #4]
 8013c02:	2130      	movs	r1, #48	; 0x30
 8013c04:	461a      	mov	r2, r3
 8013c06:	2301      	movs	r3, #1
 8013c08:	f7fd fb72 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013c0c:	4603      	mov	r3, r0
 8013c0e:	2b00      	cmp	r3, #0
 8013c10:	d101      	bne.n	8013c16 <LSM303AGR_ACC_W_Int1_6D+0x26>
    return MEMS_ERROR;
 8013c12:	2300      	movs	r3, #0
 8013c14:	e01c      	b.n	8013c50 <LSM303AGR_ACC_W_Int1_6D+0x60>

  value &= ~LSM303AGR_ACC_6D_MASK;
 8013c16:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013c1a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8013c1e:	b2db      	uxtb	r3, r3
 8013c20:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013c24:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013c28:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013c2c:	4313      	orrs	r3, r2
 8013c2e:	b2db      	uxtb	r3, r3
 8013c30:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8013c34:	f10d 030f 	add.w	r3, sp, #15
 8013c38:	9801      	ldr	r0, [sp, #4]
 8013c3a:	2130      	movs	r1, #48	; 0x30
 8013c3c:	461a      	mov	r2, r3
 8013c3e:	2301      	movs	r3, #1
 8013c40:	f7fd fb2e 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8013c44:	4603      	mov	r3, r0
 8013c46:	2b00      	cmp	r3, #0
 8013c48:	d101      	bne.n	8013c4e <LSM303AGR_ACC_W_Int1_6D+0x5e>
    return MEMS_ERROR;
 8013c4a:	2300      	movs	r3, #0
 8013c4c:	e000      	b.n	8013c50 <LSM303AGR_ACC_W_Int1_6D+0x60>

  return MEMS_SUCCESS;
 8013c4e:	2301      	movs	r3, #1
}
 8013c50:	4618      	mov	r0, r3
 8013c52:	b005      	add	sp, #20
 8013c54:	f85d fb04 	ldr.w	pc, [sp], #4
 8013c58:	f3af 8000 	nop.w
 8013c5c:	f3af 8000 	nop.w

08013c60 <LSM303AGR_ACC_R_Int1_6D>:
* Input          : Pointer to LSM303AGR_ACC_6D_t
* Output         : Status of 6D see LSM303AGR_ACC_6D_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_6D(void *handle, LSM303AGR_ACC_6D_t *value)
{
 8013c60:	b500      	push	{lr}
 8013c62:	b083      	sub	sp, #12
 8013c64:	9001      	str	r0, [sp, #4]
 8013c66:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 8013c68:	9801      	ldr	r0, [sp, #4]
 8013c6a:	2130      	movs	r1, #48	; 0x30
 8013c6c:	9a00      	ldr	r2, [sp, #0]
 8013c6e:	2301      	movs	r3, #1
 8013c70:	f7fd fb3e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013c74:	4603      	mov	r3, r0
 8013c76:	2b00      	cmp	r3, #0
 8013c78:	d101      	bne.n	8013c7e <LSM303AGR_ACC_R_Int1_6D+0x1e>
    return MEMS_ERROR;
 8013c7a:	2300      	movs	r3, #0
 8013c7c:	e007      	b.n	8013c8e <LSM303AGR_ACC_R_Int1_6D+0x2e>

  *value &= LSM303AGR_ACC_6D_MASK; //mask
 8013c7e:	9b00      	ldr	r3, [sp, #0]
 8013c80:	781b      	ldrb	r3, [r3, #0]
 8013c82:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8013c86:	b2da      	uxtb	r2, r3
 8013c88:	9b00      	ldr	r3, [sp, #0]
 8013c8a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013c8c:	2301      	movs	r3, #1
}
 8013c8e:	4618      	mov	r0, r3
 8013c90:	b003      	add	sp, #12
 8013c92:	f85d fb04 	ldr.w	pc, [sp], #4
 8013c96:	bf00      	nop
 8013c98:	f3af 8000 	nop.w
 8013c9c:	f3af 8000 	nop.w

08013ca0 <LSM303AGR_ACC_W_Int1_AOI>:
* Input          : LSM303AGR_ACC_AOI_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1_AOI(void *handle, LSM303AGR_ACC_AOI_t newValue)
{
 8013ca0:	b500      	push	{lr}
 8013ca2:	b085      	sub	sp, #20
 8013ca4:	9001      	str	r0, [sp, #4]
 8013ca6:	460b      	mov	r3, r1
 8013ca8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8013cac:	f10d 030f 	add.w	r3, sp, #15
 8013cb0:	9801      	ldr	r0, [sp, #4]
 8013cb2:	2130      	movs	r1, #48	; 0x30
 8013cb4:	461a      	mov	r2, r3
 8013cb6:	2301      	movs	r3, #1
 8013cb8:	f7fd fb1a 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013cbc:	4603      	mov	r3, r0
 8013cbe:	2b00      	cmp	r3, #0
 8013cc0:	d101      	bne.n	8013cc6 <LSM303AGR_ACC_W_Int1_AOI+0x26>
    return MEMS_ERROR;
 8013cc2:	2300      	movs	r3, #0
 8013cc4:	e01c      	b.n	8013d00 <LSM303AGR_ACC_W_Int1_AOI+0x60>

  value &= ~LSM303AGR_ACC_AOI_MASK;
 8013cc6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013cca:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8013cce:	b2db      	uxtb	r3, r3
 8013cd0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013cd4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013cd8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013cdc:	4313      	orrs	r3, r2
 8013cde:	b2db      	uxtb	r3, r3
 8013ce0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8013ce4:	f10d 030f 	add.w	r3, sp, #15
 8013ce8:	9801      	ldr	r0, [sp, #4]
 8013cea:	2130      	movs	r1, #48	; 0x30
 8013cec:	461a      	mov	r2, r3
 8013cee:	2301      	movs	r3, #1
 8013cf0:	f7fd fad6 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8013cf4:	4603      	mov	r3, r0
 8013cf6:	2b00      	cmp	r3, #0
 8013cf8:	d101      	bne.n	8013cfe <LSM303AGR_ACC_W_Int1_AOI+0x5e>
    return MEMS_ERROR;
 8013cfa:	2300      	movs	r3, #0
 8013cfc:	e000      	b.n	8013d00 <LSM303AGR_ACC_W_Int1_AOI+0x60>

  return MEMS_SUCCESS;
 8013cfe:	2301      	movs	r3, #1
}
 8013d00:	4618      	mov	r0, r3
 8013d02:	b005      	add	sp, #20
 8013d04:	f85d fb04 	ldr.w	pc, [sp], #4
 8013d08:	f3af 8000 	nop.w
 8013d0c:	f3af 8000 	nop.w

08013d10 <LSM303AGR_ACC_R_Int1_AOI>:
* Input          : Pointer to LSM303AGR_ACC_AOI_t
* Output         : Status of AOI see LSM303AGR_ACC_AOI_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_AOI(void *handle, LSM303AGR_ACC_AOI_t *value)
{
 8013d10:	b500      	push	{lr}
 8013d12:	b083      	sub	sp, #12
 8013d14:	9001      	str	r0, [sp, #4]
 8013d16:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 8013d18:	9801      	ldr	r0, [sp, #4]
 8013d1a:	2130      	movs	r1, #48	; 0x30
 8013d1c:	9a00      	ldr	r2, [sp, #0]
 8013d1e:	2301      	movs	r3, #1
 8013d20:	f7fd fae6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013d24:	4603      	mov	r3, r0
 8013d26:	2b00      	cmp	r3, #0
 8013d28:	d101      	bne.n	8013d2e <LSM303AGR_ACC_R_Int1_AOI+0x1e>
    return MEMS_ERROR;
 8013d2a:	2300      	movs	r3, #0
 8013d2c:	e007      	b.n	8013d3e <LSM303AGR_ACC_R_Int1_AOI+0x2e>

  *value &= LSM303AGR_ACC_AOI_MASK; //mask
 8013d2e:	9b00      	ldr	r3, [sp, #0]
 8013d30:	781b      	ldrb	r3, [r3, #0]
 8013d32:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8013d36:	b2da      	uxtb	r2, r3
 8013d38:	9b00      	ldr	r3, [sp, #0]
 8013d3a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013d3c:	2301      	movs	r3, #1
}
 8013d3e:	4618      	mov	r0, r3
 8013d40:	b003      	add	sp, #12
 8013d42:	f85d fb04 	ldr.w	pc, [sp], #4
 8013d46:	bf00      	nop
 8013d48:	f3af 8000 	nop.w
 8013d4c:	f3af 8000 	nop.w

08013d50 <LSM303AGR_ACC_W_Int2EnXLo>:
* Input          : LSM303AGR_ACC_XLIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2EnXLo(void *handle, LSM303AGR_ACC_XLIE_t newValue)
{
 8013d50:	b500      	push	{lr}
 8013d52:	b085      	sub	sp, #20
 8013d54:	9001      	str	r0, [sp, #4]
 8013d56:	460b      	mov	r3, r1
 8013d58:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8013d5c:	f10d 030f 	add.w	r3, sp, #15
 8013d60:	9801      	ldr	r0, [sp, #4]
 8013d62:	2134      	movs	r1, #52	; 0x34
 8013d64:	461a      	mov	r2, r3
 8013d66:	2301      	movs	r3, #1
 8013d68:	f7fd fac2 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013d6c:	4603      	mov	r3, r0
 8013d6e:	2b00      	cmp	r3, #0
 8013d70:	d101      	bne.n	8013d76 <LSM303AGR_ACC_W_Int2EnXLo+0x26>
    return MEMS_ERROR;
 8013d72:	2300      	movs	r3, #0
 8013d74:	e01c      	b.n	8013db0 <LSM303AGR_ACC_W_Int2EnXLo+0x60>

  value &= ~LSM303AGR_ACC_XLIE_MASK;
 8013d76:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013d7a:	f023 0301 	bic.w	r3, r3, #1
 8013d7e:	b2db      	uxtb	r3, r3
 8013d80:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013d84:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013d88:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013d8c:	4313      	orrs	r3, r2
 8013d8e:	b2db      	uxtb	r3, r3
 8013d90:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8013d94:	f10d 030f 	add.w	r3, sp, #15
 8013d98:	9801      	ldr	r0, [sp, #4]
 8013d9a:	2134      	movs	r1, #52	; 0x34
 8013d9c:	461a      	mov	r2, r3
 8013d9e:	2301      	movs	r3, #1
 8013da0:	f7fd fa7e 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8013da4:	4603      	mov	r3, r0
 8013da6:	2b00      	cmp	r3, #0
 8013da8:	d101      	bne.n	8013dae <LSM303AGR_ACC_W_Int2EnXLo+0x5e>
    return MEMS_ERROR;
 8013daa:	2300      	movs	r3, #0
 8013dac:	e000      	b.n	8013db0 <LSM303AGR_ACC_W_Int2EnXLo+0x60>

  return MEMS_SUCCESS;
 8013dae:	2301      	movs	r3, #1
}
 8013db0:	4618      	mov	r0, r3
 8013db2:	b005      	add	sp, #20
 8013db4:	f85d fb04 	ldr.w	pc, [sp], #4
 8013db8:	f3af 8000 	nop.w
 8013dbc:	f3af 8000 	nop.w

08013dc0 <LSM303AGR_ACC_R_Int2EnXLo>:
* Input          : Pointer to LSM303AGR_ACC_XLIE_t
* Output         : Status of XLIE see LSM303AGR_ACC_XLIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2EnXLo(void *handle, LSM303AGR_ACC_XLIE_t *value)
{
 8013dc0:	b500      	push	{lr}
 8013dc2:	b083      	sub	sp, #12
 8013dc4:	9001      	str	r0, [sp, #4]
 8013dc6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8013dc8:	9801      	ldr	r0, [sp, #4]
 8013dca:	2134      	movs	r1, #52	; 0x34
 8013dcc:	9a00      	ldr	r2, [sp, #0]
 8013dce:	2301      	movs	r3, #1
 8013dd0:	f7fd fa8e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013dd4:	4603      	mov	r3, r0
 8013dd6:	2b00      	cmp	r3, #0
 8013dd8:	d101      	bne.n	8013dde <LSM303AGR_ACC_R_Int2EnXLo+0x1e>
    return MEMS_ERROR;
 8013dda:	2300      	movs	r3, #0
 8013ddc:	e007      	b.n	8013dee <LSM303AGR_ACC_R_Int2EnXLo+0x2e>

  *value &= LSM303AGR_ACC_XLIE_MASK; //mask
 8013dde:	9b00      	ldr	r3, [sp, #0]
 8013de0:	781b      	ldrb	r3, [r3, #0]
 8013de2:	f003 0301 	and.w	r3, r3, #1
 8013de6:	b2da      	uxtb	r2, r3
 8013de8:	9b00      	ldr	r3, [sp, #0]
 8013dea:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013dec:	2301      	movs	r3, #1
}
 8013dee:	4618      	mov	r0, r3
 8013df0:	b003      	add	sp, #12
 8013df2:	f85d fb04 	ldr.w	pc, [sp], #4
 8013df6:	bf00      	nop
 8013df8:	f3af 8000 	nop.w
 8013dfc:	f3af 8000 	nop.w

08013e00 <LSM303AGR_ACC_W_Int2EnXHi>:
* Input          : LSM303AGR_ACC_XHIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2EnXHi(void *handle, LSM303AGR_ACC_XHIE_t newValue)
{
 8013e00:	b500      	push	{lr}
 8013e02:	b085      	sub	sp, #20
 8013e04:	9001      	str	r0, [sp, #4]
 8013e06:	460b      	mov	r3, r1
 8013e08:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8013e0c:	f10d 030f 	add.w	r3, sp, #15
 8013e10:	9801      	ldr	r0, [sp, #4]
 8013e12:	2134      	movs	r1, #52	; 0x34
 8013e14:	461a      	mov	r2, r3
 8013e16:	2301      	movs	r3, #1
 8013e18:	f7fd fa6a 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013e1c:	4603      	mov	r3, r0
 8013e1e:	2b00      	cmp	r3, #0
 8013e20:	d101      	bne.n	8013e26 <LSM303AGR_ACC_W_Int2EnXHi+0x26>
    return MEMS_ERROR;
 8013e22:	2300      	movs	r3, #0
 8013e24:	e01c      	b.n	8013e60 <LSM303AGR_ACC_W_Int2EnXHi+0x60>

  value &= ~LSM303AGR_ACC_XHIE_MASK;
 8013e26:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013e2a:	f023 0302 	bic.w	r3, r3, #2
 8013e2e:	b2db      	uxtb	r3, r3
 8013e30:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013e34:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013e38:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013e3c:	4313      	orrs	r3, r2
 8013e3e:	b2db      	uxtb	r3, r3
 8013e40:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8013e44:	f10d 030f 	add.w	r3, sp, #15
 8013e48:	9801      	ldr	r0, [sp, #4]
 8013e4a:	2134      	movs	r1, #52	; 0x34
 8013e4c:	461a      	mov	r2, r3
 8013e4e:	2301      	movs	r3, #1
 8013e50:	f7fd fa26 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8013e54:	4603      	mov	r3, r0
 8013e56:	2b00      	cmp	r3, #0
 8013e58:	d101      	bne.n	8013e5e <LSM303AGR_ACC_W_Int2EnXHi+0x5e>
    return MEMS_ERROR;
 8013e5a:	2300      	movs	r3, #0
 8013e5c:	e000      	b.n	8013e60 <LSM303AGR_ACC_W_Int2EnXHi+0x60>

  return MEMS_SUCCESS;
 8013e5e:	2301      	movs	r3, #1
}
 8013e60:	4618      	mov	r0, r3
 8013e62:	b005      	add	sp, #20
 8013e64:	f85d fb04 	ldr.w	pc, [sp], #4
 8013e68:	f3af 8000 	nop.w
 8013e6c:	f3af 8000 	nop.w

08013e70 <LSM303AGR_ACC_R_Int2EnXHi>:
* Input          : Pointer to LSM303AGR_ACC_XHIE_t
* Output         : Status of XHIE see LSM303AGR_ACC_XHIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2EnXHi(void *handle, LSM303AGR_ACC_XHIE_t *value)
{
 8013e70:	b500      	push	{lr}
 8013e72:	b083      	sub	sp, #12
 8013e74:	9001      	str	r0, [sp, #4]
 8013e76:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8013e78:	9801      	ldr	r0, [sp, #4]
 8013e7a:	2134      	movs	r1, #52	; 0x34
 8013e7c:	9a00      	ldr	r2, [sp, #0]
 8013e7e:	2301      	movs	r3, #1
 8013e80:	f7fd fa36 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013e84:	4603      	mov	r3, r0
 8013e86:	2b00      	cmp	r3, #0
 8013e88:	d101      	bne.n	8013e8e <LSM303AGR_ACC_R_Int2EnXHi+0x1e>
    return MEMS_ERROR;
 8013e8a:	2300      	movs	r3, #0
 8013e8c:	e007      	b.n	8013e9e <LSM303AGR_ACC_R_Int2EnXHi+0x2e>

  *value &= LSM303AGR_ACC_XHIE_MASK; //mask
 8013e8e:	9b00      	ldr	r3, [sp, #0]
 8013e90:	781b      	ldrb	r3, [r3, #0]
 8013e92:	f003 0302 	and.w	r3, r3, #2
 8013e96:	b2da      	uxtb	r2, r3
 8013e98:	9b00      	ldr	r3, [sp, #0]
 8013e9a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013e9c:	2301      	movs	r3, #1
}
 8013e9e:	4618      	mov	r0, r3
 8013ea0:	b003      	add	sp, #12
 8013ea2:	f85d fb04 	ldr.w	pc, [sp], #4
 8013ea6:	bf00      	nop
 8013ea8:	f3af 8000 	nop.w
 8013eac:	f3af 8000 	nop.w

08013eb0 <LSM303AGR_ACC_W_Int2EnYLo>:
* Input          : LSM303AGR_ACC_YLIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2EnYLo(void *handle, LSM303AGR_ACC_YLIE_t newValue)
{
 8013eb0:	b500      	push	{lr}
 8013eb2:	b085      	sub	sp, #20
 8013eb4:	9001      	str	r0, [sp, #4]
 8013eb6:	460b      	mov	r3, r1
 8013eb8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8013ebc:	f10d 030f 	add.w	r3, sp, #15
 8013ec0:	9801      	ldr	r0, [sp, #4]
 8013ec2:	2134      	movs	r1, #52	; 0x34
 8013ec4:	461a      	mov	r2, r3
 8013ec6:	2301      	movs	r3, #1
 8013ec8:	f7fd fa12 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013ecc:	4603      	mov	r3, r0
 8013ece:	2b00      	cmp	r3, #0
 8013ed0:	d101      	bne.n	8013ed6 <LSM303AGR_ACC_W_Int2EnYLo+0x26>
    return MEMS_ERROR;
 8013ed2:	2300      	movs	r3, #0
 8013ed4:	e01c      	b.n	8013f10 <LSM303AGR_ACC_W_Int2EnYLo+0x60>

  value &= ~LSM303AGR_ACC_YLIE_MASK;
 8013ed6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013eda:	f023 0304 	bic.w	r3, r3, #4
 8013ede:	b2db      	uxtb	r3, r3
 8013ee0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013ee4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013ee8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013eec:	4313      	orrs	r3, r2
 8013eee:	b2db      	uxtb	r3, r3
 8013ef0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8013ef4:	f10d 030f 	add.w	r3, sp, #15
 8013ef8:	9801      	ldr	r0, [sp, #4]
 8013efa:	2134      	movs	r1, #52	; 0x34
 8013efc:	461a      	mov	r2, r3
 8013efe:	2301      	movs	r3, #1
 8013f00:	f7fd f9ce 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8013f04:	4603      	mov	r3, r0
 8013f06:	2b00      	cmp	r3, #0
 8013f08:	d101      	bne.n	8013f0e <LSM303AGR_ACC_W_Int2EnYLo+0x5e>
    return MEMS_ERROR;
 8013f0a:	2300      	movs	r3, #0
 8013f0c:	e000      	b.n	8013f10 <LSM303AGR_ACC_W_Int2EnYLo+0x60>

  return MEMS_SUCCESS;
 8013f0e:	2301      	movs	r3, #1
}
 8013f10:	4618      	mov	r0, r3
 8013f12:	b005      	add	sp, #20
 8013f14:	f85d fb04 	ldr.w	pc, [sp], #4
 8013f18:	f3af 8000 	nop.w
 8013f1c:	f3af 8000 	nop.w

08013f20 <LSM303AGR_ACC_R_Int2EnYLo>:
* Input          : Pointer to LSM303AGR_ACC_YLIE_t
* Output         : Status of YLIE see LSM303AGR_ACC_YLIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2EnYLo(void *handle, LSM303AGR_ACC_YLIE_t *value)
{
 8013f20:	b500      	push	{lr}
 8013f22:	b083      	sub	sp, #12
 8013f24:	9001      	str	r0, [sp, #4]
 8013f26:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8013f28:	9801      	ldr	r0, [sp, #4]
 8013f2a:	2134      	movs	r1, #52	; 0x34
 8013f2c:	9a00      	ldr	r2, [sp, #0]
 8013f2e:	2301      	movs	r3, #1
 8013f30:	f7fd f9de 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013f34:	4603      	mov	r3, r0
 8013f36:	2b00      	cmp	r3, #0
 8013f38:	d101      	bne.n	8013f3e <LSM303AGR_ACC_R_Int2EnYLo+0x1e>
    return MEMS_ERROR;
 8013f3a:	2300      	movs	r3, #0
 8013f3c:	e007      	b.n	8013f4e <LSM303AGR_ACC_R_Int2EnYLo+0x2e>

  *value &= LSM303AGR_ACC_YLIE_MASK; //mask
 8013f3e:	9b00      	ldr	r3, [sp, #0]
 8013f40:	781b      	ldrb	r3, [r3, #0]
 8013f42:	f003 0304 	and.w	r3, r3, #4
 8013f46:	b2da      	uxtb	r2, r3
 8013f48:	9b00      	ldr	r3, [sp, #0]
 8013f4a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013f4c:	2301      	movs	r3, #1
}
 8013f4e:	4618      	mov	r0, r3
 8013f50:	b003      	add	sp, #12
 8013f52:	f85d fb04 	ldr.w	pc, [sp], #4
 8013f56:	bf00      	nop
 8013f58:	f3af 8000 	nop.w
 8013f5c:	f3af 8000 	nop.w

08013f60 <LSM303AGR_ACC_W_Int2EnYHi>:
* Input          : LSM303AGR_ACC_YHIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2EnYHi(void *handle, LSM303AGR_ACC_YHIE_t newValue)
{
 8013f60:	b500      	push	{lr}
 8013f62:	b085      	sub	sp, #20
 8013f64:	9001      	str	r0, [sp, #4]
 8013f66:	460b      	mov	r3, r1
 8013f68:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8013f6c:	f10d 030f 	add.w	r3, sp, #15
 8013f70:	9801      	ldr	r0, [sp, #4]
 8013f72:	2134      	movs	r1, #52	; 0x34
 8013f74:	461a      	mov	r2, r3
 8013f76:	2301      	movs	r3, #1
 8013f78:	f7fd f9ba 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013f7c:	4603      	mov	r3, r0
 8013f7e:	2b00      	cmp	r3, #0
 8013f80:	d101      	bne.n	8013f86 <LSM303AGR_ACC_W_Int2EnYHi+0x26>
    return MEMS_ERROR;
 8013f82:	2300      	movs	r3, #0
 8013f84:	e01c      	b.n	8013fc0 <LSM303AGR_ACC_W_Int2EnYHi+0x60>

  value &= ~LSM303AGR_ACC_YHIE_MASK;
 8013f86:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013f8a:	f023 0308 	bic.w	r3, r3, #8
 8013f8e:	b2db      	uxtb	r3, r3
 8013f90:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013f94:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013f98:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013f9c:	4313      	orrs	r3, r2
 8013f9e:	b2db      	uxtb	r3, r3
 8013fa0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8013fa4:	f10d 030f 	add.w	r3, sp, #15
 8013fa8:	9801      	ldr	r0, [sp, #4]
 8013faa:	2134      	movs	r1, #52	; 0x34
 8013fac:	461a      	mov	r2, r3
 8013fae:	2301      	movs	r3, #1
 8013fb0:	f7fd f976 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8013fb4:	4603      	mov	r3, r0
 8013fb6:	2b00      	cmp	r3, #0
 8013fb8:	d101      	bne.n	8013fbe <LSM303AGR_ACC_W_Int2EnYHi+0x5e>
    return MEMS_ERROR;
 8013fba:	2300      	movs	r3, #0
 8013fbc:	e000      	b.n	8013fc0 <LSM303AGR_ACC_W_Int2EnYHi+0x60>

  return MEMS_SUCCESS;
 8013fbe:	2301      	movs	r3, #1
}
 8013fc0:	4618      	mov	r0, r3
 8013fc2:	b005      	add	sp, #20
 8013fc4:	f85d fb04 	ldr.w	pc, [sp], #4
 8013fc8:	f3af 8000 	nop.w
 8013fcc:	f3af 8000 	nop.w

08013fd0 <LSM303AGR_ACC_R_Int2EnYHi>:
* Input          : Pointer to LSM303AGR_ACC_YHIE_t
* Output         : Status of YHIE see LSM303AGR_ACC_YHIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2EnYHi(void *handle, LSM303AGR_ACC_YHIE_t *value)
{
 8013fd0:	b500      	push	{lr}
 8013fd2:	b083      	sub	sp, #12
 8013fd4:	9001      	str	r0, [sp, #4]
 8013fd6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8013fd8:	9801      	ldr	r0, [sp, #4]
 8013fda:	2134      	movs	r1, #52	; 0x34
 8013fdc:	9a00      	ldr	r2, [sp, #0]
 8013fde:	2301      	movs	r3, #1
 8013fe0:	f7fd f986 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8013fe4:	4603      	mov	r3, r0
 8013fe6:	2b00      	cmp	r3, #0
 8013fe8:	d101      	bne.n	8013fee <LSM303AGR_ACC_R_Int2EnYHi+0x1e>
    return MEMS_ERROR;
 8013fea:	2300      	movs	r3, #0
 8013fec:	e007      	b.n	8013ffe <LSM303AGR_ACC_R_Int2EnYHi+0x2e>

  *value &= LSM303AGR_ACC_YHIE_MASK; //mask
 8013fee:	9b00      	ldr	r3, [sp, #0]
 8013ff0:	781b      	ldrb	r3, [r3, #0]
 8013ff2:	f003 0308 	and.w	r3, r3, #8
 8013ff6:	b2da      	uxtb	r2, r3
 8013ff8:	9b00      	ldr	r3, [sp, #0]
 8013ffa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013ffc:	2301      	movs	r3, #1
}
 8013ffe:	4618      	mov	r0, r3
 8014000:	b003      	add	sp, #12
 8014002:	f85d fb04 	ldr.w	pc, [sp], #4
 8014006:	bf00      	nop
 8014008:	f3af 8000 	nop.w
 801400c:	f3af 8000 	nop.w

08014010 <LSM303AGR_ACC_W_Int2EnZLo>:
* Input          : LSM303AGR_ACC_ZLIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2EnZLo(void *handle, LSM303AGR_ACC_ZLIE_t newValue)
{
 8014010:	b500      	push	{lr}
 8014012:	b085      	sub	sp, #20
 8014014:	9001      	str	r0, [sp, #4]
 8014016:	460b      	mov	r3, r1
 8014018:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 801401c:	f10d 030f 	add.w	r3, sp, #15
 8014020:	9801      	ldr	r0, [sp, #4]
 8014022:	2134      	movs	r1, #52	; 0x34
 8014024:	461a      	mov	r2, r3
 8014026:	2301      	movs	r3, #1
 8014028:	f7fd f962 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 801402c:	4603      	mov	r3, r0
 801402e:	2b00      	cmp	r3, #0
 8014030:	d101      	bne.n	8014036 <LSM303AGR_ACC_W_Int2EnZLo+0x26>
    return MEMS_ERROR;
 8014032:	2300      	movs	r3, #0
 8014034:	e01c      	b.n	8014070 <LSM303AGR_ACC_W_Int2EnZLo+0x60>

  value &= ~LSM303AGR_ACC_ZLIE_MASK;
 8014036:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801403a:	f023 0310 	bic.w	r3, r3, #16
 801403e:	b2db      	uxtb	r3, r3
 8014040:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014044:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014048:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801404c:	4313      	orrs	r3, r2
 801404e:	b2db      	uxtb	r3, r3
 8014050:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8014054:	f10d 030f 	add.w	r3, sp, #15
 8014058:	9801      	ldr	r0, [sp, #4]
 801405a:	2134      	movs	r1, #52	; 0x34
 801405c:	461a      	mov	r2, r3
 801405e:	2301      	movs	r3, #1
 8014060:	f7fd f91e 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8014064:	4603      	mov	r3, r0
 8014066:	2b00      	cmp	r3, #0
 8014068:	d101      	bne.n	801406e <LSM303AGR_ACC_W_Int2EnZLo+0x5e>
    return MEMS_ERROR;
 801406a:	2300      	movs	r3, #0
 801406c:	e000      	b.n	8014070 <LSM303AGR_ACC_W_Int2EnZLo+0x60>

  return MEMS_SUCCESS;
 801406e:	2301      	movs	r3, #1
}
 8014070:	4618      	mov	r0, r3
 8014072:	b005      	add	sp, #20
 8014074:	f85d fb04 	ldr.w	pc, [sp], #4
 8014078:	f3af 8000 	nop.w
 801407c:	f3af 8000 	nop.w

08014080 <LSM303AGR_ACC_R_Int2EnZLo>:
* Input          : Pointer to LSM303AGR_ACC_ZLIE_t
* Output         : Status of ZLIE see LSM303AGR_ACC_ZLIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2EnZLo(void *handle, LSM303AGR_ACC_ZLIE_t *value)
{
 8014080:	b500      	push	{lr}
 8014082:	b083      	sub	sp, #12
 8014084:	9001      	str	r0, [sp, #4]
 8014086:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8014088:	9801      	ldr	r0, [sp, #4]
 801408a:	2134      	movs	r1, #52	; 0x34
 801408c:	9a00      	ldr	r2, [sp, #0]
 801408e:	2301      	movs	r3, #1
 8014090:	f7fd f92e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014094:	4603      	mov	r3, r0
 8014096:	2b00      	cmp	r3, #0
 8014098:	d101      	bne.n	801409e <LSM303AGR_ACC_R_Int2EnZLo+0x1e>
    return MEMS_ERROR;
 801409a:	2300      	movs	r3, #0
 801409c:	e007      	b.n	80140ae <LSM303AGR_ACC_R_Int2EnZLo+0x2e>

  *value &= LSM303AGR_ACC_ZLIE_MASK; //mask
 801409e:	9b00      	ldr	r3, [sp, #0]
 80140a0:	781b      	ldrb	r3, [r3, #0]
 80140a2:	f003 0310 	and.w	r3, r3, #16
 80140a6:	b2da      	uxtb	r2, r3
 80140a8:	9b00      	ldr	r3, [sp, #0]
 80140aa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80140ac:	2301      	movs	r3, #1
}
 80140ae:	4618      	mov	r0, r3
 80140b0:	b003      	add	sp, #12
 80140b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80140b6:	bf00      	nop
 80140b8:	f3af 8000 	nop.w
 80140bc:	f3af 8000 	nop.w

080140c0 <LSM303AGR_ACC_W_Int2EnZHi>:
* Input          : LSM303AGR_ACC_ZHIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2EnZHi(void *handle, LSM303AGR_ACC_ZHIE_t newValue)
{
 80140c0:	b500      	push	{lr}
 80140c2:	b085      	sub	sp, #20
 80140c4:	9001      	str	r0, [sp, #4]
 80140c6:	460b      	mov	r3, r1
 80140c8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 80140cc:	f10d 030f 	add.w	r3, sp, #15
 80140d0:	9801      	ldr	r0, [sp, #4]
 80140d2:	2134      	movs	r1, #52	; 0x34
 80140d4:	461a      	mov	r2, r3
 80140d6:	2301      	movs	r3, #1
 80140d8:	f7fd f90a 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80140dc:	4603      	mov	r3, r0
 80140de:	2b00      	cmp	r3, #0
 80140e0:	d101      	bne.n	80140e6 <LSM303AGR_ACC_W_Int2EnZHi+0x26>
    return MEMS_ERROR;
 80140e2:	2300      	movs	r3, #0
 80140e4:	e01c      	b.n	8014120 <LSM303AGR_ACC_W_Int2EnZHi+0x60>

  value &= ~LSM303AGR_ACC_ZHIE_MASK;
 80140e6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80140ea:	f023 0320 	bic.w	r3, r3, #32
 80140ee:	b2db      	uxtb	r3, r3
 80140f0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80140f4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80140f8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80140fc:	4313      	orrs	r3, r2
 80140fe:	b2db      	uxtb	r3, r3
 8014100:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8014104:	f10d 030f 	add.w	r3, sp, #15
 8014108:	9801      	ldr	r0, [sp, #4]
 801410a:	2134      	movs	r1, #52	; 0x34
 801410c:	461a      	mov	r2, r3
 801410e:	2301      	movs	r3, #1
 8014110:	f7fd f8c6 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8014114:	4603      	mov	r3, r0
 8014116:	2b00      	cmp	r3, #0
 8014118:	d101      	bne.n	801411e <LSM303AGR_ACC_W_Int2EnZHi+0x5e>
    return MEMS_ERROR;
 801411a:	2300      	movs	r3, #0
 801411c:	e000      	b.n	8014120 <LSM303AGR_ACC_W_Int2EnZHi+0x60>

  return MEMS_SUCCESS;
 801411e:	2301      	movs	r3, #1
}
 8014120:	4618      	mov	r0, r3
 8014122:	b005      	add	sp, #20
 8014124:	f85d fb04 	ldr.w	pc, [sp], #4
 8014128:	f3af 8000 	nop.w
 801412c:	f3af 8000 	nop.w

08014130 <LSM303AGR_ACC_R_Int2EnZHi>:
* Input          : Pointer to LSM303AGR_ACC_ZHIE_t
* Output         : Status of ZHIE see LSM303AGR_ACC_ZHIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2EnZHi(void *handle, LSM303AGR_ACC_ZHIE_t *value)
{
 8014130:	b500      	push	{lr}
 8014132:	b083      	sub	sp, #12
 8014134:	9001      	str	r0, [sp, #4]
 8014136:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8014138:	9801      	ldr	r0, [sp, #4]
 801413a:	2134      	movs	r1, #52	; 0x34
 801413c:	9a00      	ldr	r2, [sp, #0]
 801413e:	2301      	movs	r3, #1
 8014140:	f7fd f8d6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014144:	4603      	mov	r3, r0
 8014146:	2b00      	cmp	r3, #0
 8014148:	d101      	bne.n	801414e <LSM303AGR_ACC_R_Int2EnZHi+0x1e>
    return MEMS_ERROR;
 801414a:	2300      	movs	r3, #0
 801414c:	e007      	b.n	801415e <LSM303AGR_ACC_R_Int2EnZHi+0x2e>

  *value &= LSM303AGR_ACC_ZHIE_MASK; //mask
 801414e:	9b00      	ldr	r3, [sp, #0]
 8014150:	781b      	ldrb	r3, [r3, #0]
 8014152:	f003 0320 	and.w	r3, r3, #32
 8014156:	b2da      	uxtb	r2, r3
 8014158:	9b00      	ldr	r3, [sp, #0]
 801415a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801415c:	2301      	movs	r3, #1
}
 801415e:	4618      	mov	r0, r3
 8014160:	b003      	add	sp, #12
 8014162:	f85d fb04 	ldr.w	pc, [sp], #4
 8014166:	bf00      	nop
 8014168:	f3af 8000 	nop.w
 801416c:	f3af 8000 	nop.w

08014170 <LSM303AGR_ACC_W_Int2_6D>:
* Input          : LSM303AGR_ACC_6D_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2_6D(void *handle, LSM303AGR_ACC_6D_t newValue)
{
 8014170:	b500      	push	{lr}
 8014172:	b085      	sub	sp, #20
 8014174:	9001      	str	r0, [sp, #4]
 8014176:	460b      	mov	r3, r1
 8014178:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 801417c:	f10d 030f 	add.w	r3, sp, #15
 8014180:	9801      	ldr	r0, [sp, #4]
 8014182:	2134      	movs	r1, #52	; 0x34
 8014184:	461a      	mov	r2, r3
 8014186:	2301      	movs	r3, #1
 8014188:	f7fd f8b2 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 801418c:	4603      	mov	r3, r0
 801418e:	2b00      	cmp	r3, #0
 8014190:	d101      	bne.n	8014196 <LSM303AGR_ACC_W_Int2_6D+0x26>
    return MEMS_ERROR;
 8014192:	2300      	movs	r3, #0
 8014194:	e01c      	b.n	80141d0 <LSM303AGR_ACC_W_Int2_6D+0x60>

  value &= ~LSM303AGR_ACC_6D_MASK;
 8014196:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801419a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 801419e:	b2db      	uxtb	r3, r3
 80141a0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80141a4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80141a8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80141ac:	4313      	orrs	r3, r2
 80141ae:	b2db      	uxtb	r3, r3
 80141b0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 80141b4:	f10d 030f 	add.w	r3, sp, #15
 80141b8:	9801      	ldr	r0, [sp, #4]
 80141ba:	2134      	movs	r1, #52	; 0x34
 80141bc:	461a      	mov	r2, r3
 80141be:	2301      	movs	r3, #1
 80141c0:	f7fd f86e 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 80141c4:	4603      	mov	r3, r0
 80141c6:	2b00      	cmp	r3, #0
 80141c8:	d101      	bne.n	80141ce <LSM303AGR_ACC_W_Int2_6D+0x5e>
    return MEMS_ERROR;
 80141ca:	2300      	movs	r3, #0
 80141cc:	e000      	b.n	80141d0 <LSM303AGR_ACC_W_Int2_6D+0x60>

  return MEMS_SUCCESS;
 80141ce:	2301      	movs	r3, #1
}
 80141d0:	4618      	mov	r0, r3
 80141d2:	b005      	add	sp, #20
 80141d4:	f85d fb04 	ldr.w	pc, [sp], #4
 80141d8:	f3af 8000 	nop.w
 80141dc:	f3af 8000 	nop.w

080141e0 <LSM303AGR_ACC_R_Int2_6D>:
* Input          : Pointer to LSM303AGR_ACC_6D_t
* Output         : Status of 6D see LSM303AGR_ACC_6D_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_6D(void *handle, LSM303AGR_ACC_6D_t *value)
{
 80141e0:	b500      	push	{lr}
 80141e2:	b083      	sub	sp, #12
 80141e4:	9001      	str	r0, [sp, #4]
 80141e6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 80141e8:	9801      	ldr	r0, [sp, #4]
 80141ea:	2134      	movs	r1, #52	; 0x34
 80141ec:	9a00      	ldr	r2, [sp, #0]
 80141ee:	2301      	movs	r3, #1
 80141f0:	f7fd f87e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80141f4:	4603      	mov	r3, r0
 80141f6:	2b00      	cmp	r3, #0
 80141f8:	d101      	bne.n	80141fe <LSM303AGR_ACC_R_Int2_6D+0x1e>
    return MEMS_ERROR;
 80141fa:	2300      	movs	r3, #0
 80141fc:	e007      	b.n	801420e <LSM303AGR_ACC_R_Int2_6D+0x2e>

  *value &= LSM303AGR_ACC_6D_MASK; //mask
 80141fe:	9b00      	ldr	r3, [sp, #0]
 8014200:	781b      	ldrb	r3, [r3, #0]
 8014202:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8014206:	b2da      	uxtb	r2, r3
 8014208:	9b00      	ldr	r3, [sp, #0]
 801420a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801420c:	2301      	movs	r3, #1
}
 801420e:	4618      	mov	r0, r3
 8014210:	b003      	add	sp, #12
 8014212:	f85d fb04 	ldr.w	pc, [sp], #4
 8014216:	bf00      	nop
 8014218:	f3af 8000 	nop.w
 801421c:	f3af 8000 	nop.w

08014220 <LSM303AGR_ACC_W_Int2_AOI>:
* Input          : LSM303AGR_ACC_AOI_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2_AOI(void *handle, LSM303AGR_ACC_AOI_t newValue)
{
 8014220:	b500      	push	{lr}
 8014222:	b085      	sub	sp, #20
 8014224:	9001      	str	r0, [sp, #4]
 8014226:	460b      	mov	r3, r1
 8014228:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 801422c:	f10d 030f 	add.w	r3, sp, #15
 8014230:	9801      	ldr	r0, [sp, #4]
 8014232:	2134      	movs	r1, #52	; 0x34
 8014234:	461a      	mov	r2, r3
 8014236:	2301      	movs	r3, #1
 8014238:	f7fd f85a 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 801423c:	4603      	mov	r3, r0
 801423e:	2b00      	cmp	r3, #0
 8014240:	d101      	bne.n	8014246 <LSM303AGR_ACC_W_Int2_AOI+0x26>
    return MEMS_ERROR;
 8014242:	2300      	movs	r3, #0
 8014244:	e01c      	b.n	8014280 <LSM303AGR_ACC_W_Int2_AOI+0x60>

  value &= ~LSM303AGR_ACC_AOI_MASK;
 8014246:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801424a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 801424e:	b2db      	uxtb	r3, r3
 8014250:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014254:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014258:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801425c:	4313      	orrs	r3, r2
 801425e:	b2db      	uxtb	r3, r3
 8014260:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8014264:	f10d 030f 	add.w	r3, sp, #15
 8014268:	9801      	ldr	r0, [sp, #4]
 801426a:	2134      	movs	r1, #52	; 0x34
 801426c:	461a      	mov	r2, r3
 801426e:	2301      	movs	r3, #1
 8014270:	f7fd f816 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8014274:	4603      	mov	r3, r0
 8014276:	2b00      	cmp	r3, #0
 8014278:	d101      	bne.n	801427e <LSM303AGR_ACC_W_Int2_AOI+0x5e>
    return MEMS_ERROR;
 801427a:	2300      	movs	r3, #0
 801427c:	e000      	b.n	8014280 <LSM303AGR_ACC_W_Int2_AOI+0x60>

  return MEMS_SUCCESS;
 801427e:	2301      	movs	r3, #1
}
 8014280:	4618      	mov	r0, r3
 8014282:	b005      	add	sp, #20
 8014284:	f85d fb04 	ldr.w	pc, [sp], #4
 8014288:	f3af 8000 	nop.w
 801428c:	f3af 8000 	nop.w

08014290 <LSM303AGR_ACC_R_Int2_AOI>:
* Input          : Pointer to LSM303AGR_ACC_AOI_t
* Output         : Status of AOI see LSM303AGR_ACC_AOI_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_AOI(void *handle, LSM303AGR_ACC_AOI_t *value)
{
 8014290:	b500      	push	{lr}
 8014292:	b083      	sub	sp, #12
 8014294:	9001      	str	r0, [sp, #4]
 8014296:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8014298:	9801      	ldr	r0, [sp, #4]
 801429a:	2134      	movs	r1, #52	; 0x34
 801429c:	9a00      	ldr	r2, [sp, #0]
 801429e:	2301      	movs	r3, #1
 80142a0:	f7fd f826 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80142a4:	4603      	mov	r3, r0
 80142a6:	2b00      	cmp	r3, #0
 80142a8:	d101      	bne.n	80142ae <LSM303AGR_ACC_R_Int2_AOI+0x1e>
    return MEMS_ERROR;
 80142aa:	2300      	movs	r3, #0
 80142ac:	e007      	b.n	80142be <LSM303AGR_ACC_R_Int2_AOI+0x2e>

  *value &= LSM303AGR_ACC_AOI_MASK; //mask
 80142ae:	9b00      	ldr	r3, [sp, #0]
 80142b0:	781b      	ldrb	r3, [r3, #0]
 80142b2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80142b6:	b2da      	uxtb	r2, r3
 80142b8:	9b00      	ldr	r3, [sp, #0]
 80142ba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80142bc:	2301      	movs	r3, #1
}
 80142be:	4618      	mov	r0, r3
 80142c0:	b003      	add	sp, #12
 80142c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80142c6:	bf00      	nop
 80142c8:	f3af 8000 	nop.w
 80142cc:	f3af 8000 	nop.w

080142d0 <LSM303AGR_ACC_R_Int1_Xlo>:
* Input          : Pointer to LSM303AGR_ACC_XL_t
* Output         : Status of XL see LSM303AGR_ACC_XL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_Xlo(void *handle, LSM303AGR_ACC_XL_t *value)
{
 80142d0:	b500      	push	{lr}
 80142d2:	b083      	sub	sp, #12
 80142d4:	9001      	str	r0, [sp, #4]
 80142d6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 80142d8:	9801      	ldr	r0, [sp, #4]
 80142da:	2131      	movs	r1, #49	; 0x31
 80142dc:	9a00      	ldr	r2, [sp, #0]
 80142de:	2301      	movs	r3, #1
 80142e0:	f7fd f806 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80142e4:	4603      	mov	r3, r0
 80142e6:	2b00      	cmp	r3, #0
 80142e8:	d101      	bne.n	80142ee <LSM303AGR_ACC_R_Int1_Xlo+0x1e>
    return MEMS_ERROR;
 80142ea:	2300      	movs	r3, #0
 80142ec:	e007      	b.n	80142fe <LSM303AGR_ACC_R_Int1_Xlo+0x2e>

  *value &= LSM303AGR_ACC_XL_MASK; //mask
 80142ee:	9b00      	ldr	r3, [sp, #0]
 80142f0:	781b      	ldrb	r3, [r3, #0]
 80142f2:	f003 0301 	and.w	r3, r3, #1
 80142f6:	b2da      	uxtb	r2, r3
 80142f8:	9b00      	ldr	r3, [sp, #0]
 80142fa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80142fc:	2301      	movs	r3, #1
}
 80142fe:	4618      	mov	r0, r3
 8014300:	b003      	add	sp, #12
 8014302:	f85d fb04 	ldr.w	pc, [sp], #4
 8014306:	bf00      	nop
 8014308:	f3af 8000 	nop.w
 801430c:	f3af 8000 	nop.w

08014310 <LSM303AGR_ACC_R_Int1_XHi>:
* Input          : Pointer to LSM303AGR_ACC_XH_t
* Output         : Status of XH see LSM303AGR_ACC_XH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_XHi(void *handle, LSM303AGR_ACC_XH_t *value)
{
 8014310:	b500      	push	{lr}
 8014312:	b083      	sub	sp, #12
 8014314:	9001      	str	r0, [sp, #4]
 8014316:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 8014318:	9801      	ldr	r0, [sp, #4]
 801431a:	2131      	movs	r1, #49	; 0x31
 801431c:	9a00      	ldr	r2, [sp, #0]
 801431e:	2301      	movs	r3, #1
 8014320:	f7fc ffe6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014324:	4603      	mov	r3, r0
 8014326:	2b00      	cmp	r3, #0
 8014328:	d101      	bne.n	801432e <LSM303AGR_ACC_R_Int1_XHi+0x1e>
    return MEMS_ERROR;
 801432a:	2300      	movs	r3, #0
 801432c:	e007      	b.n	801433e <LSM303AGR_ACC_R_Int1_XHi+0x2e>

  *value &= LSM303AGR_ACC_XH_MASK; //mask
 801432e:	9b00      	ldr	r3, [sp, #0]
 8014330:	781b      	ldrb	r3, [r3, #0]
 8014332:	f003 0302 	and.w	r3, r3, #2
 8014336:	b2da      	uxtb	r2, r3
 8014338:	9b00      	ldr	r3, [sp, #0]
 801433a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801433c:	2301      	movs	r3, #1
}
 801433e:	4618      	mov	r0, r3
 8014340:	b003      	add	sp, #12
 8014342:	f85d fb04 	ldr.w	pc, [sp], #4
 8014346:	bf00      	nop
 8014348:	f3af 8000 	nop.w
 801434c:	f3af 8000 	nop.w

08014350 <LSM303AGR_ACC_R_Int1_YLo>:
* Input          : Pointer to LSM303AGR_ACC_YL_t
* Output         : Status of YL see LSM303AGR_ACC_YL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_YLo(void *handle, LSM303AGR_ACC_YL_t *value)
{
 8014350:	b500      	push	{lr}
 8014352:	b083      	sub	sp, #12
 8014354:	9001      	str	r0, [sp, #4]
 8014356:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 8014358:	9801      	ldr	r0, [sp, #4]
 801435a:	2131      	movs	r1, #49	; 0x31
 801435c:	9a00      	ldr	r2, [sp, #0]
 801435e:	2301      	movs	r3, #1
 8014360:	f7fc ffc6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014364:	4603      	mov	r3, r0
 8014366:	2b00      	cmp	r3, #0
 8014368:	d101      	bne.n	801436e <LSM303AGR_ACC_R_Int1_YLo+0x1e>
    return MEMS_ERROR;
 801436a:	2300      	movs	r3, #0
 801436c:	e007      	b.n	801437e <LSM303AGR_ACC_R_Int1_YLo+0x2e>

  *value &= LSM303AGR_ACC_YL_MASK; //mask
 801436e:	9b00      	ldr	r3, [sp, #0]
 8014370:	781b      	ldrb	r3, [r3, #0]
 8014372:	f003 0304 	and.w	r3, r3, #4
 8014376:	b2da      	uxtb	r2, r3
 8014378:	9b00      	ldr	r3, [sp, #0]
 801437a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801437c:	2301      	movs	r3, #1
}
 801437e:	4618      	mov	r0, r3
 8014380:	b003      	add	sp, #12
 8014382:	f85d fb04 	ldr.w	pc, [sp], #4
 8014386:	bf00      	nop
 8014388:	f3af 8000 	nop.w
 801438c:	f3af 8000 	nop.w

08014390 <LSM303AGR_ACC_R_Int1_YHi>:
* Input          : Pointer to LSM303AGR_ACC_YH_t
* Output         : Status of YH see LSM303AGR_ACC_YH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_YHi(void *handle, LSM303AGR_ACC_YH_t *value)
{
 8014390:	b500      	push	{lr}
 8014392:	b083      	sub	sp, #12
 8014394:	9001      	str	r0, [sp, #4]
 8014396:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 8014398:	9801      	ldr	r0, [sp, #4]
 801439a:	2131      	movs	r1, #49	; 0x31
 801439c:	9a00      	ldr	r2, [sp, #0]
 801439e:	2301      	movs	r3, #1
 80143a0:	f7fc ffa6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80143a4:	4603      	mov	r3, r0
 80143a6:	2b00      	cmp	r3, #0
 80143a8:	d101      	bne.n	80143ae <LSM303AGR_ACC_R_Int1_YHi+0x1e>
    return MEMS_ERROR;
 80143aa:	2300      	movs	r3, #0
 80143ac:	e007      	b.n	80143be <LSM303AGR_ACC_R_Int1_YHi+0x2e>

  *value &= LSM303AGR_ACC_YH_MASK; //mask
 80143ae:	9b00      	ldr	r3, [sp, #0]
 80143b0:	781b      	ldrb	r3, [r3, #0]
 80143b2:	f003 0308 	and.w	r3, r3, #8
 80143b6:	b2da      	uxtb	r2, r3
 80143b8:	9b00      	ldr	r3, [sp, #0]
 80143ba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80143bc:	2301      	movs	r3, #1
}
 80143be:	4618      	mov	r0, r3
 80143c0:	b003      	add	sp, #12
 80143c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80143c6:	bf00      	nop
 80143c8:	f3af 8000 	nop.w
 80143cc:	f3af 8000 	nop.w

080143d0 <LSM303AGR_ACC_R_Int1_Zlo>:
* Input          : Pointer to LSM303AGR_ACC_ZL_t
* Output         : Status of ZL see LSM303AGR_ACC_ZL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_Zlo(void *handle, LSM303AGR_ACC_ZL_t *value)
{
 80143d0:	b500      	push	{lr}
 80143d2:	b083      	sub	sp, #12
 80143d4:	9001      	str	r0, [sp, #4]
 80143d6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 80143d8:	9801      	ldr	r0, [sp, #4]
 80143da:	2131      	movs	r1, #49	; 0x31
 80143dc:	9a00      	ldr	r2, [sp, #0]
 80143de:	2301      	movs	r3, #1
 80143e0:	f7fc ff86 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80143e4:	4603      	mov	r3, r0
 80143e6:	2b00      	cmp	r3, #0
 80143e8:	d101      	bne.n	80143ee <LSM303AGR_ACC_R_Int1_Zlo+0x1e>
    return MEMS_ERROR;
 80143ea:	2300      	movs	r3, #0
 80143ec:	e007      	b.n	80143fe <LSM303AGR_ACC_R_Int1_Zlo+0x2e>

  *value &= LSM303AGR_ACC_ZL_MASK; //mask
 80143ee:	9b00      	ldr	r3, [sp, #0]
 80143f0:	781b      	ldrb	r3, [r3, #0]
 80143f2:	f003 0310 	and.w	r3, r3, #16
 80143f6:	b2da      	uxtb	r2, r3
 80143f8:	9b00      	ldr	r3, [sp, #0]
 80143fa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80143fc:	2301      	movs	r3, #1
}
 80143fe:	4618      	mov	r0, r3
 8014400:	b003      	add	sp, #12
 8014402:	f85d fb04 	ldr.w	pc, [sp], #4
 8014406:	bf00      	nop
 8014408:	f3af 8000 	nop.w
 801440c:	f3af 8000 	nop.w

08014410 <LSM303AGR_ACC_R_Int1_ZHi>:
* Input          : Pointer to LSM303AGR_ACC_ZH_t
* Output         : Status of ZH see LSM303AGR_ACC_ZH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_ZHi(void *handle, LSM303AGR_ACC_ZH_t *value)
{
 8014410:	b500      	push	{lr}
 8014412:	b083      	sub	sp, #12
 8014414:	9001      	str	r0, [sp, #4]
 8014416:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 8014418:	9801      	ldr	r0, [sp, #4]
 801441a:	2131      	movs	r1, #49	; 0x31
 801441c:	9a00      	ldr	r2, [sp, #0]
 801441e:	2301      	movs	r3, #1
 8014420:	f7fc ff66 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014424:	4603      	mov	r3, r0
 8014426:	2b00      	cmp	r3, #0
 8014428:	d101      	bne.n	801442e <LSM303AGR_ACC_R_Int1_ZHi+0x1e>
    return MEMS_ERROR;
 801442a:	2300      	movs	r3, #0
 801442c:	e007      	b.n	801443e <LSM303AGR_ACC_R_Int1_ZHi+0x2e>

  *value &= LSM303AGR_ACC_ZH_MASK; //mask
 801442e:	9b00      	ldr	r3, [sp, #0]
 8014430:	781b      	ldrb	r3, [r3, #0]
 8014432:	f003 0320 	and.w	r3, r3, #32
 8014436:	b2da      	uxtb	r2, r3
 8014438:	9b00      	ldr	r3, [sp, #0]
 801443a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801443c:	2301      	movs	r3, #1
}
 801443e:	4618      	mov	r0, r3
 8014440:	b003      	add	sp, #12
 8014442:	f85d fb04 	ldr.w	pc, [sp], #4
 8014446:	bf00      	nop
 8014448:	f3af 8000 	nop.w
 801444c:	f3af 8000 	nop.w

08014450 <LSM303AGR_ACC_R_Int1_IA>:
* Input          : Pointer to LSM303AGR_ACC_IA_t
* Output         : Status of IA see LSM303AGR_ACC_IA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_IA(void *handle, LSM303AGR_ACC_IA_t *value)
{
 8014450:	b500      	push	{lr}
 8014452:	b083      	sub	sp, #12
 8014454:	9001      	str	r0, [sp, #4]
 8014456:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 8014458:	9801      	ldr	r0, [sp, #4]
 801445a:	2131      	movs	r1, #49	; 0x31
 801445c:	9a00      	ldr	r2, [sp, #0]
 801445e:	2301      	movs	r3, #1
 8014460:	f7fc ff46 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014464:	4603      	mov	r3, r0
 8014466:	2b00      	cmp	r3, #0
 8014468:	d101      	bne.n	801446e <LSM303AGR_ACC_R_Int1_IA+0x1e>
    return MEMS_ERROR;
 801446a:	2300      	movs	r3, #0
 801446c:	e007      	b.n	801447e <LSM303AGR_ACC_R_Int1_IA+0x2e>

  *value &= LSM303AGR_ACC_IA_MASK; //mask
 801446e:	9b00      	ldr	r3, [sp, #0]
 8014470:	781b      	ldrb	r3, [r3, #0]
 8014472:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8014476:	b2da      	uxtb	r2, r3
 8014478:	9b00      	ldr	r3, [sp, #0]
 801447a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801447c:	2301      	movs	r3, #1
}
 801447e:	4618      	mov	r0, r3
 8014480:	b003      	add	sp, #12
 8014482:	f85d fb04 	ldr.w	pc, [sp], #4
 8014486:	bf00      	nop
 8014488:	f3af 8000 	nop.w
 801448c:	f3af 8000 	nop.w

08014490 <LSM303AGR_ACC_R_Int2_Xlo>:
* Input          : Pointer to LSM303AGR_ACC_XL_t
* Output         : Status of XL see LSM303AGR_ACC_XL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_Xlo(void *handle, LSM303AGR_ACC_XL_t *value)
{
 8014490:	b500      	push	{lr}
 8014492:	b083      	sub	sp, #12
 8014494:	9001      	str	r0, [sp, #4]
 8014496:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 8014498:	9801      	ldr	r0, [sp, #4]
 801449a:	2135      	movs	r1, #53	; 0x35
 801449c:	9a00      	ldr	r2, [sp, #0]
 801449e:	2301      	movs	r3, #1
 80144a0:	f7fc ff26 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80144a4:	4603      	mov	r3, r0
 80144a6:	2b00      	cmp	r3, #0
 80144a8:	d101      	bne.n	80144ae <LSM303AGR_ACC_R_Int2_Xlo+0x1e>
    return MEMS_ERROR;
 80144aa:	2300      	movs	r3, #0
 80144ac:	e007      	b.n	80144be <LSM303AGR_ACC_R_Int2_Xlo+0x2e>

  *value &= LSM303AGR_ACC_XL_MASK; //mask
 80144ae:	9b00      	ldr	r3, [sp, #0]
 80144b0:	781b      	ldrb	r3, [r3, #0]
 80144b2:	f003 0301 	and.w	r3, r3, #1
 80144b6:	b2da      	uxtb	r2, r3
 80144b8:	9b00      	ldr	r3, [sp, #0]
 80144ba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80144bc:	2301      	movs	r3, #1
}
 80144be:	4618      	mov	r0, r3
 80144c0:	b003      	add	sp, #12
 80144c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80144c6:	bf00      	nop
 80144c8:	f3af 8000 	nop.w
 80144cc:	f3af 8000 	nop.w

080144d0 <LSM303AGR_ACC_R_Int2_XHi>:
* Input          : Pointer to LSM303AGR_ACC_XH_t
* Output         : Status of XH see LSM303AGR_ACC_XH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_XHi(void *handle, LSM303AGR_ACC_XH_t *value)
{
 80144d0:	b500      	push	{lr}
 80144d2:	b083      	sub	sp, #12
 80144d4:	9001      	str	r0, [sp, #4]
 80144d6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 80144d8:	9801      	ldr	r0, [sp, #4]
 80144da:	2135      	movs	r1, #53	; 0x35
 80144dc:	9a00      	ldr	r2, [sp, #0]
 80144de:	2301      	movs	r3, #1
 80144e0:	f7fc ff06 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80144e4:	4603      	mov	r3, r0
 80144e6:	2b00      	cmp	r3, #0
 80144e8:	d101      	bne.n	80144ee <LSM303AGR_ACC_R_Int2_XHi+0x1e>
    return MEMS_ERROR;
 80144ea:	2300      	movs	r3, #0
 80144ec:	e007      	b.n	80144fe <LSM303AGR_ACC_R_Int2_XHi+0x2e>

  *value &= LSM303AGR_ACC_XH_MASK; //mask
 80144ee:	9b00      	ldr	r3, [sp, #0]
 80144f0:	781b      	ldrb	r3, [r3, #0]
 80144f2:	f003 0302 	and.w	r3, r3, #2
 80144f6:	b2da      	uxtb	r2, r3
 80144f8:	9b00      	ldr	r3, [sp, #0]
 80144fa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80144fc:	2301      	movs	r3, #1
}
 80144fe:	4618      	mov	r0, r3
 8014500:	b003      	add	sp, #12
 8014502:	f85d fb04 	ldr.w	pc, [sp], #4
 8014506:	bf00      	nop
 8014508:	f3af 8000 	nop.w
 801450c:	f3af 8000 	nop.w

08014510 <LSM303AGR_ACC_R_Int2_YLo>:
* Input          : Pointer to LSM303AGR_ACC_YL_t
* Output         : Status of YL see LSM303AGR_ACC_YL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_YLo(void *handle, LSM303AGR_ACC_YL_t *value)
{
 8014510:	b500      	push	{lr}
 8014512:	b083      	sub	sp, #12
 8014514:	9001      	str	r0, [sp, #4]
 8014516:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 8014518:	9801      	ldr	r0, [sp, #4]
 801451a:	2135      	movs	r1, #53	; 0x35
 801451c:	9a00      	ldr	r2, [sp, #0]
 801451e:	2301      	movs	r3, #1
 8014520:	f7fc fee6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014524:	4603      	mov	r3, r0
 8014526:	2b00      	cmp	r3, #0
 8014528:	d101      	bne.n	801452e <LSM303AGR_ACC_R_Int2_YLo+0x1e>
    return MEMS_ERROR;
 801452a:	2300      	movs	r3, #0
 801452c:	e007      	b.n	801453e <LSM303AGR_ACC_R_Int2_YLo+0x2e>

  *value &= LSM303AGR_ACC_YL_MASK; //mask
 801452e:	9b00      	ldr	r3, [sp, #0]
 8014530:	781b      	ldrb	r3, [r3, #0]
 8014532:	f003 0304 	and.w	r3, r3, #4
 8014536:	b2da      	uxtb	r2, r3
 8014538:	9b00      	ldr	r3, [sp, #0]
 801453a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801453c:	2301      	movs	r3, #1
}
 801453e:	4618      	mov	r0, r3
 8014540:	b003      	add	sp, #12
 8014542:	f85d fb04 	ldr.w	pc, [sp], #4
 8014546:	bf00      	nop
 8014548:	f3af 8000 	nop.w
 801454c:	f3af 8000 	nop.w

08014550 <LSM303AGR_ACC_R_Int2_YHi>:
* Input          : Pointer to LSM303AGR_ACC_YH_t
* Output         : Status of YH see LSM303AGR_ACC_YH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_YHi(void *handle, LSM303AGR_ACC_YH_t *value)
{
 8014550:	b500      	push	{lr}
 8014552:	b083      	sub	sp, #12
 8014554:	9001      	str	r0, [sp, #4]
 8014556:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 8014558:	9801      	ldr	r0, [sp, #4]
 801455a:	2135      	movs	r1, #53	; 0x35
 801455c:	9a00      	ldr	r2, [sp, #0]
 801455e:	2301      	movs	r3, #1
 8014560:	f7fc fec6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014564:	4603      	mov	r3, r0
 8014566:	2b00      	cmp	r3, #0
 8014568:	d101      	bne.n	801456e <LSM303AGR_ACC_R_Int2_YHi+0x1e>
    return MEMS_ERROR;
 801456a:	2300      	movs	r3, #0
 801456c:	e007      	b.n	801457e <LSM303AGR_ACC_R_Int2_YHi+0x2e>

  *value &= LSM303AGR_ACC_YH_MASK; //mask
 801456e:	9b00      	ldr	r3, [sp, #0]
 8014570:	781b      	ldrb	r3, [r3, #0]
 8014572:	f003 0308 	and.w	r3, r3, #8
 8014576:	b2da      	uxtb	r2, r3
 8014578:	9b00      	ldr	r3, [sp, #0]
 801457a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801457c:	2301      	movs	r3, #1
}
 801457e:	4618      	mov	r0, r3
 8014580:	b003      	add	sp, #12
 8014582:	f85d fb04 	ldr.w	pc, [sp], #4
 8014586:	bf00      	nop
 8014588:	f3af 8000 	nop.w
 801458c:	f3af 8000 	nop.w

08014590 <LSM303AGR_ACC_R_Int2_Zlo>:
* Input          : Pointer to LSM303AGR_ACC_ZL_t
* Output         : Status of ZL see LSM303AGR_ACC_ZL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_Zlo(void *handle, LSM303AGR_ACC_ZL_t *value)
{
 8014590:	b500      	push	{lr}
 8014592:	b083      	sub	sp, #12
 8014594:	9001      	str	r0, [sp, #4]
 8014596:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 8014598:	9801      	ldr	r0, [sp, #4]
 801459a:	2135      	movs	r1, #53	; 0x35
 801459c:	9a00      	ldr	r2, [sp, #0]
 801459e:	2301      	movs	r3, #1
 80145a0:	f7fc fea6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80145a4:	4603      	mov	r3, r0
 80145a6:	2b00      	cmp	r3, #0
 80145a8:	d101      	bne.n	80145ae <LSM303AGR_ACC_R_Int2_Zlo+0x1e>
    return MEMS_ERROR;
 80145aa:	2300      	movs	r3, #0
 80145ac:	e007      	b.n	80145be <LSM303AGR_ACC_R_Int2_Zlo+0x2e>

  *value &= LSM303AGR_ACC_ZL_MASK; //mask
 80145ae:	9b00      	ldr	r3, [sp, #0]
 80145b0:	781b      	ldrb	r3, [r3, #0]
 80145b2:	f003 0310 	and.w	r3, r3, #16
 80145b6:	b2da      	uxtb	r2, r3
 80145b8:	9b00      	ldr	r3, [sp, #0]
 80145ba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80145bc:	2301      	movs	r3, #1
}
 80145be:	4618      	mov	r0, r3
 80145c0:	b003      	add	sp, #12
 80145c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80145c6:	bf00      	nop
 80145c8:	f3af 8000 	nop.w
 80145cc:	f3af 8000 	nop.w

080145d0 <LSM303AGR_ACC_R_Int2_ZHi>:
* Input          : Pointer to LSM303AGR_ACC_ZH_t
* Output         : Status of ZH see LSM303AGR_ACC_ZH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_ZHi(void *handle, LSM303AGR_ACC_ZH_t *value)
{
 80145d0:	b500      	push	{lr}
 80145d2:	b083      	sub	sp, #12
 80145d4:	9001      	str	r0, [sp, #4]
 80145d6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 80145d8:	9801      	ldr	r0, [sp, #4]
 80145da:	2135      	movs	r1, #53	; 0x35
 80145dc:	9a00      	ldr	r2, [sp, #0]
 80145de:	2301      	movs	r3, #1
 80145e0:	f7fc fe86 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80145e4:	4603      	mov	r3, r0
 80145e6:	2b00      	cmp	r3, #0
 80145e8:	d101      	bne.n	80145ee <LSM303AGR_ACC_R_Int2_ZHi+0x1e>
    return MEMS_ERROR;
 80145ea:	2300      	movs	r3, #0
 80145ec:	e007      	b.n	80145fe <LSM303AGR_ACC_R_Int2_ZHi+0x2e>

  *value &= LSM303AGR_ACC_ZH_MASK; //mask
 80145ee:	9b00      	ldr	r3, [sp, #0]
 80145f0:	781b      	ldrb	r3, [r3, #0]
 80145f2:	f003 0320 	and.w	r3, r3, #32
 80145f6:	b2da      	uxtb	r2, r3
 80145f8:	9b00      	ldr	r3, [sp, #0]
 80145fa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80145fc:	2301      	movs	r3, #1
}
 80145fe:	4618      	mov	r0, r3
 8014600:	b003      	add	sp, #12
 8014602:	f85d fb04 	ldr.w	pc, [sp], #4
 8014606:	bf00      	nop
 8014608:	f3af 8000 	nop.w
 801460c:	f3af 8000 	nop.w

08014610 <LSM303AGR_ACC_R_Int2_IA>:
* Input          : Pointer to LSM303AGR_ACC_IA_t
* Output         : Status of IA see LSM303AGR_ACC_IA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_IA(void *handle, LSM303AGR_ACC_IA_t *value)
{
 8014610:	b500      	push	{lr}
 8014612:	b083      	sub	sp, #12
 8014614:	9001      	str	r0, [sp, #4]
 8014616:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 8014618:	9801      	ldr	r0, [sp, #4]
 801461a:	2135      	movs	r1, #53	; 0x35
 801461c:	9a00      	ldr	r2, [sp, #0]
 801461e:	2301      	movs	r3, #1
 8014620:	f7fc fe66 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014624:	4603      	mov	r3, r0
 8014626:	2b00      	cmp	r3, #0
 8014628:	d101      	bne.n	801462e <LSM303AGR_ACC_R_Int2_IA+0x1e>
    return MEMS_ERROR;
 801462a:	2300      	movs	r3, #0
 801462c:	e007      	b.n	801463e <LSM303AGR_ACC_R_Int2_IA+0x2e>

  *value &= LSM303AGR_ACC_IA_MASK; //mask
 801462e:	9b00      	ldr	r3, [sp, #0]
 8014630:	781b      	ldrb	r3, [r3, #0]
 8014632:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8014636:	b2da      	uxtb	r2, r3
 8014638:	9b00      	ldr	r3, [sp, #0]
 801463a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801463c:	2301      	movs	r3, #1
}
 801463e:	4618      	mov	r0, r3
 8014640:	b003      	add	sp, #12
 8014642:	f85d fb04 	ldr.w	pc, [sp], #4
 8014646:	bf00      	nop
 8014648:	f3af 8000 	nop.w
 801464c:	f3af 8000 	nop.w

08014650 <LSM303AGR_ACC_W_Int1_Threshold>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1_Threshold(void *handle, u8_t newValue)
{
 8014650:	b500      	push	{lr}
 8014652:	b085      	sub	sp, #20
 8014654:	9001      	str	r0, [sp, #4]
 8014656:	460b      	mov	r3, r1
 8014658:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_THS_POSITION; //mask
  newValue &= LSM303AGR_ACC_THS_MASK; //coerce
 801465c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014660:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8014664:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_THS, &value, 1) )
 8014668:	f10d 030f 	add.w	r3, sp, #15
 801466c:	9801      	ldr	r0, [sp, #4]
 801466e:	2132      	movs	r1, #50	; 0x32
 8014670:	461a      	mov	r2, r3
 8014672:	2301      	movs	r3, #1
 8014674:	f7fc fe3c 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014678:	4603      	mov	r3, r0
 801467a:	2b00      	cmp	r3, #0
 801467c:	d101      	bne.n	8014682 <LSM303AGR_ACC_W_Int1_Threshold+0x32>
    return MEMS_ERROR;
 801467e:	2300      	movs	r3, #0
 8014680:	e01c      	b.n	80146bc <LSM303AGR_ACC_W_Int1_Threshold+0x6c>

  value &= ~LSM303AGR_ACC_THS_MASK;
 8014682:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014686:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801468a:	b2db      	uxtb	r3, r3
 801468c:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014690:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014694:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014698:	4313      	orrs	r3, r2
 801469a:	b2db      	uxtb	r3, r3
 801469c:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_THS, &value, 1) )
 80146a0:	f10d 030f 	add.w	r3, sp, #15
 80146a4:	9801      	ldr	r0, [sp, #4]
 80146a6:	2132      	movs	r1, #50	; 0x32
 80146a8:	461a      	mov	r2, r3
 80146aa:	2301      	movs	r3, #1
 80146ac:	f7fc fdf8 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 80146b0:	4603      	mov	r3, r0
 80146b2:	2b00      	cmp	r3, #0
 80146b4:	d101      	bne.n	80146ba <LSM303AGR_ACC_W_Int1_Threshold+0x6a>
    return MEMS_ERROR;
 80146b6:	2300      	movs	r3, #0
 80146b8:	e000      	b.n	80146bc <LSM303AGR_ACC_W_Int1_Threshold+0x6c>

  return MEMS_SUCCESS;
 80146ba:	2301      	movs	r3, #1
}
 80146bc:	4618      	mov	r0, r3
 80146be:	b005      	add	sp, #20
 80146c0:	f85d fb04 	ldr.w	pc, [sp], #4
 80146c4:	f3af 8000 	nop.w
 80146c8:	f3af 8000 	nop.w
 80146cc:	f3af 8000 	nop.w

080146d0 <LSM303AGR_ACC_R_Int1_Threshold>:
* Input          : Pointer to u8_t
* Output         : Status of THS
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_Threshold(void *handle, u8_t *value)
{
 80146d0:	b500      	push	{lr}
 80146d2:	b083      	sub	sp, #12
 80146d4:	9001      	str	r0, [sp, #4]
 80146d6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_THS, (u8_t *)value, 1) )
 80146d8:	9801      	ldr	r0, [sp, #4]
 80146da:	2132      	movs	r1, #50	; 0x32
 80146dc:	9a00      	ldr	r2, [sp, #0]
 80146de:	2301      	movs	r3, #1
 80146e0:	f7fc fe06 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80146e4:	4603      	mov	r3, r0
 80146e6:	2b00      	cmp	r3, #0
 80146e8:	d101      	bne.n	80146ee <LSM303AGR_ACC_R_Int1_Threshold+0x1e>
    return MEMS_ERROR;
 80146ea:	2300      	movs	r3, #0
 80146ec:	e00b      	b.n	8014706 <LSM303AGR_ACC_R_Int1_Threshold+0x36>

  *value &= LSM303AGR_ACC_THS_MASK; //coerce
 80146ee:	9b00      	ldr	r3, [sp, #0]
 80146f0:	781b      	ldrb	r3, [r3, #0]
 80146f2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80146f6:	b2da      	uxtb	r2, r3
 80146f8:	9b00      	ldr	r3, [sp, #0]
 80146fa:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_THS_POSITION; //mask
 80146fc:	9b00      	ldr	r3, [sp, #0]
 80146fe:	781a      	ldrb	r2, [r3, #0]
 8014700:	9b00      	ldr	r3, [sp, #0]
 8014702:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014704:	2301      	movs	r3, #1
}
 8014706:	4618      	mov	r0, r3
 8014708:	b003      	add	sp, #12
 801470a:	f85d fb04 	ldr.w	pc, [sp], #4
 801470e:	bf00      	nop

08014710 <LSM303AGR_ACC_W_Int2_Threshold>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2_Threshold(void *handle, u8_t newValue)
{
 8014710:	b500      	push	{lr}
 8014712:	b085      	sub	sp, #20
 8014714:	9001      	str	r0, [sp, #4]
 8014716:	460b      	mov	r3, r1
 8014718:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_THS_POSITION; //mask
  newValue &= LSM303AGR_ACC_THS_MASK; //coerce
 801471c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014720:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8014724:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_THS, &value, 1) )
 8014728:	f10d 030f 	add.w	r3, sp, #15
 801472c:	9801      	ldr	r0, [sp, #4]
 801472e:	2136      	movs	r1, #54	; 0x36
 8014730:	461a      	mov	r2, r3
 8014732:	2301      	movs	r3, #1
 8014734:	f7fc fddc 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014738:	4603      	mov	r3, r0
 801473a:	2b00      	cmp	r3, #0
 801473c:	d101      	bne.n	8014742 <LSM303AGR_ACC_W_Int2_Threshold+0x32>
    return MEMS_ERROR;
 801473e:	2300      	movs	r3, #0
 8014740:	e01c      	b.n	801477c <LSM303AGR_ACC_W_Int2_Threshold+0x6c>

  value &= ~LSM303AGR_ACC_THS_MASK;
 8014742:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014746:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801474a:	b2db      	uxtb	r3, r3
 801474c:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014750:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014754:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014758:	4313      	orrs	r3, r2
 801475a:	b2db      	uxtb	r3, r3
 801475c:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_THS, &value, 1) )
 8014760:	f10d 030f 	add.w	r3, sp, #15
 8014764:	9801      	ldr	r0, [sp, #4]
 8014766:	2136      	movs	r1, #54	; 0x36
 8014768:	461a      	mov	r2, r3
 801476a:	2301      	movs	r3, #1
 801476c:	f7fc fd98 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8014770:	4603      	mov	r3, r0
 8014772:	2b00      	cmp	r3, #0
 8014774:	d101      	bne.n	801477a <LSM303AGR_ACC_W_Int2_Threshold+0x6a>
    return MEMS_ERROR;
 8014776:	2300      	movs	r3, #0
 8014778:	e000      	b.n	801477c <LSM303AGR_ACC_W_Int2_Threshold+0x6c>

  return MEMS_SUCCESS;
 801477a:	2301      	movs	r3, #1
}
 801477c:	4618      	mov	r0, r3
 801477e:	b005      	add	sp, #20
 8014780:	f85d fb04 	ldr.w	pc, [sp], #4
 8014784:	f3af 8000 	nop.w
 8014788:	f3af 8000 	nop.w
 801478c:	f3af 8000 	nop.w

08014790 <LSM303AGR_ACC_R_Int2_Threshold>:
* Input          : Pointer to u8_t
* Output         : Status of THS
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_Threshold(void *handle, u8_t *value)
{
 8014790:	b500      	push	{lr}
 8014792:	b083      	sub	sp, #12
 8014794:	9001      	str	r0, [sp, #4]
 8014796:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_THS, (u8_t *)value, 1) )
 8014798:	9801      	ldr	r0, [sp, #4]
 801479a:	2136      	movs	r1, #54	; 0x36
 801479c:	9a00      	ldr	r2, [sp, #0]
 801479e:	2301      	movs	r3, #1
 80147a0:	f7fc fda6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80147a4:	4603      	mov	r3, r0
 80147a6:	2b00      	cmp	r3, #0
 80147a8:	d101      	bne.n	80147ae <LSM303AGR_ACC_R_Int2_Threshold+0x1e>
    return MEMS_ERROR;
 80147aa:	2300      	movs	r3, #0
 80147ac:	e00b      	b.n	80147c6 <LSM303AGR_ACC_R_Int2_Threshold+0x36>

  *value &= LSM303AGR_ACC_THS_MASK; //coerce
 80147ae:	9b00      	ldr	r3, [sp, #0]
 80147b0:	781b      	ldrb	r3, [r3, #0]
 80147b2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80147b6:	b2da      	uxtb	r2, r3
 80147b8:	9b00      	ldr	r3, [sp, #0]
 80147ba:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_THS_POSITION; //mask
 80147bc:	9b00      	ldr	r3, [sp, #0]
 80147be:	781a      	ldrb	r2, [r3, #0]
 80147c0:	9b00      	ldr	r3, [sp, #0]
 80147c2:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80147c4:	2301      	movs	r3, #1
}
 80147c6:	4618      	mov	r0, r3
 80147c8:	b003      	add	sp, #12
 80147ca:	f85d fb04 	ldr.w	pc, [sp], #4
 80147ce:	bf00      	nop

080147d0 <LSM303AGR_ACC_W_Int1_Duration>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1_Duration(void *handle, u8_t newValue)
{
 80147d0:	b500      	push	{lr}
 80147d2:	b085      	sub	sp, #20
 80147d4:	9001      	str	r0, [sp, #4]
 80147d6:	460b      	mov	r3, r1
 80147d8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_D_POSITION; //mask
  newValue &= LSM303AGR_ACC_D_MASK; //coerce
 80147dc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80147e0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80147e4:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_DURATION, &value, 1) )
 80147e8:	f10d 030f 	add.w	r3, sp, #15
 80147ec:	9801      	ldr	r0, [sp, #4]
 80147ee:	2133      	movs	r1, #51	; 0x33
 80147f0:	461a      	mov	r2, r3
 80147f2:	2301      	movs	r3, #1
 80147f4:	f7fc fd7c 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80147f8:	4603      	mov	r3, r0
 80147fa:	2b00      	cmp	r3, #0
 80147fc:	d101      	bne.n	8014802 <LSM303AGR_ACC_W_Int1_Duration+0x32>
    return MEMS_ERROR;
 80147fe:	2300      	movs	r3, #0
 8014800:	e01c      	b.n	801483c <LSM303AGR_ACC_W_Int1_Duration+0x6c>

  value &= ~LSM303AGR_ACC_D_MASK;
 8014802:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014806:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801480a:	b2db      	uxtb	r3, r3
 801480c:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014810:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014814:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014818:	4313      	orrs	r3, r2
 801481a:	b2db      	uxtb	r3, r3
 801481c:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_DURATION, &value, 1) )
 8014820:	f10d 030f 	add.w	r3, sp, #15
 8014824:	9801      	ldr	r0, [sp, #4]
 8014826:	2133      	movs	r1, #51	; 0x33
 8014828:	461a      	mov	r2, r3
 801482a:	2301      	movs	r3, #1
 801482c:	f7fc fd38 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8014830:	4603      	mov	r3, r0
 8014832:	2b00      	cmp	r3, #0
 8014834:	d101      	bne.n	801483a <LSM303AGR_ACC_W_Int1_Duration+0x6a>
    return MEMS_ERROR;
 8014836:	2300      	movs	r3, #0
 8014838:	e000      	b.n	801483c <LSM303AGR_ACC_W_Int1_Duration+0x6c>

  return MEMS_SUCCESS;
 801483a:	2301      	movs	r3, #1
}
 801483c:	4618      	mov	r0, r3
 801483e:	b005      	add	sp, #20
 8014840:	f85d fb04 	ldr.w	pc, [sp], #4
 8014844:	f3af 8000 	nop.w
 8014848:	f3af 8000 	nop.w
 801484c:	f3af 8000 	nop.w

08014850 <LSM303AGR_ACC_R_Int1_Duration>:
* Input          : Pointer to u8_t
* Output         : Status of D
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_Duration(void *handle, u8_t *value)
{
 8014850:	b500      	push	{lr}
 8014852:	b083      	sub	sp, #12
 8014854:	9001      	str	r0, [sp, #4]
 8014856:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_DURATION, (u8_t *)value, 1) )
 8014858:	9801      	ldr	r0, [sp, #4]
 801485a:	2133      	movs	r1, #51	; 0x33
 801485c:	9a00      	ldr	r2, [sp, #0]
 801485e:	2301      	movs	r3, #1
 8014860:	f7fc fd46 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014864:	4603      	mov	r3, r0
 8014866:	2b00      	cmp	r3, #0
 8014868:	d101      	bne.n	801486e <LSM303AGR_ACC_R_Int1_Duration+0x1e>
    return MEMS_ERROR;
 801486a:	2300      	movs	r3, #0
 801486c:	e00b      	b.n	8014886 <LSM303AGR_ACC_R_Int1_Duration+0x36>

  *value &= LSM303AGR_ACC_D_MASK; //coerce
 801486e:	9b00      	ldr	r3, [sp, #0]
 8014870:	781b      	ldrb	r3, [r3, #0]
 8014872:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8014876:	b2da      	uxtb	r2, r3
 8014878:	9b00      	ldr	r3, [sp, #0]
 801487a:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_D_POSITION; //mask
 801487c:	9b00      	ldr	r3, [sp, #0]
 801487e:	781a      	ldrb	r2, [r3, #0]
 8014880:	9b00      	ldr	r3, [sp, #0]
 8014882:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014884:	2301      	movs	r3, #1
}
 8014886:	4618      	mov	r0, r3
 8014888:	b003      	add	sp, #12
 801488a:	f85d fb04 	ldr.w	pc, [sp], #4
 801488e:	bf00      	nop

08014890 <LSM303AGR_ACC_W_Int2_Duration>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2_Duration(void *handle, u8_t newValue)
{
 8014890:	b500      	push	{lr}
 8014892:	b085      	sub	sp, #20
 8014894:	9001      	str	r0, [sp, #4]
 8014896:	460b      	mov	r3, r1
 8014898:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_D_POSITION; //mask
  newValue &= LSM303AGR_ACC_D_MASK; //coerce
 801489c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80148a0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80148a4:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_DURATION, &value, 1) )
 80148a8:	f10d 030f 	add.w	r3, sp, #15
 80148ac:	9801      	ldr	r0, [sp, #4]
 80148ae:	2137      	movs	r1, #55	; 0x37
 80148b0:	461a      	mov	r2, r3
 80148b2:	2301      	movs	r3, #1
 80148b4:	f7fc fd1c 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80148b8:	4603      	mov	r3, r0
 80148ba:	2b00      	cmp	r3, #0
 80148bc:	d101      	bne.n	80148c2 <LSM303AGR_ACC_W_Int2_Duration+0x32>
    return MEMS_ERROR;
 80148be:	2300      	movs	r3, #0
 80148c0:	e01c      	b.n	80148fc <LSM303AGR_ACC_W_Int2_Duration+0x6c>

  value &= ~LSM303AGR_ACC_D_MASK;
 80148c2:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80148c6:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80148ca:	b2db      	uxtb	r3, r3
 80148cc:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80148d0:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80148d4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80148d8:	4313      	orrs	r3, r2
 80148da:	b2db      	uxtb	r3, r3
 80148dc:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_DURATION, &value, 1) )
 80148e0:	f10d 030f 	add.w	r3, sp, #15
 80148e4:	9801      	ldr	r0, [sp, #4]
 80148e6:	2137      	movs	r1, #55	; 0x37
 80148e8:	461a      	mov	r2, r3
 80148ea:	2301      	movs	r3, #1
 80148ec:	f7fc fcd8 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 80148f0:	4603      	mov	r3, r0
 80148f2:	2b00      	cmp	r3, #0
 80148f4:	d101      	bne.n	80148fa <LSM303AGR_ACC_W_Int2_Duration+0x6a>
    return MEMS_ERROR;
 80148f6:	2300      	movs	r3, #0
 80148f8:	e000      	b.n	80148fc <LSM303AGR_ACC_W_Int2_Duration+0x6c>

  return MEMS_SUCCESS;
 80148fa:	2301      	movs	r3, #1
}
 80148fc:	4618      	mov	r0, r3
 80148fe:	b005      	add	sp, #20
 8014900:	f85d fb04 	ldr.w	pc, [sp], #4
 8014904:	f3af 8000 	nop.w
 8014908:	f3af 8000 	nop.w
 801490c:	f3af 8000 	nop.w

08014910 <LSM303AGR_ACC_R_Int2_Duration>:
* Input          : Pointer to u8_t
* Output         : Status of D
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_Duration(void *handle, u8_t *value)
{
 8014910:	b500      	push	{lr}
 8014912:	b083      	sub	sp, #12
 8014914:	9001      	str	r0, [sp, #4]
 8014916:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_DURATION, (u8_t *)value, 1) )
 8014918:	9801      	ldr	r0, [sp, #4]
 801491a:	2137      	movs	r1, #55	; 0x37
 801491c:	9a00      	ldr	r2, [sp, #0]
 801491e:	2301      	movs	r3, #1
 8014920:	f7fc fce6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014924:	4603      	mov	r3, r0
 8014926:	2b00      	cmp	r3, #0
 8014928:	d101      	bne.n	801492e <LSM303AGR_ACC_R_Int2_Duration+0x1e>
    return MEMS_ERROR;
 801492a:	2300      	movs	r3, #0
 801492c:	e00b      	b.n	8014946 <LSM303AGR_ACC_R_Int2_Duration+0x36>

  *value &= LSM303AGR_ACC_D_MASK; //coerce
 801492e:	9b00      	ldr	r3, [sp, #0]
 8014930:	781b      	ldrb	r3, [r3, #0]
 8014932:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8014936:	b2da      	uxtb	r2, r3
 8014938:	9b00      	ldr	r3, [sp, #0]
 801493a:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_D_POSITION; //mask
 801493c:	9b00      	ldr	r3, [sp, #0]
 801493e:	781a      	ldrb	r2, [r3, #0]
 8014940:	9b00      	ldr	r3, [sp, #0]
 8014942:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014944:	2301      	movs	r3, #1
}
 8014946:	4618      	mov	r0, r3
 8014948:	b003      	add	sp, #12
 801494a:	f85d fb04 	ldr.w	pc, [sp], #4
 801494e:	bf00      	nop

08014950 <LSM303AGR_ACC_W_XSingle>:
* Input          : LSM303AGR_ACC_XS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_XSingle(void *handle, LSM303AGR_ACC_XS_t newValue)
{
 8014950:	b500      	push	{lr}
 8014952:	b085      	sub	sp, #20
 8014954:	9001      	str	r0, [sp, #4]
 8014956:	460b      	mov	r3, r1
 8014958:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 801495c:	f10d 030f 	add.w	r3, sp, #15
 8014960:	9801      	ldr	r0, [sp, #4]
 8014962:	2138      	movs	r1, #56	; 0x38
 8014964:	461a      	mov	r2, r3
 8014966:	2301      	movs	r3, #1
 8014968:	f7fc fcc2 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 801496c:	4603      	mov	r3, r0
 801496e:	2b00      	cmp	r3, #0
 8014970:	d101      	bne.n	8014976 <LSM303AGR_ACC_W_XSingle+0x26>
    return MEMS_ERROR;
 8014972:	2300      	movs	r3, #0
 8014974:	e01c      	b.n	80149b0 <LSM303AGR_ACC_W_XSingle+0x60>

  value &= ~LSM303AGR_ACC_XS_MASK;
 8014976:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801497a:	f023 0301 	bic.w	r3, r3, #1
 801497e:	b2db      	uxtb	r3, r3
 8014980:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014984:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014988:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801498c:	4313      	orrs	r3, r2
 801498e:	b2db      	uxtb	r3, r3
 8014990:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8014994:	f10d 030f 	add.w	r3, sp, #15
 8014998:	9801      	ldr	r0, [sp, #4]
 801499a:	2138      	movs	r1, #56	; 0x38
 801499c:	461a      	mov	r2, r3
 801499e:	2301      	movs	r3, #1
 80149a0:	f7fc fc7e 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 80149a4:	4603      	mov	r3, r0
 80149a6:	2b00      	cmp	r3, #0
 80149a8:	d101      	bne.n	80149ae <LSM303AGR_ACC_W_XSingle+0x5e>
    return MEMS_ERROR;
 80149aa:	2300      	movs	r3, #0
 80149ac:	e000      	b.n	80149b0 <LSM303AGR_ACC_W_XSingle+0x60>

  return MEMS_SUCCESS;
 80149ae:	2301      	movs	r3, #1
}
 80149b0:	4618      	mov	r0, r3
 80149b2:	b005      	add	sp, #20
 80149b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80149b8:	f3af 8000 	nop.w
 80149bc:	f3af 8000 	nop.w

080149c0 <LSM303AGR_ACC_R_XSingle>:
* Input          : Pointer to LSM303AGR_ACC_XS_t
* Output         : Status of XS see LSM303AGR_ACC_XS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XSingle(void *handle, LSM303AGR_ACC_XS_t *value)
{
 80149c0:	b500      	push	{lr}
 80149c2:	b083      	sub	sp, #12
 80149c4:	9001      	str	r0, [sp, #4]
 80149c6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, (u8_t *)value, 1) )
 80149c8:	9801      	ldr	r0, [sp, #4]
 80149ca:	2138      	movs	r1, #56	; 0x38
 80149cc:	9a00      	ldr	r2, [sp, #0]
 80149ce:	2301      	movs	r3, #1
 80149d0:	f7fc fc8e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80149d4:	4603      	mov	r3, r0
 80149d6:	2b00      	cmp	r3, #0
 80149d8:	d101      	bne.n	80149de <LSM303AGR_ACC_R_XSingle+0x1e>
    return MEMS_ERROR;
 80149da:	2300      	movs	r3, #0
 80149dc:	e007      	b.n	80149ee <LSM303AGR_ACC_R_XSingle+0x2e>

  *value &= LSM303AGR_ACC_XS_MASK; //mask
 80149de:	9b00      	ldr	r3, [sp, #0]
 80149e0:	781b      	ldrb	r3, [r3, #0]
 80149e2:	f003 0301 	and.w	r3, r3, #1
 80149e6:	b2da      	uxtb	r2, r3
 80149e8:	9b00      	ldr	r3, [sp, #0]
 80149ea:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80149ec:	2301      	movs	r3, #1
}
 80149ee:	4618      	mov	r0, r3
 80149f0:	b003      	add	sp, #12
 80149f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80149f6:	bf00      	nop
 80149f8:	f3af 8000 	nop.w
 80149fc:	f3af 8000 	nop.w

08014a00 <LSM303AGR_ACC_W_XDouble>:
* Input          : LSM303AGR_ACC_XD_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_XDouble(void *handle, LSM303AGR_ACC_XD_t newValue)
{
 8014a00:	b500      	push	{lr}
 8014a02:	b085      	sub	sp, #20
 8014a04:	9001      	str	r0, [sp, #4]
 8014a06:	460b      	mov	r3, r1
 8014a08:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8014a0c:	f10d 030f 	add.w	r3, sp, #15
 8014a10:	9801      	ldr	r0, [sp, #4]
 8014a12:	2138      	movs	r1, #56	; 0x38
 8014a14:	461a      	mov	r2, r3
 8014a16:	2301      	movs	r3, #1
 8014a18:	f7fc fc6a 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014a1c:	4603      	mov	r3, r0
 8014a1e:	2b00      	cmp	r3, #0
 8014a20:	d101      	bne.n	8014a26 <LSM303AGR_ACC_W_XDouble+0x26>
    return MEMS_ERROR;
 8014a22:	2300      	movs	r3, #0
 8014a24:	e01c      	b.n	8014a60 <LSM303AGR_ACC_W_XDouble+0x60>

  value &= ~LSM303AGR_ACC_XD_MASK;
 8014a26:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014a2a:	f023 0302 	bic.w	r3, r3, #2
 8014a2e:	b2db      	uxtb	r3, r3
 8014a30:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014a34:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014a38:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014a3c:	4313      	orrs	r3, r2
 8014a3e:	b2db      	uxtb	r3, r3
 8014a40:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8014a44:	f10d 030f 	add.w	r3, sp, #15
 8014a48:	9801      	ldr	r0, [sp, #4]
 8014a4a:	2138      	movs	r1, #56	; 0x38
 8014a4c:	461a      	mov	r2, r3
 8014a4e:	2301      	movs	r3, #1
 8014a50:	f7fc fc26 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8014a54:	4603      	mov	r3, r0
 8014a56:	2b00      	cmp	r3, #0
 8014a58:	d101      	bne.n	8014a5e <LSM303AGR_ACC_W_XDouble+0x5e>
    return MEMS_ERROR;
 8014a5a:	2300      	movs	r3, #0
 8014a5c:	e000      	b.n	8014a60 <LSM303AGR_ACC_W_XDouble+0x60>

  return MEMS_SUCCESS;
 8014a5e:	2301      	movs	r3, #1
}
 8014a60:	4618      	mov	r0, r3
 8014a62:	b005      	add	sp, #20
 8014a64:	f85d fb04 	ldr.w	pc, [sp], #4
 8014a68:	f3af 8000 	nop.w
 8014a6c:	f3af 8000 	nop.w

08014a70 <LSM303AGR_ACC_R_XDouble>:
* Input          : Pointer to LSM303AGR_ACC_XD_t
* Output         : Status of XD see LSM303AGR_ACC_XD_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XDouble(void *handle, LSM303AGR_ACC_XD_t *value)
{
 8014a70:	b500      	push	{lr}
 8014a72:	b083      	sub	sp, #12
 8014a74:	9001      	str	r0, [sp, #4]
 8014a76:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, (u8_t *)value, 1) )
 8014a78:	9801      	ldr	r0, [sp, #4]
 8014a7a:	2138      	movs	r1, #56	; 0x38
 8014a7c:	9a00      	ldr	r2, [sp, #0]
 8014a7e:	2301      	movs	r3, #1
 8014a80:	f7fc fc36 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014a84:	4603      	mov	r3, r0
 8014a86:	2b00      	cmp	r3, #0
 8014a88:	d101      	bne.n	8014a8e <LSM303AGR_ACC_R_XDouble+0x1e>
    return MEMS_ERROR;
 8014a8a:	2300      	movs	r3, #0
 8014a8c:	e007      	b.n	8014a9e <LSM303AGR_ACC_R_XDouble+0x2e>

  *value &= LSM303AGR_ACC_XD_MASK; //mask
 8014a8e:	9b00      	ldr	r3, [sp, #0]
 8014a90:	781b      	ldrb	r3, [r3, #0]
 8014a92:	f003 0302 	and.w	r3, r3, #2
 8014a96:	b2da      	uxtb	r2, r3
 8014a98:	9b00      	ldr	r3, [sp, #0]
 8014a9a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014a9c:	2301      	movs	r3, #1
}
 8014a9e:	4618      	mov	r0, r3
 8014aa0:	b003      	add	sp, #12
 8014aa2:	f85d fb04 	ldr.w	pc, [sp], #4
 8014aa6:	bf00      	nop
 8014aa8:	f3af 8000 	nop.w
 8014aac:	f3af 8000 	nop.w

08014ab0 <LSM303AGR_ACC_W_YSingle>:
* Input          : LSM303AGR_ACC_YS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_YSingle(void *handle, LSM303AGR_ACC_YS_t newValue)
{
 8014ab0:	b500      	push	{lr}
 8014ab2:	b085      	sub	sp, #20
 8014ab4:	9001      	str	r0, [sp, #4]
 8014ab6:	460b      	mov	r3, r1
 8014ab8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8014abc:	f10d 030f 	add.w	r3, sp, #15
 8014ac0:	9801      	ldr	r0, [sp, #4]
 8014ac2:	2138      	movs	r1, #56	; 0x38
 8014ac4:	461a      	mov	r2, r3
 8014ac6:	2301      	movs	r3, #1
 8014ac8:	f7fc fc12 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014acc:	4603      	mov	r3, r0
 8014ace:	2b00      	cmp	r3, #0
 8014ad0:	d101      	bne.n	8014ad6 <LSM303AGR_ACC_W_YSingle+0x26>
    return MEMS_ERROR;
 8014ad2:	2300      	movs	r3, #0
 8014ad4:	e01c      	b.n	8014b10 <LSM303AGR_ACC_W_YSingle+0x60>

  value &= ~LSM303AGR_ACC_YS_MASK;
 8014ad6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014ada:	f023 0304 	bic.w	r3, r3, #4
 8014ade:	b2db      	uxtb	r3, r3
 8014ae0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014ae4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014ae8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014aec:	4313      	orrs	r3, r2
 8014aee:	b2db      	uxtb	r3, r3
 8014af0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8014af4:	f10d 030f 	add.w	r3, sp, #15
 8014af8:	9801      	ldr	r0, [sp, #4]
 8014afa:	2138      	movs	r1, #56	; 0x38
 8014afc:	461a      	mov	r2, r3
 8014afe:	2301      	movs	r3, #1
 8014b00:	f7fc fbce 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8014b04:	4603      	mov	r3, r0
 8014b06:	2b00      	cmp	r3, #0
 8014b08:	d101      	bne.n	8014b0e <LSM303AGR_ACC_W_YSingle+0x5e>
    return MEMS_ERROR;
 8014b0a:	2300      	movs	r3, #0
 8014b0c:	e000      	b.n	8014b10 <LSM303AGR_ACC_W_YSingle+0x60>

  return MEMS_SUCCESS;
 8014b0e:	2301      	movs	r3, #1
}
 8014b10:	4618      	mov	r0, r3
 8014b12:	b005      	add	sp, #20
 8014b14:	f85d fb04 	ldr.w	pc, [sp], #4
 8014b18:	f3af 8000 	nop.w
 8014b1c:	f3af 8000 	nop.w

08014b20 <LSM303AGR_ACC_R_YSingle>:
* Input          : Pointer to LSM303AGR_ACC_YS_t
* Output         : Status of YS see LSM303AGR_ACC_YS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_YSingle(void *handle, LSM303AGR_ACC_YS_t *value)
{
 8014b20:	b500      	push	{lr}
 8014b22:	b083      	sub	sp, #12
 8014b24:	9001      	str	r0, [sp, #4]
 8014b26:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, (u8_t *)value, 1) )
 8014b28:	9801      	ldr	r0, [sp, #4]
 8014b2a:	2138      	movs	r1, #56	; 0x38
 8014b2c:	9a00      	ldr	r2, [sp, #0]
 8014b2e:	2301      	movs	r3, #1
 8014b30:	f7fc fbde 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014b34:	4603      	mov	r3, r0
 8014b36:	2b00      	cmp	r3, #0
 8014b38:	d101      	bne.n	8014b3e <LSM303AGR_ACC_R_YSingle+0x1e>
    return MEMS_ERROR;
 8014b3a:	2300      	movs	r3, #0
 8014b3c:	e007      	b.n	8014b4e <LSM303AGR_ACC_R_YSingle+0x2e>

  *value &= LSM303AGR_ACC_YS_MASK; //mask
 8014b3e:	9b00      	ldr	r3, [sp, #0]
 8014b40:	781b      	ldrb	r3, [r3, #0]
 8014b42:	f003 0304 	and.w	r3, r3, #4
 8014b46:	b2da      	uxtb	r2, r3
 8014b48:	9b00      	ldr	r3, [sp, #0]
 8014b4a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014b4c:	2301      	movs	r3, #1
}
 8014b4e:	4618      	mov	r0, r3
 8014b50:	b003      	add	sp, #12
 8014b52:	f85d fb04 	ldr.w	pc, [sp], #4
 8014b56:	bf00      	nop
 8014b58:	f3af 8000 	nop.w
 8014b5c:	f3af 8000 	nop.w

08014b60 <LSM303AGR_ACC_W_YDouble>:
* Input          : LSM303AGR_ACC_YD_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_YDouble(void *handle, LSM303AGR_ACC_YD_t newValue)
{
 8014b60:	b500      	push	{lr}
 8014b62:	b085      	sub	sp, #20
 8014b64:	9001      	str	r0, [sp, #4]
 8014b66:	460b      	mov	r3, r1
 8014b68:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8014b6c:	f10d 030f 	add.w	r3, sp, #15
 8014b70:	9801      	ldr	r0, [sp, #4]
 8014b72:	2138      	movs	r1, #56	; 0x38
 8014b74:	461a      	mov	r2, r3
 8014b76:	2301      	movs	r3, #1
 8014b78:	f7fc fbba 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014b7c:	4603      	mov	r3, r0
 8014b7e:	2b00      	cmp	r3, #0
 8014b80:	d101      	bne.n	8014b86 <LSM303AGR_ACC_W_YDouble+0x26>
    return MEMS_ERROR;
 8014b82:	2300      	movs	r3, #0
 8014b84:	e01c      	b.n	8014bc0 <LSM303AGR_ACC_W_YDouble+0x60>

  value &= ~LSM303AGR_ACC_YD_MASK;
 8014b86:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014b8a:	f023 0308 	bic.w	r3, r3, #8
 8014b8e:	b2db      	uxtb	r3, r3
 8014b90:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014b94:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014b98:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014b9c:	4313      	orrs	r3, r2
 8014b9e:	b2db      	uxtb	r3, r3
 8014ba0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8014ba4:	f10d 030f 	add.w	r3, sp, #15
 8014ba8:	9801      	ldr	r0, [sp, #4]
 8014baa:	2138      	movs	r1, #56	; 0x38
 8014bac:	461a      	mov	r2, r3
 8014bae:	2301      	movs	r3, #1
 8014bb0:	f7fc fb76 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8014bb4:	4603      	mov	r3, r0
 8014bb6:	2b00      	cmp	r3, #0
 8014bb8:	d101      	bne.n	8014bbe <LSM303AGR_ACC_W_YDouble+0x5e>
    return MEMS_ERROR;
 8014bba:	2300      	movs	r3, #0
 8014bbc:	e000      	b.n	8014bc0 <LSM303AGR_ACC_W_YDouble+0x60>

  return MEMS_SUCCESS;
 8014bbe:	2301      	movs	r3, #1
}
 8014bc0:	4618      	mov	r0, r3
 8014bc2:	b005      	add	sp, #20
 8014bc4:	f85d fb04 	ldr.w	pc, [sp], #4
 8014bc8:	f3af 8000 	nop.w
 8014bcc:	f3af 8000 	nop.w

08014bd0 <LSM303AGR_ACC_R_YDouble>:
* Input          : Pointer to LSM303AGR_ACC_YD_t
* Output         : Status of YD see LSM303AGR_ACC_YD_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_YDouble(void *handle, LSM303AGR_ACC_YD_t *value)
{
 8014bd0:	b500      	push	{lr}
 8014bd2:	b083      	sub	sp, #12
 8014bd4:	9001      	str	r0, [sp, #4]
 8014bd6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, (u8_t *)value, 1) )
 8014bd8:	9801      	ldr	r0, [sp, #4]
 8014bda:	2138      	movs	r1, #56	; 0x38
 8014bdc:	9a00      	ldr	r2, [sp, #0]
 8014bde:	2301      	movs	r3, #1
 8014be0:	f7fc fb86 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014be4:	4603      	mov	r3, r0
 8014be6:	2b00      	cmp	r3, #0
 8014be8:	d101      	bne.n	8014bee <LSM303AGR_ACC_R_YDouble+0x1e>
    return MEMS_ERROR;
 8014bea:	2300      	movs	r3, #0
 8014bec:	e007      	b.n	8014bfe <LSM303AGR_ACC_R_YDouble+0x2e>

  *value &= LSM303AGR_ACC_YD_MASK; //mask
 8014bee:	9b00      	ldr	r3, [sp, #0]
 8014bf0:	781b      	ldrb	r3, [r3, #0]
 8014bf2:	f003 0308 	and.w	r3, r3, #8
 8014bf6:	b2da      	uxtb	r2, r3
 8014bf8:	9b00      	ldr	r3, [sp, #0]
 8014bfa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014bfc:	2301      	movs	r3, #1
}
 8014bfe:	4618      	mov	r0, r3
 8014c00:	b003      	add	sp, #12
 8014c02:	f85d fb04 	ldr.w	pc, [sp], #4
 8014c06:	bf00      	nop
 8014c08:	f3af 8000 	nop.w
 8014c0c:	f3af 8000 	nop.w

08014c10 <LSM303AGR_ACC_W_ZSingle>:
* Input          : LSM303AGR_ACC_ZS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ZSingle(void *handle, LSM303AGR_ACC_ZS_t newValue)
{
 8014c10:	b500      	push	{lr}
 8014c12:	b085      	sub	sp, #20
 8014c14:	9001      	str	r0, [sp, #4]
 8014c16:	460b      	mov	r3, r1
 8014c18:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8014c1c:	f10d 030f 	add.w	r3, sp, #15
 8014c20:	9801      	ldr	r0, [sp, #4]
 8014c22:	2138      	movs	r1, #56	; 0x38
 8014c24:	461a      	mov	r2, r3
 8014c26:	2301      	movs	r3, #1
 8014c28:	f7fc fb62 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014c2c:	4603      	mov	r3, r0
 8014c2e:	2b00      	cmp	r3, #0
 8014c30:	d101      	bne.n	8014c36 <LSM303AGR_ACC_W_ZSingle+0x26>
    return MEMS_ERROR;
 8014c32:	2300      	movs	r3, #0
 8014c34:	e01c      	b.n	8014c70 <LSM303AGR_ACC_W_ZSingle+0x60>

  value &= ~LSM303AGR_ACC_ZS_MASK;
 8014c36:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014c3a:	f023 0310 	bic.w	r3, r3, #16
 8014c3e:	b2db      	uxtb	r3, r3
 8014c40:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014c44:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014c48:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014c4c:	4313      	orrs	r3, r2
 8014c4e:	b2db      	uxtb	r3, r3
 8014c50:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8014c54:	f10d 030f 	add.w	r3, sp, #15
 8014c58:	9801      	ldr	r0, [sp, #4]
 8014c5a:	2138      	movs	r1, #56	; 0x38
 8014c5c:	461a      	mov	r2, r3
 8014c5e:	2301      	movs	r3, #1
 8014c60:	f7fc fb1e 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8014c64:	4603      	mov	r3, r0
 8014c66:	2b00      	cmp	r3, #0
 8014c68:	d101      	bne.n	8014c6e <LSM303AGR_ACC_W_ZSingle+0x5e>
    return MEMS_ERROR;
 8014c6a:	2300      	movs	r3, #0
 8014c6c:	e000      	b.n	8014c70 <LSM303AGR_ACC_W_ZSingle+0x60>

  return MEMS_SUCCESS;
 8014c6e:	2301      	movs	r3, #1
}
 8014c70:	4618      	mov	r0, r3
 8014c72:	b005      	add	sp, #20
 8014c74:	f85d fb04 	ldr.w	pc, [sp], #4
 8014c78:	f3af 8000 	nop.w
 8014c7c:	f3af 8000 	nop.w

08014c80 <LSM303AGR_ACC_R_ZSingle>:
* Input          : Pointer to LSM303AGR_ACC_ZS_t
* Output         : Status of ZS see LSM303AGR_ACC_ZS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ZSingle(void *handle, LSM303AGR_ACC_ZS_t *value)
{
 8014c80:	b500      	push	{lr}
 8014c82:	b083      	sub	sp, #12
 8014c84:	9001      	str	r0, [sp, #4]
 8014c86:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, (u8_t *)value, 1) )
 8014c88:	9801      	ldr	r0, [sp, #4]
 8014c8a:	2138      	movs	r1, #56	; 0x38
 8014c8c:	9a00      	ldr	r2, [sp, #0]
 8014c8e:	2301      	movs	r3, #1
 8014c90:	f7fc fb2e 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014c94:	4603      	mov	r3, r0
 8014c96:	2b00      	cmp	r3, #0
 8014c98:	d101      	bne.n	8014c9e <LSM303AGR_ACC_R_ZSingle+0x1e>
    return MEMS_ERROR;
 8014c9a:	2300      	movs	r3, #0
 8014c9c:	e007      	b.n	8014cae <LSM303AGR_ACC_R_ZSingle+0x2e>

  *value &= LSM303AGR_ACC_ZS_MASK; //mask
 8014c9e:	9b00      	ldr	r3, [sp, #0]
 8014ca0:	781b      	ldrb	r3, [r3, #0]
 8014ca2:	f003 0310 	and.w	r3, r3, #16
 8014ca6:	b2da      	uxtb	r2, r3
 8014ca8:	9b00      	ldr	r3, [sp, #0]
 8014caa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014cac:	2301      	movs	r3, #1
}
 8014cae:	4618      	mov	r0, r3
 8014cb0:	b003      	add	sp, #12
 8014cb2:	f85d fb04 	ldr.w	pc, [sp], #4
 8014cb6:	bf00      	nop
 8014cb8:	f3af 8000 	nop.w
 8014cbc:	f3af 8000 	nop.w

08014cc0 <LSM303AGR_ACC_W_ZDouble>:
* Input          : LSM303AGR_ACC_ZD_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ZDouble(void *handle, LSM303AGR_ACC_ZD_t newValue)
{
 8014cc0:	b500      	push	{lr}
 8014cc2:	b085      	sub	sp, #20
 8014cc4:	9001      	str	r0, [sp, #4]
 8014cc6:	460b      	mov	r3, r1
 8014cc8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8014ccc:	f10d 030f 	add.w	r3, sp, #15
 8014cd0:	9801      	ldr	r0, [sp, #4]
 8014cd2:	2138      	movs	r1, #56	; 0x38
 8014cd4:	461a      	mov	r2, r3
 8014cd6:	2301      	movs	r3, #1
 8014cd8:	f7fc fb0a 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014cdc:	4603      	mov	r3, r0
 8014cde:	2b00      	cmp	r3, #0
 8014ce0:	d101      	bne.n	8014ce6 <LSM303AGR_ACC_W_ZDouble+0x26>
    return MEMS_ERROR;
 8014ce2:	2300      	movs	r3, #0
 8014ce4:	e01c      	b.n	8014d20 <LSM303AGR_ACC_W_ZDouble+0x60>

  value &= ~LSM303AGR_ACC_ZD_MASK;
 8014ce6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014cea:	f023 0320 	bic.w	r3, r3, #32
 8014cee:	b2db      	uxtb	r3, r3
 8014cf0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014cf4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014cf8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014cfc:	4313      	orrs	r3, r2
 8014cfe:	b2db      	uxtb	r3, r3
 8014d00:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8014d04:	f10d 030f 	add.w	r3, sp, #15
 8014d08:	9801      	ldr	r0, [sp, #4]
 8014d0a:	2138      	movs	r1, #56	; 0x38
 8014d0c:	461a      	mov	r2, r3
 8014d0e:	2301      	movs	r3, #1
 8014d10:	f7fc fac6 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8014d14:	4603      	mov	r3, r0
 8014d16:	2b00      	cmp	r3, #0
 8014d18:	d101      	bne.n	8014d1e <LSM303AGR_ACC_W_ZDouble+0x5e>
    return MEMS_ERROR;
 8014d1a:	2300      	movs	r3, #0
 8014d1c:	e000      	b.n	8014d20 <LSM303AGR_ACC_W_ZDouble+0x60>

  return MEMS_SUCCESS;
 8014d1e:	2301      	movs	r3, #1
}
 8014d20:	4618      	mov	r0, r3
 8014d22:	b005      	add	sp, #20
 8014d24:	f85d fb04 	ldr.w	pc, [sp], #4
 8014d28:	f3af 8000 	nop.w
 8014d2c:	f3af 8000 	nop.w

08014d30 <LSM303AGR_ACC_R_ZDouble>:
* Input          : Pointer to LSM303AGR_ACC_ZD_t
* Output         : Status of ZD see LSM303AGR_ACC_ZD_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ZDouble(void *handle, LSM303AGR_ACC_ZD_t *value)
{
 8014d30:	b500      	push	{lr}
 8014d32:	b083      	sub	sp, #12
 8014d34:	9001      	str	r0, [sp, #4]
 8014d36:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, (u8_t *)value, 1) )
 8014d38:	9801      	ldr	r0, [sp, #4]
 8014d3a:	2138      	movs	r1, #56	; 0x38
 8014d3c:	9a00      	ldr	r2, [sp, #0]
 8014d3e:	2301      	movs	r3, #1
 8014d40:	f7fc fad6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014d44:	4603      	mov	r3, r0
 8014d46:	2b00      	cmp	r3, #0
 8014d48:	d101      	bne.n	8014d4e <LSM303AGR_ACC_R_ZDouble+0x1e>
    return MEMS_ERROR;
 8014d4a:	2300      	movs	r3, #0
 8014d4c:	e007      	b.n	8014d5e <LSM303AGR_ACC_R_ZDouble+0x2e>

  *value &= LSM303AGR_ACC_ZD_MASK; //mask
 8014d4e:	9b00      	ldr	r3, [sp, #0]
 8014d50:	781b      	ldrb	r3, [r3, #0]
 8014d52:	f003 0320 	and.w	r3, r3, #32
 8014d56:	b2da      	uxtb	r2, r3
 8014d58:	9b00      	ldr	r3, [sp, #0]
 8014d5a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014d5c:	2301      	movs	r3, #1
}
 8014d5e:	4618      	mov	r0, r3
 8014d60:	b003      	add	sp, #12
 8014d62:	f85d fb04 	ldr.w	pc, [sp], #4
 8014d66:	bf00      	nop
 8014d68:	f3af 8000 	nop.w
 8014d6c:	f3af 8000 	nop.w

08014d70 <LSM303AGR_ACC_R_ClickX>:
* Input          : Pointer to LSM303AGR_ACC_X_t
* Output         : Status of X see LSM303AGR_ACC_X_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickX(void *handle, LSM303AGR_ACC_X_t *value)
{
 8014d70:	b500      	push	{lr}
 8014d72:	b083      	sub	sp, #12
 8014d74:	9001      	str	r0, [sp, #4]
 8014d76:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 8014d78:	9801      	ldr	r0, [sp, #4]
 8014d7a:	2139      	movs	r1, #57	; 0x39
 8014d7c:	9a00      	ldr	r2, [sp, #0]
 8014d7e:	2301      	movs	r3, #1
 8014d80:	f7fc fab6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014d84:	4603      	mov	r3, r0
 8014d86:	2b00      	cmp	r3, #0
 8014d88:	d101      	bne.n	8014d8e <LSM303AGR_ACC_R_ClickX+0x1e>
    return MEMS_ERROR;
 8014d8a:	2300      	movs	r3, #0
 8014d8c:	e007      	b.n	8014d9e <LSM303AGR_ACC_R_ClickX+0x2e>

  *value &= LSM303AGR_ACC_X_MASK; //mask
 8014d8e:	9b00      	ldr	r3, [sp, #0]
 8014d90:	781b      	ldrb	r3, [r3, #0]
 8014d92:	f003 0301 	and.w	r3, r3, #1
 8014d96:	b2da      	uxtb	r2, r3
 8014d98:	9b00      	ldr	r3, [sp, #0]
 8014d9a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014d9c:	2301      	movs	r3, #1
}
 8014d9e:	4618      	mov	r0, r3
 8014da0:	b003      	add	sp, #12
 8014da2:	f85d fb04 	ldr.w	pc, [sp], #4
 8014da6:	bf00      	nop
 8014da8:	f3af 8000 	nop.w
 8014dac:	f3af 8000 	nop.w

08014db0 <LSM303AGR_ACC_R_ClickY>:
* Input          : Pointer to LSM303AGR_ACC_Y_t
* Output         : Status of Y see LSM303AGR_ACC_Y_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickY(void *handle, LSM303AGR_ACC_Y_t *value)
{
 8014db0:	b500      	push	{lr}
 8014db2:	b083      	sub	sp, #12
 8014db4:	9001      	str	r0, [sp, #4]
 8014db6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 8014db8:	9801      	ldr	r0, [sp, #4]
 8014dba:	2139      	movs	r1, #57	; 0x39
 8014dbc:	9a00      	ldr	r2, [sp, #0]
 8014dbe:	2301      	movs	r3, #1
 8014dc0:	f7fc fa96 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014dc4:	4603      	mov	r3, r0
 8014dc6:	2b00      	cmp	r3, #0
 8014dc8:	d101      	bne.n	8014dce <LSM303AGR_ACC_R_ClickY+0x1e>
    return MEMS_ERROR;
 8014dca:	2300      	movs	r3, #0
 8014dcc:	e007      	b.n	8014dde <LSM303AGR_ACC_R_ClickY+0x2e>

  *value &= LSM303AGR_ACC_Y_MASK; //mask
 8014dce:	9b00      	ldr	r3, [sp, #0]
 8014dd0:	781b      	ldrb	r3, [r3, #0]
 8014dd2:	f003 0302 	and.w	r3, r3, #2
 8014dd6:	b2da      	uxtb	r2, r3
 8014dd8:	9b00      	ldr	r3, [sp, #0]
 8014dda:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014ddc:	2301      	movs	r3, #1
}
 8014dde:	4618      	mov	r0, r3
 8014de0:	b003      	add	sp, #12
 8014de2:	f85d fb04 	ldr.w	pc, [sp], #4
 8014de6:	bf00      	nop
 8014de8:	f3af 8000 	nop.w
 8014dec:	f3af 8000 	nop.w

08014df0 <LSM303AGR_ACC_R_ClickZ>:
* Input          : Pointer to LSM303AGR_ACC_Z_t
* Output         : Status of Z see LSM303AGR_ACC_Z_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickZ(void *handle, LSM303AGR_ACC_Z_t *value)
{
 8014df0:	b500      	push	{lr}
 8014df2:	b083      	sub	sp, #12
 8014df4:	9001      	str	r0, [sp, #4]
 8014df6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 8014df8:	9801      	ldr	r0, [sp, #4]
 8014dfa:	2139      	movs	r1, #57	; 0x39
 8014dfc:	9a00      	ldr	r2, [sp, #0]
 8014dfe:	2301      	movs	r3, #1
 8014e00:	f7fc fa76 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014e04:	4603      	mov	r3, r0
 8014e06:	2b00      	cmp	r3, #0
 8014e08:	d101      	bne.n	8014e0e <LSM303AGR_ACC_R_ClickZ+0x1e>
    return MEMS_ERROR;
 8014e0a:	2300      	movs	r3, #0
 8014e0c:	e007      	b.n	8014e1e <LSM303AGR_ACC_R_ClickZ+0x2e>

  *value &= LSM303AGR_ACC_Z_MASK; //mask
 8014e0e:	9b00      	ldr	r3, [sp, #0]
 8014e10:	781b      	ldrb	r3, [r3, #0]
 8014e12:	f003 0304 	and.w	r3, r3, #4
 8014e16:	b2da      	uxtb	r2, r3
 8014e18:	9b00      	ldr	r3, [sp, #0]
 8014e1a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014e1c:	2301      	movs	r3, #1
}
 8014e1e:	4618      	mov	r0, r3
 8014e20:	b003      	add	sp, #12
 8014e22:	f85d fb04 	ldr.w	pc, [sp], #4
 8014e26:	bf00      	nop
 8014e28:	f3af 8000 	nop.w
 8014e2c:	f3af 8000 	nop.w

08014e30 <LSM303AGR_ACC_R_ClickSign>:
* Input          : Pointer to LSM303AGR_ACC_SIGN_t
* Output         : Status of SIGN see LSM303AGR_ACC_SIGN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickSign(void *handle, LSM303AGR_ACC_SIGN_t *value)
{
 8014e30:	b500      	push	{lr}
 8014e32:	b083      	sub	sp, #12
 8014e34:	9001      	str	r0, [sp, #4]
 8014e36:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 8014e38:	9801      	ldr	r0, [sp, #4]
 8014e3a:	2139      	movs	r1, #57	; 0x39
 8014e3c:	9a00      	ldr	r2, [sp, #0]
 8014e3e:	2301      	movs	r3, #1
 8014e40:	f7fc fa56 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014e44:	4603      	mov	r3, r0
 8014e46:	2b00      	cmp	r3, #0
 8014e48:	d101      	bne.n	8014e4e <LSM303AGR_ACC_R_ClickSign+0x1e>
    return MEMS_ERROR;
 8014e4a:	2300      	movs	r3, #0
 8014e4c:	e007      	b.n	8014e5e <LSM303AGR_ACC_R_ClickSign+0x2e>

  *value &= LSM303AGR_ACC_SIGN_MASK; //mask
 8014e4e:	9b00      	ldr	r3, [sp, #0]
 8014e50:	781b      	ldrb	r3, [r3, #0]
 8014e52:	f003 0308 	and.w	r3, r3, #8
 8014e56:	b2da      	uxtb	r2, r3
 8014e58:	9b00      	ldr	r3, [sp, #0]
 8014e5a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014e5c:	2301      	movs	r3, #1
}
 8014e5e:	4618      	mov	r0, r3
 8014e60:	b003      	add	sp, #12
 8014e62:	f85d fb04 	ldr.w	pc, [sp], #4
 8014e66:	bf00      	nop
 8014e68:	f3af 8000 	nop.w
 8014e6c:	f3af 8000 	nop.w

08014e70 <LSM303AGR_ACC_R_SingleCLICK>:
* Input          : Pointer to LSM303AGR_ACC_SCLICK_t
* Output         : Status of SCLICK see LSM303AGR_ACC_SCLICK_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_SingleCLICK(void *handle, LSM303AGR_ACC_SCLICK_t *value)
{
 8014e70:	b500      	push	{lr}
 8014e72:	b083      	sub	sp, #12
 8014e74:	9001      	str	r0, [sp, #4]
 8014e76:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 8014e78:	9801      	ldr	r0, [sp, #4]
 8014e7a:	2139      	movs	r1, #57	; 0x39
 8014e7c:	9a00      	ldr	r2, [sp, #0]
 8014e7e:	2301      	movs	r3, #1
 8014e80:	f7fc fa36 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014e84:	4603      	mov	r3, r0
 8014e86:	2b00      	cmp	r3, #0
 8014e88:	d101      	bne.n	8014e8e <LSM303AGR_ACC_R_SingleCLICK+0x1e>
    return MEMS_ERROR;
 8014e8a:	2300      	movs	r3, #0
 8014e8c:	e007      	b.n	8014e9e <LSM303AGR_ACC_R_SingleCLICK+0x2e>

  *value &= LSM303AGR_ACC_SCLICK_MASK; //mask
 8014e8e:	9b00      	ldr	r3, [sp, #0]
 8014e90:	781b      	ldrb	r3, [r3, #0]
 8014e92:	f003 0310 	and.w	r3, r3, #16
 8014e96:	b2da      	uxtb	r2, r3
 8014e98:	9b00      	ldr	r3, [sp, #0]
 8014e9a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014e9c:	2301      	movs	r3, #1
}
 8014e9e:	4618      	mov	r0, r3
 8014ea0:	b003      	add	sp, #12
 8014ea2:	f85d fb04 	ldr.w	pc, [sp], #4
 8014ea6:	bf00      	nop
 8014ea8:	f3af 8000 	nop.w
 8014eac:	f3af 8000 	nop.w

08014eb0 <LSM303AGR_ACC_R_DoubleCLICK>:
* Input          : Pointer to LSM303AGR_ACC_DCLICK_t
* Output         : Status of DCLICK see LSM303AGR_ACC_DCLICK_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_DoubleCLICK(void *handle, LSM303AGR_ACC_DCLICK_t *value)
{
 8014eb0:	b500      	push	{lr}
 8014eb2:	b083      	sub	sp, #12
 8014eb4:	9001      	str	r0, [sp, #4]
 8014eb6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 8014eb8:	9801      	ldr	r0, [sp, #4]
 8014eba:	2139      	movs	r1, #57	; 0x39
 8014ebc:	9a00      	ldr	r2, [sp, #0]
 8014ebe:	2301      	movs	r3, #1
 8014ec0:	f7fc fa16 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014ec4:	4603      	mov	r3, r0
 8014ec6:	2b00      	cmp	r3, #0
 8014ec8:	d101      	bne.n	8014ece <LSM303AGR_ACC_R_DoubleCLICK+0x1e>
    return MEMS_ERROR;
 8014eca:	2300      	movs	r3, #0
 8014ecc:	e007      	b.n	8014ede <LSM303AGR_ACC_R_DoubleCLICK+0x2e>

  *value &= LSM303AGR_ACC_DCLICK_MASK; //mask
 8014ece:	9b00      	ldr	r3, [sp, #0]
 8014ed0:	781b      	ldrb	r3, [r3, #0]
 8014ed2:	f003 0320 	and.w	r3, r3, #32
 8014ed6:	b2da      	uxtb	r2, r3
 8014ed8:	9b00      	ldr	r3, [sp, #0]
 8014eda:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014edc:	2301      	movs	r3, #1
}
 8014ede:	4618      	mov	r0, r3
 8014ee0:	b003      	add	sp, #12
 8014ee2:	f85d fb04 	ldr.w	pc, [sp], #4
 8014ee6:	bf00      	nop
 8014ee8:	f3af 8000 	nop.w
 8014eec:	f3af 8000 	nop.w

08014ef0 <LSM303AGR_ACC_R_CLICK_IA>:
* Input          : Pointer to LSM303AGR_ACC_IA_t
* Output         : Status of IA see LSM303AGR_ACC_IA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_CLICK_IA(void *handle, LSM303AGR_ACC_CLICK_IA_t *value)
{
 8014ef0:	b500      	push	{lr}
 8014ef2:	b083      	sub	sp, #12
 8014ef4:	9001      	str	r0, [sp, #4]
 8014ef6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 8014ef8:	9801      	ldr	r0, [sp, #4]
 8014efa:	2139      	movs	r1, #57	; 0x39
 8014efc:	9a00      	ldr	r2, [sp, #0]
 8014efe:	2301      	movs	r3, #1
 8014f00:	f7fc f9f6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014f04:	4603      	mov	r3, r0
 8014f06:	2b00      	cmp	r3, #0
 8014f08:	d101      	bne.n	8014f0e <LSM303AGR_ACC_R_CLICK_IA+0x1e>
    return MEMS_ERROR;
 8014f0a:	2300      	movs	r3, #0
 8014f0c:	e007      	b.n	8014f1e <LSM303AGR_ACC_R_CLICK_IA+0x2e>

  *value &= LSM303AGR_ACC_IA_MASK; //mask
 8014f0e:	9b00      	ldr	r3, [sp, #0]
 8014f10:	781b      	ldrb	r3, [r3, #0]
 8014f12:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8014f16:	b2da      	uxtb	r2, r3
 8014f18:	9b00      	ldr	r3, [sp, #0]
 8014f1a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014f1c:	2301      	movs	r3, #1
}
 8014f1e:	4618      	mov	r0, r3
 8014f20:	b003      	add	sp, #12
 8014f22:	f85d fb04 	ldr.w	pc, [sp], #4
 8014f26:	bf00      	nop
 8014f28:	f3af 8000 	nop.w
 8014f2c:	f3af 8000 	nop.w

08014f30 <LSM303AGR_ACC_W_ClickThreshold>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ClickThreshold(void *handle, u8_t newValue)
{
 8014f30:	b500      	push	{lr}
 8014f32:	b085      	sub	sp, #20
 8014f34:	9001      	str	r0, [sp, #4]
 8014f36:	460b      	mov	r3, r1
 8014f38:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_THS_POSITION; //mask
  newValue &= LSM303AGR_ACC_THS_MASK; //coerce
 8014f3c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014f40:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8014f44:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_THS, &value, 1) )
 8014f48:	f10d 030f 	add.w	r3, sp, #15
 8014f4c:	9801      	ldr	r0, [sp, #4]
 8014f4e:	213a      	movs	r1, #58	; 0x3a
 8014f50:	461a      	mov	r2, r3
 8014f52:	2301      	movs	r3, #1
 8014f54:	f7fc f9cc 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014f58:	4603      	mov	r3, r0
 8014f5a:	2b00      	cmp	r3, #0
 8014f5c:	d101      	bne.n	8014f62 <LSM303AGR_ACC_W_ClickThreshold+0x32>
    return MEMS_ERROR;
 8014f5e:	2300      	movs	r3, #0
 8014f60:	e01c      	b.n	8014f9c <LSM303AGR_ACC_W_ClickThreshold+0x6c>

  value &= ~LSM303AGR_ACC_THS_MASK;
 8014f62:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014f66:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8014f6a:	b2db      	uxtb	r3, r3
 8014f6c:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014f70:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014f74:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014f78:	4313      	orrs	r3, r2
 8014f7a:	b2db      	uxtb	r3, r3
 8014f7c:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_THS, &value, 1) )
 8014f80:	f10d 030f 	add.w	r3, sp, #15
 8014f84:	9801      	ldr	r0, [sp, #4]
 8014f86:	213a      	movs	r1, #58	; 0x3a
 8014f88:	461a      	mov	r2, r3
 8014f8a:	2301      	movs	r3, #1
 8014f8c:	f7fc f988 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8014f90:	4603      	mov	r3, r0
 8014f92:	2b00      	cmp	r3, #0
 8014f94:	d101      	bne.n	8014f9a <LSM303AGR_ACC_W_ClickThreshold+0x6a>
    return MEMS_ERROR;
 8014f96:	2300      	movs	r3, #0
 8014f98:	e000      	b.n	8014f9c <LSM303AGR_ACC_W_ClickThreshold+0x6c>

  return MEMS_SUCCESS;
 8014f9a:	2301      	movs	r3, #1
}
 8014f9c:	4618      	mov	r0, r3
 8014f9e:	b005      	add	sp, #20
 8014fa0:	f85d fb04 	ldr.w	pc, [sp], #4
 8014fa4:	f3af 8000 	nop.w
 8014fa8:	f3af 8000 	nop.w
 8014fac:	f3af 8000 	nop.w

08014fb0 <LSM303AGR_ACC_R_ClickThreshold>:
* Input          : Pointer to u8_t
* Output         : Status of THS
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickThreshold(void *handle, u8_t *value)
{
 8014fb0:	b500      	push	{lr}
 8014fb2:	b083      	sub	sp, #12
 8014fb4:	9001      	str	r0, [sp, #4]
 8014fb6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_THS, (u8_t *)value, 1) )
 8014fb8:	9801      	ldr	r0, [sp, #4]
 8014fba:	213a      	movs	r1, #58	; 0x3a
 8014fbc:	9a00      	ldr	r2, [sp, #0]
 8014fbe:	2301      	movs	r3, #1
 8014fc0:	f7fc f996 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8014fc4:	4603      	mov	r3, r0
 8014fc6:	2b00      	cmp	r3, #0
 8014fc8:	d101      	bne.n	8014fce <LSM303AGR_ACC_R_ClickThreshold+0x1e>
    return MEMS_ERROR;
 8014fca:	2300      	movs	r3, #0
 8014fcc:	e00b      	b.n	8014fe6 <LSM303AGR_ACC_R_ClickThreshold+0x36>

  *value &= LSM303AGR_ACC_THS_MASK; //coerce
 8014fce:	9b00      	ldr	r3, [sp, #0]
 8014fd0:	781b      	ldrb	r3, [r3, #0]
 8014fd2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8014fd6:	b2da      	uxtb	r2, r3
 8014fd8:	9b00      	ldr	r3, [sp, #0]
 8014fda:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_THS_POSITION; //mask
 8014fdc:	9b00      	ldr	r3, [sp, #0]
 8014fde:	781a      	ldrb	r2, [r3, #0]
 8014fe0:	9b00      	ldr	r3, [sp, #0]
 8014fe2:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014fe4:	2301      	movs	r3, #1
}
 8014fe6:	4618      	mov	r0, r3
 8014fe8:	b003      	add	sp, #12
 8014fea:	f85d fb04 	ldr.w	pc, [sp], #4
 8014fee:	bf00      	nop

08014ff0 <LSM303AGR_ACC_W_ClickTimeLimit>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ClickTimeLimit(void *handle, u8_t newValue)
{
 8014ff0:	b500      	push	{lr}
 8014ff2:	b085      	sub	sp, #20
 8014ff4:	9001      	str	r0, [sp, #4]
 8014ff6:	460b      	mov	r3, r1
 8014ff8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_TLI_POSITION; //mask
  newValue &= LSM303AGR_ACC_TLI_MASK; //coerce
 8014ffc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015000:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8015004:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TIME_LIMIT, &value, 1) )
 8015008:	f10d 030f 	add.w	r3, sp, #15
 801500c:	9801      	ldr	r0, [sp, #4]
 801500e:	213b      	movs	r1, #59	; 0x3b
 8015010:	461a      	mov	r2, r3
 8015012:	2301      	movs	r3, #1
 8015014:	f7fc f96c 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8015018:	4603      	mov	r3, r0
 801501a:	2b00      	cmp	r3, #0
 801501c:	d101      	bne.n	8015022 <LSM303AGR_ACC_W_ClickTimeLimit+0x32>
    return MEMS_ERROR;
 801501e:	2300      	movs	r3, #0
 8015020:	e01c      	b.n	801505c <LSM303AGR_ACC_W_ClickTimeLimit+0x6c>

  value &= ~LSM303AGR_ACC_TLI_MASK;
 8015022:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015026:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801502a:	b2db      	uxtb	r3, r3
 801502c:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015030:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015034:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015038:	4313      	orrs	r3, r2
 801503a:	b2db      	uxtb	r3, r3
 801503c:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_TIME_LIMIT, &value, 1) )
 8015040:	f10d 030f 	add.w	r3, sp, #15
 8015044:	9801      	ldr	r0, [sp, #4]
 8015046:	213b      	movs	r1, #59	; 0x3b
 8015048:	461a      	mov	r2, r3
 801504a:	2301      	movs	r3, #1
 801504c:	f7fc f928 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 8015050:	4603      	mov	r3, r0
 8015052:	2b00      	cmp	r3, #0
 8015054:	d101      	bne.n	801505a <LSM303AGR_ACC_W_ClickTimeLimit+0x6a>
    return MEMS_ERROR;
 8015056:	2300      	movs	r3, #0
 8015058:	e000      	b.n	801505c <LSM303AGR_ACC_W_ClickTimeLimit+0x6c>

  return MEMS_SUCCESS;
 801505a:	2301      	movs	r3, #1
}
 801505c:	4618      	mov	r0, r3
 801505e:	b005      	add	sp, #20
 8015060:	f85d fb04 	ldr.w	pc, [sp], #4
 8015064:	f3af 8000 	nop.w
 8015068:	f3af 8000 	nop.w
 801506c:	f3af 8000 	nop.w

08015070 <LSM303AGR_ACC_R_ClickTimeLimit>:
* Input          : Pointer to u8_t
* Output         : Status of TLI
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickTimeLimit(void *handle, u8_t *value)
{
 8015070:	b500      	push	{lr}
 8015072:	b083      	sub	sp, #12
 8015074:	9001      	str	r0, [sp, #4]
 8015076:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TIME_LIMIT, (u8_t *)value, 1) )
 8015078:	9801      	ldr	r0, [sp, #4]
 801507a:	213b      	movs	r1, #59	; 0x3b
 801507c:	9a00      	ldr	r2, [sp, #0]
 801507e:	2301      	movs	r3, #1
 8015080:	f7fc f936 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8015084:	4603      	mov	r3, r0
 8015086:	2b00      	cmp	r3, #0
 8015088:	d101      	bne.n	801508e <LSM303AGR_ACC_R_ClickTimeLimit+0x1e>
    return MEMS_ERROR;
 801508a:	2300      	movs	r3, #0
 801508c:	e00b      	b.n	80150a6 <LSM303AGR_ACC_R_ClickTimeLimit+0x36>

  *value &= LSM303AGR_ACC_TLI_MASK; //coerce
 801508e:	9b00      	ldr	r3, [sp, #0]
 8015090:	781b      	ldrb	r3, [r3, #0]
 8015092:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8015096:	b2da      	uxtb	r2, r3
 8015098:	9b00      	ldr	r3, [sp, #0]
 801509a:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_TLI_POSITION; //mask
 801509c:	9b00      	ldr	r3, [sp, #0]
 801509e:	781a      	ldrb	r2, [r3, #0]
 80150a0:	9b00      	ldr	r3, [sp, #0]
 80150a2:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80150a4:	2301      	movs	r3, #1
}
 80150a6:	4618      	mov	r0, r3
 80150a8:	b003      	add	sp, #12
 80150aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80150ae:	bf00      	nop

080150b0 <LSM303AGR_ACC_W_ClickTimeLatency>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ClickTimeLatency(void *handle, u8_t newValue)
{
 80150b0:	b500      	push	{lr}
 80150b2:	b085      	sub	sp, #20
 80150b4:	9001      	str	r0, [sp, #4]
 80150b6:	460b      	mov	r3, r1
 80150b8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_TLA_POSITION; //mask
  newValue &= LSM303AGR_ACC_TLA_MASK; //coerce

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TIME_LATENCY, &value, 1) )
 80150bc:	f10d 030f 	add.w	r3, sp, #15
 80150c0:	9801      	ldr	r0, [sp, #4]
 80150c2:	213c      	movs	r1, #60	; 0x3c
 80150c4:	461a      	mov	r2, r3
 80150c6:	2301      	movs	r3, #1
 80150c8:	f7fc f912 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80150cc:	4603      	mov	r3, r0
 80150ce:	2b00      	cmp	r3, #0
 80150d0:	d101      	bne.n	80150d6 <LSM303AGR_ACC_W_ClickTimeLatency+0x26>
    return MEMS_ERROR;
 80150d2:	2300      	movs	r3, #0
 80150d4:	e018      	b.n	8015108 <LSM303AGR_ACC_W_ClickTimeLatency+0x58>

  value &= (u8_t)~LSM303AGR_ACC_TLA_MASK;
 80150d6:	2300      	movs	r3, #0
 80150d8:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80150dc:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80150e0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80150e4:	4313      	orrs	r3, r2
 80150e6:	b2db      	uxtb	r3, r3
 80150e8:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_TIME_LATENCY, &value, 1) )
 80150ec:	f10d 030f 	add.w	r3, sp, #15
 80150f0:	9801      	ldr	r0, [sp, #4]
 80150f2:	213c      	movs	r1, #60	; 0x3c
 80150f4:	461a      	mov	r2, r3
 80150f6:	2301      	movs	r3, #1
 80150f8:	f7fc f8d2 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 80150fc:	4603      	mov	r3, r0
 80150fe:	2b00      	cmp	r3, #0
 8015100:	d101      	bne.n	8015106 <LSM303AGR_ACC_W_ClickTimeLatency+0x56>
    return MEMS_ERROR;
 8015102:	2300      	movs	r3, #0
 8015104:	e000      	b.n	8015108 <LSM303AGR_ACC_W_ClickTimeLatency+0x58>

  return MEMS_SUCCESS;
 8015106:	2301      	movs	r3, #1
}
 8015108:	4618      	mov	r0, r3
 801510a:	b005      	add	sp, #20
 801510c:	f85d fb04 	ldr.w	pc, [sp], #4

08015110 <LSM303AGR_ACC_R_ClickTimeLatency>:
* Input          : Pointer to u8_t
* Output         : Status of TLA
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickTimeLatency(void *handle, u8_t *value)
{
 8015110:	b500      	push	{lr}
 8015112:	b083      	sub	sp, #12
 8015114:	9001      	str	r0, [sp, #4]
 8015116:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TIME_LATENCY, (u8_t *)value, 1) )
 8015118:	9801      	ldr	r0, [sp, #4]
 801511a:	213c      	movs	r1, #60	; 0x3c
 801511c:	9a00      	ldr	r2, [sp, #0]
 801511e:	2301      	movs	r3, #1
 8015120:	f7fc f8e6 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8015124:	4603      	mov	r3, r0
 8015126:	2b00      	cmp	r3, #0
 8015128:	d101      	bne.n	801512e <LSM303AGR_ACC_R_ClickTimeLatency+0x1e>
    return MEMS_ERROR;
 801512a:	2300      	movs	r3, #0
 801512c:	e008      	b.n	8015140 <LSM303AGR_ACC_R_ClickTimeLatency+0x30>

  *value &= LSM303AGR_ACC_TLA_MASK; //coerce
 801512e:	9b00      	ldr	r3, [sp, #0]
 8015130:	781a      	ldrb	r2, [r3, #0]
 8015132:	9b00      	ldr	r3, [sp, #0]
 8015134:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_TLA_POSITION; //mask
 8015136:	9b00      	ldr	r3, [sp, #0]
 8015138:	781a      	ldrb	r2, [r3, #0]
 801513a:	9b00      	ldr	r3, [sp, #0]
 801513c:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801513e:	2301      	movs	r3, #1
}
 8015140:	4618      	mov	r0, r3
 8015142:	b003      	add	sp, #12
 8015144:	f85d fb04 	ldr.w	pc, [sp], #4
 8015148:	f3af 8000 	nop.w
 801514c:	f3af 8000 	nop.w

08015150 <LSM303AGR_ACC_W_ClickTimeWindow>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ClickTimeWindow(void *handle, u8_t newValue)
{
 8015150:	b500      	push	{lr}
 8015152:	b085      	sub	sp, #20
 8015154:	9001      	str	r0, [sp, #4]
 8015156:	460b      	mov	r3, r1
 8015158:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_TW_POSITION; //mask
  newValue &= LSM303AGR_ACC_TW_MASK; //coerce

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TIME_WINDOW, &value, 1) )
 801515c:	f10d 030f 	add.w	r3, sp, #15
 8015160:	9801      	ldr	r0, [sp, #4]
 8015162:	213d      	movs	r1, #61	; 0x3d
 8015164:	461a      	mov	r2, r3
 8015166:	2301      	movs	r3, #1
 8015168:	f7fc f8c2 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 801516c:	4603      	mov	r3, r0
 801516e:	2b00      	cmp	r3, #0
 8015170:	d101      	bne.n	8015176 <LSM303AGR_ACC_W_ClickTimeWindow+0x26>
    return MEMS_ERROR;
 8015172:	2300      	movs	r3, #0
 8015174:	e018      	b.n	80151a8 <LSM303AGR_ACC_W_ClickTimeWindow+0x58>

  value &= (u8_t)~LSM303AGR_ACC_TW_MASK;
 8015176:	2300      	movs	r3, #0
 8015178:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 801517c:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015180:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015184:	4313      	orrs	r3, r2
 8015186:	b2db      	uxtb	r3, r3
 8015188:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_TIME_WINDOW, &value, 1) )
 801518c:	f10d 030f 	add.w	r3, sp, #15
 8015190:	9801      	ldr	r0, [sp, #4]
 8015192:	213d      	movs	r1, #61	; 0x3d
 8015194:	461a      	mov	r2, r3
 8015196:	2301      	movs	r3, #1
 8015198:	f7fc f882 	bl	80112a0 <LSM303AGR_ACC_WriteReg>
 801519c:	4603      	mov	r3, r0
 801519e:	2b00      	cmp	r3, #0
 80151a0:	d101      	bne.n	80151a6 <LSM303AGR_ACC_W_ClickTimeWindow+0x56>
    return MEMS_ERROR;
 80151a2:	2300      	movs	r3, #0
 80151a4:	e000      	b.n	80151a8 <LSM303AGR_ACC_W_ClickTimeWindow+0x58>

  return MEMS_SUCCESS;
 80151a6:	2301      	movs	r3, #1
}
 80151a8:	4618      	mov	r0, r3
 80151aa:	b005      	add	sp, #20
 80151ac:	f85d fb04 	ldr.w	pc, [sp], #4

080151b0 <LSM303AGR_ACC_R_ClickTimeWindow>:
* Input          : Pointer to u8_t
* Output         : Status of TW
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickTimeWindow(void *handle, u8_t *value)
{
 80151b0:	b500      	push	{lr}
 80151b2:	b083      	sub	sp, #12
 80151b4:	9001      	str	r0, [sp, #4]
 80151b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TIME_WINDOW, (u8_t *)value, 1) )
 80151b8:	9801      	ldr	r0, [sp, #4]
 80151ba:	213d      	movs	r1, #61	; 0x3d
 80151bc:	9a00      	ldr	r2, [sp, #0]
 80151be:	2301      	movs	r3, #1
 80151c0:	f7fc f896 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 80151c4:	4603      	mov	r3, r0
 80151c6:	2b00      	cmp	r3, #0
 80151c8:	d101      	bne.n	80151ce <LSM303AGR_ACC_R_ClickTimeWindow+0x1e>
    return MEMS_ERROR;
 80151ca:	2300      	movs	r3, #0
 80151cc:	e008      	b.n	80151e0 <LSM303AGR_ACC_R_ClickTimeWindow+0x30>

  *value &= LSM303AGR_ACC_TW_MASK; //coerce
 80151ce:	9b00      	ldr	r3, [sp, #0]
 80151d0:	781a      	ldrb	r2, [r3, #0]
 80151d2:	9b00      	ldr	r3, [sp, #0]
 80151d4:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_TW_POSITION; //mask
 80151d6:	9b00      	ldr	r3, [sp, #0]
 80151d8:	781a      	ldrb	r2, [r3, #0]
 80151da:	9b00      	ldr	r3, [sp, #0]
 80151dc:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80151de:	2301      	movs	r3, #1
}
 80151e0:	4618      	mov	r0, r3
 80151e2:	b003      	add	sp, #12
 80151e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80151e8:	f3af 8000 	nop.w
 80151ec:	f3af 8000 	nop.w

080151f0 <LSM303AGR_ACC_Get_Voltage_ADC>:
* Input          : pointer to [u8_t]
* Output         : Voltage_ADC buffer u8_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_Get_Voltage_ADC(void *handle, u8_t *buff)
{
 80151f0:	b500      	push	{lr}
 80151f2:	b085      	sub	sp, #20
 80151f4:	9001      	str	r0, [sp, #4]
 80151f6:	9100      	str	r1, [sp, #0]
  u8_t i, j, k;
  u8_t numberOfByteForDimension;

  numberOfByteForDimension = 6 / 3;
 80151f8:	2302      	movs	r3, #2
 80151fa:	f88d 300c 	strb.w	r3, [sp, #12]

  k = 0;
 80151fe:	2300      	movs	r3, #0
 8015200:	f88d 300d 	strb.w	r3, [sp, #13]
  for (i = 0; i < 3; i++ )
 8015204:	2300      	movs	r3, #0
 8015206:	f88d 300f 	strb.w	r3, [sp, #15]
 801520a:	e02b      	b.n	8015264 <LSM303AGR_ACC_Get_Voltage_ADC+0x74>
  {
    for (j = 0; j < numberOfByteForDimension; j++ )
 801520c:	2300      	movs	r3, #0
 801520e:	f88d 300e 	strb.w	r3, [sp, #14]
 8015212:	e01c      	b.n	801524e <LSM303AGR_ACC_Get_Voltage_ADC+0x5e>
    {
      if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_OUT_ADC1_L + k, &buff[k], 1 ))
 8015214:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8015218:	3308      	adds	r3, #8
 801521a:	b2da      	uxtb	r2, r3
 801521c:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8015220:	9900      	ldr	r1, [sp, #0]
 8015222:	440b      	add	r3, r1
 8015224:	9801      	ldr	r0, [sp, #4]
 8015226:	4611      	mov	r1, r2
 8015228:	461a      	mov	r2, r3
 801522a:	2301      	movs	r3, #1
 801522c:	f7fc f860 	bl	80112f0 <LSM303AGR_ACC_ReadReg>
 8015230:	4603      	mov	r3, r0
 8015232:	2b00      	cmp	r3, #0
 8015234:	d101      	bne.n	801523a <LSM303AGR_ACC_Get_Voltage_ADC+0x4a>
        return MEMS_ERROR;
 8015236:	2300      	movs	r3, #0
 8015238:	e019      	b.n	801526e <LSM303AGR_ACC_Get_Voltage_ADC+0x7e>
      k++;
 801523a:	f89d 300d 	ldrb.w	r3, [sp, #13]
 801523e:	3301      	adds	r3, #1
 8015240:	f88d 300d 	strb.w	r3, [sp, #13]
  numberOfByteForDimension = 6 / 3;

  k = 0;
  for (i = 0; i < 3; i++ )
  {
    for (j = 0; j < numberOfByteForDimension; j++ )
 8015244:	f89d 300e 	ldrb.w	r3, [sp, #14]
 8015248:	3301      	adds	r3, #1
 801524a:	f88d 300e 	strb.w	r3, [sp, #14]
 801524e:	f89d 200e 	ldrb.w	r2, [sp, #14]
 8015252:	f89d 300c 	ldrb.w	r3, [sp, #12]
 8015256:	429a      	cmp	r2, r3
 8015258:	d3dc      	bcc.n	8015214 <LSM303AGR_ACC_Get_Voltage_ADC+0x24>
  u8_t numberOfByteForDimension;

  numberOfByteForDimension = 6 / 3;

  k = 0;
  for (i = 0; i < 3; i++ )
 801525a:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801525e:	3301      	adds	r3, #1
 8015260:	f88d 300f 	strb.w	r3, [sp, #15]
 8015264:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015268:	2b02      	cmp	r3, #2
 801526a:	d9cf      	bls.n	801520c <LSM303AGR_ACC_Get_Voltage_ADC+0x1c>
        return MEMS_ERROR;
      k++;
    }
  }

  return MEMS_SUCCESS;
 801526c:	2301      	movs	r3, #1
}
 801526e:	4618      	mov	r0, r3
 8015270:	b005      	add	sp, #20
 8015272:	f85d fb04 	ldr.w	pc, [sp], #4
 8015276:	bf00      	nop
 8015278:	f3af 8000 	nop.w
 801527c:	f3af 8000 	nop.w

08015280 <Sensor_IO_SPI_Write>:
#define SPI_1LINE_ENABLE(__HANDLE__) ((__HANDLE__)->spi->CR1 |= SPI_CR1_SPE)
#define SPI_1LINE_DISABLE(__HANDLE__) ((__HANDLE__)->spi->CR1 &= (~SPI_CR1_SPE))
#define SPI_DMA_DISABLE(__HANDLE__) ((__HANDLE__)->spi->CR2 &= (~(SPI_CR2_RXDMAEN|SPI_CR2_TXDMAEN)))
#define SPI_DMA_ENABLE(__HANDLE__) ((__HANDLE__)->spi->CR2 |= (SPI_CR2_RXDMAEN|SPI_CR2_TXDMAEN))

uint8_t Sensor_IO_SPI_Write(SPIDriver *bus, SPIConfig *cfg, uint8_t WriteAddr, uint8_t *pBuffer, uint16_t nBytesToWrite ) {
 8015280:	b500      	push	{lr}
 8015282:	b087      	sub	sp, #28
 8015284:	9003      	str	r0, [sp, #12]
 8015286:	9102      	str	r1, [sp, #8]
 8015288:	9300      	str	r3, [sp, #0]
 801528a:	4613      	mov	r3, r2
 801528c:	f88d 3007 	strb.w	r3, [sp, #7]
  int i;

  if (nBytesToWrite > 1) {                /* Set bit 6 of the address if multiple bytes will be sent. */
 8015290:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 8015294:	2b01      	cmp	r3, #1
 8015296:	d905      	bls.n	80152a4 <Sensor_IO_SPI_Write+0x24>
    WriteAddr |= 0x40;
 8015298:	f89d 3007 	ldrb.w	r3, [sp, #7]
 801529c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80152a0:	f88d 3007 	strb.w	r3, [sp, #7]
  }
  WriteAddr = WriteAddr & (~0x80);        /* Clear the write bit (bit 7)      */
 80152a4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80152a8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80152ac:	f88d 3007 	strb.w	r3, [sp, #7]
  spiAcquireBus(bus);                     /* Acquire ownership of the bus.    */
 80152b0:	9803      	ldr	r0, [sp, #12]
 80152b2:	f7f1 f835 	bl	8006320 <spiAcquireBus>
  spiStart(bus, cfg);                     /* Setup transfer parameters.       */
 80152b6:	9803      	ldr	r0, [sp, #12]
 80152b8:	9902      	ldr	r1, [sp, #8]
 80152ba:	f7f0 ff11 	bl	80060e0 <spiStart>
  SPI_DMA_DISABLE(bus);                   /* Turn off the DMA interrupt since this bus is polled */
 80152be:	9b03      	ldr	r3, [sp, #12]
 80152c0:	69db      	ldr	r3, [r3, #28]
 80152c2:	9a03      	ldr	r2, [sp, #12]
 80152c4:	69d2      	ldr	r2, [r2, #28]
 80152c6:	6852      	ldr	r2, [r2, #4]
 80152c8:	f022 0203 	bic.w	r2, r2, #3
 80152cc:	605a      	str	r2, [r3, #4]
  SPI_1LINE_ENABLE(bus);
 80152ce:	9b03      	ldr	r3, [sp, #12]
 80152d0:	69db      	ldr	r3, [r3, #28]
 80152d2:	9a03      	ldr	r2, [sp, #12]
 80152d4:	69d2      	ldr	r2, [r2, #28]
 80152d6:	6812      	ldr	r2, [r2, #0]
 80152d8:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80152dc:	601a      	str	r2, [r3, #0]
  SPI_1LINE_TX(bus);                      /* Make sure that the MOSI pin is output */
 80152de:	9b03      	ldr	r3, [sp, #12]
 80152e0:	69db      	ldr	r3, [r3, #28]
 80152e2:	9a03      	ldr	r2, [sp, #12]
 80152e4:	69d2      	ldr	r2, [r2, #28]
 80152e6:	6812      	ldr	r2, [r2, #0]
 80152e8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80152ec:	601a      	str	r2, [r3, #0]
  spiSelect(bus);                         /* Slave Select assertion.          */
 80152ee:	9803      	ldr	r0, [sp, #12]
 80152f0:	f7f0 ff1e 	bl	8006130 <spiSelect>
  spiPolledTx(bus, WriteAddr);            /* Send the address byte            */
 80152f4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80152f8:	9803      	ldr	r0, [sp, #12]
 80152fa:	4619      	mov	r1, r3
 80152fc:	f7f5 fbd0 	bl	800aaa0 <spi_lld_polled_tx>
  for(i=0;i<nBytesToWrite;i++) {
 8015300:	2300      	movs	r3, #0
 8015302:	9305      	str	r3, [sp, #20]
 8015304:	e00a      	b.n	801531c <Sensor_IO_SPI_Write+0x9c>
    spiPolledTx(bus, *pBuffer++);         /* Send the address byte            */
 8015306:	9b00      	ldr	r3, [sp, #0]
 8015308:	1c5a      	adds	r2, r3, #1
 801530a:	9200      	str	r2, [sp, #0]
 801530c:	781b      	ldrb	r3, [r3, #0]
 801530e:	9803      	ldr	r0, [sp, #12]
 8015310:	4619      	mov	r1, r3
 8015312:	f7f5 fbc5 	bl	800aaa0 <spi_lld_polled_tx>
  SPI_DMA_DISABLE(bus);                   /* Turn off the DMA interrupt since this bus is polled */
  SPI_1LINE_ENABLE(bus);
  SPI_1LINE_TX(bus);                      /* Make sure that the MOSI pin is output */
  spiSelect(bus);                         /* Slave Select assertion.          */
  spiPolledTx(bus, WriteAddr);            /* Send the address byte            */
  for(i=0;i<nBytesToWrite;i++) {
 8015316:	9b05      	ldr	r3, [sp, #20]
 8015318:	3301      	adds	r3, #1
 801531a:	9305      	str	r3, [sp, #20]
 801531c:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 8015320:	9b05      	ldr	r3, [sp, #20]
 8015322:	429a      	cmp	r2, r3
 8015324:	dcef      	bgt.n	8015306 <Sensor_IO_SPI_Write+0x86>
    spiPolledTx(bus, *pBuffer++);         /* Send the address byte            */
  }
  spiUnselect(bus);                       /* Slave Select de-assertion.       */
 8015326:	9803      	ldr	r0, [sp, #12]
 8015328:	f7f0 ff12 	bl	8006150 <spiUnselect>
  spiReleaseBus(bus);                     /* Ownership release.               */
 801532c:	9803      	ldr	r0, [sp, #12]
 801532e:	f7f1 f807 	bl	8006340 <spiReleaseBus>
  return 0;
 8015332:	2300      	movs	r3, #0
}
 8015334:	4618      	mov	r0, r3
 8015336:	b007      	add	sp, #28
 8015338:	f85d fb04 	ldr.w	pc, [sp], #4
 801533c:	f3af 8000 	nop.w

08015340 <Sensor_IO_SPI_Read>:

uint8_t Sensor_IO_SPI_Read(SPIDriver *bus, SPIConfig *cfg, uint8_t ReadAddr, uint8_t *pBuffer, uint16_t nBytesToRead ) {
 8015340:	b510      	push	{r4, lr}
 8015342:	b086      	sub	sp, #24
 8015344:	9003      	str	r0, [sp, #12]
 8015346:	9102      	str	r1, [sp, #8]
 8015348:	9300      	str	r3, [sp, #0]
 801534a:	4613      	mov	r3, r2
 801534c:	f88d 3007 	strb.w	r3, [sp, #7]
  int i;
  if (nBytesToRead > 1) {                  /* Set bit 6 of the address if multiple bytes will be sent. */
 8015350:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 8015354:	2b01      	cmp	r3, #1
 8015356:	d905      	bls.n	8015364 <Sensor_IO_SPI_Read+0x24>
    ReadAddr |= 0x40;
 8015358:	f89d 3007 	ldrb.w	r3, [sp, #7]
 801535c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8015360:	f88d 3007 	strb.w	r3, [sp, #7]
  }
  ReadAddr = ReadAddr | 0x80;             /* Set the read bit (bit 7)         */
 8015364:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8015368:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801536c:	f88d 3007 	strb.w	r3, [sp, #7]
  spiAcquireBus(bus);                     /* Acquire ownership of the bus.    */
 8015370:	9803      	ldr	r0, [sp, #12]
 8015372:	f7f0 ffd5 	bl	8006320 <spiAcquireBus>
  spiStart(bus, cfg);                     /* Setup transfer parameters.       */
 8015376:	9803      	ldr	r0, [sp, #12]
 8015378:	9902      	ldr	r1, [sp, #8]
 801537a:	f7f0 feb1 	bl	80060e0 <spiStart>
  SPI_DMA_DISABLE(bus);                   /* Turn off the DMA interrupt since this bus is polled */
 801537e:	9b03      	ldr	r3, [sp, #12]
 8015380:	69db      	ldr	r3, [r3, #28]
 8015382:	9a03      	ldr	r2, [sp, #12]
 8015384:	69d2      	ldr	r2, [r2, #28]
 8015386:	6852      	ldr	r2, [r2, #4]
 8015388:	f022 0203 	bic.w	r2, r2, #3
 801538c:	605a      	str	r2, [r3, #4]
  SPI_1LINE_ENABLE(bus);
 801538e:	9b03      	ldr	r3, [sp, #12]
 8015390:	69db      	ldr	r3, [r3, #28]
 8015392:	9a03      	ldr	r2, [sp, #12]
 8015394:	69d2      	ldr	r2, [r2, #28]
 8015396:	6812      	ldr	r2, [r2, #0]
 8015398:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 801539c:	601a      	str	r2, [r3, #0]
  spiSelect(bus);                         /* Slave Select assertion.          */
 801539e:	9803      	ldr	r0, [sp, #12]
 80153a0:	f7f0 fec6 	bl	8006130 <spiSelect>
  spiPolledTx(bus, ReadAddr);             /* Send the address byte            */
 80153a4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80153a8:	9803      	ldr	r0, [sp, #12]
 80153aa:	4619      	mov	r1, r3
 80153ac:	f7f5 fb78 	bl	800aaa0 <spi_lld_polled_tx>
  SPI_1LINE_DISABLE(bus);
 80153b0:	9b03      	ldr	r3, [sp, #12]
 80153b2:	69db      	ldr	r3, [r3, #28]
 80153b4:	9a03      	ldr	r2, [sp, #12]
 80153b6:	69d2      	ldr	r2, [r2, #28]
 80153b8:	6812      	ldr	r2, [r2, #0]
 80153ba:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80153be:	601a      	str	r2, [r3, #0]
  SPI_1LINE_RX(bus);
 80153c0:	9b03      	ldr	r3, [sp, #12]
 80153c2:	69db      	ldr	r3, [r3, #28]
 80153c4:	9a03      	ldr	r2, [sp, #12]
 80153c6:	69d2      	ldr	r2, [r2, #28]
 80153c8:	6812      	ldr	r2, [r2, #0]
 80153ca:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 80153ce:	601a      	str	r2, [r3, #0]
  for(i=0;i<nBytesToRead;i++) {
 80153d0:	2300      	movs	r3, #0
 80153d2:	9305      	str	r3, [sp, #20]
 80153d4:	e00b      	b.n	80153ee <Sensor_IO_SPI_Read+0xae>
    *pBuffer++ = spiPolledRx(bus);     /* Receive data from the wire       */
 80153d6:	9c00      	ldr	r4, [sp, #0]
 80153d8:	1c63      	adds	r3, r4, #1
 80153da:	9300      	str	r3, [sp, #0]
 80153dc:	9803      	ldr	r0, [sp, #12]
 80153de:	f7f5 fb8f 	bl	800ab00 <spi_lld_polled_rx>
 80153e2:	4603      	mov	r3, r0
 80153e4:	b2db      	uxtb	r3, r3
 80153e6:	7023      	strb	r3, [r4, #0]
  SPI_1LINE_ENABLE(bus);
  spiSelect(bus);                         /* Slave Select assertion.          */
  spiPolledTx(bus, ReadAddr);             /* Send the address byte            */
  SPI_1LINE_DISABLE(bus);
  SPI_1LINE_RX(bus);
  for(i=0;i<nBytesToRead;i++) {
 80153e8:	9b05      	ldr	r3, [sp, #20]
 80153ea:	3301      	adds	r3, #1
 80153ec:	9305      	str	r3, [sp, #20]
 80153ee:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 80153f2:	9b05      	ldr	r3, [sp, #20]
 80153f4:	429a      	cmp	r2, r3
 80153f6:	dcee      	bgt.n	80153d6 <Sensor_IO_SPI_Read+0x96>
    *pBuffer++ = spiPolledRx(bus);     /* Receive data from the wire       */
  }
  spiUnselect(bus);                       /* Slave Select de-assertion.       */
 80153f8:	9803      	ldr	r0, [sp, #12]
 80153fa:	f7f0 fea9 	bl	8006150 <spiUnselect>
  SPI_1LINE_TX(bus);
 80153fe:	9b03      	ldr	r3, [sp, #12]
 8015400:	69db      	ldr	r3, [r3, #28]
 8015402:	9a03      	ldr	r2, [sp, #12]
 8015404:	69d2      	ldr	r2, [r2, #28]
 8015406:	6812      	ldr	r2, [r2, #0]
 8015408:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 801540c:	601a      	str	r2, [r3, #0]
  spiReleaseBus(bus);                     /* Ownership release.               */
 801540e:	9803      	ldr	r0, [sp, #12]
 8015410:	f7f0 ff96 	bl	8006340 <spiReleaseBus>
  return 0;
 8015414:	2300      	movs	r3, #0
}
 8015416:	4618      	mov	r0, r3
 8015418:	b006      	add	sp, #24
 801541a:	bd10      	pop	{r4, pc}
 801541c:	f3af 8000 	nop.w

08015420 <__aeabi_ldivmod>:
 8015420:	b973      	cbnz	r3, 8015440 <__aeabi_ldivmod+0x20>
 8015422:	b96a      	cbnz	r2, 8015440 <__aeabi_ldivmod+0x20>
 8015424:	2900      	cmp	r1, #0
 8015426:	bf08      	it	eq
 8015428:	2800      	cmpeq	r0, #0
 801542a:	bfbc      	itt	lt
 801542c:	2000      	movlt	r0, #0
 801542e:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
 8015432:	bfc4      	itt	gt
 8015434:	f06f 4100 	mvngt.w	r1, #2147483648	; 0x80000000
 8015438:	f04f 30ff 	movgt.w	r0, #4294967295
 801543c:	f000 b840 	b.w	80154c0 <__aeabi_idiv0>
 8015440:	b082      	sub	sp, #8
 8015442:	46ec      	mov	ip, sp
 8015444:	e92d 5000 	stmdb	sp!, {ip, lr}
 8015448:	f000 f80a 	bl	8015460 <__gnu_ldivmod_helper>
 801544c:	f8dd e004 	ldr.w	lr, [sp, #4]
 8015450:	b002      	add	sp, #8
 8015452:	bc0c      	pop	{r2, r3}
 8015454:	4770      	bx	lr
 8015456:	bf00      	nop
	...

08015460 <__gnu_ldivmod_helper>:
 8015460:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
 8015464:	9e06      	ldr	r6, [sp, #24]
 8015466:	4614      	mov	r4, r2
 8015468:	461d      	mov	r5, r3
 801546a:	4680      	mov	r8, r0
 801546c:	4689      	mov	r9, r1
 801546e:	f000 f82f 	bl	80154d0 <__divdi3>
 8015472:	fb04 f301 	mul.w	r3, r4, r1
 8015476:	fb00 3305 	mla	r3, r0, r5, r3
 801547a:	fba4 4500 	umull	r4, r5, r4, r0
 801547e:	441d      	add	r5, r3
 8015480:	ebb8 0404 	subs.w	r4, r8, r4
 8015484:	eb69 0505 	sbc.w	r5, r9, r5
 8015488:	e9c6 4500 	strd	r4, r5, [r6]
 801548c:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

08015490 <__gnu_uldivmod_helper>:
 8015490:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
 8015494:	9e06      	ldr	r6, [sp, #24]
 8015496:	4614      	mov	r4, r2
 8015498:	4680      	mov	r8, r0
 801549a:	4689      	mov	r9, r1
 801549c:	461d      	mov	r5, r3
 801549e:	f000 f967 	bl	8015770 <__udivdi3>
 80154a2:	fb00 f505 	mul.w	r5, r0, r5
 80154a6:	fb04 5301 	mla	r3, r4, r1, r5
 80154aa:	fba0 4504 	umull	r4, r5, r0, r4
 80154ae:	441d      	add	r5, r3
 80154b0:	ebb8 0404 	subs.w	r4, r8, r4
 80154b4:	eb69 0505 	sbc.w	r5, r9, r5
 80154b8:	e9c6 4500 	strd	r4, r5, [r6]
 80154bc:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

080154c0 <__aeabi_idiv0>:
 80154c0:	4770      	bx	lr
 80154c2:	bf00      	nop
	...

080154d0 <__divdi3>:
 80154d0:	2900      	cmp	r1, #0
 80154d2:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80154d6:	f2c0 809f 	blt.w	8015618 <__divdi3+0x148>
 80154da:	2400      	movs	r4, #0
 80154dc:	2b00      	cmp	r3, #0
 80154de:	f2c0 8096 	blt.w	801560e <__divdi3+0x13e>
 80154e2:	4615      	mov	r5, r2
 80154e4:	4606      	mov	r6, r0
 80154e6:	460f      	mov	r7, r1
 80154e8:	2b00      	cmp	r3, #0
 80154ea:	d13e      	bne.n	801556a <__divdi3+0x9a>
 80154ec:	428a      	cmp	r2, r1
 80154ee:	d957      	bls.n	80155a0 <__divdi3+0xd0>
 80154f0:	fab2 f382 	clz	r3, r2
 80154f4:	b14b      	cbz	r3, 801550a <__divdi3+0x3a>
 80154f6:	f1c3 0220 	rsb	r2, r3, #32
 80154fa:	fa01 f703 	lsl.w	r7, r1, r3
 80154fe:	fa20 f202 	lsr.w	r2, r0, r2
 8015502:	409d      	lsls	r5, r3
 8015504:	4317      	orrs	r7, r2
 8015506:	fa00 f603 	lsl.w	r6, r0, r3
 801550a:	0c29      	lsrs	r1, r5, #16
 801550c:	fbb7 f2f1 	udiv	r2, r7, r1
 8015510:	0c33      	lsrs	r3, r6, #16
 8015512:	fb01 7c12 	mls	ip, r1, r2, r7
 8015516:	b2a8      	uxth	r0, r5
 8015518:	ea43 470c 	orr.w	r7, r3, ip, lsl #16
 801551c:	fb00 f302 	mul.w	r3, r0, r2
 8015520:	42bb      	cmp	r3, r7
 8015522:	d909      	bls.n	8015538 <__divdi3+0x68>
 8015524:	197f      	adds	r7, r7, r5
 8015526:	f102 3cff 	add.w	ip, r2, #4294967295
 801552a:	f080 8101 	bcs.w	8015730 <__divdi3+0x260>
 801552e:	42bb      	cmp	r3, r7
 8015530:	f240 80fe 	bls.w	8015730 <__divdi3+0x260>
 8015534:	3a02      	subs	r2, #2
 8015536:	442f      	add	r7, r5
 8015538:	1aff      	subs	r7, r7, r3
 801553a:	fbb7 f3f1 	udiv	r3, r7, r1
 801553e:	b2b6      	uxth	r6, r6
 8015540:	fb01 7113 	mls	r1, r1, r3, r7
 8015544:	ea46 4101 	orr.w	r1, r6, r1, lsl #16
 8015548:	fb00 f003 	mul.w	r0, r0, r3
 801554c:	4288      	cmp	r0, r1
 801554e:	d908      	bls.n	8015562 <__divdi3+0x92>
 8015550:	1949      	adds	r1, r1, r5
 8015552:	f103 37ff 	add.w	r7, r3, #4294967295
 8015556:	f080 80ed 	bcs.w	8015734 <__divdi3+0x264>
 801555a:	4288      	cmp	r0, r1
 801555c:	f240 80ea 	bls.w	8015734 <__divdi3+0x264>
 8015560:	3b02      	subs	r3, #2
 8015562:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
 8015566:	2300      	movs	r3, #0
 8015568:	e003      	b.n	8015572 <__divdi3+0xa2>
 801556a:	428b      	cmp	r3, r1
 801556c:	d90a      	bls.n	8015584 <__divdi3+0xb4>
 801556e:	2300      	movs	r3, #0
 8015570:	461a      	mov	r2, r3
 8015572:	4610      	mov	r0, r2
 8015574:	4619      	mov	r1, r3
 8015576:	b114      	cbz	r4, 801557e <__divdi3+0xae>
 8015578:	4240      	negs	r0, r0
 801557a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 801557e:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8015582:	4770      	bx	lr
 8015584:	fab3 f883 	clz	r8, r3
 8015588:	f1b8 0f00 	cmp.w	r8, #0
 801558c:	f040 8084 	bne.w	8015698 <__divdi3+0x1c8>
 8015590:	428b      	cmp	r3, r1
 8015592:	d302      	bcc.n	801559a <__divdi3+0xca>
 8015594:	4282      	cmp	r2, r0
 8015596:	f200 80de 	bhi.w	8015756 <__divdi3+0x286>
 801559a:	2300      	movs	r3, #0
 801559c:	2201      	movs	r2, #1
 801559e:	e7e8      	b.n	8015572 <__divdi3+0xa2>
 80155a0:	b912      	cbnz	r2, 80155a8 <__divdi3+0xd8>
 80155a2:	2301      	movs	r3, #1
 80155a4:	fbb3 f5f2 	udiv	r5, r3, r2
 80155a8:	fab5 f285 	clz	r2, r5
 80155ac:	2a00      	cmp	r2, #0
 80155ae:	d139      	bne.n	8015624 <__divdi3+0x154>
 80155b0:	1b7f      	subs	r7, r7, r5
 80155b2:	0c28      	lsrs	r0, r5, #16
 80155b4:	fa1f fc85 	uxth.w	ip, r5
 80155b8:	2301      	movs	r3, #1
 80155ba:	fbb7 f1f0 	udiv	r1, r7, r0
 80155be:	0c32      	lsrs	r2, r6, #16
 80155c0:	fb00 7711 	mls	r7, r0, r1, r7
 80155c4:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
 80155c8:	fb0c f201 	mul.w	r2, ip, r1
 80155cc:	42ba      	cmp	r2, r7
 80155ce:	d907      	bls.n	80155e0 <__divdi3+0x110>
 80155d0:	197f      	adds	r7, r7, r5
 80155d2:	f101 38ff 	add.w	r8, r1, #4294967295
 80155d6:	d202      	bcs.n	80155de <__divdi3+0x10e>
 80155d8:	42ba      	cmp	r2, r7
 80155da:	f200 80c1 	bhi.w	8015760 <__divdi3+0x290>
 80155de:	4641      	mov	r1, r8
 80155e0:	1abf      	subs	r7, r7, r2
 80155e2:	fbb7 f2f0 	udiv	r2, r7, r0
 80155e6:	b2b6      	uxth	r6, r6
 80155e8:	fb00 7012 	mls	r0, r0, r2, r7
 80155ec:	ea46 4000 	orr.w	r0, r6, r0, lsl #16
 80155f0:	fb0c fc02 	mul.w	ip, ip, r2
 80155f4:	4584      	cmp	ip, r0
 80155f6:	d907      	bls.n	8015608 <__divdi3+0x138>
 80155f8:	1940      	adds	r0, r0, r5
 80155fa:	f102 37ff 	add.w	r7, r2, #4294967295
 80155fe:	d202      	bcs.n	8015606 <__divdi3+0x136>
 8015600:	4584      	cmp	ip, r0
 8015602:	f200 80ab 	bhi.w	801575c <__divdi3+0x28c>
 8015606:	463a      	mov	r2, r7
 8015608:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 801560c:	e7b1      	b.n	8015572 <__divdi3+0xa2>
 801560e:	43e4      	mvns	r4, r4
 8015610:	4252      	negs	r2, r2
 8015612:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8015616:	e764      	b.n	80154e2 <__divdi3+0x12>
 8015618:	4240      	negs	r0, r0
 801561a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 801561e:	f04f 34ff 	mov.w	r4, #4294967295
 8015622:	e75b      	b.n	80154dc <__divdi3+0xc>
 8015624:	4095      	lsls	r5, r2
 8015626:	f1c2 0320 	rsb	r3, r2, #32
 801562a:	fa27 f103 	lsr.w	r1, r7, r3
 801562e:	0c28      	lsrs	r0, r5, #16
 8015630:	fa26 f303 	lsr.w	r3, r6, r3
 8015634:	4097      	lsls	r7, r2
 8015636:	fbb1 f8f0 	udiv	r8, r1, r0
 801563a:	431f      	orrs	r7, r3
 801563c:	0c3b      	lsrs	r3, r7, #16
 801563e:	fb00 1118 	mls	r1, r0, r8, r1
 8015642:	fa1f fc85 	uxth.w	ip, r5
 8015646:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 801564a:	fb0c f308 	mul.w	r3, ip, r8
 801564e:	428b      	cmp	r3, r1
 8015650:	fa06 f602 	lsl.w	r6, r6, r2
 8015654:	d908      	bls.n	8015668 <__divdi3+0x198>
 8015656:	1949      	adds	r1, r1, r5
 8015658:	f108 32ff 	add.w	r2, r8, #4294967295
 801565c:	d279      	bcs.n	8015752 <__divdi3+0x282>
 801565e:	428b      	cmp	r3, r1
 8015660:	d977      	bls.n	8015752 <__divdi3+0x282>
 8015662:	f1a8 0802 	sub.w	r8, r8, #2
 8015666:	4429      	add	r1, r5
 8015668:	1ac9      	subs	r1, r1, r3
 801566a:	fbb1 f3f0 	udiv	r3, r1, r0
 801566e:	b2bf      	uxth	r7, r7
 8015670:	fb00 1113 	mls	r1, r0, r3, r1
 8015674:	ea47 4701 	orr.w	r7, r7, r1, lsl #16
 8015678:	fb0c f203 	mul.w	r2, ip, r3
 801567c:	42ba      	cmp	r2, r7
 801567e:	d907      	bls.n	8015690 <__divdi3+0x1c0>
 8015680:	197f      	adds	r7, r7, r5
 8015682:	f103 31ff 	add.w	r1, r3, #4294967295
 8015686:	d260      	bcs.n	801574a <__divdi3+0x27a>
 8015688:	42ba      	cmp	r2, r7
 801568a:	d95e      	bls.n	801574a <__divdi3+0x27a>
 801568c:	3b02      	subs	r3, #2
 801568e:	442f      	add	r7, r5
 8015690:	1abf      	subs	r7, r7, r2
 8015692:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8015696:	e790      	b.n	80155ba <__divdi3+0xea>
 8015698:	f1c8 0220 	rsb	r2, r8, #32
 801569c:	fa03 fc08 	lsl.w	ip, r3, r8
 80156a0:	fa25 f302 	lsr.w	r3, r5, r2
 80156a4:	ea43 0c0c 	orr.w	ip, r3, ip
 80156a8:	ea4f 491c 	mov.w	r9, ip, lsr #16
 80156ac:	fa21 f302 	lsr.w	r3, r1, r2
 80156b0:	fa01 f708 	lsl.w	r7, r1, r8
 80156b4:	fa20 f202 	lsr.w	r2, r0, r2
 80156b8:	fbb3 f1f9 	udiv	r1, r3, r9
 80156bc:	4317      	orrs	r7, r2
 80156be:	fb09 3311 	mls	r3, r9, r1, r3
 80156c2:	0c3a      	lsrs	r2, r7, #16
 80156c4:	fa1f fb8c 	uxth.w	fp, ip
 80156c8:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
 80156cc:	fb0b fa01 	mul.w	sl, fp, r1
 80156d0:	459a      	cmp	sl, r3
 80156d2:	fa05 f008 	lsl.w	r0, r5, r8
 80156d6:	d908      	bls.n	80156ea <__divdi3+0x21a>
 80156d8:	eb13 030c 	adds.w	r3, r3, ip
 80156dc:	f101 32ff 	add.w	r2, r1, #4294967295
 80156e0:	d235      	bcs.n	801574e <__divdi3+0x27e>
 80156e2:	459a      	cmp	sl, r3
 80156e4:	d933      	bls.n	801574e <__divdi3+0x27e>
 80156e6:	3902      	subs	r1, #2
 80156e8:	4463      	add	r3, ip
 80156ea:	ebca 0303 	rsb	r3, sl, r3
 80156ee:	fbb3 f2f9 	udiv	r2, r3, r9
 80156f2:	fb09 3312 	mls	r3, r9, r2, r3
 80156f6:	b2bf      	uxth	r7, r7
 80156f8:	ea47 4703 	orr.w	r7, r7, r3, lsl #16
 80156fc:	fb0b f902 	mul.w	r9, fp, r2
 8015700:	45b9      	cmp	r9, r7
 8015702:	d908      	bls.n	8015716 <__divdi3+0x246>
 8015704:	eb17 070c 	adds.w	r7, r7, ip
 8015708:	f102 33ff 	add.w	r3, r2, #4294967295
 801570c:	d21b      	bcs.n	8015746 <__divdi3+0x276>
 801570e:	45b9      	cmp	r9, r7
 8015710:	d919      	bls.n	8015746 <__divdi3+0x276>
 8015712:	3a02      	subs	r2, #2
 8015714:	4467      	add	r7, ip
 8015716:	ea42 4501 	orr.w	r5, r2, r1, lsl #16
 801571a:	fba5 0100 	umull	r0, r1, r5, r0
 801571e:	ebc9 0707 	rsb	r7, r9, r7
 8015722:	428f      	cmp	r7, r1
 8015724:	f04f 0300 	mov.w	r3, #0
 8015728:	d30a      	bcc.n	8015740 <__divdi3+0x270>
 801572a:	d005      	beq.n	8015738 <__divdi3+0x268>
 801572c:	462a      	mov	r2, r5
 801572e:	e720      	b.n	8015572 <__divdi3+0xa2>
 8015730:	4662      	mov	r2, ip
 8015732:	e701      	b.n	8015538 <__divdi3+0x68>
 8015734:	463b      	mov	r3, r7
 8015736:	e714      	b.n	8015562 <__divdi3+0x92>
 8015738:	fa06 f608 	lsl.w	r6, r6, r8
 801573c:	4286      	cmp	r6, r0
 801573e:	d2f5      	bcs.n	801572c <__divdi3+0x25c>
 8015740:	1e6a      	subs	r2, r5, #1
 8015742:	2300      	movs	r3, #0
 8015744:	e715      	b.n	8015572 <__divdi3+0xa2>
 8015746:	461a      	mov	r2, r3
 8015748:	e7e5      	b.n	8015716 <__divdi3+0x246>
 801574a:	460b      	mov	r3, r1
 801574c:	e7a0      	b.n	8015690 <__divdi3+0x1c0>
 801574e:	4611      	mov	r1, r2
 8015750:	e7cb      	b.n	80156ea <__divdi3+0x21a>
 8015752:	4690      	mov	r8, r2
 8015754:	e788      	b.n	8015668 <__divdi3+0x198>
 8015756:	4643      	mov	r3, r8
 8015758:	4642      	mov	r2, r8
 801575a:	e70a      	b.n	8015572 <__divdi3+0xa2>
 801575c:	3a02      	subs	r2, #2
 801575e:	e753      	b.n	8015608 <__divdi3+0x138>
 8015760:	3902      	subs	r1, #2
 8015762:	442f      	add	r7, r5
 8015764:	e73c      	b.n	80155e0 <__divdi3+0x110>
 8015766:	bf00      	nop
	...

08015770 <__udivdi3>:
 8015770:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8015774:	4614      	mov	r4, r2
 8015776:	4605      	mov	r5, r0
 8015778:	460e      	mov	r6, r1
 801577a:	2b00      	cmp	r3, #0
 801577c:	d143      	bne.n	8015806 <__udivdi3+0x96>
 801577e:	428a      	cmp	r2, r1
 8015780:	d953      	bls.n	801582a <__udivdi3+0xba>
 8015782:	fab2 f782 	clz	r7, r2
 8015786:	b157      	cbz	r7, 801579e <__udivdi3+0x2e>
 8015788:	f1c7 0620 	rsb	r6, r7, #32
 801578c:	fa20 f606 	lsr.w	r6, r0, r6
 8015790:	fa01 f307 	lsl.w	r3, r1, r7
 8015794:	fa02 f407 	lsl.w	r4, r2, r7
 8015798:	431e      	orrs	r6, r3
 801579a:	fa00 f507 	lsl.w	r5, r0, r7
 801579e:	0c21      	lsrs	r1, r4, #16
 80157a0:	fbb6 f2f1 	udiv	r2, r6, r1
 80157a4:	0c2b      	lsrs	r3, r5, #16
 80157a6:	fb01 6712 	mls	r7, r1, r2, r6
 80157aa:	b2a0      	uxth	r0, r4
 80157ac:	ea43 4607 	orr.w	r6, r3, r7, lsl #16
 80157b0:	fb00 f302 	mul.w	r3, r0, r2
 80157b4:	42b3      	cmp	r3, r6
 80157b6:	d909      	bls.n	80157cc <__udivdi3+0x5c>
 80157b8:	1936      	adds	r6, r6, r4
 80157ba:	f102 37ff 	add.w	r7, r2, #4294967295
 80157be:	f080 80f6 	bcs.w	80159ae <__udivdi3+0x23e>
 80157c2:	42b3      	cmp	r3, r6
 80157c4:	f240 80f3 	bls.w	80159ae <__udivdi3+0x23e>
 80157c8:	3a02      	subs	r2, #2
 80157ca:	4426      	add	r6, r4
 80157cc:	1af6      	subs	r6, r6, r3
 80157ce:	fbb6 f3f1 	udiv	r3, r6, r1
 80157d2:	b2ad      	uxth	r5, r5
 80157d4:	fb01 6113 	mls	r1, r1, r3, r6
 80157d8:	ea45 4101 	orr.w	r1, r5, r1, lsl #16
 80157dc:	fb00 f003 	mul.w	r0, r0, r3
 80157e0:	4288      	cmp	r0, r1
 80157e2:	d908      	bls.n	80157f6 <__udivdi3+0x86>
 80157e4:	1909      	adds	r1, r1, r4
 80157e6:	f103 36ff 	add.w	r6, r3, #4294967295
 80157ea:	f080 80e2 	bcs.w	80159b2 <__udivdi3+0x242>
 80157ee:	4288      	cmp	r0, r1
 80157f0:	f240 80df 	bls.w	80159b2 <__udivdi3+0x242>
 80157f4:	3b02      	subs	r3, #2
 80157f6:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
 80157fa:	2300      	movs	r3, #0
 80157fc:	4610      	mov	r0, r2
 80157fe:	4619      	mov	r1, r3
 8015800:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8015804:	4770      	bx	lr
 8015806:	428b      	cmp	r3, r1
 8015808:	d84a      	bhi.n	80158a0 <__udivdi3+0x130>
 801580a:	fab3 f683 	clz	r6, r3
 801580e:	2e00      	cmp	r6, #0
 8015810:	d14d      	bne.n	80158ae <__udivdi3+0x13e>
 8015812:	428b      	cmp	r3, r1
 8015814:	d302      	bcc.n	801581c <__udivdi3+0xac>
 8015816:	4282      	cmp	r2, r0
 8015818:	f200 80d6 	bhi.w	80159c8 <__udivdi3+0x258>
 801581c:	2300      	movs	r3, #0
 801581e:	2201      	movs	r2, #1
 8015820:	4610      	mov	r0, r2
 8015822:	4619      	mov	r1, r3
 8015824:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8015828:	4770      	bx	lr
 801582a:	b912      	cbnz	r2, 8015832 <__udivdi3+0xc2>
 801582c:	2401      	movs	r4, #1
 801582e:	fbb4 f4f2 	udiv	r4, r4, r2
 8015832:	fab4 f284 	clz	r2, r4
 8015836:	2a00      	cmp	r2, #0
 8015838:	d17c      	bne.n	8015934 <__udivdi3+0x1c4>
 801583a:	1b09      	subs	r1, r1, r4
 801583c:	0c26      	lsrs	r6, r4, #16
 801583e:	b2a7      	uxth	r7, r4
 8015840:	2301      	movs	r3, #1
 8015842:	fbb1 f0f6 	udiv	r0, r1, r6
 8015846:	0c2a      	lsrs	r2, r5, #16
 8015848:	fb06 1110 	mls	r1, r6, r0, r1
 801584c:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
 8015850:	fb07 f200 	mul.w	r2, r7, r0
 8015854:	428a      	cmp	r2, r1
 8015856:	d907      	bls.n	8015868 <__udivdi3+0xf8>
 8015858:	1909      	adds	r1, r1, r4
 801585a:	f100 3cff 	add.w	ip, r0, #4294967295
 801585e:	d202      	bcs.n	8015866 <__udivdi3+0xf6>
 8015860:	428a      	cmp	r2, r1
 8015862:	f200 80c3 	bhi.w	80159ec <__udivdi3+0x27c>
 8015866:	4660      	mov	r0, ip
 8015868:	1a89      	subs	r1, r1, r2
 801586a:	fbb1 f2f6 	udiv	r2, r1, r6
 801586e:	b2ad      	uxth	r5, r5
 8015870:	fb06 1112 	mls	r1, r6, r2, r1
 8015874:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
 8015878:	fb07 f702 	mul.w	r7, r7, r2
 801587c:	42af      	cmp	r7, r5
 801587e:	d908      	bls.n	8015892 <__udivdi3+0x122>
 8015880:	192c      	adds	r4, r5, r4
 8015882:	f102 31ff 	add.w	r1, r2, #4294967295
 8015886:	f080 8096 	bcs.w	80159b6 <__udivdi3+0x246>
 801588a:	42a7      	cmp	r7, r4
 801588c:	f240 8093 	bls.w	80159b6 <__udivdi3+0x246>
 8015890:	3a02      	subs	r2, #2
 8015892:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8015896:	4610      	mov	r0, r2
 8015898:	4619      	mov	r1, r3
 801589a:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 801589e:	4770      	bx	lr
 80158a0:	2300      	movs	r3, #0
 80158a2:	461a      	mov	r2, r3
 80158a4:	4610      	mov	r0, r2
 80158a6:	4619      	mov	r1, r3
 80158a8:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80158ac:	4770      	bx	lr
 80158ae:	f1c6 0520 	rsb	r5, r6, #32
 80158b2:	fa22 f405 	lsr.w	r4, r2, r5
 80158b6:	40b3      	lsls	r3, r6
 80158b8:	431c      	orrs	r4, r3
 80158ba:	ea4f 4814 	mov.w	r8, r4, lsr #16
 80158be:	fa21 f305 	lsr.w	r3, r1, r5
 80158c2:	fa01 f706 	lsl.w	r7, r1, r6
 80158c6:	fa20 f505 	lsr.w	r5, r0, r5
 80158ca:	fbb3 fcf8 	udiv	ip, r3, r8
 80158ce:	432f      	orrs	r7, r5
 80158d0:	fb08 331c 	mls	r3, r8, ip, r3
 80158d4:	0c3d      	lsrs	r5, r7, #16
 80158d6:	fa1f fa84 	uxth.w	sl, r4
 80158da:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
 80158de:	fb0a f90c 	mul.w	r9, sl, ip
 80158e2:	4599      	cmp	r9, r3
 80158e4:	fa02 fb06 	lsl.w	fp, r2, r6
 80158e8:	d904      	bls.n	80158f4 <__udivdi3+0x184>
 80158ea:	191b      	adds	r3, r3, r4
 80158ec:	f10c 32ff 	add.w	r2, ip, #4294967295
 80158f0:	d36d      	bcc.n	80159ce <__udivdi3+0x25e>
 80158f2:	4694      	mov	ip, r2
 80158f4:	ebc9 0303 	rsb	r3, r9, r3
 80158f8:	fbb3 f5f8 	udiv	r5, r3, r8
 80158fc:	fb08 3315 	mls	r3, r8, r5, r3
 8015900:	b2bf      	uxth	r7, r7
 8015902:	ea47 4703 	orr.w	r7, r7, r3, lsl #16
 8015906:	fb0a f805 	mul.w	r8, sl, r5
 801590a:	45b8      	cmp	r8, r7
 801590c:	d904      	bls.n	8015918 <__udivdi3+0x1a8>
 801590e:	193f      	adds	r7, r7, r4
 8015910:	f105 33ff 	add.w	r3, r5, #4294967295
 8015914:	d361      	bcc.n	80159da <__udivdi3+0x26a>
 8015916:	461d      	mov	r5, r3
 8015918:	ea45 4c0c 	orr.w	ip, r5, ip, lsl #16
 801591c:	fbac 230b 	umull	r2, r3, ip, fp
 8015920:	ebc8 0707 	rsb	r7, r8, r7
 8015924:	429f      	cmp	r7, r3
 8015926:	f04f 0500 	mov.w	r5, #0
 801592a:	d349      	bcc.n	80159c0 <__udivdi3+0x250>
 801592c:	d045      	beq.n	80159ba <__udivdi3+0x24a>
 801592e:	4662      	mov	r2, ip
 8015930:	462b      	mov	r3, r5
 8015932:	e763      	b.n	80157fc <__udivdi3+0x8c>
 8015934:	4094      	lsls	r4, r2
 8015936:	f1c2 0320 	rsb	r3, r2, #32
 801593a:	fa21 fc03 	lsr.w	ip, r1, r3
 801593e:	0c26      	lsrs	r6, r4, #16
 8015940:	fa20 f303 	lsr.w	r3, r0, r3
 8015944:	fa01 f502 	lsl.w	r5, r1, r2
 8015948:	fbbc f8f6 	udiv	r8, ip, r6
 801594c:	ea43 0105 	orr.w	r1, r3, r5
 8015950:	0c0b      	lsrs	r3, r1, #16
 8015952:	fb06 cc18 	mls	ip, r6, r8, ip
 8015956:	b2a7      	uxth	r7, r4
 8015958:	ea43 4c0c 	orr.w	ip, r3, ip, lsl #16
 801595c:	fb07 f308 	mul.w	r3, r7, r8
 8015960:	4563      	cmp	r3, ip
 8015962:	fa00 f502 	lsl.w	r5, r0, r2
 8015966:	d909      	bls.n	801597c <__udivdi3+0x20c>
 8015968:	eb1c 0c04 	adds.w	ip, ip, r4
 801596c:	f108 32ff 	add.w	r2, r8, #4294967295
 8015970:	d23a      	bcs.n	80159e8 <__udivdi3+0x278>
 8015972:	4563      	cmp	r3, ip
 8015974:	d938      	bls.n	80159e8 <__udivdi3+0x278>
 8015976:	f1a8 0802 	sub.w	r8, r8, #2
 801597a:	44a4      	add	ip, r4
 801597c:	ebc3 0c0c 	rsb	ip, r3, ip
 8015980:	fbbc f3f6 	udiv	r3, ip, r6
 8015984:	b289      	uxth	r1, r1
 8015986:	fb06 cc13 	mls	ip, r6, r3, ip
 801598a:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
 801598e:	fb07 f203 	mul.w	r2, r7, r3
 8015992:	428a      	cmp	r2, r1
 8015994:	d907      	bls.n	80159a6 <__udivdi3+0x236>
 8015996:	1909      	adds	r1, r1, r4
 8015998:	f103 30ff 	add.w	r0, r3, #4294967295
 801599c:	d222      	bcs.n	80159e4 <__udivdi3+0x274>
 801599e:	428a      	cmp	r2, r1
 80159a0:	d920      	bls.n	80159e4 <__udivdi3+0x274>
 80159a2:	3b02      	subs	r3, #2
 80159a4:	4421      	add	r1, r4
 80159a6:	1a89      	subs	r1, r1, r2
 80159a8:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 80159ac:	e749      	b.n	8015842 <__udivdi3+0xd2>
 80159ae:	463a      	mov	r2, r7
 80159b0:	e70c      	b.n	80157cc <__udivdi3+0x5c>
 80159b2:	4633      	mov	r3, r6
 80159b4:	e71f      	b.n	80157f6 <__udivdi3+0x86>
 80159b6:	460a      	mov	r2, r1
 80159b8:	e76b      	b.n	8015892 <__udivdi3+0x122>
 80159ba:	40b0      	lsls	r0, r6
 80159bc:	4290      	cmp	r0, r2
 80159be:	d2b6      	bcs.n	801592e <__udivdi3+0x1be>
 80159c0:	f10c 32ff 	add.w	r2, ip, #4294967295
 80159c4:	2300      	movs	r3, #0
 80159c6:	e719      	b.n	80157fc <__udivdi3+0x8c>
 80159c8:	4633      	mov	r3, r6
 80159ca:	4632      	mov	r2, r6
 80159cc:	e716      	b.n	80157fc <__udivdi3+0x8c>
 80159ce:	4599      	cmp	r9, r3
 80159d0:	d98f      	bls.n	80158f2 <__udivdi3+0x182>
 80159d2:	f1ac 0c02 	sub.w	ip, ip, #2
 80159d6:	4423      	add	r3, r4
 80159d8:	e78c      	b.n	80158f4 <__udivdi3+0x184>
 80159da:	45b8      	cmp	r8, r7
 80159dc:	d99b      	bls.n	8015916 <__udivdi3+0x1a6>
 80159de:	3d02      	subs	r5, #2
 80159e0:	4427      	add	r7, r4
 80159e2:	e799      	b.n	8015918 <__udivdi3+0x1a8>
 80159e4:	4603      	mov	r3, r0
 80159e6:	e7de      	b.n	80159a6 <__udivdi3+0x236>
 80159e8:	4690      	mov	r8, r2
 80159ea:	e7c7      	b.n	801597c <__udivdi3+0x20c>
 80159ec:	3802      	subs	r0, #2
 80159ee:	4421      	add	r1, r4
 80159f0:	e73a      	b.n	8015868 <__udivdi3+0xf8>
 80159f2:	bf00      	nop
	...

08015a00 <memcpy>:
 8015a00:	4684      	mov	ip, r0
 8015a02:	ea41 0300 	orr.w	r3, r1, r0
 8015a06:	f013 0303 	ands.w	r3, r3, #3
 8015a0a:	d16d      	bne.n	8015ae8 <memcpy+0xe8>
 8015a0c:	3a40      	subs	r2, #64	; 0x40
 8015a0e:	d341      	bcc.n	8015a94 <memcpy+0x94>
 8015a10:	f851 3b04 	ldr.w	r3, [r1], #4
 8015a14:	f840 3b04 	str.w	r3, [r0], #4
 8015a18:	f851 3b04 	ldr.w	r3, [r1], #4
 8015a1c:	f840 3b04 	str.w	r3, [r0], #4
 8015a20:	f851 3b04 	ldr.w	r3, [r1], #4
 8015a24:	f840 3b04 	str.w	r3, [r0], #4
 8015a28:	f851 3b04 	ldr.w	r3, [r1], #4
 8015a2c:	f840 3b04 	str.w	r3, [r0], #4
 8015a30:	f851 3b04 	ldr.w	r3, [r1], #4
 8015a34:	f840 3b04 	str.w	r3, [r0], #4
 8015a38:	f851 3b04 	ldr.w	r3, [r1], #4
 8015a3c:	f840 3b04 	str.w	r3, [r0], #4
 8015a40:	f851 3b04 	ldr.w	r3, [r1], #4
 8015a44:	f840 3b04 	str.w	r3, [r0], #4
 8015a48:	f851 3b04 	ldr.w	r3, [r1], #4
 8015a4c:	f840 3b04 	str.w	r3, [r0], #4
 8015a50:	f851 3b04 	ldr.w	r3, [r1], #4
 8015a54:	f840 3b04 	str.w	r3, [r0], #4
 8015a58:	f851 3b04 	ldr.w	r3, [r1], #4
 8015a5c:	f840 3b04 	str.w	r3, [r0], #4
 8015a60:	f851 3b04 	ldr.w	r3, [r1], #4
 8015a64:	f840 3b04 	str.w	r3, [r0], #4
 8015a68:	f851 3b04 	ldr.w	r3, [r1], #4
 8015a6c:	f840 3b04 	str.w	r3, [r0], #4
 8015a70:	f851 3b04 	ldr.w	r3, [r1], #4
 8015a74:	f840 3b04 	str.w	r3, [r0], #4
 8015a78:	f851 3b04 	ldr.w	r3, [r1], #4
 8015a7c:	f840 3b04 	str.w	r3, [r0], #4
 8015a80:	f851 3b04 	ldr.w	r3, [r1], #4
 8015a84:	f840 3b04 	str.w	r3, [r0], #4
 8015a88:	f851 3b04 	ldr.w	r3, [r1], #4
 8015a8c:	f840 3b04 	str.w	r3, [r0], #4
 8015a90:	3a40      	subs	r2, #64	; 0x40
 8015a92:	d2bd      	bcs.n	8015a10 <memcpy+0x10>
 8015a94:	3230      	adds	r2, #48	; 0x30
 8015a96:	d311      	bcc.n	8015abc <memcpy+0xbc>
 8015a98:	f851 3b04 	ldr.w	r3, [r1], #4
 8015a9c:	f840 3b04 	str.w	r3, [r0], #4
 8015aa0:	f851 3b04 	ldr.w	r3, [r1], #4
 8015aa4:	f840 3b04 	str.w	r3, [r0], #4
 8015aa8:	f851 3b04 	ldr.w	r3, [r1], #4
 8015aac:	f840 3b04 	str.w	r3, [r0], #4
 8015ab0:	f851 3b04 	ldr.w	r3, [r1], #4
 8015ab4:	f840 3b04 	str.w	r3, [r0], #4
 8015ab8:	3a10      	subs	r2, #16
 8015aba:	d2ed      	bcs.n	8015a98 <memcpy+0x98>
 8015abc:	320c      	adds	r2, #12
 8015abe:	d305      	bcc.n	8015acc <memcpy+0xcc>
 8015ac0:	f851 3b04 	ldr.w	r3, [r1], #4
 8015ac4:	f840 3b04 	str.w	r3, [r0], #4
 8015ac8:	3a04      	subs	r2, #4
 8015aca:	d2f9      	bcs.n	8015ac0 <memcpy+0xc0>
 8015acc:	3204      	adds	r2, #4
 8015ace:	d008      	beq.n	8015ae2 <memcpy+0xe2>
 8015ad0:	07d2      	lsls	r2, r2, #31
 8015ad2:	bf1c      	itt	ne
 8015ad4:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8015ad8:	f800 3b01 	strbne.w	r3, [r0], #1
 8015adc:	d301      	bcc.n	8015ae2 <memcpy+0xe2>
 8015ade:	880b      	ldrh	r3, [r1, #0]
 8015ae0:	8003      	strh	r3, [r0, #0]
 8015ae2:	4660      	mov	r0, ip
 8015ae4:	4770      	bx	lr
 8015ae6:	bf00      	nop
 8015ae8:	2a08      	cmp	r2, #8
 8015aea:	d313      	bcc.n	8015b14 <memcpy+0x114>
 8015aec:	078b      	lsls	r3, r1, #30
 8015aee:	d08d      	beq.n	8015a0c <memcpy+0xc>
 8015af0:	f010 0303 	ands.w	r3, r0, #3
 8015af4:	d08a      	beq.n	8015a0c <memcpy+0xc>
 8015af6:	f1c3 0304 	rsb	r3, r3, #4
 8015afa:	1ad2      	subs	r2, r2, r3
 8015afc:	07db      	lsls	r3, r3, #31
 8015afe:	bf1c      	itt	ne
 8015b00:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8015b04:	f800 3b01 	strbne.w	r3, [r0], #1
 8015b08:	d380      	bcc.n	8015a0c <memcpy+0xc>
 8015b0a:	f831 3b02 	ldrh.w	r3, [r1], #2
 8015b0e:	f820 3b02 	strh.w	r3, [r0], #2
 8015b12:	e77b      	b.n	8015a0c <memcpy+0xc>
 8015b14:	3a04      	subs	r2, #4
 8015b16:	d3d9      	bcc.n	8015acc <memcpy+0xcc>
 8015b18:	3a01      	subs	r2, #1
 8015b1a:	f811 3b01 	ldrb.w	r3, [r1], #1
 8015b1e:	f800 3b01 	strb.w	r3, [r0], #1
 8015b22:	d2f9      	bcs.n	8015b18 <memcpy+0x118>
 8015b24:	780b      	ldrb	r3, [r1, #0]
 8015b26:	7003      	strb	r3, [r0, #0]
 8015b28:	784b      	ldrb	r3, [r1, #1]
 8015b2a:	7043      	strb	r3, [r0, #1]
 8015b2c:	788b      	ldrb	r3, [r1, #2]
 8015b2e:	7083      	strb	r3, [r0, #2]
 8015b30:	4660      	mov	r0, ip
 8015b32:	4770      	bx	lr
	...

08015b40 <strcmp>:
 8015b40:	ea40 0c01 	orr.w	ip, r0, r1
 8015b44:	f01c 0f07 	tst.w	ip, #7
 8015b48:	d123      	bne.n	8015b92 <strcmp+0x52>
 8015b4a:	f1bd 0d10 	subs.w	sp, sp, #16
 8015b4e:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8015b52:	e9cd 6700 	strd	r6, r7, [sp]
 8015b56:	f06f 0600 	mvn.w	r6, #0
 8015b5a:	f04f 0700 	mov.w	r7, #0
 8015b5e:	bf00      	nop
 8015b60:	e8f0 2302 	ldrd	r2, r3, [r0], #8
 8015b64:	e8f1 4502 	ldrd	r4, r5, [r1], #8
 8015b68:	42a2      	cmp	r2, r4
 8015b6a:	fa82 fc46 	uadd8	ip, r2, r6
 8015b6e:	faa7 fc86 	sel	ip, r7, r6
 8015b72:	bf08      	it	eq
 8015b74:	f1bc 0f00 	cmpeq.w	ip, #0
 8015b78:	f040 80d7 	bne.w	8015d2a <strcmp+0x1ea>
 8015b7c:	42ab      	cmp	r3, r5
 8015b7e:	fa83 fc46 	uadd8	ip, r3, r6
 8015b82:	faa7 fc86 	sel	ip, r7, r6
 8015b86:	bf08      	it	eq
 8015b88:	f1bc 0f00 	cmpeq.w	ip, #0
 8015b8c:	f040 80ca 	bne.w	8015d24 <strcmp+0x1e4>
 8015b90:	e7e6      	b.n	8015b60 <strcmp+0x20>
 8015b92:	f010 0c03 	ands.w	ip, r0, #3
 8015b96:	d021      	beq.n	8015bdc <strcmp+0x9c>
 8015b98:	f020 0003 	bic.w	r0, r0, #3
 8015b9c:	f850 2b04 	ldr.w	r2, [r0], #4
 8015ba0:	ea5f 7ccc 	movs.w	ip, ip, lsl #31
 8015ba4:	d008      	beq.n	8015bb8 <strcmp+0x78>
 8015ba6:	d20f      	bcs.n	8015bc8 <strcmp+0x88>
 8015ba8:	f811 cb01 	ldrb.w	ip, [r1], #1
 8015bac:	fa5f f392 	uxtb.w	r3, r2, ror #8
 8015bb0:	ebb3 0c0c 	subs.w	ip, r3, ip
 8015bb4:	d110      	bne.n	8015bd8 <strcmp+0x98>
 8015bb6:	b17b      	cbz	r3, 8015bd8 <strcmp+0x98>
 8015bb8:	f811 cb01 	ldrb.w	ip, [r1], #1
 8015bbc:	fa5f f3a2 	uxtb.w	r3, r2, ror #16
 8015bc0:	ebb3 0c0c 	subs.w	ip, r3, ip
 8015bc4:	d108      	bne.n	8015bd8 <strcmp+0x98>
 8015bc6:	b13b      	cbz	r3, 8015bd8 <strcmp+0x98>
 8015bc8:	f811 cb01 	ldrb.w	ip, [r1], #1
 8015bcc:	fa5f f3b2 	uxtb.w	r3, r2, ror #24
 8015bd0:	ebb3 0c0c 	subs.w	ip, r3, ip
 8015bd4:	d100      	bne.n	8015bd8 <strcmp+0x98>
 8015bd6:	b90b      	cbnz	r3, 8015bdc <strcmp+0x9c>
 8015bd8:	4660      	mov	r0, ip
 8015bda:	4770      	bx	lr
 8015bdc:	f1bd 0d10 	subs.w	sp, sp, #16
 8015be0:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8015be4:	e9cd 6700 	strd	r6, r7, [sp]
 8015be8:	f06f 0600 	mvn.w	r6, #0
 8015bec:	f04f 0700 	mov.w	r7, #0
 8015bf0:	f011 0c03 	ands.w	ip, r1, #3
 8015bf4:	d12d      	bne.n	8015c52 <strcmp+0x112>
 8015bf6:	f010 0f04 	tst.w	r0, #4
 8015bfa:	d00d      	beq.n	8015c18 <strcmp+0xd8>
 8015bfc:	f850 2b04 	ldr.w	r2, [r0], #4
 8015c00:	f851 4b04 	ldr.w	r4, [r1], #4
 8015c04:	42a2      	cmp	r2, r4
 8015c06:	fa82 fc46 	uadd8	ip, r2, r6
 8015c0a:	faa7 fc86 	sel	ip, r7, r6
 8015c0e:	bf08      	it	eq
 8015c10:	f1bc 0f00 	cmpeq.w	ip, #0
 8015c14:	f040 8089 	bne.w	8015d2a <strcmp+0x1ea>
 8015c18:	f011 0f04 	tst.w	r1, #4
 8015c1c:	d09f      	beq.n	8015b5e <strcmp+0x1e>
 8015c1e:	f851 5b04 	ldr.w	r5, [r1], #4
 8015c22:	bf00      	nop
 8015c24:	e8f0 2302 	ldrd	r2, r3, [r0], #8
 8015c28:	42aa      	cmp	r2, r5
 8015c2a:	fa82 fc46 	uadd8	ip, r2, r6
 8015c2e:	faa7 fc86 	sel	ip, r7, r6
 8015c32:	bf08      	it	eq
 8015c34:	f1bc 0f00 	cmpeq.w	ip, #0
 8015c38:	d171      	bne.n	8015d1e <strcmp+0x1de>
 8015c3a:	e8f1 4502 	ldrd	r4, r5, [r1], #8
 8015c3e:	42a3      	cmp	r3, r4
 8015c40:	fa83 fc46 	uadd8	ip, r3, r6
 8015c44:	faa7 fc86 	sel	ip, r7, r6
 8015c48:	bf08      	it	eq
 8015c4a:	f1bc 0f00 	cmpeq.w	ip, #0
 8015c4e:	d163      	bne.n	8015d18 <strcmp+0x1d8>
 8015c50:	e7e8      	b.n	8015c24 <strcmp+0xe4>
 8015c52:	f021 0103 	bic.w	r1, r1, #3
 8015c56:	f1bc 0f02 	cmp.w	ip, #2
 8015c5a:	d01e      	beq.n	8015c9a <strcmp+0x15a>
 8015c5c:	da3b      	bge.n	8015cd6 <strcmp+0x196>
 8015c5e:	f851 5b04 	ldr.w	r5, [r1], #4
 8015c62:	bf00      	nop
 8015c64:	f850 3b04 	ldr.w	r3, [r0], #4
 8015c68:	ea4f 2515 	mov.w	r5, r5, lsr #8
 8015c6c:	fa83 fc46 	uadd8	ip, r3, r6
 8015c70:	faa7 fc86 	sel	ip, r7, r6
 8015c74:	ebb7 2f0c 	cmp.w	r7, ip, lsl #8
 8015c78:	ea03 2216 	and.w	r2, r3, r6, lsr #8
 8015c7c:	bf08      	it	eq
 8015c7e:	42aa      	cmpeq	r2, r5
 8015c80:	d14d      	bne.n	8015d1e <strcmp+0x1de>
 8015c82:	f851 5b04 	ldr.w	r5, [r1], #4
 8015c86:	f1bc 0f00 	cmp.w	ip, #0
 8015c8a:	ea82 0303 	eor.w	r3, r2, r3
 8015c8e:	ea4f 6205 	mov.w	r2, r5, lsl #24
 8015c92:	bf08      	it	eq
 8015c94:	4293      	cmpeq	r3, r2
 8015c96:	d13c      	bne.n	8015d12 <strcmp+0x1d2>
 8015c98:	e7e4      	b.n	8015c64 <strcmp+0x124>
 8015c9a:	f851 5b04 	ldr.w	r5, [r1], #4
 8015c9e:	bf00      	nop
 8015ca0:	f850 3b04 	ldr.w	r3, [r0], #4
 8015ca4:	ea4f 4515 	mov.w	r5, r5, lsr #16
 8015ca8:	fa83 fc46 	uadd8	ip, r3, r6
 8015cac:	faa7 fc86 	sel	ip, r7, r6
 8015cb0:	ebb7 4f0c 	cmp.w	r7, ip, lsl #16
 8015cb4:	ea03 4216 	and.w	r2, r3, r6, lsr #16
 8015cb8:	bf08      	it	eq
 8015cba:	42aa      	cmpeq	r2, r5
 8015cbc:	d12f      	bne.n	8015d1e <strcmp+0x1de>
 8015cbe:	f851 5b04 	ldr.w	r5, [r1], #4
 8015cc2:	f1bc 0f00 	cmp.w	ip, #0
 8015cc6:	ea82 0303 	eor.w	r3, r2, r3
 8015cca:	ea4f 4205 	mov.w	r2, r5, lsl #16
 8015cce:	bf08      	it	eq
 8015cd0:	4293      	cmpeq	r3, r2
 8015cd2:	d11e      	bne.n	8015d12 <strcmp+0x1d2>
 8015cd4:	e7e4      	b.n	8015ca0 <strcmp+0x160>
 8015cd6:	f851 5b04 	ldr.w	r5, [r1], #4
 8015cda:	bf00      	nop
 8015cdc:	f850 3b04 	ldr.w	r3, [r0], #4
 8015ce0:	ea4f 6515 	mov.w	r5, r5, lsr #24
 8015ce4:	fa83 fc46 	uadd8	ip, r3, r6
 8015ce8:	faa7 fc86 	sel	ip, r7, r6
 8015cec:	ebb7 6f0c 	cmp.w	r7, ip, lsl #24
 8015cf0:	ea03 6216 	and.w	r2, r3, r6, lsr #24
 8015cf4:	bf08      	it	eq
 8015cf6:	42aa      	cmpeq	r2, r5
 8015cf8:	d111      	bne.n	8015d1e <strcmp+0x1de>
 8015cfa:	f851 5b04 	ldr.w	r5, [r1], #4
 8015cfe:	f1bc 0f00 	cmp.w	ip, #0
 8015d02:	ea82 0303 	eor.w	r3, r2, r3
 8015d06:	ea4f 2205 	mov.w	r2, r5, lsl #8
 8015d0a:	bf08      	it	eq
 8015d0c:	4293      	cmpeq	r3, r2
 8015d0e:	d100      	bne.n	8015d12 <strcmp+0x1d2>
 8015d10:	e7e4      	b.n	8015cdc <strcmp+0x19c>
 8015d12:	ba19      	rev	r1, r3
 8015d14:	ba12      	rev	r2, r2
 8015d16:	e00a      	b.n	8015d2e <strcmp+0x1ee>
 8015d18:	ba19      	rev	r1, r3
 8015d1a:	ba22      	rev	r2, r4
 8015d1c:	e007      	b.n	8015d2e <strcmp+0x1ee>
 8015d1e:	ba11      	rev	r1, r2
 8015d20:	ba2a      	rev	r2, r5
 8015d22:	e004      	b.n	8015d2e <strcmp+0x1ee>
 8015d24:	ba19      	rev	r1, r3
 8015d26:	ba2a      	rev	r2, r5
 8015d28:	e001      	b.n	8015d2e <strcmp+0x1ee>
 8015d2a:	ba11      	rev	r1, r2
 8015d2c:	ba22      	rev	r2, r4
 8015d2e:	fa9c f08c 	rev.w	r0, ip
 8015d32:	e9dd 6700 	ldrd	r6, r7, [sp]
 8015d36:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
 8015d3a:	f11d 0d10 	adds.w	sp, sp, #16
 8015d3e:	b138      	cbz	r0, 8015d50 <strcmp+0x210>
 8015d40:	fab0 f080 	clz	r0, r0
 8015d44:	f1c0 0018 	rsb	r0, r0, #24
 8015d48:	fa21 f100 	lsr.w	r1, r1, r0
 8015d4c:	fa22 f200 	lsr.w	r2, r2, r0
 8015d50:	2001      	movs	r0, #1
 8015d52:	4291      	cmp	r1, r2
 8015d54:	bf98      	it	ls
 8015d56:	4180      	sbcls	r0, r0
 8015d58:	4770      	bx	lr
 8015d5a:	bf00      	nop
 8015d5c:	0000      	movs	r0, r0
	...

08015d60 <memset>:
 8015d60:	b4f0      	push	{r4, r5, r6, r7}
 8015d62:	0784      	lsls	r4, r0, #30
 8015d64:	d043      	beq.n	8015dee <memset+0x8e>
 8015d66:	1e54      	subs	r4, r2, #1
 8015d68:	2a00      	cmp	r2, #0
 8015d6a:	d03e      	beq.n	8015dea <memset+0x8a>
 8015d6c:	b2cd      	uxtb	r5, r1
 8015d6e:	4603      	mov	r3, r0
 8015d70:	e003      	b.n	8015d7a <memset+0x1a>
 8015d72:	1e62      	subs	r2, r4, #1
 8015d74:	2c00      	cmp	r4, #0
 8015d76:	d038      	beq.n	8015dea <memset+0x8a>
 8015d78:	4614      	mov	r4, r2
 8015d7a:	f803 5b01 	strb.w	r5, [r3], #1
 8015d7e:	079a      	lsls	r2, r3, #30
 8015d80:	d1f7      	bne.n	8015d72 <memset+0x12>
 8015d82:	2c03      	cmp	r4, #3
 8015d84:	d92a      	bls.n	8015ddc <memset+0x7c>
 8015d86:	b2cd      	uxtb	r5, r1
 8015d88:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 8015d8c:	2c0f      	cmp	r4, #15
 8015d8e:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8015d92:	d915      	bls.n	8015dc0 <memset+0x60>
 8015d94:	f1a4 0710 	sub.w	r7, r4, #16
 8015d98:	093f      	lsrs	r7, r7, #4
 8015d9a:	f103 0610 	add.w	r6, r3, #16
 8015d9e:	eb06 1607 	add.w	r6, r6, r7, lsl #4
 8015da2:	461a      	mov	r2, r3
 8015da4:	6015      	str	r5, [r2, #0]
 8015da6:	6055      	str	r5, [r2, #4]
 8015da8:	6095      	str	r5, [r2, #8]
 8015daa:	60d5      	str	r5, [r2, #12]
 8015dac:	3210      	adds	r2, #16
 8015dae:	42b2      	cmp	r2, r6
 8015db0:	d1f8      	bne.n	8015da4 <memset+0x44>
 8015db2:	f004 040f 	and.w	r4, r4, #15
 8015db6:	3701      	adds	r7, #1
 8015db8:	2c03      	cmp	r4, #3
 8015dba:	eb03 1307 	add.w	r3, r3, r7, lsl #4
 8015dbe:	d90d      	bls.n	8015ddc <memset+0x7c>
 8015dc0:	461e      	mov	r6, r3
 8015dc2:	4622      	mov	r2, r4
 8015dc4:	3a04      	subs	r2, #4
 8015dc6:	2a03      	cmp	r2, #3
 8015dc8:	f846 5b04 	str.w	r5, [r6], #4
 8015dcc:	d8fa      	bhi.n	8015dc4 <memset+0x64>
 8015dce:	1f22      	subs	r2, r4, #4
 8015dd0:	f022 0203 	bic.w	r2, r2, #3
 8015dd4:	3204      	adds	r2, #4
 8015dd6:	4413      	add	r3, r2
 8015dd8:	f004 0403 	and.w	r4, r4, #3
 8015ddc:	b12c      	cbz	r4, 8015dea <memset+0x8a>
 8015dde:	b2c9      	uxtb	r1, r1
 8015de0:	441c      	add	r4, r3
 8015de2:	f803 1b01 	strb.w	r1, [r3], #1
 8015de6:	42a3      	cmp	r3, r4
 8015de8:	d1fb      	bne.n	8015de2 <memset+0x82>
 8015dea:	bcf0      	pop	{r4, r5, r6, r7}
 8015dec:	4770      	bx	lr
 8015dee:	4614      	mov	r4, r2
 8015df0:	4603      	mov	r3, r0
 8015df2:	e7c6      	b.n	8015d82 <memset+0x22>
	...

08015e00 <strpbrk>:
 8015e00:	b4f0      	push	{r4, r5, r6, r7}
 8015e02:	7804      	ldrb	r4, [r0, #0]
 8015e04:	b30c      	cbz	r4, 8015e4a <strpbrk+0x4a>
 8015e06:	780e      	ldrb	r6, [r1, #0]
 8015e08:	4607      	mov	r7, r0
 8015e0a:	b1c6      	cbz	r6, 8015e3e <strpbrk+0x3e>
 8015e0c:	42a6      	cmp	r6, r4
 8015e0e:	d010      	beq.n	8015e32 <strpbrk+0x32>
 8015e10:	1c4b      	adds	r3, r1, #1
 8015e12:	e001      	b.n	8015e18 <strpbrk+0x18>
 8015e14:	4294      	cmp	r4, r2
 8015e16:	d00b      	beq.n	8015e30 <strpbrk+0x30>
 8015e18:	461d      	mov	r5, r3
 8015e1a:	f813 2b01 	ldrb.w	r2, [r3], #1
 8015e1e:	2a00      	cmp	r2, #0
 8015e20:	d1f8      	bne.n	8015e14 <strpbrk+0x14>
 8015e22:	7844      	ldrb	r4, [r0, #1]
 8015e24:	3001      	adds	r0, #1
 8015e26:	2c00      	cmp	r4, #0
 8015e28:	d1ee      	bne.n	8015e08 <strpbrk+0x8>
 8015e2a:	782e      	ldrb	r6, [r5, #0]
 8015e2c:	4607      	mov	r7, r0
 8015e2e:	e000      	b.n	8015e32 <strpbrk+0x32>
 8015e30:	4626      	mov	r6, r4
 8015e32:	2e00      	cmp	r6, #0
 8015e34:	bf14      	ite	ne
 8015e36:	4638      	movne	r0, r7
 8015e38:	2000      	moveq	r0, #0
 8015e3a:	bcf0      	pop	{r4, r5, r6, r7}
 8015e3c:	4770      	bx	lr
 8015e3e:	7844      	ldrb	r4, [r0, #1]
 8015e40:	460d      	mov	r5, r1
 8015e42:	3001      	adds	r0, #1
 8015e44:	2c00      	cmp	r4, #0
 8015e46:	d1df      	bne.n	8015e08 <strpbrk+0x8>
 8015e48:	e7ef      	b.n	8015e2a <strpbrk+0x2a>
 8015e4a:	4620      	mov	r0, r4
 8015e4c:	bcf0      	pop	{r4, r5, r6, r7}
 8015e4e:	4770      	bx	lr

08015e50 <strspn>:
 8015e50:	b4f0      	push	{r4, r5, r6, r7}
 8015e52:	7804      	ldrb	r4, [r0, #0]
 8015e54:	b1cc      	cbz	r4, 8015e8a <strspn+0x3a>
 8015e56:	780e      	ldrb	r6, [r1, #0]
 8015e58:	4607      	mov	r7, r0
 8015e5a:	b19e      	cbz	r6, 8015e84 <strspn+0x34>
 8015e5c:	4605      	mov	r5, r0
 8015e5e:	42b4      	cmp	r4, r6
 8015e60:	d00a      	beq.n	8015e78 <strspn+0x28>
 8015e62:	460a      	mov	r2, r1
 8015e64:	e001      	b.n	8015e6a <strspn+0x1a>
 8015e66:	429c      	cmp	r4, r3
 8015e68:	d006      	beq.n	8015e78 <strspn+0x28>
 8015e6a:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8015e6e:	2b00      	cmp	r3, #0
 8015e70:	d1f9      	bne.n	8015e66 <strspn+0x16>
 8015e72:	1a28      	subs	r0, r5, r0
 8015e74:	bcf0      	pop	{r4, r5, r6, r7}
 8015e76:	4770      	bx	lr
 8015e78:	786c      	ldrb	r4, [r5, #1]
 8015e7a:	1c7d      	adds	r5, r7, #1
 8015e7c:	2c00      	cmp	r4, #0
 8015e7e:	d0f8      	beq.n	8015e72 <strspn+0x22>
 8015e80:	462f      	mov	r7, r5
 8015e82:	e7ec      	b.n	8015e5e <strspn+0xe>
 8015e84:	4630      	mov	r0, r6
 8015e86:	bcf0      	pop	{r4, r5, r6, r7}
 8015e88:	4770      	bx	lr
 8015e8a:	4620      	mov	r0, r4
 8015e8c:	e7f2      	b.n	8015e74 <strspn+0x24>
 8015e8e:	bf00      	nop

08015e90 <ram_areas>:
 8015e90:	72e8 0801 18a4 2000 18a4 2000 18a4 2000     .r..... ... ... 
 8015ea0:	72e8 0801 0000 0000 0000 0000 0000 0000     .r..............
 8015eb0:	72e8 0801 0000 0000 0000 0000 0000 0000     .r..............
 8015ec0:	72e8 0801 0000 0000 0000 0000 0000 0000     .r..............
 8015ed0:	72e8 0801 0000 1000 0000 1000 0000 1000     .r..............
 8015ee0:	72e8 0801 0000 0000 0000 0000 0000 0000     .r..............
 8015ef0:	72e8 0801 0000 0000 0000 0000 0000 0000     .r..............
 8015f00:	72e8 0801 0000 0000 0000 0000 0000 0000     .r..............
 8015f10:	6469 656c 0000 0000 0000 0000 0000 0000     idle............

08015f20 <ch_debug>:
 8015f20:	616d 6e69 1600 1845 0404 0844 100c 1814     main..E...D.....
 8015f30:	1c00 1e1d 001f 0000 0000 0000 0000 0000     ................

08015f40 <sdc_vmt>:
 8015f40:	af61 0800 af71 0800 5751 0800 5911 0800     a...q...QW...Y..
 8015f50:	5971 0800 59d1 0800 5a61 0800 5aa1 0800     qY...Y..aZ...Z..

08015f60 <vmt>:
 8015f60:	5c91 0800 5cc1 0800 5cf1 0800 5d21 0800     .\...\...\..!]..
 8015f70:	5d41 0800 5d71 0800 5d91 0800 5dc1 0800     A]..q]...]...]..

08015f80 <zero_status>:
 8015f80:	0000 0000                                   ....

08015f84 <active_status>:
 8015f84:	0000 0000                                   ....

08015f88 <halted_status>:
 8015f88:	0001 0000 0000 0000                         ........

08015f90 <_stm32_dma_streams>:
 8015f90:	0000 4002 0008 4002 0001 0000 00a8 4002     ...@...@.......@
 8015fa0:	0000 000b 0000 4002 001c 4002 0002 0000     .......@...@....
 8015fb0:	00a8 4002 0104 000c 0000 4002 0030 4002     ...@.......@0..@
 8015fc0:	0004 0000 00a8 4002 0208 000d 0000 4002     .......@.......@
 8015fd0:	0044 4002 0008 0000 00a8 4002 030c 000e     D..@.......@....
 8015fe0:	0000 4002 0058 4002 0010 0000 00a8 4002     ...@X..@.......@
 8015ff0:	0410 000f 0000 4002 006c 4002 0020 0000     .......@l..@ ...
 8016000:	00a8 4002 0514 0010 0000 4002 0080 4002     ...@.......@...@
 8016010:	0040 0000 00a8 4002 0618 0011 0400 4002     @......@.......@
 8016020:	0408 4002 0080 0000 04a8 4002 0700 0038     ...@.......@..8.
 8016030:	0400 4002 041c 4002 0100 0000 04a8 4002     ...@...@.......@
 8016040:	0804 0039 0400 4002 0430 4002 0200 0000     ..9....@0..@....
 8016050:	04a8 4002 0908 003a 0400 4002 0444 4002     ...@..:....@D..@
 8016060:	0400 0000 04a8 4002 0a0c 003b 0400 4002     .......@..;....@
 8016070:	0458 4002 0800 0000 04a8 4002 0b10 003c     X..@.......@..<.
 8016080:	0400 4002 046c 4002 1000 0000 04a8 4002     ...@l..@.......@
 8016090:	0c14 0044 0400 4002 0480 4002 2000 0000     ..D....@...@. ..
 80160a0:	04a8 4002 0d18 0045 0000 0000 0000 0000     ...@..E.........

080160b0 <ep0config>:
 80160b0:	0000 0000 6c61 0800 6dc1 0800 6ec1 0800     ....al...m...n..
 80160c0:	0040 0040 092c 2000 092c 2000 0001 0000     @.@.,.. ,.. ....
 80160d0:	093c 2000                                   <.. 

080160d4 <fsparams>:
 80160d4:	0080 0000 0140 0000 0003 0000 7375 5f62     ....@.......usb_
 80160e4:	6c6c 5f64 7570 706d 0000 0000               lld_pump....

080160f0 <sdc_default_cfg>:
 80160f0:	0000 0000 0001 0000 0000 0000 0000 0000     ................

08016100 <dummytx>:
 8016100:	ffff 0000 4d44 2041 6166 6c69 7275 0065     ....DMA failure.

08016110 <default_config>:
 8016110:	9600 0000 0000 0000 4000 0000 0000 0000     .........@......

08016120 <pal_default_config>:
 8016120:	ab73 ebff 0000 0000 fcc0 c3f0 0008 2800     s..............(
 8016130:	ffff 0000 0000 5550 00b0 0000 0000 0000     ......PU........
 8016140:	0000 0000 afd4 b9fc 0000 0000 3c3f cf0f     ............?<..
 8016150:	0002 000a ffff 0000 0000 0600 0000 505b     ..............[P
	...
 8016168:	f1ec 0eff 0000 0000 cf3c 0fc3 0822 0000     ........<..."...
 8016178:	fdff 0000 0600 0000 0000 0008 0000 0000     ................
 8016188:	0000 0000 ffef ffff 0000 0000 ffff ffff     ................
 8016198:	0000 0000 fffe 0000 0800 0000 0000 0000     ................
	...
 80161b0:	ffff ffff 0000 0000 ffff ffff 0009 5550     ..............PU
 80161c0:	feff 0000 0d00 6ddd aa60 aaaa 0000 0000     .......m`.......
 80161d0:	0000 0000 ffff ffff 0000 0000 ffff ffff     ................
 80161e0:	0000 0000 ffff 0000 0000 0000 0000 0000     ................
	...
 80161f8:	ffff fdff 0000 0000 0000 0000 0000 0000     ................
 8016208:	ffff 0000 0000 0000 0000 0000 0000 0000     ................
 8016218:	0000 0000 fffd ffff 0000 0000 0003 0000     ................
 8016228:	0000 0000 ffff 0000 0000 0000 0000 0000     ................
	...

08016240 <wa>:
 8016240:	1238 2000 1380 2000 14c8 2000 1610 2000     8.. ... ... ... 
 8016250:	1758 2000 0a0d 0000 0000 0000 2a2a 202a     X.. ........*** 
 8016260:	6843 6269 4f69 2f53 5452 7420 7365 2074     ChibiOS/RT test 
 8016270:	7573 7469 0065 0000 2a2a 002a 2a2a 202a     suite...***.*** 
 8016280:	654b 6e72 6c65 203a 2020 2020 2020 0000     Kernel:       ..
 8016290:	2e33 2e31 0035 0000 2a2a 202a 6f43 706d     3.1.5...*** Comp
 80162a0:	6c69 6465 203a 2020 2020 0000 614d 2072     iled:     ..Mar 
 80162b0:	3320 3220 3130 2037 202d 3231 333a 3a36      3 2017 - 12:36:
 80162c0:	3435 0000 2a2a 202a 6f43 706d 6c69 7265     54..*** Compiler
 80162d0:	203a 2020 2020 0000 4347 2043 2e34 2e38     :     ..GCC 4.8.
 80162e0:	2034 3032 3431 3530 3632 2820 6572 656c     4 20140526 (rele
 80162f0:	7361 2965 5b20 5241 2f4d 6d65 6562 6464     ase) [ARM/embedd
 8016300:	6465 342d 385f 622d 6172 636e 2068 6572     ed-4_8-branch re
 8016310:	6976 6973 6e6f 3220 3131 3533 5d38 0000     vision 211358]..
 8016320:	2a2a 202a 7241 6863 7469 6365 7574 6572     *** Architecture
 8016330:	203a 0000 5241 764d 4537 4d2d 0000 0000     : ..ARMv7E-M....
 8016340:	2a2a 202a 6f43 6572 5620 7261 6169 746e     *** Core Variant
 8016350:	203a 0000 6f43 7472 7865 4d2d 0034 0000     : ..Cortex-M4...
 8016360:	2a2a 202a 6f50 7472 4920 666e 3a6f 2020     *** Port Info:  
 8016370:	2020 0000 6441 6176 636e 6465 6b20 7265       ..Advanced ker
 8016380:	656e 206c 6f6d 6564 0000 0000 2a2a 202a     nel mode....*** 
 8016390:	6c50 7461 6f66 6d72 203a 2020 2020 0000     Platform:     ..
 80163a0:	5453 334d 4c32 7834 2078 6c55 7274 2061     STM32L4xx Ultra 
 80163b0:	6f4c 2077 6f50 6577 0072 0000 2a2a 202a     Low Power...*** 
 80163c0:	6554 7473 4220 616f 6472 203a 2020 0000     Test Board:   ..
 80163d0:	5453 5320 6e65 6f73 7472 6c69 2065 0000     ST Sensortile ..
 80163e0:	2d2d 202d 6554 7473 4320 7361 2065 0000     --- Test Case ..
 80163f0:	002e 0000 2820 0000 0029 0000 2d2d 202d     .... (..)...--- 
 8016400:	6552 7573 746c 203a 4146 4c49 5255 2045     Result: FAILURE 
 8016410:	2328 0000 5b20 0000 295d 0000 2d2d 202d     (#.. [..])..--- 
 8016420:	6552 7573 746c 203a 5553 4343 5345 0053     Result: SUCCESS.
 8016430:	6946 616e 206c 6572 7573 746c 203a 0000     Final result: ..
 8016440:	4146 4c49 5255 0045 5553 4343 5345 0053     FAILURE.SUCCESS.
 8016450:	0045 0000 0044 0000 0043 0000 0042 0000     E...D...C...B...
 8016460:	0041 0000 4241 4443 0045 0000 6854 6572     A...ABCDE...Thre
 8016470:	6461 2c73 6520 716e 6575 6975 676e 7420     ads, enqueuing t
 8016480:	7365 2074 3123 0000                         est #1..

08016488 <testthd1>:
 8016488:	646c 0801 0000 0000 0000 0000 b801 0800     ld..............
 8016498:	6854 6572 6461 2c73 6520 716e 6575 6975     Threads, enqueui
 80164a8:	676e 7420 7365 2074 3223 0000               ng test #2..

080164b4 <testthd2>:
 80164b4:	6498 0801 0000 0000 0000 0000 b901 0800     .d..............
 80164c4:	6854 6572 6461 2c73 7020 6972 726f 7469     Threads, priorit
 80164d4:	2079 6863 6e61 6567 0000 0000               y change....

080164e0 <testthd3>:
 80164e0:	64c4 0801 0000 0000 0000 0000 ba11 0800     .d..............
 80164f0:	6854 6572 6461 2c73 6420 6c65 7961 0073     Threads, delays.

08016500 <testthd4>:
 8016500:	64f0 0801 0000 0000 0000 0000 bc01 0800     .d..............

08016510 <patternthd>:
 8016510:	6488 0801 64b4 0801 64e0 0801 6500 0801     .d...d...d...e..
	...
 8016530:	0041 0000 0042 0000 0043 0000 0044 0000     A...B...C...D...
 8016540:	0045 0000 4241 4443 0045 0000 6553 616d     E...ABCDE...Sema
 8016550:	6870 726f 7365 202c 6e65 7571 7565 6e69     phores, enqueuin
 8016560:	0067 0000                                   g...

08016564 <testsem1>:
 8016564:	654c 0801 be51 0800 0000 0000 be81 0800     Le..Q...........
 8016574:	6553 616d 6870 726f 7365 202c 6974 656d     Semaphores, time
 8016584:	756f 0074                                   out.

08016588 <testsem2>:
 8016588:	6574 0801 c001 0800 0000 0000 c041 0800     te..........A...
 8016598:	6553 616d 6870 726f 7365 202c 7461 6d6f     Semaphores, atom
 80165a8:	6369 7320 6769 616e 2d6c 6177 7469 0000     ic signal-wait..

080165b8 <testsem3>:
 80165b8:	6598 0801 c201 0800 0000 0000 c231 0800     .e..........1...
 80165c8:	6942 616e 7972 5320 6d65 7061 6f68 6572     Binary Semaphore
 80165d8:	2c73 6620 6e75 7463 6f69 616e 696c 7974     s, functionality
 80165e8:	0000 0000                                   ....

080165ec <testsem4>:
 80165ec:	65c8 0801 0000 0000 0000 0000 c311 0800     .e..............

080165fc <patternsem>:
 80165fc:	6564 0801 6588 0801 65b8 0801 65ec 0801     de...e...e...e..
 801660c:	0000 0000 0045 0000 0044 0000 0043 0000     ....E...D...C...
 801661c:	0042 0000 0041 0000 4241 4443 0045 0000     B...A...ABCDE...
 801662c:	754d 6574 6578 2c73 7020 6972 726f 7469     Mutexes, priorit
 801663c:	2079 6e65 7571 7565 6e69 2067 6574 7473     y enqueuing test
 801664c:	0000 0000                                   ....

08016650 <testmtx1>:
 8016650:	662c 0801 c531 0800 0000 0000 c571 0800     ,f..1.......q...
 8016660:	754d 6574 6578 2c73 7020 6972 726f 7469     Mutexes, priorit
 8016670:	2079 6572 7574 6e72 0000 0000               y return....

0801667c <testmtx4>:
 801667c:	6660 0801 c691 0800 0000 0000 c711 0800     `f..............
 801668c:	754d 6574 6578 2c73 7320 6174 7574 0073     Mutexes, status.

0801669c <testmtx5>:
 801669c:	668c 0801 ca11 0800 0000 0000 ca21 0800     .f..........!...
 80166ac:	6f43 646e 6156 2c72 7320 6769 616e 206c     CondVar, signal 
 80166bc:	6574 7473 0000 0000                         test....

080166c4 <testmtx6>:
 80166c4:	66ac 0801 cb31 0800 0000 0000 cb81 0800     .f..1...........
 80166d4:	6f43 646e 6156 2c72 6220 6f72 6461 6163     CondVar, broadca
 80166e4:	7473 7420 7365 0074                         st test.

080166ec <testmtx7>:
 80166ec:	66d4 0801 cca1 0800 0000 0000 ccc1 0800     .f..............
 80166fc:	4241 0043 6f43 646e 6156 2c72 6220 6f6f     ABC.CondVar, boo
 801670c:	7473 7420 7365 0074                         st test.

08016714 <testmtx8>:
 8016714:	6700 0801 cdc1 0800 0000 0000 ce71 0800     .g..........q...

08016724 <patternmtx>:
 8016724:	6650 0801 667c 0801 669c 0801 66c4 0801     Pf..|f...f...f..
 8016734:	66ec 0801 6714 0801 0000 0000 4241 0043     .f...g......ABC.
 8016744:	654d 7373 6761 7365 202c 6f6c 706f 0000     Messages, loop..

08016754 <testmsg1>:
 8016754:	6744 0801 0000 0000 0000 0000 cf91 0800     Dg..............

08016764 <patternmsg>:
 8016764:	6754 0801 0000 0000 0000 0000 4241 4443     Tg..........ABCD
 8016774:	0045 0000 614d 6c69 6f62 6578 2c73 7120     E...Mailboxes, q
 8016784:	6575 6975 676e 6120 646e 7420 6d69 6f65     ueuing and timeo
 8016794:	7475 0073                                   uts.

08016798 <testmbox1>:
 8016798:	6778 0801 d0d1 0800 0000 0000 d0f1 0800     xg..............

080167a8 <patternmbox>:
 80167a8:	6798 0801 0000 0000                         .g......

080167b0 <evhndl>:
 80167b0:	da21 0800 da41 0800 da61 0800 4241 0043     !...A...a...ABC.
 80167c0:	7645 6e65 7374 202c 6572 6967 7473 6172     Events, registra
 80167d0:	6974 6e6f 6120 646e 6420 7369 6170 6374     tion and dispatc
 80167e0:	0068 0000                                   h...

080167e4 <testevt1>:
 80167e4:	67c0 0801 da11 0800 0000 0000 da81 0800     .g..............
 80167f4:	0041 0000 7645 6e65 7374 202c 6177 7469     A...Events, wait
 8016804:	6120 646e 6220 6f72 6461 6163 7473 0000      and broadcast..

08016814 <testevt2>:
 8016814:	67f8 0801 db41 0800 0000 0000 dba1 0800     .g..A...........
 8016824:	7645 6e65 7374 202c 6974 656d 756f 7374     Events, timeouts
 8016834:	0000 0000                                   ....

08016838 <testevt3>:
 8016838:	6824 0801 df01 0800 0000 0000 df11 0800     $h..............

08016848 <patternevt>:
 8016848:	67e4 0801 6814 0801 6838 0801 0000 0000     .g...h..8h......
	...
 8016860:	6548 7061 202c 6c61 6f6c 6163 6974 6e6f     Heap, allocation
 8016870:	6120 646e 6620 6172 6d67 6e65 6174 6974      and fragmentati
 8016880:	6e6f 7420 7365 0074                         on test.

08016888 <testheap1>:
 8016888:	6860 0801 e011 0800 0000 0000 e031 0800     `h..........1...

08016898 <patternheap>:
 8016898:	6888 0801 0000 0000 654d 6f6d 7972 5020     .h......Memory P
 80168a8:	6f6f 736c 202c 7571 7565 2f65 6564 7571     ools, queue/dequ
 80168b8:	7565 0065                                   eue.

080168bc <testpools1>:
 80168bc:	68a0 0801 e321 0800 0000 0000 e341 0800     .h..!.......A...

080168cc <patternpools>:
 80168cc:	68bc 0801 0000 0000 0000 0000 0000 0000     .h..............
 80168dc:	0000 0000 0041 0000 0042 0000 0043 0000     ....A...B...C...
 80168ec:	4241 0000 7944 616e 696d 2063 5041 7349     AB..Dynamic APIs
 80168fc:	202c 6874 6572 6461 2073 7263 6165 6974     , threads creati
 801690c:	6e6f 6620 6f72 206d 6568 7061 0000 0000     on from heap....

0801691c <testdyn1>:
 801691c:	68f0 0801 e4a1 0800 0000 0000 e4c1 0800     .h..............
 801692c:	0044 0000 0045 0000 4241 4443 0000 0000     D...E...ABCD....
 801693c:	7944 616e 696d 2063 5041 7349 202c 6874     Dynamic APIs, th
 801694c:	6572 6461 2073 7263 6165 6974 6e6f 6620     reads creation f
 801695c:	6f72 206d 656d 6f6d 7972 7020 6f6f 006c     rom memory pool.

0801696c <testdyn2>:
 801696c:	693c 0801 e611 0800 0000 0000 e631 0800     <i..........1...
 801697c:	7944 616e 696d 2063 5041 7349 202c 6572     Dynamic APIs, re
 801698c:	6967 7473 7972 6120 646e 7220 6665 7265     gistry and refer
 801699c:	6e65 6563 0073 0000                         ences...

080169a4 <testdyn3>:
 80169a4:	697c 0801 e801 0800 0000 0000 e821 0800     |i..........!...

080169b4 <patterndyn>:
 80169b4:	691c 0801 696c 0801 69a4 0801 0000 0000     .i..li...i......
	...
 80169d0:	4241 4443 0000 0000 7551 7565 7365 202c     ABCD....Queues, 
 80169e0:	6e69 7570 2074 7571 7565 7365 0000 0000     input queues....

080169f0 <testqueues1>:
 80169f0:	69d8 0801 eb61 0800 0000 0000 ebb1 0800     .i..a...........
 8016a00:	7551 7565 7365 202c 756f 7074 7475 7120     Queues, output q
 8016a10:	6575 6575 0073 0000                         ueues...

08016a18 <testqueues2>:
 8016a18:	6a00 0801 eec1 0800 0000 0000 ef11 0800     .j..............

08016a28 <patternqueues>:
 8016a28:	69f0 0801 6a18 0801 0000 0000 0000 0000     .i...j..........
	...
 8016a40:	7953 7473 6d65 202c 7263 7469 6369 6c61     System, critical
 8016a50:	7a20 6e6f 7365 0000                          zones..

08016a58 <testsys1>:
 8016a58:	6a40 0801 0000 0000 0000 0000 f451 0800     @j..........Q...
 8016a68:	7953 7473 6d65 202c 6e69 6574 7272 7075     System, interrup
 8016a78:	7374 6820 6e61 6c64 6e69 0067               ts handling.

08016a84 <testsys2>:
 8016a84:	6a68 0801 0000 0000 0000 0000 f4e1 0800     hj..............
 8016a94:	7953 7473 6d65 202c 6e69 6574 7267 7469     System, integrit
 8016aa4:	0079 0000                                   y...

08016aa8 <testsys3>:
 8016aa8:	6a94 0801 0000 0000 0000 0000 f501 0800     .j..............

08016ab8 <patternsys>:
 8016ab8:	6a58 0801 6a84 0801 6aa8 0801 0000 0000     Xj...j...j......
	...
 8016ad0:	2d2d 202d 6353 726f 2065 203a 0000 0000     --- Score : ....
 8016ae0:	6d20 6773 2f73 2c53 0020 0000 6320 7874      msgs/S, ... ctx
 8016af0:	7773 2f63 0053 0000 6542 636e 6d68 7261     swc/S...Benchmar
 8016b00:	2c6b 6d20 7365 6173 6567 2073 3123 0000     k, messages #1..

08016b10 <testbmk1>:
 8016b10:	6af8 0801 0000 0000 0000 0000 f761 0800     .j..........a...
 8016b20:	6542 636e 6d68 7261 2c6b 6d20 7365 6173     Benchmark, messa
 8016b30:	6567 2073 3223 0000                         ges #2..

08016b38 <testbmk2>:
 8016b38:	6b20 0801 0000 0000 0000 0000 f7e1 0800      k..............
 8016b48:	6542 636e 6d68 7261 2c6b 6d20 7365 6173     Benchmark, messa
 8016b58:	6567 2073 3323 0000                         ges #3..

08016b60 <testbmk3>:
 8016b60:	6b48 0801 0000 0000 0000 0000 f861 0800     Hk..........a...
 8016b70:	6542 636e 6d68 7261 2c6b 6320 6e6f 6574     Benchmark, conte
 8016b80:	7478 7320 6977 6374 0068 0000               xt switch...

08016b8c <testbmk4>:
 8016b8c:	6b70 0801 0000 0000 0000 0000 f9a1 0800     pk..............
 8016b9c:	7420 7268 6165 7364 532f 0000 6542 636e      threads/S..Benc
 8016bac:	6d68 7261 2c6b 7420 7268 6165 7364 202c     hmark, threads, 
 8016bbc:	7566 6c6c 6320 6379 656c 0000               full cycle..

08016bc8 <testbmk5>:
 8016bc8:	6ba8 0801 0000 0000 0000 0000 fa71 0800     .k..........q...
 8016bd8:	6542 636e 6d68 7261 2c6b 7420 7268 6165     Benchmark, threa
 8016be8:	7364 202c 7263 6165 6574 6f20 6c6e 0079     ds, create only.

08016bf8 <testbmk6>:
 8016bf8:	6bd8 0801 0000 0000 0000 0000 faf1 0800     .k..............
 8016c08:	7220 7365 6863 6465 6c75 7365 532f 202c      reschedules/S, 
 8016c18:	0000 0000 6542 636e 6d68 7261 2c6b 6d20     ....Benchmark, m
 8016c28:	7361 2073 6572 6373 6568 7564 656c 202c     ass reschedule, 
 8016c38:	2035 6874 6572 6461 0073 0000               5 threads...

08016c44 <testbmk7>:
 8016c44:	6c1c 0801 fba1 0800 0000 0000 fbb1 0800     .l..............
 8016c54:	6542 636e 6d68 7261 2c6b 7220 756f 646e     Benchmark, round
 8016c64:	7220 626f 6e69 6320 6e6f 6574 7478 7320      robin context s
 8016c74:	6977 6374 6968 676e 0000 0000               witching....

08016c80 <testbmk8>:
 8016c80:	6c54 0801 0000 0000 0000 0000 fd31 0800     Tl..........1...
 8016c90:	6220 7479 7365 532f 0000 0000 6542 636e      bytes/S....Benc
 8016ca0:	6d68 7261 2c6b 4920 4f2f 5120 6575 6575     hmark, I/O Queue
 8016cb0:	2073 6874 6f72 6775 7068 7475 0000 0000     s throughput....

08016cc0 <testbmk9>:
 8016cc0:	6c9c 0801 0000 0000 0000 0000 fe31 0800     .l..........1...
 8016cd0:	7420 6d69 7265 2f73 0053 0000 6542 636e      timers/S...Benc
 8016ce0:	6d68 7261 2c6b 7620 7269 7574 6c61 7420     hmark, virtual t
 8016cf0:	6d69 7265 2073 6573 2f74 6572 6573 0074     imers set/reset.

08016d00 <testbmk10>:
 8016d00:	6cdc 0801 0000 0000 0000 0000 fef1 0800     .l..............
 8016d10:	7720 6961 2b74 6973 6e67 6c61 532f 0000      wait+signal/S..
 8016d20:	6542 636e 6d68 7261 2c6b 7320 6d65 7061     Benchmark, semap
 8016d30:	6f68 6572 2073 6177 7469 732f 6769 616e     hores wait/signa
 8016d40:	006c 0000                                   l...

08016d44 <testbmk11>:
 8016d44:	6d20 0801 ff81 0800 0000 0000 ff91 0800      m..............
 8016d54:	6c20 636f 2b6b 6e75 6f6c 6b63 532f 0000      lock+unlock/S..
 8016d64:	6542 636e 6d68 7261 2c6b 6d20 7475 7865     Benchmark, mutex
 8016d74:	7365 6c20 636f 2f6b 6e75 6f6c 6b63 0000     es lock/unlock..

08016d84 <testbmk12>:
 8016d84:	6d64 0801 0021 0801 0000 0000 0031 0801     dm..!.......1...
 8016d94:	2d2d 202d 7953 7473 6d65 203a 0000 0000     --- System: ....
 8016da4:	6220 7479 7365 0000 2d2d 202d 6854 6572      bytes..--- Thre
 8016db4:	6461 203a 0000 0000 2d2d 202d 6954 656d     ad: ....--- Time
 8016dc4:	2072 203a 0000 0000 2d2d 202d 6553 616d     r : ....--- Sema
 8016dd4:	6870 203a 0000 0000 2d2d 202d 7645 6e65     ph: ....--- Even
 8016de4:	5374 203a 0000 0000 2d2d 202d 7645 6e65     tS: ....--- Even
 8016df4:	4c74 203a 0000 0000 2d2d 202d 754d 6574     tL: ....--- Mute
 8016e04:	2078 203a 0000 0000 2d2d 202d 6f43 646e     x : ....--- Cond
 8016e14:	2e56 203a 0000 0000 2d2d 202d 7551 7565     V.: ....--- Queu
 8016e24:	2065 203a 0000 0000 2d2d 202d 614d 6c69     e : ....--- Mail
 8016e34:	2e42 203a 0000 0000 6542 636e 6d68 7261     B.: ....Benchmar
 8016e44:	2c6b 5220 4d41 6620 6f6f 7074 6972 746e     k, RAM footprint
 8016e54:	0000 0000                                   ....

08016e58 <testbmk13>:
 8016e58:	6e3c 0801 0000 0000 0000 0000 00c1 0801     <n..............

08016e68 <patternbmk>:
 8016e68:	6b10 0801 6b38 0801 6b60 0801 6b8c 0801     .k..8k..`k...k..
 8016e78:	6bc8 0801 6bf8 0801 6c44 0801 6c80 0801     .k...k..Dl...l..
 8016e88:	6cc0 0801 6d00 0801 6d44 0801 6d84 0801     .l...m..Dm...m..
 8016e98:	6e58 0801 0000 0000                         Xn......

08016ea0 <vmt>:
 8016ea0:	03b1 0801 0411 0801 0471 0801 04c1 0801     ........q.......
 8016eb0:	6e28 6c75 296c 0000 0000 0000 0000 0000     (null)..........
 8016ec0:	7355 6761 3a65 2520 0d73 000a 7325 0020     Usage: %s...%s .
 8016ed0:	6e69 6f66 0000 0000 654b 6e72 6c65 203a     info....Kernel: 
 8016ee0:	2020 2020 2020 7325 0a0d 0000 2e33 2e31           %s....3.1.
 8016ef0:	0035 0000 6f43 706d 6c69 7265 203a 2020     5...Compiler:   
 8016f00:	2020 7325 0a0d 0000 4347 2043 2e34 2e38       %s....GCC 4.8.
 8016f10:	2034 3032 3431 3530 3632 2820 6572 656c     4 20140526 (rele
 8016f20:	7361 2965 5b20 5241 2f4d 6d65 6562 6464     ase) [ARM/embedd
 8016f30:	6465 342d 385f 622d 6172 636e 2068 6572     ed-4_8-branch re
 8016f40:	6976 6973 6e6f 3220 3131 3533 5d38 0000     vision 211358]..
 8016f50:	7241 6863 7469 6365 7574 6572 203a 7325     Architecture: %s
 8016f60:	0a0d 0000 5241 764d 4537 4d2d 0000 0000     ....ARMv7E-M....
 8016f70:	6f43 6572 5620 7261 6169 746e 203a 7325     Core Variant: %s
 8016f80:	0a0d 0000 6f43 7472 7865 4d2d 0034 0000     ....Cortex-M4...
 8016f90:	6f50 7472 4920 666e 3a6f 2020 2020 7325     Port Info:    %s
 8016fa0:	0a0d 0000 6441 6176 636e 6465 6b20 7265     ....Advanced ker
 8016fb0:	656e 206c 6f6d 6564 0000 0000 6c50 7461     nel mode....Plat
 8016fc0:	6f66 6d72 203a 2020 2020 7325 0a0d 0000     form:     %s....
 8016fd0:	5453 334d 4c32 7834 2078 6c55 7274 2061     STM32L4xx Ultra 
 8016fe0:	6f4c 2077 6f50 6577 0072 0000 6f42 7261     Low Power...Boar
 8016ff0:	3a64 2020 2020 2020 2020 7325 0a0d 0000     d:        %s....
 8017000:	5453 5320 6e65 6f73 7472 6c69 2065 0000     ST Sensortile ..
 8017010:	7542 6c69 2064 6974 656d 203a 2020 7325     Build time:   %s
 8017020:	7325 7325 0a0d 0000 614d 2072 3320 3220     %s%s....Mar  3 2
 8017030:	3130 0037 2d20 0020 3231 333a 3a36 3435     017. - .12:36:54
 8017040:	0000 0000 7973 7473 6d69 0065 6c25 0d75     ....systime.%lu.
 8017050:	000a 0000                                   ....

08017054 <local_commands>:
 8017054:	6ed0 0801 0c61 0801 7044 0801 0d31 0801     .n..a...Dp..1...
	...
 801706c:	6873 6c65 006c 0000 0a0d 6843 6269 4f69     shell.....ChibiO
 801707c:	2f53 5452 5320 6568 6c6c 0a0d 0000 0000     S/RT Shell......
 801708c:	6863 203e 0000 0000 0a0d 6f6c 6f67 7475     ch> ......logout
 801709c:	0000 0000 0920 0000 6f74 206f 616d 796e     .... ...too many
 80170ac:	6120 6772 6d75 6e65 7374 0a0d 0000 0000      arguments......
 80170bc:	7865 7469 0000 0000 6568 706c 0000 0000     exit....help....
 80170cc:	6f43 6d6d 6e61 7364 203a 6568 706c 6520     Commands: help e
 80170dc:	6978 2074 0000 0000 0a0d 0000 7325 0000     xit ........%s..
 80170ec:	3f20 0a0d 0000 0000 445e 0000 0000 0000      ?......^D......
 80170fc:	0000 0000 6c62 6e69 656b 0072 7325 0d0a     ....blinker.%s..
 801710c:	0000 0000 736c 336d 3330 5720 6f68 4120     ....lsm303 Who A
 801711c:	206d 2049 6164 6174 3d20 3020 2578 3230     m I data = 0x%02
 801712c:	0a78 000d 796d 6365 6f68 0000 6361 6563     x...myecho..acce
 801713c:	5f6c 6177 0069 0000                         l_wai...

08017144 <commands>:
 8017144:	7130 0801 1161 0801 7138 0801 11a1 0801     0q..a...8q......
	...

0801715c <shell_cfg1>:
 801715c:	11a4 2000 7144 0801 0d0a 7055 6120 646e     ... Dq....Up and
 801716c:	5220 6e75 696e 676e 0d0a 0000 0000 0000      Running........
 801717c:	0000 0000                                   ....

08017180 <LSM303AGR_ACC_Sensitivity_List>:
 8017180:	03d4 0000 0000 0000 079e 0000 0000 0000     ................
 8017190:	0f3c 0000 0000 0000 2dc8 0000 0000 0000     <........-......
 80171a0:	0f3c 0000 0000 0000 1e8c 0000 0000 0000     <...............
 80171b0:	3d0e 0000 0000 0000 b734 0000 0000 0000     .=......4.......
 80171c0:	3d0e 0000 0000 0000 7a1c 0000 0000 0000     .=.......z......
 80171d0:	f438 0000 0000 0000 dcbc 0002 0000 0000     8...............
